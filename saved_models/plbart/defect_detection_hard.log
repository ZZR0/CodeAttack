textattack: Running 8 worker(s) on 8 GPU(s).
/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/functional.py:1709: UserWarning: nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.
  warnings.warn("nn.functional.sigmoid is deprecated. Use torch.sigmoid instead.")
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/2690 [00:00<00:02, 1168.98it/s]--------------------------------------------- Result 1 ---------------------------------------------
[[0 (43%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 1 / 1 / 2:   0%|          | 2/2690 [00:00<00:01, 1715.11it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 2 / 3:   0%|          | 3/2690 [00:00<00:01, 2170.59it/s][[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < xen_9pdev->num_rings; i++) { char *str; int ring_order; xen_9pdev->rings[i].priv = xen_9pdev; xen_9pdev->rings[i].evtchn = -1; xen_9pdev->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) { goto out; } xen_9pdev->rings[i].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].intf) { goto out; } ring_order = xen_9pdev->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[i].ring_order = ring_order; xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].data) { goto out; } xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data; xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]); xen_9pdev->rings[i].out_cons = 0; xen_9pdev->rings[i].out_size = 0; xen_9pdev->rings[i].inprogress = "False" != "False"; xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn); if (xen_9pdev->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]); } xen_9pdev->security_model = xenstore_read_be_str(xendev, "security_model"); xen_9pdev->path = xenstore_read_be_str(xendev, "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 1 / 3 / 4:   0%|          | 4/2690 [00:00<00:01, 2485.88it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 4 / 5:   0%|          | 5/2690 [00:00<00:00, 2760.14it/s][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; const char *boot_device = args->boot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = "False" != "False"; char *filename; msi_supported = "True" == "True"; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { spapr->rma_size = rma_alloc_size; } else { spapr->rma_size = ram_size; if (kvm_enabled()) { spapr->vrma_adjust = 1; spapr->rma_size = MIN(spapr->rma_size, 0x10000000); } } rtas_limit = MIN(spapr->rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; spapr->htab_shift = 18; while (spapr->htab_shift <= 46) { if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) { break; } spapr->htab_shift++; } spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr->next_irq = XICS_IRQ_BASE; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; xics_cpu_setup(spapr->icp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env->msr_mask &= ~(1 << 6); if (kvm_enabled()) { kvmppc_set_papr(cpu); } qemu_register_reset(spapr_cpu_reset, cpu); } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr_events_init(spapr); spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (spapr_vga_init(phb->bus)) { spapr->has_graphics = "True" == "True"; } if (usb_enabled(spapr->has_graphics)) { pci_create_simple(phb->bus, -1, "pci-ohci"); if (spapr->has_graphics) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } } if (spapr->rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size > 0; } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } if (bios_name == NULL) { bios_name = FW_FILE_NAME; } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); spapr->entry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr->epow_irq); assert(spapr->fdt_skel != NULL); }
--------------------------------------------- Result 5 ---------------------------------------------
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *s1 = avctx->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int width, height, i, v, j; float aspect; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); s->aspect_ratio_info= get_bits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1_aspect[s->aspect_ratio_info]; if(aspect!=0.0) avctx->aspect_ratio= width/(aspect*height); } s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; avctx->has_b_frames= 1; s->avctx = avctx; avctx->width = width; avctx->height = height; if (s->frame_rate_index >= 9) { avctx->frame_rate = 25 * FRAME_RATE_BASE; } else { avctx->frame_rate = frame_rate_tab[s->frame_rate_index]; } s->frame_rate = avctx->frame_rate; avctx->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->inter_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; avctx->sub_id = 1; return 0; }
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 1 / 4 / 6:   0%|          | 6/2690 [00:00<00:00, 2752.47it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 5 / 7:   0%|          | 7/2690 [00:00<00:00, 2948.40it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 6 / 8:   0%|          | 8/2690 [00:00<00:00, 3094.29it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 7 / 9:   0%|          | 9/2690 [00:00<00:00, 3243.58it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 8 / 10:   0%|          | 10/2690 [00:00<00:00, 3354.64it/s][Succeeded / Failed / Skipped / Total] 1 / 1 / 8 / 10:   0%|          | 11/2690 [00:00<00:51, 52.09it/s]  [[0 (4%)]] --> [[0 (53%)]] --> Socre: 0.5264285802841187

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[drc]]) { [[drc]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[drc]]->awaiting_release) { uint32_t [[drc_index]] = spapr_drc_index([[drc]]); trace_spapr_drc_set_allocation_state_finalizing([[drc_index]]); spapr_drc_detach([[drc]]); } return RTAS_OUT_SUCCESS; }

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *[[unlocks]]) { [[unlocks]]->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if ([[unlocks]]->awaiting_release) { uint32_t [[scow]] = spapr_drc_index([[unlocks]]); trace_spapr_drc_set_allocation_state_finalizing([[scow]]); spapr_drc_detach([[unlocks]]); } return RTAS_OUT_SUCCESS; }
--------------------------------------------- Result 7 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *r) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; if (r->sector_count == (uint32_t)-1) { DPRINTF("Read buf_len=%zd\n", r->iov.iov_len); r->sector_count = 0; scsi_req_data(&r->req, r->iov.iov_len); return; } DPRINTF("Read sector_count=%d\n", r->sector_count); if (r->sector_count == 0) { scsi_command_complete(r, GOOD, NO_SENSE); return; } assert(r->req.aiocb == NULL); n = r->sector_count; if (n > SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; r->iov.iov_len = n * 512; qemu_iovec_init_external(&r->qiov, &r->iov, 1); r->req.aiocb = bdrv_aio_readv(s->bs, r->sector, &r->qiov, n, scsi_read_complete, r); if (r->req.aiocb == NULL) { scsi_read_complete(r, -EIO); } }
--------------------------------------------- Result 8 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irq[32]; ResetInfo *reset_info; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr uart0_base = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) { fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); } env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } lm32_uart_create(uart0_base, irq[uart0_irq], serial_hds[0]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(serial_hds[1]); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }
--------------------------------------------- Result 9 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int linesize, DCTELEM *block) { int i; int dc = block[0]; const uint8_t *cm; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; cm = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = cm[dest[0]]; dest[1] = cm[dest[1]]; dest[2] = cm[dest[2]]; dest[3] = cm[dest[3]]; dest[4] = cm[dest[4]]; dest[5] = cm[dest[5]]; dest[6] = cm[dest[6]]; dest[7] = cm[dest[7]]; dest += linesize; } }
--------------------------------------------- Result 10 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *bs, const char *desc_file_path) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { return -EINVAL; } } else if (ret != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags, &local_err); if (ret) { qerror_report_err(local_err); error_free(local_err); return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags); if (ret) { bdrv_unref(extent_file); return ret; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }
--------------------------------------------- Result 11 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 1 / 8 / 11:   0%|          | 11/2690 [00:00<00:51, 51.93it/s][Succeeded / Failed / Skipped / Total] 3 / 1 / 8 / 12:   0%|          | 12/2690 [00:00<00:47, 56.51it/s][Succeeded / Failed / Skipped / Total] 4 / 1 / 8 / 13:   0%|          | 13/2690 [00:00<01:14, 36.00it/s][Succeeded / Failed / Skipped / Total] 4 / 1 / 9 / 14:   1%|          | 14/2690 [00:00<02:03, 21.62it/s][[0 (31%)]] --> [[0 (50%)]] --> Socre: 0.5035247802734375

[[[[Adv]]]]: aio_write_f(int argc, char **[[argv]]) { char *[[p]]; int count = 0; int nr_iov, i, c; int [[pattern]] = 0xcd; struct aio_ctx *[[ctx]] = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *[[acb]]; while ((c = getopt(argc, [[argv]], "CqP:")) != EOF) { switch (c) { case 'C': [[ctx]]->Cflag = 1; break; case 'q': [[ctx]]->qflag = 1; break; case 'P': [[pattern]] = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); [[ctx]]->offset = cvtnum([[argv]][optind]); if ([[ctx]]->offset < 0) { printf("non-numeric length argument -- %s\n", [[argv]][optind]); return 0; } optind++; if ([[ctx]]->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)[[ctx]]->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum([[argv]][optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", [[argv]][i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&[[ctx]]->qiov, nr_iov); [[ctx]]->buf = [[p]] = qemu_io_alloc(count, [[pattern]]); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum([[argv]][optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", [[argv]][optind]); return 0; } qemu_iovec_add(&[[ctx]]->qiov, [[p]], len); [[p]] += len; optind++; } gettimeofday(&[[ctx]]->t1, NULL); [[acb]] = bdrv_aio_writev(bs, [[ctx]]->offset >> 9, &[[ctx]]->qiov, [[ctx]]->qiov.size >> 9, aio_write_done, [[ctx]]); if (![[acb]]) return -EIO; return 0; }

[[[[Adv]]]]: aio_write_f(int argc, char **[[napisy]]) { char *[[rs]]; int count = 0; int nr_iov, i, c; int [[modelling]] = 0xcd; struct aio_ctx *[[vio]] = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *[[certitude]]; while ((c = getopt(argc, [[napisy]], "CqP:")) != EOF) { switch (c) { case 'C': [[vio]]->Cflag = 1; break; case 'q': [[vio]]->qflag = 1; break; case 'P': [[modelling]] = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); [[vio]]->offset = cvtnum([[napisy]][optind]); if ([[vio]]->offset < 0) { printf("non-numeric length argument -- %s\n", [[napisy]][optind]); return 0; } optind++; if ([[vio]]->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)[[vio]]->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum([[napisy]][optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", [[napisy]][i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&[[vio]]->qiov, nr_iov); [[vio]]->buf = [[rs]] = qemu_io_alloc(count, [[modelling]]); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum([[napisy]][optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", [[napisy]][optind]); return 0; } qemu_iovec_add(&[[vio]]->qiov, [[rs]], len); [[rs]] += len; optind++; } gettimeofday(&[[vio]]->t1, NULL); [[certitude]] = bdrv_aio_writev(bs, [[vio]]->offset >> 9, &[[vio]]->qiov, [[vio]]->qiov.size >> 9, aio_write_done, [[vio]]); if (![[certitude]]) return -EIO; return 0; }
--------------------------------------------- Result 12 ---------------------------------------------
[[0 (62%)]] --> [[0 (48%)]] --> Socre: 0.5212404727935791

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *[[gb]], VLC *[[vlc]]) { uint8_t [[symbols]][256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits([[gb]], 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits([[gb]], 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { [[symbols]][count] = get_bits([[gb]], 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse([[vlc]], VLC_BITS, count, bits, 1, 1, codes, 2, 2, [[symbols]], 1, 1, 0);

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *[[aries]], VLC *[[graboid]]) { uint8_t [[icon]][256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits([[aries]], 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits([[aries]], 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { [[icon]][count] = get_bits([[aries]], 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse([[graboid]], VLC_BITS, count, bits, 1, 1, codes, 2, 2, [[icon]], 1, 1, 0);
--------------------------------------------- Result 13 ---------------------------------------------
[[0 (73%)]] --> [[0 (47%)]] --> Socre: 0.5348874628543854

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *[[avctx]], const AVFrame *[[frame]], opj_image_t *[[image]]) { int compno; int x, y; int *[[image_line]]; int frame_index; const int numcomps = [[image]]->numcomps; uint16_t *frame_ptr = (uint16_t *)[[frame]]->data[0]; for (compno = 0; compno < numcomps; ++compno) { if ([[image]]->comps[compno].w > [[frame]]->linesize[0] / numcomps) { av_log([[avctx]], AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < numcomps; ++compno) { for (y = 0; y < [[avctx]]->height; ++y) { [[image_line]] = [[image]]->comps[compno].data + y * [[image]]->comps[compno].w; frame_index = y * ([[frame]]->linesize[0] / 2) + compno; for (x = 0; x < [[avctx]]->width; ++x) { [[image_line]][x] = frame_ptr[frame_index] >> 4; frame_index += numcomps; } for (; x < [[image]]->comps[compno].w; ++x) { [[image_line]][x] = [[image_line]][x - 1]; } } for (; y < [[image]]->comps[compno].h; ++y) { [[image_line]] = [[image]]->comps[compno].data + y * [[image]]->comps[compno].w; for (x = 0; x < [[image]]->comps[compno].w; ++x) { [[image_line]][x] = [[image_line]][x - [[image]]->comps[compno].w]; } } } return 1; }

[[[[Adv]]]]: static int libopenjpeg_copy_packed12(AVCodecContext *[[ripe]], const AVFrame *[[shaping]], opj_image_t *[[photographer]]) { int compno; int x, y; int *[[lycans]]; int frame_index; const int numcomps = [[photographer]]->numcomps; uint16_t *frame_ptr = (uint16_t *)[[shaping]]->data[0]; for (compno = 0; compno < numcomps; ++compno) { if ([[photographer]]->comps[compno].w > [[shaping]]->linesize[0] / numcomps) { av_log([[ripe]], AV_LOG_ERROR, "Error: frame's linesize is too small for the image\n"); return 0; } } for (compno = 0; compno < numcomps; ++compno) { for (y = 0; y < [[ripe]]->height; ++y) { [[lycans]] = [[photographer]]->comps[compno].data + y * [[photographer]]->comps[compno].w; frame_index = y * ([[shaping]]->linesize[0] / 2) + compno; for (x = 0; x < [[ripe]]->width; ++x) { [[lycans]][x] = frame_ptr[frame_index] >> 4; frame_index += numcomps; } for (; x < [[photographer]]->comps[compno].w; ++x) { [[lycans]][x] = [[lycans]][x - 1]; } } for (; y < [[photographer]]->comps[compno].h; ++y) { [[lycans]] = [[photographer]]->comps[compno].data + y * [[photographer]]->comps[compno].w; for (x = 0; x < [[photographer]]->comps[compno].w; ++x) { [[lycans]][x] = [[lycans]][x - [[photographer]]->comps[compno].w]; } } } return 1; }
--------------------------------------------- Result 14 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_cpu_kick(void *env) { return; }
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 1 / 10 / 15:   1%|          | 15/2690 [00:02<08:34,  5.20it/s][Succeeded / Failed / Skipped / Total] 5 / 1 / 10 / 16:   1%|          | 16/2690 [00:03<09:29,  4.69it/s][Succeeded / Failed / Skipped / Total] 6 / 1 / 10 / 17:   1%|          | 17/2690 [00:03<08:56,  4.99it/s][Succeeded / Failed / Skipped / Total] 6 / 1 / 11 / 18:   1%|          | 18/2690 [00:03<08:26,  5.28it/s][Succeeded / Failed / Skipped / Total] 7 / 1 / 11 / 19:   1%|          | 19/2690 [00:03<07:59,  5.57it/s][Succeeded / Failed / Skipped / Total] 7 / 1 / 12 / 20:   1%|          | 20/2690 [00:03<07:35,  5.86it/s][[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void temp_allocate_frame(TCGContext *s, int temp) { TCGTemp *ts; ts = &s->temps[temp]; s->current_frame_offset = (s->current_frame_offset + sizeof(tcg_target_long) - 1) & ~(sizeof(tcg_target_long) - 1); if (s->current_frame_offset + sizeof(tcg_target_long) > s->frame_end) tcg_abort(); ts->mem_offset = s->current_frame_offset; ts->mem_reg = s->frame_reg; ts->mem_allocated = 1; s->current_frame_offset += sizeof(tcg_target_long); }
--------------------------------------------- Result 16 ---------------------------------------------
[[0 (34%)]] --> [[0 (53%)]] --> Socre: 0.5277205109596252

[[[[Adv]]]]: static target_ulong h_enter(CPUState *[[env]], sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong flags = args[0]; target_ulong pte_index = args[1]; target_ulong pteh = args[2]; target_ulong [[ptel]] = args[3]; target_ulong i; uint8_t *hpte; if (pteh & HPTE_V_LARGE) { #if 0 if (([[ptel]] & 0xf000) == 0x1000) { } else #endif if (([[ptel]] & 0xff000) == 0) { if (pteh & 0x80) { return H_PARAMETER; } } else { return H_PARAMETER; } } if (([[ptel]] & HPTE_R_WIMG) != HPTE_R_M) { return H_PARAMETER; } pteh &= ~0x60ULL; if ((pte_index * HASH_PTE_SIZE_64) & ~[[env]]->htab_mask) { return H_PARAMETER; } if (likely((flags & H_EXACT) == 0)) { pte_index &= ~7ULL; hpte = [[env]]->external_htab + (pte_index * HASH_PTE_SIZE_64); for (i = 0; ; ++i) { if (i == 8) { return H_PTEG_FULL; } if (((ldq_p(hpte) & HPTE_V_VALID) == 0) && lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { break; } hpte += HASH_PTE_SIZE_64; } } else { i = 0; hpte = [[env]]->external_htab + (pte_index * HASH_PTE_SIZE_64); if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { return H_PTEG_FULL; } } stq_p(hpte + (HASH_PTE_SIZE_64/2), [[ptel]]); stq_p(hpte, pteh); assert(!(ldq_p(hpte) & HPTE_V_HVLOCK)); args[0] = pte_index + i; return H_SUCCESS; }

[[[[Adv]]]]: static target_ulong h_enter(CPUState *[[convincing]], sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong flags = args[0]; target_ulong pte_index = args[1]; target_ulong pteh = args[2]; target_ulong [[posada]] = args[3]; target_ulong i; uint8_t *hpte; if (pteh & HPTE_V_LARGE) { #if 0 if (([[posada]] & 0xf000) == 0x1000) { } else #endif if (([[posada]] & 0xff000) == 0) { if (pteh & 0x80) { return H_PARAMETER; } } else { return H_PARAMETER; } } if (([[posada]] & HPTE_R_WIMG) != HPTE_R_M) { return H_PARAMETER; } pteh &= ~0x60ULL; if ((pte_index * HASH_PTE_SIZE_64) & ~[[convincing]]->htab_mask) { return H_PARAMETER; } if (likely((flags & H_EXACT) == 0)) { pte_index &= ~7ULL; hpte = [[convincing]]->external_htab + (pte_index * HASH_PTE_SIZE_64); for (i = 0; ; ++i) { if (i == 8) { return H_PTEG_FULL; } if (((ldq_p(hpte) & HPTE_V_VALID) == 0) && lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { break; } hpte += HASH_PTE_SIZE_64; } } else { i = 0; hpte = [[convincing]]->external_htab + (pte_index * HASH_PTE_SIZE_64); if (!lock_hpte(hpte, HPTE_V_HVLOCK | HPTE_V_VALID)) { return H_PTEG_FULL; } } stq_p(hpte + (HASH_PTE_SIZE_64/2), [[posada]]); stq_p(hpte, pteh); assert(!(ldq_p(hpte) & HPTE_V_HVLOCK)); args[0] = pte_index + i; return H_SUCCESS; }
--------------------------------------------- Result 17 ---------------------------------------------
[[0 (46%)]] --> [[0 (50%)]] --> Socre: 0.5035287737846375

[[[[Adv]]]]: void qmp_block_stream(const char *[[device]], bool has_base, const char *base, Error **errp) { BlockDriverState *[[bs]]; BlockDriverState *base_bs = NULL; Error *local_err = NULL; [[bs]] = bdrv_find([[device]]); if (![[bs]]) { error_set(errp, QERR_DEVICE_NOT_FOUND, [[device]]); return; } if (base) { base_bs = bdrv_find_backing_image([[bs]], base); if (base_bs == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start([[bs]], base_bs, base, block_stream_cb, [[bs]], &local_err); if (error_is_set(&local_err)) { error_propagate(errp, local_err); return; } drive_get_ref(drive_get_by_blockdev([[bs]])); trace_qmp_block_stream([[bs]], [[bs]]->job); }

[[[[Adv]]]]: void qmp_block_stream(const char *[[mechanically]], bool has_base, const char *base, Error **errp) { BlockDriverState *[[colombian]]; BlockDriverState *base_bs = NULL; Error *local_err = NULL; [[colombian]] = bdrv_find([[mechanically]]); if (![[colombian]]) { error_set(errp, QERR_DEVICE_NOT_FOUND, [[mechanically]]); return; } if (base) { base_bs = bdrv_find_backing_image([[colombian]], base); if (base_bs == NULL) { error_set(errp, QERR_BASE_NOT_FOUND, base); return; } } stream_start([[colombian]], base_bs, base, block_stream_cb, [[colombian]], &local_err); if (error_is_set(&local_err)) { error_propagate(errp, local_err); return; } drive_get_ref(drive_get_by_blockdev([[colombian]])); trace_qmp_block_stream([[colombian]], [[colombian]]->job); }
--------------------------------------------- Result 18 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mptsas_scsi_init(PCIDevice *dev, Error **errp) { DeviceState *d = DEVICE(dev); MPTSASState *s = MPT_SAS(dev); dev->config[PCI_LATENCY_TIMER] = 0; dev->config[PCI_INTERRUPT_PIN] = 0x01; memory_region_init_io(&s->mmio_io, OBJECT(s), &mptsas_mmio_ops, s, "mptsas-mmio", 0x4000); memory_region_init_io(&s->port_io, OBJECT(s), &mptsas_port_ops, s, "mptsas-io", 256); memory_region_init_io(&s->diag_io, OBJECT(s), &mptsas_diag_ops, s, "mptsas-diag", 0x10000); if (s->msi != ON_OFF_AUTO_OFF && msi_init(dev, 0, 1, "True" == "True", "False" != "False") >= 0) { s->msi_in_use = "True" == "True"; } pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_IO, &s->port_io); pci_register_bar(dev, 1, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->mmio_io); pci_register_bar(dev, 2, PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_TYPE_32, &s->diag_io); if (!s->sas_addr) { s->sas_addr = ((NAA_LOCALLY_ASSIGNED_ID << 24) | IEEE_COMPANY_LOCALLY_ASSIGNED) << 36; s->sas_addr |= (pci_bus_num(dev->bus) << 16); s->sas_addr |= (PCI_SLOT(dev->devfn) << 8); s->sas_addr |= PCI_FUNC(dev->devfn); } s->max_devices = MPTSAS_NUM_PORTS; s->request_bh = qemu_bh_new(mptsas_fetch_requests, s); QTAILQ_INIT(&s->pending); scsi_bus_new(&s->bus, sizeof(s->bus), &dev->qdev, &mptsas_scsi_info, NULL); if (!d->hotplugged) { scsi_bus_legacy_handle_cmdline(&s->bus, errp); } }
--------------------------------------------- Result 19 ---------------------------------------------
[[0 (20%)]] --> [[0 (56%)]] --> Socre: 0.5560705661773682

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *[[s]]) { return ([[s]]->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && [[s]]->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? [[s]]->num_busses : 1; }

[[[[Adv]]]]: static inline int num_effective_busses(XilinxSPIPS *[[pp]]) { return ([[pp]]->regs[R_LQSPI_STS] & LQSPI_CFG_SEP_BUS && [[pp]]->regs[R_LQSPI_STS] & LQSPI_CFG_TWO_MEM) ? [[pp]]->num_busses : 1; }
--------------------------------------------- Result 20 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void codeblock(DiracContext *s, SubBand *b, GetBitContext *gb, DiracArith *c, int left, int right, int top, int bottom, int blockcnt_one, int is_arith) { int x, y, zero_block; int qoffset, qfactor; IDWTELEM *buf; if (!blockcnt_one) { if (is_arith) zero_block = dirac_get_arith_bit(c, CTX_ZERO_BLOCK); else zero_block = get_bits1(gb); if (zero_block) return; } if (s->codeblock_mode && !(s->old_delta_quant && blockcnt_one)) { if (is_arith) b->quant += dirac_get_arith_int(c, CTX_DELTA_Q_F, CTX_DELTA_Q_DATA); else b->quant += dirac_get_se_golomb(gb); } b->quant = FFMIN(b->quant, MAX_QUANT); qfactor = qscale_tab[b->quant]; if (!s->num_refs) qoffset = qoffset_intra_tab[b->quant]; else qoffset = qoffset_inter_tab[b->quant]; buf = b->ibuf + top * b->stride; for (y = top; y < bottom; y++) { for (x = left; x < right; x++) { if (is_arith) coeff_unpack_arith(c, qfactor, qoffset, b, buf+x, x, y); else buf[x] = coeff_unpack_golomb(gb, qfactor, qoffset); } buf += b->stride; } }
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 2 / 12 / 21:   1%|          | 21/2690 [00:03<07:13,  6.16it/s][Succeeded / Failed / Skipped / Total] 7 / 2 / 12 / 21:   1%|          | 22/2690 [00:03<06:53,  6.45it/s][Succeeded / Failed / Skipped / Total] 7 / 2 / 13 / 22:   1%|          | 22/2690 [00:03<06:53,  6.45it/s][Succeeded / Failed / Skipped / Total] 8 / 2 / 13 / 23:   1%|          | 23/2690 [00:03<06:37,  6.71it/s][Succeeded / Failed / Skipped / Total] 8 / 2 / 14 / 24:   1%|          | 24/2690 [00:03<06:37,  6.71it/s][[0 (69%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) { IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data; ByteIOContext *pb = &s->pb; int ret; ret = process_ipmovie_chunk(ipmovie, pb, pkt); if (ret == CHUNK_BAD) ret = AVERROR_INVALIDDATA; else if (ret == CHUNK_EOF) ret = AVERROR_IO; else if (ret == CHUNK_NOMEM) ret = AVERROR_NOMEM; else ret = 0; return ret; }

[[[[Adv]]]]: static int ipmovie_read_packet(AVFormatContext *s, AVPacket *pkt) { IPMVEContext *ipmovie = (IPMVEContext *)s->priv_data; ByteIOContext *pb = &s->pb; int ret; ret = process_ipmovie_chunk(ipmovie, pb, pkt); if (ret == CHUNK_BAD) ret = AVERROR_INVALIDDATA; else if (ret == CHUNK_EOF) ret = AVERROR_IO; else if (ret == CHUNK_NOMEM) ret = AVERROR_NOMEM; else ret = 0; return ret; }
--------------------------------------------- Result 22 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_op_arith_add(DisasContext *ctx, TCGv ret, TCGv arg1, TCGv arg2, int add_ca, int compute_ca, int compute_ov) { TCGv t0, t1; if ((!compute_ca && !compute_ov) || (!TCGV_EQUAL(ret,arg1) && !TCGV_EQUAL(ret, arg2))) { t0 = ret; } else { t0 = tcg_temp_local_new(); } if (add_ca) { t1 = tcg_temp_local_new(); tcg_gen_mov_tl(t1, cpu_ca); } else { TCGV_UNUSED(t1); } if (compute_ca) { tcg_gen_movi_tl(cpu_ca, 0); } if (compute_ov) { tcg_gen_movi_tl(cpu_ov, 0); } tcg_gen_add_tl(t0, arg1, arg2); if (compute_ca) { gen_op_arith_compute_ca(ctx, t0, arg1, 0); } if (add_ca) { tcg_gen_add_tl(t0, t0, t1); gen_op_arith_compute_ca(ctx, t0, t1, 0); tcg_temp_free(t1); } if (compute_ov) { gen_op_arith_compute_ov(ctx, t0, arg1, arg2, 0); } if (unlikely(Rc(ctx->opcode) != 0)) gen_set_Rc0(ctx, t0); if (!TCGV_EQUAL(t0, ret)) { tcg_gen_mov_tl(ret, t0); tcg_temp_free(t0); } }
--------------------------------------------- Result 23 ---------------------------------------------
[[0 (66%)]] --> [[0 (44%)]] --> Socre: 0.5562166273593903

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *[[unit]]) { BitstreamContext bc; int [[err]]; [[err]] = bitstream_init(&bc, [[unit]]->data, 8 * [[unit]]->data_size); if ([[err]] < 0) return [[err]]; switch ([[unit]]->type) { case HEVC_NAL_VPS: { H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); [[err]] = cbs_h265_read_vps(ctx, &bc, vps); if ([[err]] >= 0) [[err]] = cbs_h265_replace_vps(ctx, vps); if ([[err]] < 0) { av_free(vps); return [[err]]; } [[unit]]->content = vps; } break; case HEVC_NAL_SPS: { H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); [[err]] = cbs_h265_read_sps(ctx, &bc, sps); if ([[err]] >= 0) [[err]] = cbs_h265_replace_sps(ctx, sps); if ([[err]] < 0) { av_free(sps); return [[err]]; } [[unit]]->content = sps; } break; case HEVC_NAL_PPS: { H265RawPPS *[[pps]]; [[pps]] = av_mallocz(sizeof(*[[pps]])); if (![[pps]]) return AVERROR(ENOMEM); [[err]] = cbs_h265_read_pps(ctx, &bc, [[pps]]); if ([[err]] >= 0) [[err]] = cbs_h265_replace_pps(ctx, [[pps]]); if ([[err]] < 0) { av_free([[pps]]); return [[err]]; } [[unit]]->content = [[pps]]; } break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: { H265RawSlice *[[slice]]; int pos, len; [[slice]] = av_mallocz(sizeof(*[[slice]])); if (![[slice]]) return AVERROR(ENOMEM); [[err]] = cbs_h265_read_slice_segment_header(ctx, &bc, &[[slice]]->header); if ([[err]] < 0) { av_free([[slice]]); return [[err]]; } pos = bitstream_tell(&bc); len = [[unit]]->data_size; if (![[unit]]->data[len - 1]) { int z; for (z = 0; z < len && ![[unit]]->data[len - z - 1]; z++); av_log(ctx->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; } [[slice]]->data_size = len - pos / 8; [[slice]]->data = av_malloc([[slice]]->data_size); if (![[slice]]->data) { av_free([[slice]]); return AVERROR(ENOMEM); } memcpy([[slice]]->data, [[unit]]->data + pos / 8, [[slice]]->data_size); [[slice]]->data_bit_start = pos % 8; [[unit]]->content = [[slice]]; } break; case HEVC_NAL_AUD: { H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); [[err]] = cbs_h265_read_aud(ctx, &bc, aud); if ([[err]] < 0) { av_free(aud); return [[err]]; } [[unit]]->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; }

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *[[formations]]) { BitstreamContext bc; int [[euh]]; [[euh]] = bitstream_init(&bc, [[formations]]->data, 8 * [[formations]]->data_size); if ([[euh]] < 0) return [[euh]]; switch ([[formations]]->type) { case HEVC_NAL_VPS: { H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); [[euh]] = cbs_h265_read_vps(ctx, &bc, vps); if ([[euh]] >= 0) [[euh]] = cbs_h265_replace_vps(ctx, vps); if ([[euh]] < 0) { av_free(vps); return [[euh]]; } [[formations]]->content = vps; } break; case HEVC_NAL_SPS: { H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); [[euh]] = cbs_h265_read_sps(ctx, &bc, sps); if ([[euh]] >= 0) [[euh]] = cbs_h265_replace_sps(ctx, sps); if ([[euh]] < 0) { av_free(sps); return [[euh]]; } [[formations]]->content = sps; } break; case HEVC_NAL_PPS: { H265RawPPS *[[without]]; [[without]] = av_mallocz(sizeof(*[[without]])); if (![[without]]) return AVERROR(ENOMEM); [[euh]] = cbs_h265_read_pps(ctx, &bc, [[without]]); if ([[euh]] >= 0) [[euh]] = cbs_h265_replace_pps(ctx, [[without]]); if ([[euh]] < 0) { av_free([[without]]); return [[euh]]; } [[formations]]->content = [[without]]; } break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: { H265RawSlice *[[cuttings]]; int pos, len; [[cuttings]] = av_mallocz(sizeof(*[[cuttings]])); if (![[cuttings]]) return AVERROR(ENOMEM); [[euh]] = cbs_h265_read_slice_segment_header(ctx, &bc, &[[cuttings]]->header); if ([[euh]] < 0) { av_free([[cuttings]]); return [[euh]]; } pos = bitstream_tell(&bc); len = [[formations]]->data_size; if (![[formations]]->data[len - 1]) { int z; for (z = 0; z < len && ![[formations]]->data[len - z - 1]; z++); av_log(ctx->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; } [[cuttings]]->data_size = len - pos / 8; [[cuttings]]->data = av_malloc([[cuttings]]->data_size); if (![[cuttings]]->data) { av_free([[cuttings]]); return AVERROR(ENOMEM); } memcpy([[cuttings]]->data, [[formations]]->data + pos / 8, [[cuttings]]->data_size); [[cuttings]]->data_bit_start = pos % 8; [[formations]]->content = [[cuttings]]; } break; case HEVC_NAL_AUD: { H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); [[euh]] = cbs_h265_read_aud(ctx, &bc, aud); if ([[euh]] < 0) { av_free(aud); return [[euh]]; } [[formations]]->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; }
--------------------------------------------- Result 24 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: FFTContext *av_fft_init(int nbits, int inverse) { FFTContext *s = av_malloc(sizeof(*s)); if (s && ff_fft_init(s, nbits, inverse)) av_freep(&s); return s; }
--------------------------------------------- Result 25 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 2 / 15 / 25:   1%|          | 25/2690 [00:05<09:02,  4.91it/s][Succeeded / Failed / Skipped / Total] 8 / 2 / 16 / 26:   1%|          | 26/2690 [00:05<08:41,  5.11it/s][Succeeded / Failed / Skipped / Total] 8 / 3 / 16 / 27:   1%|          | 27/2690 [00:05<08:21,  5.31it/s][Succeeded / Failed / Skipped / Total] 9 / 3 / 16 / 28:   1%|          | 28/2690 [00:05<08:03,  5.50it/s][Succeeded / Failed / Skipped / Total] 9 / 3 / 17 / 29:   1%|          | 29/2690 [00:08<12:40,  3.50it/s][Succeeded / Failed / Skipped / Total] 9 / 3 / 18 / 30:   1%|          | 30/2690 [00:09<13:36,  3.26it/s][[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv34_decode_mv(RV34DecContext *r, int block_type) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int i, j, k, l; int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int next_bt; memset(r->dmv, 0, sizeof(r->dmv)); for(i = 0; i < num_mvs[block_type]; i++){ r->dmv[i][0] = svq3_get_se_golomb(gb); r->dmv[i][1] = svq3_get_se_golomb(gb); } switch(block_type){ case RV34_MB_TYPE_INTRA: case RV34_MB_TYPE_INTRA16x16: ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); return 0; case RV34_MB_SKIP: if(s->pict_type == AV_PICTURE_TYPE_P){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; } case RV34_MB_B_DIRECT: if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0); next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride]; if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); }else for(j = 0; j < 2; j++) for(i = 0; i < 2; i++) for(k = 0; k < 2; k++) for(l = 0; l < 2; l++) s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]); if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) rv34_mc_2mv(r, block_type); else rv34_mc_2mv_skip(r); ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); break; case RV34_MB_P_16x16: case RV34_MB_P_MIX16x16: rv34_pred_mv(r, block_type, 0, 0); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; case RV34_MB_B_FORWARD: case RV34_MB_B_BACKWARD: r->dmv[1][0] = r->dmv[0][0]; r->dmv[1][1] = r->dmv[0][1]; if(r->rv30) rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD); else rv34_pred_mv_b (r, block_type, block_type == RV34_MB_B_BACKWARD); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD); break; case RV34_MB_P_16x8: case RV34_MB_P_8x16: rv34_pred_mv(r, block_type, 0, 0); rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1); if(block_type == RV34_MB_P_16x8){ rv34_mc_1mv(r, block_type, 0, 0, 0, 2, 1, 0); rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0); } if(block_type == RV34_MB_P_8x16){ rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0); rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0); } break; case RV34_MB_B_BIDIR: rv34_pred_mv_b (r, block_type, 0); rv34_pred_mv_b (r, block_type, 1); rv34_mc_2mv (r, block_type); break; case RV34_MB_P_8x8: for(i=0;i< 4;i++){ rv34_pred_mv(r, block_type, i, i); rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0); } break; } return 0; }
--------------------------------------------- Result 26 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int encode_frame(AVCodecContext *avctx, unsigned char *buf, int buf_size, void *data){ FFV1Context *f = avctx->priv_data; CABACContext * const c= &f->c; AVFrame *pict = data; const int width= f->width; const int height= f->height; AVFrame * const p= &f->picture; int used_count= 0; if(avctx->strict_std_compliance >= 0){ av_log(avctx, AV_LOG_ERROR, "this codec is under development, files encoded with it wont be decodeable with future versions!!!\n" "use vstrict=-1 to use it anyway\n"); return -1; } ff_init_cabac_encoder(c, buf, buf_size); ff_init_cabac_states(c, ff_h264_lps_range, ff_h264_mps_state, ff_h264_lps_state, 64); c->lps_state[2] = 1; c->lps_state[3] = 0; *p = *pict; p->pict_type= FF_I_TYPE; if(avctx->gop_size==0 || f->picture_number % avctx->gop_size == 0){ put_cabac_bypass(c, 1); p->key_frame= 1; write_header(f); clear_state(f); }else{ put_cabac_bypass(c, 0); p->key_frame= 0; } if(!f->ac){ used_count += put_cabac_terminate(c, 1); init_put_bits(&f->pb, buf + used_count, buf_size - used_count); } if(f->colorspace==0){ const int chroma_width = -((-width )>>f->chroma_h_shift); const int chroma_height= -((-height)>>f->chroma_v_shift); encode_plane(f, p->data[0], width, height, p->linesize[0], 0); encode_plane(f, p->data[1], chroma_width, chroma_height, p->linesize[1], 1); encode_plane(f, p->data[2], chroma_width, chroma_height, p->linesize[2], 1); }else{ encode_rgb_frame(f, (uint32_t*)(p->data[0]), width, height, p->linesize[0]/4); } emms_c(); f->picture_number++; if(f->ac){ return put_cabac_terminate(c, 1); }else{ flush_put_bits(&f->pb); return used_count + (put_bits_count(&f->pb)+7)/8; } }
--------------------------------------------- Result 27 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int main(void) { int nf; Suite *s; SRunner *sr; s = qfloat_suite(); sr = srunner_create(s); srunner_run_all(sr, CK_NORMAL); nf = srunner_ntests_failed(sr); srunner_free(sr); return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE; }

[[[[Adv]]]]: int main(void) { int nf; Suite *s; SRunner *sr; s = qfloat_suite(); sr = srunner_create(s); srunner_run_all(sr, CK_NORMAL); nf = srunner_ntests_failed(sr); srunner_free(sr); return (nf == 0) ? EXIT_SUCCESS : EXIT_FAILURE; }
--------------------------------------------- Result 28 ---------------------------------------------
[[0 (89%)]] --> [[0 (34%)]] --> Socre: 0.6607603430747986

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv var) { TCGv [[tmp]] = new_tmp(); tcg_gen_shri_i32([[tmp]], var, 31); gen_set_CF([[tmp]]); dead_tmp([[tmp]]); }

[[[[Adv]]]]: static void gen_set_CF_bit31(TCGv var) { TCGv [[zoolander]] = new_tmp(); tcg_gen_shri_i32([[zoolander]], var, 31); gen_set_CF([[zoolander]]); dead_tmp([[zoolander]]); }
--------------------------------------------- Result 29 ---------------------------------------------
[[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int nb_coefs; int blk, bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { block = &s->blocks[blk]; block->new_rematrixing_strategy = !blk; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType sum[4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType rt = block->mdct_coef[1][i]; CoefType md = lt + rt; CoefType sd = lt - rt; sum[0] += lt * lt; sum[1] += rt * rt; sum[2] += md * md; sum[3] += sd * sd; } if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if (blk && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }
--------------------------------------------- Result 30 ---------------------------------------------
[[0 (7%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_audio_fini (void *opaque) { (void) opaque; }
--------------------------------------------- Result 31 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 4 / 18 / 31:   1%|          | 31/2690 [00:09<13:10,  3.36it/s][Succeeded / Failed / Skipped / Total] 9 / 5 / 18 / 32:   1%|          | 32/2690 [00:09<12:45,  3.47it/s][Succeeded / Failed / Skipped / Total] 9 / 5 / 18 / 32:   1%|          | 33/2690 [00:09<12:24,  3.57it/s][Succeeded / Failed / Skipped / Total] 10 / 5 / 18 / 33:   1%|          | 33/2690 [00:09<12:24,  3.57it/s][[0 (65%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *s = (const uint16_t*)src; end = s + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = end - 7; while (s < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*s) :"memory"); d += 24; s += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }

[[[[Adv]]]]: static inline void RENAME(rgb15tobgr24)(const uint8_t *src, uint8_t *dst, int src_size) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = dst; const uint16_t *s = (const uint16_t*)src; end = s + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); mm_end = end - 7; while (s < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" "movq %%mm0, %%mm6 \n\t" "movq %%mm3, %%mm7 \n\t" "movq 8%1, %%mm0 \n\t" "movq 8%1, %%mm1 \n\t" "movq 8%1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" "movq %%mm0, %%mm3 \n\t" "movq %%mm1, %%mm4 \n\t" "movq %%mm2, %%mm5 \n\t" "punpcklwd %5, %%mm0 \n\t" "punpcklwd %5, %%mm1 \n\t" "punpcklwd %5, %%mm2 \n\t" "punpckhwd %5, %%mm3 \n\t" "punpckhwd %5, %%mm4 \n\t" "punpckhwd %5, %%mm5 \n\t" "psllq $8, %%mm1 \n\t" "psllq $16, %%mm2 \n\t" "por %%mm1, %%mm0 \n\t" "por %%mm2, %%mm0 \n\t" "psllq $8, %%mm4 \n\t" "psllq $16, %%mm5 \n\t" "por %%mm4, %%mm3 \n\t" "por %%mm5, %%mm3 \n\t" :"=m"(*d) :"m"(*s),"m"(mask15b),"m"(mask15g),"m"(mask15r), "m"(mmx_null) :"memory"); __asm__ volatile( "movq %%mm0, %%mm4 \n\t" "movq %%mm3, %%mm5 \n\t" "movq %%mm6, %%mm0 \n\t" "movq %%mm7, %%mm1 \n\t" "movq %%mm4, %%mm6 \n\t" "movq %%mm5, %%mm7 \n\t" "movq %%mm0, %%mm2 \n\t" "movq %%mm1, %%mm3 \n\t" STORE_BGR24_MMX :"=m"(*d) :"m"(*s) :"memory"); d += 24; s += 8; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while (s < end) { register uint16_t bgr; bgr = *s++; *d++ = (bgr&0x1F)<<3; *d++ = (bgr&0x3E0)>>2; *d++ = (bgr&0x7C00)>>7; } }
--------------------------------------------- Result 32 ---------------------------------------------
[[0 (75%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t ret; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { ret = -1; } else { ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) ret = ~ret; } T0 = ret; }

[[[[Adv]]]]: void do_POWER_maskg (void) { uint32_t ret; if ((uint32_t)T0 == (uint32_t)(T1 + 1)) { ret = -1; } else { ret = (((uint32_t)(-1)) >> ((uint32_t)T0)) ^ (((uint32_t)(-1) >> ((uint32_t)T1)) >> 1); if ((uint32_t)T0 > (uint32_t)T1) ret = ~ret; } T0 = ret; }
--------------------------------------------- Result 33 ---------------------------------------------
[[0 (48%)]] --> [[0 (55%)]] --> Socre: 0.5512789487838745

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1); int [[ret]]; if (vdev->intx.disabled || !pin) { return 0; } vfio_disable_interrupts(vdev); vdev->intx.pin = pin - 1; [[ret]] = event_notifier_init(&vdev->intx.interrupt, 0); if ([[ret]]) { error_report("vfio: Error: event_notifier_init failed\n"); return [[ret]]; } irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled(vdev, "False" != "False"); vdev->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); return 0; }

[[[[Adv]]]]: static int vfio_enable_intx(VFIODevice *vdev) { VFIOIRQSetFD irq_set_fd = { .irq_set = { .argsz = sizeof(irq_set_fd), .flags = VFIO_IRQ_SET_DATA_EVENTFD | VFIO_IRQ_SET_ACTION_TRIGGER, .index = VFIO_PCI_INTX_IRQ_INDEX, .start = 0, .count = 1, }, }; uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1); int [[retirement]]; if (vdev->intx.disabled || !pin) { return 0; } vfio_disable_interrupts(vdev); vdev->intx.pin = pin - 1; [[retirement]] = event_notifier_init(&vdev->intx.interrupt, 0); if ([[retirement]]) { error_report("vfio: Error: event_notifier_init failed\n"); return [[retirement]]; } irq_set_fd.fd = event_notifier_get_fd(&vdev->intx.interrupt); qemu_set_fd_handler(irq_set_fd.fd, vfio_intx_interrupt, NULL, vdev); if (ioctl(vdev->fd, VFIO_DEVICE_SET_IRQS, &irq_set_fd)) { error_report("vfio: Error: Failed to setup INTx fd: %m\n"); return -errno; } vfio_mmap_set_enabled(vdev, "False" != "False"); vdev->interrupt = VFIO_INT_INTx; DPRINTF("%s(%04x:%02x:%02x.%x)\n", __func__, vdev->host.domain, vdev->host.bus, vdev->host.slot, vdev->host.function); return 0; }
--------------------------------------------- Result 34 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 5 / 19 / 34:   1%|         | 34/2690 [00:09<12:04,  3.66it/s][Succeeded / Failed / Skipped / Total] 10 / 5 / 20 / 35:   1%|         | 35/2690 [00:09<12:10,  3.64it/s][Succeeded / Failed / Skipped / Total] 11 / 5 / 20 / 36:   1%|         | 36/2690 [00:10<12:26,  3.56it/s][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { granularity = bdrv_get_default_bitmap_granularity(target); } assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) { error_setg(errp, QERR_INVALID_PARAMETER, "on-source-error"); return; } if (buf_size < 0) { error_setg(errp, "Invalid parameter 'buf-size'"); return; } if (buf_size == 0) { buf_size = DEFAULT_MIRROR_BUF_SIZE; } if (replaces) { replaced_bs = bdrv_lookup_bs(replaces, replaces, errp); if (replaced_bs == NULL) { return; } } else { replaced_bs = bs; } if (replaced_bs->blk && target->blk) { error_setg(errp, "Can't create node with two BlockBackends"); return; } s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = g_strdup(replaces); s->on_source_error = on_source_error; s->on_target_error = on_target_error; s->target = target; s->is_none_mode = is_none_mode; s->base = base; s->granularity = granularity; s->buf_size = ROUND_UP(buf_size, granularity); s->unmap = unmap; s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s->dirty_bitmap) { g_free(s->replaces); block_job_unref(&s->common); return; } bdrv_op_block_all(s->target, s->common.blocker); bdrv_set_enable_write_cache(s->target, "True" == "True"); if (s->target->blk) { blk_set_on_error(s->target->blk, on_target_error, on_target_error); blk_iostatus_enable(s->target->blk); } s->common.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 35 ---------------------------------------------
[[0 (30%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int get_siz(Jpeg2000DecoderContext *s) { int i; int ncomponents; uint32_t log2_chroma_wh = 0; const enum AVPixelFormat *possible_fmts = NULL; int possible_fmts_nb = 0; if (bytestream2_get_bytes_left(&s->g) < 36) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for SIZ\n"); s->avctx->profile = bytestream2_get_be16u(&s->g); s->width = bytestream2_get_be32u(&s->g); s->height = bytestream2_get_be32u(&s->g); s->image_offset_x = bytestream2_get_be32u(&s->g); s->image_offset_y = bytestream2_get_be32u(&s->g); s->tile_width = bytestream2_get_be32u(&s->g); s->tile_height = bytestream2_get_be32u(&s->g); s->tile_offset_x = bytestream2_get_be32u(&s->g); s->tile_offset_y = bytestream2_get_be32u(&s->g); ncomponents = bytestream2_get_be16u(&s->g); if (s->image_offset_x || s->image_offset_y) { avpriv_request_sample(s->avctx, "Support for image offsets"); return AVERROR_PATCHWELCOME; if (av_image_check_size(s->width, s->height, 0, s->avctx)) { avpriv_request_sample(s->avctx, "Large Dimensions"); return AVERROR_PATCHWELCOME; if (ncomponents <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid number of components: %d\n", if (ncomponents > 4) { avpriv_request_sample(s->avctx, "Support for %d components", ncomponents); return AVERROR_PATCHWELCOME; s->ncomponents = ncomponents; if (s->tile_width <= 0 || s->tile_height <= 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid tile dimension %dx%d.\n", s->tile_width, s->tile_height); if (bytestream2_get_bytes_left(&s->g) < 3 * s->ncomponents) { av_log(s->avctx, AV_LOG_ERROR, "Insufficient space for %d components in SIZ\n", s->ncomponents); for (i = 0; i < s->ncomponents; i++) { uint8_t x = bytestream2_get_byteu(&s->g); s->cbps[i] = (x & 0x7f) + 1; s->precision = FFMAX(s->cbps[i], s->precision); s->sgnd[i] = !!(x & 0x80); s->cdx[i] = bytestream2_get_byteu(&s->g); s->cdy[i] = bytestream2_get_byteu(&s->g); if ( !s->cdx[i] || s->cdx[i] == 3 || s->cdx[i] > 4 || !s->cdy[i] || s->cdy[i] == 3 || s->cdy[i] > 4) { av_log(s->avctx, AV_LOG_ERROR, "Invalid sample separation %d/%d\n", s->cdx[i], s->cdy[i]); log2_chroma_wh |= s->cdy[i] >> 1 << i * 4 | s->cdx[i] >> 1 << i * 4 + 2; s->numXtiles = ff_jpeg2000_ceildiv(s->width - s->tile_offset_x, s->tile_width); s->numYtiles = ff_jpeg2000_ceildiv(s->height - s->tile_offset_y, s->tile_height); if (s->numXtiles * (uint64_t)s->numYtiles > INT_MAX/sizeof(*s->tile)) { s->numXtiles = s->numYtiles = 0; return AVERROR(EINVAL); s->tile = av_mallocz_array(s->numXtiles * s->numYtiles, sizeof(*s->tile)); if (!s->tile) { s->numXtiles = s->numYtiles = 0; return AVERROR(ENOMEM); for (i = 0; i < s->numXtiles * s->numYtiles; i++) { Jpeg2000Tile *tile = s->tile + i; tile->comp = av_mallocz(s->ncomponents * sizeof(*tile->comp)); if (!tile->comp) return AVERROR(ENOMEM); s->avctx->width = ff_jpeg2000_ceildivpow2(s->width - s->image_offset_x, s->reduction_factor); s->avctx->height = ff_jpeg2000_ceildivpow2(s->height - s->image_offset_y, s->reduction_factor); if (s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_2K || s->avctx->profile == FF_PROFILE_JPEG2000_DCINEMA_4K) { possible_fmts = xyz_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(xyz_pix_fmts); } else { switch (s->colour_space) { case 16: possible_fmts = rgb_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(rgb_pix_fmts); break; case 17: possible_fmts = gray_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(gray_pix_fmts); break; case 18: possible_fmts = yuv_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(yuv_pix_fmts); break; default: possible_fmts = all_pix_fmts; possible_fmts_nb = FF_ARRAY_ELEMS(all_pix_fmts); break; for (i = 0; i < possible_fmts_nb; ++i) { if (pix_fmt_match(possible_fmts[i], ncomponents, s->precision, log2_chroma_wh, s->pal8)) { s->avctx->pix_fmt = possible_fmts[i]; break; if (i == possible_fmts_nb) { if (ncomponents == 4 && s->cdy[0] == 1 && s->cdx[0] == 1 && s->cdy[1] == 1 && s->cdx[1] == 1 && s->cdy[2] == s->cdy[3] && s->cdx[2] == s->cdx[3]) { if (s->precision == 8 && s->cdy[2] == 2 && s->cdx[2] == 2 && !s->pal8) { s->avctx->pix_fmt = AV_PIX_FMT_YUVA420P; s->cdef[0] = 0; s->cdef[1] = 1; s->cdef[2] = 2; s->cdef[3] = 3; i = 0; if (i == possible_fmts_nb) { av_log(s->avctx, AV_LOG_ERROR, "Unknown pix_fmt, profile: %d, colour_space: %d, " "components: %d, precision: %d\n" "cdx[0]: %d, cdy[0]: %d\n" "cdx[1]: %d, cdy[1]: %d\n" "cdx[2]: %d, cdy[2]: %d\n" "cdx[3]: %d, cdy[3]: %d\n", s->avctx->profile, s->colour_space, ncomponents, s->precision, s->cdx[0], s->cdy[0], ncomponents > 1 ? s->cdx[1] : 0, ncomponents > 1 ? s->cdy[1] : 0, ncomponents > 2 ? s->cdx[2] : 0, ncomponents > 2 ? s->cdy[2] : 0, ncomponents > 3 ? s->cdx[3] : 0, ncomponents > 3 ? s->cdy[3] : 0); return AVERROR_PATCHWELCOME; s->avctx->bits_per_raw_sample = s->precision; return 0;
--------------------------------------------- Result 36 ---------------------------------------------
[[0 (95%)]] --> [[0 (27%)]] --> Socre: 0.73148512840271

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t [[x0]]; uint32_t x1; [[x0]] = T0 | ((uint64_t) (env->y) << 32); x1 = T1; [[x0]] = [[x0]] / x1; if ([[x0]] > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = [[x0]]; T1 = 0; FORCE_RET();

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t [[followers]]; uint32_t x1; [[followers]] = T0 | ((uint64_t) (env->y) << 32); x1 = T1; [[followers]] = [[followers]] / x1; if ([[followers]] > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = [[followers]]; T1 = 0; FORCE_RET();
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 5 / 20 / 37:   1%|         | 37/2690 [00:10<12:06,  3.65it/s][Succeeded / Failed / Skipped / Total] 13 / 5 / 20 / 38:   1%|         | 38/2690 [00:10<11:46,  3.75it/s][Succeeded / Failed / Skipped / Total] 14 / 5 / 20 / 39:   1%|         | 39/2690 [00:10<11:28,  3.85it/s][Succeeded / Failed / Skipped / Total] 14 / 6 / 20 / 40:   1%|         | 40/2690 [00:10<11:12,  3.94it/s][Succeeded / Failed / Skipped / Total] 14 / 6 / 21 / 41:   2%|         | 41/2690 [00:11<12:47,  3.45it/s][Succeeded / Failed / Skipped / Total] 15 / 6 / 21 / 42:   2%|         | 42/2690 [00:13<14:34,  3.03it/s][[0 (52%)]] --> [[0 (47%)]] --> Socre: 0.5281290113925934

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *[[data]], int data_len) { USBRedirDevice *dev = priv; uint8_t [[ep]] = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, [[ep]], len, id); aurb = async_find(dev, id); if (!aurb) { free([[data]]); return; } if (aurb->bulk_packet.endpoint != bulk_packet->endpoint || aurb->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if (aurb->packet) { len = usbredir_handle_status(dev, bulk_packet->status, len); if (len > 0) { usbredir_log_data(dev, "bulk data in:", [[data]], data_len); if (data_len <= aurb->packet->len) { memcpy(aurb->packet->data, [[data]], data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, aurb->packet->len); len = USB_RET_STALL; } } aurb->packet->len = len; usb_packet_complete(&dev->dev, aurb->packet); } async_free(dev, aurb); free([[data]]); }

[[[[Adv]]]]: static void usbredir_bulk_packet(void *priv, uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *[[endorsements]], int data_len) { USBRedirDevice *dev = priv; uint8_t [[bae]] = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, [[bae]], len, id); aurb = async_find(dev, id); if (!aurb) { free([[endorsements]]); return; } if (aurb->bulk_packet.endpoint != bulk_packet->endpoint || aurb->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if (aurb->packet) { len = usbredir_handle_status(dev, bulk_packet->status, len); if (len > 0) { usbredir_log_data(dev, "bulk data in:", [[endorsements]], data_len); if (data_len <= aurb->packet->len) { memcpy(aurb->packet->data, [[endorsements]], data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, aurb->packet->len); len = USB_RET_STALL; } } aurb->packet->len = len; usb_packet_complete(&dev->dev, aurb->packet); } async_free(dev, aurb); free([[endorsements]]); }
--------------------------------------------- Result 38 ---------------------------------------------
[[0 (47%)]] --> [[0 (51%)]] --> Socre: 0.5085888504981995

[[[[Adv]]]]: static void sdl_send_mouse_event(int dx, int [[dy]], int x, int y, int state) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != state) { qemu_input_update_buttons(dcl->con, bmap, prev_state, state); prev_state = state; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x, real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y, real_screen->h); } else { if (guest_cursor) { x -= guest_x; y -= guest_y; guest_x += x; guest_y += y; dx = x; [[dy]] = y; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[dy]]); } qemu_input_event_sync(); }

[[[[Adv]]]]: static void sdl_send_mouse_event(int dx, int [[de]], int x, int y, int state) { static uint32_t bmap[INPUT_BUTTON__MAX] = { [INPUT_BUTTON_LEFT] = SDL_BUTTON(SDL_BUTTON_LEFT), [INPUT_BUTTON_MIDDLE] = SDL_BUTTON(SDL_BUTTON_MIDDLE), [INPUT_BUTTON_RIGHT] = SDL_BUTTON(SDL_BUTTON_RIGHT), [INPUT_BUTTON_WHEEL_UP] = SDL_BUTTON(SDL_BUTTON_WHEELUP), [INPUT_BUTTON_WHEEL_DOWN] = SDL_BUTTON(SDL_BUTTON_WHEELDOWN), }; static uint32_t prev_state; if (prev_state != state) { qemu_input_update_buttons(dcl->con, bmap, prev_state, state); prev_state = state; } if (qemu_input_is_absolute()) { qemu_input_queue_abs(dcl->con, INPUT_AXIS_X, x, real_screen->w); qemu_input_queue_abs(dcl->con, INPUT_AXIS_Y, y, real_screen->h); } else { if (guest_cursor) { x -= guest_x; y -= guest_y; guest_x += x; guest_y += y; dx = x; [[de]] = y; } qemu_input_queue_rel(dcl->con, INPUT_AXIS_X, dx); qemu_input_queue_rel(dcl->con, INPUT_AXIS_Y, [[de]]); } qemu_input_event_sync(); }
--------------------------------------------- Result 39 ---------------------------------------------
[[0 (41%)]] --> [[0 (51%)]] --> Socre: 0.5080381035804749

[[[[Adv]]]]: static void stream_process_mem2s(struct Stream *s, StreamSlave *[[tx_dev]]) { uint32_t prev_d; unsigned char [[txbuf]][16 * 1024]; unsigned int txlen; uint32_t [[app]][6]; if (!stream_running(s) || stream_idle(s)) { return; } while (1) { stream_desc_load(s, s->regs[R_CURDESC]); if (s->desc.status & SDESC_STATUS_COMPLETE) { s->regs[R_DMASR] |= DMASR_HALTED; break; } if (stream_desc_sof(&s->desc)) { s->pos = 0; memcpy([[app]], s->desc.app, sizeof [[app]]); } txlen = s->desc.control & SDESC_CTRL_LEN_MASK; if ((txlen + s->pos) > sizeof [[txbuf]]) { hw_error("%s: too small internal txbuf! %d\n", __func__, txlen + s->pos); } cpu_physical_memory_read(s->desc.buffer_address, [[txbuf]] + s->pos, txlen); s->pos += txlen; if (stream_desc_eof(&s->desc)) { stream_push([[tx_dev]], [[txbuf]], s->pos, [[app]]); s->pos = 0; stream_complete(s); } s->desc.status = txlen | SDESC_STATUS_COMPLETE; stream_desc_store(s, s->regs[R_CURDESC]); prev_d = s->regs[R_CURDESC]; s->regs[R_CURDESC] = s->desc.nxtdesc; if (prev_d == s->regs[R_TAILDESC]) { s->regs[R_DMASR] |= DMASR_IDLE; break; } } }

[[[[Adv]]]]: static void stream_process_mem2s(struct Stream *s, StreamSlave *[[imposes]]) { uint32_t prev_d; unsigned char [[masato]][16 * 1024]; unsigned int txlen; uint32_t [[alp]][6]; if (!stream_running(s) || stream_idle(s)) { return; } while (1) { stream_desc_load(s, s->regs[R_CURDESC]); if (s->desc.status & SDESC_STATUS_COMPLETE) { s->regs[R_DMASR] |= DMASR_HALTED; break; } if (stream_desc_sof(&s->desc)) { s->pos = 0; memcpy([[alp]], s->desc.app, sizeof [[alp]]); } txlen = s->desc.control & SDESC_CTRL_LEN_MASK; if ((txlen + s->pos) > sizeof [[masato]]) { hw_error("%s: too small internal txbuf! %d\n", __func__, txlen + s->pos); } cpu_physical_memory_read(s->desc.buffer_address, [[masato]] + s->pos, txlen); s->pos += txlen; if (stream_desc_eof(&s->desc)) { stream_push([[imposes]], [[masato]], s->pos, [[alp]]); s->pos = 0; stream_complete(s); } s->desc.status = txlen | SDESC_STATUS_COMPLETE; stream_desc_store(s, s->regs[R_CURDESC]); prev_d = s->regs[R_CURDESC]; s->regs[R_CURDESC] = s->desc.nxtdesc; if (prev_d == s->regs[R_TAILDESC]) { s->regs[R_DMASR] |= DMASR_IDLE; break; } } }
--------------------------------------------- Result 40 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }
--------------------------------------------- Result 41 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void commit_set_speed(BlockJob *job, int64_t speed, Error **errp) { CommitBlockJob *s = container_of(job, CommitBlockJob, common); if (speed < 0) { error_setg(errp, QERR_INVALID_PARAMETER, "speed"); return; } ratelimit_set_speed(&s->limit, speed / BDRV_SECTOR_SIZE, SLICE_TIME); }
--------------------------------------------- Result 42 ---------------------------------------------
[[0 (31%)]] --> [[0 (56%)]] --> Socre: 0.5644555687904358

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[env]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[env]]); }

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *[[youre]]) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0([[youre]]); }
--------------------------------------------- Result 43 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 6 / 21 / 43:   2%|         | 43/2690 [00:14<15:05,  2.92it/s][Succeeded / Failed / Skipped / Total] 16 / 6 / 21 / 43:   2%|         | 44/2690 [00:14<14:44,  2.99it/s][Succeeded / Failed / Skipped / Total] 17 / 6 / 21 / 44:   2%|         | 44/2690 [00:14<14:44,  2.99it/s][Succeeded / Failed / Skipped / Total] 17 / 6 / 22 / 45:   2%|         | 45/2690 [00:14<14:24,  3.06it/s][Succeeded / Failed / Skipped / Total] 17 / 6 / 23 / 46:   2%|         | 46/2690 [00:14<14:05,  3.13it/s][Succeeded / Failed / Skipped / Total] 17 / 7 / 23 / 47:   2%|         | 47/2690 [00:14<13:47,  3.19it/s][Succeeded / Failed / Skipped / Total] 17 / 8 / 23 / 48:   2%|         | 48/2690 [00:14<13:38,  3.23it/s][Succeeded / Failed / Skipped / Total] 17 / 8 / 24 / 49:   2%|         | 49/2690 [00:15<13:30,  3.26it/s][Succeeded / Failed / Skipped / Total] 18 / 8 / 24 / 50:   2%|         | 50/2690 [00:15<13:27,  3.27it/s][Succeeded / Failed / Skipped / Total] 19 / 8 / 24 / 51:   2%|         | 51/2690 [00:15<13:12,  3.33it/s][[0 (68%)]] --> [[0 (45%)]] --> Socre: 0.55426225066185

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s, uint32_t [[length]]) { int n, i, r, g, b; if (([[length]] % 3) != 0 || [[length]] > 256 * 3) return AVERROR_INVALIDDATA; n = [[length]] / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s, uint32_t [[moments]]) { int n, i, r, g, b; if (([[moments]] % 3) != 0 || [[moments]] > 256 * 3) return AVERROR_INVALIDDATA; n = [[moments]] / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }
--------------------------------------------- Result 44 ---------------------------------------------
[[0 (90%)]] --> [[0 (48%)]] --> Socre: 0.5246648788452148

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *[[dev]], uint64_t [[iova]], uint64_t len) { struct vhost_iotlb_msg [[imsg]]; [[imsg]].iova = [[iova]]; [[imsg]].size = len; [[imsg]].type = VHOST_IOTLB_INVALIDATE; return [[dev]]->vhost_ops->vhost_send_device_iotlb_msg([[dev]], &[[imsg]]); }

[[[[Adv]]]]: int vhost_backend_invalidate_device_iotlb(struct vhost_dev *[[anand]], uint64_t [[giris]], uint64_t len) { struct vhost_iotlb_msg [[farmlands]]; [[farmlands]].iova = [[giris]]; [[farmlands]].size = len; [[farmlands]].type = VHOST_IOTLB_INVALIDATE; return [[anand]]->vhost_ops->vhost_send_device_iotlb_msg([[anand]], &[[farmlands]]); }
--------------------------------------------- Result 45 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static size_t header_ext_add(char *buf, uint32_t magic, const void *s, size_t len, size_t buflen) { QCowExtension *ext_backing_fmt = (QCowExtension*) buf; size_t ext_len = sizeof(QCowExtension) + ((len + 7) & ~7); if (buflen < ext_len) { return -ENOSPC; } *ext_backing_fmt = (QCowExtension) { .magic = cpu_to_be32(magic), .len = cpu_to_be32(len), }; memcpy(buf + sizeof(QCowExtension), s, len); return ext_len; }
--------------------------------------------- Result 46 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int adpcm_decode_init(AVCodecContext * avctx) { ADPCMContext *c = avctx->priv_data; if(avctx->channels > 2U){ return -1; } c->channel = 0; c->status[0].predictor = c->status[1].predictor = 0; c->status[0].step_index = c->status[1].step_index = 0; c->status[0].step = c->status[1].step = 0; switch(avctx->codec->id) { case CODEC_ID_ADPCM_CT: c->status[0].step = c->status[1].step = 511; break; case CODEC_ID_ADPCM_IMA_WS: if (avctx->extradata && avctx->extradata_size == 2 * 4) { c->status[0].predictor = AV_RL32(avctx->extradata); c->status[1].predictor = AV_RL32(avctx->extradata + 4); } break; default: break; } return 0; }
--------------------------------------------- Result 47 ---------------------------------------------
[[0 (59%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int i1) { int i; if (i1 <= i0 + 1) { if (i0 == 1) p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16; else p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int(p, i0, i1); i0++; i1++; for (i = i0/2 - 2; i < i1/2 + 1; i++) p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2 + 1; i++) p[2 * i] -= (I_LFTG_BETA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2; i++) p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2; i < i1/2; i++) p[2 * i] += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; }

[[[[Adv]]]]: static void sd_1d97_int(int *p, int i0, int i1) { int i; if (i1 <= i0 + 1) { if (i0 == 1) p[1] = (p[1] * I_LFTG_X + (1<<15)) >> 16; else p[0] = (p[0] * I_LFTG_K + (1<<15)) >> 16; return; } extend97_int(p, i0, i1); i0++; i1++; for (i = i0/2 - 2; i < i1/2 + 1; i++) p[2 * i + 1] -= (I_LFTG_ALPHA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2 + 1; i++) p[2 * i] -= (I_LFTG_BETA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; for (i = i0/2 - 1; i < i1/2; i++) p[2 * i + 1] += (I_LFTG_GAMMA * (p[2 * i] + p[2 * i + 2]) + (1 << 15)) >> 16; for (i = i0/2; i < i1/2; i++) p[2 * i] += (I_LFTG_DELTA * (p[2 * i - 1] + p[2 * i + 1]) + (1 << 15)) >> 16; }
--------------------------------------------- Result 48 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void helper_store_fpcr (uint64_t val) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS); #endif switch ((val >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }

[[[[Adv]]]]: void helper_store_fpcr (uint64_t val) { #ifdef CONFIG_SOFTFLOAT set_float_exception_flags((val >> 52) & 0x3F, &FP_STATUS); #endif switch ((val >> 58) & 3) { case 0: set_float_rounding_mode(float_round_to_zero, &FP_STATUS); break; case 1: set_float_rounding_mode(float_round_down, &FP_STATUS); break; case 2: set_float_rounding_mode(float_round_nearest_even, &FP_STATUS); break; case 3: set_float_rounding_mode(float_round_up, &FP_STATUS); break; } }
--------------------------------------------- Result 49 ---------------------------------------------
[[0 (62%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int qemu_cpu_self(void *env) { return 1; }
--------------------------------------------- Result 50 ---------------------------------------------
[[0 (8%)]] --> [[0 (59%)]] --> Socre: 0.5889378190040588

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[lexer]], JSONLexerEmitter [[func]]) { [[lexer]]->emit = [[func]]; [[lexer]]->state = IN_START; [[lexer]]->token = qstring_new(); [[lexer]]->x = [[lexer]]->y = 0; }

[[[[Adv]]]]: void json_lexer_init(JSONLexer *[[ogden]], JSONLexerEmitter [[getcha]]) { [[ogden]]->emit = [[getcha]]; [[ogden]]->state = IN_START; [[ogden]]->token = qstring_new(); [[ogden]]->x = [[ogden]]->y = 0; }
--------------------------------------------- Result 51 ---------------------------------------------
[[0 (62%)]] --> [[0 (44%)]] --> Socre: 0.5550938248634338

[[[[Adv]]]]: static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom [[atom]]) { AVStream *st; if (c->fc->nb_streams < 1) return 0; if ([[atom]].size <= 40) return 0; st = c->fc->streams[c->fc->nb_streams-1]; if ((uint64_t)[[atom]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free(st->codec->extradata); st->codec->extradata = av_mallocz([[atom]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); st->codec->extradata_size = [[atom]].size - 40; avio_skip(pb, 40); avio_read(pb, st->codec->extradata, [[atom]].size - 40); return 0; }

[[[[Adv]]]]: static int mov_read_strf(MOVContext *c, AVIOContext *pb, MOVAtom [[isotope]]) { AVStream *st; if (c->fc->nb_streams < 1) return 0; if ([[isotope]].size <= 40) return 0; st = c->fc->streams[c->fc->nb_streams-1]; if ((uint64_t)[[isotope]].size > (1<<30)) return AVERROR_INVALIDDATA; av_free(st->codec->extradata); st->codec->extradata = av_mallocz([[isotope]].size - 40 + FF_INPUT_BUFFER_PADDING_SIZE); if (!st->codec->extradata) return AVERROR(ENOMEM); st->codec->extradata_size = [[isotope]].size - 40; avio_skip(pb, 40); avio_read(pb, st->codec->extradata, [[isotope]].size - 40); return 0; }
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 9 / 24 / 52:   2%|         | 52/2690 [00:15<12:57,  3.39it/s][Succeeded / Failed / Skipped / Total] 19 / 9 / 25 / 53:   2%|         | 53/2690 [00:15<12:42,  3.46it/s][Succeeded / Failed / Skipped / Total] 20 / 9 / 25 / 54:   2%|         | 54/2690 [00:15<12:30,  3.51it/s][Succeeded / Failed / Skipped / Total] 20 / 9 / 25 / 54:   2%|         | 55/2690 [00:15<12:34,  3.49it/s][Succeeded / Failed / Skipped / Total] 20 / 10 / 25 / 55:   2%|         | 55/2690 [00:15<12:34,  3.49it/s][Succeeded / Failed / Skipped / Total] 20 / 10 / 26 / 56:   2%|         | 56/2690 [00:16<13:05,  3.35it/s][Succeeded / Failed / Skipped / Total] 20 / 10 / 27 / 57:   2%|         | 57/2690 [00:16<12:51,  3.41it/s][Succeeded / Failed / Skipped / Total] 20 / 11 / 27 / 58:   2%|         | 58/2690 [00:17<12:58,  3.38it/s][Succeeded / Failed / Skipped / Total] 20 / 11 / 28 / 59:   2%|         | 59/2690 [00:17<12:46,  3.43it/s][[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int usb_device_delete_addr(int busnr, int addr) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find(busnr); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == addr) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }

[[[[Adv]]]]: int usb_device_delete_addr(int busnr, int addr) { USBBus *bus; USBPort *port; USBDevice *dev; bus = usb_bus_find(busnr); if (!bus) return -1; TAILQ_FOREACH(port, &bus->used, next) { if (port->dev->addr == addr) break; } if (!port) return -1; dev = port->dev; TAILQ_REMOVE(&bus->used, port, next); bus->nused--; usb_attach(port, NULL); dev->info->handle_destroy(dev); TAILQ_INSERT_TAIL(&bus->free, port, next); bus->nfree++; return 0; }
--------------------------------------------- Result 53 ---------------------------------------------
[[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void bt_hci_event_complete_read_local_name(struct bt_hci_s *hci) { read_local_name_rp params; params.status = HCI_SUCCESS; memset(params.name, 0, sizeof(params.name)); if (hci->device.lmp_name) strncpy(params.name, hci->device.lmp_name, sizeof(params.name)); bt_hci_event_complete(hci, &params, READ_LOCAL_NAME_RP_SIZE); }
--------------------------------------------- Result 54 ---------------------------------------------
[[0 (89%)]] --> [[0 (35%)]] --> Socre: 0.645879715681076

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[width]]) { int [[i]]; for([[i]]=0; [[i]]<[[width]]; [[i]]++) { int r= ((uint32_t*)src)[[[i]]]&0xFF; int g= (((uint32_t*)src)[[[i]]]>>8)&0xFF; int b= (((uint32_t*)src)[[[i]]]>>16)&0xFF; dst[[[i]]]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }

[[[[Adv]]]]: static inline void RENAME(rgb32ToY)(uint8_t *dst, uint8_t *src, int [[longitude]]) { int [[am]]; for([[am]]=0; [[am]]<[[longitude]]; [[am]]++) { int r= ((uint32_t*)src)[[[am]]]&0xFF; int g= (((uint32_t*)src)[[[am]]]>>8)&0xFF; int b= (((uint32_t*)src)[[[am]]]>>16)&0xFF; dst[[[am]]]= ((RY*r + GY*g + BY*b + (33<<(RGB2YUV_SHIFT-1)) )>>RGB2YUV_SHIFT); } }
--------------------------------------------- Result 55 ---------------------------------------------
[[0 (11%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *s, bool link_down) { s->nc.link_down = link_down; if (s->nc.peer) { s->nc.peer->link_down = link_down; } if (s->nc.info->link_status_changed) { s->nc.info->link_status_changed(&s->nc); } if (s->nc.peer && s->nc.peer->info->link_status_changed) { s->nc.peer->info->link_status_changed(s->nc.peer); } }

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *s, bool link_down) { s->nc.link_down = link_down; if (s->nc.peer) { s->nc.peer->link_down = link_down; } if (s->nc.info->link_status_changed) { s->nc.info->link_status_changed(&s->nc); } if (s->nc.peer && s->nc.peer->info->link_status_changed) { s->nc.peer->info->link_status_changed(s->nc.peer); } }
--------------------------------------------- Result 56 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int crypto_open(URLContext *h, const char *uri, int flags) { const char *nested_url; int ret; CryptoContext *c = h->priv_data; if (!av_strstart(uri, "crypto+", &nested_url) && !av_strstart(uri, "crypto:", &nested_url)) { av_log(h, AV_LOG_ERROR, "Unsupported url %s\n", uri); ret = AVERROR(EINVAL); goto err; } if (c->keylen < BLOCKSIZE || c->ivlen < BLOCKSIZE) { av_log(h, AV_LOG_ERROR, "Key or IV not set\n"); ret = AVERROR(EINVAL); goto err; } if (flags & AVIO_FLAG_WRITE) { av_log(h, AV_LOG_ERROR, "Only decryption is supported currently\n"); ret = AVERROR(ENOSYS); goto err; } if ((ret = ffurl_open(&c->hd, nested_url, AVIO_FLAG_READ)) < 0) { av_log(h, AV_LOG_ERROR, "Unable to open input\n"); goto err; } c->aes = av_mallocz(av_aes_size); if (!c->aes) { ret = AVERROR(ENOMEM); goto err; } av_aes_init(c->aes, c->key, 128, 1); h->is_streamed = 1; return 0; err: av_free(c->key); av_free(c->iv); return ret; }
--------------------------------------------- Result 57 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int inet_dgram_opts(QemuOpts *opts) { struct addrinfo ai, *peer = NULL, *local = NULL; const char *addr; const char *port; char uaddr[INET6_ADDRSTRLEN+1]; char uport[33]; int sock = -1, rc; memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_CANONNAME | AI_ADDRCONFIG; ai.ai_family = PF_UNSPEC; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "host"); port = qemu_opt_get(opts, "port"); if (addr == NULL || strlen(addr) == 0) { addr = "localhost"; } if (port == NULL || strlen(port) == 0) { fprintf(stderr, "inet_dgram: port not specified\n"); return -1; } if (qemu_opt_get_bool(opts, "ipv4", 0)) ai.ai_family = PF_INET; if (qemu_opt_get_bool(opts, "ipv6", 0)) ai.ai_family = PF_INET6; if (0 != (rc = getaddrinfo(addr, port, &ai, &peer))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: peer (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, peer); } memset(&ai,0, sizeof(ai)); ai.ai_flags = AI_PASSIVE; ai.ai_family = peer->ai_family; ai.ai_socktype = SOCK_DGRAM; addr = qemu_opt_get(opts, "localaddr"); port = qemu_opt_get(opts, "localport"); if (addr == NULL || strlen(addr) == 0) { addr = NULL; } if (!port || strlen(port) == 0) port = "0"; if (0 != (rc = getaddrinfo(addr, port, &ai, &local))) { fprintf(stderr,"getaddrinfo(%s,%s): %s\n", addr, port, gai_strerror(rc)); return -1; } if (sockets_debug) { fprintf(stderr, "%s: local (%s:%s)\n", __FUNCTION__, addr, port); inet_print_addrinfo(__FUNCTION__, local); } sock = socket(peer->ai_family, peer->ai_socktype, peer->ai_protocol); if (sock < 0) { fprintf(stderr,"%s: socket(%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), strerror(errno)); goto err; } setsockopt(sock,SOL_SOCKET,SO_REUSEADDR,(void*)&on,sizeof(on)); if (getnameinfo((struct sockaddr*)local->ai_addr,local->ai_addrlen, uaddr,INET6_ADDRSTRLEN,uport,32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (bind(sock, local->ai_addr, local->ai_addrlen) < 0) { fprintf(stderr,"%s: bind(%s,%s,%d): OK\n", __FUNCTION__, inet_strfamily(local->ai_family), uaddr, inet_getport(local)); goto err; } if (getnameinfo((struct sockaddr*)peer->ai_addr, peer->ai_addrlen, uaddr, INET6_ADDRSTRLEN, uport, 32, NI_NUMERICHOST | NI_NUMERICSERV) != 0) { fprintf(stderr, "%s: getnameinfo: oops\n", __FUNCTION__); goto err; } if (connect(sock,peer->ai_addr,peer->ai_addrlen) < 0) { fprintf(stderr, "%s: connect(%s,%s,%s,%s): %s\n", __FUNCTION__, inet_strfamily(peer->ai_family), peer->ai_canonname, uaddr, uport, strerror(errno)); goto err; } freeaddrinfo(local); freeaddrinfo(peer); return sock; err: if (-1 != sock) closesocket(sock); if (local) freeaddrinfo(local); if (peer) freeaddrinfo(peer); return -1; }
--------------------------------------------- Result 58 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void mem_begin(MemoryListener *listener) { AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener); d->phys_map.ptr = PHYS_MAP_NODE_NIL; }

[[[[Adv]]]]: static void mem_begin(MemoryListener *listener) { AddressSpaceDispatch *d = container_of(listener, AddressSpaceDispatch, listener); d->phys_map.ptr = PHYS_MAP_NODE_NIL; }
--------------------------------------------- Result 59 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static bool vnc_should_update(VncState *vs) { switch (vs->update) { case VNC_STATE_UPDATE_NONE: break; case VNC_STATE_UPDATE_INCREMENTAL: if (!vs->output.offset || vs->audio_cap) { return "True" == "True"; } break; case VNC_STATE_UPDATE_FORCE: return "True" == "True"; } return "False" != "False"; }
[Succeeded / Failed / Skipped / Total] 20 / 11 / 29 / 60:   2%|         | 60/2690 [00:17<12:50,  3.41it/s][Succeeded / Failed / Skipped / Total] 21 / 11 / 29 / 61:   2%|         | 61/2690 [00:18<13:24,  3.27it/s][Succeeded / Failed / Skipped / Total] 22 / 11 / 29 / 62:   2%|         | 62/2690 [00:19<13:48,  3.17it/s][Succeeded / Failed / Skipped / Total] 23 / 11 / 29 / 63:   2%|         | 63/2690 [00:19<13:35,  3.22it/s]--------------------------------------------- Result 60 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint32_t s390_pci_generate_fid(Error **errp) { uint32_t fid = 0; while (fid <= ZPCI_MAX_FID) { if (!s390_pci_find_dev_by_fid(fid)) { return fid; } if (fid == ZPCI_MAX_FID) { break; } fid++; } error_setg(errp, "no free fid could be found"); return 0; }
--------------------------------------------- Result 61 ---------------------------------------------
[[0 (61%)]] --> [[0 (48%)]] --> Socre: 0.5160125494003296

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *[[avctx]]) { HEVCContext *[[s]] = [[avctx]]->priv_data; int i; [[s]]->avctx = [[avctx]]; [[s]]->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[s]]->HEVClc) goto fail; [[s]]->HEVClcList[0] = [[s]]->HEVClc; [[s]]->sList[0] = [[s]]; [[s]]->cabac_state = av_malloc(HEVC_CONTEXTS); if (![[s]]->cabac_state) goto fail; [[s]]->output_frame = av_frame_alloc(); if (![[s]]->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS([[s]]->DPB); i++) { [[s]]->DPB[i].frame = av_frame_alloc(); if (![[s]]->DPB[i].frame) goto fail; [[s]]->DPB[i].tf.f = [[s]]->DPB[i].frame; } [[s]]->max_ra = INT_MAX; [[s]]->md5_ctx = av_md5_alloc(); if (![[s]]->md5_ctx) goto fail; ff_bswapdsp_init(&[[s]]->bdsp); [[s]]->context_initialized = 1; [[s]]->eos = 0; return 0; fail: hevc_decode_free([[avctx]]); return AVERROR(ENOMEM); }

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *[[coxswain]]) { HEVCContext *[[oder]] = [[coxswain]]->priv_data; int i; [[oder]]->avctx = [[coxswain]]; [[oder]]->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[oder]]->HEVClc) goto fail; [[oder]]->HEVClcList[0] = [[oder]]->HEVClc; [[oder]]->sList[0] = [[oder]]; [[oder]]->cabac_state = av_malloc(HEVC_CONTEXTS); if (![[oder]]->cabac_state) goto fail; [[oder]]->output_frame = av_frame_alloc(); if (![[oder]]->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS([[oder]]->DPB); i++) { [[oder]]->DPB[i].frame = av_frame_alloc(); if (![[oder]]->DPB[i].frame) goto fail; [[oder]]->DPB[i].tf.f = [[oder]]->DPB[i].frame; } [[oder]]->max_ra = INT_MAX; [[oder]]->md5_ctx = av_md5_alloc(); if (![[oder]]->md5_ctx) goto fail; ff_bswapdsp_init(&[[oder]]->bdsp); [[oder]]->context_initialized = 1; [[oder]]->eos = 0; return 0; fail: hevc_decode_free([[coxswain]]); return AVERROR(ENOMEM); }
--------------------------------------------- Result 62 ---------------------------------------------
[[0 (18%)]] --> [[0 (53%)]] --> Socre: 0.5263113379478455

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char [[command]][CONTROL_BUFFER_SIZE]; char *[[res]] = NULL; const int size_codes[] = {213, 0}; snprintf([[command]], sizeof([[command]]), "SIZE %s\r\n", s->path); if (ftp_send_command(s, [[command]], size_codes, &[[res]])) { s->filesize = strtoll(&[[res]][4], NULL, 10); } else { s->filesize = -1; av_free([[res]]); return AVERROR(EIO); } av_free([[res]]); return 0; }

[[[[Adv]]]]: static int ftp_file_size(FTPContext *s) { char [[skipper]][CONTROL_BUFFER_SIZE]; char *[[absolutely]] = NULL; const int size_codes[] = {213, 0}; snprintf([[skipper]], sizeof([[skipper]]), "SIZE %s\r\n", s->path); if (ftp_send_command(s, [[skipper]], size_codes, &[[absolutely]])) { s->filesize = strtoll(&[[absolutely]][4], NULL, 10); } else { s->filesize = -1; av_free([[absolutely]]); return AVERROR(EIO); } av_free([[absolutely]]); return 0; }
--------------------------------------------- Result 63 ---------------------------------------------
[[0 (58%)]] --> [[0 (49%)]] --> Socre: 0.5072143077850342

[[[[Adv]]]]: int ff_alloc_entries(AVCodecContext *avctx, int [[count]]) { int [[i]]; if (avctx->active_thread_type & FF_THREAD_SLICE) { SliceThreadContext *[[p]] = avctx->internal->thread_ctx; [[p]]->thread_count = avctx->thread_count; [[p]]->entries = av_mallocz_array([[count]], sizeof(int)); if (![[p]]->entries) { return AVERROR(ENOMEM); } [[p]]->entries_count = [[count]]; [[p]]->progress_mutex = av_malloc_array([[p]]->thread_count, sizeof(pthread_mutex_t)); [[p]]->progress_cond = av_malloc_array([[p]]->thread_count, sizeof(pthread_cond_t)); for ([[i]] = 0; [[i]] < [[p]]->thread_count; [[i]]++) { pthread_mutex_init(&[[p]]->progress_mutex[[[i]]], NULL); pthread_cond_init(&[[p]]->progress_cond[[[i]]], NULL); } } return 0; }

[[[[Adv]]]]: int ff_alloc_entries(AVCodecContext *avctx, int [[tells]]) { int [[yo]]; if (avctx->active_thread_type & FF_THREAD_SLICE) { SliceThreadContext *[[bp]] = avctx->internal->thread_ctx; [[bp]]->thread_count = avctx->thread_count; [[bp]]->entries = av_mallocz_array([[tells]], sizeof(int)); if (![[bp]]->entries) { return AVERROR(ENOMEM); } [[bp]]->entries_count = [[tells]]; [[bp]]->progress_mutex = av_malloc_array([[bp]]->thread_count, sizeof(pthread_mutex_t)); [[bp]]->progress_cond = av_malloc_array([[bp]]->thread_count, sizeof(pthread_cond_t)); for ([[yo]] = 0; [[yo]] < [[bp]]->thread_count; [[yo]]++) { pthread_mutex_init(&[[bp]]->progress_mutex[[[yo]]], NULL); pthread_cond_init(&[[bp]]->progress_cond[[[yo]]], NULL); } } return 0; }
--------------------------------------------- Result 64 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 11 / 30 / 64:   2%|         | 64/2690 [00:19<13:22,  3.27it/s][Succeeded / Failed / Skipped / Total] 23 / 11 / 31 / 65:   2%|         | 65/2690 [00:19<13:10,  3.32it/s][Succeeded / Failed / Skipped / Total] 23 / 11 / 31 / 65:   2%|         | 66/2690 [00:20<13:53,  3.15it/s][Succeeded / Failed / Skipped / Total] 24 / 11 / 31 / 66:   2%|         | 66/2690 [00:20<13:53,  3.15it/s][Succeeded / Failed / Skipped / Total] 24 / 11 / 32 / 67:   2%|         | 67/2690 [00:21<13:53,  3.15it/s][Succeeded / Failed / Skipped / Total] 24 / 11 / 33 / 68:   3%|         | 68/2690 [00:21<13:41,  3.19it/s][[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void build_feed_streams(void) { FFStream *stream, *feed; int i; for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (!stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = add_av_stream(feed, stream->streams[i]); } } } for(stream = first_stream; stream != NULL; stream = stream->next) { feed = stream->feed; if (feed) { if (stream->is_feed) { for(i=0;i<stream->nb_streams;i++) stream->feed_streams[i] = i; } } } for(feed = first_feed; feed != NULL; feed = feed->next_feed) { int fd; if (url_exist(feed->feed_filename)) { AVFormatContext *s; int matches = 0; if (av_open_input_file(&s, feed->feed_filename, NULL, FFM_PACKET_SIZE, NULL) >= 0) { if (s->nb_streams == feed->nb_streams) { matches = 1; for(i=0;i<s->nb_streams;i++) { AVStream *sf, *ss; sf = feed->streams[i]; ss = s->streams[i]; if (sf->index != ss->index || sf->id != ss->id) { http_log("Index & Id do not match for stream %d (%s)\n", i, feed->feed_filename); matches = 0; } else { AVCodecContext *ccf, *ccs; ccf = sf->codec; ccs = ss->codec; #define CHECK_CODEC(x) (ccf->x != ccs->x) if (CHECK_CODEC(codec_id) || CHECK_CODEC(codec_type)) { http_log("Codecs do not match for stream %d\n", i); matches = 0; } else if (CHECK_CODEC(bit_rate) || CHECK_CODEC(flags)) { http_log("Codec bitrates do not match for stream %d\n", i); matches = 0; } else if (ccf->codec_type == AVMEDIA_TYPE_VIDEO) { if (CHECK_CODEC(time_base.den) || CHECK_CODEC(time_base.num) || CHECK_CODEC(width) || CHECK_CODEC(height)) { http_log("Codec width, height and framerate do not match for stream %d\n", i); matches = 0; } } else if (ccf->codec_type == AVMEDIA_TYPE_AUDIO) { if (CHECK_CODEC(sample_rate) || CHECK_CODEC(channels) || CHECK_CODEC(frame_size)) { http_log("Codec sample_rate, channels, frame_size do not match for stream %d\n", i); matches = 0; } } else { http_log("Unknown codec type\n"); matches = 0; } } if (!matches) break; } } else http_log("Deleting feed file '%s' as stream counts differ (%d != %d)\n", feed->feed_filename, s->nb_streams, feed->nb_streams); av_close_input_file(s); } else http_log("Deleting feed file '%s' as it appears to be corrupt\n", feed->feed_filename); if (!matches) { if (feed->readonly) { http_log("Unable to delete feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } unlink(feed->feed_filename); } } if (!url_exist(feed->feed_filename)) { AVFormatContext s1 = {0}, *s = &s1; if (feed->readonly) { http_log("Unable to create feed file '%s' as it is marked readonly\n", feed->feed_filename); exit(1); } if (avio_open(&s->pb, feed->feed_filename, AVIO_FLAG_WRITE) < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } s->oformat = feed->fmt; s->nb_streams = feed->nb_streams; for(i=0;i<s->nb_streams;i++) { AVStream *st; st = feed->streams[i]; s->streams[i] = st; } av_set_parameters(s, NULL); if (av_write_header(s) < 0) { http_log("Container doesn't supports the required parameters\n"); exit(1); } av_freep(&s->priv_data); avio_close(s->pb); } fd = open(feed->feed_filename, O_RDONLY); if (fd < 0) { http_log("Could not open output feed file '%s'\n", feed->feed_filename); exit(1); } feed->feed_write_index = FFMAX(ffm_read_write_index(fd), FFM_PACKET_SIZE); feed->feed_size = lseek(fd, 0, SEEK_END); if (feed->feed_max_size && feed->feed_max_size < feed->feed_size) feed->feed_max_size = feed->feed_size; close(fd); } }
--------------------------------------------- Result 65 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_qemu_strtoll_whitespace(void) { const char *str = " \t "; char f = 'X'; const char *endptr = &f; int64_t res = 999; int err; err = qemu_strtoll(str, &endptr, 0, &res); g_assert_cmpint(err, ==, 0); g_assert_cmpint(res, ==, 0); g_assert(endptr == str); }
--------------------------------------------- Result 66 ---------------------------------------------
[[0 (18%)]] --> [[0 (56%)]] --> Socre: 0.563858151435852

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **[[errp]]) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *[[v]] = VIRTIO_9P(dev); V9fsState *s = &[[v]]->state; virtio_cleanup(vdev); v9fs_device_unrealize_common(s, [[errp]]); }

[[[[Adv]]]]: static void virtio_9p_device_unrealize(DeviceState *dev, Error **[[remuneration]]) { VirtIODevice *vdev = VIRTIO_DEVICE(dev); V9fsVirtioState *[[across]] = VIRTIO_9P(dev); V9fsState *s = &[[across]]->state; virtio_cleanup(vdev); v9fs_device_unrealize_common(s, [[remuneration]]); }
--------------------------------------------- Result 67 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcg_out_qemu_ld(TCGContext *s, const TCGArg *args, bool is_64) { TCGReg datalo, datahi, addrlo, rbase; TCGReg addrhi __attribute__((unused)); TCGMemOpIdx oi; TCGMemOp opc, s_bits; #ifdef CONFIG_SOFTMMU int mem_index; tcg_insn_unit *label_ptr; #endif datalo = *args++; datahi = (TCG_TARGET_REG_BITS == 32 && is_64 ? *args++ : 0); addrlo = *args++; addrhi = (TCG_TARGET_REG_BITS < TARGET_LONG_BITS ? *args++ : 0); oi = *args++; opc = get_memop(oi); s_bits = opc & MO_SIZE; #ifdef CONFIG_SOFTMMU mem_index = get_mmuidx(oi); addrlo = tcg_out_tlb_read(s, s_bits, addrlo, addrhi, mem_index, "True" == "True"); label_ptr = s->code_ptr; tcg_out_bc_noaddr(s, BC | BI(7, CR_EQ) | BO_COND_FALSE | LK); rbase = TCG_REG_R3; #else rbase = GUEST_BASE ? TCG_GUEST_BASE_REG : 0; if (TCG_TARGET_REG_BITS > TARGET_LONG_BITS) { tcg_out_ext32u(s, TCG_REG_TMP1, addrlo); addrlo = TCG_REG_TMP1; } #endif if (TCG_TARGET_REG_BITS == 32 && s_bits == MO_64) { if (opc & MO_BSWAP) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(datahi, rbase, TCG_REG_R0)); } else if (rbase != 0) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWZX | TAB(datahi, rbase, addrlo)); tcg_out32(s, LWZX | TAB(datalo, rbase, TCG_REG_R0)); } else if (addrlo == datahi) { tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); } else { tcg_out32(s, LWZ | TAI(datahi, addrlo, 0)); tcg_out32(s, LWZ | TAI(datalo, addrlo, 4)); } } else { uint32_t insn = qemu_ldx_opc[opc & (MO_BSWAP | MO_SSIZE)]; if (!HAVE_ISA_2_06 && insn == LDBRX) { tcg_out32(s, ADDI | TAI(TCG_REG_R0, addrlo, 4)); tcg_out32(s, LWBRX | TAB(datalo, rbase, addrlo)); tcg_out32(s, LWBRX | TAB(TCG_REG_R0, rbase, TCG_REG_R0)); tcg_out_rld(s, RLDIMI, datalo, TCG_REG_R0, 32, 0); } else if (insn) { tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); } else { insn = qemu_ldx_opc[opc & (MO_SIZE | MO_BSWAP)]; tcg_out32(s, insn | TAB(datalo, rbase, addrlo)); insn = qemu_exts_opc[s_bits]; tcg_out32(s, insn | RA(datalo) | RS(datalo)); } } #ifdef CONFIG_SOFTMMU add_qemu_ldst_label(s, "True" == "True", oi, datalo, datahi, addrlo, addrhi, s->code_ptr, label_ptr); #endif }
--------------------------------------------- Result 68 ---------------------------------------------
[[0 (22%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static MemTxResult vtd_mem_ir_write(void *opaque, hwaddr addr, uint64_t value, unsigned size, MemTxAttrs attrs) { int ret = 0; MSIMessage from = {0}, to = {0}; from.address = (uint64_t) addr + VTD_INTERRUPT_ADDR_FIRST; from.data = (uint32_t) value; ret = vtd_interrupt_remap_msi(opaque, &from, &to); if (ret) { VTD_DPRINTF(GENERAL, "int remap fail for addr 0x%"PRIx64 " data 0x%"PRIx32, from.address, from.data); return MEMTX_ERROR; } VTD_DPRINTF(IR, "delivering MSI 0x%"PRIx64":0x%"PRIx32 " for device sid 0x%04x", to.address, to.data, sid); if (dma_memory_write(&address_space_memory, to.address, &to.data, size)) { VTD_DPRINTF(GENERAL, "error: fail to write 0x%"PRIx64 " value 0x%"PRIx32, to.address, to.data); } return MEMTX_OK; }
--------------------------------------------- Result 69 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 11 / 33 / 69:   3%|         | 69/2690 [00:21<13:33,  3.22it/s][Succeeded / Failed / Skipped / Total] 25 / 11 / 34 / 70:   3%|         | 70/2690 [00:21<13:40,  3.19it/s][Succeeded / Failed / Skipped / Total] 25 / 11 / 35 / 71:   3%|         | 71/2690 [00:22<13:45,  3.17it/s][Succeeded / Failed / Skipped / Total] 26 / 11 / 35 / 72:   3%|         | 72/2690 [00:22<13:37,  3.20it/s][[0 (26%)]] --> [[0 (52%)]] --> Socre: 0.5190119743347168

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *[[env]], const mips_def_t *def) { int i; for (i = 0; i < MIPS_FPU_MAX; i++) [[env]]->fpus[i].fcr0 = def->CP1_fcr0; memcpy(&[[env]]->active_fpu, &[[env]]->fpus[0], sizeof([[env]]->active_fpu)); if ([[env]]->user_mode_only) { if ([[env]]->CP0_Config1 & (1 << CP0C1_FP)) [[env]]->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if ([[env]]->active_fpu.fcr0 & (1 << FCR0_F64)) [[env]]->hflags |= MIPS_HFLAG_F64; #endif } }

[[[[Adv]]]]: static void fpu_init (CPUMIPSState *[[testing]], const mips_def_t *def) { int i; for (i = 0; i < MIPS_FPU_MAX; i++) [[testing]]->fpus[i].fcr0 = def->CP1_fcr0; memcpy(&[[testing]]->active_fpu, &[[testing]]->fpus[0], sizeof([[testing]]->active_fpu)); if ([[testing]]->user_mode_only) { if ([[testing]]->CP0_Config1 & (1 << CP0C1_FP)) [[testing]]->hflags |= MIPS_HFLAG_FPU; #ifdef TARGET_MIPS64 if ([[testing]]->active_fpu.fcr0 & (1 << FCR0_F64)) [[testing]]->hflags |= MIPS_HFLAG_F64; #endif } }
--------------------------------------------- Result 70 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_interrupt64(CPUX86State *env, int intno, int is_int, int error_code, target_ulong next_eip, int is_hw) { SegmentCache *dt; target_ulong ptr; int type, dpl, selector, cpl, ist; int has_error_code, new_stack; uint32_t e1, e2, e3, ss; target_ulong old_eip, esp, offset; has_error_code = 0; if (!is_int && !is_hw) { has_error_code = exception_has_error_code(intno); } if (is_int) { old_eip = next_eip; } else { old_eip = env->eip; } dt = &env->idt; if (intno * 16 + 15 > dt->limit) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } ptr = dt->base + intno * 16; e1 = cpu_ldl_kernel(env, ptr); e2 = cpu_ldl_kernel(env, ptr + 4); e3 = cpu_ldl_kernel(env, ptr + 8); type = (e2 >> DESC_TYPE_SHIFT) & 0x1f; switch (type) { case 14: case 15: break; default: raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); break; } dpl = (e2 >> DESC_DPL_SHIFT) & 3; cpl = env->hflags & HF_CPL_MASK; if (is_int && dpl < cpl) { raise_exception_err(env, EXCP0D_GPF, intno * 16 + 2); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, intno * 16 + 2); } selector = e1 >> 16; offset = ((target_ulong)e3 << 32) | (e2 & 0xffff0000) | (e1 & 0x0000ffff); ist = e2 & 7; if ((selector & 0xfffc) == 0) { raise_exception_err(env, EXCP0D_GPF, 0); } if (load_segment(env, &e1, &e2, selector) != 0) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_S_MASK) || !(e2 & (DESC_CS_MASK))) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } dpl = (e2 >> DESC_DPL_SHIFT) & 3; if (dpl > cpl) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if (!(e2 & DESC_P_MASK)) { raise_exception_err(env, EXCP0B_NOSEG, selector & 0xfffc); } if (!(e2 & DESC_L_MASK) || (e2 & DESC_B_MASK)) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } if ((!(e2 & DESC_C_MASK) && dpl < cpl) || ist != 0) { new_stack = 1; esp = get_rsp_from_tss(env, ist != 0 ? ist + 3 : dpl); ss = 0; } else if ((e2 & DESC_C_MASK) || dpl == cpl) { if (env->eflags & VM_MASK) { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); } new_stack = 0; esp = env->regs[R_ESP]; dpl = cpl; } else { raise_exception_err(env, EXCP0D_GPF, selector & 0xfffc); new_stack = 0; esp = 0; } esp &= ~0xfLL; PUSHQ(esp, env->segs[R_SS].selector); PUSHQ(esp, env->regs[R_ESP]); PUSHQ(esp, cpu_compute_eflags(env)); PUSHQ(esp, env->segs[R_CS].selector); PUSHQ(esp, old_eip); if (has_error_code) { PUSHQ(esp, error_code); } if ((type & 1) == 0) { env->eflags &= ~IF_MASK; } env->eflags &= ~(TF_MASK | VM_MASK | RF_MASK | NT_MASK); if (new_stack) { ss = 0 | dpl; cpu_x86_load_seg_cache(env, R_SS, ss, 0, 0, 0); } env->regs[R_ESP] = esp; selector = (selector & ~3) | dpl; cpu_x86_load_seg_cache(env, R_CS, selector, get_seg_base(e1, e2), get_seg_limit(e1, e2), e2); env->eip = offset; }
--------------------------------------------- Result 71 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_migrate(void) { char *uri = g_strdup_printf("unix:%s/migsocket", tmpfs); QTestState *global = global_qtest, *from, *to; unsigned char dest_byte_a, dest_byte_b, dest_byte_c, dest_byte_d; gchar *cmd; QDict *rsp; char *bootpath = g_strdup_printf("%s/bootsect", tmpfs); FILE *bootfile = fopen(bootpath, "wb"); got_stop = "False" != "False"; g_assert_cmpint(fwrite(bootsect, 512, 1, bootfile), ==, 1); fclose(bootfile); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcsource,debug-threads=on" " -serial file:%s/src_serial" " -drive file=%s,format=raw", tmpfs, bootpath); from = qtest_start(cmd); g_free(cmd); cmd = g_strdup_printf("-machine accel=kvm:tcg -m 150M" " -name pcdest,debug-threads=on" " -serial file:%s/dest_serial" " -drive file=%s,format=raw" " -incoming %s", tmpfs, bootpath, uri); to = qtest_init(cmd); g_free(cmd); global_qtest = from; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = to; rsp = qmp("{ 'execute': 'migrate-set-capabilities'," "'arguments': { " "'capabilities': [ {" "'capability': 'postcopy-ram'," "'state': true } ] } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); global_qtest = from; rsp = qmp("{ 'execute': 'migrate_set_speed'," "'arguments': { 'value': 100000000 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); rsp = qmp("{ 'execute': 'migrate_set_downtime'," "'arguments': { 'value': 0.001 } }"); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_serial("src_serial"); cmd = g_strdup_printf("{ 'execute': 'migrate'," "'arguments': { 'uri': '%s' } }", uri); rsp = qmp(cmd); g_free(cmd); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); wait_for_migration_pass(); rsp = return_or_event(qmp("{ 'execute': 'migrate-start-postcopy' }")); g_assert(qdict_haskey(rsp, "return")); QDECREF(rsp); if (!got_stop) { qmp_eventwait("STOP"); } global_qtest = to; qmp_eventwait("RESUME"); wait_for_serial("dest_serial"); global_qtest = from; wait_for_migration_complete(); qtest_quit(from); global_qtest = to; qtest_memread(to, start_address, &dest_byte_a, 1); do { qtest_memread(to, start_address, &dest_byte_b, 1); usleep(10 * 1000); } while (dest_byte_a == dest_byte_b); qmp("{ 'execute' : 'stop'}"); qtest_memread(to, start_address, &dest_byte_c, 1); sleep(1); qtest_memread(to, start_address, &dest_byte_d, 1); g_assert_cmpint(dest_byte_c, ==, dest_byte_d); check_guests_ram(); qtest_quit(to); g_free(uri); global_qtest = global; cleanup("bootsect"); cleanup("migsocket"); cleanup("src_serial"); cleanup("dest_serial"); }
--------------------------------------------- Result 72 ---------------------------------------------
[[0 (20%)]] --> [[0 (52%)]] --> Socre: 0.5245452523231506

[[[[Adv]]]]: static inline void gen_neon_widen(TCGv [[dest]], TCGv [[src]], int size, int [[u]]) { if ([[u]]) { switch (size) { case 0: gen_helper_neon_widen_u8([[dest]], [[src]]); break; case 1: gen_helper_neon_widen_u16([[dest]], [[src]]); break; case 2: tcg_gen_extu_i32_i64([[dest]], [[src]]); break; default: abort(); } } else { switch (size) { case 0: gen_helper_neon_widen_s8([[dest]], [[src]]); break; case 1: gen_helper_neon_widen_s16([[dest]], [[src]]); break; case 2: tcg_gen_ext_i32_i64([[dest]], [[src]]); break; default: abort(); } } dead_tmp([[src]]); }

[[[[Adv]]]]: static inline void gen_neon_widen(TCGv [[people]], TCGv [[junko]], int size, int [[neither]]) { if ([[neither]]) { switch (size) { case 0: gen_helper_neon_widen_u8([[people]], [[junko]]); break; case 1: gen_helper_neon_widen_u16([[people]], [[junko]]); break; case 2: tcg_gen_extu_i32_i64([[people]], [[junko]]); break; default: abort(); } } else { switch (size) { case 0: gen_helper_neon_widen_s8([[people]], [[junko]]); break; case 1: gen_helper_neon_widen_s16([[people]], [[junko]]); break; case 2: tcg_gen_ext_i32_i64([[people]], [[junko]]); break; default: abort(); } } dead_tmp([[junko]]); }
[Succeeded / Failed / Skipped / Total] 26 / 11 / 36 / 73:   3%|         | 73/2690 [00:22<13:37,  3.20it/s][Succeeded / Failed / Skipped / Total] 26 / 11 / 37 / 74:   3%|         | 74/2690 [00:23<13:42,  3.18it/s]--------------------------------------------- Result 73 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h264_decode_ref_pic_marking(const H264Context *h, H264SliceContext *sl, GetBitContext *gb) { int i; MMCO *mmco = sl->mmco; int nb_mmco = 0; if (h->nal_unit_type == NAL_IDR_SLICE) { skip_bits1(gb); if (get_bits1(gb)) { mmco[0].opcode = MMCO_LONG; mmco[0].long_arg = 0; nb_mmco = 1; } sl->explicit_ref_marking = 1; } else { sl->explicit_ref_marking = get_bits1(gb); if (sl->explicit_ref_marking) { for (i = 0; i < MAX_MMCO_COUNT; i++) { MMCOOpcode opcode = get_ue_golomb_31(gb); mmco[i].opcode = opcode; if (opcode == MMCO_SHORT2UNUSED || opcode == MMCO_SHORT2LONG) { mmco[i].short_pic_num = (sl->curr_pic_num - get_ue_golomb(gb) - 1) & (sl->max_pic_num - 1); #if 0 if (mmco[i].short_pic_num >= h->short_ref_count || !h->short_ref[mmco[i].short_pic_num]) { av_log(s->avctx, AV_LOG_ERROR, "illegal short ref in memory management control " "operation %d\n", mmco); return -1; } #endif } if (opcode == MMCO_SHORT2LONG || opcode == MMCO_LONG2UNUSED || opcode == MMCO_LONG || opcode == MMCO_SET_MAX_LONG) { unsigned int long_arg = get_ue_golomb_31(gb); if (long_arg >= 32 || (long_arg >= 16 && !(opcode == MMCO_SET_MAX_LONG && long_arg == 16) && !(opcode == MMCO_LONG2UNUSED && FIELD_PICTURE(h)))) { av_log(h->avctx, AV_LOG_ERROR, "illegal long ref in memory management control " "operation %d\n", opcode); return -1; } mmco[i].long_arg = long_arg; } if (opcode > (unsigned) MMCO_LONG) { av_log(h->avctx, AV_LOG_ERROR, "illegal memory management control operation %d\n", opcode); return -1; } if (opcode == MMCO_END) break; } nb_mmco = i; } } sl->nb_mmco = nb_mmco; return 0; }
--------------------------------------------- Result 74 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int opus_decode_frame(OpusStreamContext *s, const uint8_t *data, int size) { int samples = s->packet.frame_duration; int redundancy = 0; int redundancy_size, redundancy_pos; int ret, i, consumed; int delayed_samples = s->delayed_samples; ret = opus_rc_init(&s->rc, data, size); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_SILK || s->packet.mode == OPUS_MODE_HYBRID) { if (!swr_is_initialized(s->swr)) { ret = opus_init_resample(s); if (ret < 0) return ret; } samples = ff_silk_decode_superframe(s->silk, &s->rc, s->silk_output, FFMIN(s->packet.bandwidth, OPUS_BANDWIDTH_WIDEBAND), s->packet.stereo + 1, silk_frame_duration_ms[s->packet.config]); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error decoding a SILK frame.\n"); return samples; } samples = swr_convert(s->swr, (uint8_t**)s->out, s->packet.frame_duration, (const uint8_t**)s->silk_output, samples); if (samples < 0) { av_log(s->avctx, AV_LOG_ERROR, "Error resampling SILK data.\n"); return samples; } s->delayed_samples += s->packet.frame_duration - samples; } else ff_silk_flush(s->silk); consumed = opus_rc_tell(&s->rc); if (s->packet.mode == OPUS_MODE_HYBRID && consumed + 37 <= size * 8) redundancy = opus_rc_p2model(&s->rc, 12); else if (s->packet.mode == OPUS_MODE_SILK && consumed + 17 <= size * 8) redundancy = 1; if (redundancy) { redundancy_pos = opus_rc_p2model(&s->rc, 1); if (s->packet.mode == OPUS_MODE_HYBRID) redundancy_size = opus_rc_unimodel(&s->rc, 256) + 2; else redundancy_size = size - (consumed + 7) / 8; size -= redundancy_size; if (size < 0) { av_log(s->avctx, AV_LOG_ERROR, "Invalid redundancy frame size.\n"); return AVERROR_INVALIDDATA; } if (redundancy_pos) { ret = opus_decode_redundancy(s, data + size, redundancy_size); if (ret < 0) return ret; ff_celt_flush(s->celt); } } if (s->packet.mode == OPUS_MODE_CELT || s->packet.mode == OPUS_MODE_HYBRID) { float *out_tmp[2] = { s->out[0], s->out[1] }; float **dst = (s->packet.mode == OPUS_MODE_CELT) ? out_tmp : s->celt_output; int celt_output_samples = samples; int delay_samples = av_audio_fifo_size(s->celt_delay); if (delay_samples) { if (s->packet.mode == OPUS_MODE_HYBRID) { av_audio_fifo_read(s->celt_delay, (void**)s->celt_output, delay_samples); for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, delay_samples); out_tmp[i] += delay_samples; } celt_output_samples -= delay_samples; } else { av_log(s->avctx, AV_LOG_WARNING, "Spurious CELT delay samples present.\n"); av_audio_fifo_drain(s->celt_delay, delay_samples); if (s->avctx->err_recognition & AV_EF_EXPLODE) return AVERROR_BUG; } } opus_raw_init(&s->rc, data + size, size); ret = ff_celt_decode_frame(s->celt, &s->rc, dst, s->packet.stereo + 1, s->packet.frame_duration, (s->packet.mode == OPUS_MODE_HYBRID) ? 17 : 0, celt_band_end[s->packet.bandwidth]); if (ret < 0) return ret; if (s->packet.mode == OPUS_MODE_HYBRID) { int celt_delay = s->packet.frame_duration - celt_output_samples; void *delaybuf[2] = { s->celt_output[0] + celt_output_samples, s->celt_output[1] + celt_output_samples }; for (i = 0; i < s->output_channels; i++) { s->fdsp->vector_fmac_scalar(out_tmp[i], s->celt_output[i], 1.0, celt_output_samples); } ret = av_audio_fifo_write(s->celt_delay, delaybuf, celt_delay); if (ret < 0) return ret; } } else ff_celt_flush(s->celt); if (s->redundancy_idx) { for (i = 0; i < s->output_channels; i++) opus_fade(s->out[i], s->out[i], s->redundancy_output[i] + 120 + s->redundancy_idx, ff_celt_window2 + s->redundancy_idx, 120 - s->redundancy_idx); s->redundancy_idx = 0; } if (redundancy) { if (!redundancy_pos) { ff_celt_flush(s->celt); ret = opus_decode_redundancy(s, data + size, redundancy_size); if (ret < 0) return ret; for (i = 0; i < s->output_channels; i++) { opus_fade(s->out[i] + samples - 120 + delayed_samples, s->out[i] + samples - 120 + delayed_samples, s->redundancy_output[i] + 120, ff_celt_window2, 120 - delayed_samples); if (delayed_samples) s->redundancy_idx = 120 - delayed_samples; } } else { for (i = 0; i < s->output_channels; i++) { memcpy(s->out[i] + delayed_samples, s->redundancy_output[i], 120 * sizeof(float)); opus_fade(s->out[i] + 120 + delayed_samples, s->redundancy_output[i] + 120, s->out[i] + 120 + delayed_samples, ff_celt_window2, 120); } } } return samples; }
--------------------------------------------- Result 75 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 11 / 37 / 75:   3%|         | 75/2690 [00:25<14:39,  2.97it/s][Succeeded / Failed / Skipped / Total] 28 / 11 / 37 / 76:   3%|         | 76/2690 [00:26<15:10,  2.87it/s][Succeeded / Failed / Skipped / Total] 28 / 11 / 37 / 76:   3%|         | 77/2690 [00:26<14:59,  2.90it/s][Succeeded / Failed / Skipped / Total] 28 / 12 / 37 / 77:   3%|         | 77/2690 [00:26<14:59,  2.90it/s][[0 (27%)]] --> [[0 (51%)]] --> Socre: 0.5096769332885742

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *[[conf]], char **[[serial]]) { VirtIOBlock *[[s]]; int [[cylinders]], heads, secs; static int virtio_blk_id; DriveInfo *[[dinfo]]; if (![[conf]]->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted([[conf]]->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*[[serial]]) { [[dinfo]] = drive_get_by_blockdev([[conf]]->bs); if (*[[dinfo]]->serial) { *[[serial]] = strdup([[dinfo]]->serial); } } [[s]] = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); [[s]]->vdev.get_config = virtio_blk_update_config; [[s]]->vdev.get_features = virtio_blk_get_features; [[s]]->vdev.reset = virtio_blk_reset; [[s]]->bs = [[conf]]->bs; [[s]]->conf = [[conf]]; [[s]]->serial = *[[serial]]; [[s]]->rq = NULL; [[s]]->sector_mask = ([[s]]->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry([[s]]->bs, &[[cylinders]], &heads, &secs); [[s]]->vq = virtio_add_queue(&[[s]]->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, [[s]]); [[s]]->qdev = dev; register_savevm(dev, "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, [[s]]); bdrv_set_dev_ops([[s]]->bs, &virtio_block_ops, [[s]]); bdrv_set_buffer_alignment([[s]]->bs, [[conf]]->logical_block_size); bdrv_iostatus_enable([[s]]->bs); add_boot_device_path([[conf]]->bootindex, dev, "/disk@0,0"); return &[[s]]->vdev; }

[[[[Adv]]]]: VirtIODevice *virtio_blk_init(DeviceState *dev, BlockConf *[[exec]], char **[[spectra]]) { VirtIOBlock *[[o]]; int [[vases]], heads, secs; static int virtio_blk_id; DriveInfo *[[klunk]]; if (![[exec]]->bs) { error_report("virtio-blk-pci: drive property not set"); return NULL; } if (!bdrv_is_inserted([[exec]]->bs)) { error_report("Device needs media, but drive is empty"); return NULL; } if (!*[[spectra]]) { [[klunk]] = drive_get_by_blockdev([[exec]]->bs); if (*[[klunk]]->serial) { *[[spectra]] = strdup([[klunk]]->serial); } } [[o]] = (VirtIOBlock *)virtio_common_init("virtio-blk", VIRTIO_ID_BLOCK, sizeof(struct virtio_blk_config), sizeof(VirtIOBlock)); [[o]]->vdev.get_config = virtio_blk_update_config; [[o]]->vdev.get_features = virtio_blk_get_features; [[o]]->vdev.reset = virtio_blk_reset; [[o]]->bs = [[exec]]->bs; [[o]]->conf = [[exec]]; [[o]]->serial = *[[spectra]]; [[o]]->rq = NULL; [[o]]->sector_mask = ([[o]]->conf->logical_block_size / BDRV_SECTOR_SIZE) - 1; bdrv_guess_geometry([[o]]->bs, &[[vases]], &heads, &secs); [[o]]->vq = virtio_add_queue(&[[o]]->vdev, 128, virtio_blk_handle_output); qemu_add_vm_change_state_handler(virtio_blk_dma_restart_cb, [[o]]); [[o]]->qdev = dev; register_savevm(dev, "virtio-blk", virtio_blk_id++, 2, virtio_blk_save, virtio_blk_load, [[o]]); bdrv_set_dev_ops([[o]]->bs, &virtio_block_ops, [[o]]); bdrv_set_buffer_alignment([[o]]->bs, [[exec]]->logical_block_size); bdrv_iostatus_enable([[o]]->bs); add_boot_device_path([[exec]]->bootindex, dev, "/disk@0,0"); return &[[o]]->vdev; }
--------------------------------------------- Result 76 ---------------------------------------------
[[0 (69%)]] --> [[0 (48%)]] --> Socre: 0.5249770879745483

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *[[avctx]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *[[buf]] = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *[[bfi]] = [[avctx]]->priv_data; uint8_t *[[dst]] = [[bfi]]->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = [[bfi]]->dst + [[avctx]]->width * [[avctx]]->height; uint32_t *[[pal]]; int i, j, height = [[avctx]]->height; if ([[bfi]]->frame.data[0]) [[avctx]]->release_buffer([[avctx]], &[[bfi]]->frame); [[bfi]]->frame.reference = 1; if ([[avctx]]->get_buffer([[avctx]], &[[bfi]]->frame) < 0) { av_log([[avctx]], AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (![[avctx]]->frame_number) { [[bfi]]->frame.pict_type = AV_PICTURE_TYPE_I; [[bfi]]->frame.key_frame = 1; if ([[avctx]]->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } [[pal]] = (uint32_t *)[[bfi]]->frame.data[1]; for (i = 0; i < [[avctx]]->extradata_size / 3; i++) { int shift = 16; *[[pal]] = 0; for (j = 0; j < 3; j++, shift -= 8) *[[pal]] += (([[avctx]]->extradata[i * 3 + j] << 2) | ([[avctx]]->extradata[i * 3 + j] >> 4)) << shift; [[pal]]++; } [[bfi]]->frame.palette_has_changed = 1; } else { [[bfi]]->frame.pict_type = AV_PICTURE_TYPE_P; [[bfi]]->frame.key_frame = 0; } [[buf]] += 4; while ([[dst]] != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *[[buf]]++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if ([[buf]] >= buf_end) { av_log([[avctx]], AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&[[buf]]); offset = bytestream_get_le16(&[[buf]]); } else { length = bytestream_get_le16(&[[buf]]); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&[[buf]]); } if ([[dst]] + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - [[buf]]) { av_log([[avctx]], AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&[[buf]], [[dst]], length); [[dst]] += length; break; case 1: dst_offset = [[dst]] - offset; length *= 4; if (dst_offset < [[bfi]]->dst) break; while (length--) *[[dst]]++ = *dst_offset++; break; case 2: [[dst]] += length; break; case 3: colour1 = bytestream_get_byte(&[[buf]]); colour2 = bytestream_get_byte(&[[buf]]); while (length--) { *[[dst]]++ = colour1; *[[dst]]++ = colour2; } break; } } src = [[bfi]]->dst; [[dst]] = [[bfi]]->frame.data[0]; while (height--) { memcpy([[dst]], src, [[avctx]]->width); src += [[avctx]]->width; [[dst]] += [[bfi]]->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)data = [[bfi]]->frame; return buf_size; }

[[[[Adv]]]]: static int bfi_decode_frame(AVCodecContext *[[bongs]], void *data, int *data_size, AVPacket *avpkt) { const uint8_t *[[trujillo]] = avpkt->data, *buf_end = avpkt->data + avpkt->size; int buf_size = avpkt->size; BFIContext *[[ini]] = [[bongs]]->priv_data; uint8_t *[[sti]] = [[ini]]->dst; uint8_t *src, *dst_offset, colour1, colour2; uint8_t *frame_end = [[ini]]->dst + [[bongs]]->width * [[bongs]]->height; uint32_t *[[playmate]]; int i, j, height = [[bongs]]->height; if ([[ini]]->frame.data[0]) [[bongs]]->release_buffer([[bongs]], &[[ini]]->frame); [[ini]]->frame.reference = 1; if ([[bongs]]->get_buffer([[bongs]], &[[ini]]->frame) < 0) { av_log([[bongs]], AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } if (![[bongs]]->frame_number) { [[ini]]->frame.pict_type = AV_PICTURE_TYPE_I; [[ini]]->frame.key_frame = 1; if ([[bongs]]->extradata_size > 768) { av_log(NULL, AV_LOG_ERROR, "Palette is too large.\n"); return -1; } [[playmate]] = (uint32_t *)[[ini]]->frame.data[1]; for (i = 0; i < [[bongs]]->extradata_size / 3; i++) { int shift = 16; *[[playmate]] = 0; for (j = 0; j < 3; j++, shift -= 8) *[[playmate]] += (([[bongs]]->extradata[i * 3 + j] << 2) | ([[bongs]]->extradata[i * 3 + j] >> 4)) << shift; [[playmate]]++; } [[ini]]->frame.palette_has_changed = 1; } else { [[ini]]->frame.pict_type = AV_PICTURE_TYPE_P; [[ini]]->frame.key_frame = 0; } [[trujillo]] += 4; while ([[sti]] != frame_end) { static const uint8_t lentab[4] = { 0, 2, 0, 1 }; unsigned int byte = *[[trujillo]]++, av_uninit(offset); unsigned int code = byte >> 6; unsigned int length = byte & ~0xC0; if ([[trujillo]] >= buf_end) { av_log([[bongs]], AV_LOG_ERROR, "Input resolution larger than actual frame.\n"); return -1; } if (length == 0) { if (code == 1) { length = bytestream_get_byte(&[[trujillo]]); offset = bytestream_get_le16(&[[trujillo]]); } else { length = bytestream_get_le16(&[[trujillo]]); if (code == 2 && length == 0) break; } } else { if (code == 1) offset = bytestream_get_byte(&[[trujillo]]); } if ([[sti]] + (length << lentab[code]) > frame_end) break; switch (code) { case 0: if (length >= buf_end - [[trujillo]]) { av_log([[bongs]], AV_LOG_ERROR, "Frame larger than buffer.\n"); return -1; } bytestream_get_buffer(&[[trujillo]], [[sti]], length); [[sti]] += length; break; case 1: dst_offset = [[sti]] - offset; length *= 4; if (dst_offset < [[ini]]->dst) break; while (length--) *[[sti]]++ = *dst_offset++; break; case 2: [[sti]] += length; break; case 3: colour1 = bytestream_get_byte(&[[trujillo]]); colour2 = bytestream_get_byte(&[[trujillo]]); while (length--) { *[[sti]]++ = colour1; *[[sti]]++ = colour2; } break; } } src = [[ini]]->dst; [[sti]] = [[ini]]->frame.data[0]; while (height--) { memcpy([[sti]], src, [[bongs]]->width); src += [[bongs]]->width; [[sti]] += [[ini]]->frame.linesize[0]; } *data_size = sizeof(AVFrame); *(AVFrame *)data = [[ini]]->frame; return buf_size; }
--------------------------------------------- Result 77 ---------------------------------------------
[[0 (78%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette) { long i; for(i=0; i<num_pixels; i++) { dst[0]= palette[ src[i]*4+0 ]; dst[1]= palette[ src[i]*4+1 ]; dst[2]= palette[ src[i]*4+2 ]; dst+= 3; } }

[[[[Adv]]]]: void palette8tobgr24(const uint8_t *src, uint8_t *dst, long num_pixels, const uint8_t *palette) { long i; for(i=0; i<num_pixels; i++) { dst[0]= palette[ src[i]*4+0 ]; dst[1]= palette[ src[i]*4+1 ]; dst[2]= palette[ src[i]*4+2 ]; dst+= 3; } }
--------------------------------------------- Result 78 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 28 / 12 / 38 / 78:   3%|         | 78/2690 [00:26<15:01,  2.90it/s][Succeeded / Failed / Skipped / Total] 29 / 12 / 38 / 79:   3%|         | 79/2690 [00:27<15:08,  2.87it/s][Succeeded / Failed / Skipped / Total] 30 / 12 / 38 / 80:   3%|         | 80/2690 [00:28<15:14,  2.86it/s][Succeeded / Failed / Skipped / Total] 30 / 13 / 38 / 81:   3%|         | 81/2690 [00:29<15:50,  2.74it/s][Succeeded / Failed / Skipped / Total] 30 / 13 / 39 / 82:   3%|         | 82/2690 [00:29<15:52,  2.74it/s][Succeeded / Failed / Skipped / Total] 30 / 13 / 40 / 83:   3%|         | 83/2690 [00:30<15:45,  2.76it/s][[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: av_cold int swri_rematrix_init(SwrContext *s){ int i, j; int nb_in = av_get_channel_layout_nb_channels(s->in_ch_layout); int nb_out = av_get_channel_layout_nb_channels(s->out_ch_layout); s->mix_any_f = NULL; if (!s->rematrix_custom) { int r = auto_matrix(s); if (r) return r; } if (s->midbuf.fmt == AV_SAMPLE_FMT_S16P){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(int)); s->native_one = av_mallocz(sizeof(int)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) { double rem = 0; for (j = 0; j < nb_in; j++) { double target = s->matrix[i][j] * 32768 + rem; ((int*)s->native_matrix)[i * nb_in + j] = lrintf(target); rem += target - ((int*)s->native_matrix)[i * nb_in + j]; } } *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s16; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s16; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s16(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_FLTP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(float)); s->native_one = av_mallocz(sizeof(float)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((float*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((float*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_float; s->mix_2_1_f = (mix_2_1_func_type*)sum2_float; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_float(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_DBLP){ s->native_matrix = av_calloc(nb_in * nb_out, sizeof(double)); s->native_one = av_mallocz(sizeof(double)); if (!s->native_matrix || !s->native_one) return AVERROR(ENOMEM); for (i = 0; i < nb_out; i++) for (j = 0; j < nb_in; j++) ((double*)s->native_matrix)[i * nb_in + j] = s->matrix[i][j]; *((double*)s->native_one) = 1.0; s->mix_1_1_f = (mix_1_1_func_type*)copy_double; s->mix_2_1_f = (mix_2_1_func_type*)sum2_double; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_double(s); }else if(s->midbuf.fmt == AV_SAMPLE_FMT_S32P){ s->native_one = av_mallocz(sizeof(int)); if (!s->native_one) return AVERROR(ENOMEM); *((int*)s->native_one) = 32768; s->mix_1_1_f = (mix_1_1_func_type*)copy_s32; s->mix_2_1_f = (mix_2_1_func_type*)sum2_s32; s->mix_any_f = (mix_any_func_type*)get_mix_any_func_s32(s); }else av_assert0(0); for (i = 0; i < SWR_CH_MAX; i++) { int ch_in=0; for (j = 0; j < SWR_CH_MAX; j++) { s->matrix32[i][j]= lrintf(s->matrix[i][j] * 32768); if(s->matrix[i][j]) s->matrix_ch[i][++ch_in]= j; } s->matrix_ch[i][0]= ch_in; } if(HAVE_YASM && HAVE_MMX) return swri_rematrix_init_x86(s); return 0; }
--------------------------------------------- Result 79 ---------------------------------------------
[[0 (19%)]] --> [[0 (50%)]] --> Socre: 0.5006749033927917

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *[[s]]) { int [[i]]; for ([[i]] = 0; [[i]] < UTLB_SIZE; [[i]]++) { tlb_t * [[entry]] = &[[s]]->utlb[[[i]]]; [[entry]]->v = 0; } for ([[i]] = 0; [[i]] < UTLB_SIZE; [[i]]++) { tlb_t * [[entry]] = &[[s]]->utlb[[[i]]]; [[entry]]->v = 0; } tlb_flush([[s]], 1); }

[[[[Adv]]]]: void cpu_sh4_invalidate_tlb(CPUSH4State *[[nor]]) { int [[the]]; for ([[the]] = 0; [[the]] < UTLB_SIZE; [[the]]++) { tlb_t * [[introducing]] = &[[nor]]->utlb[[[the]]]; [[introducing]]->v = 0; } for ([[the]] = 0; [[the]] < UTLB_SIZE; [[the]]++) { tlb_t * [[introducing]] = &[[nor]]->utlb[[[the]]]; [[introducing]]->v = 0; } tlb_flush([[nor]], 1); }
--------------------------------------------- Result 80 ---------------------------------------------
[[0 (72%)]] --> [[0 (48%)]] --> Socre: 0.5173004269599915

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *next; next = QSIMPLEQ_FIRST(&queue->entries); if (!next) { return "False" != "False"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter(next, NULL); return "[[True]]" == "[[True]]"; }

[[[[Adv]]]]: bool qemu_co_enter_next(CoQueue *queue) { Coroutine *next; next = QSIMPLEQ_FIRST(&queue->entries); if (!next) { return "False" != "False"; } QSIMPLEQ_REMOVE_HEAD(&queue->entries, co_queue_next); qemu_coroutine_enter(next, NULL); return "[[Staunch]]" == "[[Staunch]]"; }
--------------------------------------------- Result 81 ---------------------------------------------
[[0 (24%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf) { uint32_t rgb = 0; if (bpp == 32) { rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24; rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16; rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) << 8; rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) << 0; } if (bpp == 16) { rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8; rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0; } return rgb; }

[[[[Adv]]]]: static uint32_t tight_palette_buf2rgb(int bpp, const uint8_t *buf) { uint32_t rgb = 0; if (bpp == 32) { rgb |= ((buf[0] & ~1) | !((buf[4] >> 3) & 1)) << 24; rgb |= ((buf[1] & ~1) | !((buf[4] >> 2) & 1)) << 16; rgb |= ((buf[2] & ~1) | !((buf[4] >> 1) & 1)) << 8; rgb |= ((buf[3] & ~1) | !((buf[4] >> 0) & 1)) << 0; } if (bpp == 16) { rgb |= ((buf[0] & ~1) | !((buf[2] >> 1) & 1)) << 8; rgb |= ((buf[1] & ~1) | !((buf[2] >> 0) & 1)) << 0; } return rgb; }
--------------------------------------------- Result 82 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void scsi_write_data(SCSIRequest *req) { SCSIDiskReq *r = DO_UPCAST(SCSIDiskReq, req, req); SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, r->req.dev); uint32_t n; assert(r->req.aiocb == NULL); scsi_req_ref(&r->req); if (r->req.cmd.mode != SCSI_XFER_TO_DEV) { DPRINTF("Data transfer direction invalid\n"); scsi_write_complete(r, -EINVAL); return; } if (!r->req.sg && !r->qiov.size) { r->started = "True" == "True"; scsi_write_complete(r, 0); return; } if (s->tray_open) { scsi_write_complete(r, -ENOMEDIUM); return; } if (r->req.cmd.buf[0] == VERIFY_10 || r->req.cmd.buf[0] == VERIFY_12 || r->req.cmd.buf[0] == VERIFY_16) { if (r->req.sg) { scsi_dma_complete(r, 0); } else { scsi_write_complete(r, 0); } return; } if (r->req.sg) { dma_acct_start(s->qdev.conf.bs, &r->acct, r->req.sg, BDRV_ACCT_WRITE); r->req.resid -= r->req.sg->size; r->req.aiocb = dma_bdrv_write(s->qdev.conf.bs, r->req.sg, r->sector, scsi_dma_complete, r); } else { n = r->qiov.size / 512; bdrv_acct_start(s->qdev.conf.bs, &r->acct, n * BDRV_SECTOR_SIZE, BDRV_ACCT_WRITE); r->req.aiocb = bdrv_aio_writev(s->qdev.conf.bs, r->sector, &r->qiov, n, scsi_write_complete, r); } }
--------------------------------------------- Result 83 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qed_aio_read_data(void *opaque, int ret, uint64_t offset, size_t len) { QEDAIOCB *acb = opaque; BDRVQEDState *s = acb_to_s(acb); BlockDriverState *bs = acb->common.bs; offset += qed_offset_into_cluster(s, acb->cur_pos); trace_qed_aio_read_data(s, acb, ret, offset, len); if (ret < 0) { goto err; } qemu_iovec_concat(&acb->cur_qiov, acb->qiov, acb->qiov_offset, len); if (ret == QED_CLUSTER_ZERO) { qemu_iovec_memset(&acb->cur_qiov, 0, 0, acb->cur_qiov.size); qed_aio_next_io(acb, 0); return; } else if (ret != QED_CLUSTER_FOUND) { qed_read_backing_file(s, acb->cur_pos, &acb->cur_qiov, qed_aio_next_io, acb); return; } BLKDBG_EVENT(bs->file, BLKDBG_READ_AIO); bdrv_aio_readv(bs->file, offset / BDRV_SECTOR_SIZE, &acb->cur_qiov, acb->cur_qiov.size / BDRV_SECTOR_SIZE, qed_aio_next_io, acb); return; err: qed_aio_complete(acb, ret); }
--------------------------------------------- Result 84 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 13 / 40 / 84:   3%|         | 84/2690 [00:30<15:55,  2.73it/s][Succeeded / Failed / Skipped / Total] 32 / 13 / 40 / 85:   3%|         | 85/2690 [00:30<15:46,  2.75it/s][[0 (61%)]] --> [[0 (41%)]] --> Socre: 0.5933980643749237

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *[[s]] = bs->opaque; QCowHeader *[[header]]; char *buf; size_t buflen = [[s]]->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; buf = qemu_blockalign(bs, buflen); [[header]] = (QCowHeader*) buf; if (buflen < sizeof(*[[header]])) { ret = -ENOSPC; goto fail; } header_length = sizeof(*[[header]]) + [[s]]->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = [[s]]->refcount_table_size >> ([[s]]->cluster_bits - 3); *[[header]] = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32([[s]]->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32([[s]]->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32([[s]]->crypt_method_header), .l1_size = cpu_to_be32([[s]]->l1_size), .l1_table_offset = cpu_to_be64([[s]]->l1_table_offset), .refcount_table_offset = cpu_to_be64([[s]]->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32([[s]]->nb_snapshots), .snapshots_offset = cpu_to_be64([[s]]->snapshots_offset), .incompatible_features = cpu_to_be64([[s]]->incompatible_features), .compatible_features = cpu_to_be64([[s]]->compatible_features), .autoclear_features = cpu_to_be64([[s]]->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch ([[s]]->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*[[header]]); break; default: return -EINVAL; } buf += ret; buflen -= ret; memset(buf, 0, buflen); if ([[s]]->unknown_header_fields_size) { if (buflen < [[s]]->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy(buf, [[s]]->unknown_header_fields, [[s]]->unknown_header_fields_size); buf += [[s]]->unknown_header_fields_size; buflen -= [[s]]->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; QLIST_FOREACH(uext, &[[s]]->unknown_header_ext, next) { ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy(buf, bs->backing_file, buflen); [[header]]->backing_file_offset = cpu_to_be64(buf - ((char*) [[header]])); [[header]]->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, [[header]], [[s]]->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree([[header]]); return ret; }

[[[[Adv]]]]: int qcow2_update_header(BlockDriverState *bs) { BDRVQcowState *[[science]] = bs->opaque; QCowHeader *[[incumbent]]; char *buf; size_t buflen = [[science]]->cluster_size; int ret; uint64_t total_size; uint32_t refcount_table_clusters; size_t header_length; Qcow2UnknownHeaderExtension *uext; buf = qemu_blockalign(bs, buflen); [[incumbent]] = (QCowHeader*) buf; if (buflen < sizeof(*[[incumbent]])) { ret = -ENOSPC; goto fail; } header_length = sizeof(*[[incumbent]]) + [[science]]->unknown_header_fields_size; total_size = bs->total_sectors * BDRV_SECTOR_SIZE; refcount_table_clusters = [[science]]->refcount_table_size >> ([[science]]->cluster_bits - 3); *[[incumbent]] = (QCowHeader) { .magic = cpu_to_be32(QCOW_MAGIC), .version = cpu_to_be32([[science]]->qcow_version), .backing_file_offset = 0, .backing_file_size = 0, .cluster_bits = cpu_to_be32([[science]]->cluster_bits), .size = cpu_to_be64(total_size), .crypt_method = cpu_to_be32([[science]]->crypt_method_header), .l1_size = cpu_to_be32([[science]]->l1_size), .l1_table_offset = cpu_to_be64([[science]]->l1_table_offset), .refcount_table_offset = cpu_to_be64([[science]]->refcount_table_offset), .refcount_table_clusters = cpu_to_be32(refcount_table_clusters), .nb_snapshots = cpu_to_be32([[science]]->nb_snapshots), .snapshots_offset = cpu_to_be64([[science]]->snapshots_offset), .incompatible_features = cpu_to_be64([[science]]->incompatible_features), .compatible_features = cpu_to_be64([[science]]->compatible_features), .autoclear_features = cpu_to_be64([[science]]->autoclear_features), .refcount_order = cpu_to_be32(3 + REFCOUNT_SHIFT), .header_length = cpu_to_be32(header_length), }; switch ([[science]]->qcow_version) { case 2: ret = offsetof(QCowHeader, incompatible_features); break; case 3: ret = sizeof(*[[incumbent]]); break; default: return -EINVAL; } buf += ret; buflen -= ret; memset(buf, 0, buflen); if ([[science]]->unknown_header_fields_size) { if (buflen < [[science]]->unknown_header_fields_size) { ret = -ENOSPC; goto fail; } memcpy(buf, [[science]]->unknown_header_fields, [[science]]->unknown_header_fields_size); buf += [[science]]->unknown_header_fields_size; buflen -= [[science]]->unknown_header_fields_size; } if (*bs->backing_format) { ret = header_ext_add(buf, QCOW2_EXT_MAGIC_BACKING_FORMAT, bs->backing_format, strlen(bs->backing_format), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } Qcow2Feature features[] = { }; ret = header_ext_add(buf, QCOW2_EXT_MAGIC_FEATURE_TABLE, features, sizeof(features), buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; QLIST_FOREACH(uext, &[[science]]->unknown_header_ext, next) { ret = header_ext_add(buf, uext->magic, uext->data, uext->len, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; } ret = header_ext_add(buf, QCOW2_EXT_MAGIC_END, NULL, 0, buflen); if (ret < 0) { goto fail; } buf += ret; buflen -= ret; if (*bs->backing_file) { size_t backing_file_len = strlen(bs->backing_file); if (buflen < backing_file_len) { ret = -ENOSPC; goto fail; } strncpy(buf, bs->backing_file, buflen); [[incumbent]]->backing_file_offset = cpu_to_be64(buf - ((char*) [[incumbent]])); [[incumbent]]->backing_file_size = cpu_to_be32(backing_file_len); } ret = bdrv_pwrite(bs->file, 0, [[incumbent]], [[science]]->cluster_size); if (ret < 0) { goto fail; } ret = 0; fail: qemu_vfree([[incumbent]]); return ret; }
--------------------------------------------- Result 85 ---------------------------------------------
[[0 (17%)]] --> [[0 (58%)]] --> Socre: 0.5783485770225525

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[sum]]) { while ([[sum]]>>16) [[sum]] = ([[sum]] & 0xFFFF)+([[sum]] >> 16); return ~[[sum]]; }

[[[[Adv]]]]: uint16_t net_checksum_finish(uint32_t [[cash]]) { while ([[cash]]>>16) [[cash]] = ([[cash]] & 0xFFFF)+([[cash]] >> 16); return ~[[cash]]; }
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 13 / 41 / 86:   3%|         | 86/2690 [00:32<16:29,  2.63it/s][[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decodeChannelSoundUnit (ATRAC3Context *q, GetBitContext *gb, channel_unit *pSnd, float *pOut, int channelNum, int codingMode) { int band, result=0, numSubbands, lastTonal, numBands; if (codingMode == JOINT_STEREO && channelNum == 1) { if (get_bits(gb,2) != 3) { av_log(NULL,AV_LOG_ERROR,"JS mono Sound Unit id != 3.\n"); return -1; } } else { if (get_bits(gb,6) != 0x28) { av_log(NULL,AV_LOG_ERROR,"Sound Unit id != 0x28.\n"); return -1; } } pSnd->bandsCoded = get_bits(gb,2); result = decodeGainControl (gb, &(pSnd->gainBlock[pSnd->gcBlkSwitch]), pSnd->bandsCoded); if (result) return result; pSnd->numComponents = decodeTonalComponents (gb, pSnd->components, pSnd->bandsCoded); if (pSnd->numComponents == -1) return -1; numSubbands = decodeSpectrum (gb, pSnd->spectrum); lastTonal = addTonalComponents (pSnd->spectrum, pSnd->numComponents, pSnd->components); numBands = (subbandTab[numSubbands] - 1) >> 8; if (lastTonal >= 0) numBands = FFMAX((lastTonal + 256) >> 8, numBands); for (band=0; band<4; band++) { if (band <= numBands) { IMLT(&(pSnd->spectrum[band*256]), pSnd->IMDCT_buf, band&1); } else memset(pSnd->IMDCT_buf, 0, 512 * sizeof(float)); gainCompensateAndOverlap (pSnd->IMDCT_buf, &(pSnd->prevFrame[band*256]), &(pOut[band*256]), &((pSnd->gainBlock[1 - (pSnd->gcBlkSwitch)]).gBlock[band]), &((pSnd->gainBlock[pSnd->gcBlkSwitch]).gBlock[band])); } pSnd->gcBlkSwitch ^= 1; return 0; }
--------------------------------------------- Result 87 ---------------------------------------------
[[0 (50%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifname[128]; assert(netdev->type == NET_CLIENT_DRIVER_TAP); tap = &netdev->u.tap; queues = tap->has_queues ? tap->queues : 1; vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL; if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) { error_setg(errp, "Multiqueue tap cannot be used with QEMU vlans"); return -1; } if (tap->has_fd) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_fds || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; } fd = monitor_fd_param(cur_mon, tap->fd, &err); if (fd == -1) { error_propagate(errp, err); return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); return -1; } } else if (tap->has_fds) { char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_vhostfd) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; } nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES); if (tap->has_vhostfds) { nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) { error_setg(errp, "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; } } for (i = 0; i < nfds; i++) { fd = monitor_fd_param(cur_mon, fds[i], &err); if (fd == -1) { error_propagate(errp, err); goto free_fail; } fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) { vnet_hdr = tap_probe_vnet_hdr(fd); } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) { error_setg(errp, "vnet_hdr not consistent across given tap fds"); goto free_fail; } net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap->has_vhostfds ? vhost_fds[i] : NULL, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); goto free_fail; } } g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i < nfds; i++) { g_free(fds[i]); g_free(vhost_fds[i]); } g_free(fds); g_free(vhost_fds); return -1; } else if (tap->has_helper) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; } fd = net_bridge_run_helper(tap->helper, tap->has_br ? tap->br : DEFAULT_BRIDGE_INTERFACE, errp); if (fd == -1) { return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } else { if (tap->has_vhostfds) { error_setg(errp, "vhostfds= is invalid if fds= wasn't specified"); return -1; } script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT; downscript = tap->has_downscript ? tap->downscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap->has_ifname) { pstrcpy(ifname, sizeof ifname, tap->ifname); } else { ifname[0] = '\0'; } for (i = 0; i < queues; i++) { fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script, ifname, sizeof ifname, queues > 1, errp); if (fd == -1) { return -1; } if (queues > 1 && i == 0 && !tap->has_ifname) { if (tap_fd_get_ifname(fd, ifname)) { error_setg(errp, "Fail to get ifname"); close(fd); return -1; } } net_init_tap_one(tap, peer, "tap", name, ifname, i >= 1 ? "no" : script, i >= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } } return 0; }

[[[[Adv]]]]: int net_init_tap(const Netdev *netdev, const char *name, NetClientState *peer, Error **errp) { const NetdevTapOptions *tap; int fd, vnet_hdr = 0, i = 0, queues; const char *script = NULL; const char *downscript = NULL; Error *err = NULL; const char *vhostfdname; char ifname[128]; assert(netdev->type == NET_CLIENT_DRIVER_TAP); tap = &netdev->u.tap; queues = tap->has_queues ? tap->queues : 1; vhostfdname = tap->has_vhostfd ? tap->vhostfd : NULL; if (peer && (tap->has_queues || tap->has_fds || tap->has_vhostfds)) { error_setg(errp, "Multiqueue tap cannot be used with QEMU vlans"); return -1; } if (tap->has_fd) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_fds || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, fds=, and vhostfds= " "are invalid with fd="); return -1; } fd = monitor_fd_param(cur_mon, tap->fd, &err); if (fd == -1) { error_propagate(errp, err); return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "tap", name, NULL, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); return -1; } } else if (tap->has_fds) { char **fds = g_new0(char *, MAX_TAP_QUEUES); char **vhost_fds = g_new0(char *, MAX_TAP_QUEUES); int nfds, nvhosts; if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_helper || tap->has_queues || tap->has_vhostfd) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "helper=, queues=, and vhostfd= " "are invalid with fds="); return -1; } nfds = get_fds(tap->fds, fds, MAX_TAP_QUEUES); if (tap->has_vhostfds) { nvhosts = get_fds(tap->vhostfds, vhost_fds, MAX_TAP_QUEUES); if (nfds != nvhosts) { error_setg(errp, "The number of fds passed does not match " "the number of vhostfds passed"); goto free_fail; } } for (i = 0; i < nfds; i++) { fd = monitor_fd_param(cur_mon, fds[i], &err); if (fd == -1) { error_propagate(errp, err); goto free_fail; } fcntl(fd, F_SETFL, O_NONBLOCK); if (i == 0) { vnet_hdr = tap_probe_vnet_hdr(fd); } else if (vnet_hdr != tap_probe_vnet_hdr(fd)) { error_setg(errp, "vnet_hdr not consistent across given tap fds"); goto free_fail; } net_init_tap_one(tap, peer, "tap", name, ifname, script, downscript, tap->has_vhostfds ? vhost_fds[i] : NULL, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); goto free_fail; } } g_free(fds); g_free(vhost_fds); return 0; free_fail: for (i = 0; i < nfds; i++) { g_free(fds[i]); g_free(vhost_fds[i]); } g_free(fds); g_free(vhost_fds); return -1; } else if (tap->has_helper) { if (tap->has_ifname || tap->has_script || tap->has_downscript || tap->has_vnet_hdr || tap->has_queues || tap->has_vhostfds) { error_setg(errp, "ifname=, script=, downscript=, vnet_hdr=, " "queues=, and vhostfds= are invalid with helper="); return -1; } fd = net_bridge_run_helper(tap->helper, tap->has_br ? tap->br : DEFAULT_BRIDGE_INTERFACE, errp); if (fd == -1) { return -1; } fcntl(fd, F_SETFL, O_NONBLOCK); vnet_hdr = tap_probe_vnet_hdr(fd); net_init_tap_one(tap, peer, "bridge", name, ifname, script, downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } else { if (tap->has_vhostfds) { error_setg(errp, "vhostfds= is invalid if fds= wasn't specified"); return -1; } script = tap->has_script ? tap->script : DEFAULT_NETWORK_SCRIPT; downscript = tap->has_downscript ? tap->downscript : DEFAULT_NETWORK_DOWN_SCRIPT; if (tap->has_ifname) { pstrcpy(ifname, sizeof ifname, tap->ifname); } else { ifname[0] = '\0'; } for (i = 0; i < queues; i++) { fd = net_tap_init(tap, &vnet_hdr, i >= 1 ? "no" : script, ifname, sizeof ifname, queues > 1, errp); if (fd == -1) { return -1; } if (queues > 1 && i == 0 && !tap->has_ifname) { if (tap_fd_get_ifname(fd, ifname)) { error_setg(errp, "Fail to get ifname"); close(fd); return -1; } } net_init_tap_one(tap, peer, "tap", name, ifname, i >= 1 ? "no" : script, i >= 1 ? "no" : downscript, vhostfdname, vnet_hdr, fd, &err); if (err) { error_propagate(errp, err); close(fd); return -1; } } } return 0; }[Succeeded / Failed / Skipped / Total] 32 / 14 / 41 / 87:   3%|         | 87/2690 [00:33<16:49,  2.58it/s][Succeeded / Failed / Skipped / Total] 32 / 14 / 41 / 87:   3%|         | 88/2690 [00:34<16:55,  2.56it/s][Succeeded / Failed / Skipped / Total] 33 / 14 / 41 / 88:   3%|         | 88/2690 [00:34<16:55,  2.56it/s][Succeeded / Failed / Skipped / Total] 33 / 14 / 42 / 89:   3%|         | 89/2690 [00:34<16:44,  2.59it/s][Succeeded / Failed / Skipped / Total] 33 / 14 / 43 / 90:   3%|         | 90/2690 [00:34<16:37,  2.61it/s][Succeeded / Failed / Skipped / Total] 34 / 14 / 43 / 91:   3%|         | 91/2690 [00:35<16:51,  2.57it/s][Succeeded / Failed / Skipped / Total] 35 / 14 / 43 / 92:   3%|         | 92/2690 [00:36<17:02,  2.54it/s][Succeeded / Failed / Skipped / Total] 35 / 14 / 44 / 93:   3%|         | 93/2690 [00:39<18:16,  2.37it/s][Succeeded / Failed / Skipped / Total] 36 / 14 / 44 / 94:   3%|         | 94/2690 [00:39<18:11,  2.38it/s]
--------------------------------------------- Result 88 ---------------------------------------------
[[0 (26%)]] --> [[0 (52%)]] --> Socre: 0.5218787789344788

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *[[buf]], size_t [[size]]) { TAPState *[[s]] = opaque; int [[ret]]; for(;;) { [[ret]] = write([[s]]->fd, [[buf]], [[size]]); if ([[ret]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }

[[[[Adv]]]]: static void tap_receive(void *opaque, const uint8_t *[[amicably]], size_t [[magnitude]]) { TAPState *[[per]] = opaque; int [[withdrawals]]; for(;;) { [[withdrawals]] = write([[per]]->fd, [[amicably]], [[magnitude]]); if ([[withdrawals]] < 0 && (errno == EINTR || errno == EAGAIN)) { } else { break; } } }
--------------------------------------------- Result 89 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void s390_machine_reset(void) { S390CPU *ipl_cpu = S390_CPU(qemu_get_cpu(0)); qemu_devices_reset(); s390_cmma_reset(); s390_crypto_reset(); s390_ipl_prepare_cpu(ipl_cpu); s390_cpu_set_state(CPU_STATE_OPERATING, ipl_cpu); }
--------------------------------------------- Result 90 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tcp_start_incoming_migration(const char *host_port, Error **errp) { int s; s = inet_listen(host_port, NULL, 256, SOCK_STREAM, 0, errp); if (s < 0) { return; } qemu_set_fd_handler2(s, NULL, tcp_accept_incoming_migration, NULL, (void *)(intptr_t)s); }
--------------------------------------------- Result 91 ---------------------------------------------
[[0 (41%)]] --> [[0 (57%)]] --> Socre: 0.5732690691947937

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[d]]) { memset([[d]]->wmask + PCI_PRIMARY_BUS, 0xff, 4); [[d]]->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; [[d]]->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[d]]->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[d]]->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[d]]->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[d]]->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; [[d]]->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[d]]->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[d]]->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[d]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[d]]->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[d]]->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; [[d]]->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[d]]->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[d]]->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }

[[[[Adv]]]]: static void pci_init_mask_bridge(PCIDevice *[[trois]]) { memset([[trois]]->wmask + PCI_PRIMARY_BUS, 0xff, 4); [[trois]]->wmask[PCI_IO_BASE] = PCI_IO_RANGE_MASK & 0xff; [[trois]]->wmask[PCI_IO_LIMIT] = PCI_IO_RANGE_MASK & 0xff; pci_set_word([[trois]]->wmask + PCI_MEMORY_BASE, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[trois]]->wmask + PCI_MEMORY_LIMIT, PCI_MEMORY_RANGE_MASK & 0xffff); pci_set_word([[trois]]->wmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_MASK & 0xffff); pci_set_word([[trois]]->wmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_MASK & 0xffff); memset([[trois]]->wmask + PCI_PREF_BASE_UPPER32, 0xff, 8); [[trois]]->config[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_16; [[trois]]->config[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_16; pci_word_test_and_set_mask([[trois]]->config + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_64); pci_word_test_and_set_mask([[trois]]->config + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_64); #define PCI_BRIDGE_CTL_VGA_16BIT 0x10 #define PCI_BRIDGE_CTL_DISCARD 0x100 #define PCI_BRIDGE_CTL_SEC_DISCARD 0x200 #define PCI_BRIDGE_CTL_DISCARD_STATUS 0x400 #define PCI_BRIDGE_CTL_DISCARD_SERR 0x800 pci_set_word([[trois]]->wmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_PARITY | PCI_BRIDGE_CTL_SERR | PCI_BRIDGE_CTL_ISA | PCI_BRIDGE_CTL_VGA | PCI_BRIDGE_CTL_VGA_16BIT | PCI_BRIDGE_CTL_MASTER_ABORT | PCI_BRIDGE_CTL_BUS_RESET | PCI_BRIDGE_CTL_FAST_BACK | PCI_BRIDGE_CTL_DISCARD | PCI_BRIDGE_CTL_SEC_DISCARD | PCI_BRIDGE_CTL_DISCARD_SERR); pci_set_word([[trois]]->w1cmask + PCI_BRIDGE_CONTROL, PCI_BRIDGE_CTL_DISCARD_STATUS); [[trois]]->cmask[PCI_IO_BASE] |= PCI_IO_RANGE_TYPE_MASK; [[trois]]->cmask[PCI_IO_LIMIT] |= PCI_IO_RANGE_TYPE_MASK; pci_word_test_and_set_mask([[trois]]->cmask + PCI_PREF_MEMORY_BASE, PCI_PREF_RANGE_TYPE_MASK); pci_word_test_and_set_mask([[trois]]->cmask + PCI_PREF_MEMORY_LIMIT, PCI_PREF_RANGE_TYPE_MASK); }
--------------------------------------------- Result 92 ---------------------------------------------
[[0 (92%)]] --> [[0 (43%)]] --> Socre: 0.5714152753353119

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *[[md]], int [[val]]) { CPUState *[[env]] = mon_get_cpu(); if (![[env]]) return 0; return [[env]]->regwptr[[[val]]]; }

[[[[Adv]]]]: static target_long monitor_get_reg(const struct MonitorDef *[[mh]], int [[selecting]]) { CPUState *[[zoltan]] = mon_get_cpu(); if (![[zoltan]]) return 0; return [[zoltan]]->regwptr[[[selecting]]]; }
--------------------------------------------- Result 93 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void stream_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, const char *backing_file_str, int64_t speed, BlockdevOnError on_error, BlockCompletionFunc *cb, void *opaque, Error **errp) { StreamBlockJob *s; s = block_job_create(job_id, &stream_job_driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->base = base; s->backing_file_str = g_strdup(backing_file_str); s->on_error = on_error; s->common.co = qemu_coroutine_create(stream_run); trace_stream_start(bs, base, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 94 ---------------------------------------------
[[0 (69%)]] --> [[0 (47%)]] --> Socre: 0.5297105312347412

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int stride, int16_t *block) { int [[i]], num_coeff; if (get_bits1(gb)) { ctx->frame->key_frame = 0; ctx->frame->pict_type = AV_PICTURE_TYPE_P; return 0; } memset(block, 0, sizeof(*block) * 64); num_coeff = get_bits(gb, 7); if (num_coeff > 64) return AVERROR_INVALIDDATA; for ([[i]] = 0; [[i]] < num_coeff; [[i]]++) block[ff_zigzag_direct[[[i]]]] = get_se_golomb(gb) * ctx->qmat[ff_zigzag_direct[[[i]]]]; fic_idct_put(dst, stride, block); return 0; }

[[[[Adv]]]]: static int fic_decode_block(FICContext *ctx, GetBitContext *gb, uint8_t *dst, int stride, int16_t *block) { int [[al]], num_coeff; if (get_bits1(gb)) { ctx->frame->key_frame = 0; ctx->frame->pict_type = AV_PICTURE_TYPE_P; return 0; } memset(block, 0, sizeof(*block) * 64); num_coeff = get_bits(gb, 7); if (num_coeff > 64) return AVERROR_INVALIDDATA; for ([[al]] = 0; [[al]] < num_coeff; [[al]]++) block[ff_zigzag_direct[[[al]]]] = get_se_golomb(gb) * ctx->qmat[ff_zigzag_direct[[[al]]]]; fic_idct_put(dst, stride, block); return 0; }
--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 14 / 45 / 95:   4%|         | 95/2690 [00:39<17:59,  2.40it/s][Succeeded / Failed / Skipped / Total] 36 / 14 / 46 / 96:   4%|         | 96/2690 [00:39<17:48,  2.43it/s][Succeeded / Failed / Skipped / Total] 36 / 14 / 47 / 97:   4%|         | 97/2690 [00:39<17:48,  2.43it/s][Succeeded / Failed / Skipped / Total] 37 / 14 / 47 / 98:   4%|         | 98/2690 [00:40<17:50,  2.42it/s][Succeeded / Failed / Skipped / Total] 37 / 14 / 47 / 98:   4%|         | 99/2690 [00:41<17:55,  2.41it/s][Succeeded / Failed / Skipped / Total] 38 / 14 / 47 / 99:   4%|         | 99/2690 [00:41<17:55,  2.41it/s][[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: MigrationState *exec_start_outgoing_migration(const char *command, int64_t bandwidth_limit, int async) { FdMigrationState *s; FILE *f; s = qemu_mallocz(sizeof(*s)); if (s == NULL) { dprintf("Unable to allocate FdMigrationState\n"); goto err; } f = popen(command, "w"); if (f == NULL) { dprintf("Unable to popen exec target\n"); goto err_after_alloc; } s->fd = fileno(f); if (s->fd == -1) { dprintf("Unable to retrieve file descriptor for popen'd handle\n"); goto err_after_open; } if (fcntl(s->fd, F_SETFD, O_NONBLOCK) == -1) { dprintf("Unable to set nonblocking mode on file descriptor\n"); goto err_after_open; } s->opaque = qemu_popen(f, "w"); s->get_error = file_errno; s->write = file_write; s->mig_state.cancel = migrate_fd_cancel; s->mig_state.get_status = migrate_fd_get_status; s->mig_state.release = migrate_fd_release; s->state = MIG_STATE_ACTIVE; s->detach = !async; s->bandwidth_limit = bandwidth_limit; if (s->detach == 1) { dprintf("detaching from monitor\n"); monitor_suspend(); s->detach = 2; } migrate_fd_connect(s); return &s->mig_state; err_after_open: pclose(f); err_after_alloc: qemu_free(s); err: return NULL; }
--------------------------------------------- Result 96 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_rtsp_undo_setup(AVFormatContext *s, int send_packets) { RTSPState *rt = s->priv_data; int i; for (i = 0; i < rt->nb_rtsp_streams; i++) { RTSPStream *rtsp_st = rt->rtsp_streams[i]; if (!rtsp_st) continue; if (rtsp_st->transport_priv) { if (s->oformat) { AVFormatContext *rtpctx = rtsp_st->transport_priv; av_write_trailer(rtpctx); if (rt->lower_transport == RTSP_LOWER_TRANSPORT_TCP) { uint8_t *ptr; if (CONFIG_RTSP_MUXER && rtpctx->pb && send_packets) ff_rtsp_tcp_write_packet(s, rtsp_st); avio_close_dyn_buf(rtpctx->pb, &ptr); av_free(ptr); } else { avio_close(rtpctx->pb); } avformat_free_context(rtpctx); } else if (rt->transport == RTSP_TRANSPORT_RDT && CONFIG_RTPDEC) ff_rdt_parse_close(rtsp_st->transport_priv); else if (rt->transport == RTSP_TRANSPORT_RTP && CONFIG_RTPDEC) ff_rtp_parse_close(rtsp_st->transport_priv); } rtsp_st->transport_priv = NULL; if (rtsp_st->rtp_handle) ffurl_close(rtsp_st->rtp_handle); rtsp_st->rtp_handle = NULL; } }
--------------------------------------------- Result 97 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int spapr_populate_pci_child_dt(PCIDevice *dev, void *fdt, int offset, sPAPRPHBState *sphb) { ResourceProps rp; bool is_bridge = "False" != "False"; int pci_status, err; char *buf = NULL; uint32_t drc_index = spapr_phb_get_pci_drc_index(sphb, dev); uint32_t ccode = pci_default_read_config(dev, PCI_CLASS_PROG, 3); uint32_t max_msi, max_msix; if (pci_default_read_config(dev, PCI_HEADER_TYPE, 1) == PCI_HEADER_TYPE_BRIDGE) { is_bridge = "True" == "True"; } _FDT(fdt_setprop_cell(fdt, offset, "vendor-id", pci_default_read_config(dev, PCI_VENDOR_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "device-id", pci_default_read_config(dev, PCI_DEVICE_ID, 2))); _FDT(fdt_setprop_cell(fdt, offset, "revision-id", pci_default_read_config(dev, PCI_REVISION_ID, 1))); _FDT(fdt_setprop_cell(fdt, offset, "class-code", ccode)); if (pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1)) { _FDT(fdt_setprop_cell(fdt, offset, "interrupts", pci_default_read_config(dev, PCI_INTERRUPT_PIN, 1))); } if (!is_bridge) { _FDT(fdt_setprop_cell(fdt, offset, "min-grant", pci_default_read_config(dev, PCI_MIN_GNT, 1))); _FDT(fdt_setprop_cell(fdt, offset, "max-latency", pci_default_read_config(dev, PCI_MAX_LAT, 1))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-id", pci_default_read_config(dev, PCI_SUBSYSTEM_ID, 2))); } if (pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2)) { _FDT(fdt_setprop_cell(fdt, offset, "subsystem-vendor-id", pci_default_read_config(dev, PCI_SUBSYSTEM_VENDOR_ID, 2))); } _FDT(fdt_setprop_cell(fdt, offset, "cache-line-size", pci_default_read_config(dev, PCI_CACHE_LINE_SIZE, 1))); pci_status = pci_default_read_config(dev, PCI_STATUS, 2); _FDT(fdt_setprop_cell(fdt, offset, "devsel-speed", PCI_STATUS_DEVSEL_MASK & pci_status)); if (pci_status & PCI_STATUS_FAST_BACK) { _FDT(fdt_setprop(fdt, offset, "fast-back-to-back", NULL, 0)); } if (pci_status & PCI_STATUS_66MHZ) { _FDT(fdt_setprop(fdt, offset, "66mhz-capable", NULL, 0)); } if (pci_status & PCI_STATUS_UDF) { _FDT(fdt_setprop(fdt, offset, "udf-supported", NULL, 0)); } _FDT(fdt_setprop_string(fdt, offset, "name", pci_find_device_name((ccode >> 16) & 0xff, (ccode >> 8) & 0xff, ccode & 0xff))); buf = spapr_phb_get_loc_code(sphb, dev); if (!buf) { error_report("Failed setting the ibm,loc-code"); return -1; } err = fdt_setprop_string(fdt, offset, "ibm,loc-code", buf); g_free(buf); if (err < 0) { return err; } if (drc_index) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,my-drc-index", drc_index)); } _FDT(fdt_setprop_cell(fdt, offset, "#address-cells", RESOURCE_CELLS_ADDRESS)); _FDT(fdt_setprop_cell(fdt, offset, "#size-cells", RESOURCE_CELLS_SIZE)); max_msi = msi_nr_vectors_allocated(dev); if (max_msi) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi", max_msi)); } max_msix = dev->msix_entries_nr; if (max_msix) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,req#msi-x", max_msix)); } populate_resource_props(dev, &rp); _FDT(fdt_setprop(fdt, offset, "reg", (uint8_t *)rp.reg, rp.reg_len)); _FDT(fdt_setprop(fdt, offset, "assigned-addresses", (uint8_t *)rp.assigned, rp.assigned_len)); if (sphb->pcie_ecs && pci_is_express(dev)) { _FDT(fdt_setprop_cell(fdt, offset, "ibm,pci-config-space-type", 0x1)); } return 0; }
--------------------------------------------- Result 98 ---------------------------------------------
[[0 (40%)]] --> [[0 (64%)]] --> Socre: 0.6380836963653564

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *[[dst]], int16_t block[4][16], ptrdiff_t [[stride]]) { vp8_idct_dc_add_c([[dst]]+[[stride]]*0+0, block[0], [[stride]]); vp8_idct_dc_add_c([[dst]]+[[stride]]*0+4, block[1], [[stride]]); vp8_idct_dc_add_c([[dst]]+[[stride]]*4+0, block[2], [[stride]]); vp8_idct_dc_add_c([[dst]]+[[stride]]*4+4, block[3], [[stride]]); }

[[[[Adv]]]]: static void vp8_idct_dc_add4uv_c(uint8_t *[[tsi]], int16_t block[4][16], ptrdiff_t [[stade]]) { vp8_idct_dc_add_c([[tsi]]+[[stade]]*0+0, block[0], [[stade]]); vp8_idct_dc_add_c([[tsi]]+[[stade]]*0+4, block[1], [[stade]]); vp8_idct_dc_add_c([[tsi]]+[[stade]]*4+0, block[2], [[stade]]); vp8_idct_dc_add_c([[tsi]]+[[stade]]*4+4, block[3], [[stade]]); }
--------------------------------------------- Result 99 ---------------------------------------------
[[0 (26%)]] --> [[0 (53%)]] --> Socre: 0.5318385362625122

[[[[Adv]]]]: static void gpollfds_from_select(void) { int [[fd]]; for ([[fd]] = 0; [[fd]] <= nfds; [[fd]]++) { int [[events]] = 0; if (FD_ISSET([[fd]], &rfds)) { [[events]] |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET([[fd]], &wfds)) { [[events]] |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET([[fd]], &xfds)) { [[events]] |= G_IO_PRI; } if ([[events]]) { GPollFD pfd = { .fd = [[fd]], .events = [[events]], }; g_array_append_val(gpollfds, pfd); } } }

[[[[Adv]]]]: static void gpollfds_from_select(void) { int [[realms]]; for ([[realms]] = 0; [[realms]] <= nfds; [[realms]]++) { int [[mishaps]] = 0; if (FD_ISSET([[realms]], &rfds)) { [[mishaps]] |= G_IO_IN | G_IO_HUP | G_IO_ERR; } if (FD_ISSET([[realms]], &wfds)) { [[mishaps]] |= G_IO_OUT | G_IO_ERR; } if (FD_ISSET([[realms]], &xfds)) { [[mishaps]] |= G_IO_PRI; } if ([[mishaps]]) { GPollFD pfd = { .fd = [[realms]], .events = [[mishaps]], }; g_array_append_val(gpollfds, pfd); } } }
--------------------------------------------- Result 100 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 14 / 48 / 100:   4%|         | 100/2690 [00:41<18:05,  2.39it/s][Succeeded / Failed / Skipped / Total] 38 / 15 / 48 / 101:   4%|         | 101/2690 [00:41<17:54,  2.41it/s][Succeeded / Failed / Skipped / Total] 38 / 15 / 49 / 102:   4%|         | 102/2690 [00:41<17:45,  2.43it/s][Succeeded / Failed / Skipped / Total] 39 / 15 / 49 / 103:   4%|         | 103/2690 [00:42<17:55,  2.40it/s][[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void do_token_in(USBDevice *s, USBPacket *p) { int request, value, index; assert(p->ep->nr == 0); request = (s->setup_buf[0] << 8) | s->setup_buf[1]; value = (s->setup_buf[3] << 8) | s->setup_buf[2]; index = (s->setup_buf[5] << 8) | s->setup_buf[4]; switch(s->setup_state) { case SETUP_STATE_ACK: if (!(s->setup_buf[0] & USB_DIR_IN)) { usb_device_handle_control(s, p, request, value, index, s->setup_len, s->data_buf); if (p->status == USB_RET_ASYNC) { return; } s->setup_state = SETUP_STATE_IDLE; p->actual_length = 0; } break; case SETUP_STATE_DATA: if (s->setup_buf[0] & USB_DIR_IN) { int len = s->setup_len - s->setup_index; if (len > p->iov.size) { len = p->iov.size; } usb_packet_copy(p, s->data_buf + s->setup_index, len); s->setup_index += len; if (s->setup_index >= s->setup_len) { s->setup_state = SETUP_STATE_ACK; } return; } s->setup_state = SETUP_STATE_IDLE; p->status = USB_RET_STALL; break; default: p->status = USB_RET_STALL; } }
--------------------------------------------- Result 101 ---------------------------------------------
[[0 (55%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong liobn = args[0]; target_ulong ioba = args[1]; target_ulong tce = args[2]; VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn); VIOsPAPR_RTCE *rtce; if (!dev) { hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn); return H_PARAMETER; } ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1); #ifdef DEBUG_TCE fprintf(stderr, "spapr_vio_put_tce on %s ioba 0x" TARGET_FMT_lx " TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce); #endif if (ioba >= dev->rtce_window_size) { hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT); rtce->tce = tce; return H_SUCCESS; }

[[[[Adv]]]]: static target_ulong h_put_tce(CPUPPCState *env, sPAPREnvironment *spapr, target_ulong opcode, target_ulong *args) { target_ulong liobn = args[0]; target_ulong ioba = args[1]; target_ulong tce = args[2]; VIOsPAPRDevice *dev = spapr_vio_find_by_reg(spapr->vio_bus, liobn); VIOsPAPR_RTCE *rtce; if (!dev) { hcall_dprintf("LIOBN 0x" TARGET_FMT_lx " does not exist\n", liobn); return H_PARAMETER; } ioba &= ~(SPAPR_VIO_TCE_PAGE_SIZE - 1); #ifdef DEBUG_TCE fprintf(stderr, "spapr_vio_put_tce on %s ioba 0x" TARGET_FMT_lx " TCE 0x" TARGET_FMT_lx "\n", dev->qdev.id, ioba, tce); #endif if (ioba >= dev->rtce_window_size) { hcall_dprintf("Out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } rtce = dev->rtce_table + (ioba >> SPAPR_VIO_TCE_PAGE_SHIFT); rtce->tce = tce; return H_SUCCESS; }
--------------------------------------------- Result 102 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { int ret; *got_picture_ptr = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, got_picture_ptr, avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*got_picture_ptr) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }
--------------------------------------------- Result 103 ---------------------------------------------
[[0 (62%)]] --> [[0 (46%)]] --> Socre: 0.5372471511363983

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *[[m]], GetBitContext *gb) { MLPHeaderInfo [[mh]]; int substr, ret; if ((ret = ff_mlp_read_major_sync([[m]]->avctx, &[[mh]], gb)) != 0) return ret; if ([[mh]].group1_bits == 0) { av_log([[m]]->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if ([[mh]].group2_bits > [[mh]].group1_bits) { av_log([[m]]->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if ([[mh]].group2_samplerate && [[mh]].group2_samplerate != [[mh]].group1_samplerate) { av_log([[m]]->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if ([[mh]].group1_samplerate == 0) { av_log([[m]]->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if ([[mh]].group1_samplerate > MAX_SAMPLERATE) { av_log([[m]]->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", [[mh]].group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if ([[mh]].access_unit_size > MAX_BLOCKSIZE) { av_log([[m]]->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", [[mh]].access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if ([[mh]].access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log([[m]]->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", [[mh]].access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if ([[mh]].num_substreams == 0) return AVERROR_INVALIDDATA; if ([[m]]->avctx->codec_id == AV_CODEC_ID_MLP && [[mh]].num_substreams > 2) { av_log([[m]]->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if ([[mh]].num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", [[mh]].num_substreams); [[m]]->access_unit_size = [[mh]].access_unit_size; [[m]]->access_unit_size_pow2 = [[mh]].access_unit_size_pow2; [[m]]->num_substreams = [[mh]].num_substreams; [[m]]->max_decoded_substream = [[m]]->num_substreams - 1; [[m]]->avctx->sample_rate = [[mh]].group1_samplerate; [[m]]->avctx->frame_size = [[mh]].access_unit_size; [[m]]->avctx->bits_per_raw_sample = [[mh]].group1_bits; if ([[mh]].group1_bits > 16) [[m]]->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else [[m]]->avctx->sample_fmt = AV_SAMPLE_FMT_S16; [[m]]->params_valid = 1; for (substr = 0; substr < MAX_SUBSTREAMS; substr++) [[m]]->substream[substr].restart_seen = 0; if ([[m]]->avctx->codec_id == AV_CODEC_ID_MLP) { if ((substr = ([[mh]].num_substreams > 1))) [[m]]->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; [[m]]->substream[substr].ch_layout = [[mh]].channel_layout_mlp; } else { if ((substr = ([[mh]].num_substreams > 1))) [[m]]->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if ([[mh]].num_substreams > 2) if ([[mh]].channel_layout_thd_stream2) [[m]]->substream[2].ch_layout = [[mh]].channel_layout_thd_stream2; else [[m]]->substream[2].ch_layout = [[mh]].channel_layout_thd_stream1; [[m]]->substream[substr].ch_layout = [[mh]].channel_layout_thd_stream1; if ([[m]]->avctx->channels<=2 && [[m]]->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && [[m]]->max_decoded_substream == 1) { av_log([[m]]->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); [[m]]->max_decoded_substream = 0; if ([[m]]->avctx->channels==2) [[m]]->avctx->channel_layout = AV_CH_LAYOUT_STEREO; [[m]]->needs_reordering = [[mh]].channel_arrangement >= 18 && [[mh]].channel_arrangement <= 20; return 0;

[[[[Adv]]]]: static int read_major_sync(MLPDecodeContext *[[miilion]], GetBitContext *gb) { MLPHeaderInfo [[td]]; int substr, ret; if ((ret = ff_mlp_read_major_sync([[miilion]]->avctx, &[[td]], gb)) != 0) return ret; if ([[td]].group1_bits == 0) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "invalid/unknown bits per sample\n"); return AVERROR_INVALIDDATA; if ([[td]].group2_bits > [[td]].group1_bits) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "Channel group 2 cannot have more bits per sample than group 1.\n"); return AVERROR_INVALIDDATA; if ([[td]].group2_samplerate && [[td]].group2_samplerate != [[td]].group1_samplerate) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "Channel groups with differing sample rates are not currently supported.\n"); return AVERROR_INVALIDDATA; if ([[td]].group1_samplerate == 0) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "invalid/unknown sampling rate\n"); return AVERROR_INVALIDDATA; if ([[td]].group1_samplerate > MAX_SAMPLERATE) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "Sampling rate %d is greater than the supported maximum (%d).\n", [[td]].group1_samplerate, MAX_SAMPLERATE); return AVERROR_INVALIDDATA; if ([[td]].access_unit_size > MAX_BLOCKSIZE) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "Block size %d is greater than the supported maximum (%d).\n", [[td]].access_unit_size, MAX_BLOCKSIZE); return AVERROR_INVALIDDATA; if ([[td]].access_unit_size_pow2 > MAX_BLOCKSIZE_POW2) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "Block size pow2 %d is greater than the supported maximum (%d).\n", [[td]].access_unit_size_pow2, MAX_BLOCKSIZE_POW2); return AVERROR_INVALIDDATA; if ([[td]].num_substreams == 0) return AVERROR_INVALIDDATA; if ([[miilion]]->avctx->codec_id == AV_CODEC_ID_MLP && [[td]].num_substreams > 2) { av_log([[miilion]]->avctx, AV_LOG_ERROR, "MLP only supports up to 2 substreams.\n"); return AVERROR_INVALIDDATA; if ([[td]].num_substreams > MAX_SUBSTREAMS) { "%d substreams (more than the " "maximum supported by the decoder)", [[td]].num_substreams); [[miilion]]->access_unit_size = [[td]].access_unit_size; [[miilion]]->access_unit_size_pow2 = [[td]].access_unit_size_pow2; [[miilion]]->num_substreams = [[td]].num_substreams; [[miilion]]->max_decoded_substream = [[miilion]]->num_substreams - 1; [[miilion]]->avctx->sample_rate = [[td]].group1_samplerate; [[miilion]]->avctx->frame_size = [[td]].access_unit_size; [[miilion]]->avctx->bits_per_raw_sample = [[td]].group1_bits; if ([[td]].group1_bits > 16) [[miilion]]->avctx->sample_fmt = AV_SAMPLE_FMT_S32; else [[miilion]]->avctx->sample_fmt = AV_SAMPLE_FMT_S16; [[miilion]]->params_valid = 1; for (substr = 0; substr < MAX_SUBSTREAMS; substr++) [[miilion]]->substream[substr].restart_seen = 0; if ([[miilion]]->avctx->codec_id == AV_CODEC_ID_MLP) { if ((substr = ([[td]].num_substreams > 1))) [[miilion]]->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; [[miilion]]->substream[substr].ch_layout = [[td]].channel_layout_mlp; } else { if ((substr = ([[td]].num_substreams > 1))) [[miilion]]->substream[0].ch_layout = AV_CH_LAYOUT_STEREO; if ([[td]].num_substreams > 2) if ([[td]].channel_layout_thd_stream2) [[miilion]]->substream[2].ch_layout = [[td]].channel_layout_thd_stream2; else [[miilion]]->substream[2].ch_layout = [[td]].channel_layout_thd_stream1; [[miilion]]->substream[substr].ch_layout = [[td]].channel_layout_thd_stream1; if ([[miilion]]->avctx->channels<=2 && [[miilion]]->substream[substr].ch_layout == AV_CH_LAYOUT_MONO && [[miilion]]->max_decoded_substream == 1) { av_log([[miilion]]->avctx, AV_LOG_DEBUG, "Mono stream with 2 substreams, ignoring 2nd\n"); [[miilion]]->max_decoded_substream = 0; if ([[miilion]]->avctx->channels==2) [[miilion]]->avctx->channel_layout = AV_CH_LAYOUT_STEREO; [[miilion]]->needs_reordering = [[td]].channel_arrangement >= 18 && [[td]].channel_arrangement <= 20; return 0;
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 15 / 50 / 104:   4%|         | 104/2690 [00:44<18:19,  2.35it/s][Succeeded / Failed / Skipped / Total] 39 / 15 / 51 / 105:   4%|         | 105/2690 [00:46<19:16,  2.23it/s][Succeeded / Failed / Skipped / Total] 39 / 15 / 52 / 106:   4%|         | 106/2690 [00:47<19:19,  2.23it/s][Succeeded / Failed / Skipped / Total] 40 / 15 / 52 / 107:   4%|         | 107/2690 [00:49<20:01,  2.15it/s][[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void integratorcp_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; ARMCPU *cpu; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); MemoryRegion *ram_alias = g_new(MemoryRegion, 1); qemu_irq pic[32]; DeviceState *dev; int i; if (!cpu_model) { cpu_model = "arm926"; } cpu = cpu_arm_init(cpu_model); if (!cpu) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } memory_region_init_ram(ram, NULL, "integrator.ram", ram_size); vmstate_register_ram_global(ram); memory_region_add_subregion(address_space_mem, 0, ram); memory_region_init_alias(ram_alias, NULL, "ram.alias", ram, 0, ram_size); memory_region_add_subregion(address_space_mem, 0x80000000, ram_alias); dev = qdev_create(NULL, TYPE_INTEGRATOR_CM); qdev_prop_set_uint32(dev, "memsz", ram_size >> 20); qdev_init_nofail(dev); sysbus_mmio_map((SysBusDevice *)dev, 0, 0x10000000); dev = sysbus_create_varargs(TYPE_INTEGRATOR_PIC, 0x14000000, qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_IRQ), qdev_get_gpio_in(DEVICE(cpu), ARM_CPU_FIQ), NULL); for (i = 0; i < 32; i++) { pic[i] = qdev_get_gpio_in(dev, i); } sysbus_create_simple(TYPE_INTEGRATOR_PIC, 0xca000000, pic[26]); sysbus_create_varargs("integrator_pit", 0x13000000, pic[5], pic[6], pic[7], NULL); sysbus_create_simple("pl031", 0x15000000, pic[8]); sysbus_create_simple("pl011", 0x16000000, pic[1]); sysbus_create_simple("pl011", 0x17000000, pic[2]); icp_control_init(0xcb000000); sysbus_create_simple("pl050_keyboard", 0x18000000, pic[3]); sysbus_create_simple("pl050_mouse", 0x19000000, pic[4]); sysbus_create_varargs("pl181", 0x1c000000, pic[23], pic[24], NULL); if (nd_table[0].used) smc91c111_init(&nd_table[0], 0xc8000000, pic[27]); sysbus_create_simple("pl110", 0xc0000000, pic[22]); integrator_binfo.ram_size = ram_size; integrator_binfo.kernel_filename = kernel_filename; integrator_binfo.kernel_cmdline = kernel_cmdline; integrator_binfo.initrd_filename = initrd_filename; arm_load_kernel(cpu, &integrator_binfo); }
--------------------------------------------- Result 105 ---------------------------------------------
[[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int get_video_buffer(AVFrame *frame, int align) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(frame->format); int ret, i; if (!desc) return AVERROR(EINVAL); if ((ret = av_image_check_size(frame->width, frame->height, 0, NULL)) < 0) return ret; if (!frame->linesize[0]) { ret = av_image_fill_linesizes(frame->linesize, frame->format, frame->width); if (ret < 0) return ret; for (i = 0; i < 4 && frame->linesize[i]; i++) frame->linesize[i] = FFALIGN(frame->linesize[i], align); } for (i = 0; i < 4 && frame->linesize[i]; i++) { int h = FFALIGN(frame->height, 32); if (i == 1 || i == 2) h = -((-h) >> desc->log2_chroma_h); frame->buf[i] = av_buffer_alloc(frame->linesize[i] * h); if (!frame->buf[i]) goto fail; frame->data[i] = frame->buf[i]->data; } if (desc->flags & PIX_FMT_PAL || desc->flags & PIX_FMT_PSEUDOPAL) { av_buffer_unref(&frame->buf[1]); frame->buf[1] = av_buffer_alloc(1024); if (!frame->buf[1]) goto fail; frame->data[1] = frame->buf[1]->data; } frame->extended_data = frame->data; return 0; fail: av_frame_unref(frame); return AVERROR(ENOMEM); }
--------------------------------------------- Result 106 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static opj_image_t *mj2_create_image(AVCodecContext *avctx, opj_cparameters_t *parameters) { const AVPixFmtDescriptor *desc = av_pix_fmt_desc_get(avctx->pix_fmt); opj_image_cmptparm_t cmptparm[4] = {{0}}; opj_image_t *img; int i; int sub_dx[4]; int sub_dy[4]; int numcomps; OPJ_COLOR_SPACE color_space = CLRSPC_UNKNOWN; sub_dx[0] = sub_dx[3] = 1; sub_dy[0] = sub_dy[3] = 1; sub_dx[1] = sub_dx[2] = 1 << desc->log2_chroma_w; sub_dy[1] = sub_dy[2] = 1 << desc->log2_chroma_h; numcomps = desc->nb_components; switch (avctx->pix_fmt) { case AV_PIX_FMT_GRAY8: case AV_PIX_FMT_YA8: case AV_PIX_FMT_GRAY16: case AV_PIX_FMT_YA16: color_space = CLRSPC_GRAY; break; case AV_PIX_FMT_RGB24: case AV_PIX_FMT_RGBA: case AV_PIX_FMT_RGB48: case AV_PIX_FMT_RGBA64: case AV_PIX_FMT_GBR24P: case AV_PIX_FMT_GBRP9: case AV_PIX_FMT_GBRP10: case AV_PIX_FMT_GBRP12: case AV_PIX_FMT_GBRP14: case AV_PIX_FMT_GBRP16: case AV_PIX_FMT_XYZ12: color_space = CLRSPC_SRGB; break; case AV_PIX_FMT_YUV410P: case AV_PIX_FMT_YUV411P: case AV_PIX_FMT_YUV420P: case AV_PIX_FMT_YUV422P: case AV_PIX_FMT_YUV440P: case AV_PIX_FMT_YUV444P: case AV_PIX_FMT_YUVA420P: case AV_PIX_FMT_YUVA422P: case AV_PIX_FMT_YUVA444P: case AV_PIX_FMT_YUV420P9: case AV_PIX_FMT_YUV422P9: case AV_PIX_FMT_YUV444P9: case AV_PIX_FMT_YUVA420P9: case AV_PIX_FMT_YUVA422P9: case AV_PIX_FMT_YUVA444P9: case AV_PIX_FMT_YUV420P10: case AV_PIX_FMT_YUV422P10: case AV_PIX_FMT_YUV444P10: case AV_PIX_FMT_YUVA420P10: case AV_PIX_FMT_YUVA422P10: case AV_PIX_FMT_YUVA444P10: case AV_PIX_FMT_YUV420P12: case AV_PIX_FMT_YUV422P12: case AV_PIX_FMT_YUV444P12: case AV_PIX_FMT_YUV420P14: case AV_PIX_FMT_YUV422P14: case AV_PIX_FMT_YUV444P14: case AV_PIX_FMT_YUV420P16: case AV_PIX_FMT_YUV422P16: case AV_PIX_FMT_YUV444P16: case AV_PIX_FMT_YUVA420P16: case AV_PIX_FMT_YUVA422P16: case AV_PIX_FMT_YUVA444P16: color_space = CLRSPC_SYCC; break; default: av_log(avctx, AV_LOG_ERROR, "The requested pixel format '%s' is not supported\n", av_get_pix_fmt_name(avctx->pix_fmt)); } for (i = 0; i < numcomps; i++) { cmptparm[i].prec = desc->comp[i].depth_minus1 + 1; cmptparm[i].bpp = desc->comp[i].depth_minus1 + 1; cmptparm[i].sgnd = 0; cmptparm[i].dx = sub_dx[i]; cmptparm[i].dy = sub_dy[i]; cmptparm[i].w = (avctx->width + sub_dx[i] - 1) / sub_dx[i]; cmptparm[i].h = (avctx->height + sub_dy[i] - 1) / sub_dy[i]; } img = opj_image_create(numcomps, cmptparm, color_space); img->x0 = 0; img->y0 = 0; img->x1 = (avctx->width - 1) * parameters->subsampling_dx + 1; img->y1 = (avctx->height - 1) * parameters->subsampling_dy + 1; return img; }
--------------------------------------------- Result 107 ---------------------------------------------
[[0 (66%)]] --> [[0 (39%)]] --> Socre: 0.6090275347232819

[[[[Adv]]]]: void cpu_tick_set_count(CPUTimer *timer, uint64_t count) { uint64_t [[real_count]] = count & ~timer->disabled_mask; uint64_t [[disabled_bit]] = count & timer->disabled_mask; int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - cpu_to_timer_ticks([[real_count]], timer->frequency); TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n", timer->name, [[real_count]], timer->disabled?"disabled":"enabled", timer); timer->disabled = [[disabled_bit]] ? 1 : 0; timer->clock_offset = vm_clock_offset; }

[[[[Adv]]]]: void cpu_tick_set_count(CPUTimer *timer, uint64_t count) { uint64_t [[gyrate]] = count & ~timer->disabled_mask; uint64_t [[jessup]] = count & timer->disabled_mask; int64_t vm_clock_offset = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) - cpu_to_timer_ticks([[gyrate]], timer->frequency); TIMER_DPRINTF("%s set_count count=0x%016lx (%s) p=%p\n", timer->name, [[gyrate]], timer->disabled?"disabled":"enabled", timer); timer->disabled = [[jessup]] ? 1 : 0; timer->clock_offset = vm_clock_offset; }
--------------------------------------------- Result 108 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 16 / 52 / 108:   4%|         | 108/2690 [00:49<19:50,  2.17it/s][Succeeded / Failed / Skipped / Total] 41 / 16 / 52 / 109:   4%|         | 109/2690 [00:51<20:18,  2.12it/s][Succeeded / Failed / Skipped / Total] 41 / 16 / 52 / 109:   4%|         | 110/2690 [00:51<20:13,  2.13it/s][Succeeded / Failed / Skipped / Total] 41 / 16 / 53 / 110:   4%|         | 110/2690 [00:51<20:13,  2.13it/s][Succeeded / Failed / Skipped / Total] 41 / 16 / 53 / 110:   4%|         | 111/2690 [00:53<20:44,  2.07it/s][[0 (56%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *sbd) { DeviceState *dev = DEVICE(sbd); struct omap_gpif_s *s = OMAP1_GPIO(dev); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in(dev, omap_gpio_set, 16); qdev_init_gpio_out(dev, s->omap1.handler, 16); sysbus_init_irq(sbd, &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio(sbd, &s->iomem); return 0; }

[[[[Adv]]]]: static int omap_gpio_init(SysBusDevice *sbd) { DeviceState *dev = DEVICE(sbd); struct omap_gpif_s *s = OMAP1_GPIO(dev); if (!s->clk) { hw_error("omap-gpio: clk not connected\n"); } qdev_init_gpio_in(dev, omap_gpio_set, 16); qdev_init_gpio_out(dev, s->omap1.handler, 16); sysbus_init_irq(sbd, &s->omap1.irq); memory_region_init_io(&s->iomem, OBJECT(s), &omap_gpio_ops, &s->omap1, "omap.gpio", 0x1000); sysbus_init_mmio(sbd, &s->iomem); return 0; }
--------------------------------------------- Result 109 ---------------------------------------------
[[0 (61%)]] --> [[0 (49%)]] --> Socre: 0.5098347365856171

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *[[s]]) { BinDemuxContext *bin = [[s]]->priv_data; AVStream *[[st]] = avformat_new_stream([[s]], NULL); if (![[st]]) return NULL; [[st]]->codec->codec_tag = 0; [[st]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (!bin->width) { [[st]]->codec->width = (80<<3); [[st]]->codec->height = (25<<4); } avpriv_set_pts_info([[st]], 60, bin->framerate.den, bin->framerate.num); bin->chars_per_frame = FFMAX(av_q2d([[st]]->time_base) * bin->chars_per_frame, 1); return [[st]]; }

[[[[Adv]]]]: static AVStream * init_stream(AVFormatContext *[[oder]]) { BinDemuxContext *bin = [[oder]]->priv_data; AVStream *[[thoroughfare]] = avformat_new_stream([[oder]], NULL); if (![[thoroughfare]]) return NULL; [[thoroughfare]]->codec->codec_tag = 0; [[thoroughfare]]->codec->codec_type = AVMEDIA_TYPE_VIDEO; if (!bin->width) { [[thoroughfare]]->codec->width = (80<<3); [[thoroughfare]]->codec->height = (25<<4); } avpriv_set_pts_info([[thoroughfare]], 60, bin->framerate.den, bin->framerate.num); bin->chars_per_frame = FFMAX(av_q2d([[thoroughfare]]->time_base) * bin->chars_per_frame, 1); return [[thoroughfare]]; }
--------------------------------------------- Result 110 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void set_vlan(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { DeviceState *dev = DEVICE(obj); Property *prop = opaque; NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop); NetClientState **ptr = &peers_ptr->ncs[0]; Error *local_err = NULL; int32_t id; NetClientState *hubport; if (dev->realized) { qdev_prop_set_after_realize(dev, name, errp); visit_type_int32(v, &id, name, &local_err); if (local_err) { error_propagate(errp, local_err); if (id == -1) { *ptr = NULL; hubport = net_hub_port_find(id); if (!hubport) { error_set(errp, QERR_INVALID_PARAMETER_VALUE, name, prop->info->name); *ptr = hubport;
--------------------------------------------- Result 111 ---------------------------------------------
[[0 (37%)]] --> [[0 (50%)]] --> Socre: 0.5002702474594116

[[[[Adv]]]]: static int kvm_get_msrs(X86CPU *cpu) { CPUX86State *env = &cpu->env; struct kvm_msr_entry *[[msrs]] = cpu->kvm_msr_buf->entries; int [[ret]], i; uint64_t mtrr_top_bits; kvm_msr_buf_reset(cpu); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0); kvm_msr_entry_add(cpu, MSR_PAT, 0); if (has_msr_star) { kvm_msr_entry_add(cpu, MSR_STAR, 0); } if (has_msr_hsave_pa) { kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0); } if (has_msr_tsc_aux) { kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0); } if (has_msr_tsc_adjust) { kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0); } if (has_msr_tsc_deadline) { kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0); } if (has_msr_misc_enable) { kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0); } if (has_msr_smbase) { kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0); } if (has_msr_feature_control) { kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0); } if (has_msr_bndcfgs) { kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0); } if (has_msr_xss) { kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0); } if (!env->tsc_valid) { kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0); env->tsc_valid = !runstate_is_running(); } #ifdef TARGET_X86_64 if (lm_capable_kernel) { kvm_msr_entry_add(cpu, MSR_CSTAR, 0); kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0); kvm_msr_entry_add(cpu, MSR_FMASK, 0); kvm_msr_entry_add(cpu, MSR_LSTAR, 0); } #endif kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0); kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0); if (has_msr_async_pf_en) { kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0); } if (has_msr_pv_eoi_en) { kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0); } if (has_msr_kvm_steal_time) { kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0); } if (has_msr_architectural_pmu) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0); for (i = 0; i < MAX_FIXED_COUNTERS; i++) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0); } for (i = 0; i < num_architectural_pmu_counters; i++) { kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0); kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0); } } if (env->mcg_cap) { kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0); kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0); if (has_msr_mcg_ext_ctl) { kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0); } for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) { kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0); } } if (has_msr_hv_hypercall) { kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0); } if (has_msr_hv_vapic) { kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0); } if (has_msr_hv_tsc) { kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0); } if (has_msr_hv_crash) { int [[j]]; for ([[j]] = 0; [[j]] < HV_X64_MSR_CRASH_PARAMS; [[j]]++) { kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + [[j]], 0); } } if (has_msr_hv_runtime) { kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0); } if (cpu->hyperv_synic) { uint32_t [[msr]]; kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0); for ([[msr]] = HV_X64_MSR_SINT0; [[msr]] <= HV_X64_MSR_SINT15; [[msr]]++) { kvm_msr_entry_add(cpu, [[msr]], 0); } } if (has_msr_hv_stimer) { uint32_t [[msr]]; for ([[msr]] = HV_X64_MSR_STIMER0_CONFIG; [[msr]] <= HV_X64_MSR_STIMER3_COUNT; [[msr]]++) { kvm_msr_entry_add(cpu, [[msr]], 0); } } if (has_msr_mtrr) { kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0); for (i = 0; i < MSR_MTRRcap_VCNT; i++) { kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0); kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0); } } [[ret]] = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf); if ([[ret]] < 0) { return [[ret]]; } assert([[ret]] == cpu->kvm_msr_buf->nmsrs); if (cpu->fill_mtrr_mask) { QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52); assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS); mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits); } else { mtrr_top_bits = 0; } for (i = 0; i < [[ret]]; i++) { uint32_t index = [[msrs]][i].index; switch (index) { case MSR_IA32_SYSENTER_CS: env->sysenter_cs = [[msrs]][i].data; break; case MSR_IA32_SYSENTER_ESP: env->sysenter_esp = [[msrs]][i].data; break; case MSR_IA32_SYSENTER_EIP: env->sysenter_eip = [[msrs]][i].data; break; case MSR_PAT: env->pat = [[msrs]][i].data; break; case MSR_STAR: env->star = [[msrs]][i].data; break; #ifdef TARGET_X86_64 case MSR_CSTAR: env->cstar = [[msrs]][i].data; break; case MSR_KERNELGSBASE: env->kernelgsbase = [[msrs]][i].data; break; case MSR_FMASK: env->fmask = [[msrs]][i].data; break; case MSR_LSTAR: env->lstar = [[msrs]][i].data; break; #endif case MSR_IA32_TSC: env->tsc = [[msrs]][i].data; break; case MSR_TSC_AUX: env->tsc_aux = [[msrs]][i].data; break; case MSR_TSC_ADJUST: env->tsc_adjust = [[msrs]][i].data; break; case MSR_IA32_TSCDEADLINE: env->tsc_deadline = [[msrs]][i].data; break; case MSR_VM_HSAVE_PA: env->vm_hsave = [[msrs]][i].data; break; case MSR_KVM_SYSTEM_TIME: env->system_time_msr = [[msrs]][i].data; break; case MSR_KVM_WALL_CLOCK: env->wall_clock_msr = [[msrs]][i].data; break; case MSR_MCG_STATUS: env->mcg_status = [[msrs]][i].data; break; case MSR_MCG_CTL: env->mcg_ctl = [[msrs]][i].data; break; case MSR_MCG_EXT_CTL: env->mcg_ext_ctl = [[msrs]][i].data; break; case MSR_IA32_MISC_ENABLE: env->msr_ia32_misc_enable = [[msrs]][i].data; break; case MSR_IA32_SMBASE: env->smbase = [[msrs]][i].data; break; case MSR_IA32_FEATURE_CONTROL: env->msr_ia32_feature_control = [[msrs]][i].data; break; case MSR_IA32_BNDCFGS: env->msr_bndcfgs = [[msrs]][i].data; break; case MSR_IA32_XSS: env->xss = [[msrs]][i].data; break; default: if ([[msrs]][i].index >= MSR_MC0_CTL && [[msrs]][i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) { env->mce_banks[[[msrs]][i].index - MSR_MC0_CTL] = [[msrs]][i].data; } break; case MSR_KVM_ASYNC_PF_EN: env->async_pf_en_msr = [[msrs]][i].data; break; case MSR_KVM_PV_EOI_EN: env->pv_eoi_en_msr = [[msrs]][i].data; break; case MSR_KVM_STEAL_TIME: env->steal_time_msr = [[msrs]][i].data; break; case MSR_CORE_PERF_FIXED_CTR_CTRL: env->msr_fixed_ctr_ctrl = [[msrs]][i].data; break; case MSR_CORE_PERF_GLOBAL_CTRL: env->msr_global_ctrl = [[msrs]][i].data; break; case MSR_CORE_PERF_GLOBAL_STATUS: env->msr_global_status = [[msrs]][i].data; break; case MSR_CORE_PERF_GLOBAL_OVF_CTRL: env->msr_global_ovf_ctrl = [[msrs]][i].data; break; case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1: env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = [[msrs]][i].data; break; case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1: env->msr_gp_counters[index - MSR_P6_PERFCTR0] = [[msrs]][i].data; break; case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1: env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = [[msrs]][i].data; break; case HV_X64_MSR_HYPERCALL: env->msr_hv_hypercall = [[msrs]][i].data; break; case HV_X64_MSR_GUEST_OS_ID: env->msr_hv_guest_os_id = [[msrs]][i].data; break; case HV_X64_MSR_APIC_ASSIST_PAGE: env->msr_hv_vapic = [[msrs]][i].data; break; case HV_X64_MSR_REFERENCE_TSC: env->msr_hv_tsc = [[msrs]][i].data; break; case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = [[msrs]][i].data; break; case HV_X64_MSR_VP_RUNTIME: env->msr_hv_runtime = [[msrs]][i].data; break; case HV_X64_MSR_SCONTROL: env->msr_hv_synic_control = [[msrs]][i].data; break; case HV_X64_MSR_SVERSION: env->msr_hv_synic_version = [[msrs]][i].data; break; case HV_X64_MSR_SIEFP: env->msr_hv_synic_evt_page = [[msrs]][i].data; break; case HV_X64_MSR_SIMP: env->msr_hv_synic_msg_page = [[msrs]][i].data; break; case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = [[msrs]][i].data; break; case HV_X64_MSR_STIMER0_CONFIG: case HV_X64_MSR_STIMER1_CONFIG: case HV_X64_MSR_STIMER2_CONFIG: case HV_X64_MSR_STIMER3_CONFIG: env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] = [[msrs]][i].data; break; case HV_X64_MSR_STIMER0_COUNT: case HV_X64_MSR_STIMER1_COUNT: case HV_X64_MSR_STIMER2_COUNT: case HV_X64_MSR_STIMER3_COUNT: env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] = [[msrs]][i].data; break; case MSR_MTRRdefType: env->mtrr_deftype = [[msrs]][i].data; break; case MSR_MTRRfix64K_00000: env->mtrr_fixed[0] = [[msrs]][i].data; break; case MSR_MTRRfix16K_80000: env->mtrr_fixed[1] = [[msrs]][i].data; break; case MSR_MTRRfix16K_A0000: env->mtrr_fixed[2] = [[msrs]][i].data; break; case MSR_MTRRfix4K_C0000: env->mtrr_fixed[3] = [[msrs]][i].data; break; case MSR_MTRRfix4K_C8000: env->mtrr_fixed[4] = [[msrs]][i].data; break; case MSR_MTRRfix4K_D0000: env->mtrr_fixed[5] = [[msrs]][i].data; break; case MSR_MTRRfix4K_D8000: env->mtrr_fixed[6] = [[msrs]][i].data; break; case MSR_MTRRfix4K_E0000: env->mtrr_fixed[7] = [[msrs]][i].data; break; case MSR_MTRRfix4K_E8000: env->mtrr_fixed[8] = [[msrs]][i].data; break; case MSR_MTRRfix4K_F0000: env->mtrr_fixed[9] = [[msrs]][i].data; break; case MSR_MTRRfix4K_F8000: env->mtrr_fixed[10] = [[msrs]][i].data; break; case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1): if (index & 1) { env->mtrr_var[MSR_MTRRphysIndex(index)].mask = [[msrs]][i].data | mtrr_top_bits; } else { env->mtrr_var[MSR_MTRRphysIndex(index)].base = [[msrs]][i].data; } break; } } return 0; }

[[[[Adv]]]]: static int kvm_get_msrs(X86CPU *cpu) { CPUX86State *env = &cpu->env; struct kvm_msr_entry *[[essences]] = cpu->kvm_msr_buf->entries; int [[annuity]], i; uint64_t mtrr_top_bits; kvm_msr_buf_reset(cpu); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_CS, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_ESP, 0); kvm_msr_entry_add(cpu, MSR_IA32_SYSENTER_EIP, 0); kvm_msr_entry_add(cpu, MSR_PAT, 0); if (has_msr_star) { kvm_msr_entry_add(cpu, MSR_STAR, 0); } if (has_msr_hsave_pa) { kvm_msr_entry_add(cpu, MSR_VM_HSAVE_PA, 0); } if (has_msr_tsc_aux) { kvm_msr_entry_add(cpu, MSR_TSC_AUX, 0); } if (has_msr_tsc_adjust) { kvm_msr_entry_add(cpu, MSR_TSC_ADJUST, 0); } if (has_msr_tsc_deadline) { kvm_msr_entry_add(cpu, MSR_IA32_TSCDEADLINE, 0); } if (has_msr_misc_enable) { kvm_msr_entry_add(cpu, MSR_IA32_MISC_ENABLE, 0); } if (has_msr_smbase) { kvm_msr_entry_add(cpu, MSR_IA32_SMBASE, 0); } if (has_msr_feature_control) { kvm_msr_entry_add(cpu, MSR_IA32_FEATURE_CONTROL, 0); } if (has_msr_bndcfgs) { kvm_msr_entry_add(cpu, MSR_IA32_BNDCFGS, 0); } if (has_msr_xss) { kvm_msr_entry_add(cpu, MSR_IA32_XSS, 0); } if (!env->tsc_valid) { kvm_msr_entry_add(cpu, MSR_IA32_TSC, 0); env->tsc_valid = !runstate_is_running(); } #ifdef TARGET_X86_64 if (lm_capable_kernel) { kvm_msr_entry_add(cpu, MSR_CSTAR, 0); kvm_msr_entry_add(cpu, MSR_KERNELGSBASE, 0); kvm_msr_entry_add(cpu, MSR_FMASK, 0); kvm_msr_entry_add(cpu, MSR_LSTAR, 0); } #endif kvm_msr_entry_add(cpu, MSR_KVM_SYSTEM_TIME, 0); kvm_msr_entry_add(cpu, MSR_KVM_WALL_CLOCK, 0); if (has_msr_async_pf_en) { kvm_msr_entry_add(cpu, MSR_KVM_ASYNC_PF_EN, 0); } if (has_msr_pv_eoi_en) { kvm_msr_entry_add(cpu, MSR_KVM_PV_EOI_EN, 0); } if (has_msr_kvm_steal_time) { kvm_msr_entry_add(cpu, MSR_KVM_STEAL_TIME, 0); } if (has_msr_architectural_pmu) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_CTRL, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_STATUS, 0); kvm_msr_entry_add(cpu, MSR_CORE_PERF_GLOBAL_OVF_CTRL, 0); for (i = 0; i < MAX_FIXED_COUNTERS; i++) { kvm_msr_entry_add(cpu, MSR_CORE_PERF_FIXED_CTR0 + i, 0); } for (i = 0; i < num_architectural_pmu_counters; i++) { kvm_msr_entry_add(cpu, MSR_P6_PERFCTR0 + i, 0); kvm_msr_entry_add(cpu, MSR_P6_EVNTSEL0 + i, 0); } } if (env->mcg_cap) { kvm_msr_entry_add(cpu, MSR_MCG_STATUS, 0); kvm_msr_entry_add(cpu, MSR_MCG_CTL, 0); if (has_msr_mcg_ext_ctl) { kvm_msr_entry_add(cpu, MSR_MCG_EXT_CTL, 0); } for (i = 0; i < (env->mcg_cap & 0xff) * 4; i++) { kvm_msr_entry_add(cpu, MSR_MC0_CTL + i, 0); } } if (has_msr_hv_hypercall) { kvm_msr_entry_add(cpu, HV_X64_MSR_HYPERCALL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_GUEST_OS_ID, 0); } if (has_msr_hv_vapic) { kvm_msr_entry_add(cpu, HV_X64_MSR_APIC_ASSIST_PAGE, 0); } if (has_msr_hv_tsc) { kvm_msr_entry_add(cpu, HV_X64_MSR_REFERENCE_TSC, 0); } if (has_msr_hv_crash) { int [[duncan]]; for ([[duncan]] = 0; [[duncan]] < HV_X64_MSR_CRASH_PARAMS; [[duncan]]++) { kvm_msr_entry_add(cpu, HV_X64_MSR_CRASH_P0 + [[duncan]], 0); } } if (has_msr_hv_runtime) { kvm_msr_entry_add(cpu, HV_X64_MSR_VP_RUNTIME, 0); } if (cpu->hyperv_synic) { uint32_t [[yuan]]; kvm_msr_entry_add(cpu, HV_X64_MSR_SCONTROL, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SVERSION, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIEFP, 0); kvm_msr_entry_add(cpu, HV_X64_MSR_SIMP, 0); for ([[yuan]] = HV_X64_MSR_SINT0; [[yuan]] <= HV_X64_MSR_SINT15; [[yuan]]++) { kvm_msr_entry_add(cpu, [[yuan]], 0); } } if (has_msr_hv_stimer) { uint32_t [[yuan]]; for ([[yuan]] = HV_X64_MSR_STIMER0_CONFIG; [[yuan]] <= HV_X64_MSR_STIMER3_COUNT; [[yuan]]++) { kvm_msr_entry_add(cpu, [[yuan]], 0); } } if (has_msr_mtrr) { kvm_msr_entry_add(cpu, MSR_MTRRdefType, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix64K_00000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_80000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix16K_A0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_C8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_D8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_E8000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F0000, 0); kvm_msr_entry_add(cpu, MSR_MTRRfix4K_F8000, 0); for (i = 0; i < MSR_MTRRcap_VCNT; i++) { kvm_msr_entry_add(cpu, MSR_MTRRphysBase(i), 0); kvm_msr_entry_add(cpu, MSR_MTRRphysMask(i), 0); } } [[annuity]] = kvm_vcpu_ioctl(CPU(cpu), KVM_GET_MSRS, cpu->kvm_msr_buf); if ([[annuity]] < 0) { return [[annuity]]; } assert([[annuity]] == cpu->kvm_msr_buf->nmsrs); if (cpu->fill_mtrr_mask) { QEMU_BUILD_BUG_ON(TARGET_PHYS_ADDR_SPACE_BITS > 52); assert(cpu->phys_bits <= TARGET_PHYS_ADDR_SPACE_BITS); mtrr_top_bits = MAKE_64BIT_MASK(cpu->phys_bits, 52 - cpu->phys_bits); } else { mtrr_top_bits = 0; } for (i = 0; i < [[annuity]]; i++) { uint32_t index = [[essences]][i].index; switch (index) { case MSR_IA32_SYSENTER_CS: env->sysenter_cs = [[essences]][i].data; break; case MSR_IA32_SYSENTER_ESP: env->sysenter_esp = [[essences]][i].data; break; case MSR_IA32_SYSENTER_EIP: env->sysenter_eip = [[essences]][i].data; break; case MSR_PAT: env->pat = [[essences]][i].data; break; case MSR_STAR: env->star = [[essences]][i].data; break; #ifdef TARGET_X86_64 case MSR_CSTAR: env->cstar = [[essences]][i].data; break; case MSR_KERNELGSBASE: env->kernelgsbase = [[essences]][i].data; break; case MSR_FMASK: env->fmask = [[essences]][i].data; break; case MSR_LSTAR: env->lstar = [[essences]][i].data; break; #endif case MSR_IA32_TSC: env->tsc = [[essences]][i].data; break; case MSR_TSC_AUX: env->tsc_aux = [[essences]][i].data; break; case MSR_TSC_ADJUST: env->tsc_adjust = [[essences]][i].data; break; case MSR_IA32_TSCDEADLINE: env->tsc_deadline = [[essences]][i].data; break; case MSR_VM_HSAVE_PA: env->vm_hsave = [[essences]][i].data; break; case MSR_KVM_SYSTEM_TIME: env->system_time_msr = [[essences]][i].data; break; case MSR_KVM_WALL_CLOCK: env->wall_clock_msr = [[essences]][i].data; break; case MSR_MCG_STATUS: env->mcg_status = [[essences]][i].data; break; case MSR_MCG_CTL: env->mcg_ctl = [[essences]][i].data; break; case MSR_MCG_EXT_CTL: env->mcg_ext_ctl = [[essences]][i].data; break; case MSR_IA32_MISC_ENABLE: env->msr_ia32_misc_enable = [[essences]][i].data; break; case MSR_IA32_SMBASE: env->smbase = [[essences]][i].data; break; case MSR_IA32_FEATURE_CONTROL: env->msr_ia32_feature_control = [[essences]][i].data; break; case MSR_IA32_BNDCFGS: env->msr_bndcfgs = [[essences]][i].data; break; case MSR_IA32_XSS: env->xss = [[essences]][i].data; break; default: if ([[essences]][i].index >= MSR_MC0_CTL && [[essences]][i].index < MSR_MC0_CTL + (env->mcg_cap & 0xff) * 4) { env->mce_banks[[[essences]][i].index - MSR_MC0_CTL] = [[essences]][i].data; } break; case MSR_KVM_ASYNC_PF_EN: env->async_pf_en_msr = [[essences]][i].data; break; case MSR_KVM_PV_EOI_EN: env->pv_eoi_en_msr = [[essences]][i].data; break; case MSR_KVM_STEAL_TIME: env->steal_time_msr = [[essences]][i].data; break; case MSR_CORE_PERF_FIXED_CTR_CTRL: env->msr_fixed_ctr_ctrl = [[essences]][i].data; break; case MSR_CORE_PERF_GLOBAL_CTRL: env->msr_global_ctrl = [[essences]][i].data; break; case MSR_CORE_PERF_GLOBAL_STATUS: env->msr_global_status = [[essences]][i].data; break; case MSR_CORE_PERF_GLOBAL_OVF_CTRL: env->msr_global_ovf_ctrl = [[essences]][i].data; break; case MSR_CORE_PERF_FIXED_CTR0 ... MSR_CORE_PERF_FIXED_CTR0 + MAX_FIXED_COUNTERS - 1: env->msr_fixed_counters[index - MSR_CORE_PERF_FIXED_CTR0] = [[essences]][i].data; break; case MSR_P6_PERFCTR0 ... MSR_P6_PERFCTR0 + MAX_GP_COUNTERS - 1: env->msr_gp_counters[index - MSR_P6_PERFCTR0] = [[essences]][i].data; break; case MSR_P6_EVNTSEL0 ... MSR_P6_EVNTSEL0 + MAX_GP_COUNTERS - 1: env->msr_gp_evtsel[index - MSR_P6_EVNTSEL0] = [[essences]][i].data; break; case HV_X64_MSR_HYPERCALL: env->msr_hv_hypercall = [[essences]][i].data; break; case HV_X64_MSR_GUEST_OS_ID: env->msr_hv_guest_os_id = [[essences]][i].data; break; case HV_X64_MSR_APIC_ASSIST_PAGE: env->msr_hv_vapic = [[essences]][i].data; break; case HV_X64_MSR_REFERENCE_TSC: env->msr_hv_tsc = [[essences]][i].data; break; case HV_X64_MSR_CRASH_P0 ... HV_X64_MSR_CRASH_P4: env->msr_hv_crash_params[index - HV_X64_MSR_CRASH_P0] = [[essences]][i].data; break; case HV_X64_MSR_VP_RUNTIME: env->msr_hv_runtime = [[essences]][i].data; break; case HV_X64_MSR_SCONTROL: env->msr_hv_synic_control = [[essences]][i].data; break; case HV_X64_MSR_SVERSION: env->msr_hv_synic_version = [[essences]][i].data; break; case HV_X64_MSR_SIEFP: env->msr_hv_synic_evt_page = [[essences]][i].data; break; case HV_X64_MSR_SIMP: env->msr_hv_synic_msg_page = [[essences]][i].data; break; case HV_X64_MSR_SINT0 ... HV_X64_MSR_SINT15: env->msr_hv_synic_sint[index - HV_X64_MSR_SINT0] = [[essences]][i].data; break; case HV_X64_MSR_STIMER0_CONFIG: case HV_X64_MSR_STIMER1_CONFIG: case HV_X64_MSR_STIMER2_CONFIG: case HV_X64_MSR_STIMER3_CONFIG: env->msr_hv_stimer_config[(index - HV_X64_MSR_STIMER0_CONFIG)/2] = [[essences]][i].data; break; case HV_X64_MSR_STIMER0_COUNT: case HV_X64_MSR_STIMER1_COUNT: case HV_X64_MSR_STIMER2_COUNT: case HV_X64_MSR_STIMER3_COUNT: env->msr_hv_stimer_count[(index - HV_X64_MSR_STIMER0_COUNT)/2] = [[essences]][i].data; break; case MSR_MTRRdefType: env->mtrr_deftype = [[essences]][i].data; break; case MSR_MTRRfix64K_00000: env->mtrr_fixed[0] = [[essences]][i].data; break; case MSR_MTRRfix16K_80000: env->mtrr_fixed[1] = [[essences]][i].data; break; case MSR_MTRRfix16K_A0000: env->mtrr_fixed[2] = [[essences]][i].data; break; case MSR_MTRRfix4K_C0000: env->mtrr_fixed[3] = [[essences]][i].data; break; case MSR_MTRRfix4K_C8000: env->mtrr_fixed[4] = [[essences]][i].data; break; case MSR_MTRRfix4K_D0000: env->mtrr_fixed[5] = [[essences]][i].data; break; case MSR_MTRRfix4K_D8000: env->mtrr_fixed[6] = [[essences]][i].data; break; case MSR_MTRRfix4K_E0000: env->mtrr_fixed[7] = [[essences]][i].data; break; case MSR_MTRRfix4K_E8000: env->mtrr_fixed[8] = [[essences]][i].data; break; case MSR_MTRRfix4K_F0000: env->mtrr_fixed[9] = [[essences]][i].data; break; case MSR_MTRRfix4K_F8000: env->mtrr_fixed[10] = [[essences]][i].data; break; case MSR_MTRRphysBase(0) ... MSR_MTRRphysMask(MSR_MTRRcap_VCNT - 1): if (index & 1) { env->mtrr_var[MSR_MTRRphysIndex(index)].mask = [[essences]][i].data | mtrr_top_bits; } else { env->mtrr_var[MSR_MTRRphysIndex(index)].base = [[essences]][i].data; } break; } } return 0; }[Succeeded / Failed / Skipped / Total] 42 / 16 / 53 / 111:   4%|         | 111/2690 [00:53<20:44,  2.07it/s][Succeeded / Failed / Skipped / Total] 42 / 16 / 53 / 111:   4%|         | 112/2690 [00:54<20:43,  2.07it/s][Succeeded / Failed / Skipped / Total] 43 / 16 / 53 / 112:   4%|         | 112/2690 [00:54<20:43,  2.07it/s][Succeeded / Failed / Skipped / Total] 43 / 16 / 53 / 112:   4%|         | 113/2690 [00:54<20:43,  2.07it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 53 / 113:   4%|         | 113/2690 [00:54<20:43,  2.07it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 53 / 113:   4%|         | 114/2690 [00:54<20:34,  2.09it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 54 / 114:   4%|         | 114/2690 [00:54<20:34,  2.09it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 54 / 114:   4%|         | 115/2690 [00:55<20:33,  2.09it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 55 / 115:   4%|         | 115/2690 [00:55<20:33,  2.09it/s][Succeeded / Failed / Skipped / Total] 43 / 17 / 55 / 115:   4%|         | 116/2690 [00:56<21:01,  2.04it/s][Succeeded / Failed / Skipped / Total] 44 / 17 / 55 / 116:   4%|         | 116/2690 [00:56<21:01,  2.04it/s][Succeeded / Failed / Skipped / Total] 45 / 17 / 55 / 117:   4%|         | 117/2690 [00:56<20:50,  2.06it/s][Succeeded / Failed / Skipped / Total] 45 / 17 / 56 / 118:   4%|         | 118/2690 [00:56<20:39,  2.08it/s][Succeeded / Failed / Skipped / Total] 45 / 17 / 56 / 118:   4%|         | 119/2690 [00:57<20:38,  2.08it/s][Succeeded / Failed / Skipped / Total] 46 / 17 / 56 / 119:   4%|         | 119/2690 [00:57<20:38,  2.08it/s]
--------------------------------------------- Result 112 ---------------------------------------------
[[0 (16%)]] --> [[0 (60%)]] --> Socre: 0.6044275164604187

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *[[dev]]) { PCIXenPlatformState *[[d]] = DO_UPCAST(PCIXenPlatformState, pci_dev, [[dev]]); uint8_t *[[pci_conf]]; [[pci_conf]] = [[d]]->pci_dev.config; pci_set_word([[pci_conf]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[pci_conf]], 0); [[pci_conf]][PCI_INTERRUPT_PIN] = 1; pci_register_bar(&[[d]]->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[d]]->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[d]]); return 0; }

[[[[Adv]]]]: static int xen_platform_initfn(PCIDevice *[[anand]]) { PCIXenPlatformState *[[quattro]] = DO_UPCAST(PCIXenPlatformState, pci_dev, [[anand]]); uint8_t *[[jutting]]; [[jutting]] = [[quattro]]->pci_dev.config; pci_set_word([[jutting]] + PCI_COMMAND, PCI_COMMAND_IO | PCI_COMMAND_MEMORY); pci_config_set_prog_interface([[jutting]], 0); [[jutting]][PCI_INTERRUPT_PIN] = 1; pci_register_bar(&[[quattro]]->pci_dev, 0, 0x100, PCI_BASE_ADDRESS_SPACE_IO, platform_ioport_map); pci_register_bar(&[[quattro]]->pci_dev, 1, 0x1000000, PCI_BASE_ADDRESS_MEM_PREFETCH, platform_mmio_map); platform_fixed_ioport_init([[quattro]]); return 0; }
--------------------------------------------- Result 113 ---------------------------------------------
[[0 (3%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *bs) { return bs->removable; }

[[[[Adv]]]]: int bdrv_is_removable(BlockDriverState *bs) { return bs->removable; }
--------------------------------------------- Result 114 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void omap_mcbsp_i2s_attach(struct omap_mcbsp_s *s, I2SCodec *slave) { s->codec = slave; slave->rx_swallow = qemu_allocate_irqs(omap_mcbsp_i2s_swallow, s, 1)[0]; slave->tx_start = qemu_allocate_irqs(omap_mcbsp_i2s_start, s, 1)[0]; }
--------------------------------------------- Result 115 ---------------------------------------------
[[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void device_initfn(Object *obj) { DeviceState *dev = DEVICE(obj); Property *prop; if (qdev_hotplug) { dev->hotplugged = 1; qdev_hot_added = "True" == "True"; } dev->instance_id_alias = -1; dev->state = DEV_STATE_CREATED; qdev_prop_set_defaults(dev, qdev_get_props(dev)); for (prop = qdev_get_props(dev); prop && prop->name; prop++) { qdev_property_add_legacy(dev, prop, NULL); qdev_property_add_static(dev, prop, NULL); } object_property_add_str(OBJECT(dev), "type", qdev_get_type, NULL, NULL); }
--------------------------------------------- Result 116 ---------------------------------------------
[[0 (78%)]] --> [[0 (34%)]] --> Socre: 0.6636094152927399

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *[[avctx]]) { PNGDecContext *[[s]] = [[avctx]]->priv_data; ff_thread_release_buffer([[avctx]], &[[s]]->previous_picture); av_frame_free(&[[s]]->previous_picture.f); ff_thread_release_buffer([[avctx]], &[[s]]->last_picture); av_frame_free(&[[s]]->last_picture.f); ff_thread_release_buffer([[avctx]], &[[s]]->picture); av_frame_free(&[[s]]->picture.f); av_freep(&[[s]]->buffer); [[s]]->buffer_size = 0; av_freep(&[[s]]->last_row); [[s]]->last_row_size = 0; av_freep(&[[s]]->tmp_row); [[s]]->tmp_row_size = 0; av_freep(&[[s]]->extra_data); [[s]]->extra_data_size = 0; return 0; }

[[[[Adv]]]]: static av_cold int png_dec_end(AVCodecContext *[[facsimile]]) { PNGDecContext *[[p]] = [[facsimile]]->priv_data; ff_thread_release_buffer([[facsimile]], &[[p]]->previous_picture); av_frame_free(&[[p]]->previous_picture.f); ff_thread_release_buffer([[facsimile]], &[[p]]->last_picture); av_frame_free(&[[p]]->last_picture.f); ff_thread_release_buffer([[facsimile]], &[[p]]->picture); av_frame_free(&[[p]]->picture.f); av_freep(&[[p]]->buffer); [[p]]->buffer_size = 0; av_freep(&[[p]]->last_row); [[p]]->last_row_size = 0; av_freep(&[[p]]->tmp_row); [[p]]->tmp_row_size = 0; av_freep(&[[p]]->extra_data); [[p]]->extra_data_size = 0; return 0; }
--------------------------------------------- Result 117 ---------------------------------------------
[[0 (38%)]] --> [[0 (51%)]] --> Socre: 0.510888934135437

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *fs = av_mallocz(sizeof(*fs)); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int [[sxe]] = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = [[sxe]] - sxs; fs->slice_height = sye - sys; fs->slice_x = sxs; fs->slice_y = sys; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); if (!fs->sample_buffer) return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: av_cold int ffv1_init_slice_contexts(FFV1Context *f) { int i; f->slice_count = f->num_h_slices * f->num_v_slices; if (f->slice_count <= 0) { av_log(f->avctx, AV_LOG_ERROR, "Invalid number of slices\n"); return AVERROR(EINVAL); } for (i = 0; i < f->slice_count; i++) { FFV1Context *fs = av_mallocz(sizeof(*fs)); int sx = i % f->num_h_slices; int sy = i / f->num_h_slices; int sxs = f->avctx->width * sx / f->num_h_slices; int [[teleportation]] = f->avctx->width * (sx + 1) / f->num_h_slices; int sys = f->avctx->height * sy / f->num_v_slices; int sye = f->avctx->height * (sy + 1) / f->num_v_slices; f->slice_context[i] = fs; memcpy(fs, f, sizeof(*fs)); memset(fs->rc_stat2, 0, sizeof(fs->rc_stat2)); fs->slice_width = [[teleportation]] - sxs; fs->slice_height = sye - sys; fs->slice_x = sxs; fs->slice_y = sys; fs->sample_buffer = av_malloc(3 * MAX_PLANES * (fs->width + 6) * sizeof(*fs->sample_buffer)); if (!fs->sample_buffer) return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 118 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void fd_chr_update_read_handler(CharDriverState *chr) { FDCharDriver *s = chr->opaque; if (s->fd_in_tag) { g_source_remove(s->fd_in_tag); s->fd_in_tag = 0; } if (s->fd_in) { s->fd_in_tag = io_add_watch_poll(s->fd_in, fd_chr_read_poll, fd_chr_read, chr); } }
--------------------------------------------- Result 119 ---------------------------------------------
[[0 (10%)]] --> [[0 (54%)]] --> Socre: 0.5439161658287048

[[[[Adv]]]]: int floatx80_eq(floatx80 [[a]], floatx80 [[b]], float_status *[[status]]) { if ( ( ( extractFloatx80Exp( [[a]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[a]] )<<1 ) ) || ( ( extractFloatx80Exp( [[b]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[b]] )<<1 ) ) ) { float_raise(float_flag_invalid, [[status]]); return 0; } return ( [[a]].low == [[b]].low ) && ( ( [[a]].high == [[b]].high ) || ( ( [[a]].low == 0 ) && ( (uint16_t) ( ( [[a]].high | [[b]].high )<<1 ) == 0 ) ) ); }

[[[[Adv]]]]: int floatx80_eq(floatx80 [[latest]], floatx80 [[tres]], float_status *[[diseases]]) { if ( ( ( extractFloatx80Exp( [[latest]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[latest]] )<<1 ) ) || ( ( extractFloatx80Exp( [[tres]] ) == 0x7FFF ) && (uint64_t) ( extractFloatx80Frac( [[tres]] )<<1 ) ) ) { float_raise(float_flag_invalid, [[diseases]]); return 0; } return ( [[latest]].low == [[tres]].low ) && ( ( [[latest]].high == [[tres]].high ) || ( ( [[latest]].low == 0 ) && ( (uint16_t) ( ( [[latest]].high | [[tres]].high )<<1 ) == 0 ) ) ); }
--------------------------------------------- Result 120 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 46 / 17 / 57 / 120:   4%|         | 120/2690 [00:58<20:53,  2.05it/s][Succeeded / Failed / Skipped / Total] 46 / 17 / 58 / 121:   4%|         | 121/2690 [01:00<21:28,  1.99it/s][Succeeded / Failed / Skipped / Total] 46 / 17 / 58 / 121:   5%|         | 122/2690 [01:01<21:28,  1.99it/s][Succeeded / Failed / Skipped / Total] 47 / 17 / 58 / 122:   5%|         | 122/2690 [01:01<21:28,  1.99it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 58 / 123:   5%|         | 123/2690 [01:01<21:17,  2.01it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 59 / 124:   5%|         | 124/2690 [01:01<21:09,  2.02it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 59 / 124:   5%|         | 125/2690 [01:03<21:34,  1.98it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 60 / 125:   5%|         | 125/2690 [01:03<21:34,  1.98it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 61 / 126:   5%|         | 126/2690 [01:04<21:46,  1.96it/s][[0 (11%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void bios_linker_loader_alloc(GArray *linker, const char *file, uint32_t alloc_align, bool alloc_fseg) { BiosLinkerLoaderEntry entry; assert(!(alloc_align & (alloc_align - 1))); memset(&entry, 0, sizeof entry); strncpy(entry.alloc.file, file, sizeof entry.alloc.file - 1); entry.command = cpu_to_le32(BIOS_LINKER_LOADER_COMMAND_ALLOCATE); entry.alloc.align = cpu_to_le32(alloc_align); entry.alloc.zone = cpu_to_le32(alloc_fseg ? BIOS_LINKER_LOADER_ALLOC_ZONE_FSEG : BIOS_LINKER_LOADER_ALLOC_ZONE_HIGH); g_array_prepend_vals(linker, &entry, sizeof entry); }
--------------------------------------------- Result 121 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int probe_file(WriterContext *wctx, const char *filename) { AVFormatContext *fmt_ctx; int ret, i; int section_id; do_read_frames = do_show_frames || do_count_frames; do_read_packets = do_show_packets || do_count_packets; ret = open_input_file(&fmt_ctx, filename); if (ret < 0) return ret; #define CHECK_END if (ret < 0) goto end nb_streams_frames = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_frames)); nb_streams_packets = av_calloc(fmt_ctx->nb_streams, sizeof(*nb_streams_packets)); selected_streams = av_calloc(fmt_ctx->nb_streams, sizeof(*selected_streams)); for (i = 0; i < fmt_ctx->nb_streams; i++) { if (stream_specifier) { ret = avformat_match_stream_specifier(fmt_ctx, fmt_ctx->streams[i], stream_specifier); CHECK_END; else selected_streams[i] = ret; ret = 0; } else { selected_streams[i] = 1; } } if (do_read_frames || do_read_packets) { if (do_show_frames && do_show_packets && wctx->writer->flags & WRITER_FLAG_PUT_PACKETS_AND_FRAMES_IN_SAME_CHAPTER) section_id = SECTION_ID_PACKETS_AND_FRAMES; else if (do_show_packets && !do_show_frames) section_id = SECTION_ID_PACKETS; else section_id = SECTION_ID_FRAMES; if (do_show_frames || do_show_packets) writer_print_section_header(wctx, section_id); ret = read_packets(wctx, fmt_ctx); if (do_show_frames || do_show_packets) writer_print_section_footer(wctx); CHECK_END; } if (do_show_programs) { ret = show_programs(wctx, fmt_ctx); CHECK_END; } if (do_show_streams) { ret = show_streams(wctx, fmt_ctx); CHECK_END; } if (do_show_chapters) { ret = show_chapters(wctx, fmt_ctx); CHECK_END; } if (do_show_format) { ret = show_format(wctx, fmt_ctx); CHECK_END; } end: close_input_file(&fmt_ctx); av_freep(&nb_streams_frames); av_freep(&nb_streams_packets); av_freep(&selected_streams); return ret; }
--------------------------------------------- Result 122 ---------------------------------------------
[[0 (1%)]] --> [[0 (52%)]] --> Socre: 0.5188698172569275

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[opaque]], target_phys_addr_t offset) { uint32_t val; val = gic_dist_readb([[opaque]], offset); val |= gic_dist_readb([[opaque]], offset + 1) << 8; return val; }

[[[[Adv]]]]: static uint32_t gic_dist_readw(void *[[inscrutable]], target_phys_addr_t offset) { uint32_t val; val = gic_dist_readb([[inscrutable]], offset); val |= gic_dist_readb([[inscrutable]], offset + 1) << 8; return val; }
--------------------------------------------- Result 123 ---------------------------------------------
[[0 (23%)]] --> [[0 (52%)]] --> Socre: 0.5216712355613708

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t [[sector_num]], QEMUIOVector *[[qiov]], int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque, int type) { struct qemu_paiocb *acb; acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque); if (!acb) return NULL; acb->aio_type = type; acb->aio_fildes = fd; acb->ev_signo = SIGUSR2; acb->async_context_id = get_async_context_id(); if ([[qiov]]) { acb->aio_iov = [[qiov]]->iov; acb->aio_niov = [[qiov]]->niov; } acb->aio_nbytes = nb_sectors * 512; acb->aio_offset = [[sector_num]] * 512; acb->next = posix_aio_state->first_aio; posix_aio_state->first_aio = acb; trace_paio_submit(acb, opaque, [[sector_num]], nb_sectors, type); qemu_paio_submit(acb); return &acb->common; }

[[[[Adv]]]]: BlockDriverAIOCB *paio_submit(BlockDriverState *bs, int fd, int64_t [[hammock]], QEMUIOVector *[[ghostbuster]], int nb_sectors, BlockDriverCompletionFunc *cb, void *opaque, int type) { struct qemu_paiocb *acb; acb = qemu_aio_get(&raw_aio_pool, bs, cb, opaque); if (!acb) return NULL; acb->aio_type = type; acb->aio_fildes = fd; acb->ev_signo = SIGUSR2; acb->async_context_id = get_async_context_id(); if ([[ghostbuster]]) { acb->aio_iov = [[ghostbuster]]->iov; acb->aio_niov = [[ghostbuster]]->niov; } acb->aio_nbytes = nb_sectors * 512; acb->aio_offset = [[hammock]] * 512; acb->next = posix_aio_state->first_aio; posix_aio_state->first_aio = acb; trace_paio_submit(acb, opaque, [[hammock]], nb_sectors, type); qemu_paio_submit(acb); return &acb->common; }
--------------------------------------------- Result 124 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void iscsi_refresh_limits(BlockDriverState *bs, Error **errp) { IscsiLun *iscsilun = bs->opaque; uint64_t max_xfer_len = iscsilun->use_16_for_rw ? 0xffffffff : 0xffff; bs->bl.request_alignment = iscsilun->block_size; if (iscsilun->bl.max_xfer_len) { max_xfer_len = MIN(max_xfer_len, iscsilun->bl.max_xfer_len); } if (max_xfer_len * iscsilun->block_size < INT_MAX) { bs->bl.max_transfer = max_xfer_len * iscsilun->block_size; } if (iscsilun->lbp.lbpu) { if (iscsilun->bl.max_unmap < 0xffffffff / iscsilun->block_size) { bs->bl.max_pdiscard = iscsilun->bl.max_unmap * iscsilun->block_size; } bs->bl.pdiscard_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pdiscard_alignment = iscsilun->block_size; } if (iscsilun->bl.max_ws_len < 0xffffffff / iscsilun->block_size) { bs->bl.max_pwrite_zeroes = iscsilun->bl.max_ws_len * iscsilun->block_size; } if (iscsilun->lbp.lbpws) { bs->bl.pwrite_zeroes_alignment = iscsilun->bl.opt_unmap_gran * iscsilun->block_size; } else { bs->bl.pwrite_zeroes_alignment = iscsilun->block_size; } if (iscsilun->bl.opt_xfer_len && iscsilun->bl.opt_xfer_len < INT_MAX / iscsilun->block_size) { bs->bl.opt_transfer = pow2floor(iscsilun->bl.opt_xfer_len * iscsilun->block_size); } }
--------------------------------------------- Result 125 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int kvm_physical_sync_dirty_bitmap(target_phys_addr_t start_addr, target_phys_addr_t end_addr) { KVMState *s = kvm_state; unsigned long size, allocated_size = 0; KVMDirtyLog d; KVMSlot *mem; int ret = 0; d.dirty_bitmap = NULL; while (start_addr < end_addr) { mem = kvm_lookup_overlapping_slot(s, start_addr, end_addr); if (mem == NULL) { break; } size = ALIGN(((mem->memory_size) >> TARGET_PAGE_BITS), HOST_LONG_BITS) / 8; if (!d.dirty_bitmap) { d.dirty_bitmap = qemu_malloc(size); } else if (size > allocated_size) { d.dirty_bitmap = qemu_realloc(d.dirty_bitmap, size); } allocated_size = size; memset(d.dirty_bitmap, 0, allocated_size); d.slot = mem->slot; if (kvm_vm_ioctl(s, KVM_GET_DIRTY_LOG, &d) == -1) { DPRINTF("ioctl failed %d\n", errno); ret = -1; break; } kvm_get_dirty_pages_log_range(mem->start_addr, d.dirty_bitmap, mem->start_addr, mem->memory_size); start_addr = mem->start_addr + mem->memory_size; } qemu_free(d.dirty_bitmap); return ret; }
--------------------------------------------- Result 126 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void test_qemu_strtoull_overflow(void) { const char *str = "99999999999999999999999999999999999999999999"; char f = 'X'; const char *endptr = &f; uint64_t res = 999; int err; err = qemu_strtoull(str, &endptr, 0, &res); g_assert_cmpint(err, ==, -ERANGE); g_assert_cmpint(res, ==, ULLONG_MAX); g_assert(endptr == str + strlen(str)); }
--------------------------------------------- Result 127 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 17 / 62 / 127:   5%|         | 127/2690 [01:04<21:35,  1.98it/s][Succeeded / Failed / Skipped / Total] 48 / 17 / 62 / 127:   5%|         | 128/2690 [01:04<21:35,  1.98it/s][Succeeded / Failed / Skipped / Total] 49 / 17 / 62 / 128:   5%|         | 128/2690 [01:04<21:35,  1.98it/s][Succeeded / Failed / Skipped / Total] 49 / 18 / 62 / 129:   5%|         | 129/2690 [01:05<21:42,  1.97it/s][[0 (13%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int floppy_probe_device(const char *filename) { int fd, ret; int prio = 0; struct floppy_struct fdparam; struct stat st; if (strstart(filename, "/dev/fd", NULL) && !strstart(filename, "/dev/fdset/", NULL)) { prio = 50; } fd = qemu_open(filename, O_RDONLY | O_NONBLOCK); if (fd < 0) { goto out; } ret = fstat(fd, &st); if (ret == -1 || !S_ISBLK(st.st_mode)) { goto outc; } ret = ioctl(fd, FDGETPRM, &fdparam); if (ret >= 0) prio = 100; outc: qemu_close(fd); out: return prio; }
--------------------------------------------- Result 128 ---------------------------------------------
[[0 (17%)]] --> [[0 (53%)]] --> Socre: 0.5328482985496521

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *[[dev]], Error **[[errp]]) { DriveInfo *dinfo; Error *[[local_err]] = NULL; if (![[dev]]->conf.bs) { scsi_realize([[dev]], &[[local_err]]); assert([[local_err]]); error_propagate([[errp]], [[local_err]]); return; } dinfo = drive_get_by_blockdev([[dev]]->conf.bs); if (dinfo->media_cd) { scsi_cd_realize([[dev]], [[errp]]); } else { scsi_hd_realize([[dev]], [[errp]]); } }

[[[[Adv]]]]: static void scsi_disk_realize(SCSIDevice *[[rohit]], Error **[[unwritten]]) { DriveInfo *dinfo; Error *[[laps]] = NULL; if (![[rohit]]->conf.bs) { scsi_realize([[rohit]], &[[laps]]); assert([[laps]]); error_propagate([[unwritten]], [[laps]]); return; } dinfo = drive_get_by_blockdev([[rohit]]->conf.bs); if (dinfo->media_cd) { scsi_cd_realize([[rohit]], [[unwritten]]); } else { scsi_hd_realize([[rohit]], [[unwritten]]); } }
--------------------------------------------- Result 129 ---------------------------------------------
[[0 (52%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height, uint8_t *qp_store, int qp_stride) { int x, y, i, j; const int count = 1<<p->log2_count; for (i = 0; i < 3; i++) { int is_chroma = !!i; int w = width >> (is_chroma ? p->hsub : 0); int h = height >> (is_chroma ? p->vsub : 0); int stride = p->temp_stride[i]; int block = BLOCK >> (is_chroma ? p->hsub : 0); if (!src[i] || !dst[i]) continue; for (y = 0; y < h; y++) { int index = block + block * stride + y * stride; memcpy(p->src[i] + index, src[i] + y * src_stride[i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * stride, p->src[i] + ( y+block ) * stride, stride); memcpy(p->src[i] + (h+block +y) * stride, p->src[i] + (h-y+block-1) * stride, stride); } p->frame->linesize[i] = stride; memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += qp_store[x + y * qp_stride]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < count; i++) { const int x1 = offset[i+count-1][0]; const int y1 = offset[i+count-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || !dst[2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int is_chroma = !!j; if (!dst[j]) continue; store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> (is_chroma ? p->hsub : 0), height >> (is_chroma ? p->vsub : 0), 8-p->log2_count); } }

[[[[Adv]]]]: static void filter(USPPContext *p, uint8_t *dst[3], uint8_t *src[3], int dst_stride[3], int src_stride[3], int width, int height, uint8_t *qp_store, int qp_stride) { int x, y, i, j; const int count = 1<<p->log2_count; for (i = 0; i < 3; i++) { int is_chroma = !!i; int w = width >> (is_chroma ? p->hsub : 0); int h = height >> (is_chroma ? p->vsub : 0); int stride = p->temp_stride[i]; int block = BLOCK >> (is_chroma ? p->hsub : 0); if (!src[i] || !dst[i]) continue; for (y = 0; y < h; y++) { int index = block + block * stride + y * stride; memcpy(p->src[i] + index, src[i] + y * src_stride[i], w ); for (x = 0; x < block; x++) { p->src[i][index - x - 1] = p->src[i][index + x ]; p->src[i][index + w + x ] = p->src[i][index + w - x - 1]; } } for (y = 0; y < block; y++) { memcpy(p->src[i] + ( block-1-y) * stride, p->src[i] + ( y+block ) * stride, stride); memcpy(p->src[i] + (h+block +y) * stride, p->src[i] + (h-y+block-1) * stride, stride); } p->frame->linesize[i] = stride; memset(p->temp[i], 0, (h + 2 * block) * stride * sizeof(int16_t)); } if (p->qp) p->frame->quality = p->qp * FF_QP2LAMBDA; else { int qpsum=0; int qpcount = (height>>4) * (height>>4); for (y = 0; y < (height>>4); y++) { for (x = 0; x < (width>>4); x++) qpsum += qp_store[x + y * qp_stride]; } p->frame->quality = norm_qscale((qpsum + qpcount/2) / qpcount, p->qscale_type) * FF_QP2LAMBDA; } p->frame->height = height; p->frame->width = width; for (i = 0; i < count; i++) { const int x1 = offset[i+count-1][0]; const int y1 = offset[i+count-1][1]; const int x1c = x1 >> p->hsub; const int y1c = y1 >> p->vsub; const int BLOCKc = BLOCK >> p->hsub; int offset; AVPacket pkt; int got_pkt_ptr; av_init_packet(&pkt); pkt.data = p->outbuf; pkt.size = p->outbuf_size; p->frame->data[0] = p->src[0] + x1 + y1 * p->frame->linesize[0]; p->frame->data[1] = p->src[1] + x1c + y1c * p->frame->linesize[1]; p->frame->data[2] = p->src[2] + x1c + y1c * p->frame->linesize[2]; p->frame->format = p->avctx_enc[i]->pix_fmt; avcodec_encode_video2(p->avctx_enc[i], &pkt, p->frame, &got_pkt_ptr); p->frame_dec = p->avctx_enc[i]->coded_frame; offset = (BLOCK-x1) + (BLOCK-y1) * p->frame_dec->linesize[0]; for (y = 0; y < height; y++) for (x = 0; x < width; x++) p->temp[0][x + y * p->temp_stride[0]] += p->frame_dec->data[0][x + y * p->frame_dec->linesize[0] + offset]; if (!src[2] || !dst[2]) continue; offset = (BLOCKc-x1c) + (BLOCKc-y1c) * p->frame_dec->linesize[1]; for (y = 0; y < height>>p->vsub; y++) { for (x = 0; x < width>>p->hsub; x++) { p->temp[1][x + y * p->temp_stride[1]] += p->frame_dec->data[1][x + y * p->frame_dec->linesize[1] + offset]; p->temp[2][x + y * p->temp_stride[2]] += p->frame_dec->data[2][x + y * p->frame_dec->linesize[2] + offset]; } } } for (j = 0; j < 3; j++) { int is_chroma = !!j; if (!dst[j]) continue; store_slice_c(dst[j], p->temp[j], dst_stride[j], p->temp_stride[j], width >> (is_chroma ? p->hsub : 0), height >> (is_chroma ? p->vsub : 0), 8-p->log2_count); } }
--------------------------------------------- Result 130 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 19 / 62 / 130:   5%|         | 130/2690 [01:06<21:40,  1.97it/s][Succeeded / Failed / Skipped / Total] 49 / 19 / 62 / 130:   5%|         | 131/2690 [01:06<21:30,  1.98it/s][[0 (24%)]] --> [[[FAILED]]]

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int sdram_size) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s->env = cpu_init("pxa255"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0]; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size, qemu_ram_alloc(NULL, "pxa255.sdram", sdram_size) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s->pic = pxa2xx_pic_init(0x40d00000, s->env); s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]); pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]); s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv, s->pic[PXA2XX_PIC_MMC], s->dma); for (i = 0; pxa255_serial[i].io_base; i ++) if (serial_hds[i]) { #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 1); #else serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 0); #endif } else { break; } if (serial_hds[i]) s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP], s->dma, serial_hds[i]); s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]); s->cm_base = 0x41300000; s->cm_regs[CCCR >> 2] = 0x02000210; s->clkcfg = 0x00000009; iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s->mm_base = 0x48000000; s->mm_regs[MDMRS >> 2] = 0x00020002; s->mm_regs[MDREFR >> 2] = 0x03ca4000; s->mm_regs[MECR >> 2] = 0x00000001; iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s->pm_base = 0x40f00000; iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->pm_base, 0x100, iomemtype); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_ssp[i].io_base; i ++); s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_ssp[i].io_base; i ++) { DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[i].io_base, s->pic[pxa255_ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi"); } if (usb_enabled) { sysbus_create_simple("sysbus-ohci", 0x4c000000, s->pic[PXA2XX_PIC_USBH1]); } s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000); s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000); s->rtc_base = 0x40900000; iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff); s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff); s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma); qdev_connect_gpio_out(s->gpio, 1, s->reset); return s; }

[[[[Adv]]]]: PXA2xxState *pxa255_init(unsigned int sdram_size) { PXA2xxState *s; int iomemtype, i; DriveInfo *dinfo; s = (PXA2xxState *) qemu_mallocz(sizeof(PXA2xxState)); s->env = cpu_init("pxa255"); if (!s->env) { fprintf(stderr, "Unable to find CPU definition\n"); exit(1); } s->reset = qemu_allocate_irqs(pxa2xx_reset, s, 1)[0]; cpu_register_physical_memory(PXA2XX_SDRAM_BASE, sdram_size, qemu_ram_alloc(NULL, "pxa255.sdram", sdram_size) | IO_MEM_RAM); cpu_register_physical_memory(PXA2XX_INTERNAL_BASE, PXA2XX_INTERNAL_SIZE, qemu_ram_alloc(NULL, "pxa255.internal", PXA2XX_INTERNAL_SIZE) | IO_MEM_RAM); s->pic = pxa2xx_pic_init(0x40d00000, s->env); s->dma = pxa255_dma_init(0x40000000, s->pic[PXA2XX_PIC_DMA]); pxa25x_timer_init(0x40a00000, &s->pic[PXA2XX_PIC_OST_0]); s->gpio = pxa2xx_gpio_init(0x40e00000, s->env, s->pic, 85); dinfo = drive_get(IF_SD, 0, 0); if (!dinfo) { fprintf(stderr, "qemu: missing SecureDigital device\n"); exit(1); } s->mmc = pxa2xx_mmci_init(0x41100000, dinfo->bdrv, s->pic[PXA2XX_PIC_MMC], s->dma); for (i = 0; pxa255_serial[i].io_base; i ++) if (serial_hds[i]) { #ifdef TARGET_WORDS_BIGENDIAN serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 1); #else serial_mm_init(pxa255_serial[i].io_base, 2, s->pic[pxa255_serial[i].irqn], 14745600/16, serial_hds[i], 1, 0); #endif } else { break; } if (serial_hds[i]) s->fir = pxa2xx_fir_init(0x40800000, s->pic[PXA2XX_PIC_ICP], s->dma, serial_hds[i]); s->lcd = pxa2xx_lcdc_init(0x44000000, s->pic[PXA2XX_PIC_LCD]); s->cm_base = 0x41300000; s->cm_regs[CCCR >> 2] = 0x02000210; s->clkcfg = 0x00000009; iomemtype = cpu_register_io_memory(pxa2xx_cm_readfn, pxa2xx_cm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->cm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_cm", 0, 0, pxa2xx_cm_save, pxa2xx_cm_load, s); cpu_arm_set_cp_io(s->env, 14, pxa2xx_cp14_read, pxa2xx_cp14_write, s); s->mm_base = 0x48000000; s->mm_regs[MDMRS >> 2] = 0x00020002; s->mm_regs[MDREFR >> 2] = 0x03ca4000; s->mm_regs[MECR >> 2] = 0x00000001; iomemtype = cpu_register_io_memory(pxa2xx_mm_readfn, pxa2xx_mm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->mm_base, 0x1000, iomemtype); register_savevm(NULL, "pxa2xx_mm", 0, 0, pxa2xx_mm_save, pxa2xx_mm_load, s); s->pm_base = 0x40f00000; iomemtype = cpu_register_io_memory(pxa2xx_pm_readfn, pxa2xx_pm_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->pm_base, 0x100, iomemtype); register_savevm(NULL, "pxa2xx_pm", 0, 0, pxa2xx_pm_save, pxa2xx_pm_load, s); for (i = 0; pxa255_ssp[i].io_base; i ++); s->ssp = (SSIBus **)qemu_mallocz(sizeof(SSIBus *) * i); for (i = 0; pxa255_ssp[i].io_base; i ++) { DeviceState *dev; dev = sysbus_create_simple("pxa2xx-ssp", pxa255_ssp[i].io_base, s->pic[pxa255_ssp[i].irqn]); s->ssp[i] = (SSIBus *)qdev_get_child_bus(dev, "ssi"); } if (usb_enabled) { sysbus_create_simple("sysbus-ohci", 0x4c000000, s->pic[PXA2XX_PIC_USBH1]); } s->pcmcia[0] = pxa2xx_pcmcia_init(0x20000000); s->pcmcia[1] = pxa2xx_pcmcia_init(0x30000000); s->rtc_base = 0x40900000; iomemtype = cpu_register_io_memory(pxa2xx_rtc_readfn, pxa2xx_rtc_writefn, s, DEVICE_NATIVE_ENDIAN); cpu_register_physical_memory(s->rtc_base, 0x1000, iomemtype); pxa2xx_rtc_init(s); register_savevm(NULL, "pxa2xx_rtc", 0, 0, pxa2xx_rtc_save, pxa2xx_rtc_load, s); s->i2c[0] = pxa2xx_i2c_init(0x40301600, s->pic[PXA2XX_PIC_I2C], 0xffff); s->i2c[1] = pxa2xx_i2c_init(0x40f00100, s->pic[PXA2XX_PIC_PWRI2C], 0xff); s->i2s = pxa2xx_i2s_init(0x40400000, s->pic[PXA2XX_PIC_I2S], s->dma); qdev_connect_gpio_out(s->gpio, 1, s->reset); return s; }
--------------------------------------------- Result 131 ---------------------------------------------
[[0 (42%)]] --> [[0 (54%)]] --> Socre: 0.5440177321434021

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *[[kernel_cmdline]], const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int [[ret]], linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int [[drive_index]]; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef->default_cpu_model; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { [[ret]] = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if ([[ret]] < 0) { [[ret]] = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { [[ret]] = -1; } if ([[ret]] < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; initrd_size = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if (initrd_size > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { [[drive_index]] = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if ([[drive_index]] != -1) hd[i] = drives_table[[[drive_index]]].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { [[drive_index]] = drive_get_index(IF_FLOPPY, 0, i); if ([[drive_index]] != -1) fd[i] = drives_table[[[drive_index]]].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, [[kernel_cmdline]], INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if ([[kernel_cmdline]]) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, [[kernel_cmdline]]); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }

[[[[Adv]]]]: static void sun4uv_init(ram_addr_t RAM_size, const char *boot_devices, const char *kernel_filename, const char *[[ricin]], const char *initrd_filename, const char *cpu_model, const struct hwdef *hwdef) { CPUState *env; char *filename; m48t59_t *nvram; int [[reforms]], linux_boot; unsigned int i; ram_addr_t ram_offset, prom_offset; long initrd_size, kernel_size; PCIBus *pci_bus, *pci_bus2, *pci_bus3; QEMUBH *bh; qemu_irq *irq; int [[encephalitis]]; BlockDriverState *hd[MAX_IDE_BUS * MAX_IDE_DEVS]; BlockDriverState *fd[MAX_FD]; void *fw_cfg; ResetData *reset_info; linux_boot = (kernel_filename != NULL); if (!cpu_model) cpu_model = hwdef->default_cpu_model; env = cpu_init(cpu_model); if (!env) { fprintf(stderr, "Unable to find Sparc CPU definition\n"); exit(1); } bh = qemu_bh_new(tick_irq, env); env->tick = ptimer_init(bh); ptimer_set_period(env->tick, 1ULL); bh = qemu_bh_new(stick_irq, env); env->stick = ptimer_init(bh); ptimer_set_period(env->stick, 1ULL); bh = qemu_bh_new(hstick_irq, env); env->hstick = ptimer_init(bh); ptimer_set_period(env->hstick, 1ULL); reset_info = qemu_mallocz(sizeof(ResetData)); reset_info->env = env; reset_info->reset_addr = hwdef->prom_addr + 0x40ULL; qemu_register_reset(main_cpu_reset, reset_info); main_cpu_reset(reset_info); env->pc = hwdef->prom_addr + 0x20ULL; env->npc = env->pc + 4; ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); if (filename) { [[reforms]] = load_elf(filename, hwdef->prom_addr - PROM_VADDR, NULL, NULL, NULL); if ([[reforms]] < 0) { [[reforms]] = load_image_targphys(filename, hwdef->prom_addr, (PROM_SIZE_MAX + TARGET_PAGE_SIZE) & TARGET_PAGE_MASK); } qemu_free(filename); } else { [[reforms]] = -1; } if ([[reforms]] < 0) { fprintf(stderr, "qemu: could not load prom '%s'\n", bios_name); exit(1); } kernel_size = 0; initrd_size = 0; if (linux_boot) { kernel_size = load_elf(kernel_filename, 0, NULL, NULL, NULL); if (kernel_size < 0) kernel_size = load_aout(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, ram_size - KERNEL_LOAD_ADDR); if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_size = load_image_targphys(initrd_filename, INITRD_LOAD_ADDR, ram_size - INITRD_LOAD_ADDR); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } if (initrd_size > 0) { for (i = 0; i < 64 * TARGET_PAGE_SIZE; i += TARGET_PAGE_SIZE) { if (ldl_phys(KERNEL_LOAD_ADDR + i) == 0x48647253) { stl_phys(KERNEL_LOAD_ADDR + i + 16, INITRD_LOAD_ADDR); stl_phys(KERNEL_LOAD_ADDR + i + 20, initrd_size); break; } } } } pci_bus = pci_apb_init(APB_SPECIAL_BASE, APB_MEM_BASE, NULL, &pci_bus2, &pci_bus3); isa_mem_base = VGA_BASE; pci_vga_init(pci_bus, 0, 0); pci_ebus_init(pci_bus, -1); i = 0; if (hwdef->console_serial_base) { serial_mm_init(hwdef->console_serial_base, 0, NULL, 115200, serial_hds[i], 1); i++; } for(; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { serial_init(serial_io[i], NULL , 115200, serial_hds[i]); } } for(i = 0; i < MAX_PARALLEL_PORTS; i++) { if (parallel_hds[i]) { parallel_init(parallel_io[i], NULL , parallel_hds[i]); } } for(i = 0; i < nb_nics; i++) pci_nic_init(&nd_table[i], "ne2k_pci", NULL); irq = qemu_allocate_irqs(cpu_set_irq, env, MAX_PILS); if (drive_get_max_bus(IF_IDE) >= MAX_IDE_BUS) { fprintf(stderr, "qemu: too many IDE bus\n"); exit(1); } for(i = 0; i < MAX_IDE_BUS * MAX_IDE_DEVS; i++) { [[encephalitis]] = drive_get_index(IF_IDE, i / MAX_IDE_DEVS, i % MAX_IDE_DEVS); if ([[encephalitis]] != -1) hd[i] = drives_table[[[encephalitis]]].bdrv; else hd[i] = NULL; } pci_cmd646_ide_init(pci_bus, hd, 1); i8042_init(NULL , NULL , 0x60); for(i = 0; i < MAX_FD; i++) { [[encephalitis]] = drive_get_index(IF_FLOPPY, 0, i); if ([[encephalitis]] != -1) fd[i] = drives_table[[[encephalitis]]].bdrv; else fd[i] = NULL; } floppy_controller = fdctrl_init(NULL , 2, 0, 0x3f0, fd); nvram = m48t59_init(NULL , 0, 0x0074, NVRAM_SIZE, 59); sun4u_NVRAM_set_params(nvram, NVRAM_SIZE, "Sun4u", RAM_size, boot_devices, KERNEL_LOAD_ADDR, kernel_size, [[ricin]], INITRD_LOAD_ADDR, initrd_size, 0, graphic_width, graphic_height, graphic_depth, (uint8_t *)&nd_table[0].macaddr); fw_cfg = fw_cfg_init(BIOS_CFG_IOPORT, BIOS_CFG_IOPORT + 1, 0, 0); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_ADDR, KERNEL_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_SIZE, kernel_size); if ([[ricin]]) { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, CMDLINE_ADDR); pstrcpy_targphys(CMDLINE_ADDR, TARGET_PAGE_SIZE, [[ricin]]); } else { fw_cfg_add_i32(fw_cfg, FW_CFG_KERNEL_CMDLINE, 0); } fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_ADDR, INITRD_LOAD_ADDR); fw_cfg_add_i32(fw_cfg, FW_CFG_INITRD_SIZE, initrd_size); fw_cfg_add_i16(fw_cfg, FW_CFG_BOOT_DEVICE, boot_devices[0]); qemu_register_boot_set(fw_cfg_boot_set, fw_cfg); }[Succeeded / Failed / Skipped / Total] 50 / 19 / 62 / 131:   5%|         | 131/2690 [01:06<21:30,  1.98it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 63 / 132:   5%|         | 132/2690 [01:06<21:22,  1.99it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 64 / 133:   5%|         | 133/2690 [01:06<21:13,  2.01it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 64 / 133:   5%|         | 134/2690 [01:06<21:03,  2.02it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 65 / 134:   5%|         | 134/2690 [01:06<21:03,  2.02it/s][Succeeded / Failed / Skipped / Total] 50 / 19 / 66 / 135:   5%|         | 135/2690 [01:06<20:55,  2.04it/s][Succeeded / Failed / Skipped / Total] 51 / 19 / 66 / 136:   5%|         | 136/2690 [01:06<20:49,  2.04it/s][Succeeded / Failed / Skipped / Total] 51 / 19 / 66 / 136:   5%|         | 137/2690 [01:06<20:39,  2.06it/s]
--------------------------------------------- Result 132 ---------------------------------------------
[[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_get_bootindex(Object *obj, Visitor *v, void *opaque, const char *name, Error **errp) { NvmeCtrl *s = NVME(obj); visit_type_int32(v, &s->conf.bootindex, name, errp); }
--------------------------------------------- Result 133 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int scsi_req_length(SCSIRequest *req, uint8_t *cmd) { switch (cmd[0] >> 5) { case 0: req->cmd.xfer = cmd[4]; req->cmd.len = 6; if (req->cmd.xfer == 0) req->cmd.xfer = 256; break; case 1: case 2: req->cmd.xfer = cmd[8] | (cmd[7] << 8); req->cmd.len = 10; break; case 4: req->cmd.xfer = cmd[13] | (cmd[12] << 8) | (cmd[11] << 16) | (cmd[10] << 24); req->cmd.len = 16; break; case 5: req->cmd.xfer = cmd[9] | (cmd[8] << 8) | (cmd[7] << 16) | (cmd[6] << 24); req->cmd.len = 12; break; default: trace_scsi_req_parse_bad(req->dev->id, req->lun, req->tag, cmd[0]); return -1; } switch(cmd[0]) { case TEST_UNIT_READY: case START_STOP: case SEEK_6: case WRITE_FILEMARKS: case SPACE: case RESERVE: case RELEASE: case ERASE: case ALLOW_MEDIUM_REMOVAL: case VERIFY: case SEEK_10: case SYNCHRONIZE_CACHE: case LOCK_UNLOCK_CACHE: case LOAD_UNLOAD: case SET_CD_SPEED: case SET_LIMITS: case WRITE_LONG: case MOVE_MEDIUM: case UPDATE_BLOCK: req->cmd.xfer = 0; break; case MODE_SENSE: break; case WRITE_SAME: req->cmd.xfer = 1; break; case READ_CAPACITY: req->cmd.xfer = 8; break; case READ_BLOCK_LIMITS: req->cmd.xfer = 6; break; case READ_POSITION: req->cmd.xfer = 20; break; case SEND_VOLUME_TAG: req->cmd.xfer *= 40; break; case MEDIUM_SCAN: req->cmd.xfer *= 8; break; case WRITE_10: case WRITE_VERIFY: case WRITE_6: case WRITE_12: case WRITE_VERIFY_12: case WRITE_16: case WRITE_VERIFY_16: req->cmd.xfer *= req->dev->blocksize; break; case READ_10: case READ_6: case READ_REVERSE: case RECOVER_BUFFERED_DATA: case READ_12: case READ_16: req->cmd.xfer *= req->dev->blocksize; break; case INQUIRY: req->cmd.xfer = cmd[4] | (cmd[3] << 8); break; case MAINTENANCE_OUT: case MAINTENANCE_IN: if (req->dev->type == TYPE_ROM) { req->cmd.xfer = cmd[9] | (cmd[8] << 8); } break; } return 0; }
--------------------------------------------- Result 134 ---------------------------------------------
[[0 (32%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts) { ObjectClass *oc; DeviceClass *dc; const char *driver, *path, *id; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { qerror_report(QERR_MISSING_PARAMETER, "driver"); return NULL; } oc = object_class_by_name(driver); if (!oc) { const char *typename = find_typename_by_alias(driver); if (typename) { driver = typename; oc = object_class_by_name(driver); } } if (!object_class_dynamic_cast(oc, TYPE_DEVICE)) { qerror_report(ERROR_CLASS_GENERIC_ERROR, "'%s' is not a valid device model name", driver); return NULL; } if (object_class_is_abstract(oc)) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "non-abstract device type"); return NULL; } dc = DEVICE_CLASS(oc); if (dc->cannot_instantiate_with_device_add_yet) { qerror_report(QERR_INVALID_PARAMETER_VALUE, "driver", "pluggable device type"); return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { qerror_report(QERR_BAD_BUS_FOR_DEVICE, driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus) { qerror_report(QERR_NO_BUS_FOR_DEVICE, dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !bus->allow_hotplug) { qerror_report(QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } id = qemu_opts_id(opts); if (id) { dev->id = id; } if (qemu_opt_foreach(opts, set_property, dev, 1) != 0) { object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; } if (dev->id) { object_property_add_child(qdev_get_peripheral(), dev->id, OBJECT(dev), NULL); } else { static int anon_count; gchar *name = g_strdup_printf("device[%d]", anon_count++); object_property_add_child(qdev_get_peripheral_anon(), name, OBJECT(dev), NULL); g_free(name); } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { qerror_report_err(err); error_free(err); dev->opts = NULL; object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); qerror_report(QERR_DEVICE_INIT_FAILED, driver); return NULL; } return dev; }
--------------------------------------------- Result 135 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: ff_rm_parse_packet (AVFormatContext *s, AVIOContext *pb, AVStream *st, RMStream *ast, int len, AVPacket *pkt, int *seq, int flags, int64_t timestamp) { RMDemuxContext *rm = s->priv_data; int ret; if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { rm->current_stream= st->id; ret = rm_assemble_video_frame(s, pb, rm, ast, pkt, len, seq, &timestamp); if(ret) return ret < 0 ? ret : -1; } else if (st->codec->codec_type == AVMEDIA_TYPE_AUDIO) { if ((ast->deint_id == DEINT_ID_GENR) || (ast->deint_id == DEINT_ID_INT4) || (ast->deint_id == DEINT_ID_SIPR)) { int x; int sps = ast->sub_packet_size; int cfs = ast->coded_framesize; int h = ast->sub_packet_h; int y = ast->sub_packet_cnt; int w = ast->audio_framesize; if (flags & 2) y = ast->sub_packet_cnt = 0; if (!y) ast->audiotimestamp = timestamp; switch (ast->deint_id) { case DEINT_ID_INT4: for (x = 0; x < h/2; x++) avio_read(pb, ast->pkt.data+x*2*w+y*cfs, cfs); break; case DEINT_ID_GENR: for (x = 0; x < w/sps; x++) avio_read(pb, ast->pkt.data+sps*(h*x+((h+1)/2)*(y&1)+(y>>1)), sps); break; case DEINT_ID_SIPR: avio_read(pb, ast->pkt.data + y * w, w); break; } if (++(ast->sub_packet_cnt) < h) return -1; if (ast->deint_id == DEINT_ID_SIPR) ff_rm_reorder_sipr_data(ast->pkt.data, h, w); ast->sub_packet_cnt = 0; rm->audio_stream_num = st->index; rm->audio_pkt_cnt = h * w / st->codec->block_align; } else if ((ast->deint_id == DEINT_ID_VBRF) || (ast->deint_id == DEINT_ID_VBRS)) { int x; rm->audio_stream_num = st->index; ast->sub_packet_cnt = (avio_rb16(pb) & 0xf0) >> 4; if (ast->sub_packet_cnt) { for (x = 0; x < ast->sub_packet_cnt; x++) ast->sub_packet_lengths[x] = avio_rb16(pb); rm->audio_pkt_cnt = ast->sub_packet_cnt; ast->audiotimestamp = timestamp; } else return -1; } else { av_get_packet(pb, pkt, len); rm_ac3_swap_bytes(st, pkt); } } else av_get_packet(pb, pkt, len); pkt->stream_index = st->index; #if 0 if (st->codec->codec_type == AVMEDIA_TYPE_VIDEO) { if(st->codec->codec_id == AV_CODEC_ID_RV20){ int seq= 128*(pkt->data[2]&0x7F) + (pkt->data[3]>>1); av_log(s, AV_LOG_DEBUG, "%d %"PRId64" %d\n", *timestamp, *timestamp*512LL/25, seq); seq |= (timestamp&~0x3FFF); if(seq - timestamp > 0x2000) seq -= 0x4000; if(seq - timestamp < -0x2000) seq += 0x4000; } } #endif pkt->pts = timestamp; if (flags & 2) pkt->flags |= AV_PKT_FLAG_KEY; return st->codec->codec_type == AVMEDIA_TYPE_AUDIO ? rm->audio_pkt_cnt : 0; }
--------------------------------------------- Result 136 ---------------------------------------------
[[0 (25%)]] --> [[0 (60%)]] --> Socre: 0.6021186113357544

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[func]], void *arg) { thread_pool_submit_aio([[func]], arg, NULL, NULL); }

[[[[Adv]]]]: void thread_pool_submit(ThreadPoolFunc *[[excessively]], void *arg) { thread_pool_submit_aio([[excessively]], arg, NULL, NULL); }
--------------------------------------------- Result 137 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 52 / 19 / 66 / 137:   5%|         | 137/2690 [01:06<20:39,  2.06it/s][Succeeded / Failed / Skipped / Total] 52 / 19 / 67 / 138:   5%|         | 138/2690 [01:06<20:31,  2.07it/s][Succeeded / Failed / Skipped / Total] 52 / 19 / 68 / 139:   5%|         | 139/2690 [01:06<20:23,  2.09it/s][Succeeded / Failed / Skipped / Total] 52 / 19 / 68 / 139:   5%|         | 140/2690 [01:06<20:14,  2.10it/s][Succeeded / Failed / Skipped / Total] 52 / 19 / 69 / 140:   5%|         | 140/2690 [01:06<20:14,  2.10it/s][Succeeded / Failed / Skipped / Total] 52 / 20 / 69 / 141:   5%|         | 141/2690 [01:06<20:04,  2.12it/s][Succeeded / Failed / Skipped / Total] 53 / 20 / 69 / 142:   5%|         | 142/2690 [01:06<19:56,  2.13it/s][Succeeded / Failed / Skipped / Total] 53 / 20 / 70 / 143:   5%|         | 143/2690 [01:06<19:48,  2.14it/s][[0 (68%)]] --> [[0 (36%)]] --> Socre: 0.6405903100967407

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *[[queue]], void *p_data) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = p_data; if (![[queue]]->p_head) [[queue]]->p_head = p_new; else [[queue]]->p_tail->next = p_new; [[queue]]->p_tail = p_new; ++[[queue]]->size; return 0; }

[[[[Adv]]]]: int ff_schro_queue_push_back(FFSchroQueue *[[trailer]], void *p_data) { FFSchroQueueElement *p_new = av_mallocz(sizeof(FFSchroQueueElement)); if (!p_new) return -1; p_new->data = p_data; if (![[trailer]]->p_head) [[trailer]]->p_head = p_new; else [[trailer]]->p_tail->next = p_new; [[trailer]]->p_tail = p_new; ++[[trailer]]->size; return 0; }
--------------------------------------------- Result 138 ---------------------------------------------
[[0 (21%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: Object *object_resolve_path_component(Object *parent, const gchar *part) { ObjectProperty *prop = object_property_find(parent, part, NULL); if (prop == NULL) { return NULL; } if (object_property_is_link(prop)) { return *(Object **)prop->opaque; } else if (object_property_is_child(prop)) { return prop->opaque; } else { return NULL; } }
--------------------------------------------- Result 139 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int cpu_exec(CPUState *cpu) { CPUClass *cc = CPU_GET_CLASS(cpu); int ret; SyncClocks sc; current_cpu = cpu; if (cpu_handle_halt(cpu)) { return EXCP_HALTED; } rcu_read_lock(); cc->cpu_exec_enter(cpu); init_delay_params(&sc, cpu); if (sigsetjmp(cpu->jmp_env, 0) != 0) { #if defined(__clang__) || !QEMU_GNUC_PREREQ(4, 6) cpu = current_cpu; cc = CPU_GET_CLASS(cpu); #else g_assert(cpu == current_cpu); g_assert(cc == CPU_GET_CLASS(cpu)); #endif cpu->can_do_io = 1; tb_lock_reset(); if (qemu_mutex_iothread_locked()) { qemu_mutex_unlock_iothread(); } } while (!cpu_handle_exception(cpu, &ret)) { TranslationBlock *last_tb = NULL; int tb_exit = 0; while (!cpu_handle_interrupt(cpu, &last_tb)) { TranslationBlock *tb = tb_find(cpu, last_tb, tb_exit); cpu_loop_exec_tb(cpu, tb, &last_tb, &tb_exit, &sc); align_clocks(&sc, cpu); } } cc->cpu_exec_exit(cpu); rcu_read_unlock(); current_cpu = NULL; return ret; }
--------------------------------------------- Result 140 ---------------------------------------------
[[0 (46%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int kvmppc_reset_htab(int shift_hint) { uint32_t shift = shift_hint; if (!kvm_enabled()) { return 0; } if (kvm_check_extension(kvm_state, KVM_CAP_PPC_ALLOC_HTAB)) { int ret; ret = kvm_vm_ioctl(kvm_state, KVM_PPC_ALLOCATE_HTAB, &shift); if (ret == -ENOTTY) { return 0; } else if (ret < 0) { return ret; } return shift; } if (kvmppc_is_pr(kvm_state)) { return 0; } else { return 24; } }
--------------------------------------------- Result 141 ---------------------------------------------
[[0 (56%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *s, vscsi_req *req) { union viosrp_iu *iu = &req->iu; struct srp_login_rsp *rsp = &iu->srp.login_rsp; uint64_t tag = iu->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset(iu, 0, sizeof(struct srp_login_rsp)); rsp->opcode = SRP_LOGIN_RSP; rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp->tag = tag; rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT); }

[[[[Adv]]]]: static void vscsi_process_login(VSCSIState *s, vscsi_req *req) { union viosrp_iu *iu = &req->iu; struct srp_login_rsp *rsp = &iu->srp.login_rsp; uint64_t tag = iu->srp.rsp.tag; trace_spapr_vscsi__process_login(); memset(iu, 0, sizeof(struct srp_login_rsp)); rsp->opcode = SRP_LOGIN_RSP; rsp->req_lim_delta = cpu_to_be32(VSCSI_REQ_LIMIT-2); rsp->tag = tag; rsp->max_it_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->max_ti_iu_len = cpu_to_be32(sizeof(union srp_iu)); rsp->buf_fmt = cpu_to_be16(SRP_BUF_FORMAT_DIRECT | SRP_BUF_FORMAT_INDIRECT); vscsi_send_iu(s, req, sizeof(*rsp), VIOSRP_SRP_FORMAT); }
--------------------------------------------- Result 142 ---------------------------------------------
[[0 (26%)]] --> [[0 (55%)]] --> Socre: 0.5494505763053894

[[[[Adv]]]]: static void copy_irb_to_guest(IRB *dest, const IRB *[[src]], PMCW *[[pmcw]]) { int i; uint16_t [[stctl]] = [[src]]->scsw.ctrl & SCSW_CTRL_MASK_STCTL; uint16_t [[actl]] = [[src]]->scsw.ctrl & SCSW_CTRL_MASK_ACTL; copy_scsw_to_guest(&dest->scsw, &[[src]]->scsw); for (i = 0; i < ARRAY_SIZE(dest->esw); i++) { dest->esw[i] = cpu_to_be32([[src]]->esw[i]); } for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) { dest->ecw[i] = cpu_to_be32([[src]]->ecw[i]); } if (([[src]]->scsw.flags & SCSW_FLAGS_MASK_ESWF) || !([[pmcw]]->flags & PMCW_FLAGS_MASK_TF) || !([[pmcw]]->chars & PMCW_CHARS_MASK_XMWME)) { return; } if (!([[stctl]] & SCSW_STCTL_STATUS_PEND)) { return; } if (([[stctl]] & SCSW_STCTL_PRIMARY) || ([[stctl]] == SCSW_STCTL_SECONDARY) || (([[stctl]] & SCSW_STCTL_INTERMEDIATE) && ([[actl]] & SCSW_ACTL_SUSP))) { for (i = 0; i < ARRAY_SIZE(dest->emw); i++) { dest->emw[i] = cpu_to_be32([[src]]->emw[i]); } } }

[[[[Adv]]]]: static void copy_irb_to_guest(IRB *dest, const IRB *[[betrayal]], PMCW *[[barking]]) { int i; uint16_t [[baggie]] = [[betrayal]]->scsw.ctrl & SCSW_CTRL_MASK_STCTL; uint16_t [[pincher]] = [[betrayal]]->scsw.ctrl & SCSW_CTRL_MASK_ACTL; copy_scsw_to_guest(&dest->scsw, &[[betrayal]]->scsw); for (i = 0; i < ARRAY_SIZE(dest->esw); i++) { dest->esw[i] = cpu_to_be32([[betrayal]]->esw[i]); } for (i = 0; i < ARRAY_SIZE(dest->ecw); i++) { dest->ecw[i] = cpu_to_be32([[betrayal]]->ecw[i]); } if (([[betrayal]]->scsw.flags & SCSW_FLAGS_MASK_ESWF) || !([[barking]]->flags & PMCW_FLAGS_MASK_TF) || !([[barking]]->chars & PMCW_CHARS_MASK_XMWME)) { return; } if (!([[baggie]] & SCSW_STCTL_STATUS_PEND)) { return; } if (([[baggie]] & SCSW_STCTL_PRIMARY) || ([[baggie]] == SCSW_STCTL_SECONDARY) || (([[baggie]] & SCSW_STCTL_INTERMEDIATE) && ([[pincher]] & SCSW_ACTL_SUSP))) { for (i = 0; i < ARRAY_SIZE(dest->emw); i++) { dest->emw[i] = cpu_to_be32([[betrayal]]->emw[i]); } } }
--------------------------------------------- Result 143 ---------------------------------------------
[[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ptx_decode_frame(AVCodecContext *avctx, void *data, int *data_size, AVPacket *avpkt) { const uint8_t *buf = avpkt->data; PTXContext * const s = avctx->priv_data; AVFrame *picture = data; AVFrame * const p = &s->picture; unsigned int offset, w, h, y, stride, bytes_per_pixel; uint8_t *ptr; offset = AV_RL16(buf); w = AV_RL16(buf+8); h = AV_RL16(buf+10); bytes_per_pixel = AV_RL16(buf+12) >> 3; if (bytes_per_pixel != 2) { av_log_ask_for_sample(avctx, "Image format is not RGB15.\n"); return -1; } avctx->pix_fmt = PIX_FMT_RGB555; if (buf_end - buf < offset) if (offset != 0x2c) av_log_ask_for_sample(avctx, "offset != 0x2c\n"); buf += offset; if (p->data[0]) avctx->release_buffer(avctx, p); if (av_image_check_size(w, h, 0, avctx)) return -1; if (w != avctx->width || h != avctx->height) avcodec_set_dimensions(avctx, w, h); if (avctx->get_buffer(avctx, p) < 0) { av_log(avctx, AV_LOG_ERROR, "get_buffer() failed\n"); return -1; } p->pict_type = AV_PICTURE_TYPE_I; ptr = p->data[0]; stride = p->linesize[0]; for (y=0; y<h; y++) { if (buf_end - buf < w * bytes_per_pixel) break; #if HAVE_BIGENDIAN unsigned int x; for (x=0; x<w*bytes_per_pixel; x+=bytes_per_pixel) AV_WN16(ptr+x, AV_RL16(buf+x)); #else memcpy(ptr, buf, w*bytes_per_pixel); #endif ptr += stride; buf += w*bytes_per_pixel; } *picture = s->picture; *data_size = sizeof(AVPicture); return offset + w*h*bytes_per_pixel; }
--------------------------------------------- Result 144 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 53 / 20 / 71 / 144:   5%|         | 144/2690 [01:06<19:39,  2.16it/s][Succeeded / Failed / Skipped / Total] 54 / 20 / 71 / 145:   5%|         | 145/2690 [01:06<19:30,  2.17it/s][Succeeded / Failed / Skipped / Total] 54 / 20 / 72 / 146:   5%|         | 146/2690 [01:06<19:22,  2.19it/s][[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int process_input_packet(InputStream *ist, const AVPacket *pkt) { int i; int got_output; AVPacket avpkt; if (ist->next_dts == AV_NOPTS_VALUE) ist->next_dts = ist->last_dts; if (pkt == NULL) { av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; goto handle_eof; } else { avpkt = *pkt; } if (pkt->dts != AV_NOPTS_VALUE) ist->next_dts = ist->last_dts = av_rescale_q(pkt->dts, ist->st->time_base, AV_TIME_BASE_Q); while (ist->decoding_needed && (avpkt.size > 0 || (!pkt && got_output))) { int ret = 0; handle_eof: ist->last_dts = ist->next_dts; if (avpkt.size && avpkt.size != pkt->size && !(ist->dec->capabilities & CODEC_CAP_SUBFRAMES)) { av_log(NULL, ist->showed_multi_packet_warning ? AV_LOG_VERBOSE : AV_LOG_WARNING, "Multiple frames in a packet from stream %d\n", pkt->stream_index); ist->showed_multi_packet_warning = 1; } switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ret = decode_audio (ist, &avpkt, &got_output); break; case AVMEDIA_TYPE_VIDEO: ret = decode_video (ist, &avpkt, &got_output); if (avpkt.duration) ist->next_dts += av_rescale_q(avpkt.duration, ist->st->time_base, AV_TIME_BASE_Q); else if (ist->st->avg_frame_rate.num) ist->next_dts += av_rescale_q(1, av_inv_q(ist->st->avg_frame_rate), AV_TIME_BASE_Q); else if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += av_rescale_q(ticks, ist->dec_ctx->time_base, AV_TIME_BASE_Q); } break; case AVMEDIA_TYPE_SUBTITLE: ret = transcode_subtitles(ist, &avpkt, &got_output); break; default: return -1; } if (ret < 0) return ret; if (pkt) { avpkt.data += ret; avpkt.size -= ret; } if (!got_output) { continue; } } if (!ist->decoding_needed) { ist->last_dts = ist->next_dts; switch (ist->dec_ctx->codec_type) { case AVMEDIA_TYPE_AUDIO: ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->frame_size) / ist->dec_ctx->sample_rate; break; case AVMEDIA_TYPE_VIDEO: if (ist->dec_ctx->time_base.num != 0) { int ticks = ist->st->parser ? ist->st->parser->repeat_pict + 1 : ist->dec_ctx->ticks_per_frame; ist->next_dts += ((int64_t)AV_TIME_BASE * ist->dec_ctx->time_base.num * ticks) / ist->dec_ctx->time_base.den; } break; } } for (i = 0; pkt && i < nb_output_streams; i++) { OutputStream *ost = output_streams[i]; if (!check_output_constraints(ist, ost) || ost->encoding_needed) continue; do_streamcopy(ist, ost, pkt); } return 0; }
--------------------------------------------- Result 145 ---------------------------------------------
[[0 (67%)]] --> [[0 (50%)]] --> Socre: 0.5013284981250763

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[bs]]) { BDRVVPCState *s = [[bs]]->opaque; g_free(s->pagetable); #ifdef CACHE g_free(s->pageentry_u8); #endif migrate_del_blocker(s->migration_blocker); error_free(s->migration_blocker); }

[[[[Adv]]]]: static void vpc_close(BlockDriverState *[[marxist]]) { BDRVVPCState *s = [[marxist]]->opaque; g_free(s->pagetable); #ifdef CACHE g_free(s->pageentry_u8); #endif migrate_del_blocker(s->migration_blocker); error_free(s->migration_blocker); }
--------------------------------------------- Result 146 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: POWERPC_FAMILY(POWER9)(ObjectClass *oc, void *data) { DeviceClass *dc = DEVICE_CLASS(oc); PowerPCCPUClass *pcc = POWERPC_CPU_CLASS(oc); CPUClass *cc = CPU_CLASS(oc); dc->fw_name = "PowerPC,POWER9"; dc->desc = "POWER9"; dc->props = powerpc_servercpu_properties; pcc->pvr_match = ppc_pvr_match_power9; pcc->pcr_mask = PCR_COMPAT_2_05 | PCR_COMPAT_2_06 | PCR_COMPAT_2_07; pcc->pcr_supported = PCR_COMPAT_3_00 | PCR_COMPAT_2_07 | PCR_COMPAT_2_06 | PCR_COMPAT_2_05; pcc->init_proc = init_proc_POWER9; pcc->check_pow = check_pow_nocheck; cc->has_work = cpu_has_work_POWER9; pcc->insns_flags = PPC_INSNS_BASE | PPC_ISEL | PPC_STRING | PPC_MFTB | PPC_FLOAT | PPC_FLOAT_FSEL | PPC_FLOAT_FRES | PPC_FLOAT_FSQRT | PPC_FLOAT_FRSQRTE | PPC_FLOAT_FRSQRTES | PPC_FLOAT_STFIWX | PPC_FLOAT_EXT | PPC_CACHE | PPC_CACHE_ICBI | PPC_CACHE_DCBZ | PPC_MEM_SYNC | PPC_MEM_EIEIO | PPC_MEM_TLBIE | PPC_MEM_TLBSYNC | PPC_64B | PPC_64BX | PPC_ALTIVEC | PPC_SEGMENT_64B | PPC_SLBI | PPC_POPCNTB | PPC_POPCNTWD | PPC_CILDST; pcc->insns_flags2 = PPC2_VSX | PPC2_VSX207 | PPC2_DFP | PPC2_DBRX | PPC2_PERM_ISA206 | PPC2_DIVE_ISA206 | PPC2_ATOMIC_ISA206 | PPC2_FP_CVT_ISA206 | PPC2_FP_TST_ISA206 | PPC2_BCTAR_ISA207 | PPC2_LSQ_ISA207 | PPC2_ALTIVEC_207 | PPC2_ISA205 | PPC2_ISA207S | PPC2_FP_CVT_S64 | PPC2_TM | PPC2_PM_ISA206 | PPC2_ISA300; pcc->msr_mask = (1ull << MSR_SF) | (1ull << MSR_TM) | (1ull << MSR_VR) | (1ull << MSR_VSX) | (1ull << MSR_EE) | (1ull << MSR_PR) | (1ull << MSR_FP) | (1ull << MSR_ME) | (1ull << MSR_FE0) | (1ull << MSR_SE) | (1ull << MSR_DE) | (1ull << MSR_FE1) | (1ull << MSR_IR) | (1ull << MSR_DR) | (1ull << MSR_PMM) | (1ull << MSR_RI) | (1ull << MSR_LE); pcc->mmu_model = POWERPC_MMU_3_00; #if defined(CONFIG_SOFTMMU) pcc->handle_mmu_fault = ppc64_v3_handle_mmu_fault; pcc->sps = &POWER7_POWER8_sps; pcc->radix_page_info = &POWER9_radix_page_info; #endif pcc->excp_model = POWERPC_EXCP_POWER8; pcc->bus_model = PPC_FLAGS_INPUT_POWER7; pcc->bfd_mach = bfd_mach_ppc64; pcc->flags = POWERPC_FLAG_VRE | POWERPC_FLAG_SE | POWERPC_FLAG_BE | POWERPC_FLAG_PMM | POWERPC_FLAG_BUS_CLK | POWERPC_FLAG_CFAR | POWERPC_FLAG_VSX | POWERPC_FLAG_TM; pcc->l1_dcache_size = 0x8000; pcc->l1_icache_size = 0x8000; pcc->interrupts_big_endian = ppc_cpu_interrupts_big_endian_lpcr; }
--------------------------------------------- Result 147 ---------------------------------------------
[[0 (34%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static target_ulong disas_insn(DisasContext *s, CPUState *cpu) { CPUX86State *env = cpu->env_ptr; int b, prefixes; int shift; TCGMemOp ot, aflag, dflag; int modrm, reg, rm, mod, op, opreg, val; target_ulong next_eip, tval; int rex_w, rex_r; target_ulong pc_start = s->base.pc_next; s->pc_start = s->pc = pc_start; prefixes = 0; s->override = -1; rex_w = -1; rex_r = 0; #ifdef TARGET_X86_64 s->rex_x = 0; s->rex_b = 0; x86_64_hregs = 0; #endif s->rip_offset = 0; s->vex_l = 0; s->vex_v = 0; if (sigsetjmp(s->jmpbuf, 0) != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); return s->pc; } next_byte: b = x86_ldub_code(env, s); switch (b) { case 0xf3: prefixes |= PREFIX_REPZ; goto next_byte; case 0xf2: prefixes |= PREFIX_REPNZ; goto next_byte; case 0xf0: prefixes |= PREFIX_LOCK; goto next_byte; case 0x2e: s->override = R_CS; goto next_byte; case 0x36: s->override = R_SS; goto next_byte; case 0x3e: s->override = R_DS; goto next_byte; case 0x26: s->override = R_ES; goto next_byte; case 0x64: s->override = R_FS; goto next_byte; case 0x65: s->override = R_GS; goto next_byte; case 0x66: prefixes |= PREFIX_DATA; goto next_byte; case 0x67: prefixes |= PREFIX_ADR; goto next_byte; #ifdef TARGET_X86_64 case 0x40 ... 0x4f: if (CODE64(s)) { rex_w = (b >> 3) & 1; rex_r = (b & 0x4) << 1; s->rex_x = (b & 0x2) << 2; REX_B(s) = (b & 0x1) << 3; x86_64_hregs = 1; goto next_byte; } break; #endif case 0xc5: case 0xc4: if (s->code32 && !s->vm86) { static const int pp_prefix[4] = { 0, PREFIX_DATA, PREFIX_REPZ, PREFIX_REPNZ }; int vex3, vex2 = x86_ldub_code(env, s); if (!CODE64(s) && (vex2 & 0xc0) != 0xc0) { break; } s->pc++; if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ | PREFIX_LOCK | PREFIX_DATA)) { goto illegal_op; } #ifdef TARGET_X86_64 if (x86_64_hregs) { goto illegal_op; } #endif rex_r = (~vex2 >> 4) & 8; if (b == 0xc5) { vex3 = vex2; b = x86_ldub_code(env, s); } else { #ifdef TARGET_X86_64 s->rex_x = (~vex2 >> 3) & 8; s->rex_b = (~vex2 >> 2) & 8; #endif vex3 = x86_ldub_code(env, s); rex_w = (vex3 >> 7) & 1; switch (vex2 & 0x1f) { case 0x01: b = x86_ldub_code(env, s) | 0x100; break; case 0x02: b = 0x138; break; case 0x03: b = 0x13a; break; default: goto unknown_op; } } s->vex_v = (~vex3 >> 3) & 0xf; s->vex_l = (vex3 >> 2) & 1; prefixes |= pp_prefix[vex3 & 3] | PREFIX_VEX; } break; } if (CODE64(s)) { dflag = (rex_w > 0 ? MO_64 : prefixes & PREFIX_DATA ? MO_16 : MO_32); aflag = (prefixes & PREFIX_ADR ? MO_32 : MO_64); } else { if (s->code32 ^ ((prefixes & PREFIX_DATA) != 0)) { dflag = MO_32; } else { dflag = MO_16; } if (s->code32 ^ ((prefixes & PREFIX_ADR) != 0)) { aflag = MO_32; } else { aflag = MO_16; } } s->prefix = prefixes; s->aflag = aflag; s->dflag = dflag; reswitch: switch(b) { case 0x0f: b = x86_ldub_code(env, s) | 0x100; goto reswitch; case 0x00 ... 0x05: case 0x08 ... 0x0d: case 0x10 ... 0x15: case 0x18 ... 0x1d: case 0x20 ... 0x25: case 0x28 ... 0x2d: case 0x30 ... 0x35: case 0x38 ... 0x3d: { int op, f, val; op = (b >> 3) & 7; f = (b >> 1) & 3; ot = mo_b_d(b, dflag); switch(f) { case 0: modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else if (op == OP_XORL && rm == reg) { xor_zero: set_cc_op(s, CC_OP_CLR); tcg_gen_movi_tl(cpu_T0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op(s, op, ot, opreg); break; case 1: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; rm = (modrm & 7) | REX_B(s); if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); } else if (op == OP_XORL && rm == reg) { goto xor_zero; } else { gen_op_mov_v_reg(ot, cpu_T1, rm); } gen_op(s, op, ot, reg); break; case 2: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, OR_EAX); break; } } break; case 0x82: if (CODE64(s)) goto illegal_op; case 0x80: case 0x81: case 0x83: { int val; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (b == 0x83) s->rip_offset = 1; else s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } switch(b) { default: case 0x80: case 0x81: case 0x82: val = insn_get(env, s, ot); break; case 0x83: val = (int8_t)insn_get(env, s, MO_8); break; } tcg_gen_movi_tl(cpu_T1, val); gen_op(s, op, ot, opreg); } break; case 0x40 ... 0x47: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), 1); break; case 0x48 ... 0x4f: ot = dflag; gen_inc(s, ot, OR_EAX + (b & 7), -1); break; case 0xf6: case 0xf7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (mod != 3) { if (op == 0) { s->rip_offset = insn_const_size(ot); } gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK) || op != 2) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 2: if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } tcg_gen_movi_tl(cpu_T0, ~0); tcg_gen_atomic_xor_fetch_tl(cpu_T0, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); } else { tcg_gen_not_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 3: if (s->prefix & PREFIX_LOCK) { TCGLabel *label1; TCGv a0, t0, t1, t2; if (mod == 3) { goto illegal_op; } a0 = tcg_temp_local_new(); t0 = tcg_temp_local_new(); label1 = gen_new_label(); tcg_gen_mov_tl(a0, cpu_A0); tcg_gen_mov_tl(t0, cpu_T0); gen_set_label(label1); t1 = tcg_temp_new(); t2 = tcg_temp_new(); tcg_gen_mov_tl(t2, t0); tcg_gen_neg_tl(t1, t0); tcg_gen_atomic_cmpxchg_tl(t0, a0, t0, t1, s->mem_index, ot | MO_LE); tcg_temp_free(t1); tcg_gen_brcond_tl(TCG_COND_NE, t0, t2, label1); tcg_temp_free(t2); tcg_temp_free(a0); tcg_gen_mov_tl(cpu_T0, t0); tcg_temp_free(t0); } else { tcg_gen_neg_tl(cpu_T0, cpu_T0); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } gen_op_update_neg_cc(); set_cc_op(s, CC_OP_SUBB + ot); break; case 4: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8u_tl(cpu_T0, cpu_T0); tcg_gen_ext8u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_andi_tl(cpu_cc_src, cpu_T0, 0xff00); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16u_tl(cpu_T0, cpu_T0); tcg_gen_ext16u_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_mulu2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_mulu2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 5: switch(ot) { case MO_8: gen_op_mov_v_reg(MO_8, cpu_T1, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); tcg_gen_ext8s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext8s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); set_cc_op(s, CC_OP_MULB); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T1, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); tcg_gen_shri_tl(cpu_T0, cpu_T0, 16); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); set_cc_op(s, CC_OP_MULW); break; default: case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_regs[R_EAX]); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EAX], cpu_tmp2_i32); tcg_gen_extu_i32_tl(cpu_regs[R_EDX], cpu_tmp3_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); set_cc_op(s, CC_OP_MULL); break; #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_T0, cpu_regs[R_EAX]); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[R_EAX]); tcg_gen_sari_tl(cpu_cc_src, cpu_regs[R_EAX], 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_regs[R_EDX]); set_cc_op(s, CC_OP_MULQ); break; #endif } break; case 6: switch(ot) { case MO_8: gen_helper_divb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_divw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_divl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_divq_EAX(cpu_env, cpu_T0); break; #endif } break; case 7: switch(ot) { case MO_8: gen_helper_idivb_AL(cpu_env, cpu_T0); break; case MO_16: gen_helper_idivw_AX(cpu_env, cpu_T0); break; default: case MO_32: gen_helper_idivl_EAX(cpu_env, cpu_T0); break; #ifdef TARGET_X86_64 case MO_64: gen_helper_idivq_EAX(cpu_env, cpu_T0); break; #endif } break; default: goto unknown_op; } break; case 0xfe: case 0xff: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); op = (modrm >> 3) & 7; if (op >= 2 && b == 0xfe) { goto unknown_op; } if (CODE64(s)) { if (op == 2 || op == 4) { ot = MO_64; } else if (op == 3 || op == 5) { ot = dflag != MO_16 ? MO_32 + (rex_w == 1) : MO_16; } else if (op == 6) { ot = mo_pushpop(s, dflag); } } if (mod != 3) { gen_lea_modrm(env, s, modrm); if (op >= 2 && op != 3 && op != 5) gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } switch(op) { case 0: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, 1); break; case 1: if (mod != 3) opreg = OR_TMP0; else opreg = rm; gen_inc(s, ot, opreg, -1); break; case 2: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } next_eip = s->pc - s->cs_base; tcg_gen_movi_tl(cpu_T1, next_eip); gen_push_v(s, cpu_T1); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 3: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_lcall: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_tl(s->pc - s->cs_base)); } else { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lcall_real(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 4: if (dflag == MO_16) { tcg_gen_ext16u_tl(cpu_T0, cpu_T0); } gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 5: gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); do_ljmp: if (s->pe && !s->vm86) { tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ljmp_protected(cpu_env, cpu_tmp2_i32, cpu_T1, tcg_const_tl(s->pc - s->cs_base)); } else { gen_op_movl_seg_T0_vm(R_CS); gen_op_jmp_v(cpu_T1); } tcg_gen_ld_tl(cpu_tmp4, cpu_env, offsetof(CPUX86State, eip)); gen_jr(s, cpu_tmp4); break; case 6: gen_push_v(s, cpu_T0); break; default: goto unknown_op; } break; case 0x84: case 0x85: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_v_reg(ot, cpu_T1, reg); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0xa8: case 0xa9: ot = mo_b_d(b, dflag); val = insn_get(env, s, ot); gen_op_mov_v_reg(ot, cpu_T0, OR_EAX); tcg_gen_movi_tl(cpu_T1, val); gen_op_testl_T0_T1_cc(); set_cc_op(s, CC_OP_LOGICB + ot); break; case 0x98: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, R_EAX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, R_EAX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_8, cpu_T0, R_EAX); tcg_gen_ext8s_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: tcg_abort(); } break; case 0x99: switch (dflag) { #ifdef TARGET_X86_64 case MO_64: gen_op_mov_v_reg(MO_64, cpu_T0, R_EAX); tcg_gen_sari_tl(cpu_T0, cpu_T0, 63); gen_op_mov_reg_v(MO_64, R_EDX, cpu_T0); break; #endif case MO_32: gen_op_mov_v_reg(MO_32, cpu_T0, R_EAX); tcg_gen_ext32s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 31); gen_op_mov_reg_v(MO_32, R_EDX, cpu_T0); break; case MO_16: gen_op_mov_v_reg(MO_16, cpu_T0, R_EAX); tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_sari_tl(cpu_T0, cpu_T0, 15); gen_op_mov_reg_v(MO_16, R_EDX, cpu_T0); break; default: tcg_abort(); } break; case 0x1af: case 0x69: case 0x6b: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (b == 0x69) s->rip_offset = insn_const_size(ot); else if (b == 0x6b) s->rip_offset = 1; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); if (b == 0x69) { val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T1, val); } else if (b == 0x6b) { val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T1, val); } else { gen_op_mov_v_reg(ot, cpu_T1, reg); } switch (ot) { #ifdef TARGET_X86_64 case MO_64: tcg_gen_muls2_i64(cpu_regs[reg], cpu_T1, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sari_tl(cpu_cc_src, cpu_cc_dst, 63); tcg_gen_sub_tl(cpu_cc_src, cpu_cc_src, cpu_T1); break; #endif case MO_32: tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); tcg_gen_muls2_i32(cpu_tmp2_i32, cpu_tmp3_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_regs[reg], cpu_tmp2_i32); tcg_gen_sari_i32(cpu_tmp2_i32, cpu_tmp2_i32, 31); tcg_gen_mov_tl(cpu_cc_dst, cpu_regs[reg]); tcg_gen_sub_i32(cpu_tmp2_i32, cpu_tmp2_i32, cpu_tmp3_i32); tcg_gen_extu_i32_tl(cpu_cc_src, cpu_tmp2_i32); break; default: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); tcg_gen_ext16s_tl(cpu_T1, cpu_T1); tcg_gen_mul_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); tcg_gen_ext16s_tl(cpu_tmp0, cpu_T0); tcg_gen_sub_tl(cpu_cc_src, cpu_T0, cpu_tmp0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; } set_cc_op(s, CC_OP_MULB + ot); break; case 0x1c0: case 0x1c1: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; gen_op_mov_v_reg(ot, cpu_T0, reg); if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, cpu_T1, rm); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_mov_reg_v(ot, reg, cpu_T1); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { gen_lea_modrm(env, s, modrm); if (s->prefix & PREFIX_LOCK) { tcg_gen_atomic_fetch_add_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); } else { gen_op_ld_v(s, ot, cpu_T1, cpu_A0); tcg_gen_add_tl(cpu_T0, cpu_T0, cpu_T1); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } gen_op_mov_reg_v(ot, reg, cpu_T1); } gen_op_update2_cc(); set_cc_op(s, CC_OP_ADDB + ot); break; case 0x1b0: case 0x1b1: { TCGv oldv, newv, cmpv; ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; oldv = tcg_temp_new(); newv = tcg_temp_new(); cmpv = tcg_temp_new(); gen_op_mov_v_reg(ot, newv, reg); tcg_gen_mov_tl(cmpv, cpu_regs[R_EAX]); if (s->prefix & PREFIX_LOCK) { if (mod == 3) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_atomic_cmpxchg_tl(oldv, cpu_A0, cmpv, newv, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, R_EAX, oldv); } else { if (mod == 3) { rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(ot, oldv, rm); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, oldv, cpu_A0); rm = 0; } gen_extu(ot, oldv); gen_extu(ot, cmpv); tcg_gen_movcond_tl(TCG_COND_EQ, newv, oldv, cmpv, newv, oldv); if (mod == 3) { gen_op_mov_reg_v(ot, R_EAX, oldv); gen_op_mov_reg_v(ot, rm, newv); } else { gen_op_st_v(s, ot, newv, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, oldv); } } tcg_gen_mov_tl(cpu_cc_src, oldv); tcg_gen_mov_tl(cpu_cc_srcT, cmpv); tcg_gen_sub_tl(cpu_cc_dst, cmpv, oldv); set_cc_op(s, CC_OP_SUBB + ot); tcg_temp_free(oldv); tcg_temp_free(newv); tcg_temp_free(cmpv); } break; case 0x1c7: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if ((mod == 3) || ((modrm & 0x38) != 0x8)) goto illegal_op; #ifdef TARGET_X86_64 if (dflag == MO_64) { if (!(s->cpuid_ext_features & CPUID_EXT_CX16)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg16b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg16b_unlocked(cpu_env, cpu_A0); } } else #endif { if (!(s->cpuid_features & CPUID_CX8)) goto illegal_op; gen_lea_modrm(env, s, modrm); if ((s->prefix & PREFIX_LOCK) && parallel_cpus) { gen_helper_cmpxchg8b(cpu_env, cpu_A0); } else { gen_helper_cmpxchg8b_unlocked(cpu_env, cpu_A0); } } set_cc_op(s, CC_OP_EFLAGS); break; case 0x50 ... 0x57: gen_op_mov_v_reg(MO_32, cpu_T0, (b & 7) | REX_B(s)); gen_push_v(s, cpu_T0); break; case 0x58 ... 0x5f: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_mov_reg_v(ot, (b & 7) | REX_B(s), cpu_T0); break; case 0x60: if (CODE64(s)) goto illegal_op; gen_pusha(s); break; case 0x61: if (CODE64(s)) goto illegal_op; gen_popa(s); break; case 0x68: case 0x6a: ot = mo_pushpop(s, dflag); if (b == 0x68) val = insn_get(env, s, ot); else val = (int8_t)insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_push_v(s, cpu_T0); break; case 0x8f: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; ot = gen_pop_T0(s); if (mod == 3) { gen_pop_update(s, ot); rm = (modrm & 7) | REX_B(s); gen_op_mov_reg_v(ot, rm, cpu_T0); } else { s->popl_esp_hack = 1 << ot; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); s->popl_esp_hack = 0; gen_pop_update(s, ot); } break; case 0xc8: { int level; val = x86_lduw_code(env, s); level = x86_ldub_code(env, s); gen_enter(s, val, level); } break; case 0xc9: gen_leave(s); break; case 0x06: case 0x0e: case 0x16: case 0x1e: if (CODE64(s)) goto illegal_op; gen_op_movl_T0_seg(b >> 3); gen_push_v(s, cpu_T0); break; case 0x1a0: case 0x1a8: gen_op_movl_T0_seg((b >> 3) & 7); gen_push_v(s, cpu_T0); break; case 0x07: case 0x17: case 0x1f: if (CODE64(s)) goto illegal_op; reg = b >> 3; ot = gen_pop_T0(s); gen_movl_seg_T0(s, reg); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x1a1: case 0x1a9: ot = gen_pop_T0(s); gen_movl_seg_T0(s, (b >> 3) & 7); gen_pop_update(s, ot); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x88: case 0x89: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0xc6: case 0xc7: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod != 3) { s->rip_offset = insn_const_size(ot); gen_lea_modrm(env, s, modrm); } val = insn_get(env, s, ot); tcg_gen_movi_tl(cpu_T0, val); if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, (modrm & 7) | REX_B(s), cpu_T0); } break; case 0x8a: case 0x8b: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x8e: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; if (reg >= 6 || reg == R_CS) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_movl_seg_T0(s, reg); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); if (reg == R_SS) { s->tf = 0; gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_eob(s); } } break; case 0x8c: modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (reg >= 6) goto illegal_op; gen_op_movl_T0_seg(reg); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0x1b6: case 0x1b7: case 0x1be: case 0x1bf: { TCGMemOp d_ot; TCGMemOp s_ot; d_ot = dflag; ot = (b & 1) + MO_8; s_ot = b & 8 ? MO_SIGN | ot : ot; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { if (s_ot == MO_SB && byte_reg_is_xH(rm)) { tcg_gen_sextract_tl(cpu_T0, cpu_regs[rm - 4], 8, 8); } else { gen_op_mov_v_reg(ot, cpu_T0, rm); switch (s_ot) { case MO_UB: tcg_gen_ext8u_tl(cpu_T0, cpu_T0); break; case MO_SB: tcg_gen_ext8s_tl(cpu_T0, cpu_T0); break; case MO_UW: tcg_gen_ext16u_tl(cpu_T0, cpu_T0); break; default: case MO_SW: tcg_gen_ext16s_tl(cpu_T0, cpu_T0); break; } } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, s_ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } break; case 0x8d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; { AddressParts a = gen_lea_modrm_0(env, s, modrm); TCGv ea = gen_lea_modrm_1(a); gen_lea_v_seg(s, s->aflag, ea, -1, -1); gen_op_mov_reg_v(dflag, reg, cpu_A0); } break; case 0xa0: case 0xa1: case 0xa2: case 0xa3: { target_ulong offset_addr; ot = mo_b_d(b, dflag); switch (s->aflag) { #ifdef TARGET_X86_64 case MO_64: offset_addr = x86_ldq_code(env, s); break; #endif default: offset_addr = insn_get(env, s, s->aflag); break; } tcg_gen_movi_tl(cpu_A0, offset_addr); gen_add_A0_ds_seg(s); if ((b & 2) == 0) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); gen_op_mov_reg_v(ot, R_EAX, cpu_T0); } else { gen_op_mov_v_reg(ot, cpu_T0, R_EAX); gen_op_st_v(s, ot, cpu_T0, cpu_A0); } } break; case 0xd7: tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EBX]); tcg_gen_ext8u_tl(cpu_T0, cpu_regs[R_EAX]); tcg_gen_add_tl(cpu_A0, cpu_A0, cpu_T0); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_op_ld_v(s, MO_8, cpu_T0, cpu_A0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xb0 ... 0xb7: val = insn_get(env, s, MO_8); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(MO_8, (b & 7) | REX_B(s), cpu_T0); break; case 0xb8 ... 0xbf: #ifdef TARGET_X86_64 if (dflag == MO_64) { uint64_t tmp; tmp = x86_ldq_code(env, s); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, tmp); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { ot = dflag; val = insn_get(env, s, ot); reg = (b & 7) | REX_B(s); tcg_gen_movi_tl(cpu_T0, val); gen_op_mov_reg_v(ot, reg, cpu_T0); } break; case 0x91 ... 0x97: do_xchg_reg_eax: ot = dflag; reg = (b & 7) | REX_B(s); rm = R_EAX; goto do_xchg_reg; case 0x86: case 0x87: ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) { rm = (modrm & 7) | REX_B(s); do_xchg_reg: gen_op_mov_v_reg(ot, cpu_T0, reg); gen_op_mov_v_reg(ot, cpu_T1, rm); gen_op_mov_reg_v(ot, rm, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T1); } else { gen_lea_modrm(env, s, modrm); gen_op_mov_v_reg(ot, cpu_T0, reg); tcg_gen_atomic_xchg_tl(cpu_T1, cpu_A0, cpu_T0, s->mem_index, ot | MO_LE); gen_op_mov_reg_v(ot, reg, cpu_T1); } break; case 0xc4: op = R_ES; goto do_lxx; case 0xc5: op = R_DS; goto do_lxx; case 0x1b2: op = R_SS; goto do_lxx; case 0x1b4: op = R_FS; goto do_lxx; case 0x1b5: op = R_GS; do_lxx: ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, cpu_T1, cpu_A0); gen_add_A0_im(s, 1 << ot); gen_op_ld_v(s, MO_16, cpu_T0, cpu_A0); gen_movl_seg_T0(s, op); gen_op_mov_reg_v(ot, reg, cpu_T1); if (s->base.is_jmp) { gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0xc0: case 0xc1: shift = 2; grp2: { ot = mo_b_d(b, dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; if (mod != 3) { if (shift == 2) { s->rip_offset = 1; } gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = (modrm & 7) | REX_B(s); } if (shift == 0) { gen_shift(s, op, ot, opreg, OR_ECX); } else { if (shift == 2) { shift = x86_ldub_code(env, s); } gen_shifti(s, op, ot, opreg, shift); } } break; case 0xd0: case 0xd1: shift = 1; goto grp2; case 0xd2: case 0xd3: shift = 0; goto grp2; case 0x1a4: op = 0; shift = 1; goto do_shiftd; case 0x1a5: op = 0; shift = 0; goto do_shiftd; case 0x1ac: op = 1; shift = 1; goto do_shiftd; case 0x1ad: op = 1; shift = 0; do_shiftd: ot = dflag; modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3) { gen_lea_modrm(env, s, modrm); opreg = OR_TMP0; } else { opreg = rm; } gen_op_mov_v_reg(ot, cpu_T1, reg); if (shift) { TCGv imm = tcg_const_tl(x86_ldub_code(env, s)); gen_shiftd_rm_T1(s, ot, opreg, op, imm); tcg_temp_free(imm); } else { gen_shiftd_rm_T1(s, ot, opreg, op, cpu_regs[R_ECX]); } break; case 0xd8 ... 0xdf: if (s->flags & (HF_EM_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; rm = modrm & 7; op = ((b & 7) << 3) | ((modrm >> 3) & 7); if (mod != 3) { gen_lea_modrm(env, s, modrm); switch(op) { case 0x00 ... 0x07: case 0x10 ... 0x17: case 0x20 ... 0x27: case 0x30 ... 0x37: { int op1; op1 = op & 7; switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_FT0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_FT0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_FT0(cpu_env, cpu_tmp2_i32); break; } gen_helper_fp_arith_ST0_FT0(op1); if (op1 == 3) { gen_helper_fpop(cpu_env); } } break; case 0x08: case 0x0a: case 0x0b: case 0x18 ... 0x1b: case 0x28 ... 0x2b: case 0x38 ... 0x3b: switch(op & 7) { case 0: switch(op >> 4) { case 0: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_flds_ST0(cpu_env, cpu_tmp2_i32); break; case 1: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; case 2: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fldl_ST0(cpu_env, cpu_tmp1_i64); break; case 3: default: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LESW); gen_helper_fildl_ST0(cpu_env, cpu_tmp2_i32); break; } break; case 1: switch(op >> 4) { case 1: gen_helper_fisttl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fisttll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fistt_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } gen_helper_fpop(cpu_env); break; default: switch(op >> 4) { case 0: gen_helper_fsts_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 1: gen_helper_fistl_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); break; case 2: gen_helper_fstl_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); break; case 3: default: gen_helper_fist_ST0(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; } if ((op & 7) == 3) gen_helper_fpop(cpu_env); break; } break; case 0x0c: gen_helper_fldenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0d: tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); gen_helper_fldcw(cpu_env, cpu_tmp2_i32); break; case 0x0e: gen_helper_fstenv(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x0f: gen_helper_fnstcw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x1d: gen_helper_fldt_ST0(cpu_env, cpu_A0); break; case 0x1f: gen_helper_fstt_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_frstor(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2e: gen_helper_fsave(cpu_env, cpu_A0, tcg_const_i32(dflag - 1)); break; case 0x2f: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_qemu_st_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUW); break; case 0x3c: gen_helper_fbld_ST0(cpu_env, cpu_A0); break; case 0x3e: gen_helper_fbst_ST0(cpu_env, cpu_A0); gen_helper_fpop(cpu_env); break; case 0x3d: tcg_gen_qemu_ld_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fildll_ST0(cpu_env, cpu_tmp1_i64); break; case 0x3f: gen_helper_fistll_ST0(cpu_tmp1_i64, cpu_env); tcg_gen_qemu_st_i64(cpu_tmp1_i64, cpu_A0, s->mem_index, MO_LEQ); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } } else { opreg = rm; switch(op) { case 0x08: gen_helper_fpush(cpu_env); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32((opreg + 1) & 7)); break; case 0x09: case 0x29: case 0x39: gen_helper_fxchg_ST0_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x0a: switch(rm) { case 0: gen_helper_fwait(cpu_env); break; default: goto unknown_op; } break; case 0x0c: switch(rm) { case 0: gen_helper_fchs_ST0(cpu_env); break; case 1: gen_helper_fabs_ST0(cpu_env); break; case 4: gen_helper_fldz_FT0(cpu_env); gen_helper_fcom_ST0_FT0(cpu_env); break; case 5: gen_helper_fxam_ST0(cpu_env); break; default: goto unknown_op; } break; case 0x0d: { switch(rm) { case 0: gen_helper_fpush(cpu_env); gen_helper_fld1_ST0(cpu_env); break; case 1: gen_helper_fpush(cpu_env); gen_helper_fldl2t_ST0(cpu_env); break; case 2: gen_helper_fpush(cpu_env); gen_helper_fldl2e_ST0(cpu_env); break; case 3: gen_helper_fpush(cpu_env); gen_helper_fldpi_ST0(cpu_env); break; case 4: gen_helper_fpush(cpu_env); gen_helper_fldlg2_ST0(cpu_env); break; case 5: gen_helper_fpush(cpu_env); gen_helper_fldln2_ST0(cpu_env); break; case 6: gen_helper_fpush(cpu_env); gen_helper_fldz_ST0(cpu_env); break; default: goto unknown_op; } } break; case 0x0e: switch(rm) { case 0: gen_helper_f2xm1(cpu_env); break; case 1: gen_helper_fyl2x(cpu_env); break; case 2: gen_helper_fptan(cpu_env); break; case 3: gen_helper_fpatan(cpu_env); break; case 4: gen_helper_fxtract(cpu_env); break; case 5: gen_helper_fprem1(cpu_env); break; case 6: gen_helper_fdecstp(cpu_env); break; default: case 7: gen_helper_fincstp(cpu_env); break; } break; case 0x0f: switch(rm) { case 0: gen_helper_fprem(cpu_env); break; case 1: gen_helper_fyl2xp1(cpu_env); break; case 2: gen_helper_fsqrt(cpu_env); break; case 3: gen_helper_fsincos(cpu_env); break; case 5: gen_helper_fscale(cpu_env); break; case 4: gen_helper_frndint(cpu_env); break; case 6: gen_helper_fsin(cpu_env); break; default: case 7: gen_helper_fcos(cpu_env); break; } break; case 0x00: case 0x01: case 0x04 ... 0x07: case 0x20: case 0x21: case 0x24 ... 0x27: case 0x30: case 0x31: case 0x34 ... 0x37: { int op1; op1 = op & 7; if (op >= 0x20) { gen_helper_fp_arith_STN_ST0(op1, opreg); if (op >= 0x30) gen_helper_fpop(cpu_env); } else { gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fp_arith_ST0_FT0(op1); } } break; case 0x02: case 0x22: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); break; case 0x03: case 0x23: case 0x32: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x15: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x1c: switch(rm) { case 0: break; case 1: break; case 2: gen_helper_fclex(cpu_env); break; case 3: gen_helper_fninit(cpu_env); break; case 4: break; default: goto unknown_op; } break; case 0x1d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x1e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x28: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); break; case 0x2a: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); break; case 0x2b: case 0x0b: case 0x3a: case 0x3b: gen_helper_fmov_STN_ST0(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x2c: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); break; case 0x2d: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); break; case 0x33: switch(rm) { case 1: gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(1)); gen_helper_fcom_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); gen_helper_fpop(cpu_env); break; default: goto unknown_op; } break; case 0x38: gen_helper_ffree_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fpop(cpu_env); break; case 0x3c: switch(rm) { case 0: gen_helper_fnstsw(cpu_tmp2_i32, cpu_env); tcg_gen_extu_i32_tl(cpu_T0, cpu_tmp2_i32); gen_op_mov_reg_v(MO_16, R_EAX, cpu_T0); break; default: goto unknown_op; } break; case 0x3d: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fucomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3e: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } gen_update_cc_op(s); gen_helper_fmov_FT0_STN(cpu_env, tcg_const_i32(opreg)); gen_helper_fcomi_ST0_FT0(cpu_env); gen_helper_fpop(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x10 ... 0x13: case 0x18 ... 0x1b: { int op1; TCGLabel *l1; static const uint8_t fcmov_cc[8] = { (JCC_B << 1), (JCC_Z << 1), (JCC_BE << 1), (JCC_P << 1), }; if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } op1 = fcmov_cc[op & 3] | (((op >> 3) & 1) ^ 1); l1 = gen_new_label(); gen_jcc1_noeob(s, op1, l1); gen_helper_fmov_ST0_STN(cpu_env, tcg_const_i32(opreg)); gen_set_label(l1); } break; default: goto unknown_op; } } break; case 0xa4: case 0xa5: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_movs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_movs(s, ot); } break; case 0xaa: case 0xab: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_stos(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_stos(s, ot); } break; case 0xac: case 0xad: ot = mo_b_d(b, dflag); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_lods(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_lods(s, ot); } break; case 0xae: case 0xaf: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_scas(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_scas(s, ot); } break; case 0xa6: case 0xa7: ot = mo_b_d(b, dflag); if (prefixes & PREFIX_REPNZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 1); } else if (prefixes & PREFIX_REPZ) { gen_repz_cmps(s, ot, pc_start - s->cs_base, s->pc - s->cs_base, 0); } else { gen_cmps(s, ot); } break; case 0x6c: case 0x6d: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_ins(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_ins(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0x6e: case 0x6f: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes) | 4); if (prefixes & (PREFIX_REPZ | PREFIX_REPNZ)) { gen_repz_outs(s, ot, pc_start - s->cs_base, s->pc - s->cs_base); } else { gen_outs(s, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_jmp(s, s->pc - s->cs_base); } } break; case 0xe4: case 0xe5: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xe6: case 0xe7: ot = mo_b_d32(b, dflag); val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T0, val); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_movi_i32(cpu_tmp2_i32, val); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xec: case 0xed: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, SVM_IOIO_TYPE_MASK | svm_is_rep(prefixes)); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_in_func(ot, cpu_T1, cpu_tmp2_i32); gen_op_mov_reg_v(ot, R_EAX, cpu_T1); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xee: case 0xef: ot = mo_b_d32(b, dflag); tcg_gen_ext16u_tl(cpu_T0, cpu_regs[R_EDX]); gen_check_io(s, ot, pc_start - s->cs_base, svm_is_rep(prefixes)); gen_op_mov_v_reg(ot, cpu_T1, R_EAX); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); tcg_gen_trunc_tl_i32(cpu_tmp3_i32, cpu_T1); gen_helper_out_func(ot, cpu_tmp2_i32, cpu_tmp3_i32); gen_bpt_io(s, cpu_tmp2_i32, ot); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0xc2: val = x86_ldsw_code(env, s); ot = gen_pop_T0(s); gen_stack_update(s, val + (1 << ot)); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xc3: ot = gen_pop_T0(s); gen_pop_update(s, ot); gen_op_jmp_v(cpu_T0); gen_bnd_jmp(s); gen_jr(s, cpu_T0); break; case 0xca: val = x86_ldsw_code(env, s); do_lret: if (s->pe && !s->vm86) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_lret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(val)); } else { gen_stack_A0(s); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_jmp_v(cpu_T0); gen_add_A0_im(s, 1 << dflag); gen_op_ld_v(s, dflag, cpu_T0, cpu_A0); gen_op_movl_seg_T0_vm(R_CS); gen_stack_update(s, val + (2 << dflag)); } gen_eob(s); break; case 0xcb: val = 0; goto do_lret; case 0xcf: gen_svm_check_intercept(s, pc_start, SVM_EXIT_IRET); if (!s->pe) { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } else if (s->vm86) { if (s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_iret_real(cpu_env, tcg_const_i32(dflag - 1)); set_cc_op(s, CC_OP_EFLAGS); } } else { gen_helper_iret_protected(cpu_env, tcg_const_i32(dflag - 1), tcg_const_i32(s->pc - s->cs_base)); set_cc_op(s, CC_OP_EFLAGS); } gen_eob(s); break; case 0xe8: { if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } tcg_gen_movi_tl(cpu_T0, next_eip); gen_push_v(s, cpu_T0); gen_bnd_jmp(s); gen_jmp(s, tval); } break; case 0x9a: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_lcall; case 0xe9: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } else if (!CODE64(s)) { tval &= 0xffffffff; } gen_bnd_jmp(s); gen_jmp(s, tval); break; case 0xea: { unsigned int selector, offset; if (CODE64(s)) goto illegal_op; ot = dflag; offset = insn_get(env, s, ot); selector = insn_get(env, s, MO_16); tcg_gen_movi_tl(cpu_T0, selector); tcg_gen_movi_tl(cpu_T1, offset); } goto do_ljmp; case 0xeb: tval = (int8_t)insn_get(env, s, MO_8); tval += s->pc - s->cs_base; if (dflag == MO_16) { tval &= 0xffff; } gen_jmp(s, tval); break; case 0x70 ... 0x7f: tval = (int8_t)insn_get(env, s, MO_8); goto do_jcc; case 0x180 ... 0x18f: if (dflag != MO_16) { tval = (int32_t)insn_get(env, s, MO_32); } else { tval = (int16_t)insn_get(env, s, MO_16); } do_jcc: next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } gen_bnd_jmp(s); gen_jcc(s, b, tval, next_eip); break; case 0x190 ... 0x19f: modrm = x86_ldub_code(env, s); gen_setcc1(s, b, cpu_T0); gen_ldst_modrm(env, s, modrm, MO_8, OR_TMP0, 1); break; case 0x140 ... 0x14f: if (!(s->cpuid_features & CPUID_CMOV)) { goto illegal_op; } ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_cmovcc1(env, s, ot, b, modrm, reg); break; case 0x9c: gen_svm_check_intercept(s, pc_start, SVM_EXIT_PUSHF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_helper_read_eflags(cpu_T0, cpu_env); gen_push_v(s, cpu_T0); } break; case 0x9d: gen_svm_check_intercept(s, pc_start, SVM_EXIT_POPF); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { ot = gen_pop_T0(s); if (s->cpl == 0) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK | IOPL_MASK) & 0xffff)); } } else { if (s->cpl <= s->iopl) { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK | IF_MASK) & 0xffff)); } } else { if (dflag != MO_16) { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK))); } else { gen_helper_write_eflags(cpu_env, cpu_T0, tcg_const_i32((TF_MASK | AC_MASK | ID_MASK | NT_MASK) & 0xffff)); } } } gen_pop_update(s, ot); set_cc_op(s, CC_OP_EFLAGS); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x9e: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_op_mov_v_reg(MO_8, cpu_T0, R_AH); gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, CC_O); tcg_gen_andi_tl(cpu_T0, cpu_T0, CC_S | CC_Z | CC_A | CC_P | CC_C); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, cpu_T0); break; case 0x9f: if (CODE64(s) && !(s->cpuid_ext3_features & CPUID_EXT3_LAHF_LM)) goto illegal_op; gen_compute_eflags(s); tcg_gen_ori_tl(cpu_T0, cpu_cc_src, 0x02); gen_op_mov_reg_v(MO_8, R_AH, cpu_T0); break; case 0xf5: gen_compute_eflags(s); tcg_gen_xori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xf8: gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_C); break; case 0xf9: gen_compute_eflags(s); tcg_gen_ori_tl(cpu_cc_src, cpu_cc_src, CC_C); break; case 0xfc: tcg_gen_movi_i32(cpu_tmp2_i32, 1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0xfd: tcg_gen_movi_i32(cpu_tmp2_i32, -1); tcg_gen_st_i32(cpu_tmp2_i32, cpu_env, offsetof(CPUX86State, df)); break; case 0x1ba: ot = dflag; modrm = x86_ldub_code(env, s); op = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod != 3) { s->rip_offset = 1; gen_lea_modrm(env, s, modrm); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } val = x86_ldub_code(env, s); tcg_gen_movi_tl(cpu_T1, val); if (op < 4) goto unknown_op; op -= 4; goto bt_op; case 0x1a3: op = 0; goto do_btx; case 0x1ab: op = 1; goto do_btx; case 0x1b3: op = 2; goto do_btx; case 0x1bb: op = 3; do_btx: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); gen_op_mov_v_reg(MO_32, cpu_T1, reg); if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); gen_exts(ot, cpu_T1); tcg_gen_sari_tl(cpu_tmp0, cpu_T1, 3 + ot); tcg_gen_shli_tl(cpu_tmp0, cpu_tmp0, ot); tcg_gen_add_tl(cpu_A0, gen_lea_modrm_1(a), cpu_tmp0); gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (!(s->prefix & PREFIX_LOCK)) { gen_op_ld_v(s, ot, cpu_T0, cpu_A0); } } else { gen_op_mov_v_reg(ot, cpu_T0, rm); } bt_op: tcg_gen_andi_tl(cpu_T1, cpu_T1, (1 << (3 + ot)) - 1); tcg_gen_movi_tl(cpu_tmp0, 1); tcg_gen_shl_tl(cpu_tmp0, cpu_tmp0, cpu_T1); if (s->prefix & PREFIX_LOCK) { switch (op) { case 0: gen_op_ld_v(s, ot, cpu_T0, cpu_A0); break; case 1: tcg_gen_atomic_fetch_or_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; case 2: tcg_gen_not_tl(cpu_tmp0, cpu_tmp0); tcg_gen_atomic_fetch_and_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; default: case 3: tcg_gen_atomic_fetch_xor_tl(cpu_T0, cpu_A0, cpu_tmp0, s->mem_index, ot | MO_LE); break; } tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); } else { tcg_gen_shr_tl(cpu_tmp4, cpu_T0, cpu_T1); switch (op) { case 0: break; case 1: tcg_gen_or_tl(cpu_T0, cpu_T0, cpu_tmp0); break; case 2: tcg_gen_andc_tl(cpu_T0, cpu_T0, cpu_tmp0); break; default: case 3: tcg_gen_xor_tl(cpu_T0, cpu_T0, cpu_tmp0); break; } if (op != 0) { if (mod != 3) { gen_op_st_v(s, ot, cpu_T0, cpu_A0); } else { gen_op_mov_reg_v(ot, rm, cpu_T0); } } } switch (s->cc_op) { case CC_OP_MULB ... CC_OP_MULQ: case CC_OP_ADDB ... CC_OP_ADDQ: case CC_OP_ADCB ... CC_OP_ADCQ: case CC_OP_SUBB ... CC_OP_SUBQ: case CC_OP_SBBB ... CC_OP_SBBQ: case CC_OP_LOGICB ... CC_OP_LOGICQ: case CC_OP_INCB ... CC_OP_INCQ: case CC_OP_DECB ... CC_OP_DECQ: case CC_OP_SHLB ... CC_OP_SHLQ: case CC_OP_SARB ... CC_OP_SARQ: case CC_OP_BMILGB ... CC_OP_BMILGQ: tcg_gen_mov_tl(cpu_cc_src, cpu_tmp4); set_cc_op(s, ((s->cc_op - CC_OP_MULB) & 3) + CC_OP_SARB); break; default: gen_compute_eflags(s); tcg_gen_deposit_tl(cpu_cc_src, cpu_cc_src, cpu_tmp4, ctz32(CC_C), 1); break; } break; case 0x1bc: case 0x1bd: ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); if ((prefixes & PREFIX_REPZ) && (b & 1 ? s->cpuid_ext3_features & CPUID_EXT3_ABM : s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_BMI1)) { int size = 8 << ot; tcg_gen_mov_tl(cpu_cc_src, cpu_T0); if (b & 1) { tcg_gen_clzi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS); tcg_gen_subi_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - size); } else { tcg_gen_ctzi_tl(cpu_T0, cpu_T0, size); } gen_op_update1_cc(); set_cc_op(s, CC_OP_BMILGB + ot); } else { tcg_gen_mov_tl(cpu_cc_dst, cpu_T0); set_cc_op(s, CC_OP_LOGICB + ot); if (b & 1) { tcg_gen_xori_tl(cpu_T1, cpu_regs[reg], TARGET_LONG_BITS - 1); tcg_gen_clz_tl(cpu_T0, cpu_T0, cpu_T1); tcg_gen_xori_tl(cpu_T0, cpu_T0, TARGET_LONG_BITS - 1); } else { tcg_gen_ctz_tl(cpu_T0, cpu_T0, cpu_regs[reg]); } } gen_op_mov_reg_v(ot, reg, cpu_T0); break; case 0x27: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_daa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x2f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_das(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x37: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aaa(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0x3f: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_helper_aas(cpu_env); set_cc_op(s, CC_OP_EFLAGS); break; case 0xd4: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); if (val == 0) { gen_exception(s, EXCP00_DIVZ, pc_start - s->cs_base); } else { gen_helper_aam(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); } break; case 0xd5: if (CODE64(s)) goto illegal_op; val = x86_ldub_code(env, s); gen_helper_aad(cpu_env, tcg_const_i32(val)); set_cc_op(s, CC_OP_LOGICB); break; case 0x90: if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (REX_B(s)) { goto do_xchg_reg_eax; } if (prefixes & PREFIX_REPZ) { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_pause(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x9b: if ((s->flags & (HF_MP_MASK | HF_TS_MASK)) == (HF_MP_MASK | HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); } else { gen_helper_fwait(cpu_env); } break; case 0xcc: gen_interrupt(s, EXCP03_INT3, pc_start - s->cs_base, s->pc - s->cs_base); break; case 0xcd: val = x86_ldub_code(env, s); if (s->vm86 && s->iopl != 3) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_interrupt(s, val, pc_start - s->cs_base, s->pc - s->cs_base); } break; case 0xce: if (CODE64(s)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_into(cpu_env, tcg_const_i32(s->pc - pc_start)); break; #ifdef WANT_ICEBP case 0xf1: gen_svm_check_intercept(s, pc_start, SVM_EXIT_ICEBP); #if 1 gen_debug(s, pc_start - s->cs_base); #else tb_flush(CPU(x86_env_get_cpu(env))); qemu_set_log(CPU_LOG_INT | CPU_LOG_TB_IN_ASM); #endif break; #endif case 0xfa: if (!s->vm86) { if (s->cpl <= s->iopl) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } else { if (s->iopl == 3) { gen_helper_cli(cpu_env); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } } break; case 0xfb: if (s->vm86 ? s->iopl == 3 : s->cpl <= s->iopl) { gen_helper_sti(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob_inhibit_irq(s, "True" == "True"); } else { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } break; case 0x62: if (CODE64(s)) goto illegal_op; ot = dflag; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_op_mov_v_reg(ot, cpu_T0, reg); gen_lea_modrm(env, s, modrm); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); if (ot == MO_16) { gen_helper_boundw(cpu_env, cpu_A0, cpu_tmp2_i32); } else { gen_helper_boundl(cpu_env, cpu_A0, cpu_tmp2_i32); } break; case 0x1c8 ... 0x1cf: reg = (b & 7) | REX_B(s); #ifdef TARGET_X86_64 if (dflag == MO_64) { gen_op_mov_v_reg(MO_64, cpu_T0, reg); tcg_gen_bswap64_i64(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_64, reg, cpu_T0); } else #endif { gen_op_mov_v_reg(MO_32, cpu_T0, reg); tcg_gen_ext32u_tl(cpu_T0, cpu_T0); tcg_gen_bswap32_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_32, reg, cpu_T0); } break; case 0xd6: if (CODE64(s)) goto illegal_op; gen_compute_eflags_c(s, cpu_T0); tcg_gen_neg_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(MO_8, R_EAX, cpu_T0); break; case 0xe0: case 0xe1: case 0xe2: case 0xe3: { TCGLabel *l1, *l2, *l3; tval = (int8_t)insn_get(env, s, MO_8); next_eip = s->pc - s->cs_base; tval += next_eip; if (dflag == MO_16) { tval &= 0xffff; } l1 = gen_new_label(); l2 = gen_new_label(); l3 = gen_new_label(); b &= 3; switch(b) { case 0: case 1: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jz_ecx(s->aflag, l3); gen_jcc1(s, (JCC_Z << 1) | (b ^ 1), l1); break; case 2: gen_op_add_reg_im(s->aflag, R_ECX, -1); gen_op_jnz_ecx(s->aflag, l1); break; default: case 3: gen_op_jz_ecx(s->aflag, l1); break; } gen_set_label(l3); gen_jmp_im(next_eip); tcg_gen_br(l2); gen_set_label(l1); gen_jmp_im(tval); gen_set_label(l2); gen_eob(s); } break; case 0x130: case 0x132: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { gen_helper_rdmsr(cpu_env); } else { gen_helper_wrmsr(cpu_env); } } break; case 0x131: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtsc(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; case 0x133: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_rdpmc(cpu_env); break; case 0x134: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysenter(cpu_env); gen_eob(s); } break; case 0x135: if (CODE64(s) && env->cpuid_vendor1 != CPUID_VENDOR_INTEL_1) goto illegal_op; if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysexit(cpu_env, tcg_const_i32(dflag - 1)); gen_eob(s); } break; #ifdef TARGET_X86_64 case 0x105: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_syscall(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob_worker(s, "False" != "False", "True" == "True"); break; case 0x107: if (!s->pe) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_helper_sysret(cpu_env, tcg_const_i32(dflag - 1)); if (s->lma) { set_cc_op(s, CC_OP_EFLAGS); } gen_eob_worker(s, "False" != "False", "True" == "True"); } break; #endif case 0x1a2: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_cpuid(cpu_env); break; case 0xf4: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_hlt(cpu_env, tcg_const_i32(s->pc - pc_start)); s->base.is_jmp = DISAS_NORETURN; } break; case 0x100: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, ldt.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 2: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_LDTR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_lldt(cpu_env, cpu_tmp2_i32); } break; case 1: if (!s->pe || s->vm86) goto illegal_op; gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_READ); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, tr.selector)); ot = mod == 3 ? dflag : MO_16; gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 3: if (!s->pe || s->vm86) goto illegal_op; if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_TR_WRITE); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_T0); gen_helper_ltr(cpu_env, cpu_tmp2_i32); } break; case 4: case 5: if (!s->pe || s->vm86) goto illegal_op; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_update_cc_op(s); if (op == 4) { gen_helper_verr(cpu_env, cpu_T0); } else { gen_helper_verw(cpu_env, cpu_T0); } set_cc_op(s, CC_OP_EFLAGS); break; default: goto unknown_op; } break; case 0x101: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xc8: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); tcg_gen_mov_tl(cpu_A0, cpu_regs[R_EAX]); gen_extu(s->aflag, cpu_A0); gen_add_A0_ds_seg(s); gen_helper_monitor(cpu_env, cpu_A0); break; case 0xc9: if (!(s->cpuid_ext_features & CPUID_EXT_MONITOR) || s->cpl != 0) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_mwait(cpu_env, tcg_const_i32(s->pc - pc_start)); gen_eob(s); break; case 0xca: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_clac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xcb: if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_SMAP) || s->cpl != 0) { goto illegal_op; } gen_helper_stac(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(1): gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_READ); gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.limit)); gen_op_st_v(s, MO_16, cpu_T0, cpu_A0); gen_add_A0_im(s, 2); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } gen_op_st_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); break; case 0xd0: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xgetbv(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xd1: if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->prefix & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_xsetbv(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xd8: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmrun(cpu_env, tcg_const_i32(s->aflag - 1), tcg_const_i32(s->pc - pc_start)); tcg_gen_exit_tb(0); s->base.is_jmp = DISAS_NORETURN; break; case 0xd9: if (!(s->flags & HF_SVME_MASK)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmmcall(cpu_env); break; case 0xda: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmload(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdb: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_vmsave(cpu_env, tcg_const_i32(s->aflag - 1)); break; case 0xdc: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_stgi(cpu_env); break; case 0xdd: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_clgi(cpu_env); break; case 0xde: if ((!(s->flags & HF_SVME_MASK) && !(s->cpuid_ext3_features & CPUID_EXT3_SKINIT)) || !s->pe) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_skinit(cpu_env); break; case 0xdf: if (!(s->flags & HF_SVME_MASK) || !s->pe) { goto illegal_op; } if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_helper_invlpga(cpu_env, tcg_const_i32(s->aflag - 1)); break; CASE_MODRM_MEM_OP(2): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_GDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, gdt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, gdt.limit)); break; CASE_MODRM_MEM_OP(3): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_IDTR_WRITE); gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_16, cpu_T1, cpu_A0); gen_add_A0_im(s, 2); gen_op_ld_v(s, CODE64(s) + MO_32, cpu_T0, cpu_A0); if (dflag == MO_16) { tcg_gen_andi_tl(cpu_T0, cpu_T0, 0xffffff); } tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, idt.base)); tcg_gen_st32_tl(cpu_T1, cpu_env, offsetof(CPUX86State, idt.limit)); break; CASE_MODRM_OP(4): gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_CR0); tcg_gen_ld_tl(cpu_T0, cpu_env, offsetof(CPUX86State, cr[0])); if (CODE64(s)) { mod = (modrm >> 6) & 3; ot = (mod != 3 ? MO_16 : s->dflag); } else { ot = MO_16; } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 1); break; case 0xee: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_rdpkru(cpu_tmp1_i64, cpu_env, cpu_tmp2_i32); tcg_gen_extr_i64_tl(cpu_regs[R_EAX], cpu_regs[R_EDX], cpu_tmp1_i64); break; case 0xef: if (prefixes & PREFIX_LOCK) { goto illegal_op; } tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); tcg_gen_trunc_tl_i32(cpu_tmp2_i32, cpu_regs[R_ECX]); gen_helper_wrpkru(cpu_env, cpu_tmp2_i32, cpu_tmp1_i64); break; CASE_MODRM_OP(6): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); gen_helper_lmsw(cpu_env, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(7): if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); break; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); gen_lea_modrm(env, s, modrm); gen_helper_invlpg(cpu_env, cpu_A0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; case 0xf8: #ifdef TARGET_X86_64 if (CODE64(s)) { if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { tcg_gen_mov_tl(cpu_T0, cpu_seg_base[R_GS]); tcg_gen_ld_tl(cpu_seg_base[R_GS], cpu_env, offsetof(CPUX86State, kernelgsbase)); tcg_gen_st_tl(cpu_T0, cpu_env, offsetof(CPUX86State, kernelgsbase)); } break; } #endif goto illegal_op; case 0xf9: if (!(s->cpuid_ext2_features & CPUID_EXT2_RDTSCP)) { goto illegal_op; } gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_rdtscp(cpu_env); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); gen_jmp(s, s->pc - s->cs_base); } break; default: goto unknown_op; } break; case 0x108: case 0x109: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, (b & 2) ? SVM_EXIT_INVD : SVM_EXIT_WBINVD); } break; case 0x63: #ifdef TARGET_X86_64 if (CODE64(s)) { int d_ot; d_ot = dflag; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; mod = (modrm >> 6) & 3; rm = (modrm & 7) | REX_B(s); if (mod == 3) { gen_op_mov_v_reg(MO_32, cpu_T0, rm); if (d_ot == MO_64) { tcg_gen_ext32s_tl(cpu_T0, cpu_T0); } gen_op_mov_reg_v(d_ot, reg, cpu_T0); } else { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, MO_32 | MO_SIGN, cpu_T0, cpu_A0); gen_op_mov_reg_v(d_ot, reg, cpu_T0); } } else #endif { TCGLabel *label1; TCGv t0, t1, t2, a0; if (!s->pe || s->vm86) goto illegal_op; t0 = tcg_temp_local_new(); t1 = tcg_temp_local_new(); t2 = tcg_temp_local_new(); ot = MO_16; modrm = x86_ldub_code(env, s); reg = (modrm >> 3) & 7; mod = (modrm >> 6) & 3; rm = modrm & 7; if (mod != 3) { gen_lea_modrm(env, s, modrm); gen_op_ld_v(s, ot, t0, cpu_A0); a0 = tcg_temp_local_new(); tcg_gen_mov_tl(a0, cpu_A0); } else { gen_op_mov_v_reg(ot, t0, rm); TCGV_UNUSED(a0); } gen_op_mov_v_reg(ot, t1, reg); tcg_gen_andi_tl(cpu_tmp0, t0, 3); tcg_gen_andi_tl(t1, t1, 3); tcg_gen_movi_tl(t2, 0); label1 = gen_new_label(); tcg_gen_brcond_tl(TCG_COND_GE, cpu_tmp0, t1, label1); tcg_gen_andi_tl(t0, t0, ~3); tcg_gen_or_tl(t0, t0, t1); tcg_gen_movi_tl(t2, CC_Z); gen_set_label(label1); if (mod != 3) { gen_op_st_v(s, ot, t0, a0); tcg_temp_free(a0); } else { gen_op_mov_reg_v(ot, rm, t0); } gen_compute_eflags(s); tcg_gen_andi_tl(cpu_cc_src, cpu_cc_src, ~CC_Z); tcg_gen_or_tl(cpu_cc_src, cpu_cc_src, t2); tcg_temp_free(t0); tcg_temp_free(t1); tcg_temp_free(t2); } break; case 0x102: case 0x103: { TCGLabel *label1; TCGv t0; if (!s->pe || s->vm86) goto illegal_op; ot = dflag != MO_16 ? MO_32 : MO_16; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, MO_16, OR_TMP0, 0); t0 = tcg_temp_local_new(); gen_update_cc_op(s); if (b == 0x102) { gen_helper_lar(t0, cpu_env, cpu_T0); } else { gen_helper_lsl(t0, cpu_env, cpu_T0); } tcg_gen_andi_tl(cpu_tmp0, cpu_cc_src, CC_Z); label1 = gen_new_label(); tcg_gen_brcondi_tl(TCG_COND_EQ, cpu_tmp0, 0, label1); gen_op_mov_reg_v(ot, reg, t0); gen_set_label(label1); set_cc_op(s, CC_OP_EFLAGS); tcg_temp_free(t0); } break; case 0x118: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; op = (modrm >> 3) & 7; switch(op) { case 0: case 1: case 2: case 3: if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; default: gen_nop_modrm(env, s, modrm); break; } break; case 0x11a: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (prefixes & PREFIX_REPZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_LTU, cpu_bndl[reg]); } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } TCGv_i64 notu = tcg_temp_new_i64(); tcg_gen_not_i64(notu, cpu_bndu[reg]); gen_bndck(env, s, modrm, TCG_COND_GTU, notu); tcg_temp_free_i64(notu); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg], cpu_bndl[reg2]); tcg_gen_mov_i64(cpu_bndu[reg], cpu_bndu[reg2]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_ld_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_ld_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } gen_set_hflag(s, HF_MPX_IU_MASK); } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndldx64(cpu_bndl[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ld_i64(cpu_bndu[reg], cpu_env, offsetof(CPUX86State, mmx_t0.MMX_Q(0))); } else { gen_helper_bndldx32(cpu_bndu[reg], cpu_env, cpu_A0, cpu_T0); tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndu[reg]); tcg_gen_shri_i64(cpu_bndu[reg], cpu_bndu[reg], 32); } gen_set_hflag(s, HF_MPX_IU_MASK); } } gen_nop_modrm(env, s, modrm); break; case 0x11b: modrm = x86_ldub_code(env, s); if (s->flags & HF_MPX_EN_MASK) { mod = (modrm >> 6) & 3; reg = ((modrm >> 3) & 7) | rex_r; if (mod != 3 && (prefixes & PREFIX_REPZ)) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } AddressParts a = gen_lea_modrm_0(env, s, modrm); if (a.base >= 0) { tcg_gen_extu_tl_i64(cpu_bndl[reg], cpu_regs[a.base]); if (!CODE64(s)) { tcg_gen_ext32u_i64(cpu_bndl[reg], cpu_bndl[reg]); } } else if (a.base == -1) { tcg_gen_movi_i64(cpu_bndl[reg], 0); } else { goto illegal_op; } tcg_gen_not_tl(cpu_A0, gen_lea_modrm_1(a)); if (!CODE64(s)) { tcg_gen_ext32u_tl(cpu_A0, cpu_A0); } tcg_gen_extu_tl_i64(cpu_bndu[reg], cpu_A0); gen_set_hflag(s, HF_MPX_IU_MASK); break; } else if (prefixes & PREFIX_REPNZ) { if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16) { goto illegal_op; } gen_bndck(env, s, modrm, TCG_COND_GTU, cpu_bndu[reg]); } else if (prefixes & PREFIX_DATA) { if (reg >= 4 || s->aflag == MO_16) { goto illegal_op; } if (mod == 3) { int reg2 = (modrm & 7) | REX_B(s); if (reg2 >= 4 || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if (s->flags & HF_MPX_IU_MASK) { tcg_gen_mov_i64(cpu_bndl[reg2], cpu_bndl[reg]); tcg_gen_mov_i64(cpu_bndu[reg2], cpu_bndu[reg]); } } else { gen_lea_modrm(env, s, modrm); if (CODE64(s)) { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEQ); tcg_gen_addi_tl(cpu_A0, cpu_A0, 8); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEQ); } else { tcg_gen_qemu_st_i64(cpu_bndl[reg], cpu_A0, s->mem_index, MO_LEUL); tcg_gen_addi_tl(cpu_A0, cpu_A0, 4); tcg_gen_qemu_st_i64(cpu_bndu[reg], cpu_A0, s->mem_index, MO_LEUL); } } } else if (mod != 3) { AddressParts a = gen_lea_modrm_0(env, s, modrm); if (reg >= 4 || (prefixes & PREFIX_LOCK) || s->aflag == MO_16 || a.base < -1) { goto illegal_op; } if (a.base >= 0) { tcg_gen_addi_tl(cpu_A0, cpu_regs[a.base], a.disp); } else { tcg_gen_movi_tl(cpu_A0, 0); } gen_lea_v_seg(s, s->aflag, cpu_A0, a.def_seg, s->override); if (a.index >= 0) { tcg_gen_mov_tl(cpu_T0, cpu_regs[a.index]); } else { tcg_gen_movi_tl(cpu_T0, 0); } if (CODE64(s)) { gen_helper_bndstx64(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } else { gen_helper_bndstx32(cpu_env, cpu_A0, cpu_T0, cpu_bndl[reg], cpu_bndu[reg]); } } } gen_nop_modrm(env, s, modrm); break; case 0x119: case 0x11c ... 0x11f: modrm = x86_ldub_code(env, s); gen_nop_modrm(env, s, modrm); break; case 0x120: case 0x122: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if ((prefixes & PREFIX_LOCK) && (reg == 0) && (s->cpuid_ext3_features & CPUID_EXT3_CR8LEG)) { reg = 8; } switch(reg) { case 0: case 2: case 3: case 4: case 8: gen_update_cc_op(s); gen_jmp_im(pc_start - s->cs_base); if (b & 2) { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_op_mov_v_reg(ot, cpu_T0, rm); gen_helper_write_crN(cpu_env, tcg_const_i32(reg), cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_start(); } gen_helper_read_crN(cpu_T0, cpu_env, tcg_const_i32(reg)); gen_op_mov_reg_v(ot, rm, cpu_T0); if (s->base.tb->cflags & CF_USE_ICOUNT) { gen_io_end(); } } break; default: goto unknown_op; } } break; case 0x121: case 0x123: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { modrm = x86_ldub_code(env, s); rm = (modrm & 7) | REX_B(s); reg = ((modrm >> 3) & 7) | rex_r; if (CODE64(s)) ot = MO_64; else ot = MO_32; if (reg >= 8) { goto illegal_op; } if (b & 2) { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_DR0 + reg); gen_op_mov_v_reg(ot, cpu_T0, rm); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_set_dr(cpu_env, cpu_tmp2_i32, cpu_T0); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_READ_DR0 + reg); tcg_gen_movi_i32(cpu_tmp2_i32, reg); gen_helper_get_dr(cpu_T0, cpu_env, cpu_tmp2_i32); gen_op_mov_reg_v(ot, rm, cpu_T0); } } break; case 0x106: if (s->cpl != 0) { gen_exception(s, EXCP0D_GPF, pc_start - s->cs_base); } else { gen_svm_check_intercept(s, pc_start, SVM_EXIT_WRITE_CR0); gen_helper_clts(cpu_env); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); } break; case 0x1c3: if (!(s->cpuid_features & CPUID_SSE2)) goto illegal_op; ot = mo_64_32(dflag); modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; reg = ((modrm >> 3) & 7) | rex_r; gen_ldst_modrm(env, s, modrm, ot, reg, 1); break; case 0x1ae: modrm = x86_ldub_code(env, s); switch (modrm) { CASE_MODRM_MEM_OP(0): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxsave(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(1): if (!(s->cpuid_features & CPUID_FXSR) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } if ((s->flags & HF_EM_MASK) || (s->flags & HF_TS_MASK)) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); gen_helper_fxrstor(cpu_env, cpu_A0); break; CASE_MODRM_MEM_OP(2): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_qemu_ld_i32(cpu_tmp2_i32, cpu_A0, s->mem_index, MO_LEUL); gen_helper_ldmxcsr(cpu_env, cpu_tmp2_i32); break; CASE_MODRM_MEM_OP(3): if ((s->flags & HF_EM_MASK) || !(s->flags & HF_OSFXSR_MASK)) { goto illegal_op; } if (s->flags & HF_TS_MASK) { gen_exception(s, EXCP07_PREX, pc_start - s->cs_base); break; } gen_lea_modrm(env, s, modrm); tcg_gen_ld32u_tl(cpu_T0, cpu_env, offsetof(CPUX86State, mxcsr)); gen_op_st_v(s, MO_32, cpu_T0, cpu_A0); break; CASE_MODRM_MEM_OP(4): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsave(cpu_env, cpu_A0, cpu_tmp1_i64); break; CASE_MODRM_MEM_OP(5): if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (prefixes & (PREFIX_LOCK | PREFIX_DATA | PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xrstor(cpu_env, cpu_A0, cpu_tmp1_i64); gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_eob(s); break; CASE_MODRM_MEM_OP(6): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLWB)) { goto illegal_op; } gen_nop_modrm(env, s, modrm); } else { if ((s->cpuid_ext_features & CPUID_EXT_XSAVE) == 0 || (s->cpuid_xsave_features & CPUID_XSAVE_XSAVEOPT) == 0 || (prefixes & (PREFIX_REPZ | PREFIX_REPNZ))) { goto illegal_op; } gen_lea_modrm(env, s, modrm); tcg_gen_concat_tl_i64(cpu_tmp1_i64, cpu_regs[R_EAX], cpu_regs[R_EDX]); gen_helper_xsaveopt(cpu_env, cpu_A0, cpu_tmp1_i64); } break; CASE_MODRM_MEM_OP(7): if (prefixes & PREFIX_LOCK) { goto illegal_op; } if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_CLFLUSHOPT)) { goto illegal_op; } } else { if ((s->prefix & (PREFIX_REPZ | PREFIX_REPNZ)) || !(s->cpuid_features & CPUID_CLFLUSH)) { goto illegal_op; } } gen_nop_modrm(env, s, modrm); break; case 0xc0 ... 0xc7: case 0xc8 ... 0xcf: case 0xd0 ... 0xd7: case 0xd8 ... 0xdf: if (CODE64(s) && (prefixes & PREFIX_REPZ) && !(prefixes & PREFIX_LOCK) && (s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_FSGSBASE)) { TCGv base, treg, src, dst; tcg_gen_movi_i32(cpu_tmp2_i32, CR4_FSGSBASE_MASK); gen_helper_cr4_testbit(cpu_env, cpu_tmp2_i32); base = cpu_seg_base[modrm & 8 ? R_GS : R_FS]; treg = cpu_regs[(modrm & 7) | REX_B(s)]; if (modrm & 0x10) { dst = base, src = treg; } else { dst = treg, src = base; } if (s->dflag == MO_32) { tcg_gen_ext32u_tl(dst, src); } else { tcg_gen_mov_tl(dst, src); } break; } goto unknown_op; case 0xf8: if (prefixes & PREFIX_DATA) { if (!(s->cpuid_7_0_ebx_features & CPUID_7_0_EBX_PCOMMIT) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } break; } case 0xf9 ... 0xff: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ST_ST | TCG_BAR_SC); break; case 0xe8 ... 0xef: if (!(s->cpuid_features & CPUID_SSE) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_LD_LD | TCG_BAR_SC); break; case 0xf0 ... 0xf7: if (!(s->cpuid_features & CPUID_SSE2) || (prefixes & PREFIX_LOCK)) { goto illegal_op; } tcg_gen_mb(TCG_MO_ALL | TCG_BAR_SC); break; default: goto unknown_op; } break; case 0x10d: modrm = x86_ldub_code(env, s); mod = (modrm >> 6) & 3; if (mod == 3) goto illegal_op; gen_nop_modrm(env, s, modrm); break; case 0x1aa: gen_svm_check_intercept(s, pc_start, SVM_EXIT_RSM); if (!(s->flags & HF_SMM_MASK)) goto illegal_op; gen_update_cc_op(s); gen_jmp_im(s->pc - s->cs_base); gen_helper_rsm(cpu_env); gen_eob(s); break; case 0x1b8: if ((prefixes & (PREFIX_REPZ | PREFIX_LOCK | PREFIX_REPNZ)) != PREFIX_REPZ) goto illegal_op; if (!(s->cpuid_ext_features & CPUID_EXT_POPCNT)) goto illegal_op; modrm = x86_ldub_code(env, s); reg = ((modrm >> 3) & 7) | rex_r; if (s->prefix & PREFIX_DATA) { ot = MO_16; } else { ot = mo_64_32(dflag); } gen_ldst_modrm(env, s, modrm, ot, OR_TMP0, 0); gen_extu(ot, cpu_T0); tcg_gen_mov_tl(cpu_cc_src, cpu_T0); tcg_gen_ctpop_tl(cpu_T0, cpu_T0); gen_op_mov_reg_v(ot, reg, cpu_T0); set_cc_op(s, CC_OP_POPCNT); break; case 0x10e ... 0x10f: s->prefix &= ~(PREFIX_REPZ | PREFIX_REPNZ | PREFIX_DATA); case 0x110 ... 0x117: case 0x128 ... 0x12f: case 0x138 ... 0x13a: case 0x150 ... 0x179: case 0x17c ... 0x17f: case 0x1c2: case 0x1c4 ... 0x1c6: case 0x1d0 ... 0x1fe: gen_sse(env, s, b, pc_start, rex_r); break; default: goto unknown_op; } return s->pc; illegal_op: gen_illegal_opcode(s); return s->pc; unknown_op: gen_unknown_opcode(env, s); return s->pc; }[Succeeded / Failed / Skipped / Total] 54 / 20 / 73 / 147:   5%|         | 147/2690 [01:06<19:13,  2.20it/s][Succeeded / Failed / Skipped / Total] 55 / 20 / 73 / 148:   6%|         | 148/2690 [01:06<19:05,  2.22it/s][Succeeded / Failed / Skipped / Total] 55 / 20 / 73 / 148:   6%|         | 149/2690 [01:07<19:03,  2.22it/s]
--------------------------------------------- Result 148 ---------------------------------------------
[[0 (78%)]] --> [[0 (43%)]] --> Socre: 0.5678868591785431

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *s, AVFormatParameters *[[ap]]) { MXFContext *[[mxf]] = s->priv_data; KLVPacket [[klv]]; int64_t [[essence_offset]] = 0; [[mxf]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) { av_log(s, AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek(s->pb, -14, SEEK_CUR); [[mxf]]->fc = s; [[mxf]]->run_in = avio_tell(s->pb); while (!s->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&[[klv]], s->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; else continue; } PRINT_KEY(s, "read header", [[klv]].key); av_dlog(s, "size %"PRIu64" offset %#"PRIx64"\n", [[klv]].length, [[klv]].offset); if (IS_KLV_KEY([[klv]].key, mxf_encrypted_triplet_key) || IS_KLV_KEY([[klv]].key, mxf_essence_element_key) || IS_KLV_KEY([[klv]].key, mxf_avid_essence_element_key) || IS_KLV_KEY([[klv]].key, mxf_system_item_key)) { if (![[mxf]]->current_partition->essence_offset) { compute_partition_essence_offset(s, [[mxf]], &[[klv]]); } if (![[essence_offset]]) [[essence_offset]] = [[klv]].offset; if (mxf_parse_handle_essence([[mxf]]) <= 0) break; continue; } else if (!memcmp([[klv]].key, mxf_header_partition_pack_key, 13) && [[klv]].key[13] >= 2 && [[klv]].key[13] <= 4 && [[mxf]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[mxf]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY([[klv]].key, metadata->key)) { int res; if ([[klv]].key[5] == 0x53) { res = mxf_read_local_tags([[mxf]], &[[klv]], metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell(s->pb) + [[klv]].length; res = metadata->read([[mxf]], s->pb, 0, [[klv]].length, [[klv]].key, [[klv]].offset); avio_seek(s->pb, next, SEEK_SET); } if (res < 0) { av_log(s, AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip(s->pb, [[klv]].length); } if (![[essence_offset]]) { av_log(s, AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek(s->pb, [[essence_offset]], SEEK_SET); mxf_compute_essence_containers([[mxf]]); return mxf_parse_structural_metadata([[mxf]]); }

[[[[Adv]]]]: static int mxf_read_header(AVFormatContext *s, AVFormatParameters *[[pas]]) { MXFContext *[[stringer]] = s->priv_data; KLVPacket [[britt]]; int64_t [[shivam]] = 0; [[stringer]]->last_forward_tell = INT64_MAX; if (!mxf_read_sync(s->pb, mxf_header_partition_pack_key, 14)) { av_log(s, AV_LOG_ERROR, "could not find header partition pack key\n"); return AVERROR_INVALIDDATA; } avio_seek(s->pb, -14, SEEK_CUR); [[stringer]]->fc = s; [[stringer]]->run_in = avio_tell(s->pb); while (!s->pb->eof_reached) { const MXFMetadataReadTableEntry *metadata; if (klv_read_packet(&[[britt]], s->pb) < 0) { if(mxf_parse_handle_partition_or_eof([[stringer]]) <= 0) break; else continue; } PRINT_KEY(s, "read header", [[britt]].key); av_dlog(s, "size %"PRIu64" offset %#"PRIx64"\n", [[britt]].length, [[britt]].offset); if (IS_KLV_KEY([[britt]].key, mxf_encrypted_triplet_key) || IS_KLV_KEY([[britt]].key, mxf_essence_element_key) || IS_KLV_KEY([[britt]].key, mxf_avid_essence_element_key) || IS_KLV_KEY([[britt]].key, mxf_system_item_key)) { if (![[stringer]]->current_partition->essence_offset) { compute_partition_essence_offset(s, [[stringer]], &[[britt]]); } if (![[shivam]]) [[shivam]] = [[britt]].offset; if (mxf_parse_handle_essence([[stringer]]) <= 0) break; continue; } else if (!memcmp([[britt]].key, mxf_header_partition_pack_key, 13) && [[britt]].key[13] >= 2 && [[britt]].key[13] <= 4 && [[stringer]]->current_partition) { if(mxf_parse_handle_partition_or_eof([[stringer]]) <= 0) break; } for (metadata = mxf_metadata_read_table; metadata->read; metadata++) { if (IS_KLV_KEY([[britt]].key, metadata->key)) { int res; if ([[britt]].key[5] == 0x53) { res = mxf_read_local_tags([[stringer]], &[[britt]], metadata->read, metadata->ctx_size, metadata->type); } else { uint64_t next = avio_tell(s->pb) + [[britt]].length; res = metadata->read([[stringer]], s->pb, 0, [[britt]].length, [[britt]].key, [[britt]].offset); avio_seek(s->pb, next, SEEK_SET); } if (res < 0) { av_log(s, AV_LOG_ERROR, "error reading header metadata\n"); return res; } break; } } if (!metadata->read) avio_skip(s->pb, [[britt]].length); } if (![[shivam]]) { av_log(s, AV_LOG_ERROR, "no essence\n"); return AVERROR_INVALIDDATA; } avio_seek(s->pb, [[shivam]], SEEK_SET); mxf_compute_essence_containers([[stringer]]); return mxf_parse_structural_metadata([[stringer]]); }
--------------------------------------------- Result 149 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 20 / 73 / 149:   6%|         | 149/2690 [01:07<19:03,  2.22it/s][[0 (56%)]] --> [[0 (50%)]] --> Socre: 0.5039551854133606

[[[[Adv]]]]: void commit_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *filter_node_name, Error **errp) { CommitBlockJob *s; BlockReopenQueue *reopen_queue = NULL; int [[orig_overlay_flags]]; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert(top != bs); if (top == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, top); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", top->filename); return; s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (!s) { return; orig_base_flags = bdrv_get_flags(base); [[orig_overlay_flags]] = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!([[orig_overlay_flags]] & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, [[orig_overlay_flags]] | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = top->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; s->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, base)); for (iter = top; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&s->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; s->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs(s->base, base, errp); if (ret < 0) { goto fail; s->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs(s->top, top, errp); if (ret < 0) { goto fail; s->active = bs; s->base_flags = orig_base_flags; s->orig_overlay_flags = [[orig_overlay_flags]]; s->backing_file_str = g_strdup(backing_file_str); s->on_error = on_error; trace_commit_start(bs, base, top, s); block_job_start(&s->common); return; fail: if (s->base) { blk_unref(s->base); if (s->top) { blk_unref(s->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&s->common);

[[[[Adv]]]]: void commit_start(const char *job_id, BlockDriverState *bs, BlockDriverState *base, BlockDriverState *top, int64_t speed, BlockdevOnError on_error, const char *backing_file_str, const char *filter_node_name, Error **errp) { CommitBlockJob *s; BlockReopenQueue *reopen_queue = NULL; int [[hee]]; int orig_base_flags; BlockDriverState *iter; BlockDriverState *overlay_bs; BlockDriverState *commit_top_bs = NULL; Error *local_err = NULL; int ret; assert(top != bs); if (top == base) { error_setg(errp, "Invalid files for merge: top and base are the same"); return; overlay_bs = bdrv_find_overlay(bs, top); if (overlay_bs == NULL) { error_setg(errp, "Could not find overlay image for %s:", top->filename); return; s = block_job_create(job_id, &commit_job_driver, bs, 0, BLK_PERM_ALL, speed, BLOCK_JOB_DEFAULT, NULL, NULL, errp); if (!s) { return; orig_base_flags = bdrv_get_flags(base); [[hee]] = bdrv_get_flags(overlay_bs); if (!(orig_base_flags & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, base, NULL, orig_base_flags | BDRV_O_RDWR); if (!([[hee]] & BDRV_O_RDWR)) { reopen_queue = bdrv_reopen_queue(reopen_queue, overlay_bs, NULL, [[hee]] | BDRV_O_RDWR); if (reopen_queue) { bdrv_reopen_multiple(bdrv_get_aio_context(bs), reopen_queue, &local_err); if (local_err != NULL) { error_propagate(errp, local_err); goto fail; commit_top_bs = bdrv_new_open_driver(&bdrv_commit_top, filter_node_name, 0, errp); if (commit_top_bs == NULL) { goto fail; commit_top_bs->total_sectors = top->total_sectors; bdrv_set_aio_context(commit_top_bs, bdrv_get_aio_context(top)); bdrv_set_backing_hd(commit_top_bs, top, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; bdrv_set_backing_hd(overlay_bs, commit_top_bs, &local_err); if (local_err) { bdrv_unref(commit_top_bs); commit_top_bs = NULL; error_propagate(errp, local_err); goto fail; s->commit_top_bs = commit_top_bs; bdrv_unref(commit_top_bs); assert(bdrv_chain_contains(top, base)); for (iter = top; iter != base; iter = backing_bs(iter)) { ret = block_job_add_bdrv(&s->common, "intermediate node", iter, 0, BLK_PERM_WRITE_UNCHANGED | BLK_PERM_WRITE, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "base", base, 0, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; ret = block_job_add_bdrv(&s->common, "overlay of top", overlay_bs, BLK_PERM_GRAPH_MOD, BLK_PERM_ALL, errp); if (ret < 0) { goto fail; s->base = blk_new(BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE | BLK_PERM_RESIZE, BLK_PERM_CONSISTENT_READ | BLK_PERM_GRAPH_MOD | BLK_PERM_WRITE_UNCHANGED); ret = blk_insert_bs(s->base, base, errp); if (ret < 0) { goto fail; s->top = blk_new(0, BLK_PERM_ALL); ret = blk_insert_bs(s->top, top, errp); if (ret < 0) { goto fail; s->active = bs; s->base_flags = orig_base_flags; s->orig_overlay_flags = [[hee]]; s->backing_file_str = g_strdup(backing_file_str); s->on_error = on_error; trace_commit_start(bs, base, top, s); block_job_start(&s->common); return; fail: if (s->base) { blk_unref(s->base); if (s->top) { blk_unref(s->top); if (commit_top_bs) { bdrv_set_backing_hd(overlay_bs, top, &error_abort); block_job_early_fail(&s->common);
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 20 / 73 / 150:   6%|         | 150/2690 [01:07<18:56,  2.23it/s][Succeeded / Failed / Skipped / Total] 57 / 20 / 74 / 151:   6%|         | 151/2690 [01:07<18:48,  2.25it/s][Succeeded / Failed / Skipped / Total] 58 / 20 / 74 / 152:   6%|         | 152/2690 [01:07<18:41,  2.26it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 74 / 153:   6%|         | 153/2690 [01:07<18:33,  2.28it/s][[0 (54%)]] --> [[0 (39%)]] --> Socre: 0.6100117862224579

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *[[initiator_name]] = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) { error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; } iscsi_url = iscsi_parse_full_url(iscsi, filename); if (iscsi_url == NULL) { error_report("Failed to parse URL : %s %s", filename, iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } memset(iscsilun, 0, sizeof(IscsiLun)); [[initiator_name]] = parse_initiator_name(iscsi_url->target); iscsi = iscsi_create_context([[initiator_name]]); if (iscsi == NULL) { error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; } if (iscsi_set_targetname(iscsi, iscsi_url->target)) { error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; } if (iscsi_url->user != NULL) { ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user, iscsi_url->passwd); if (ret != 0) { error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; } } if (parse_chap(iscsi, iscsi_url->target) != 0) { error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; } if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) { error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; } iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsi_url->lun; if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun, iscsi_connect_cb, &task) != 0) { error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; } while (!task.complete) { iscsi_set_events(iscsilun); qemu_aio_wait(); } if (task.status != 0) { error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsilun->type == TYPE_MEDIUM_CHANGER || iscsilun->type == TYPE_TAPE) { bs->sg = 1; } return 0; failed: if ([[initiator_name]] != NULL) { g_free([[initiator_name]]); } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsi != NULL) { iscsi_destroy_context(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); return ret; }

[[[[Adv]]]]: static int iscsi_open(BlockDriverState *bs, const char *filename, int flags) { IscsiLun *iscsilun = bs->opaque; struct iscsi_context *iscsi = NULL; struct iscsi_url *iscsi_url = NULL; struct IscsiTask task; char *[[squeezy]] = NULL; int ret; if ((BDRV_SECTOR_SIZE % 512) != 0) { error_report("iSCSI: Invalid BDRV_SECTOR_SIZE. " "BDRV_SECTOR_SIZE(%lld) is not a multiple " "of 512", BDRV_SECTOR_SIZE); return -EINVAL; } iscsi_url = iscsi_parse_full_url(iscsi, filename); if (iscsi_url == NULL) { error_report("Failed to parse URL : %s %s", filename, iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } memset(iscsilun, 0, sizeof(IscsiLun)); [[squeezy]] = parse_initiator_name(iscsi_url->target); iscsi = iscsi_create_context([[squeezy]]); if (iscsi == NULL) { error_report("iSCSI: Failed to create iSCSI context."); ret = -ENOMEM; goto failed; } if (iscsi_set_targetname(iscsi, iscsi_url->target)) { error_report("iSCSI: Failed to set target name."); ret = -EINVAL; goto failed; } if (iscsi_url->user != NULL) { ret = iscsi_set_initiator_username_pwd(iscsi, iscsi_url->user, iscsi_url->passwd); if (ret != 0) { error_report("Failed to set initiator username and password"); ret = -EINVAL; goto failed; } } if (parse_chap(iscsi, iscsi_url->target) != 0) { error_report("iSCSI: Failed to set CHAP user/password"); ret = -EINVAL; goto failed; } if (iscsi_set_session_type(iscsi, ISCSI_SESSION_NORMAL) != 0) { error_report("iSCSI: Failed to set session type to normal."); ret = -EINVAL; goto failed; } iscsi_set_header_digest(iscsi, ISCSI_HEADER_DIGEST_NONE_CRC32C); parse_header_digest(iscsi, iscsi_url->target); task.iscsilun = iscsilun; task.status = 0; task.complete = 0; task.bs = bs; iscsilun->iscsi = iscsi; iscsilun->lun = iscsi_url->lun; if (iscsi_full_connect_async(iscsi, iscsi_url->portal, iscsi_url->lun, iscsi_connect_cb, &task) != 0) { error_report("iSCSI: Failed to start async connect."); ret = -EINVAL; goto failed; } while (!task.complete) { iscsi_set_events(iscsilun); qemu_aio_wait(); } if (task.status != 0) { error_report("iSCSI: Failed to connect to LUN : %s", iscsi_get_error(iscsi)); ret = -EINVAL; goto failed; } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsilun->type == TYPE_MEDIUM_CHANGER || iscsilun->type == TYPE_TAPE) { bs->sg = 1; } return 0; failed: if ([[squeezy]] != NULL) { g_free([[squeezy]]); } if (iscsi_url != NULL) { iscsi_destroy_url(iscsi_url); } if (iscsi != NULL) { iscsi_destroy_context(iscsi); } memset(iscsilun, 0, sizeof(IscsiLun)); return ret; }
--------------------------------------------- Result 151 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int null_filter_samples(AVFilterLink *link, AVFilterBufferRef *samplesref) { return 0; }
--------------------------------------------- Result 152 ---------------------------------------------
[[0 (17%)]] --> [[0 (66%)]] --> Socre: 0.6625964045524597

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[tcet]], bool [[bypass]]) { [[tcet]]->bypass = [[bypass]]; }

[[[[Adv]]]]: void spapr_tce_set_bypass(sPAPRTCETable *[[banal]], bool [[shirk]]) { [[banal]]->bypass = [[shirk]]; }
--------------------------------------------- Result 153 ---------------------------------------------
[[0 (51%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *pkt_data, size_t pkt_len) { struct virtio_net_hdr *vhdr; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) { return; } vhdr = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr(vhdr); if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, vhdr->csum_start, vhdr->csum_offset); return; } data = (uint8_t *)pkt_data + vhdr->csum_start; len = pkt_len - vhdr->csum_start; stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len)); vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }

[[[[Adv]]]]: static void vmxnet3_rx_need_csum_calculate(struct VmxnetRxPkt *pkt, const void *pkt_data, size_t pkt_len) { struct virtio_net_hdr *vhdr; bool isip4, isip6, istcp, isudp; uint8_t *data; int len; if (!vmxnet_rx_pkt_has_virt_hdr(pkt)) { return; } vhdr = vmxnet_rx_pkt_get_vhdr(pkt); if (!VMXNET_FLAG_IS_SET(vhdr->flags, VIRTIO_NET_HDR_F_NEEDS_CSUM)) { return; } vmxnet_rx_pkt_get_protocols(pkt, &isip4, &isip6, &isudp, &istcp); if (!(isip4 || isip6) || !(istcp || isudp)) { return; } vmxnet3_dump_virt_hdr(vhdr); if (pkt_len < (vhdr->csum_start + vhdr->csum_offset + 2)) { VMW_PKPRN("packet len:%d < csum_start(%d) + csum_offset(%d) + 2, " "cannot calculate checksum", len, vhdr->csum_start, vhdr->csum_offset); return; } data = (uint8_t *)pkt_data + vhdr->csum_start; len = pkt_len - vhdr->csum_start; stw_be_p(data + vhdr->csum_offset, net_raw_checksum(data, len)); vhdr->flags &= ~VIRTIO_NET_HDR_F_NEEDS_CSUM; vhdr->flags |= VIRTIO_NET_HDR_F_DATA_VALID; }
--------------------------------------------- Result 154 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 58 / 21 / 75 / 154:   6%|         | 154/2690 [01:07<18:26,  2.29it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 76 / 155:   6%|         | 155/2690 [01:07<18:19,  2.31it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 77 / 156:   6%|         | 156/2690 [01:07<18:11,  2.32it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 78 / 157:   6%|         | 157/2690 [01:07<18:04,  2.34it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 78 / 157:   6%|         | 158/2690 [01:07<18:01,  2.34it/s][Succeeded / Failed / Skipped / Total] 58 / 21 / 79 / 158:   6%|         | 158/2690 [01:07<18:01,  2.34it/s][[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qmp_blockdev_add(BlockdevOptions *options, Error **errp) { QmpOutputVisitor *ov = qmp_output_visitor_new(); QObject *obj; QDict *qdict; Error *local_err = NULL; if (!options->has_id) { error_setg(errp, "Block device needs an ID"); goto fail; } if (options->has_aio && options->aio == BLOCKDEV_AIO_OPTIONS_NATIVE) { bool direct = options->cache->has_direct && options->cache->direct; if (!options->has_cache && !direct) { error_setg(errp, "aio=native requires cache.direct=true"); goto fail; } } visit_type_BlockdevOptions(qmp_output_get_visitor(ov), &options, NULL, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } obj = qmp_output_get_qobject(ov); qdict = qobject_to_qdict(obj); qdict_flatten(qdict); blockdev_init(NULL, qdict, &local_err); if (local_err) { error_propagate(errp, local_err); goto fail; } fail: qmp_output_visitor_cleanup(ov); }
--------------------------------------------- Result 155 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_system_wakeup_request(WakeupReason reason) { if (!is_suspended) { return; } if (!(wakeup_reason_mask & (1 << reason))) { return; } runstate_set(RUN_STATE_RUNNING); monitor_protocol_event(QEVENT_WAKEUP, NULL); notifier_list_notify(&wakeup_notifiers, &reason); reset_requested = 1; qemu_notify_event(); is_suspended = "False" != "False"; }
--------------------------------------------- Result 156 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: CommandInfoList *qmp_query_commands(Error **errp) { CommandInfoList *list = NULL; qmp_for_each_command(&qmp_commands, query_commands_cb, &list); return list; }
--------------------------------------------- Result 157 ---------------------------------------------
[[0 (29%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void kvmclock_pre_save(void *opaque) { KVMClockState *s = opaque; struct kvm_clock_data data; int ret; if (s->clock_valid) { return; } ret = kvm_vm_ioctl(kvm_state, KVM_GET_CLOCK, &data); if (ret < 0) { fprintf(stderr, "KVM_GET_CLOCK failed: %s\n", strerror(ret)); data.clock = 0; } s->clock = data.clock; s->clock_valid = !runstate_is_running(); }
--------------------------------------------- Result 158 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rtsp_listen(AVFormatContext *s) { RTSPState *rt = s->priv_data; char proto[128], host[128], path[512], auth[128]; char uri[500]; int port; int default_port = RTSP_DEFAULT_PORT; char tcpname[500]; const char *lower_proto = "tcp"; unsigned char rbuf[4096]; unsigned char method[10]; int rbuflen = 0; int ret; enum RTSPMethod methodcode; if (!rt->protocols) { rt->protocols = ffurl_get_protocols(NULL, NULL); if (!rt->protocols) return AVERROR(ENOMEM); } av_url_split(proto, sizeof(proto), auth, sizeof(auth), host, sizeof(host), &port, path, sizeof(path), s->filename); ff_url_join(rt->control_uri, sizeof(rt->control_uri), proto, NULL, host, port, "%s", path); if (!strcmp(proto, "rtsps")) { lower_proto = "tls"; default_port = RTSPS_DEFAULT_PORT; } if (port < 0) port = default_port; ff_url_join(tcpname, sizeof(tcpname), lower_proto, NULL, host, port, "?listen&listen_timeout=%d", rt->initial_timeout * 1000); if (ret = ffurl_open(&rt->rtsp_hd, tcpname, AVIO_FLAG_READ_WRITE, &s->interrupt_callback, NULL, rt->protocols)) { av_log(s, AV_LOG_ERROR, "Unable to open RTSP for listening\n"); return ret; } rt->state = RTSP_STATE_IDLE; rt->rtsp_hd_out = rt->rtsp_hd; for (;;) { ret = read_line(s, rbuf, sizeof(rbuf), &rbuflen); if (ret < 0) return ret; ret = parse_command_line(s, rbuf, rbuflen, uri, sizeof(uri), method, sizeof(method), &methodcode); if (ret) { av_log(s, AV_LOG_ERROR, "RTSP: Unexpected Command\n"); return ret; } if (methodcode == ANNOUNCE) { ret = rtsp_read_announce(s); rt->state = RTSP_STATE_PAUSED; } else if (methodcode == OPTIONS) { ret = rtsp_read_options(s); } else if (methodcode == RECORD) { ret = rtsp_read_record(s); if (!ret) return 0; } else if (methodcode == SETUP) ret = rtsp_read_setup(s, host, uri); if (ret) { ffurl_close(rt->rtsp_hd); return AVERROR_INVALIDDATA; } } return 0; }
--------------------------------------------- Result 159 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 21 / 79 / 159:   6%|         | 159/2690 [01:07<17:54,  2.36it/s][Succeeded / Failed / Skipped / Total] 60 / 21 / 79 / 160:   6%|         | 160/2690 [01:07<17:50,  2.36it/s][[0 (63%)]] --> [[0 (50%)]] --> Socre: 0.5007888674736023

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int [[c]], const unsigned int *[[div_blocks]], unsigned int *js_blocks) { ALSSpecificConfig *sconf = &ctx->sconf; unsigned int [[offset]] = 0; unsigned int [[b]]; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = ctx->const_block; bd[0].shift_lsbs = ctx->shift_lsbs; bd[0].opt_order = ctx->opt_order; bd[0].store_prev_samples = ctx->store_prev_samples; bd[0].use_ltp = ctx->use_ltp; bd[0].ltp_lag = ctx->ltp_lag; bd[0].ltp_gain = ctx->ltp_gain[0]; bd[0].quant_cof = ctx->quant_cof[0]; bd[0].lpc_cof = ctx->lpc_cof[0]; bd[0].prev_raw_samples = ctx->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = ctx->const_block; bd[1].shift_lsbs = ctx->shift_lsbs; bd[1].opt_order = ctx->opt_order; bd[1].store_prev_samples = ctx->store_prev_samples; bd[1].use_ltp = ctx->use_ltp; bd[1].ltp_lag = ctx->ltp_lag; bd[1].ltp_gain = ctx->ltp_gain[0]; bd[1].quant_cof = ctx->quant_cof[0]; bd[1].lpc_cof = ctx->lpc_cof[0]; bd[1].prev_raw_samples = ctx->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for ([[b]] = 0; [[b]] < ctx->num_blocks; [[b]]++) { unsigned int s; bd[0].block_length = [[div_blocks]][[[b]]]; bd[1].block_length = [[div_blocks]][[[b]]]; bd[0].raw_samples = ctx->raw_samples[[[c]] ] + [[offset]]; bd[1].raw_samples = ctx->raw_samples[[[c]] + 1] + [[offset]]; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) { zero_remaining([[b]], ctx->num_blocks, [[div_blocks]], bd[0].raw_samples); zero_remaining([[b]], ctx->num_blocks, [[div_blocks]], bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log(ctx->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < [[div_blocks]][[[b]]]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < [[div_blocks]][[[b]]]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } [[offset]] += [[div_blocks]][[[b]]]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove(ctx->raw_samples[[[c]]] - sconf->max_order, ctx->raw_samples[[[c]]] - sconf->max_order + sconf->frame_length, sizeof(*ctx->raw_samples[[[c]]]) * sconf->max_order); return 0; }

[[[[Adv]]]]: static int decode_blocks(ALSDecContext *ctx, unsigned int ra_frame, unsigned int [[chap]], const unsigned int *[[coli]], unsigned int *js_blocks) { ALSSpecificConfig *sconf = &ctx->sconf; unsigned int [[thwarted]] = 0; unsigned int [[trois]]; ALSBlockData bd[2] = { { 0 } }; bd[0].ra_block = ra_frame; bd[0].const_block = ctx->const_block; bd[0].shift_lsbs = ctx->shift_lsbs; bd[0].opt_order = ctx->opt_order; bd[0].store_prev_samples = ctx->store_prev_samples; bd[0].use_ltp = ctx->use_ltp; bd[0].ltp_lag = ctx->ltp_lag; bd[0].ltp_gain = ctx->ltp_gain[0]; bd[0].quant_cof = ctx->quant_cof[0]; bd[0].lpc_cof = ctx->lpc_cof[0]; bd[0].prev_raw_samples = ctx->prev_raw_samples; bd[0].js_blocks = *js_blocks; bd[1].ra_block = ra_frame; bd[1].const_block = ctx->const_block; bd[1].shift_lsbs = ctx->shift_lsbs; bd[1].opt_order = ctx->opt_order; bd[1].store_prev_samples = ctx->store_prev_samples; bd[1].use_ltp = ctx->use_ltp; bd[1].ltp_lag = ctx->ltp_lag; bd[1].ltp_gain = ctx->ltp_gain[0]; bd[1].quant_cof = ctx->quant_cof[0]; bd[1].lpc_cof = ctx->lpc_cof[0]; bd[1].prev_raw_samples = ctx->prev_raw_samples; bd[1].js_blocks = *(js_blocks + 1); for ([[trois]] = 0; [[trois]] < ctx->num_blocks; [[trois]]++) { unsigned int s; bd[0].block_length = [[coli]][[[trois]]]; bd[1].block_length = [[coli]][[[trois]]]; bd[0].raw_samples = ctx->raw_samples[[[chap]] ] + [[thwarted]]; bd[1].raw_samples = ctx->raw_samples[[[chap]] + 1] + [[thwarted]]; bd[0].raw_other = bd[1].raw_samples; bd[1].raw_other = bd[0].raw_samples; if(read_decode_block(ctx, &bd[0]) || read_decode_block(ctx, &bd[1])) { zero_remaining([[trois]], ctx->num_blocks, [[coli]], bd[0].raw_samples); zero_remaining([[trois]], ctx->num_blocks, [[coli]], bd[1].raw_samples); return -1; } if (bd[0].js_blocks) { if (bd[1].js_blocks) av_log(ctx->avctx, AV_LOG_WARNING, "Invalid channel pair!\n"); for (s = 0; s < [[coli]][[[trois]]]; s++) bd[0].raw_samples[s] = bd[1].raw_samples[s] - bd[0].raw_samples[s]; } else if (bd[1].js_blocks) { for (s = 0; s < [[coli]][[[trois]]]; s++) bd[1].raw_samples[s] = bd[1].raw_samples[s] + bd[0].raw_samples[s]; } [[thwarted]] += [[coli]][[[trois]]]; bd[0].ra_block = 0; bd[1].ra_block = 0; } memmove(ctx->raw_samples[[[chap]]] - sconf->max_order, ctx->raw_samples[[[chap]]] - sconf->max_order + sconf->frame_length, sizeof(*ctx->raw_samples[[[chap]]]) * sconf->max_order); return 0; }
--------------------------------------------- Result 160 ---------------------------------------------
[[0 (86%)]] --> [[0 (49%)]] --> Socre: 0.5073651373386383

[[[[Adv]]]]: static void handle_satn(ESPState *[[s]]) { uint8_t buf[32]; int [[len]]; if ([[s]]->dma && ![[s]]->dma_enabled) { [[s]]->dma_cb = handle_satn; return; } [[len]] = get_cmd([[s]], buf); if ([[len]]) do_cmd([[s]], buf); }

[[[[Adv]]]]: static void handle_satn(ESPState *[[nor]]) { uint8_t buf[32]; int [[hardly]]; if ([[nor]]->dma && ![[nor]]->dma_enabled) { [[nor]]->dma_cb = handle_satn; return; } [[hardly]] = get_cmd([[nor]], buf); if ([[hardly]]) do_cmd([[nor]], buf); }
--------------------------------------------- Result 161 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 61 / 21 / 79 / 161:   6%|         | 161/2690 [01:09<18:07,  2.32it/s][Succeeded / Failed / Skipped / Total] 62 / 21 / 79 / 162:   6%|         | 162/2690 [01:09<18:00,  2.34it/s][Succeeded / Failed / Skipped / Total] 62 / 21 / 80 / 163:   6%|         | 163/2690 [01:09<17:53,  2.35it/s][Succeeded / Failed / Skipped / Total] 63 / 21 / 80 / 164:   6%|         | 164/2690 [01:09<17:46,  2.37it/s][[0 (34%)]] --> [[0 (51%)]] --> Socre: 0.507318913936615

[[[[Adv]]]]: static int write_f(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int [[c]], cnt; char *[[buf]]; int64_t [[offset]]; int count; int total = 0; int pattern = 0xcd; while (([[c]] = getopt(argc, argv, "bCpP:q")) != EOF) { switch ([[c]]) { case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); } } if (optind != argc - 2) { return command_usage(&write_cmd); } if (bflag && pflag) { printf("-b and -p cannot be specified at the same time\n"); return 0; } [[offset]] = cvtnum(argv[optind]); if ([[offset]] < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } if (!pflag) { if ([[offset]] & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", [[offset]]); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } } [[buf]] = qemu_io_alloc(count, pattern); gettimeofday(&t1, NULL); if (pflag) { cnt = do_pwrite([[buf]], [[offset]], count, &total); } else if (bflag) { cnt = do_save_vmstate([[buf]], [[offset]], count, &total); } else { cnt = do_write([[buf]], [[offset]], count, &total); } gettimeofday(&t2, NULL); if (cnt < 0) { printf("write failed: %s\n", strerror(-cnt)); goto out; } if (qflag) { goto out; } t2 = tsub(t2, t1); print_report("wrote", &t2, [[offset]], count, total, cnt, Cflag); out: qemu_io_free([[buf]]); return 0; }

[[[[Adv]]]]: static int write_f(int argc, char **argv) { struct timeval t1, t2; int Cflag = 0, pflag = 0, qflag = 0, bflag = 0; int [[tre]], cnt; char *[[true]]; int64_t [[smashed]]; int count; int total = 0; int pattern = 0xcd; while (([[tre]] = getopt(argc, argv, "bCpP:q")) != EOF) { switch ([[tre]]) { case 'b': bflag = 1; break; case 'C': Cflag = 1; break; case 'p': pflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'q': qflag = 1; break; default: return command_usage(&write_cmd); } } if (optind != argc - 2) { return command_usage(&write_cmd); } if (bflag && pflag) { printf("-b and -p cannot be specified at the same time\n"); return 0; } [[smashed]] = cvtnum(argv[optind]); if ([[smashed]] < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; count = cvtnum(argv[optind]); if (count < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } if (!pflag) { if ([[smashed]] & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", [[smashed]]); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } } [[true]] = qemu_io_alloc(count, pattern); gettimeofday(&t1, NULL); if (pflag) { cnt = do_pwrite([[true]], [[smashed]], count, &total); } else if (bflag) { cnt = do_save_vmstate([[true]], [[smashed]], count, &total); } else { cnt = do_write([[true]], [[smashed]], count, &total); } gettimeofday(&t2, NULL); if (cnt < 0) { printf("write failed: %s\n", strerror(-cnt)); goto out; } if (qflag) { goto out; } t2 = tsub(t2, t1); print_report("wrote", &t2, [[smashed]], count, total, cnt, Cflag); out: qemu_io_free([[true]]); return 0; }
--------------------------------------------- Result 162 ---------------------------------------------
[[0 (57%)]] --> [[0 (45%)]] --> Socre: 0.5451982021331787

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int [[version]], WMACoef *ptr, int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1(gb) - 1; iptr[offset & coef_mask] = ilvl[code] ^ sign << 31; } else if (code == 1) { break; } else { if (![[version]]) { level = get_bits(gb, coef_nb_bits); offset += get_bits(gb, frame_len_bits); } else { level = ff_wma_get_large_val(gb); if (get_bits1(gb)) { if (get_bits1(gb)) { if (get_bits1(gb)) { av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits(gb, frame_len_bits) + 4; } else offset += get_bits(gb, 2) + 1; } } sign = get_bits1(gb) - 1; ptr[offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }

[[[[Adv]]]]: int ff_wma_run_level_decode(AVCodecContext *avctx, GetBitContext *gb, VLC *vlc, const float *level_table, const uint16_t *run_table, int [[papier]], WMACoef *ptr, int offset, int num_coefs, int block_len, int frame_len_bits, int coef_nb_bits) { int code, level, sign; const uint32_t *ilvl = (const uint32_t *) level_table; uint32_t *iptr = (uint32_t *) ptr; const unsigned int coef_mask = block_len - 1; for (; offset < num_coefs; offset++) { code = get_vlc2(gb, vlc->table, VLCBITS, VLCMAX); if (code > 1) { offset += run_table[code]; sign = get_bits1(gb) - 1; iptr[offset & coef_mask] = ilvl[code] ^ sign << 31; } else if (code == 1) { break; } else { if (![[papier]]) { level = get_bits(gb, coef_nb_bits); offset += get_bits(gb, frame_len_bits); } else { level = ff_wma_get_large_val(gb); if (get_bits1(gb)) { if (get_bits1(gb)) { if (get_bits1(gb)) { av_log(avctx, AV_LOG_ERROR, "broken escape sequence\n"); return -1; } else offset += get_bits(gb, frame_len_bits) + 4; } else offset += get_bits(gb, 2) + 1; } } sign = get_bits1(gb) - 1; ptr[offset & coef_mask] = (level ^ sign) - sign; } } if (offset > num_coefs) { av_log(avctx, AV_LOG_ERROR, "overflow in spectral RLE, ignoring\n"); return -1; } return 0; }
--------------------------------------------- Result 163 ---------------------------------------------
[[0 (23%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static coroutine_fn int sd_co_writev(BlockDriverState *bs, int64_t sector_num, int nb_sectors, QEMUIOVector *qiov) { SheepdogAIOCB *acb; int ret; if (bs->growable && sector_num + nb_sectors > bs->total_sectors) { ret = sd_truncate(bs, (sector_num + nb_sectors) * BDRV_SECTOR_SIZE); if (ret < 0) { return ret; } bs->total_sectors = sector_num + nb_sectors; } acb = sd_aio_setup(bs, qiov, sector_num, nb_sectors); acb->aio_done_func = sd_write_done; acb->aiocb_type = AIOCB_WRITE_UDATA; ret = sd_co_rw_vector(acb); if (ret <= 0) { qemu_aio_release(acb); return ret; } qemu_coroutine_yield(); return acb->ret; }
--------------------------------------------- Result 164 ---------------------------------------------
[[0 (74%)]] --> [[0 (43%)]] --> Socre: 0.574582040309906

[[[[Adv]]]]: static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b) { int [[sa]], sb; [[sa]] = ((int64_t)*phigh < 0); if ([[sa]]) neg128(plow, phigh); sb = (b < 0); if (sb) b = -b; div64(plow, phigh, b); if ([[sa]] ^ sb) *plow = - *plow; if ([[sa]]) *phigh = - *phigh; }

[[[[Adv]]]]: static void idiv64(uint64_t *plow, uint64_t *phigh, int64_t b) { int [[mh]], sb; [[mh]] = ((int64_t)*phigh < 0); if ([[mh]]) neg128(plow, phigh); sb = (b < 0); if (sb) b = -b; div64(plow, phigh, b); if ([[mh]] ^ sb) *plow = - *plow; if ([[mh]]) *phigh = - *phigh; }
--------------------------------------------- Result 165 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 64 / 21 / 80 / 165:   6%|         | 165/2690 [01:09<17:39,  2.38it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 80 / 166:   6%|         | 166/2690 [01:09<17:33,  2.40it/s][Succeeded / Failed / Skipped / Total] 65 / 21 / 80 / 166:   6%|         | 167/2690 [01:09<17:26,  2.41it/s][[0 (43%)]] --> [[0 (51%)]] --> Socre: 0.5107260346412659

[[[[Adv]]]]: static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info) { BDRVSheepdogState *s = bs->opaque; int ret, fd; uint32_t new_vid; SheepdogInode *inode; unsigned int datalen; dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " " "is_snapshot %d\n", sn_info->name, sn_info->id_str, s->name, sn_info->vm_state_size, s->is_snapshot); if (s->is_snapshot) { error_report("You can't create a snapshot of a snapshot VDI, " "%s (%" PRIu32 ").", s->name, s->inode.vdi_id); return -EINVAL; } dprintf("%s %s\n", sn_info->name, sn_info->id_str); s->inode.vm_state_size = sn_info->vm_state_size; s->inode.vm_clock_nsec = sn_info->vm_clock_nsec; strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag)); datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { ret = fd; goto cleanup; } ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id), s->inode.nr_copies, datalen, 0, "[[False]]" != "[[False]]", s->cache_enabled); if (ret < 0) { error_report("failed to write snapshot's inode."); goto cleanup; } ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1, s->addr, s->port); if (ret < 0) { error_report("failed to create inode for snapshot. %s", strerror(errno)); goto cleanup; } inode = (SheepdogInode *)g_malloc(datalen); ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid), s->inode.nr_copies, datalen, 0, s->cache_enabled); if (ret < 0) { error_report("failed to read new inode info. %s", strerror(errno)); goto cleanup; } memcpy(&s->inode, inode, datalen); dprintf("s->inode: name %s snap_id %x oid %x\n", s->inode.name, s->inode.snap_id, s->inode.vdi_id); cleanup: closesocket(fd); return ret; }

[[[[Adv]]]]: static int sd_snapshot_create(BlockDriverState *bs, QEMUSnapshotInfo *sn_info) { BDRVSheepdogState *s = bs->opaque; int ret, fd; uint32_t new_vid; SheepdogInode *inode; unsigned int datalen; dprintf("sn_info: name %s id_str %s s: name %s vm_state_size %" PRId64 " " "is_snapshot %d\n", sn_info->name, sn_info->id_str, s->name, sn_info->vm_state_size, s->is_snapshot); if (s->is_snapshot) { error_report("You can't create a snapshot of a snapshot VDI, " "%s (%" PRIu32 ").", s->name, s->inode.vdi_id); return -EINVAL; } dprintf("%s %s\n", sn_info->name, sn_info->id_str); s->inode.vm_state_size = sn_info->vm_state_size; s->inode.vm_clock_nsec = sn_info->vm_clock_nsec; strncpy(s->inode.tag, sn_info->name, sizeof(s->inode.tag)); datalen = SD_INODE_SIZE - sizeof(s->inode.data_vdi_id); fd = connect_to_sdog(s->addr, s->port); if (fd < 0) { ret = fd; goto cleanup; } ret = write_object(fd, (char *)&s->inode, vid_to_vdi_oid(s->inode.vdi_id), s->inode.nr_copies, datalen, 0, "[[Fictitious]]" != "[[Fictitious]]", s->cache_enabled); if (ret < 0) { error_report("failed to write snapshot's inode."); goto cleanup; } ret = do_sd_create(s->name, s->inode.vdi_size, s->inode.vdi_id, &new_vid, 1, s->addr, s->port); if (ret < 0) { error_report("failed to create inode for snapshot. %s", strerror(errno)); goto cleanup; } inode = (SheepdogInode *)g_malloc(datalen); ret = read_object(fd, (char *)inode, vid_to_vdi_oid(new_vid), s->inode.nr_copies, datalen, 0, s->cache_enabled); if (ret < 0) { error_report("failed to read new inode info. %s", strerror(errno)); goto cleanup; } memcpy(&s->inode, inode, datalen); dprintf("s->inode: name %s snap_id %x oid %x\n", s->inode.name, s->inode.snap_id, s->inode.vdi_id); cleanup: closesocket(fd); return ret; }
--------------------------------------------- Result 166 ---------------------------------------------
[[0 (46%)]] --> [[0 (59%)]] --> Socre: 0.5934333205223083

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **saddr, size_t nsaddr, SocketAddress **[[wsaddr]], size_t nwsaddr, Error **errp) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr(vd, saddr[i], "vnc-listen", &vd->lsock, &vd->lsock_tag, &vd->nlsock, errp) < 0) { return -1; } } for (i = 0; i < nwsaddr; i++) { if (vnc_display_listen_addr(vd, [[wsaddr]][i], "vnc-ws-listen", &vd->lwebsock, &vd->lwebsock_tag, &vd->nlwebsock, errp) < 0) { return -1; } } return 0; }

[[[[Adv]]]]: static int vnc_display_listen(VncDisplay *vd, SocketAddress **saddr, size_t nsaddr, SocketAddress **[[abdominal]], size_t nwsaddr, Error **errp) { size_t i; for (i = 0; i < nsaddr; i++) { if (vnc_display_listen_addr(vd, saddr[i], "vnc-listen", &vd->lsock, &vd->lsock_tag, &vd->nlsock, errp) < 0) { return -1; } } for (i = 0; i < nwsaddr; i++) { if (vnc_display_listen_addr(vd, [[abdominal]][i], "vnc-ws-listen", &vd->lwebsock, &vd->lwebsock_tag, &vd->nlwebsock, errp) < 0) { return -1; } } return 0; }
--------------------------------------------- Result 167 ---------------------------------------------
[[0 (44%)]] --> [[0 (50%)]] --> Socre: 0.5029364228248596

[[[[Adv]]]]: int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *open_inputs, AVFilterInOut *open_outputs, AVClass *log_ctx) { int [[index]] = 0, ret; char chr = 0; AVFilterInOut *[[curr_inputs]] = NULL; do { AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parse_inputs(&filters, &[[curr_inputs]], &open_outputs, log_ctx)) < 0) goto fail; if ((ret = parse_filter(&filter, &filters, graph, [[index]], log_ctx)) < 0) goto fail; if (filter->input_count == 1 && ![[curr_inputs]] && ![[index]]) { const char *tmp = "[in]"; if ((ret = parse_inputs(&tmp, &[[curr_inputs]], &open_outputs, log_ctx)) < 0) goto fail; } if ((ret = link_filter_inouts(filter, &[[curr_inputs]], &open_inputs, log_ctx)) < 0) goto fail; if ((ret = parse_outputs(&filters, &[[curr_inputs]], &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && [[curr_inputs]]) { av_log(log_ctx, AV_LOG_ERROR, "Could not find a output to link when parsing \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } [[index]]++; } while (chr == ',' || chr == ';'); if (chr) { av_log(log_ctx, AV_LOG_ERROR, "Unable to parse graph description substring: \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } if (open_inputs && !strcmp(open_inputs->name, "out") && [[curr_inputs]]) { const char *tmp = "[out]"; if ((ret = parse_outputs(&tmp, &[[curr_inputs]], &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; } return 0; fail: avfilter_graph_free(graph); free_inout(open_inputs); free_inout(open_outputs); free_inout([[curr_inputs]]); return ret; }

[[[[Adv]]]]: int avfilter_graph_parse(AVFilterGraph *graph, const char *filters, AVFilterInOut *open_inputs, AVFilterInOut *open_outputs, AVClass *log_ctx) { int [[yearbook]] = 0, ret; char chr = 0; AVFilterInOut *[[illusion]] = NULL; do { AVFilterContext *filter; filters += strspn(filters, WHITESPACES); if ((ret = parse_inputs(&filters, &[[illusion]], &open_outputs, log_ctx)) < 0) goto fail; if ((ret = parse_filter(&filter, &filters, graph, [[yearbook]], log_ctx)) < 0) goto fail; if (filter->input_count == 1 && ![[illusion]] && ![[yearbook]]) { const char *tmp = "[in]"; if ((ret = parse_inputs(&tmp, &[[illusion]], &open_outputs, log_ctx)) < 0) goto fail; } if ((ret = link_filter_inouts(filter, &[[illusion]], &open_inputs, log_ctx)) < 0) goto fail; if ((ret = parse_outputs(&filters, &[[illusion]], &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; filters += strspn(filters, WHITESPACES); chr = *filters++; if (chr == ';' && [[illusion]]) { av_log(log_ctx, AV_LOG_ERROR, "Could not find a output to link when parsing \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } [[yearbook]]++; } while (chr == ',' || chr == ';'); if (chr) { av_log(log_ctx, AV_LOG_ERROR, "Unable to parse graph description substring: \"%s\"\n", filters - 1); ret = AVERROR(EINVAL); goto fail; } if (open_inputs && !strcmp(open_inputs->name, "out") && [[illusion]]) { const char *tmp = "[out]"; if ((ret = parse_outputs(&tmp, &[[illusion]], &open_inputs, &open_outputs, log_ctx)) < 0) goto fail; } return 0; fail: avfilter_graph_free(graph); free_inout(open_inputs); free_inout(open_outputs); free_inout([[illusion]]); return ret; }
[Succeeded / Failed / Skipped / Total] 66 / 21 / 80 / 167:   6%|         | 167/2690 [01:09<17:26,  2.41it/s][Succeeded / Failed / Skipped / Total] 67 / 21 / 80 / 168:   6%|         | 168/2690 [01:09<17:19,  2.43it/s][Succeeded / Failed / Skipped / Total] 67 / 21 / 81 / 169:   6%|         | 169/2690 [01:09<17:16,  2.43it/s][Succeeded / Failed / Skipped / Total] 67 / 21 / 82 / 170:   6%|         | 170/2690 [01:09<17:11,  2.44it/s][Succeeded / Failed / Skipped / Total] 68 / 21 / 82 / 171:   6%|         | 171/2690 [01:09<17:04,  2.46it/s]--------------------------------------------- Result 168 ---------------------------------------------
[[0 (27%)]] --> [[0 (55%)]] --> Socre: 0.5451692342758179

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int [[max_cpus]]) { int [[cpu]]; bool [[first]] = "True" == "True"; GString *s = g_string_new(NULL); for ([[cpu]] = find_first_bit(cpus, [[max_cpus]]); [[cpu]] < [[max_cpus]]; [[cpu]] = find_next_bit(cpus, [[max_cpus]], [[cpu]] + 1)) { g_string_append_printf(s, "%s%d", [[first]] ? "" : " ", [[cpu]]); [[first]] = "False" != "False"; } return g_string_free(s, "False" != "False"); }

[[[[Adv]]]]: static char *enumerate_cpus(unsigned long *cpus, int [[corduroy]]) { int [[socs]]; bool [[commencing]] = "True" == "True"; GString *s = g_string_new(NULL); for ([[socs]] = find_first_bit(cpus, [[corduroy]]); [[socs]] < [[corduroy]]; [[socs]] = find_next_bit(cpus, [[corduroy]], [[socs]] + 1)) { g_string_append_printf(s, "%s%d", [[commencing]] ? "" : " ", [[socs]]); [[commencing]] = "False" != "False"; } return g_string_free(s, "False" != "False"); }
--------------------------------------------- Result 169 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int check_checksum(ByteIOContext *bc){ unsigned long checksum= get_checksum(bc); av_log(NULL, AV_LOG_ERROR, "%08X %08X\n", checksum, (int)get_be32(bc)); return 0; }
--------------------------------------------- Result 170 ---------------------------------------------
[[0 (26%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int aio_write_f(BlockBackend *blk, int argc, char **argv) { int nr_iov, c; int pattern = 0xcd; struct aio_ctx *ctx = g_new0(struct aio_ctx, 1); ctx->blk = blk; while ((c = getopt(argc, argv, "CqP:z")) != -1) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = parse_pattern(optarg); if (pattern < 0) { return 0; } break; case 'z': ctx->zflag = 1; break; default: return qemuio_command_usage(&aio_write_cmd); } } if (optind > argc - 2) { return qemuio_command_usage(&aio_write_cmd); } if (ctx->zflag && optind != argc - 2) { printf("-z supports only a single length parameter\n"); return 0; } if (ctx->zflag && ctx->Pflag) { printf("-z and -P cannot be specified at the same time\n"); return 0; } ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { print_cvtnum_err(ctx->offset, argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %" PRId64 " is not sector aligned\n", ctx->offset); block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE); return 0; } if (ctx->zflag) { int64_t count = cvtnum(argv[optind]); if (count < 0) { print_cvtnum_err(count, argv[optind]); return 0; } ctx->qiov.size = count; blk_aio_write_zeroes(blk, ctx->offset >> 9, count >> 9, 0, aio_write_done, ctx); } else { nr_iov = argc - optind; ctx->buf = create_iovec(blk, &ctx->qiov, &argv[optind], nr_iov, pattern); if (ctx->buf == NULL) { block_acct_invalid(blk_get_stats(blk), BLOCK_ACCT_WRITE); return 0; } gettimeofday(&ctx->t1, NULL); block_acct_start(blk_get_stats(blk), &ctx->acct, ctx->qiov.size, BLOCK_ACCT_WRITE); blk_aio_writev(blk, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); } return 0; }
--------------------------------------------- Result 171 ---------------------------------------------
[[0 (32%)]] --> [[0 (54%)]] --> Socre: 0.5391895174980164

[[[[Adv]]]]: static int virtio_net_device_exit(DeviceState *qdev) { VirtIONet *n = VIRTIO_NET(qdev); VirtIODevice *[[vdev]] = VIRTIO_DEVICE(qdev); int [[i]]; virtio_net_set_status([[vdev]], 0); unregister_savevm(qdev, "virtio-net", n); if (n->netclient_name) { g_free(n->netclient_name); n->netclient_name = NULL; } if (n->netclient_type) { g_free(n->netclient_type); n->netclient_type = NULL; } g_free(n->mac_table.macs); g_free(n->vlans); for ([[i]] = 0; [[i]] < n->max_queues; [[i]]++) { VirtIONetQueue *[[q]] = &n->vqs[[[i]]]; NetClientState *nc = qemu_get_subqueue(n->nic, [[i]]); qemu_purge_queued_packets(nc); if ([[q]]->tx_timer) { timer_del([[q]]->tx_timer); timer_free([[q]]->tx_timer); } else { qemu_bh_delete([[q]]->tx_bh); } } g_free(n->vqs); qemu_del_nic(n->nic); virtio_cleanup([[vdev]]); return 0; }

[[[[Adv]]]]: static int virtio_net_device_exit(DeviceState *qdev) { VirtIONet *n = VIRTIO_NET(qdev); VirtIODevice *[[snowsuit]] = VIRTIO_DEVICE(qdev); int [[ja]]; virtio_net_set_status([[snowsuit]], 0); unregister_savevm(qdev, "virtio-net", n); if (n->netclient_name) { g_free(n->netclient_name); n->netclient_name = NULL; } if (n->netclient_type) { g_free(n->netclient_type); n->netclient_type = NULL; } g_free(n->mac_table.macs); g_free(n->vlans); for ([[ja]] = 0; [[ja]] < n->max_queues; [[ja]]++) { VirtIONetQueue *[[asked]] = &n->vqs[[[ja]]]; NetClientState *nc = qemu_get_subqueue(n->nic, [[ja]]); qemu_purge_queued_packets(nc); if ([[asked]]->tx_timer) { timer_del([[asked]]->tx_timer); timer_free([[asked]]->tx_timer); } else { qemu_bh_delete([[asked]]->tx_bh); } } g_free(n->vqs); qemu_del_nic(n->nic); virtio_cleanup([[snowsuit]]); return 0; }
--------------------------------------------- Result 172 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 68 / 21 / 83 / 172:   6%|         | 172/2690 [01:09<16:58,  2.47it/s][Succeeded / Failed / Skipped / Total] 69 / 21 / 83 / 173:   6%|         | 173/2690 [01:09<16:51,  2.49it/s][[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int alloc_refcount_block(BlockDriverState *bs, int64_t cluster_index, uint16_t **refcount_block) { BDRVQcowState *s = bs->opaque; unsigned int refcount_table_index; int ret; BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC); refcount_table_index = cluster_index >> s->refcount_block_bits; if (refcount_table_index < s->refcount_table_size) { uint64_t refcount_block_offset = s->refcount_table[refcount_table_index] & REFT_OFFSET_MASK; if (refcount_block_offset) { if (offset_into_cluster(s, refcount_block_offset)) { qcow2_signal_corruption(bs, "True" == "True", -1, -1, "Refblock offset %#" PRIx64 " unaligned (reftable index: " "%#x)", refcount_block_offset, refcount_table_index); return -EIO; } return load_refcount_block(bs, refcount_block_offset, (void**) refcount_block); } } *refcount_block = NULL; ret = qcow2_cache_flush(bs, s->l2_table_cache); if (ret < 0) { return ret; } int64_t new_block = alloc_clusters_noref(bs, s->cluster_size); if (new_block < 0) { return new_block; } #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Allocate refcount block %d for %" PRIx64 " at %" PRIx64 "\n", refcount_table_index, cluster_index << s->cluster_bits, new_block); #endif if (in_same_refcount_block(s, new_block, cluster_index << s->cluster_bits)) { ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); int block_index = (new_block >> s->cluster_bits) & (s->refcount_block_size - 1); (*refcount_block)[block_index] = cpu_to_be16(1); } else { ret = update_refcount(bs, new_block, s->cluster_size, 1, "False" != "False", QCOW2_DISCARD_NEVER); if (ret < 0) { goto fail_block; } ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } ret = qcow2_cache_get_empty(bs, s->refcount_block_cache, new_block, (void**) refcount_block); if (ret < 0) { goto fail_block; } memset(*refcount_block, 0, s->cluster_size); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE); qcow2_cache_entry_mark_dirty(s->refcount_block_cache, *refcount_block); ret = qcow2_cache_flush(bs, s->refcount_block_cache); if (ret < 0) { goto fail_block; } if (refcount_table_index < s->refcount_table_size) { uint64_t data64 = cpu_to_be64(new_block); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_HOOKUP); ret = bdrv_pwrite_sync(bs->file, s->refcount_table_offset + refcount_table_index * sizeof(uint64_t), &data64, sizeof(data64)); if (ret < 0) { goto fail_block; } s->refcount_table[refcount_table_index] = new_block; return -EAGAIN; } ret = qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); if (ret < 0) { goto fail_block; } BLKDBG_EVENT(bs->file, BLKDBG_REFTABLE_GROW); uint64_t blocks_used = DIV_ROUND_UP(cluster_index, s->refcount_block_size); if (blocks_used > QCOW_MAX_REFTABLE_SIZE / sizeof(uint64_t)) { return -EFBIG; } uint64_t table_size = next_refcount_table_size(s, blocks_used + 1); uint64_t last_table_size; uint64_t blocks_clusters; do { uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); blocks_clusters = 1 + ((table_clusters + s->refcount_block_size - 1) / s->refcount_block_size); uint64_t meta_clusters = table_clusters + blocks_clusters; last_table_size = table_size; table_size = next_refcount_table_size(s, blocks_used + ((meta_clusters + s->refcount_block_size - 1) / s->refcount_block_size)); } while (last_table_size != table_size); #ifdef DEBUG_ALLOC2 fprintf(stderr, "qcow2: Grow refcount table %" PRId32 " => %" PRId64 "\n", s->refcount_table_size, table_size); #endif uint64_t meta_offset = (blocks_used * s->refcount_block_size) * s->cluster_size; uint64_t table_offset = meta_offset + blocks_clusters * s->cluster_size; uint64_t *new_table = g_try_new0(uint64_t, table_size); uint16_t *new_blocks = g_try_malloc0(blocks_clusters * s->cluster_size); assert(table_size > 0 && blocks_clusters > 0); if (new_table == NULL || new_blocks == NULL) { ret = -ENOMEM; goto fail_table; } memcpy(new_table, s->refcount_table, s->refcount_table_size * sizeof(uint64_t)); new_table[refcount_table_index] = new_block; int i; for (i = 0; i < blocks_clusters; i++) { new_table[blocks_used + i] = meta_offset + (i * s->cluster_size); } uint64_t table_clusters = size_to_clusters(s, table_size * sizeof(uint64_t)); int block = 0; for (i = 0; i < table_clusters + blocks_clusters; i++) { new_blocks[block++] = cpu_to_be16(1); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_BLOCKS); ret = bdrv_pwrite_sync(bs->file, meta_offset, new_blocks, blocks_clusters * s->cluster_size); g_free(new_blocks); new_blocks = NULL; if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { cpu_to_be64s(&new_table[i]); } BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_WRITE_TABLE); ret = bdrv_pwrite_sync(bs->file, table_offset, new_table, table_size * sizeof(uint64_t)); if (ret < 0) { goto fail_table; } for(i = 0; i < table_size; i++) { be64_to_cpus(&new_table[i]); } uint8_t data[12]; cpu_to_be64w((uint64_t*)data, table_offset); cpu_to_be32w((uint32_t*)(data + 8), table_clusters); BLKDBG_EVENT(bs->file, BLKDBG_REFBLOCK_ALLOC_SWITCH_TABLE); ret = bdrv_pwrite_sync(bs->file, offsetof(QCowHeader, refcount_table_offset), data, sizeof(data)); if (ret < 0) { goto fail_table; } uint64_t old_table_offset = s->refcount_table_offset; uint64_t old_table_size = s->refcount_table_size; g_free(s->refcount_table); s->refcount_table = new_table; s->refcount_table_size = table_size; s->refcount_table_offset = table_offset; qcow2_free_clusters(bs, old_table_offset, old_table_size * sizeof(uint64_t), QCOW2_DISCARD_OTHER); ret = load_refcount_block(bs, new_block, (void**) refcount_block); if (ret < 0) { return ret; } return -EAGAIN; fail_table: g_free(new_blocks); g_free(new_table); fail_block: if (*refcount_block != NULL) { qcow2_cache_put(bs, s->refcount_block_cache, (void**) refcount_block); } return ret; }
--------------------------------------------- Result 173 ---------------------------------------------
[[0 (50%)]] --> [[0 (51%)]] --> Socre: 0.5066556930541992

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *[[s]]) { int [[ret]], fd; uint32_t vid; char *buf; dprintf("%" PRIx32 " is snapshot.\n", [[s]]->inode.vdi_id); buf = g_malloc(SD_INODE_SIZE); [[ret]] = do_sd_create([[s]]->name, [[s]]->inode.vdi_size, [[s]]->inode.vdi_id, &vid, 1, [[s]]->addr, [[s]]->port); if ([[ret]]) { goto out; } dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog([[s]]->addr, [[s]]->port); if (fd < 0) { error_report("failed to connect"); [[ret]] = fd; goto out; } [[ret]] = read_object(fd, buf, vid_to_vdi_oid(vid), [[s]]->inode.nr_copies, SD_INODE_SIZE, 0, [[s]]->cache_enabled); closesocket(fd); if ([[ret]] < 0) { goto out; } memcpy(&[[s]]->inode, buf, sizeof([[s]]->inode)); [[s]]->is_snapshot = "False" != "False"; [[ret]] = 0; dprintf("%" PRIx32 " was newly created.\n", [[s]]->inode.vdi_id); out: g_free(buf); return [[ret]]; }

[[[[Adv]]]]: static int sd_create_branch(BDRVSheepdogState *[[z]]) { int [[ded]], fd; uint32_t vid; char *buf; dprintf("%" PRIx32 " is snapshot.\n", [[z]]->inode.vdi_id); buf = g_malloc(SD_INODE_SIZE); [[ded]] = do_sd_create([[z]]->name, [[z]]->inode.vdi_size, [[z]]->inode.vdi_id, &vid, 1, [[z]]->addr, [[z]]->port); if ([[ded]]) { goto out; } dprintf("%" PRIx32 " is created.\n", vid); fd = connect_to_sdog([[z]]->addr, [[z]]->port); if (fd < 0) { error_report("failed to connect"); [[ded]] = fd; goto out; } [[ded]] = read_object(fd, buf, vid_to_vdi_oid(vid), [[z]]->inode.nr_copies, SD_INODE_SIZE, 0, [[z]]->cache_enabled); closesocket(fd); if ([[ded]] < 0) { goto out; } memcpy(&[[z]]->inode, buf, sizeof([[z]]->inode)); [[z]]->is_snapshot = "False" != "False"; [[ded]] = 0; dprintf("%" PRIx32 " was newly created.\n", [[z]]->inode.vdi_id); out: g_free(buf); return [[ded]]; }
--------------------------------------------- Result 174 ---------------------------------------------
[[0 (56%)]] --> [[0 (50%)]] --> Socre: 0.5012004673480988

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int input_buffer_size) { ALACContext *alac = avctx->priv_data; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wasted_bytes; int [[isnotcompressed]]; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || !input_buffer_size) return input_buffer_size; if (!alac->context_initialized) { if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) { av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return input_buffer_size; } if (alac_set_info(alac)) { av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return input_buffer_size; } alac->context_initialized = 1; } init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8); channels = get_bits(&alac->gb, 3) + 1; if (channels > MAX_CHANNELS) { av_log(avctx, AV_LOG_ERROR, "channels > %d not supported\n", MAX_CHANNELS); return input_buffer_size; } skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); hassize = get_bits1(&alac->gb); wasted_bytes = get_bits(&alac->gb, 2); [[isnotcompressed]] = get_bits1(&alac->gb); if (hassize) { outputsamples = get_bits_long(&alac->gb, 32); if(outputsamples > alac->setinfo_max_samples_per_frame){ av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame); return -1; } } else outputsamples = alac->setinfo_max_samples_per_frame; if(outputsamples > *outputsize / alac->bytespersample){ av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (![[isnotcompressed]]) { int16_t predictor_coef_table[channels][32]; int predictor_coef_num[channels]; int prediction_type[channels]; int prediction_quantitization[channels]; int ricemodifier[channels]; int i, chan; interlacing_shift = get_bits(&alac->gb, 8); interlacing_leftweight = get_bits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { prediction_type[chan] = get_bits(&alac->gb, 4); prediction_quantitization[chan] = get_bits(&alac->gb, 4); ricemodifier[chan] = get_bits(&alac->gb, 3); predictor_coef_num[chan] = get_bits(&alac->gb, 5); for (i = 0; i < predictor_coef_num[chan]; i++) predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16); } if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan < channels; chan++) { bastardized_rice_decompress(alac, alac->predicterror_buffer[chan], outputsamples, readsamplesize, alac->setinfo_rice_initialhistory, alac->setinfo_rice_kmodifier, ricemodifier[chan] * alac->setinfo_rice_historymult / 4, (1 << alac->setinfo_rice_kmodifier) - 1); if (prediction_type[chan] == 0) { predictor_decompress_fir_adapt(alac->predicterror_buffer[chan], alac->outputsamples_buffer[chan], outputsamples, readsamplesize, predictor_coef_table[chan], predictor_coef_num[chan], prediction_quantitization[chan]); } else { av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", prediction_type[chan]); } } } else { int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32_t audiobits; audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size); audiobits = extend_sign32(audiobits, alac->setinfo_sample_size); alac->outputsamples_buffer[chan][i] = audiobits; } interlacing_shift = 0; interlacing_leftweight = 0; } if (get_bits(&alac->gb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac->setinfo_sample_size) { case 16: if (channels == 2) { reconstruct_stereo_16(alac->outputsamples_buffer, (int16_t*)outbuffer, alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16_t sample = alac->outputsamples_buffer[0][i]; ((int16_t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac->setinfo_sample_size); break; default: break; } if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", input_buffer_size * 8 - get_bits_count(&alac->gb)); return input_buffer_size; }

[[[[Adv]]]]: static int alac_decode_frame(AVCodecContext *avctx, void *outbuffer, int *outputsize, const uint8_t *inbuffer, int input_buffer_size) { ALACContext *alac = avctx->priv_data; int channels; unsigned int outputsamples; int hassize; int readsamplesize; int wasted_bytes; int [[icy]]; uint8_t interlacing_shift; uint8_t interlacing_leftweight; if (!inbuffer || !input_buffer_size) return input_buffer_size; if (!alac->context_initialized) { if (alac->avctx->extradata_size != ALAC_EXTRADATA_SIZE) { av_log(avctx, AV_LOG_ERROR, "alac: expected %d extradata bytes\n", ALAC_EXTRADATA_SIZE); return input_buffer_size; } if (alac_set_info(alac)) { av_log(avctx, AV_LOG_ERROR, "alac: set_info failed\n"); return input_buffer_size; } alac->context_initialized = 1; } init_get_bits(&alac->gb, inbuffer, input_buffer_size * 8); channels = get_bits(&alac->gb, 3) + 1; if (channels > MAX_CHANNELS) { av_log(avctx, AV_LOG_ERROR, "channels > %d not supported\n", MAX_CHANNELS); return input_buffer_size; } skip_bits(&alac->gb, 4); skip_bits(&alac->gb, 12); hassize = get_bits1(&alac->gb); wasted_bytes = get_bits(&alac->gb, 2); [[icy]] = get_bits1(&alac->gb); if (hassize) { outputsamples = get_bits_long(&alac->gb, 32); if(outputsamples > alac->setinfo_max_samples_per_frame){ av_log(avctx, AV_LOG_ERROR, "outputsamples %d > %d\n", outputsamples, alac->setinfo_max_samples_per_frame); return -1; } } else outputsamples = alac->setinfo_max_samples_per_frame; if(outputsamples > *outputsize / alac->bytespersample){ av_log(avctx, AV_LOG_ERROR, "sample buffer too small\n"); return -1; } *outputsize = outputsamples * alac->bytespersample; readsamplesize = alac->setinfo_sample_size - (wasted_bytes * 8) + channels - 1; if (![[icy]]) { int16_t predictor_coef_table[channels][32]; int predictor_coef_num[channels]; int prediction_type[channels]; int prediction_quantitization[channels]; int ricemodifier[channels]; int i, chan; interlacing_shift = get_bits(&alac->gb, 8); interlacing_leftweight = get_bits(&alac->gb, 8); for (chan = 0; chan < channels; chan++) { prediction_type[chan] = get_bits(&alac->gb, 4); prediction_quantitization[chan] = get_bits(&alac->gb, 4); ricemodifier[chan] = get_bits(&alac->gb, 3); predictor_coef_num[chan] = get_bits(&alac->gb, 5); for (i = 0; i < predictor_coef_num[chan]; i++) predictor_coef_table[chan][i] = (int16_t)get_bits(&alac->gb, 16); } if (wasted_bytes) av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented, unhandling of wasted_bytes\n"); for (chan = 0; chan < channels; chan++) { bastardized_rice_decompress(alac, alac->predicterror_buffer[chan], outputsamples, readsamplesize, alac->setinfo_rice_initialhistory, alac->setinfo_rice_kmodifier, ricemodifier[chan] * alac->setinfo_rice_historymult / 4, (1 << alac->setinfo_rice_kmodifier) - 1); if (prediction_type[chan] == 0) { predictor_decompress_fir_adapt(alac->predicterror_buffer[chan], alac->outputsamples_buffer[chan], outputsamples, readsamplesize, predictor_coef_table[chan], predictor_coef_num[chan], prediction_quantitization[chan]); } else { av_log(avctx, AV_LOG_ERROR, "FIXME: unhandled prediction type: %i\n", prediction_type[chan]); } } } else { int i, chan; for (i = 0; i < outputsamples; i++) for (chan = 0; chan < channels; chan++) { int32_t audiobits; audiobits = get_bits_long(&alac->gb, alac->setinfo_sample_size); audiobits = extend_sign32(audiobits, alac->setinfo_sample_size); alac->outputsamples_buffer[chan][i] = audiobits; } interlacing_shift = 0; interlacing_leftweight = 0; } if (get_bits(&alac->gb, 3) != 7) av_log(avctx, AV_LOG_ERROR, "Error : Wrong End Of Frame\n"); switch(alac->setinfo_sample_size) { case 16: if (channels == 2) { reconstruct_stereo_16(alac->outputsamples_buffer, (int16_t*)outbuffer, alac->numchannels, outputsamples, interlacing_shift, interlacing_leftweight); } else { int i; for (i = 0; i < outputsamples; i++) { int16_t sample = alac->outputsamples_buffer[0][i]; ((int16_t*)outbuffer)[i * alac->numchannels] = sample; } } break; case 20: case 24: case 32: av_log(avctx, AV_LOG_ERROR, "FIXME: unimplemented sample size %i\n", alac->setinfo_sample_size); break; default: break; } if (input_buffer_size * 8 - get_bits_count(&alac->gb) > 8) av_log(avctx, AV_LOG_ERROR, "Error : %d bits left\n", input_buffer_size * 8 - get_bits_count(&alac->gb)); return input_buffer_size; }[Succeeded / Failed / Skipped / Total] 70 / 21 / 83 / 174:   6%|         | 174/2690 [01:09<16:45,  2.50it/s][Succeeded / Failed / Skipped / Total] 71 / 21 / 83 / 175:   7%|         | 175/2690 [01:09<16:39,  2.52it/s][Succeeded / Failed / Skipped / Total] 71 / 21 / 83 / 175:   7%|         | 176/2690 [01:09<16:33,  2.53it/s][Succeeded / Failed / Skipped / Total] 72 / 21 / 83 / 176:   7%|         | 176/2690 [01:09<16:33,  2.53it/s][Succeeded / Failed / Skipped / Total] 72 / 22 / 83 / 177:   7%|         | 177/2690 [01:09<16:27,  2.54it/s][Succeeded / Failed / Skipped / Total] 72 / 23 / 83 / 178:   7%|         | 178/2690 [01:09<16:21,  2.56it/s]
--------------------------------------------- Result 175 ---------------------------------------------
[[0 (86%)]] --> [[0 (46%)]] --> Socre: 0.54310742020607

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[dev]], Property *[[prop]], const char *[[str]]) { uint8_t *ptr = qdev_get_prop_ptr([[dev]], [[prop]]); const char *fmt; fmt = strncasecmp([[str]], "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf([[str]], fmt, ptr) != 1) return -EINVAL; return 0; }

[[[[Adv]]]]: static int parse_uint8(DeviceState *[[joshi]], Property *[[appliance]], const char *[[dod]]) { uint8_t *ptr = qdev_get_prop_ptr([[joshi]], [[appliance]]); const char *fmt; fmt = strncasecmp([[dod]], "0x",2) == 0 ? "%" PRIx8 : "%" PRIu8; if (sscanf([[dod]], fmt, ptr) != 1) return -EINVAL; return 0; }
--------------------------------------------- Result 176 ---------------------------------------------
[[0 (41%)]] --> [[0 (50%)]] --> Socre: 0.5014826655387878

[[[[Adv]]]]: static int getopt(int argc, char *[[argv]][], char *opts) { static int sp = 1; int c; char *cp; if (sp == 1) if (optind >= argc || [[argv]][optind][0] != '-' || [[argv]][optind][1] == '\0') return EOF; else if (!strcmp([[argv]][optind], "--")) { optind++; return EOF; } optopt = c = [[argv]][optind][sp]; if (c == ':' || (cp = strchr(opts, c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if ([[argv]][optind][++sp] == '\0') { optind++; sp = 1; } return '?'; } if (*++cp == ':') { if ([[argv]][optind][sp+1] != '\0') optarg = &[[argv]][optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; } else optarg = [[argv]][optind++]; sp = 1; } else { if ([[argv]][optind][++sp] == '\0') { sp = 1; optind++; } optarg = NULL; } return c; }

[[[[Adv]]]]: static int getopt(int argc, char *[[maleficent]][], char *opts) { static int sp = 1; int c; char *cp; if (sp == 1) if (optind >= argc || [[maleficent]][optind][0] != '-' || [[maleficent]][optind][1] == '\0') return EOF; else if (!strcmp([[maleficent]][optind], "--")) { optind++; return EOF; } optopt = c = [[maleficent]][optind][sp]; if (c == ':' || (cp = strchr(opts, c)) == NULL) { fprintf(stderr, ": illegal option -- %c\n", c); if ([[maleficent]][optind][++sp] == '\0') { optind++; sp = 1; } return '?'; } if (*++cp == ':') { if ([[maleficent]][optind][sp+1] != '\0') optarg = &[[maleficent]][optind++][sp+1]; else if(++optind >= argc) { fprintf(stderr, ": option requires an argument -- %c\n", c); sp = 1; return '?'; } else optarg = [[maleficent]][optind++]; sp = 1; } else { if ([[maleficent]][optind][++sp] == '\0') { sp = 1; optind++; } optarg = NULL; } return c; }
--------------------------------------------- Result 177 ---------------------------------------------
[[0 (21%)]] --> [[[FAILED]]]

[[[[Adv]]]]: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp) { MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp); if (memory_region_is_mapped(mr)) { return "False" != "False"; } else { return "True" == "True"; } }

[[[[Adv]]]]: host_memory_backend_can_be_deleted(UserCreatable *uc, Error **errp) { MemoryRegion *mr; mr = host_memory_backend_get_memory(MEMORY_BACKEND(uc), errp); if (memory_region_is_mapped(mr)) { return "False" != "False"; } else { return "True" == "True"; } }
--------------------------------------------- Result 178 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val) { SLAVIO_TIMERState *s = opaque; uint32_t saddr; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, val); saddr = (addr & TIMER_MAXADDR) >> 2; switch (saddr) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; } }

[[[[Adv]]]]: static void slavio_timer_mem_writel(void *opaque, target_phys_addr_t addr, uint32_t val) { SLAVIO_TIMERState *s = opaque; uint32_t saddr; int reload = 0; DPRINTF("write " TARGET_FMT_plx " %08x\n", addr, val); saddr = (addr & TIMER_MAXADDR) >> 2; switch (saddr) { case TIMER_LIMIT: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else { qemu_irq_lower(s->irq); s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, s->limit >> 9, 1); } break; case TIMER_COUNTER: if (slavio_timer_is_user(s)) { qemu_irq_lower(s->irq); s->limit = TIMER_MAX_COUNT64; DPRINTF("processor %d user timer reset\n", s->slave_index); ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), 1); } else DPRINTF("not user timer\n"); break; case TIMER_COUNTER_NORST: s->limit = val & TIMER_MAX_COUNT32; if (!s->limit) s->limit = TIMER_MAX_COUNT32; ptimer_set_limit(s->timer, LIMIT_TO_PERIODS(s->limit), reload); break; case TIMER_STATUS: if (slavio_timer_is_user(s)) { if ((val & 1) && !s->running) { DPRINTF("processor %d user timer started\n", s->slave_index); ptimer_run(s->timer, 0); s->running = 1; } else if (!(val & 1) && s->running) { DPRINTF("processor %d user timer stopped\n", s->slave_index); ptimer_stop(s->timer); s->running = 0; } } break; case TIMER_MODE: if (s->master == NULL) { unsigned int i; for (i = 0; i < s->num_slaves; i++) { if (val & (1 << i)) { qemu_irq_lower(s->slave[i]->irq); s->slave[i]->limit = -1ULL; } if ((val & (1 << i)) != (s->slave_mode & (1 << i))) { ptimer_stop(s->slave[i]->timer); ptimer_set_limit(s->slave[i]->timer, LIMIT_TO_PERIODS(s->slave[i]->limit), 1); DPRINTF("processor %d timer changed\n", s->slave[i]->slave_index); ptimer_run(s->slave[i]->timer, 0); } } s->slave_mode = val & ((1 << s->num_slaves) - 1); } else DPRINTF("not system timer\n"); break; default: DPRINTF("invalid write address " TARGET_FMT_plx "\n", addr); break; } }
--------------------------------------------- Result 179 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 72 / 23 / 84 / 179:   7%|         | 179/2690 [01:09<16:15,  2.57it/s][Succeeded / Failed / Skipped / Total] 72 / 23 / 85 / 180:   7%|         | 180/2690 [01:09<16:09,  2.59it/s][Succeeded / Failed / Skipped / Total] 72 / 23 / 86 / 181:   7%|         | 181/2690 [01:09<16:04,  2.60it/s][Succeeded / Failed / Skipped / Total] 73 / 23 / 86 / 182:   7%|         | 182/2690 [01:09<15:58,  2.62it/s][[0 (56%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void predictor_decode_mono(APEContext *ctx, int count) { APEPredictor *p = &ctx->predictor; int32_t *decoded0 = ctx->decoded[0]; int32_t predictionA, currentA, A, sign; currentA = p->lastA[0]; while (count--) { A = *decoded0; p->buf[YDELAYA] = currentA; p->buf[YDELAYA - 1] = p->buf[YDELAYA] - p->buf[YDELAYA - 1]; predictionA = p->buf[YDELAYA ] * p->coeffsA[0][0] + p->buf[YDELAYA - 1] * p->coeffsA[0][1] + p->buf[YDELAYA - 2] * p->coeffsA[0][2] + p->buf[YDELAYA - 3] * p->coeffsA[0][3]; currentA = A + (predictionA >> 10); p->buf[YADAPTCOEFFSA] = APESIGN(p->buf[YDELAYA ]); p->buf[YADAPTCOEFFSA - 1] = APESIGN(p->buf[YDELAYA - 1]); sign = APESIGN(A); p->coeffsA[0][0] += p->buf[YADAPTCOEFFSA ] * sign; p->coeffsA[0][1] += p->buf[YADAPTCOEFFSA - 1] * sign; p->coeffsA[0][2] += p->buf[YADAPTCOEFFSA - 2] * sign; p->coeffsA[0][3] += p->buf[YADAPTCOEFFSA - 3] * sign; p->buf++; if (p->buf == p->historybuffer + HISTORY_SIZE) { memmove(p->historybuffer, p->buf, PREDICTOR_SIZE * sizeof(*p->historybuffer)); p->buf = p->historybuffer; } p->filterA[0] = currentA + ((p->filterA[0] * 31) >> 5); *(decoded0++) = p->filterA[0]; } p->lastA[0] = currentA; }
--------------------------------------------- Result 180 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline int *DEC_UQUAD(int *dst, unsigned idx, unsigned sign) { unsigned nz = idx >> 12; dst[0] = (idx & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[1] = (idx >> 2 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[2] = (idx >> 4 & 3) * (1 + (((int)sign >> 31) << 1)); sign <<= nz & 1; nz >>= 1; dst[3] = (idx >> 6 & 3) * (1 + (((int)sign >> 31) << 1)); return dst + 4; }
--------------------------------------------- Result 181 ---------------------------------------------
[[0 (15%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void hmp_info_block_jobs(Monitor *mon, const QDict *qdict) { BlockJobInfoList *list; Error *err = NULL; list = qmp_query_block_jobs(&err); assert(!err); if (!list) { monitor_printf(mon, "No active jobs\n"); return; } while (list) { if (strcmp(list->value->type, "stream") == 0) { monitor_printf(mon, "Streaming device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->device, list->value->offset, list->value->len, list->value->speed); } else { monitor_printf(mon, "Type %s, device %s: Completed %" PRId64 " of %" PRId64 " bytes, speed limit %" PRId64 " bytes/s\n", list->value->type, list->value->device, list->value->offset, list->value->len, list->value->speed); } list = list->next; } }
--------------------------------------------- Result 182 ---------------------------------------------
[[0 (47%)]] --> [[0 (52%)]] --> Socre: 0.516369640827179

[[[[Adv]]]]: static void print_report(AVFormatContext **output_files, AVOutputStream **ost_table, int nb_ostreams, int is_last_report) { char buf[1024]; AVOutputStream *ost; AVFormatContext *[[oc]]; int64_t total_size; AVCodecContext *enc; int frame_number, vid, i; double bitrate, ti1, pts; static int64_t last_time = -1; static int qp_histogram[52]; if (!is_last_report) { int64_t cur_time; cur_time = av_gettime(); if (last_time == -1) { last_time = cur_time; return; } if ((cur_time - last_time) < 500000) return; last_time = cur_time; } [[oc]] = output_files[0]; total_size = avio_size([[oc]]->pb); if(total_size<0) total_size= avio_tell([[oc]]->pb); buf[0] = '\0'; ti1 = 1e10; vid = 0; for(i=0;i<nb_ostreams;i++) { float q= -1; ost = ost_table[i]; enc = ost->st->codec; if(!ost->st->stream_copy && enc->coded_frame) q= enc->coded_frame->quality/(float)FF_QP2LAMBDA; if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q); } if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { float t = (av_gettime()-timer_start) / 1000000.0; frame_number = ost->frame_number; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q); if(is_last_report) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); if(qp_hist){ int [[j]]; int qp= lrintf(q); if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram)) qp_histogram[qp]++; for([[j]]=0; [[j]]<32; [[j]]++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[[[j]]]+1)/log(2))); } if (enc->flags&CODEC_FLAG_PSNR){ int [[j]]; double error, error_sum=0; double scale, scale_sum=0; char type[3]= {'Y','U','V'}; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR="); for([[j]]=0; [[j]]<3; [[j]]++){ if(is_last_report){ error= enc->error[[[j]]]; scale= enc->width*enc->height*255.0*255.0*frame_number; }else{ error= enc->coded_frame->error[[[j]]]; scale= enc->width*enc->height*255.0*255.0; } if([[j]]) scale/=4; error_sum += error; scale_sum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[[[j]]], psnr(error/scale)); } snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum)); } vid = 1; } pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base); if ((pts < ti1) && (pts > 0)) ti1 = pts; } if (ti1 < 0.01) ti1 = 0.01; if (verbose || is_last_report) { bitrate = (double)(total_size * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s", (double)total_size / 1024, ti1, bitrate); if (nb_frames_dup || nb_frames_drop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d", nb_frames_dup, nb_frames_drop); if (verbose >= 0) fprintf(stderr, "%s \r", buf); fflush(stderr); } if (is_last_report && verbose >= 0){ int64_t raw= audio_size + video_size + extra_size; fprintf(stderr, "\n"); fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n", video_size/1024.0, audio_size/1024.0, extra_size/1024.0, 100.0*(total_size - raw)/raw ); } }

[[[[Adv]]]]: static void print_report(AVFormatContext **output_files, AVOutputStream **ost_table, int nb_ostreams, int is_last_report) { char buf[1024]; AVOutputStream *ost; AVFormatContext *[[orca]]; int64_t total_size; AVCodecContext *enc; int frame_number, vid, i; double bitrate, ti1, pts; static int64_t last_time = -1; static int qp_histogram[52]; if (!is_last_report) { int64_t cur_time; cur_time = av_gettime(); if (last_time == -1) { last_time = cur_time; return; } if ((cur_time - last_time) < 500000) return; last_time = cur_time; } [[orca]] = output_files[0]; total_size = avio_size([[orca]]->pb); if(total_size<0) total_size= avio_tell([[orca]]->pb); buf[0] = '\0'; ti1 = 1e10; vid = 0; for(i=0;i<nb_ostreams;i++) { float q= -1; ost = ost_table[i]; enc = ost->st->codec; if(!ost->st->stream_copy && enc->coded_frame) q= enc->coded_frame->quality/(float)FF_QP2LAMBDA; if (vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "q=%2.1f ", q); } if (!vid && enc->codec_type == AVMEDIA_TYPE_VIDEO) { float t = (av_gettime()-timer_start) / 1000000.0; frame_number = ost->frame_number; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "frame=%5d fps=%3d q=%3.1f ", frame_number, (t>1)?(int)(frame_number/t+0.5) : 0, q); if(is_last_report) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "L"); if(qp_hist){ int [[q]]; int qp= lrintf(q); if(qp>=0 && qp<FF_ARRAY_ELEMS(qp_histogram)) qp_histogram[qp]++; for([[q]]=0; [[q]]<32; [[q]]++) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%X", (int)lrintf(log(qp_histogram[[[q]]]+1)/log(2))); } if (enc->flags&CODEC_FLAG_PSNR){ int [[q]]; double error, error_sum=0; double scale, scale_sum=0; char type[3]= {'Y','U','V'}; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "PSNR="); for([[q]]=0; [[q]]<3; [[q]]++){ if(is_last_report){ error= enc->error[[[q]]]; scale= enc->width*enc->height*255.0*255.0*frame_number; }else{ error= enc->coded_frame->error[[[q]]]; scale= enc->width*enc->height*255.0*255.0; } if([[q]]) scale/=4; error_sum += error; scale_sum += scale; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "%c:%2.2f ", type[[[q]]], psnr(error/scale)); } snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "*:%2.2f ", psnr(error_sum/scale_sum)); } vid = 1; } pts = (double)ost->st->pts.val * av_q2d(ost->st->time_base); if ((pts < ti1) && (pts > 0)) ti1 = pts; } if (ti1 < 0.01) ti1 = 0.01; if (verbose || is_last_report) { bitrate = (double)(total_size * 8) / ti1 / 1000.0; snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), "size=%8.0fkB time=%0.2f bitrate=%6.1fkbits/s", (double)total_size / 1024, ti1, bitrate); if (nb_frames_dup || nb_frames_drop) snprintf(buf + strlen(buf), sizeof(buf) - strlen(buf), " dup=%d drop=%d", nb_frames_dup, nb_frames_drop); if (verbose >= 0) fprintf(stderr, "%s \r", buf); fflush(stderr); } if (is_last_report && verbose >= 0){ int64_t raw= audio_size + video_size + extra_size; fprintf(stderr, "\n"); fprintf(stderr, "video:%1.0fkB audio:%1.0fkB global headers:%1.0fkB muxing overhead %f%%\n", video_size/1024.0, audio_size/1024.0, extra_size/1024.0, 100.0*(total_size - raw)/raw ); } }
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 23 / 87 / 183:   7%|         | 183/2690 [01:09<15:52,  2.63it/s][Succeeded / Failed / Skipped / Total] 74 / 23 / 87 / 184:   7%|         | 184/2690 [01:09<15:47,  2.65it/s][[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int atrim_filter_frame(AVFilterLink *inlink, AVFrame *frame) { AVFilterContext *ctx = inlink->dst; TrimContext *s = ctx->priv; int64_t start_sample, end_sample = frame->nb_samples; int64_t pts; int drop; if (s->eof) { av_frame_free(&frame); return 0; } if (frame->pts != AV_NOPTS_VALUE) pts = av_rescale_q(frame->pts, inlink->time_base, (AVRational){ 1, inlink->sample_rate }); else pts = s->next_pts; s->next_pts = pts + frame->nb_samples; if (s->start_sample < 0 && s->start_pts == AV_NOPTS_VALUE) { start_sample = 0; } else { drop = 1; start_sample = frame->nb_samples; if (s->start_sample >= 0 && s->nb_samples + frame->nb_samples > s->start_sample) { drop = 0; start_sample = FFMIN(start_sample, s->start_sample - s->nb_samples); } if (s->start_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts + frame->nb_samples > s->start_pts) { drop = 0; start_sample = FFMIN(start_sample, s->start_pts - pts); } if (drop) goto drop; } if (s->first_pts == AV_NOPTS_VALUE) s->first_pts = pts + start_sample; if (s->end_sample == INT64_MAX && s->end_pts == AV_NOPTS_VALUE && !s->duration_tb) { end_sample = frame->nb_samples; } else { drop = 1; end_sample = 0; if (s->end_sample != INT64_MAX && s->nb_samples < s->end_sample) { drop = 0; end_sample = FFMAX(end_sample, s->end_sample - s->nb_samples); } if (s->end_pts != AV_NOPTS_VALUE && pts != AV_NOPTS_VALUE && pts < s->end_pts) { drop = 0; end_sample = FFMAX(end_sample, s->end_pts - pts); } if (s->duration_tb && pts - s->first_pts < s->duration_tb) { drop = 0; end_sample = FFMAX(end_sample, s->first_pts + s->duration_tb - pts); } if (drop) { s->eof = 1; goto drop; } } s->nb_samples += frame->nb_samples; start_sample = FFMAX(0, start_sample); end_sample = FFMIN(frame->nb_samples, end_sample); av_assert0(start_sample < end_sample); if (start_sample) { AVFrame *out = ff_get_audio_buffer(ctx->outputs[0], end_sample - start_sample); if (!out) { av_frame_free(&frame); return AVERROR(ENOMEM); } av_frame_copy_props(out, frame); av_samples_copy(out->extended_data, frame->extended_data, 0, start_sample, out->nb_samples, av_get_channel_layout_nb_channels(frame->channel_layout), frame->format); if (out->pts != AV_NOPTS_VALUE) out->pts += av_rescale_q(start_sample, (AVRational){ 1, out->sample_rate }, inlink->time_base); av_frame_free(&frame); frame = out; } else frame->nb_samples = end_sample; s->got_output = 1; return ff_filter_frame(ctx->outputs[0], frame); drop: s->nb_samples += frame->nb_samples; av_frame_free(&frame); return 0; }
--------------------------------------------- Result 184 ---------------------------------------------
[[0 (51%)]] --> [[0 (47%)]] --> Socre: 0.5343621075153351

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *[[src]], const int step, const int stride, const int alpha, const int [[lims]], const int dmode, const int chroma) { int i; for(i = 0; i < 4; i++, [[src]] += stride){ int [[sflag]], p0, q0, p1, q1; int t = [[src]][0*step] - [[src]][-1*step]; if (!t) continue; [[sflag]] = (alpha * FFABS(t)) >> 7; if ([[sflag]] > 1) continue; p0 = (25*[[src]][-3*step] + 26*[[src]][-2*step] + 26*[[src]][-1*step] + 26*[[src]][ 0*step] + 25*[[src]][ 1*step] + rv40_dither_l[dmode + i]) >> 7; q0 = (25*[[src]][-2*step] + 26*[[src]][-1*step] + 26*[[src]][ 0*step] + 26*[[src]][ 1*step] + 25*[[src]][ 2*step] + rv40_dither_r[dmode + i]) >> 7; if ([[sflag]]) { p0 = av_clip(p0, [[src]][-1*step] - [[lims]], [[src]][-1*step] + [[lims]]); q0 = av_clip(q0, [[src]][ 0*step] - [[lims]], [[src]][ 0*step] + [[lims]]); } p1 = (25*[[src]][-4*step] + 26*[[src]][-3*step] + 26*[[src]][-2*step] + 26*p0 + 25*[[src]][ 0*step] + rv40_dither_l[dmode + i]) >> 7; q1 = (25*[[src]][-1*step] + 26*q0 + 26*[[src]][ 1*step] + 26*[[src]][ 2*step] + 25*[[src]][ 3*step] + rv40_dither_r[dmode + i]) >> 7; if ([[sflag]]) { p1 = av_clip(p1, [[src]][-2*step] - [[lims]], [[src]][-2*step] + [[lims]]); q1 = av_clip(q1, [[src]][ 1*step] - [[lims]], [[src]][ 1*step] + [[lims]]); } [[src]][-2*step] = p1; [[src]][-1*step] = p0; [[src]][ 0*step] = q0; [[src]][ 1*step] = q1; if(!chroma){ [[src]][-3*step] = (25*[[src]][-1*step] + 26*[[src]][-2*step] + 51*[[src]][-3*step] + 26*[[src]][-4*step] + 64) >> 7; [[src]][ 2*step] = (25*[[src]][ 0*step] + 26*[[src]][ 1*step] + 51*[[src]][ 2*step] + 26*[[src]][ 3*step] + 64) >> 7; } } }

[[[[Adv]]]]: static av_always_inline void rv40_strong_loop_filter(uint8_t *[[scummy]], const int step, const int stride, const int alpha, const int [[guerin]], const int dmode, const int chroma) { int i; for(i = 0; i < 4; i++, [[scummy]] += stride){ int [[muito]], p0, q0, p1, q1; int t = [[scummy]][0*step] - [[scummy]][-1*step]; if (!t) continue; [[muito]] = (alpha * FFABS(t)) >> 7; if ([[muito]] > 1) continue; p0 = (25*[[scummy]][-3*step] + 26*[[scummy]][-2*step] + 26*[[scummy]][-1*step] + 26*[[scummy]][ 0*step] + 25*[[scummy]][ 1*step] + rv40_dither_l[dmode + i]) >> 7; q0 = (25*[[scummy]][-2*step] + 26*[[scummy]][-1*step] + 26*[[scummy]][ 0*step] + 26*[[scummy]][ 1*step] + 25*[[scummy]][ 2*step] + rv40_dither_r[dmode + i]) >> 7; if ([[muito]]) { p0 = av_clip(p0, [[scummy]][-1*step] - [[guerin]], [[scummy]][-1*step] + [[guerin]]); q0 = av_clip(q0, [[scummy]][ 0*step] - [[guerin]], [[scummy]][ 0*step] + [[guerin]]); } p1 = (25*[[scummy]][-4*step] + 26*[[scummy]][-3*step] + 26*[[scummy]][-2*step] + 26*p0 + 25*[[scummy]][ 0*step] + rv40_dither_l[dmode + i]) >> 7; q1 = (25*[[scummy]][-1*step] + 26*q0 + 26*[[scummy]][ 1*step] + 26*[[scummy]][ 2*step] + 25*[[scummy]][ 3*step] + rv40_dither_r[dmode + i]) >> 7; if ([[muito]]) { p1 = av_clip(p1, [[scummy]][-2*step] - [[guerin]], [[scummy]][-2*step] + [[guerin]]); q1 = av_clip(q1, [[scummy]][ 1*step] - [[guerin]], [[scummy]][ 1*step] + [[guerin]]); } [[scummy]][-2*step] = p1; [[scummy]][-1*step] = p0; [[scummy]][ 0*step] = q0; [[scummy]][ 1*step] = q1; if(!chroma){ [[scummy]][-3*step] = (25*[[scummy]][-1*step] + 26*[[scummy]][-2*step] + 51*[[scummy]][-3*step] + 26*[[scummy]][-4*step] + 64) >> 7; [[scummy]][ 2*step] = (25*[[scummy]][ 0*step] + 26*[[scummy]][ 1*step] + 51*[[scummy]][ 2*step] + 26*[[scummy]][ 3*step] + 64) >> 7; } } }
--------------------------------------------- Result 185 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 23 / 87 / 185:   7%|         | 185/2690 [01:09<15:41,  2.66it/s][[0 (20%)]] --> [[0 (52%)]] --> Socre: 0.5240011215209961

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int [[nb_oargs]], int [[nb_iargs]], const TCGArg * const args, uint16_t [[dead_args]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg reg; TCGArg arg; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *[[func_addr]]; int [[allocate_args]]; TCGRegSet allocated_regs; [[func_addr]] = (tcg_insn_unit *)(intptr_t)args[[[nb_oargs]] + [[nb_iargs]]]; flags = args[[[nb_oargs]] + [[nb_iargs]] + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > [[nb_iargs]]) { nb_regs = [[nb_iargs]]; } call_stack_size = ([[nb_iargs]] - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); [[allocate_args]] = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if ([[allocate_args]]) { tcg_abort(); } stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < [[nb_iargs]]; i++) { arg = args[[[nb_oargs]] + i]; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset); } #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif } tcg_regset_set(allocated_regs, s->reserved_regs); for(i = 0; i < nb_regs; i++) { arg = args[[[nb_oargs]] + i]; if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; reg = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, reg, allocated_regs); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, reg, ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); } tcg_regset_set_reg(allocated_regs, reg); } } for(i = [[nb_oargs]]; i < [[nb_iargs]] + [[nb_oargs]]; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, allocated_regs); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, allocated_regs); } else { save_globals(s, allocated_regs); } tcg_out_call(s, [[func_addr]]); for(i = 0; i < [[nb_oargs]]; i++) { arg = args[i]; ts = &s->temps[arg]; reg = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[reg] == NULL); if (ts->fixed_reg) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, ts->reg, reg); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = reg; ts->mem_coherent = 0; s->reg_to_temp[reg] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, reg, allocated_regs); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }

[[[[Adv]]]]: static void tcg_reg_alloc_call(TCGContext *s, int [[toc]], int [[carstairs]], const TCGArg * const args, uint16_t [[laissez]], uint8_t sync_args) { int flags, nb_regs, i; TCGReg reg; TCGArg arg; TCGTemp *ts; intptr_t stack_offset; size_t call_stack_size; tcg_insn_unit *[[cowen]]; int [[abolitionists]]; TCGRegSet allocated_regs; [[cowen]] = (tcg_insn_unit *)(intptr_t)args[[[toc]] + [[carstairs]]]; flags = args[[[toc]] + [[carstairs]] + 1]; nb_regs = ARRAY_SIZE(tcg_target_call_iarg_regs); if (nb_regs > [[carstairs]]) { nb_regs = [[carstairs]]; } call_stack_size = ([[carstairs]] - nb_regs) * sizeof(tcg_target_long); call_stack_size = (call_stack_size + TCG_TARGET_STACK_ALIGN - 1) & ~(TCG_TARGET_STACK_ALIGN - 1); [[abolitionists]] = (call_stack_size > TCG_STATIC_CALL_ARGS_SIZE); if ([[abolitionists]]) { tcg_abort(); } stack_offset = TCG_TARGET_CALL_STACK_OFFSET; for(i = nb_regs; i < [[carstairs]]; i++) { arg = args[[[toc]] + i]; #ifdef TCG_TARGET_STACK_GROWSUP stack_offset -= sizeof(tcg_target_long); #endif if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; temp_load(s, ts, tcg_target_available_regs[ts->type], s->reserved_regs); tcg_out_st(s, ts->type, ts->reg, TCG_REG_CALL_STACK, stack_offset); } #ifndef TCG_TARGET_STACK_GROWSUP stack_offset += sizeof(tcg_target_long); #endif } tcg_regset_set(allocated_regs, s->reserved_regs); for(i = 0; i < nb_regs; i++) { arg = args[[[toc]] + i]; if (arg != TCG_CALL_DUMMY_ARG) { ts = &s->temps[arg]; reg = tcg_target_call_iarg_regs[i]; tcg_reg_free(s, reg, allocated_regs); if (ts->val_type == TEMP_VAL_REG) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, reg, ts->reg); } } else { TCGRegSet arg_set; tcg_regset_clear(arg_set); tcg_regset_set_reg(arg_set, reg); temp_load(s, ts, arg_set, allocated_regs); } tcg_regset_set_reg(allocated_regs, reg); } } for(i = [[toc]]; i < [[carstairs]] + [[toc]]; i++) { if (IS_DEAD_ARG(i)) { temp_dead(s, &s->temps[args[i]]); } } for (i = 0; i < TCG_TARGET_NB_REGS; i++) { if (tcg_regset_test_reg(tcg_target_call_clobber_regs, i)) { tcg_reg_free(s, i, allocated_regs); } } if (flags & TCG_CALL_NO_READ_GLOBALS) { } else if (flags & TCG_CALL_NO_WRITE_GLOBALS) { sync_globals(s, allocated_regs); } else { save_globals(s, allocated_regs); } tcg_out_call(s, [[cowen]]); for(i = 0; i < [[toc]]; i++) { arg = args[i]; ts = &s->temps[arg]; reg = tcg_target_call_oarg_regs[i]; assert(s->reg_to_temp[reg] == NULL); if (ts->fixed_reg) { if (ts->reg != reg) { tcg_out_mov(s, ts->type, ts->reg, reg); } } else { if (ts->val_type == TEMP_VAL_REG) { s->reg_to_temp[ts->reg] = NULL; } ts->val_type = TEMP_VAL_REG; ts->reg = reg; ts->mem_coherent = 0; s->reg_to_temp[reg] = ts; if (NEED_SYNC_ARG(i)) { tcg_reg_sync(s, reg, allocated_regs); } if (IS_DEAD_ARG(i)) { temp_dead(s, ts); } } } }
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 23 / 87 / 186:   7%|         | 186/2690 [01:09<15:36,  2.67it/s][Succeeded / Failed / Skipped / Total] 77 / 23 / 87 / 187:   7%|         | 187/2690 [01:09<15:31,  2.69it/s][Succeeded / Failed / Skipped / Total] 77 / 23 / 87 / 187:   7%|         | 188/2690 [01:09<15:28,  2.69it/s][[0 (51%)]] --> [[0 (47%)]] --> Socre: 0.5295409858226776

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts, Error **[[errp]]) { DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { error_setg([[errp]], QERR_MISSING_PARAMETER, "driver"); return NULL; } dc = qdev_get_device_class(&driver, [[errp]]); if (!dc) { return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path, [[errp]]); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { error_setg([[errp]], "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus || qbus_is_full(bus)) { error_setg([[errp]], "No '%s' bus found for device '%s'", dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) { error_setg([[errp]], QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } if (!migration_is_idle()) { error_setg([[errp]], "device_add not allowed while migrating"); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } qdev_set_id(dev, qemu_opts_id(opts)); if (qemu_opt_foreach(opts, set_property, dev, &err)) { } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { dev->opts = NULL; } return dev; err_del_dev: error_propagate([[errp]], err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; }

[[[[Adv]]]]: DeviceState *qdev_device_add(QemuOpts *opts, Error **[[extension]]) { DeviceClass *dc; const char *driver, *path; DeviceState *dev; BusState *bus = NULL; Error *err = NULL; driver = qemu_opt_get(opts, "driver"); if (!driver) { error_setg([[extension]], QERR_MISSING_PARAMETER, "driver"); return NULL; } dc = qdev_get_device_class(&driver, [[extension]]); if (!dc) { return NULL; } path = qemu_opt_get(opts, "bus"); if (path != NULL) { bus = qbus_find(path, [[extension]]); if (!bus) { return NULL; } if (!object_dynamic_cast(OBJECT(bus), dc->bus_type)) { error_setg([[extension]], "Device '%s' can't go on %s bus", driver, object_get_typename(OBJECT(bus))); return NULL; } } else if (dc->bus_type != NULL) { bus = qbus_find_recursive(sysbus_get_default(), NULL, dc->bus_type); if (!bus || qbus_is_full(bus)) { error_setg([[extension]], "No '%s' bus found for device '%s'", dc->bus_type, driver); return NULL; } } if (qdev_hotplug && bus && !qbus_is_hotpluggable(bus)) { error_setg([[extension]], QERR_BUS_NO_HOTPLUG, bus->name); return NULL; } if (!migration_is_idle()) { error_setg([[extension]], "device_add not allowed while migrating"); return NULL; } dev = DEVICE(object_new(driver)); if (bus) { qdev_set_parent_bus(dev, bus); } qdev_set_id(dev, qemu_opts_id(opts)); if (qemu_opt_foreach(opts, set_property, dev, &err)) { } dev->opts = opts; object_property_set_bool(OBJECT(dev), "True" == "True", "realized", &err); if (err != NULL) { dev->opts = NULL; } return dev; err_del_dev: error_propagate([[extension]], err); object_unparent(OBJECT(dev)); object_unref(OBJECT(dev)); return NULL; }
--------------------------------------------- Result 187 ---------------------------------------------
[[0 (30%)]] --> [[0 (51%)]] --> Socre: 0.5105831623077393

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *[[blk]], IDEDriveKind kind, const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t [[secs]], int [[chs_trans]]) { uint64_t nb_sectors; s->blk = [[blk]]; s->drive_kind = kind; blk_get_geometry([[blk]], &nb_sectors); s->cylinders = cylinders; s->heads = heads; s->sectors = [[secs]]; s->chs_trans = [[chs_trans]]; s->nb_sectors = nb_sectors; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if (kind == IDE_CD) { blk_set_dev_ops([[blk]], &ide_cd_block_ops, s); blk_set_guest_block_size([[blk]], 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only([[blk]])) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops([[blk]], &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch (kind) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable([[blk]]); return 0; }

[[[[Adv]]]]: int ide_init_drive(IDEState *s, BlockBackend *[[bluesman]], IDEDriveKind kind, const char *version, const char *serial, const char *model, uint64_t wwn, uint32_t cylinders, uint32_t heads, uint32_t [[those]], int [[enquired]]) { uint64_t nb_sectors; s->blk = [[bluesman]]; s->drive_kind = kind; blk_get_geometry([[bluesman]], &nb_sectors); s->cylinders = cylinders; s->heads = heads; s->sectors = [[those]]; s->chs_trans = [[enquired]]; s->nb_sectors = nb_sectors; s->wwn = wwn; s->smart_enabled = 1; s->smart_autosave = 1; s->smart_errors = 0; s->smart_selftest_count = 0; if (kind == IDE_CD) { blk_set_dev_ops([[bluesman]], &ide_cd_block_ops, s); blk_set_guest_block_size([[bluesman]], 2048); } else { if (!blk_is_inserted(s->blk)) { error_report("Device needs media, but drive is empty"); return -1; } if (blk_is_read_only([[bluesman]])) { error_report("Can't use a read-only drive"); return -1; } blk_set_dev_ops([[bluesman]], &ide_hd_block_ops, s); } if (serial) { pstrcpy(s->drive_serial_str, sizeof(s->drive_serial_str), serial); } else { snprintf(s->drive_serial_str, sizeof(s->drive_serial_str), "QM%05d", s->drive_serial); } if (model) { pstrcpy(s->drive_model_str, sizeof(s->drive_model_str), model); } else { switch (kind) { case IDE_CD: strcpy(s->drive_model_str, "QEMU DVD-ROM"); break; case IDE_CFATA: strcpy(s->drive_model_str, "QEMU MICRODRIVE"); break; default: strcpy(s->drive_model_str, "QEMU HARDDISK"); break; } } if (version) { pstrcpy(s->version, sizeof(s->version), version); } else { pstrcpy(s->version, sizeof(s->version), qemu_get_version()); } ide_reset(s); blk_iostatus_enable([[bluesman]]); return 0; }
--------------------------------------------- Result 188 ---------------------------------------------
[[0 (49%)]] --> [[0 (50%)]] --> Socre: 0.5035533905029297

[[[[Adv]]]]: static int decode_opc(MoxieCPU *cpu, DisasContext *ctx) { CPUMoxieState *env = &cpu->env; int opcode; int [[length]] = 2; if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(ctx->pc); } opcode = ctx->opcode; if (opcode & (1 << 15)) { if (opcode & (1 << 14)) { int inst = (opcode >> 10 & 0xf); #define BRANCH(cond) \ do { \ int l1 = gen_new_label(); \ tcg_gen_brcond_i32(cond, cc_a, cc_b, l1); \ gen_goto_tb(env, ctx, 1, ctx->pc+2); \ gen_set_label(l1); \ gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \ ctx->bstate = BS_BRANCH; \ } while (0) switch (inst) { case 0x00: BRANCH(TCG_COND_EQ); break; case 0x01: BRANCH(TCG_COND_NE); break; case 0x02: BRANCH(TCG_COND_LT); break; case 0x03: BRANCH(TCG_COND_GT); break; case 0x04: BRANCH(TCG_COND_LTU); break; case 0x05: BRANCH(TCG_COND_GTU); break; case 0x06: BRANCH(TCG_COND_GE); break; case 0x07: BRANCH(TCG_COND_LE); break; case 0x08: BRANCH(TCG_COND_GEU); break; case 0x09: BRANCH(TCG_COND_LEU); break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } else { int inst = (opcode >> 12 & 0x3); switch (inst) { case 0x00: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_addi_i32(REG(a), REG(a), v); } break; case 0x01: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_subi_i32(REG(a), REG(a), v); } break; case 0x02: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_ld_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; case 0x03: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_st_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } } else { int inst = opcode >> 8; switch (inst) { case 0x00: break; case 0x01: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[length]] = 6; } break; case 0x02: { int dest = (opcode >> 4) & 0xf; int [[src]] = opcode & 0xf; tcg_gen_mov_i32(REG(dest), REG([[src]])); } break; case 0x03: { TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc + 6); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); ctx->bstate = BS_BRANCH; [[length]] = 6; } break; case 0x04: { TCGv t1 = tcg_temp_new_i32(); tcg_gen_mov_i32(REG(1), REG(0)); tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 4); tcg_gen_mov_i32(REG(1), t1); tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 8); tcg_gen_mov_i32(REG(1), t1); tcg_temp_free_i32(t1); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x05: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_add_i32(REG(a), REG(a), REG(b)); } break; case 0x06: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_subi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx); tcg_temp_free_i32(t1); } break; case 0x07: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx); tcg_gen_addi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_temp_free_i32(t1); } break; case 0x08: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x09: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x0a: { int [[src]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld32u(REG(dest), REG([[src]]), ctx->memidx); } break; case 0x0b: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx); } break; case 0x0c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; case 0x0d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; case 0x0e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mov_i32(cc_a, REG(a)); tcg_gen_mov_i32(cc_b, REG(b)); } break; case 0x19: { int fnreg = (opcode >> 4) & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc+2); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); tcg_gen_mov_i32(cpu_pc, REG(fnreg)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x1a: { tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; [[length]] = 6; } break; case 0x1b: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[length]] = 6; } break; case 0x1c: { int [[src]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld8u(REG(dest), REG([[src]]), ctx->memidx); } break; case 0x1d: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x1e: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx); } break; case 0x1f: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x20: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[length]] = 6; } break; case 0x21: { int [[src]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld16u(REG(dest), REG([[src]]), ctx->memidx); } break; case 0x22: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x23: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx); } break; case 0x24: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[length]] = 6; } break; case 0x25: { int reg = (opcode >> 4) & 0xf; tcg_gen_mov_i32(cpu_pc, REG(reg)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x26: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_and_i32(REG(a), REG(a), REG(b)); } break; case 0x27: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shr_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x28: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shl_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x29: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_sub_i32(REG(a), REG(a), REG(b)); } break; case 0x2a: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_neg_i32(REG(a), REG(b)); } break; case 0x2b: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_or_i32(REG(a), REG(a), REG(b)); } break; case 0x2c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_not_i32(REG(a), REG(b)); } break; case 0x2d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_sar_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x2e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_xor_i32(REG(a), REG(a), REG(b)); } break; case 0x2f: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mul_i32(REG(a), REG(a), REG(b)); } break; case 0x30: { int val = cpu_ldl_code(env, ctx->pc+2); TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(temp, val); tcg_gen_st_i32(temp, cpu_env, offsetof(CPUMoxieState, sregs[3])); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_SWI); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); [[length]] = 6; } break; case 0x31: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_div(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x32: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x33: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_rem_i32(REG(a), REG(a), REG(b)); } break; case 0x34: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_remu_i32(REG(a), REG(a), REG(b)); } break; case 0x35: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BREAK); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; case 0x36: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; case 0x37: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; case 0x38: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; case 0x39: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[length]] = 6; } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } return [[length]]; }

[[[[Adv]]]]: static int decode_opc(MoxieCPU *cpu, DisasContext *ctx) { CPUMoxieState *env = &cpu->env; int opcode; int [[ranges]] = 2; if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(ctx->pc); } opcode = ctx->opcode; if (opcode & (1 << 15)) { if (opcode & (1 << 14)) { int inst = (opcode >> 10 & 0xf); #define BRANCH(cond) \ do { \ int l1 = gen_new_label(); \ tcg_gen_brcond_i32(cond, cc_a, cc_b, l1); \ gen_goto_tb(env, ctx, 1, ctx->pc+2); \ gen_set_label(l1); \ gen_goto_tb(env, ctx, 0, extract_branch_offset(opcode) + ctx->pc+2); \ ctx->bstate = BS_BRANCH; \ } while (0) switch (inst) { case 0x00: BRANCH(TCG_COND_EQ); break; case 0x01: BRANCH(TCG_COND_NE); break; case 0x02: BRANCH(TCG_COND_LT); break; case 0x03: BRANCH(TCG_COND_GT); break; case 0x04: BRANCH(TCG_COND_LTU); break; case 0x05: BRANCH(TCG_COND_GTU); break; case 0x06: BRANCH(TCG_COND_GE); break; case 0x07: BRANCH(TCG_COND_LE); break; case 0x08: BRANCH(TCG_COND_GEU); break; case 0x09: BRANCH(TCG_COND_LEU); break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } else { int inst = (opcode >> 12 & 0x3); switch (inst) { case 0x00: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_addi_i32(REG(a), REG(a), v); } break; case 0x01: { int a = (opcode >> 8) & 0xf; unsigned int v = (opcode & 0xff); tcg_gen_subi_i32(REG(a), REG(a), v); } break; case 0x02: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_ld_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; case 0x03: { int a = (opcode >> 8) & 0xf; unsigned v = (opcode & 0xff); tcg_gen_st_i32(REG(a), cpu_env, offsetof(CPUMoxieState, sregs[v])); } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } } else { int inst = opcode >> 8; switch (inst) { case 0x00: break; case 0x01: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[ranges]] = 6; } break; case 0x02: { int dest = (opcode >> 4) & 0xf; int [[stuart]] = opcode & 0xf; tcg_gen_mov_i32(REG(dest), REG([[stuart]])); } break; case 0x03: { TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc + 6); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); gen_goto_tb(env, ctx, 0, cpu_ldl_code(env, ctx->pc+2)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); ctx->bstate = BS_BRANCH; [[ranges]] = 6; } break; case 0x04: { TCGv t1 = tcg_temp_new_i32(); tcg_gen_mov_i32(REG(1), REG(0)); tcg_gen_qemu_ld32u(REG(0), REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 4); tcg_gen_mov_i32(REG(1), t1); tcg_gen_qemu_ld32u(cpu_pc, REG(1), ctx->memidx); tcg_gen_addi_i32(t1, REG(1), 8); tcg_gen_mov_i32(REG(1), t1); tcg_temp_free_i32(t1); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x05: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_add_i32(REG(a), REG(a), REG(b)); } break; case 0x06: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_subi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_gen_qemu_st32(REG(b), REG(a), ctx->memidx); tcg_temp_free_i32(t1); } break; case 0x07: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); tcg_gen_qemu_ld32u(REG(b), REG(a), ctx->memidx); tcg_gen_addi_i32(t1, REG(a), 4); tcg_gen_mov_i32(REG(a), t1); tcg_temp_free_i32(t1); } break; case 0x08: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x09: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x0a: { int [[stuart]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld32u(REG(dest), REG([[stuart]]), ctx->memidx); } break; case 0x0b: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st32(REG(val), REG(dest), ctx->memidx); } break; case 0x0c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld32u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; case 0x0d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st32(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; case 0x0e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mov_i32(cc_a, REG(a)); tcg_gen_mov_i32(cc_b, REG(b)); } break; case 0x19: { int fnreg = (opcode >> 4) & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_movi_i32(t1, ctx->pc+2); tcg_gen_subi_i32(t2, REG(1), 8); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(t1, REG(1), ctx->memidx); tcg_gen_subi_i32(t2, REG(1), 4); tcg_gen_mov_i32(REG(1), t2); tcg_gen_qemu_st32(REG(0), REG(1), ctx->memidx); tcg_gen_mov_i32(REG(0), REG(1)); tcg_gen_mov_i32(cpu_pc, REG(fnreg)); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x1a: { tcg_gen_movi_i32(cpu_pc, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; [[ranges]] = 6; } break; case 0x1b: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[ranges]] = 6; } break; case 0x1c: { int [[stuart]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld8u(REG(dest), REG([[stuart]]), ctx->memidx); } break; case 0x1d: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x1e: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st8(REG(val), REG(dest), ctx->memidx); } break; case 0x1f: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x20: { int reg = (opcode >> 4) & 0xf; int val = cpu_ldl_code(env, ctx->pc+2); tcg_gen_movi_i32(REG(reg), val); [[ranges]] = 6; } break; case 0x21: { int [[stuart]] = opcode & 0xf; int dest = (opcode >> 4) & 0xf; tcg_gen_qemu_ld16u(REG(dest), REG([[stuart]]), ctx->memidx); } break; case 0x22: { int reg = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(REG(reg), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x23: { int dest = (opcode >> 4) & 0xf; int val = opcode & 0xf; tcg_gen_qemu_st16(REG(val), REG(dest), ctx->memidx); } break; case 0x24: { int val = (opcode >> 4) & 0xf; TCGv ptr = tcg_temp_new_i32(); tcg_gen_movi_i32(ptr, cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(val), ptr, ctx->memidx); tcg_temp_free_i32(ptr); [[ranges]] = 6; } break; case 0x25: { int reg = (opcode >> 4) & 0xf; tcg_gen_mov_i32(cpu_pc, REG(reg)); tcg_gen_exit_tb(0); ctx->bstate = BS_BRANCH; } break; case 0x26: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_and_i32(REG(a), REG(a), REG(b)); } break; case 0x27: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shr_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x28: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_shl_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x29: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_sub_i32(REG(a), REG(a), REG(b)); } break; case 0x2a: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_neg_i32(REG(a), REG(b)); } break; case 0x2b: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_or_i32(REG(a), REG(a), REG(b)); } break; case 0x2c: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_not_i32(REG(a), REG(b)); } break; case 0x2d: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv sv = tcg_temp_new_i32(); tcg_gen_andi_i32(sv, REG(b), 0x1f); tcg_gen_sar_i32(REG(a), REG(a), sv); tcg_temp_free_i32(sv); } break; case 0x2e: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_xor_i32(REG(a), REG(a), REG(b)); } break; case 0x2f: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_mul_i32(REG(a), REG(a), REG(b)); } break; case 0x30: { int val = cpu_ldl_code(env, ctx->pc+2); TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(temp, val); tcg_gen_st_i32(temp, cpu_env, offsetof(CPUMoxieState, sregs[3])); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_SWI); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); [[ranges]] = 6; } break; case 0x31: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_div(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x32: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_movi_i32(cpu_pc, ctx->pc); gen_helper_udiv(REG(a), cpu_env, REG(a), REG(b)); } break; case 0x33: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_rem_i32(REG(a), REG(a), REG(b)); } break; case 0x34: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; tcg_gen_remu_i32(REG(a), REG(a), REG(b)); } break; case 0x35: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BREAK); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; case 0x36: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld8u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; case 0x37: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st8(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; case 0x38: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(b), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_ld16u(t2, t1, ctx->memidx); tcg_gen_mov_i32(REG(a), t2); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; case 0x39: { int a = (opcode >> 4) & 0xf; int b = opcode & 0xf; TCGv t1 = tcg_temp_new_i32(); TCGv t2 = tcg_temp_new_i32(); tcg_gen_addi_i32(t1, REG(a), cpu_ldl_code(env, ctx->pc+2)); tcg_gen_qemu_st16(REG(b), t1, ctx->memidx); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); [[ranges]] = 6; } break; default: { TCGv temp = tcg_temp_new_i32(); tcg_gen_movi_i32(cpu_pc, ctx->pc); tcg_gen_movi_i32(temp, MOXIE_EX_BAD); gen_helper_raise_exception(cpu_env, temp); tcg_temp_free_i32(temp); } break; } } return [[ranges]]; }[Succeeded / Failed / Skipped / Total] 78 / 23 / 87 / 188:   7%|         | 188/2690 [01:09<15:28,  2.69it/s][Succeeded / Failed / Skipped / Total] 79 / 23 / 87 / 189:   7%|         | 189/2690 [01:09<15:23,  2.71it/s][Succeeded / Failed / Skipped / Total] 79 / 24 / 87 / 190:   7%|         | 190/2690 [01:09<15:18,  2.72it/s][Succeeded / Failed / Skipped / Total] 79 / 25 / 87 / 191:   7%|         | 191/2690 [01:10<15:18,  2.72it/s]
--------------------------------------------- Result 189 ---------------------------------------------
[[0 (55%)]] --> [[0 (49%)]] --> Socre: 0.5073664784431458

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int buf_size2) { RVDecContext *rv = avctx->priv_data; MpegEncContext *s = &rv->m; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = buf_size * 8; init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8); if (s->codec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count < 0) { av_log(s->avctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; } if (s->mb_x >= s->mb_width || s->mb_y >= s->mb_height) { av_log(s->avctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } mb_pos = s->mb_y * s->mb_width + s->mb_x; left = s->mb_width * s->mb_height - mb_pos; if (mb_count > left) { av_log(s->avctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; } if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) { if (s->current_picture_ptr) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0; } if ((ret = ff_MPV_frame_start(s, avctx)) < 0) return ret; ff_mpeg_er_frame_start(s); } else { if (s->current_picture_ptr->f.pict_type != s->pict_type) { av_log(s->avctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; } } av_dlog(avctx, "qscale=%d\n", s->qscale); if (s->codec_id == AV_CODEC_ID_RV10) { if (s->mb_y == 0) s->first_slice_line = 1; } else { s->first_slice_line = 1; s->resync_mb_x = s->mb_x; } start_mb_x = s->mb_x; s->resync_mb_y = s->mb_y; if (s->h263_aic) { s->y_dc_scale_table = s->c_dc_scale_table = ff_aic_dc_scale_table; } else { s->y_dc_scale_table = s->c_dc_scale_table = ff_mpeg1_dc_scale_table; } if (s->modified_quant) s->chroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s->qscale); s->rv10_first_dc_coded[0] = 0; s->rv10_first_dc_coded[1] = 0; s->rv10_first_dc_coded[2] = 0; s->block_wrap[0] = s->block_wrap[1] = s->block_wrap[2] = s->block_wrap[3] = s->b8_stride; s->block_wrap[4] = s->block_wrap[5] = s->mb_stride; ff_init_block_index(s); for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) { int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s->mb_x, s->mb_y); s->mv_dir = MV_DIR_FORWARD; s->mv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s->block); if (ret != SLICE_ERROR) { int [[v]] = show_bits(&s->gb, 16); if (get_bits_count(&s->gb) + 16 > active_bits_size) [[v]] >>= get_bits_count(&s->gb) + 16 - active_bits_size; if (![[v]]) ret = SLICE_END; } if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) && 8 * buf_size2 >= get_bits_count(&s->gb)) { active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * buf_size, active_bits_size); ret = SLICE_OK; } if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) { av_log(s->avctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } if (s->pict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s->block); if (s->loop_filter) ff_h263_loop_filter(s); if (++s->mb_x == s->mb_width) { s->mb_x = 0; s->mb_y++; ff_init_block_index(s); } if (s->mb_x == s->resync_mb_x) s->first_slice_line = 0; if (ret == SLICE_END) break; } ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y, ER_MB_END); return active_bits_size; }

[[[[Adv]]]]: static int rv10_decode_packet(AVCodecContext *avctx, const uint8_t *buf, int buf_size, int buf_size2) { RVDecContext *rv = avctx->priv_data; MpegEncContext *s = &rv->m; int mb_count, mb_pos, left, start_mb_x, active_bits_size, ret; active_bits_size = buf_size * 8; init_get_bits(&s->gb, buf, FFMAX(buf_size, buf_size2) * 8); if (s->codec_id == AV_CODEC_ID_RV10) mb_count = rv10_decode_picture_header(s); else mb_count = rv20_decode_picture_header(rv); if (mb_count < 0) { av_log(s->avctx, AV_LOG_ERROR, "HEADER ERROR\n"); return AVERROR_INVALIDDATA; } if (s->mb_x >= s->mb_width || s->mb_y >= s->mb_height) { av_log(s->avctx, AV_LOG_ERROR, "POS ERROR %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } mb_pos = s->mb_y * s->mb_width + s->mb_x; left = s->mb_width * s->mb_height - mb_pos; if (mb_count > left) { av_log(s->avctx, AV_LOG_ERROR, "COUNT ERROR\n"); return AVERROR_INVALIDDATA; } if ((s->mb_x == 0 && s->mb_y == 0) || s->current_picture_ptr == NULL) { if (s->current_picture_ptr) { ff_er_frame_end(&s->er); ff_MPV_frame_end(s); s->mb_x = s->mb_y = s->resync_mb_x = s->resync_mb_y = 0; } if ((ret = ff_MPV_frame_start(s, avctx)) < 0) return ret; ff_mpeg_er_frame_start(s); } else { if (s->current_picture_ptr->f.pict_type != s->pict_type) { av_log(s->avctx, AV_LOG_ERROR, "Slice type mismatch\n"); return AVERROR_INVALIDDATA; } } av_dlog(avctx, "qscale=%d\n", s->qscale); if (s->codec_id == AV_CODEC_ID_RV10) { if (s->mb_y == 0) s->first_slice_line = 1; } else { s->first_slice_line = 1; s->resync_mb_x = s->mb_x; } start_mb_x = s->mb_x; s->resync_mb_y = s->mb_y; if (s->h263_aic) { s->y_dc_scale_table = s->c_dc_scale_table = ff_aic_dc_scale_table; } else { s->y_dc_scale_table = s->c_dc_scale_table = ff_mpeg1_dc_scale_table; } if (s->modified_quant) s->chroma_qscale_table = ff_h263_chroma_qscale_table; ff_set_qscale(s, s->qscale); s->rv10_first_dc_coded[0] = 0; s->rv10_first_dc_coded[1] = 0; s->rv10_first_dc_coded[2] = 0; s->block_wrap[0] = s->block_wrap[1] = s->block_wrap[2] = s->block_wrap[3] = s->b8_stride; s->block_wrap[4] = s->block_wrap[5] = s->mb_stride; ff_init_block_index(s); for (s->mb_num_left = mb_count; s->mb_num_left > 0; s->mb_num_left--) { int ret; ff_update_block_index(s); av_dlog(avctx, "**mb x=%d y=%d\n", s->mb_x, s->mb_y); s->mv_dir = MV_DIR_FORWARD; s->mv_type = MV_TYPE_16X16; ret = ff_h263_decode_mb(s, s->block); if (ret != SLICE_ERROR) { int [[nous]] = show_bits(&s->gb, 16); if (get_bits_count(&s->gb) + 16 > active_bits_size) [[nous]] >>= get_bits_count(&s->gb) + 16 - active_bits_size; if (![[nous]]) ret = SLICE_END; } if (ret != SLICE_ERROR && active_bits_size < get_bits_count(&s->gb) && 8 * buf_size2 >= get_bits_count(&s->gb)) { active_bits_size = buf_size2 * 8; av_log(avctx, AV_LOG_DEBUG, "update size from %d to %d\n", 8 * buf_size, active_bits_size); ret = SLICE_OK; } if (ret == SLICE_ERROR || active_bits_size < get_bits_count(&s->gb)) { av_log(s->avctx, AV_LOG_ERROR, "ERROR at MB %d %d\n", s->mb_x, s->mb_y); return AVERROR_INVALIDDATA; } if (s->pict_type != AV_PICTURE_TYPE_B) ff_h263_update_motion_val(s); ff_MPV_decode_mb(s, s->block); if (s->loop_filter) ff_h263_loop_filter(s); if (++s->mb_x == s->mb_width) { s->mb_x = 0; s->mb_y++; ff_init_block_index(s); } if (s->mb_x == s->resync_mb_x) s->first_slice_line = 0; if (ret == SLICE_END) break; } ff_er_add_slice(&s->er, start_mb_x, s->resync_mb_y, s->mb_x - 1, s->mb_y, ER_MB_END); return active_bits_size; }
--------------------------------------------- Result 190 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *name, double *obj, Error **errp) { QmpOutputVisitor *qov = to_qov(v); qmp_output_add(qov, name, qfloat_from_double(*obj)); }

[[[[Adv]]]]: static void qmp_output_type_number(Visitor *v, const char *name, double *obj, Error **errp) { QmpOutputVisitor *qov = to_qov(v); qmp_output_add(qov, name, qfloat_from_double(*obj)); }
--------------------------------------------- Result 191 ---------------------------------------------
[[0 (88%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *cpu) { #if defined(CONFIG_USER_ONLY) return cpu->host_tid; #else return cpu->cpu_index + 1; #endif }

[[[[Adv]]]]: static inline int cpu_gdb_index(CPUState *cpu) { #if defined(CONFIG_USER_ONLY) return cpu->host_tid; #else return cpu->cpu_index + 1; #endif }
--------------------------------------------- Result 192 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 25 / 87 / 192:   7%|         | 192/2690 [01:10<15:13,  2.73it/s][Succeeded / Failed / Skipped / Total] 80 / 25 / 88 / 193:   7%|         | 193/2690 [01:10<15:13,  2.73it/s][Succeeded / Failed / Skipped / Total] 80 / 25 / 89 / 194:   7%|         | 194/2690 [01:10<15:10,  2.74it/s][[0 (23%)]] --> [[0 (50%)]] --> Socre: 0.5016596913337708

[[[[Adv]]]]: static void curl_multi_do(void *[[arg]]) { BDRVCURLState *s = (BDRVCURLState *)[[arg]]; int running; int r; if (!s->multi) { return; } do { r = curl_multi_socket_all(s->multi, &running); } while(r == CURLM_CALL_MULTI_PERFORM); curl_multi_read(s); }

[[[[Adv]]]]: static void curl_multi_do(void *[[answers]]) { BDRVCURLState *s = (BDRVCURLState *)[[answers]]; int running; int r; if (!s->multi) { return; } do { r = curl_multi_socket_all(s->multi, &running); } while(r == CURLM_CALL_MULTI_PERFORM); curl_multi_read(s); }
--------------------------------------------- Result 193 ---------------------------------------------
[[0 (66%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static TranslationBlock *tb_alloc(target_ulong pc) { TranslationBlock *tb; TBContext *ctx; assert_tb_locked(); tb = tcg_tb_alloc(&tcg_ctx); if (unlikely(tb == NULL)) { return NULL; } ctx = &tcg_ctx.tb_ctx; if (unlikely(ctx->nb_tbs == ctx->tbs_size)) { ctx->tbs_size *= 2; ctx->tbs = g_renew(TranslationBlock *, ctx->tbs, ctx->tbs_size); } ctx->tbs[ctx->nb_tbs++] = tb; tb->pc = pc; tb->cflags = 0; tb->invalid = "False" != "False"; return tb; }
--------------------------------------------- Result 194 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, void *data, int *got_frame, AVPacket *avpkt) { TiffContext *const s = avctx->priv_data; AVFrame *const p = data; ThreadFrame frame = { .f = data }; unsigned off; int le, ret, plane, planes; int i, j, entries, stride; unsigned soff, ssize; uint8_t *dst; GetByteContext stripsizes; GetByteContext stripdata; bytestream2_init(&s->gb, avpkt->data, avpkt->size); if ((ret = ff_tdecode_header(&s->gb, &le, &off))) { av_log(avctx, AV_LOG_ERROR, "Invalid TIFF header\n"); return ret; } else if (off >= UINT_MAX - 14 || avpkt->size < off + 14) { av_log(avctx, AV_LOG_ERROR, "IFD offset is greater than image size\n"); return AVERROR_INVALIDDATA; } s->le = le; s->bppcount = s->bpp = 1; s->photometric = TIFF_PHOTOMETRIC_NONE; s->compr = TIFF_RAW; s->fill_order = 0; free_geotags(s); s->stripsizesoff = s->strippos = 0; bytestream2_seek(&s->gb, off, SEEK_SET); entries = ff_tget_short(&s->gb, le); if (bytestream2_get_bytes_left(&s->gb) < entries * 12) return AVERROR_INVALIDDATA; for (i = 0; i < entries; i++) { if ((ret = tiff_decode_tag(s, p)) < 0) return ret; } for (i = 0; i<s->geotag_count; i++) { const char *keyname = get_geokey_name(s->geotags[i].key); if (!keyname) { av_log(avctx, AV_LOG_WARNING, "Unknown or unsupported GeoTIFF key %d\n", s->geotags[i].key); continue; } if (get_geokey_type(s->geotags[i].key) != s->geotags[i].type) { av_log(avctx, AV_LOG_WARNING, "Type of GeoTIFF key %d is wrong\n", s->geotags[i].key); continue; } ret = av_dict_set(avpriv_frame_get_metadatap(p), keyname, s->geotags[i].val, 0); if (ret<0) { av_log(avctx, AV_LOG_ERROR, "Writing metadata with key '%s' failed\n", keyname); return ret; } } if (!s->strippos && !s->stripoff) { av_log(avctx, AV_LOG_ERROR, "Image data is missing\n"); return AVERROR_INVALIDDATA; } if ((ret = init_image(s, &frame)) < 0) return ret; if (s->strips == 1 && !s->stripsize) { av_log(avctx, AV_LOG_WARNING, "Image data size missing\n"); s->stripsize = avpkt->size - s->stripoff; } if (s->stripsizesoff) { if (s->stripsizesoff >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripsizes, avpkt->data + s->stripsizesoff, avpkt->size - s->stripsizesoff); } if (s->strippos) { if (s->strippos >= (unsigned)avpkt->size) return AVERROR_INVALIDDATA; bytestream2_init(&stripdata, avpkt->data + s->strippos, avpkt->size - s->strippos); } if (s->rps <= 0) { av_log(avctx, AV_LOG_ERROR, "rps %d invalid\n", s->rps); return AVERROR_INVALIDDATA; } planes = s->planar ? s->bppcount : 1; for (plane = 0; plane < planes; plane++) { stride = p->linesize[plane]; dst = p->data[plane]; for (i = 0; i < s->height; i += s->rps) { if (s->stripsizesoff) ssize = ff_tget(&stripsizes, s->sstype, le); else ssize = s->stripsize; if (s->strippos) soff = ff_tget(&stripdata, s->sot, le); else soff = s->stripoff; if (soff > avpkt->size || ssize > avpkt->size - soff) { av_log(avctx, AV_LOG_ERROR, "Invalid strip size/offset\n"); return AVERROR_INVALIDDATA; } if ((ret = tiff_unpack_strip(s, p, dst, stride, avpkt->data + soff, ssize, i, FFMIN(s->rps, s->height - i))) < 0) { if (avctx->err_recognition & AV_EF_EXPLODE) return ret; break; } dst += s->rps * stride; } if (s->predictor == 2) { if (s->photometric == TIFF_PHOTOMETRIC_YCBCR) { av_log(s->avctx, AV_LOG_ERROR, "predictor == 2 with YUV is unsupported"); return AVERROR_PATCHWELCOME; } dst = p->data[plane]; soff = s->bpp >> 3; if (s->planar) soff = FFMAX(soff / s->bppcount, 1); ssize = s->width * soff; if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48LE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64LE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16LE || s->avctx->pix_fmt == AV_PIX_FMT_YA16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16LE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16LE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WL16(dst + j, AV_RL16(dst + j) + AV_RL16(dst + j - soff)); dst += stride; } } else if (s->avctx->pix_fmt == AV_PIX_FMT_RGB48BE || s->avctx->pix_fmt == AV_PIX_FMT_RGBA64BE || s->avctx->pix_fmt == AV_PIX_FMT_GRAY16BE || s->avctx->pix_fmt == AV_PIX_FMT_YA16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRP16BE || s->avctx->pix_fmt == AV_PIX_FMT_GBRAP16BE) { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j += 2) AV_WB16(dst + j, AV_RB16(dst + j) + AV_RB16(dst + j - soff)); dst += stride; } } else { for (i = 0; i < s->height; i++) { for (j = soff; j < ssize; j++) dst[j] += dst[j - soff]; dst += stride; } } } if (s->photometric == TIFF_PHOTOMETRIC_WHITE_IS_ZERO) { dst = p->data[plane]; for (i = 0; i < s->height; i++) { for (j = 0; j < stride; j++) dst[j] = (s->avctx->pix_fmt == AV_PIX_FMT_PAL8 ? (1<<s->bpp) - 1 : 255) - dst[j]; dst += stride; } } } if (s->planar && s->bppcount > 2) { FFSWAP(uint8_t*, p->data[0], p->data[2]); FFSWAP(int, p->linesize[0], p->linesize[2]); FFSWAP(uint8_t*, p->data[0], p->data[1]); FFSWAP(int, p->linesize[0], p->linesize[1]); } *got_frame = 1; return avpkt->size; }
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 26 / 89 / 195:   7%|         | 195/2690 [01:11<15:14,  2.73it/s][Succeeded / Failed / Skipped / Total] 81 / 26 / 89 / 196:   7%|         | 196/2690 [01:11<15:11,  2.74it/s][[0 (45%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { int ret; *got_picture_ptr = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); avcodec_get_frame_defaults(picture); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, got_picture_ptr, avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*got_picture_ptr) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }

[[[[Adv]]]]: int attribute_align_arg avcodec_decode_video2(AVCodecContext *avctx, AVFrame *picture, int *got_picture_ptr, AVPacket *avpkt) { int ret; *got_picture_ptr = 0; if ((avctx->coded_width || avctx->coded_height) && av_image_check_size(avctx->coded_width, avctx->coded_height, 0, avctx)) return -1; avctx->pkt = avpkt; apply_param_change(avctx, avpkt); avcodec_get_frame_defaults(picture); if ((avctx->codec->capabilities & CODEC_CAP_DELAY) || avpkt->size || (avctx->active_thread_type & FF_THREAD_FRAME)) { if (HAVE_THREADS && avctx->active_thread_type & FF_THREAD_FRAME) ret = ff_thread_decode_frame(avctx, picture, got_picture_ptr, avpkt); else { ret = avctx->codec->decode(avctx, picture, got_picture_ptr, avpkt); picture->pkt_dts = avpkt->dts; picture->sample_aspect_ratio = avctx->sample_aspect_ratio; picture->width = avctx->width; picture->height = avctx->height; picture->format = avctx->pix_fmt; } emms_c(); if (*got_picture_ptr) avctx->frame_number++; } else ret = 0; picture->extended_data = picture->data; return ret; }
--------------------------------------------- Result 196 ---------------------------------------------
[[0 (52%)]] --> [[0 (44%)]] --> Socre: 0.5555658340454102

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun, MegasasCmd *cmd) { struct mfi_pd_info *info = cmd->iov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF); uint8_t cmdbuf[6]; SCSIRequest *req; size_t [[len]], resid; if (!cmd->iov_buf) { cmd->iov_buf = g_malloc0(dcmd_size); info = cmd->iov_buf; info->inquiry_data[0] = 0x7f; info->vpd_page83[0] = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info std inquiry"); g_free(cmd->iov_buf); cmd->iov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info std inquiry", lun); [[len]] = scsi_req_enqueue(req); if ([[len]] > 0) { cmd->iov_size = [[len]]; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) { megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info vpd inquiry", lun); [[len]] = scsi_req_enqueue(req); if ([[len]] > 0) { cmd->iov_size = [[len]]; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } if ((info->inquiry_data[0] >> 5) == 0) { if (megasas_is_jbod(cmd->state)) { info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); } } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); } info->ref.v.device_id = cpu_to_le16(pd_id); info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry(sdev->conf.blk, &pd_size); info->raw_size = cpu_to_le64(pd_size); info->non_coerced_size = cpu_to_le64(pd_size); info->coerced_size = cpu_to_le64(pd_size); info->encl_device_id = 0xFFFF; info->slot_number = (sdev->id & 0xFF); info->path_info.count = 1; info->path_info.sas_addr[0] = cpu_to_le64(megasas_get_sata_addr(pd_id)); info->connected_port_bitmap = 0x1; info->device_speed = 1; info->link_speed = 1; resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg); g_free(cmd->iov_buf); cmd->iov_size = dcmd_size - resid; cmd->iov_buf = NULL; return MFI_STAT_OK; }

[[[[Adv]]]]: static int megasas_pd_get_info_submit(SCSIDevice *sdev, int lun, MegasasCmd *cmd) { struct mfi_pd_info *info = cmd->iov_buf; size_t dcmd_size = sizeof(struct mfi_pd_info); uint64_t pd_size; uint16_t pd_id = ((sdev->id & 0xFF) << 8) | (lun & 0xFF); uint8_t cmdbuf[6]; SCSIRequest *req; size_t [[purely]], resid; if (!cmd->iov_buf) { cmd->iov_buf = g_malloc0(dcmd_size); info = cmd->iov_buf; info->inquiry_data[0] = 0x7f; info->vpd_page83[0] = 0x7f; megasas_setup_inquiry(cmdbuf, 0, sizeof(info->inquiry_data)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info std inquiry"); g_free(cmd->iov_buf); cmd->iov_buf = NULL; return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info std inquiry", lun); [[purely]] = scsi_req_enqueue(req); if ([[purely]] > 0) { cmd->iov_size = [[purely]]; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } else if (info->inquiry_data[0] != 0x7f && info->vpd_page83[0] == 0x7f) { megasas_setup_inquiry(cmdbuf, 0x83, sizeof(info->vpd_page83)); req = scsi_req_new(sdev, cmd->index, lun, cmdbuf, cmd); if (!req) { trace_megasas_dcmd_req_alloc_failed(cmd->index, "PD get info vpd inquiry"); return MFI_STAT_FLASH_ALLOC_FAIL; } trace_megasas_dcmd_internal_submit(cmd->index, "PD get info vpd inquiry", lun); [[purely]] = scsi_req_enqueue(req); if ([[purely]] > 0) { cmd->iov_size = [[purely]]; scsi_req_continue(req); } return MFI_STAT_INVALID_STATUS; } if ((info->inquiry_data[0] >> 5) == 0) { if (megasas_is_jbod(cmd->state)) { info->fw_state = cpu_to_le16(MFI_PD_STATE_SYSTEM); } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_ONLINE); } } else { info->fw_state = cpu_to_le16(MFI_PD_STATE_OFFLINE); } info->ref.v.device_id = cpu_to_le16(pd_id); info->state.ddf.pd_type = cpu_to_le16(MFI_PD_DDF_TYPE_IN_VD| MFI_PD_DDF_TYPE_INTF_SAS); blk_get_geometry(sdev->conf.blk, &pd_size); info->raw_size = cpu_to_le64(pd_size); info->non_coerced_size = cpu_to_le64(pd_size); info->coerced_size = cpu_to_le64(pd_size); info->encl_device_id = 0xFFFF; info->slot_number = (sdev->id & 0xFF); info->path_info.count = 1; info->path_info.sas_addr[0] = cpu_to_le64(megasas_get_sata_addr(pd_id)); info->connected_port_bitmap = 0x1; info->device_speed = 1; info->link_speed = 1; resid = dma_buf_read(cmd->iov_buf, dcmd_size, &cmd->qsg); g_free(cmd->iov_buf); cmd->iov_size = dcmd_size - resid; cmd->iov_buf = NULL; return MFI_STAT_OK; }
--------------------------------------------- Result 197 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 27 / 89 / 197:   7%|         | 197/2690 [01:12<15:20,  2.71it/s][Succeeded / Failed / Skipped / Total] 81 / 27 / 90 / 198:   7%|         | 198/2690 [01:12<15:15,  2.72it/s][[0 (33%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buff[option - buff] = '\0'; option++; if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0) return ret; if (!ctx->codec || !ctx->priv_data) return -1; } else { option = opt; } o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); } else if ((e = av_dict_get(*dict, option, NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, option, arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }

[[[[Adv]]]]: static int ffserver_save_avoption(const char *opt, const char *arg, int type, FFServerConfig *config) { static int hinted = 0; int ret = 0; AVDictionaryEntry *e; const AVOption *o = NULL; const char *option = NULL; const char *codec_name = NULL; char buff[1024]; AVCodecContext *ctx; AVDictionary **dict; enum AVCodecID guessed_codec_id; switch (type) { case AV_OPT_FLAG_VIDEO_PARAM: ctx = config->dummy_vctx; dict = &config->video_opts; guessed_codec_id = config->guessed_video_codec_id != AV_CODEC_ID_NONE ? config->guessed_video_codec_id : AV_CODEC_ID_H264; break; case AV_OPT_FLAG_AUDIO_PARAM: ctx = config->dummy_actx; dict = &config->audio_opts; guessed_codec_id = config->guessed_audio_codec_id != AV_CODEC_ID_NONE ? config->guessed_audio_codec_id : AV_CODEC_ID_AAC; break; default: av_assert0(0); } if (strchr(opt, ':')) { snprintf(buff, sizeof(buff), "%s", opt); codec_name = buff; option = strchr(buff, ':'); buff[option - buff] = '\0'; option++; if ((ret = ffserver_set_codec(ctx, codec_name, config)) < 0) return ret; if (!ctx->codec || !ctx->priv_data) return -1; } else { option = opt; } o = av_opt_find(ctx, option, NULL, type | AV_OPT_FLAG_ENCODING_PARAM, AV_OPT_SEARCH_CHILDREN); if (!o && (!strcmp(option, "time_base") || !strcmp(option, "pixel_format") || !strcmp(option, "video_size") || !strcmp(option, "codec_tag"))) o = av_opt_find(ctx, option, NULL, 0, 0); if (!o) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Option not found: %s\n", opt); if (!hinted && ctx->codec_id == AV_CODEC_ID_NONE) { hinted = 1; report_config_error(config->filename, config->line_num, AV_LOG_ERROR, NULL, "If '%s' is a codec private option, then prefix it with codec name, " "for example '%s:%s %s' or define codec earlier.\n", opt, avcodec_get_name(guessed_codec_id) ,opt, arg); } } else if ((ret = av_opt_set(ctx, option, arg, AV_OPT_SEARCH_CHILDREN)) < 0) { report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Invalid value for option %s (%s): %s\n", opt, arg, av_err2str(ret)); } else if ((e = av_dict_get(*dict, option, NULL, 0))) { if ((o->type == AV_OPT_TYPE_FLAGS) && arg && (arg[0] == '+' || arg[0] == '-')) return av_dict_set(dict, option, arg, AV_DICT_APPEND); report_config_error(config->filename, config->line_num, AV_LOG_ERROR, &config->errors, "Redeclaring value of the option %s, previous value: %s\n", opt, e->value); } else if (av_dict_set(dict, option, arg, 0) < 0) { return AVERROR(ENOMEM); } return 0; }
--------------------------------------------- Result 198 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: qcow2_co_pwritev_compressed(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov) { BDRVQcow2State *s = bs->opaque; QEMUIOVector hd_qiov; struct iovec iov; z_stream strm; int ret, out_len; uint8_t *buf, *out_buf; uint64_t cluster_offset; if (bytes == 0) { cluster_offset = bdrv_getlength(bs->file->bs); return bdrv_truncate(bs->file, cluster_offset, PREALLOC_MODE_OFF, NULL); } buf = qemu_blockalign(bs, s->cluster_size); if (bytes != s->cluster_size) { if (bytes > s->cluster_size || offset + bytes != bs->total_sectors << BDRV_SECTOR_BITS) { qemu_vfree(buf); return -EINVAL; } memset(buf + bytes, 0, s->cluster_size - bytes); } qemu_iovec_to_buf(qiov, 0, buf, bytes); out_buf = g_malloc(s->cluster_size); memset(&strm, 0, sizeof(strm)); ret = deflateInit2(&strm, Z_DEFAULT_COMPRESSION, Z_DEFLATED, -12, 9, Z_DEFAULT_STRATEGY); if (ret != 0) { ret = -EINVAL; goto fail; } strm.avail_in = s->cluster_size; strm.next_in = (uint8_t *)buf; strm.avail_out = s->cluster_size; strm.next_out = out_buf; ret = deflate(&strm, Z_FINISH); if (ret != Z_STREAM_END && ret != Z_OK) { deflateEnd(&strm); ret = -EINVAL; goto fail; } out_len = strm.next_out - out_buf; deflateEnd(&strm); if (ret != Z_STREAM_END || out_len >= s->cluster_size) { ret = qcow2_co_pwritev(bs, offset, bytes, qiov, 0); if (ret < 0) { goto fail; } goto success; } qemu_co_mutex_lock(&s->lock); cluster_offset = qcow2_alloc_compressed_cluster_offset(bs, offset, out_len); if (!cluster_offset) { qemu_co_mutex_unlock(&s->lock); ret = -EIO; goto fail; } cluster_offset &= s->cluster_offset_mask; ret = qcow2_pre_write_overlap_check(bs, 0, cluster_offset, out_len); qemu_co_mutex_unlock(&s->lock); if (ret < 0) { goto fail; } iov = (struct iovec) { .iov_base = out_buf, .iov_len = out_len, }; qemu_iovec_init_external(&hd_qiov, &iov, 1); BLKDBG_EVENT(bs->file, BLKDBG_WRITE_COMPRESSED); ret = bdrv_co_pwritev(bs->file, cluster_offset, out_len, &hd_qiov, 0); if (ret < 0) { goto fail; } success: ret = 0; fail: qemu_vfree(buf); g_free(out_buf); return ret; }
--------------------------------------------- Result 199 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 28 / 90 / 199:   7%|         | 199/2690 [01:13<15:18,  2.71it/s][Succeeded / Failed / Skipped / Total] 81 / 28 / 90 / 199:   7%|         | 200/2690 [01:13<15:16,  2.72it/s][Succeeded / Failed / Skipped / Total] 81 / 29 / 90 / 200:   7%|         | 200/2690 [01:13<15:16,  2.72it/s][Succeeded / Failed / Skipped / Total] 82 / 29 / 90 / 201:   7%|         | 201/2690 [01:13<15:12,  2.73it/s][Succeeded / Failed / Skipped / Total] 82 / 29 / 91 / 202:   8%|         | 202/2690 [01:13<15:07,  2.74it/s][Succeeded / Failed / Skipped / Total] 82 / 29 / 92 / 203:   8%|         | 203/2690 [01:13<15:02,  2.76it/s][[0 (11%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool tso_enable) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t l3_proto; l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (!tso_enable) { goto func_exit; } rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, pkt->l4proto); func_exit: return rc; }

[[[[Adv]]]]: static uint8_t net_tx_pkt_get_gso_type(struct NetTxPkt *pkt, bool tso_enable) { uint8_t rc = VIRTIO_NET_HDR_GSO_NONE; uint16_t l3_proto; l3_proto = eth_get_l3_proto(pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_base, pkt->vec[NET_TX_PKT_L2HDR_FRAG].iov_len); if (!tso_enable) { goto func_exit; } rc = eth_get_gso_type(l3_proto, pkt->vec[NET_TX_PKT_L3HDR_FRAG].iov_base, pkt->l4proto); func_exit: return rc; }
--------------------------------------------- Result 200 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba, target_ulong tce) { IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift); unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift; if (index >= tcet->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } tcet->table[index] = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&tcet->iommu, entry); return H_SUCCESS; }

[[[[Adv]]]]: static target_ulong put_tce_emu(sPAPRTCETable *tcet, target_ulong ioba, target_ulong tce) { IOMMUTLBEntry entry; hwaddr page_mask = IOMMU_PAGE_MASK(tcet->page_shift); unsigned long index = (ioba - tcet->bus_offset) >> tcet->page_shift; if (index >= tcet->nb_table) { hcall_dprintf("spapr_vio_put_tce on out-of-bounds IOBA 0x" TARGET_FMT_lx "\n", ioba); return H_PARAMETER; } tcet->table[index] = tce; entry.target_as = &address_space_memory, entry.iova = ioba & page_mask; entry.translated_addr = tce & page_mask; entry.addr_mask = ~page_mask; entry.perm = spapr_tce_iommu_access_flags(tce); memory_region_notify_iommu(&tcet->iommu, entry); return H_SUCCESS; }
--------------------------------------------- Result 201 ---------------------------------------------
[[0 (30%)]] --> [[0 (53%)]] --> Socre: 0.5295571684837341

[[[[Adv]]]]: static inline void RENAME(yuv422ptouyvy)(const uint8_t *[[ysrc]], const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartouyvy)([[ysrc]], usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); }

[[[[Adv]]]]: static inline void RENAME(yuv422ptouyvy)(const uint8_t *[[liverpool]], const uint8_t *usrc, const uint8_t *vsrc, uint8_t *dst, long width, long height, long lumStride, long chromStride, long dstStride) { RENAME(yuvPlanartouyvy)([[liverpool]], usrc, vsrc, dst, width, height, lumStride, chromStride, dstStride, 1); }
--------------------------------------------- Result 202 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static gboolean ga_channel_open(GAChannel *c, const gchar *path, GAChannelMethod method, int fd) { int ret; c->method = method; switch (c->method) { case GA_CHANNEL_VIRTIO_SERIAL: { assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NONBLOCK #ifndef CONFIG_SOLARIS | O_ASYNC #endif ); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } #ifdef CONFIG_SOLARIS ret = ioctl(fd, I_SETSIG, S_OUTPUT | S_INPUT | S_HIPRI); if (ret == -1) { g_critical("error setting event mask for channel: %s", strerror(errno)); close(fd); return "False" != "False"; } #endif ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_ISA_SERIAL: { struct termios tio; assert(fd < 0); fd = qemu_open(path, O_RDWR | O_NOCTTY | O_NONBLOCK); if (fd == -1) { g_critical("error opening channel: %s", strerror(errno)); return "False" != "False"; } tcgetattr(fd, &tio); tio.c_iflag &= ~(IGNBRK | BRKINT | IGNPAR | PARMRK | INPCK | ISTRIP | INLCR | IGNCR | ICRNL | IXON | IXOFF | IXANY | IMAXBEL); tio.c_oflag = 0; tio.c_lflag = 0; tio.c_cflag |= GA_CHANNEL_BAUDRATE_DEFAULT; tio.c_cc[VMIN] = 1; tio.c_cc[VTIME] = 0; tcflush(fd, TCIFLUSH); tcsetattr(fd, TCSANOW, &tio); ret = ga_channel_client_add(c, fd); if (ret) { g_critical("error adding channel to main loop"); close(fd); return "False" != "False"; } break; } case GA_CHANNEL_UNIX_LISTEN: { if (fd < 0) { Error *local_err = NULL; fd = unix_listen(path, NULL, strlen(path), &local_err); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } case GA_CHANNEL_VSOCK_LISTEN: { if (fd < 0) { Error *local_err = NULL; SocketAddress *addr; char *addr_str; addr_str = g_strdup_printf("vsock:%s", path); addr = socket_parse(addr_str, &local_err); g_free(addr_str); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } fd = socket_listen(addr, &local_err); qapi_free_SocketAddress(addr); if (local_err != NULL) { g_critical("%s", error_get_pretty(local_err)); error_free(local_err); return "False" != "False"; } } ga_channel_listen_add(c, fd, "True" == "True"); break; } default: g_critical("error binding/listening to specified socket"); return "False" != "False"; } return "True" == "True"; }
--------------------------------------------- Result 203 ---------------------------------------------
[[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ram_save_block(QEMUFile *f) { RAMBlock *block = last_block; ram_addr_t offset = last_offset; int bytes_sent = -1; MemoryRegion *mr; if (!block) block = QLIST_FIRST(&ram_list.blocks); do { mr = block->mr; if (memory_region_get_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION)) { uint8_t *p; int cont = (block == last_block) ? RAM_SAVE_FLAG_CONTINUE : 0; memory_region_reset_dirty(mr, offset, TARGET_PAGE_SIZE, DIRTY_MEMORY_MIGRATION); p = memory_region_get_ram_ptr(mr) + offset; if (is_dup_page(p)) { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_COMPRESS); qemu_put_byte(f, *p); bytes_sent = 1; } else { save_block_hdr(f, block, offset, cont, RAM_SAVE_FLAG_PAGE); qemu_put_buffer(f, p, TARGET_PAGE_SIZE); bytes_sent = TARGET_PAGE_SIZE; } break; } offset += TARGET_PAGE_SIZE; if (offset >= block->length) { offset = 0; block = QLIST_NEXT(block, next); if (!block) block = QLIST_FIRST(&ram_list.blocks); } } while (block != last_block || offset != last_offset); last_block = block; last_offset = offset; return bytes_sent; }
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 29 / 92 / 204:   8%|         | 204/2690 [01:18<15:53,  2.61it/s][Succeeded / Failed / Skipped / Total] 83 / 29 / 93 / 205:   8%|         | 205/2690 [01:18<15:48,  2.62it/s][Succeeded / Failed / Skipped / Total] 83 / 29 / 94 / 206:   8%|         | 206/2690 [01:18<15:43,  2.63it/s][Succeeded / Failed / Skipped / Total] 84 / 29 / 94 / 207:   8%|         | 207/2690 [01:18<15:41,  2.64it/s][[0 (41%)]] --> [[0 (51%)]] --> Socre: 0.5127128958702087

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *[[abuf0]], const uint16_t *abuf1, uint8_t *[[dest]], int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, Y2, V); } }

[[[[Adv]]]]: yuv2422_2_c_template(SwsContext *c, const uint16_t *buf0, const uint16_t *buf1, const uint16_t *ubuf0, const uint16_t *ubuf1, const uint16_t *vbuf0, const uint16_t *vbuf1, const uint16_t *[[orfeo]], const uint16_t *abuf1, uint8_t *[[grrr]], int dstW, int yalpha, int uvalpha, int y, enum PixelFormat target) { int yalpha1 = 4095 - yalpha; int uvalpha1 = 4095 - uvalpha; int i; for (i = 0; i < (dstW >> 1); i++) { int Y1 = (buf0[i * 2] * yalpha1 + buf1[i * 2] * yalpha) >> 19; int Y2 = (buf0[i * 2 + 1] * yalpha1 + buf1[i * 2 + 1] * yalpha) >> 19; int U = (ubuf0[i] * uvalpha1 + ubuf1[i] * uvalpha) >> 19; int V = (vbuf0[i] * uvalpha1 + vbuf1[i] * uvalpha) >> 19; output_pixels(i * 4, Y1, U, Y2, V); } }
--------------------------------------------- Result 205 ---------------------------------------------
[[0 (64%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void emulated_edge_mc(uint8_t *buf, const uint8_t *src, int linesize, int block_w, int block_h, int src_x, int src_y, int w, int h, emu_edge_core_func *core_fn) { int start_y, start_x, end_y, end_x, src_y_add = 0; if (src_y >= h) { src_y_add = h - 1 - src_y; src_y = h - 1; } else if (src_y <= -block_h) { src_y_add = 1 - block_h - src_y; src_y = 1 - block_h; } if (src_x >= w) { src += w - 1 - src_x; src_x = w - 1; } else if (src_x <= -block_w) { src += 1 - block_w - src_x; src_x = 1 - block_w; } start_y = FFMAX(0, -src_y); start_x = FFMAX(0, -src_x); end_y = FFMIN(block_h, h-src_y); end_x = FFMIN(block_w, w-src_x); av_assert2(start_x < end_x && block_w > 0); av_assert2(start_y < end_y && block_h > 0); src += (src_y_add + start_y) * linesize + start_x; buf += start_x; core_fn(buf, src, linesize, start_y, end_y, block_h, start_x, end_x, block_w); }
--------------------------------------------- Result 206 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int init_bundles(BinkContext *c) { int bw, bh, blocks; int i; bw = (c->avctx->width + 7) >> 3; bh = (c->avctx->height + 7) >> 3; blocks = bw * bh; for (i = 0; i < BINKB_NB_SRC; i++) { c->bundle[i].data = av_malloc(blocks * 64); if (!c->bundle[i].data) return AVERROR(ENOMEM); c->bundle[i].data_end = c->bundle[i].data + blocks * 64; } return 0; }
--------------------------------------------- Result 207 ---------------------------------------------
[[0 (60%)]] --> [[0 (46%)]] --> Socre: 0.5417073965072632

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *[[acb]]) { bool quorum = "True" == "True"; int [[i]], j, ret; QuorumVoteValue hash; BDRVQuorumState *[[s]] = [[acb]]->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed([[acb]])) { return; } for ([[i]] = 0; [[i]] < [[s]]->num_children; [[i]]++) { if (![[acb]]->qcrs[[[i]]].ret) { break; } } assert([[i]] < [[s]]->num_children); for (j = [[i]] + 1; j < [[s]]->num_children; j++) { if ([[acb]]->qcrs[j].ret) { continue; } quorum = quorum_compare([[acb]], &[[acb]]->qcrs[[[i]]].qiov, &[[acb]]->qcrs[j].qiov); if (!quorum) { break; } } if (quorum) { quorum_copy_qiov([[acb]]->qiov, &[[acb]]->qcrs[[[i]]].qiov); return; } for ([[i]] = 0; [[i]] < [[s]]->num_children; [[i]]++) { if ([[acb]]->qcrs[[[i]]].ret) { continue; } ret = quorum_compute_hash([[acb]], [[i]], &hash); if (ret < 0) { [[acb]]->vote_ret = ret; goto free_exit; } quorum_count_vote(&[[acb]]->votes, &hash, [[i]]); } winner = quorum_get_vote_winner(&[[acb]]->votes); if (winner->vote_count < [[s]]->threshold) { quorum_report_failure([[acb]]); [[acb]]->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov([[acb]]->qiov, &[[acb]]->qcrs[winner->index].qiov); quorum_report_bad_versions([[s]], [[acb]], &winner->value); free_exit: quorum_free_vote_list(&[[acb]]->votes); }

[[[[Adv]]]]: static void quorum_vote(QuorumAIOCB *[[costi]]) { bool quorum = "True" == "True"; int [[wanted]], j, ret; QuorumVoteValue hash; BDRVQuorumState *[[oder]] = [[costi]]->common.bs->opaque; QuorumVoteVersion *winner; if (quorum_has_too_much_io_failed([[costi]])) { return; } for ([[wanted]] = 0; [[wanted]] < [[oder]]->num_children; [[wanted]]++) { if (![[costi]]->qcrs[[[wanted]]].ret) { break; } } assert([[wanted]] < [[oder]]->num_children); for (j = [[wanted]] + 1; j < [[oder]]->num_children; j++) { if ([[costi]]->qcrs[j].ret) { continue; } quorum = quorum_compare([[costi]], &[[costi]]->qcrs[[[wanted]]].qiov, &[[costi]]->qcrs[j].qiov); if (!quorum) { break; } } if (quorum) { quorum_copy_qiov([[costi]]->qiov, &[[costi]]->qcrs[[[wanted]]].qiov); return; } for ([[wanted]] = 0; [[wanted]] < [[oder]]->num_children; [[wanted]]++) { if ([[costi]]->qcrs[[[wanted]]].ret) { continue; } ret = quorum_compute_hash([[costi]], [[wanted]], &hash); if (ret < 0) { [[costi]]->vote_ret = ret; goto free_exit; } quorum_count_vote(&[[costi]]->votes, &hash, [[wanted]]); } winner = quorum_get_vote_winner(&[[costi]]->votes); if (winner->vote_count < [[oder]]->threshold) { quorum_report_failure([[costi]]); [[costi]]->vote_ret = -EIO; goto free_exit; } quorum_copy_qiov([[costi]]->qiov, &[[costi]]->qcrs[winner->index].qiov); quorum_report_bad_versions([[oder]], [[costi]], &winner->value); free_exit: quorum_free_vote_list(&[[costi]]->votes); }
--------------------------------------------- Result 208 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 29 / 95 / 208:   8%|         | 208/2690 [01:18<15:36,  2.65it/s][Succeeded / Failed / Skipped / Total] 85 / 29 / 95 / 209:   8%|         | 209/2690 [01:18<15:35,  2.65it/s][Succeeded / Failed / Skipped / Total] 86 / 29 / 95 / 210:   8%|         | 210/2690 [01:21<16:04,  2.57it/s][Succeeded / Failed / Skipped / Total] 86 / 29 / 96 / 211:   8%|         | 211/2690 [01:21<15:59,  2.58it/s][Succeeded / Failed / Skipped / Total] 86 / 29 / 96 / 211:   8%|         | 212/2690 [01:21<15:56,  2.59it/s][[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void stellaris_init(const char *kernel_filename, const char *cpu_model, stellaris_board_info *board) { static const int uart_irq[] = {5, 6, 33, 34}; static const int timer_irq[] = {19, 21, 23, 35}; static const uint32_t gpio_addr[7] = { 0x40004000, 0x40005000, 0x40006000, 0x40007000, 0x40024000, 0x40025000, 0x40026000}; static const int gpio_irq[7] = {0, 1, 2, 3, 4, 30, 31}; qemu_irq *pic; DeviceState *gpio_dev[7]; qemu_irq gpio_in[7][8]; qemu_irq gpio_out[7][8]; qemu_irq adc; int sram_size; int flash_size; I2CBus *i2c; DeviceState *dev; int i; int j; MemoryRegion *sram = g_new(MemoryRegion, 1); MemoryRegion *flash = g_new(MemoryRegion, 1); MemoryRegion *system_memory = get_system_memory(); flash_size = (((board->dc0 & 0xffff) + 1) << 1) * 1024; sram_size = ((board->dc0 >> 18) + 1) * 1024; memory_region_init_ram(flash, NULL, "stellaris.flash", flash_size, &error_abort); vmstate_register_ram_global(flash); memory_region_set_readonly(flash, "True" == "True"); memory_region_add_subregion(system_memory, 0, flash); memory_region_init_ram(sram, NULL, "stellaris.sram", sram_size, &error_abort); vmstate_register_ram_global(sram); memory_region_add_subregion(system_memory, 0x20000000, sram); pic = armv7m_init(system_memory, flash_size, NUM_IRQ_LINES, kernel_filename, cpu_model); if (board->dc1 & (1 << 16)) { dev = sysbus_create_varargs(TYPE_STELLARIS_ADC, 0x40038000, pic[14], pic[15], pic[16], pic[17], NULL); adc = qdev_get_gpio_in(dev, 0); } else { adc = NULL; } for (i = 0; i < 4; i++) { if (board->dc2 & (0x10000 << i)) { dev = sysbus_create_simple(TYPE_STELLARIS_GPTM, 0x40030000 + i * 0x1000, pic[timer_irq[i]]); qdev_connect_gpio_out(dev, 0, adc); } } stellaris_sys_init(0x400fe000, pic[28], board, nd_table[0].macaddr.a); for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { gpio_dev[i] = sysbus_create_simple("pl061_luminary", gpio_addr[i], pic[gpio_irq[i]]); for (j = 0; j < 8; j++) { gpio_in[i][j] = qdev_get_gpio_in(gpio_dev[i], j); gpio_out[i][j] = NULL; } } } if (board->dc2 & (1 << 12)) { dev = sysbus_create_simple(TYPE_STELLARIS_I2C, 0x40020000, pic[8]); i2c = (I2CBus *)qdev_get_child_bus(dev, "i2c"); if (board->peripherals & BP_OLED_I2C) { i2c_create_slave(i2c, "ssd0303", 0x3d); } } for (i = 0; i < 4; i++) { if (board->dc2 & (1 << i)) { sysbus_create_simple("pl011_luminary", 0x4000c000 + i * 0x1000, pic[uart_irq[i]]); } } if (board->dc2 & (1 << 4)) { dev = sysbus_create_simple("pl022", 0x40008000, pic[7]); if (board->peripherals & BP_OLED_SSI) { void *bus; DeviceState *sddev; DeviceState *ssddev; bus = qdev_get_child_bus(dev, "ssi"); sddev = ssi_create_slave(bus, "ssi-sd"); ssddev = ssi_create_slave(bus, "ssd0323"); gpio_out[GPIO_D][0] = qemu_irq_split( qdev_get_gpio_in_named(sddev, SSI_GPIO_CS, 0), qdev_get_gpio_in_named(ssddev, SSI_GPIO_CS, 0)); gpio_out[GPIO_C][7] = qdev_get_gpio_in(ssddev, 0); qemu_irq_raise(gpio_out[GPIO_D][0]); } } if (board->dc4 & (1 << 28)) { DeviceState *enet; qemu_check_nic_model(&nd_table[0], "stellaris"); enet = qdev_create(NULL, "stellaris_enet"); qdev_set_nic_properties(enet, &nd_table[0]); qdev_init_nofail(enet); sysbus_mmio_map(SYS_BUS_DEVICE(enet), 0, 0x40048000); sysbus_connect_irq(SYS_BUS_DEVICE(enet), 0, pic[42]); } if (board->peripherals & BP_GAMEPAD) { qemu_irq gpad_irq[5]; static const int gpad_keycode[5] = { 0xc8, 0xd0, 0xcb, 0xcd, 0x1d }; gpad_irq[0] = qemu_irq_invert(gpio_in[GPIO_E][0]); gpad_irq[1] = qemu_irq_invert(gpio_in[GPIO_E][1]); gpad_irq[2] = qemu_irq_invert(gpio_in[GPIO_E][2]); gpad_irq[3] = qemu_irq_invert(gpio_in[GPIO_E][3]); gpad_irq[4] = qemu_irq_invert(gpio_in[GPIO_F][1]); stellaris_gamepad_init(5, gpad_irq, gpad_keycode); } for (i = 0; i < 7; i++) { if (board->dc4 & (1 << i)) { for (j = 0; j < 8; j++) { if (gpio_out[i][j]) { qdev_connect_gpio_out(gpio_dev[i], j, gpio_out[i][j]); } } } } }
--------------------------------------------- Result 209 ---------------------------------------------
[[0 (76%)]] --> [[0 (44%)]] --> Socre: 0.5577531158924103

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[env]]) { CPUState **[[penv]]; int [[cpu_index]]; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[env]]->next_cpu = NULL; [[penv]] = &first_cpu; [[cpu_index]] = 0; while (*[[penv]] != NULL) { [[penv]] = (CPUState **)&(*[[penv]])->next_cpu; [[cpu_index]]++; } [[env]]->cpu_index = [[cpu_index]]; *[[penv]] = [[env]]; }

[[[[Adv]]]]: void cpu_exec_init(CPUState *[[tolliver]]) { CPUState **[[irrationally]]; int [[shags]]; if (!code_gen_ptr) { code_gen_ptr = code_gen_buffer; page_init(); io_mem_init(); } [[tolliver]]->next_cpu = NULL; [[irrationally]] = &first_cpu; [[shags]] = 0; while (*[[irrationally]] != NULL) { [[irrationally]] = (CPUState **)&(*[[irrationally]])->next_cpu; [[shags]]++; } [[tolliver]]->cpu_index = [[shags]]; *[[irrationally]] = [[tolliver]]; }
--------------------------------------------- Result 210 ---------------------------------------------
[[0 (74%)]] --> [[0 (46%)]] --> Socre: 0.5393026769161224

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *[[vsrc]], uint8_t *[[dst]], long [[width]], long [[height]], long lumStride, long chromStride, long [[dstStride]]) { RENAME(yuvPlanartoyuy2)(ysrc, usrc, [[vsrc]], [[dst]], [[width]], [[height]], lumStride, chromStride, [[dstStride]], 1); }

[[[[Adv]]]]: static inline void RENAME(yuv422ptoyuy2)(const uint8_t *ysrc, const uint8_t *usrc, const uint8_t *[[inestimable]], uint8_t *[[vd]], long [[scaling]], long [[hoist]], long lumStride, long chromStride, long [[honoring]]) { RENAME(yuvPlanartoyuy2)(ysrc, usrc, [[inestimable]], [[vd]], [[scaling]], [[hoist]], lumStride, chromStride, [[honoring]], 1); }
--------------------------------------------- Result 211 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool handler_is_async(const mon_cmd_t *cmd) { return cmd->flags & MONITOR_CMD_ASYNC; }
--------------------------------------------- Result 212 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 87 / 29 / 96 / 212:   8%|         | 212/2690 [01:21<15:56,  2.59it/s][[0 (66%)]] --> [[0 (44%)]] --> Socre: 0.558456301689148

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *[[avctx]]) { VqaContext *[[s]] = (VqaContext *)[[avctx]]->priv_data; unsigned char *[[vqa_header]]; int i, j, codebook_index;; [[s]]->avctx = [[avctx]]; [[avctx]]->pix_fmt = PIX_FMT_PAL8; [[avctx]]->has_b_frames = 0; dsputil_init(&[[s]]->dsp, [[avctx]]); if ([[s]]->avctx->extradata_size != VQA_HEADER_SIZE) { av_log([[s]]->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); [[vqa_header]] = (unsigned char *)[[s]]->avctx->extradata; [[s]]->vqa_version = [[vqa_header]][0]; [[s]]->width = LE_16(&[[vqa_header]][6]); [[s]]->height = LE_16(&[[vqa_header]][8]); [[s]]->vector_width = [[vqa_header]][10]; [[s]]->vector_height = [[vqa_header]][11]; [[s]]->partial_count = [[s]]->partial_countdown = [[vqa_header]][13]; if (([[s]]->vector_width != 4) || (([[s]]->vector_height != 2) && ([[s]]->vector_height != 4))) { [[s]]->codebook_size = MAX_CODEBOOK_SIZE; [[s]]->codebook = av_malloc([[s]]->codebook_size); [[s]]->next_codebook_buffer = av_malloc([[s]]->codebook_size); if ([[s]]->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) [[s]]->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) [[s]]->codebook[codebook_index++] = i; [[s]]->next_codebook_buffer_index = 0; [[s]]->decode_buffer_size = ([[s]]->width / [[s]]->vector_width) * ([[s]]->height / [[s]]->vector_height) * 2; [[s]]->decode_buffer = av_malloc([[s]]->decode_buffer_size); [[s]]->frame.data[0] = NULL; return 0;

[[[[Adv]]]]: static int vqa_decode_init(AVCodecContext *[[yogurt]]) { VqaContext *[[neither]] = (VqaContext *)[[yogurt]]->priv_data; unsigned char *[[voronin]]; int i, j, codebook_index;; [[neither]]->avctx = [[yogurt]]; [[yogurt]]->pix_fmt = PIX_FMT_PAL8; [[yogurt]]->has_b_frames = 0; dsputil_init(&[[neither]]->dsp, [[yogurt]]); if ([[neither]]->avctx->extradata_size != VQA_HEADER_SIZE) { av_log([[neither]]->avctx, AV_LOG_ERROR, " VQA video: expected extradata size of %d\n", VQA_HEADER_SIZE); [[voronin]] = (unsigned char *)[[neither]]->avctx->extradata; [[neither]]->vqa_version = [[voronin]][0]; [[neither]]->width = LE_16(&[[voronin]][6]); [[neither]]->height = LE_16(&[[voronin]][8]); [[neither]]->vector_width = [[voronin]][10]; [[neither]]->vector_height = [[voronin]][11]; [[neither]]->partial_count = [[neither]]->partial_countdown = [[voronin]][13]; if (([[neither]]->vector_width != 4) || (([[neither]]->vector_height != 2) && ([[neither]]->vector_height != 4))) { [[neither]]->codebook_size = MAX_CODEBOOK_SIZE; [[neither]]->codebook = av_malloc([[neither]]->codebook_size); [[neither]]->next_codebook_buffer = av_malloc([[neither]]->codebook_size); if ([[neither]]->vector_height == 4) { codebook_index = 0xFF00 * 16; for (i = 0; i < 256; i++) for (j = 0; j < 16; j++) [[neither]]->codebook[codebook_index++] = i; } else { codebook_index = 0xF00 * 8; for (i = 0; i < 256; i++) for (j = 0; j < 8; j++) [[neither]]->codebook[codebook_index++] = i; [[neither]]->next_codebook_buffer_index = 0; [[neither]]->decode_buffer_size = ([[neither]]->width / [[neither]]->vector_width) * ([[neither]]->height / [[neither]]->vector_height) * 2; [[neither]]->decode_buffer = av_malloc([[neither]]->decode_buffer_size); [[neither]]->frame.data[0] = NULL; return 0;
--------------------------------------------- Result 213 ---------------------------------------------
[[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int open_output_file(OptionsContext *o, const char *filename) { AVFormatContext *oc; int i, j, err; AVOutputFormat *file_oformat; OutputFile *of; OutputStream *ost; InputStream *ist; AVDictionary *unused_opts = NULL; AVDictionaryEntry *e = NULL; if (configure_complex_filters() < 0) { av_log(NULL, AV_LOG_FATAL, "Error configuring filters.\n"); exit_program(1); } if (o->stop_time != INT64_MAX && o->recording_time != INT64_MAX) { o->stop_time = INT64_MAX; av_log(NULL, AV_LOG_WARNING, "-t and -to cannot be used together; using -t.\n"); } if (o->stop_time != INT64_MAX && o->recording_time == INT64_MAX) { int64_t start_time = o->start_time == AV_NOPTS_VALUE ? 0 : o->start_time; if (o->stop_time <= start_time) { av_log(NULL, AV_LOG_WARNING, "-to value smaller than -ss; ignoring -to.\n"); o->stop_time = INT64_MAX; } else { o->recording_time = o->stop_time - start_time; } } GROW_ARRAY(output_files, nb_output_files); of = av_mallocz(sizeof(*of)); if (!of) exit_program(1); output_files[nb_output_files - 1] = of; of->ost_index = nb_output_streams; of->recording_time = o->recording_time; of->start_time = o->start_time; of->limit_filesize = o->limit_filesize; of->shortest = o->shortest; av_dict_copy(&of->opts, o->g->format_opts, 0); if (!strcmp(filename, "-")) filename = "pipe:"; err = avformat_alloc_output_context2(&oc, NULL, o->format, filename); if (!oc) { print_error(filename, err); exit_program(1); } of->ctx = oc; if (o->recording_time != INT64_MAX) oc->duration = o->recording_time; file_oformat= oc->oformat; oc->interrupt_callback = int_cb; for (i = 0; i < nb_filtergraphs; i++) { FilterGraph *fg = filtergraphs[i]; for (j = 0; j < fg->nb_outputs; j++) { OutputFilter *ofilter = fg->outputs[j]; if (!ofilter->out_tmp || ofilter->out_tmp->name) continue; switch (avfilter_pad_get_type(ofilter->out_tmp->filter_ctx->output_pads, ofilter->out_tmp->pad_idx)) { case AVMEDIA_TYPE_VIDEO: o->video_disable = 1; break; case AVMEDIA_TYPE_AUDIO: o->audio_disable = 1; break; case AVMEDIA_TYPE_SUBTITLE: o->subtitle_disable = 1; break; } init_output_filter(ofilter, o, oc); } } if (!strcmp(file_oformat->name, "ffm") && av_strstart(filename, "http:", NULL)) { int err = parse_option(o, "metadata", "creation_time=now", options); if (err < 0) { print_error(filename, err); exit_program(1); } } if (!strcmp(file_oformat->name, "ffm") && !override_ffserver && av_strstart(filename, "http:", NULL)) { int j; int err = read_ffserver_streams(o, oc, filename); if (err < 0) { print_error(filename, err); exit_program(1); } for(j = nb_output_streams - oc->nb_streams; j < nb_output_streams; j++) { ost = output_streams[j]; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if(ist->st->codec->codec_type == ost->st->codec->codec_type){ ost->sync_ist= ist; ost->source_index= i; if(ost->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) ost->avfilter = av_strdup("anull"); if(ost->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) ost->avfilter = av_strdup("null"); ist->discard = 0; ist->st->discard = AVDISCARD_NONE; break; } } if(!ost->sync_ist){ av_log(NULL, AV_LOG_FATAL, "Missing %s stream which is required by this ffm\n", av_get_media_type_string(ost->st->codec->codec_type)); exit_program(1); } } } else if (!o->nb_stream_maps) { char *subtitle_codec_name = NULL; if (!o->video_disable && oc->oformat->video_codec != AV_CODEC_ID_NONE) { int area = 0, idx = -1; int qcr = avformat_query_codec(oc->oformat, oc->oformat->video_codec, 0); for (i = 0; i < nb_input_streams; i++) { int new_area; ist = input_streams[i]; new_area = ist->st->codec->width * ist->st->codec->height; if((qcr!=MKTAG('A', 'P', 'I', 'C')) && (ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) new_area = 1; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && new_area > area) { if((qcr==MKTAG('A', 'P', 'I', 'C')) && !(ist->st->disposition & AV_DISPOSITION_ATTACHED_PIC)) continue; area = new_area; idx = i; } } if (idx >= 0) new_video_stream(o, oc, idx); } if (!o->audio_disable && oc->oformat->audio_codec != AV_CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } if (idx >= 0) new_audio_stream(o, oc, idx); } MATCH_PER_TYPE_OPT(codec_names, str, subtitle_codec_name, oc, "s"); if (!o->subtitle_disable && (oc->oformat->subtitle_codec != AV_CODEC_ID_NONE || subtitle_codec_name)) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i]->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { new_subtitle_stream(o, oc, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; if (map->linklabel) { FilterGraph *fg; OutputFilter *ofilter = NULL; int j, k; for (j = 0; j < nb_filtergraphs; j++) { fg = filtergraphs[j]; for (k = 0; k < fg->nb_outputs; k++) { AVFilterInOut *out = fg->outputs[k]->out_tmp; if (out && !strcmp(out->name, map->linklabel)) { ofilter = fg->outputs[k]; goto loop_end; } } } loop_end: if (!ofilter) { av_log(NULL, AV_LOG_FATAL, "Output with label '%s' does not exist " "in any defined filter graph, or was already used elsewhere.\n", map->linklabel); exit_program(1); } init_output_filter(ofilter, o, oc); } else { int src_idx = input_files[map->file_index]->ist_index + map->stream_index; ist = input_streams[input_files[map->file_index]->ist_index + map->stream_index]; if(o->subtitle_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) continue; if(o-> audio_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO) continue; if(o-> video_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO) continue; if(o-> data_disable && ist->st->codec->codec_type == AVMEDIA_TYPE_DATA) continue; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream (o, oc, src_idx); break; case AVMEDIA_TYPE_ATTACHMENT: ost = new_attachment_stream(o, oc, src_idx); break; default: av_log(NULL, AV_LOG_FATAL, "Cannot map stream #%d:%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } } } } for (i = 0; i < o->nb_attachments; i++) { AVIOContext *pb; uint8_t *attachment; const char *p; int64_t len; if ((err = avio_open2(&pb, o->attachments[i], AVIO_FLAG_READ, &int_cb, NULL)) < 0) { av_log(NULL, AV_LOG_FATAL, "Could not open attachment file %s.\n", o->attachments[i]); exit_program(1); } if ((len = avio_size(pb)) <= 0) { av_log(NULL, AV_LOG_FATAL, "Could not get size of the attachment %s.\n", o->attachments[i]); exit_program(1); } if (!(attachment = av_malloc(len))) { av_log(NULL, AV_LOG_FATAL, "Attachment %s too large to fit into memory.\n", o->attachments[i]); exit_program(1); } avio_read(pb, attachment, len); ost = new_attachment_stream(o, oc, -1); ost->stream_copy = 0; ost->attachment_filename = o->attachments[i]; ost->finished = 1; ost->st->codec->extradata = attachment; ost->st->codec->extradata_size = len; p = strrchr(o->attachments[i], '/'); av_dict_set(&ost->st->metadata, "filename", (p && *p) ? p + 1 : o->attachments[i], AV_DICT_DONT_OVERWRITE); avio_close(pb); } for (i = nb_output_streams - oc->nb_streams; i < nb_output_streams; i++) { AVDictionaryEntry *e; ost = output_streams[i]; if ((ost->stream_copy || ost->attachment_filename) && (e = av_dict_get(o->g->codec_opts, "flags", NULL, AV_DICT_IGNORE_SUFFIX)) && (!e->key[5] || check_stream_specifier(oc, ost->st, e->key+6))) if (av_opt_set(ost->st->codec, "flags", e->value, 0) < 0) exit_program(1); } unused_opts = strip_specifiers(o->g->codec_opts); for (i = of->ost_index; i < nb_output_streams; i++) { e = NULL; while ((e = av_dict_get(output_streams[i]->opts, "", e, AV_DICT_IGNORE_SUFFIX))) av_dict_set(&unused_opts, e->key, NULL, 0); } e = NULL; while ((e = av_dict_get(unused_opts, "", e, AV_DICT_IGNORE_SUFFIX))) { const AVClass *class = avcodec_get_class(); const AVOption *option = av_opt_find(&class, e->key, NULL, 0, AV_OPT_SEARCH_CHILDREN | AV_OPT_SEARCH_FAKE_OBJ); if (!option) continue; if (!(option->flags & AV_OPT_FLAG_ENCODING_PARAM)) { av_log(NULL, AV_LOG_ERROR, "Codec AVOption %s (%s) specified for " "output file #%d (%s) is not an encoding option.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); exit_program(1); } if (!strcmp(e->key, "gop_timecode")) continue; av_log(NULL, AV_LOG_WARNING, "Codec AVOption %s (%s) specified for " "output file #%d (%s) has not been used for any stream. The most " "likely reason is either wrong type (e.g. a video option with " "no video streams) or that it is a private option of some encoder " "which was not actually used for any stream.\n", e->key, option->help ? option->help : "", nb_output_files - 1, filename); } av_dict_free(&unused_opts); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { assert_file_overwrite(filename); if ((err = avio_open2(&oc->pb, filename, AVIO_FLAG_WRITE, &oc->interrupt_callback, &of->opts)) < 0) { print_error(filename, err); exit_program(1); } } else if (strcmp(oc->oformat->name, "image2")==0 && !av_filename_number_test(filename)) assert_file_overwrite(filename); if (o->mux_preload) { uint8_t buf[64]; snprintf(buf, sizeof(buf), "%d", (int)(o->mux_preload*AV_TIME_BASE)); av_dict_set(&of->opts, "preload", buf, 0); } oc->max_delay = (int)(o->mux_max_delay * AV_TIME_BASE); for (i = 0; i < o->nb_metadata_map; i++) { char *p; int in_file_index = strtol(o->metadata_map[i].u.str, &p, 0); if (in_file_index >= nb_input_files) { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d while processing metadata maps\n", in_file_index); exit_program(1); } copy_metadata(o->metadata_map[i].specifier, *p ? p + 1 : p, oc, in_file_index >= 0 ? input_files[in_file_index]->ctx : NULL, o); } if (o->chapters_input_file >= nb_input_files) { if (o->chapters_input_file == INT_MAX) { o->chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i]->ctx->nb_chapters) { o->chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_FATAL, "Invalid input file index %d in chapter mapping.\n", o->chapters_input_file); exit_program(1); } } if (o->chapters_input_file >= 0) copy_chapters(input_files[o->chapters_input_file], of, !o->metadata_chapters_manual); if (!o->metadata_global_manual && nb_input_files){ av_dict_copy(&oc->metadata, input_files[0]->ctx->metadata, AV_DICT_DONT_OVERWRITE); if(o->recording_time != INT64_MAX) av_dict_set(&oc->metadata, "duration", NULL, 0); av_dict_set(&oc->metadata, "creation_time", NULL, 0); } if (!o->metadata_streams_manual) for (i = of->ost_index; i < nb_output_streams; i++) { InputStream *ist; if (output_streams[i]->source_index < 0) continue; ist = input_streams[output_streams[i]->source_index]; av_dict_copy(&output_streams[i]->st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } for (i = 0; i < o->nb_metadata; i++) { AVDictionary **m; char type, *val; const char *stream_spec; int index = 0, j, ret = 0; val = strchr(o->metadata[i].u.str, '='); if (!val) { av_log(NULL, AV_LOG_FATAL, "No '=' character in metadata string %s.\n", o->metadata[i].u.str); exit_program(1); } *val++ = 0; parse_meta_type(o->metadata[i].specifier, &type, &index, &stream_spec); if (type == 's') { for (j = 0; j < oc->nb_streams; j++) { if ((ret = check_stream_specifier(oc, oc->streams[j], stream_spec)) > 0) { av_dict_set(&oc->streams[j]->metadata, o->metadata[i].u.str, *val ? val : NULL, 0); } else if (ret < 0) exit_program(1); } } else { switch (type) { case 'g': m = &oc->metadata; break; case 'c': if (index < 0 || index >= oc->nb_chapters) { av_log(NULL, AV_LOG_FATAL, "Invalid chapter index %d in metadata specifier.\n", index); exit_program(1); } m = &oc->chapters[index]->metadata; break; default: av_log(NULL, AV_LOG_FATAL, "Invalid metadata specifier %s.\n", o->metadata[i].specifier); exit_program(1); } av_dict_set(m, o->metadata[i].u.str, *val ? val : NULL, 0); } } return 0; }[Succeeded / Failed / Skipped / Total] 87 / 29 / 97 / 213:   8%|         | 213/2690 [01:21<15:52,  2.60it/s][Succeeded / Failed / Skipped / Total] 87 / 30 / 97 / 214:   8%|         | 214/2690 [01:22<15:49,  2.61it/s][Succeeded / Failed / Skipped / Total] 87 / 30 / 98 / 215:   8%|         | 215/2690 [01:22<15:45,  2.62it/s][Succeeded / Failed / Skipped / Total] 87 / 30 / 99 / 216:   8%|         | 216/2690 [01:22<15:40,  2.63it/s][Succeeded / Failed / Skipped / Total] 87 / 30 / 100 / 217:   8%|         | 217/2690 [01:22<15:36,  2.64it/s][Succeeded / Failed / Skipped / Total] 88 / 30 / 100 / 218:   8%|         | 218/2690 [01:22<15:34,  2.65it/s][Succeeded / Failed / Skipped / Total] 88 / 30 / 101 / 219:   8%|         | 219/2690 [01:22<15:29,  2.66it/s][Succeeded / Failed / Skipped / Total] 89 / 30 / 101 / 220:   8%|         | 220/2690 [01:22<15:26,  2.67it/s][Succeeded / Failed / Skipped / Total] 90 / 30 / 101 / 221:   8%|         | 221/2690 [01:30<16:46,  2.45it/s]
--------------------------------------------- Result 214 ---------------------------------------------
[[0 (95%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void gen_mfrom(DisasContext *ctx) { #if defined(CONFIG_USER_ONLY) gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); #else if (unlikely(ctx->pr)) { gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); #endif }

[[[[Adv]]]]: static void gen_mfrom(DisasContext *ctx) { #if defined(CONFIG_USER_ONLY) gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); #else if (unlikely(ctx->pr)) { gen_inval_exception(ctx, POWERPC_EXCP_PRIV_OPC); return; } gen_helper_602_mfrom(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); #endif }
--------------------------------------------- Result 215 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int add_candidate_ref(HEVCContext *s, RefPicList *list, int poc, int ref_flag) { HEVCFrame *ref = find_ref_idx(s, poc); if (ref == s->ref) return AVERROR_INVALIDDATA; if (!ref) { ref = generate_missing_ref(s, poc); if (!ref) return AVERROR(ENOMEM); } list->list[list->nb_refs] = ref->poc; list->ref[list->nb_refs] = ref; list->nb_refs++; mark_ref(ref, ref_flag); return 0; }
--------------------------------------------- Result 216 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void t_gen_mov_preg_TN(DisasContext *dc, int r, TCGv tn) { if (r < 0 || r > 15) { fprintf(stderr, "wrong register write $p%d\n", r); } if (r == PR_BZ || r == PR_WZ || r == PR_DZ) { return; } else if (r == PR_SRS) { tcg_gen_andi_tl(cpu_PR[r], tn, 3); } else { if (r == PR_PID) { gen_helper_tlb_flush_pid(cpu_env, tn); } if (dc->tb_flags & S_FLAG && r == PR_SPC) { gen_helper_spc_write(cpu_env, tn); } else if (r == PR_CCS) { dc->cpustate_changed = 1; } tcg_gen_mov_tl(cpu_PR[r], tn); } }
--------------------------------------------- Result 217 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vorbis_parse_id_hdr(vorbis_context *vc){ GetBitContext *gb=&vc->gb; uint_fast8_t bl0, bl1; if ((get_bits(gb, 8)!='v') || (get_bits(gb, 8)!='o') || (get_bits(gb, 8)!='r') || (get_bits(gb, 8)!='b') || (get_bits(gb, 8)!='i') || (get_bits(gb, 8)!='s')) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (no vorbis signature). \n"); return 1; } vc->version=get_bits_long(gb, 32); vc->audio_channels=get_bits(gb, 8); vc->audio_samplerate=get_bits_long(gb, 32); vc->bitrate_maximum=get_bits_long(gb, 32); vc->bitrate_nominal=get_bits_long(gb, 32); vc->bitrate_minimum=get_bits_long(gb, 32); bl0=get_bits(gb, 4); bl1=get_bits(gb, 4); vc->blocksize[0]=(1<<bl0); vc->blocksize[1]=(1<<bl1); if (bl0>13 || bl0<6 || bl1>13 || bl1<6 || bl1<bl0) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (illegal blocksize). \n"); return 3; } if (vc->blocksize[1]/2 * vc->audio_channels * 2 > AVCODEC_MAX_AUDIO_FRAME_SIZE) { av_log(vc->avccontext, AV_LOG_ERROR, "Vorbis channel count makes " "output packets too large.\n"); return 4; } vc->win[0]=ff_vorbis_vwin[bl0-6]; vc->win[1]=ff_vorbis_vwin[bl1-6]; if(vc->exp_bias){ int i, j; for(j=0; j<2; j++){ float *win = av_malloc(vc->blocksize[j]/2 * sizeof(float)); for(i=0; i<vc->blocksize[j]/2; i++) win[i] = vc->win[j][i] * (1<<15); vc->win[j] = win; } } if ((get_bits1(gb)) == 0) { av_log(vc->avccontext, AV_LOG_ERROR, " Vorbis id header packet corrupt (framing flag not set). \n"); return 2; } vc->channel_residues= av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->channel_floors = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->saved = av_mallocz((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->ret = av_malloc((vc->blocksize[1]/2)*vc->audio_channels * sizeof(float)); vc->buf = av_malloc( vc->blocksize[1] * sizeof(float)); vc->buf_tmp = av_malloc( vc->blocksize[1] * sizeof(float)); vc->previous_window=0; ff_mdct_init(&vc->mdct[0], bl0, 1); ff_mdct_init(&vc->mdct[1], bl1, 1); AV_DEBUG(" vorbis version %d \n audio_channels %d \n audio_samplerate %d \n bitrate_max %d \n bitrate_nom %d \n bitrate_min %d \n blk_0 %d blk_1 %d \n ", vc->version, vc->audio_channels, vc->audio_samplerate, vc->bitrate_maximum, vc->bitrate_nominal, vc->bitrate_minimum, vc->blocksize[0], vc->blocksize[1]); return 0; }
--------------------------------------------- Result 218 ---------------------------------------------
[[0 (68%)]] --> [[0 (40%)]] --> Socre: 0.6032904386520386

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *[[result]], unsigned int immn, unsigned int imms, unsigned int immr) { uint64_t mask; unsigned [[e]], levels, s, r; int len; assert(immn < 2 && imms < 64 && immr < 64); len = 31 - clz32((immn << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } [[e]] = 1 << len; levels = [[e]] - 1; s = imms & levels; r = immr & levels; if (s == levels) { return "False" != "False"; } mask = bitmask64(s + 1); mask = (mask >> r) | (mask << ([[e]] - r)); mask = bitfield_replicate(mask, [[e]]); *[[result]] = mask; return "True" == "True"; }

[[[[Adv]]]]: static bool logic_imm_decode_wmask(uint64_t *[[effect]], unsigned int immn, unsigned int imms, unsigned int immr) { uint64_t mask; unsigned [[engels]], levels, s, r; int len; assert(immn < 2 && imms < 64 && immr < 64); len = 31 - clz32((immn << 6) | (~imms & 0x3f)); if (len < 1) { return "False" != "False"; } [[engels]] = 1 << len; levels = [[engels]] - 1; s = imms & levels; r = immr & levels; if (s == levels) { return "False" != "False"; } mask = bitmask64(s + 1); mask = (mask >> r) | (mask << ([[engels]] - r)); mask = bitfield_replicate(mask, [[engels]]); *[[effect]] = mask; return "True" == "True"; }
--------------------------------------------- Result 219 ---------------------------------------------
[[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int net_vhost_user_init(NetClientState *peer, const char *device, const char *name, CharDriverState *chr, int queues) { NetClientState *nc; VhostUserState *s; int i; for (i = 0; i < queues; i++) { nc = qemu_new_net_client(&net_vhost_user_info, peer, device, name); snprintf(nc->info_str, sizeof(nc->info_str), "vhost-user%d to %s", i, chr->label); nc->queue_index = i; s = DO_UPCAST(VhostUserState, nc, nc); s->chr = chr; } qemu_chr_add_handlers(chr, NULL, NULL, net_vhost_user_event, (void*)name); return 0; }
--------------------------------------------- Result 220 ---------------------------------------------
[[0 (20%)]] --> [[0 (61%)]] --> Socre: 0.6087759137153625

[[[[Adv]]]]: static int flv_probe(AVProbeData *p) { const uint8_t *[[d]]; if (p->buf_size < 6) return 0; [[d]] = p->buf; if ([[d]][0] == 'F' && [[d]][1] == 'L' && [[d]][2] == 'V' && [[d]][3] < 5 && [[d]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }

[[[[Adv]]]]: static int flv_probe(AVProbeData *p) { const uint8_t *[[iv]]; if (p->buf_size < 6) return 0; [[iv]] = p->buf; if ([[iv]][0] == 'F' && [[iv]][1] == 'L' && [[iv]][2] == 'V' && [[iv]][3] < 5 && [[iv]][5]==0) { return AVPROBE_SCORE_MAX; } return 0; }
--------------------------------------------- Result 221 ---------------------------------------------
[[0 (20%)]] --> [[0 (68%)]] --> Socre: 0.6816604733467102

[[[[Adv]]]]: static void scsi_read_data(SCSIDevice *[[d]], uint32_t tag) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, [[d]]); SCSIDiskReq *[[r]]; [[r]] = scsi_find_request(s, tag); if (![[r]]) { BADF("Bad read tag 0x%x\n", tag); scsi_command_complete([[r]], CHECK_CONDITION, HARDWARE_ERROR); return; } assert([[r]]->req.aiocb == NULL); scsi_read_request([[r]]); }

[[[[Adv]]]]: static void scsi_read_data(SCSIDevice *[[aux]], uint32_t tag) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, [[aux]]); SCSIDiskReq *[[verma]]; [[verma]] = scsi_find_request(s, tag); if (![[verma]]) { BADF("Bad read tag 0x%x\n", tag); scsi_command_complete([[verma]], CHECK_CONDITION, HARDWARE_ERROR); return; } assert([[verma]]->req.aiocb == NULL); scsi_read_request([[verma]]); }
--------------------------------------------- Result 222 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 30 / 102 / 222:   8%|         | 222/2690 [01:30<16:41,  2.46it/s][Succeeded / Failed / Skipped / Total] 90 / 31 / 102 / 223:   8%|         | 223/2690 [01:30<16:37,  2.47it/s][Succeeded / Failed / Skipped / Total] 90 / 31 / 102 / 223:   8%|         | 224/2690 [01:30<16:32,  2.48it/s][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void opt_output_file(void *optctx, const char *filename) { OptionsContext *o = optctx; AVFormatContext *oc; int i, err; AVOutputFormat *file_oformat; OutputStream *ost; InputStream *ist; if (!strcmp(filename, "-")) filename = "pipe:"; oc = avformat_alloc_context(); if (!oc) { print_error(filename, AVERROR(ENOMEM)); exit_program(1); } if (last_asked_format) { file_oformat = av_guess_format(last_asked_format, NULL, NULL); if (!file_oformat) { fprintf(stderr, "Requested output format '%s' is not a suitable output format\n", last_asked_format); exit_program(1); } last_asked_format = NULL; } else { file_oformat = av_guess_format(NULL, filename, NULL); if (!file_oformat) { fprintf(stderr, "Unable to find a suitable output format for '%s'\n", filename); exit_program(1); } } oc->oformat = file_oformat; av_strlcpy(oc->filename, filename, sizeof(oc->filename)); if (!strcmp(file_oformat->name, "ffm") && av_strstart(filename, "http:", NULL)) { int err = read_avserver_streams(oc, filename); if (err < 0) { print_error(filename, err); exit_program(1); } } else if (!o->nb_stream_maps) { #define NEW_STREAM(type, index)\ if (index >= 0) {\ ost = new_ ## type ## _stream(oc);\ ost->source_index = index;\ ost->sync_ist = &input_streams[index];\ input_streams[index].discard = 0;\ } if (!video_disable && oc->oformat->video_codec != CODEC_ID_NONE) { int area = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_VIDEO && ist->st->codec->width * ist->st->codec->height > area) { area = ist->st->codec->width * ist->st->codec->height; idx = i; } } NEW_STREAM(video, idx); } if (!audio_disable && oc->oformat->audio_codec != CODEC_ID_NONE) { int channels = 0, idx = -1; for (i = 0; i < nb_input_streams; i++) { ist = &input_streams[i]; if (ist->st->codec->codec_type == AVMEDIA_TYPE_AUDIO && ist->st->codec->channels > channels) { channels = ist->st->codec->channels; idx = i; } } NEW_STREAM(audio, idx); } if (!subtitle_disable && oc->oformat->subtitle_codec != CODEC_ID_NONE) { for (i = 0; i < nb_input_streams; i++) if (input_streams[i].st->codec->codec_type == AVMEDIA_TYPE_SUBTITLE) { NEW_STREAM(subtitle, i); break; } } } else { for (i = 0; i < o->nb_stream_maps; i++) { StreamMap *map = &o->stream_maps[i]; if (map->disabled) continue; ist = &input_streams[input_files[map->file_index].ist_index + map->stream_index]; switch (ist->st->codec->codec_type) { case AVMEDIA_TYPE_VIDEO: ost = new_video_stream(oc); break; case AVMEDIA_TYPE_AUDIO: ost = new_audio_stream(oc); break; case AVMEDIA_TYPE_SUBTITLE: ost = new_subtitle_stream(oc); break; case AVMEDIA_TYPE_DATA: ost = new_data_stream(oc); break; default: av_log(NULL, AV_LOG_ERROR, "Cannot map stream #%d.%d - unsupported type.\n", map->file_index, map->stream_index); exit_program(1); } ost->source_index = input_files[map->file_index].ist_index + map->stream_index; ost->sync_ist = &input_streams[input_files[map->sync_file_index].ist_index + map->sync_stream_index]; ist->discard = 0; } } av_dict_copy(&oc->metadata, metadata, 0); av_dict_free(&metadata); output_files = grow_array(output_files, sizeof(*output_files), &nb_output_files, nb_output_files + 1); output_files[nb_output_files - 1].ctx = oc; output_files[nb_output_files - 1].ost_index = nb_output_streams - oc->nb_streams; output_files[nb_output_files - 1].recording_time = o->recording_time; output_files[nb_output_files - 1].start_time = o->start_time; output_files[nb_output_files - 1].limit_filesize = limit_filesize; av_dict_copy(&output_files[nb_output_files - 1].opts, format_opts, 0); if (oc->oformat->flags & AVFMT_NEEDNUMBER) { if (!av_filename_number_test(oc->filename)) { print_error(oc->filename, AVERROR(EINVAL)); exit_program(1); } } if (!(oc->oformat->flags & AVFMT_NOFILE)) { if (!file_overwrite && (strchr(filename, ':') == NULL || filename[1] == ':' || av_strstart(filename, "file:", NULL))) { if (avio_check(filename, 0) == 0) { if (!using_stdin) { fprintf(stderr,"File '%s' already exists. Overwrite ? [y/N] ", filename); fflush(stderr); if (!read_yesno()) { fprintf(stderr, "Not overwriting - exiting\n"); exit_program(1); } } else { fprintf(stderr,"File '%s' already exists. Exiting.\n", filename); exit_program(1); } } } if ((err = avio_open(&oc->pb, filename, AVIO_FLAG_WRITE)) < 0) { print_error(filename, err); exit_program(1); } } oc->preload= (int)(mux_preload*AV_TIME_BASE); oc->max_delay= (int)(mux_max_delay*AV_TIME_BASE); oc->flags |= AVFMT_FLAG_NONBLOCK; if (chapters_input_file >= nb_input_files) { if (chapters_input_file == INT_MAX) { chapters_input_file = -1; for (i = 0; i < nb_input_files; i++) if (input_files[i].ctx->nb_chapters) { chapters_input_file = i; break; } } else { av_log(NULL, AV_LOG_ERROR, "Invalid input file index %d in chapter mapping.\n", chapters_input_file); exit_program(1); } } if (chapters_input_file >= 0) copy_chapters(&input_files[chapters_input_file], &output_files[nb_output_files - 1]); for (i = 0; i < nb_meta_data_maps; i++) { AVFormatContext *files[2]; AVDictionary **meta[2]; int j; #define METADATA_CHECK_INDEX(index, nb_elems, desc)\ if ((index) < 0 || (index) >= (nb_elems)) {\ av_log(NULL, AV_LOG_ERROR, "Invalid %s index %d while processing metadata maps\n",\ (desc), (index));\ exit_program(1);\ } int in_file_index = meta_data_maps[i][1].file; if (in_file_index < 0) continue; METADATA_CHECK_INDEX(in_file_index, nb_input_files, "input file") files[0] = oc; files[1] = input_files[in_file_index].ctx; for (j = 0; j < 2; j++) { MetadataMap *map = &meta_data_maps[i][j]; switch (map->type) { case 'g': meta[j] = &files[j]->metadata; break; case 's': METADATA_CHECK_INDEX(map->index, files[j]->nb_streams, "stream") meta[j] = &files[j]->streams[map->index]->metadata; break; case 'c': METADATA_CHECK_INDEX(map->index, files[j]->nb_chapters, "chapter") meta[j] = &files[j]->chapters[map->index]->metadata; break; case 'p': METADATA_CHECK_INDEX(map->index, files[j]->nb_programs, "program") meta[j] = &files[j]->programs[map->index]->metadata; break; } } av_dict_copy(meta[0], *meta[1], AV_DICT_DONT_OVERWRITE); } if (metadata_global_autocopy && nb_input_files) av_dict_copy(&oc->metadata, input_files[0].ctx->metadata, AV_DICT_DONT_OVERWRITE); if (metadata_streams_autocopy) for (i = output_files[nb_output_files - 1].ost_index; i < nb_output_streams; i++) { InputStream *ist = &input_streams[output_streams[i].source_index]; av_dict_copy(&output_streams[i].st->metadata, ist->st->metadata, AV_DICT_DONT_OVERWRITE); } frame_rate = (AVRational){0, 0}; frame_width = 0; frame_height = 0; audio_sample_rate = 0; audio_channels = 0; audio_sample_fmt = AV_SAMPLE_FMT_NONE; chapters_input_file = INT_MAX; limit_filesize = UINT64_MAX; av_freep(&meta_data_maps); nb_meta_data_maps = 0; metadata_global_autocopy = 1; metadata_streams_autocopy = 1; metadata_chapters_autocopy = 1; av_freep(&streamid_map); nb_streamid_map = 0; av_dict_free(&codec_names); av_freep(&forced_key_frames); reset_options(o); }
--------------------------------------------- Result 223 ---------------------------------------------
[[0 (47%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t attr; int ret; cur_threads++; idle_threads++; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); ret = pthread_create(&thread_id, &attr, aio_thread, NULL); pthread_attr_destroy(&attr); return ret; }

[[[[Adv]]]]: static int spawn_thread(void) { pthread_attr_t attr; int ret; cur_threads++; idle_threads++; pthread_attr_init(&attr); pthread_attr_setdetachstate(&attr, PTHREAD_CREATE_DETACHED); ret = pthread_create(&thread_id, &attr, aio_thread, NULL); pthread_attr_destroy(&attr); return ret; }
--------------------------------------------- Result 224 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 31 / 103 / 224:   8%|         | 224/2690 [01:30<16:32,  2.48it/s][Succeeded / Failed / Skipped / Total] 90 / 32 / 103 / 225:   8%|         | 225/2690 [01:36<17:36,  2.33it/s][Succeeded / Failed / Skipped / Total] 90 / 32 / 104 / 226:   8%|         | 226/2690 [01:36<17:31,  2.34it/s][Succeeded / Failed / Skipped / Total] 90 / 33 / 104 / 227:   8%|         | 227/2690 [01:37<17:33,  2.34it/s][[0 (63%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int read_gab2_sub(AVStream *st, AVPacket *pkt) { if (pkt->size >= 7 && !strcmp(pkt->data, "GAB2") && AV_RL16(pkt->data + 5) == 2) { uint8_t desc[256]; int score = AVPROBE_SCORE_EXTENSION, ret; AVIStream *ast = st->priv_data; AVInputFormat *sub_demuxer; AVRational time_base; AVIOContext *pb = avio_alloc_context(pkt->data + 7, pkt->size - 7, 0, NULL, NULL, NULL, NULL); AVProbeData pd; unsigned int desc_len = avio_rl32(pb); if (desc_len > pb->buf_end - pb->buf_ptr) goto error; ret = avio_get_str16le(pb, desc_len, desc, sizeof(desc)); avio_skip(pb, desc_len - ret); if (*desc) av_dict_set(&st->metadata, "title", desc, 0); avio_rl16(pb); avio_rl32(pb); pd = (AVProbeData) { .buf = pb->buf_ptr, .buf_size = pb->buf_end - pb->buf_ptr }; if (!(sub_demuxer = av_probe_input_format2(&pd, 1, &score))) goto error; if (!(ast->sub_ctx = avformat_alloc_context())) goto error; ast->sub_ctx->pb = pb; if (!avformat_open_input(&ast->sub_ctx, "", sub_demuxer, NULL)) { ff_read_packet(ast->sub_ctx, &ast->sub_pkt); *st->codec = *ast->sub_ctx->streams[0]->codec; ast->sub_ctx->streams[0]->codec->extradata = NULL; time_base = ast->sub_ctx->streams[0]->time_base; avpriv_set_pts_info(st, 64, time_base.num, time_base.den); } ast->sub_buffer = pkt->data; memset(pkt, 0, sizeof(*pkt)); return 1; error: av_freep(&pb); } return 0; }
--------------------------------------------- Result 225 ---------------------------------------------
[[0 (5%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 t0; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); t0 = tcg_temp_new_i32(); tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32(t0); }

[[[[Adv]]]]: static void gen_isel(DisasContext *ctx) { int l1, l2; uint32_t bi = rC(ctx->opcode); uint32_t mask; TCGv_i32 t0; l1 = gen_new_label(); l2 = gen_new_label(); mask = 0x08 >> (bi & 0x03); t0 = tcg_temp_new_i32(); tcg_gen_andi_i32(t0, cpu_crf[bi >> 2], mask); tcg_gen_brcondi_i32(TCG_COND_EQ, t0, 0, l1); if (rA(ctx->opcode) == 0) tcg_gen_movi_tl(cpu_gpr[rD(ctx->opcode)], 0); else tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rA(ctx->opcode)]); tcg_gen_br(l2); gen_set_label(l1); tcg_gen_mov_tl(cpu_gpr[rD(ctx->opcode)], cpu_gpr[rB(ctx->opcode)]); gen_set_label(l2); tcg_temp_free_i32(t0); }
--------------------------------------------- Result 226 ---------------------------------------------
[[0 (72%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int disas_cp15_insn(CPUState *env, DisasContext *s, uint32_t insn) { uint32_t rd; TCGv tmp, tmp2; if (arm_feature(env, ARM_FEATURE_M)) return 1; if ((insn & (1 << 25)) == 0) { if (insn & (1 << 20)) { return 1; } return 0; } if ((insn & (1 << 4)) == 0) { return 1; } if (IS_USER(s) && !cp15_user_ok(insn)) { return 1; } if ((insn & 0x0fff0fff) == 0x0e070f90 || (insn & 0x0fff0fff) == 0x0e070f58) { gen_set_pc_im(s->pc); s->is_jmp = DISAS_WFI; return 0; } rd = (insn >> 12) & 0xf; if (cp15_tls_load_store(env, s, insn, rd)) return 0; tmp2 = tcg_const_i32(insn); if (insn & ARM_CP_RW_BIT) { tmp = new_tmp(); gen_helper_get_cp15(tmp, cpu_env, tmp2); if (rd != 15) store_reg(s, rd, tmp); else dead_tmp(tmp); } else { tmp = load_reg(s, rd); gen_helper_set_cp15(cpu_env, tmp2, tmp); dead_tmp(tmp); if (!arm_feature(env, ARM_FEATURE_XSCALE) || (insn & 0x0fff0fff) != 0x0e010f10) gen_lookup_tb(s); } tcg_temp_free_i32(tmp2); return 0; }
--------------------------------------------- Result 227 ---------------------------------------------
[[0 (26%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { return vc_handler(backend->u.vc, errp); }

[[[[Adv]]]]: static CharDriverState *vc_init(const char *id, ChardevBackend *backend, ChardevReturn *ret, Error **errp) { return vc_handler(backend->u.vc, errp); }
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 91 / 33 / 104 / 228:   8%|         | 228/2690 [01:37<17:31,  2.34it/s][Succeeded / Failed / Skipped / Total] 91 / 34 / 104 / 229:   9%|         | 229/2690 [01:39<17:49,  2.30it/s][Succeeded / Failed / Skipped / Total] 92 / 34 / 104 / 230:   9%|         | 230/2690 [01:40<17:51,  2.30it/s][Succeeded / Failed / Skipped / Total] 93 / 34 / 104 / 231:   9%|         | 231/2690 [01:40<17:49,  2.30it/s][[0 (24%)]] --> [[0 (51%)]] --> Socre: 0.5083322525024414

[[[[Adv]]]]: USBDevice *usb_host_device_open(const char *devname) { int fd = -1, ret; USBHostDevice *[[dev]] = NULL; struct usbdevfs_connectinfo ci; char [[buf]][1024]; int bus_num, addr; char product_name[PRODUCT_NAME_SZ]; [[dev]] = qemu_mallocz(sizeof(USBHostDevice)); if (![[dev]]) goto fail; #ifdef DEBUG_ISOCH printf("usb_host_device_open %s\n", devname); #endif if (usb_host_find_device(&bus_num, &addr, product_name, sizeof(product_name), devname) < 0) return NULL; snprintf([[buf]], sizeof([[buf]]), USBDEVFS_PATH "/%03d/%03d", bus_num, addr); fd = open([[buf]], O_RDWR | O_NONBLOCK); if (fd < 0) { perror([[buf]]); return NULL; } [[dev]]->descr_len = read(fd, [[dev]]->descr, sizeof([[dev]]->descr)); if ([[dev]]->descr_len <= 0) { perror("usb_host_device_open: reading device data failed"); goto fail; } #ifdef DEBUG { int x; printf("=== begin dumping device descriptor data ===\n"); for (x = 0; x < [[dev]]->descr_len; x++) printf("%02x ", [[dev]]->descr[x]); printf("\n=== end dumping device descriptor data ===\n"); } #endif [[dev]]->fd = fd; [[dev]]->configuration = 1; if (!usb_host_update_interfaces([[dev]], 1)) goto fail; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } #ifdef DEBUG printf("host USB device %d.%d grabbed\n", bus_num, addr); #endif ret = usb_linux_update_endp_table([[dev]]); if (ret) goto fail; if (ci.slow) [[dev]]->dev.speed = USB_SPEED_LOW; else [[dev]]->dev.speed = USB_SPEED_HIGH; [[dev]]->dev.handle_packet = usb_generic_handle_packet; [[dev]]->dev.handle_reset = usb_host_handle_reset; [[dev]]->dev.handle_control = usb_host_handle_control; [[dev]]->dev.handle_data = usb_host_handle_data; [[dev]]->dev.handle_destroy = usb_host_handle_destroy; if (product_name[0] == '\0') snprintf([[dev]]->dev.devname, sizeof([[dev]]->dev.devname), "host:%s", devname); else pstrcpy([[dev]]->dev.devname, sizeof([[dev]]->dev.devname), product_name); #ifdef USE_ASYNCIO sigemptyset(&sigact.sa_mask); sigact.sa_sigaction = isoch_done; sigact.sa_flags = SA_SIGINFO; sigact.sa_restorer = 0; ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL); if (ret < 0) { perror("usb_host_device_open: sigaction failed"); goto fail; } if (pipe([[dev]]->pipe_fds) < 0) { perror("usb_host_device_open: pipe creation failed"); goto fail; } fcntl([[dev]]->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC); fcntl([[dev]]->pipe_fds[1], F_SETFL, O_NONBLOCK); qemu_set_fd_handler([[dev]]->pipe_fds[0], urb_completion_pipe_read, NULL, [[dev]]); #endif [[dev]]->urbs_ready = 0; return (USBDevice *)[[dev]]; fail: if ([[dev]]) qemu_free([[dev]]); close(fd); return NULL; }

[[[[Adv]]]]: USBDevice *usb_host_device_open(const char *devname) { int fd = -1, ret; USBHostDevice *[[rohit]] = NULL; struct usbdevfs_connectinfo ci; char [[weddings]][1024]; int bus_num, addr; char product_name[PRODUCT_NAME_SZ]; [[rohit]] = qemu_mallocz(sizeof(USBHostDevice)); if (![[rohit]]) goto fail; #ifdef DEBUG_ISOCH printf("usb_host_device_open %s\n", devname); #endif if (usb_host_find_device(&bus_num, &addr, product_name, sizeof(product_name), devname) < 0) return NULL; snprintf([[weddings]], sizeof([[weddings]]), USBDEVFS_PATH "/%03d/%03d", bus_num, addr); fd = open([[weddings]], O_RDWR | O_NONBLOCK); if (fd < 0) { perror([[weddings]]); return NULL; } [[rohit]]->descr_len = read(fd, [[rohit]]->descr, sizeof([[rohit]]->descr)); if ([[rohit]]->descr_len <= 0) { perror("usb_host_device_open: reading device data failed"); goto fail; } #ifdef DEBUG { int x; printf("=== begin dumping device descriptor data ===\n"); for (x = 0; x < [[rohit]]->descr_len; x++) printf("%02x ", [[rohit]]->descr[x]); printf("\n=== end dumping device descriptor data ===\n"); } #endif [[rohit]]->fd = fd; [[rohit]]->configuration = 1; if (!usb_host_update_interfaces([[rohit]], 1)) goto fail; ret = ioctl(fd, USBDEVFS_CONNECTINFO, &ci); if (ret < 0) { perror("usb_host_device_open: USBDEVFS_CONNECTINFO"); goto fail; } #ifdef DEBUG printf("host USB device %d.%d grabbed\n", bus_num, addr); #endif ret = usb_linux_update_endp_table([[rohit]]); if (ret) goto fail; if (ci.slow) [[rohit]]->dev.speed = USB_SPEED_LOW; else [[rohit]]->dev.speed = USB_SPEED_HIGH; [[rohit]]->dev.handle_packet = usb_generic_handle_packet; [[rohit]]->dev.handle_reset = usb_host_handle_reset; [[rohit]]->dev.handle_control = usb_host_handle_control; [[rohit]]->dev.handle_data = usb_host_handle_data; [[rohit]]->dev.handle_destroy = usb_host_handle_destroy; if (product_name[0] == '\0') snprintf([[rohit]]->dev.devname, sizeof([[rohit]]->dev.devname), "host:%s", devname); else pstrcpy([[rohit]]->dev.devname, sizeof([[rohit]]->dev.devname), product_name); #ifdef USE_ASYNCIO sigemptyset(&sigact.sa_mask); sigact.sa_sigaction = isoch_done; sigact.sa_flags = SA_SIGINFO; sigact.sa_restorer = 0; ret = sigaction(SIG_ISOCOMPLETE, &sigact, NULL); if (ret < 0) { perror("usb_host_device_open: sigaction failed"); goto fail; } if (pipe([[rohit]]->pipe_fds) < 0) { perror("usb_host_device_open: pipe creation failed"); goto fail; } fcntl([[rohit]]->pipe_fds[0], F_SETFL, O_NONBLOCK | O_ASYNC); fcntl([[rohit]]->pipe_fds[1], F_SETFL, O_NONBLOCK); qemu_set_fd_handler([[rohit]]->pipe_fds[0], urb_completion_pipe_read, NULL, [[rohit]]); #endif [[rohit]]->urbs_ready = 0; return (USBDevice *)[[rohit]]; fail: if ([[rohit]]) qemu_free([[rohit]]); close(fd); return NULL; }
--------------------------------------------- Result 229 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: bool machine_iommu(MachineState *machine) { return machine->iommu; }

[[[[Adv]]]]: bool machine_iommu(MachineState *machine) { return machine->iommu; }
--------------------------------------------- Result 230 ---------------------------------------------
[[0 (45%)]] --> [[0 (64%)]] --> Socre: 0.643543541431427

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *[[s]] = &tcg_ctx; int idx; TCGLabel *l; if ([[s]]->nb_labels >= TCG_MAX_LABELS) tcg_abort(); idx = [[s]]->nb_labels++; l = &[[s]]->labels[idx]; l->has_value = 0; l->u.first_reloc = NULL; return idx; }

[[[[Adv]]]]: int gen_new_label(void) { TCGContext *[[du]] = &tcg_ctx; int idx; TCGLabel *l; if ([[du]]->nb_labels >= TCG_MAX_LABELS) tcg_abort(); idx = [[du]]->nb_labels++; l = &[[du]]->labels[idx]; l->has_value = 0; l->u.first_reloc = NULL; return idx; }
--------------------------------------------- Result 231 ---------------------------------------------
[[0 (41%)]] --> [[0 (51%)]] --> Socre: 0.5085094571113586

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *[[bs]], int64_t sector_num, int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info([[bs]], &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = sector_num; *cluster_nb_sectors = nb_sectors; } else { int64_t [[c]] = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, [[c]]); *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num + nb_sectors, [[c]]); } }

[[[[Adv]]]]: void bdrv_round_to_clusters(BlockDriverState *[[majored]], int64_t sector_num, int nb_sectors, int64_t *cluster_sector_num, int *cluster_nb_sectors) { BlockDriverInfo bdi; if (bdrv_get_info([[majored]], &bdi) < 0 || bdi.cluster_size == 0) { *cluster_sector_num = sector_num; *cluster_nb_sectors = nb_sectors; } else { int64_t [[ii]] = bdi.cluster_size / BDRV_SECTOR_SIZE; *cluster_sector_num = QEMU_ALIGN_DOWN(sector_num, [[ii]]); *cluster_nb_sectors = QEMU_ALIGN_UP(sector_num - *cluster_sector_num + nb_sectors, [[ii]]); } }
--------------------------------------------- Result 232 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 34 / 105 / 232:   9%|         | 232/2690 [01:40<17:44,  2.31it/s][Succeeded / Failed / Skipped / Total] 94 / 34 / 105 / 233:   9%|         | 233/2690 [01:40<17:44,  2.31it/s][Succeeded / Failed / Skipped / Total] 94 / 35 / 105 / 234:   9%|         | 234/2690 [01:53<19:48,  2.07it/s][Succeeded / Failed / Skipped / Total] 95 / 35 / 105 / 235:   9%|         | 235/2690 [01:57<20:23,  2.01it/s][Succeeded / Failed / Skipped / Total] 95 / 35 / 105 / 235:   9%|         | 236/2690 [01:57<20:22,  2.01it/s][Succeeded / Failed / Skipped / Total] 96 / 35 / 105 / 236:   9%|         | 236/2690 [01:57<20:22,  2.01it/s][[0 (25%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void tlb_reset_dirty(CPUState *cpu, ram_addr_t start1, ram_addr_t length) { CPUArchState *env; int mmu_idx; assert_cpu_is_self(cpu); env = cpu->env_ptr; for (mmu_idx = 0; mmu_idx < NB_MMU_MODES; mmu_idx++) { unsigned int i; for (i = 0; i < CPU_TLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_table[mmu_idx][i], start1, length); } for (i = 0; i < CPU_VTLB_SIZE; i++) { tlb_reset_dirty_range(&env->tlb_v_table[mmu_idx][i], start1, length); } } }
--------------------------------------------- Result 233 ---------------------------------------------
[[0 (56%)]] --> [[0 (46%)]] --> Socre: 0.5430073738098145

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int [[flags]]) { BDRVBlkdebugState *s = bs->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= offset && inject_offset < offset + bytes)) { break; if (rule && rule->options.inject.error) { return inject_error(bs, rule); return bdrv_co_preadv(bs->file, offset, bytes, qiov, [[flags]]);

[[[[Adv]]]]: blkdebug_co_preadv(BlockDriverState *bs, uint64_t offset, uint64_t bytes, QEMUIOVector *qiov, int [[flagged]]) { BDRVBlkdebugState *s = bs->opaque; BlkdebugRule *rule = NULL; QSIMPLEQ_FOREACH(rule, &s->active_rules, active_next) { uint64_t inject_offset = rule->options.inject.offset; if (inject_offset == -1 || (inject_offset >= offset && inject_offset < offset + bytes)) { break; if (rule && rule->options.inject.error) { return inject_error(bs, rule); return bdrv_co_preadv(bs->file, offset, bytes, qiov, [[flagged]]);
--------------------------------------------- Result 234 ---------------------------------------------
[[0 (53%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *dev) { IDRegState *s = MACIO_ID_REGISTER(dev); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio(dev, &s->mem); return 0; }

[[[[Adv]]]]: static int idreg_init1(SysBusDevice *dev) { IDRegState *s = MACIO_ID_REGISTER(dev); memory_region_init_ram(&s->mem, OBJECT(s), "sun4m.idreg", sizeof(idreg_data), &error_abort); vmstate_register_ram_global(&s->mem); memory_region_set_readonly(&s->mem, "True" == "True"); sysbus_init_mmio(dev, &s->mem); return 0; }
--------------------------------------------- Result 235 ---------------------------------------------
[[0 (14%)]] --> [[0 (64%)]] --> Socre: 0.6370595693588257

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa, size_t len) { hwaddr [[mapped_len]] = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (!len) { return "[[True]]" == "[[True]]"; } ventry = &pkt->raw[pkt->raw_frags]; [[mapped_len]] = len; ventry->iov_base = cpu_physical_memory_map(pa, &[[mapped_len]], "False" != "False"); ventry->iov_len = [[mapped_len]]; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || (len != [[mapped_len]])) { return "False" != "False"; } return "[[True]]" == "[[True]]"; }

[[[[Adv]]]]: bool net_tx_pkt_add_raw_fragment(struct NetTxPkt *pkt, hwaddr pa, size_t len) { hwaddr [[unrealistic]] = 0; struct iovec *ventry; assert(pkt); assert(pkt->max_raw_frags > pkt->raw_frags); if (!len) { return "[[Genuinely]]" == "[[Genuinely]]"; } ventry = &pkt->raw[pkt->raw_frags]; [[unrealistic]] = len; ventry->iov_base = cpu_physical_memory_map(pa, &[[unrealistic]], "False" != "False"); ventry->iov_len = [[unrealistic]]; pkt->raw_frags += !!ventry->iov_base; if ((ventry->iov_base == NULL) || (len != [[unrealistic]])) { return "False" != "False"; } return "[[Genuinely]]" == "[[Genuinely]]"; }
--------------------------------------------- Result 236 ---------------------------------------------
[[0 (47%)]] --> [[0 (52%)]] --> Socre: 0.5223913192749023

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[disk]]) { char fe[256], be[256]; int [[vdev]] = 202 * 256 + 16 * [[disk]]->unit; int cdrom = [[disk]]->bdrv->type == BDRV_TYPE_CDROM; const char *[[devtype]] = cdrom ? "cdrom" : "disk"; const char *mode = cdrom ? "r" : "w"; snprintf([[disk]]->bdrv->device_name, sizeof([[disk]]->bdrv->device_name), "xvd%c", 'a' + [[disk]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[disk]]->unit, [[disk]]->bdrv->device_name, [[disk]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", [[vdev]], fe, be, sizeof(fe)); xenstore_write_int(fe, "virtual-device", [[vdev]]); xenstore_write_str(fe, "device-type", [[devtype]]); xenstore_write_str(be, "dev", [[disk]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[disk]]->bdrv->filename); xenstore_write_str(be, "mode", mode); return xen_config_dev_all(fe, be); }

[[[[Adv]]]]: int xen_config_dev_blk(DriveInfo *[[tapes]]) { char fe[256], be[256]; int [[hurley]] = 202 * 256 + 16 * [[tapes]]->unit; int cdrom = [[tapes]]->bdrv->type == BDRV_TYPE_CDROM; const char *[[thomson]] = cdrom ? "cdrom" : "disk"; const char *mode = cdrom ? "r" : "w"; snprintf([[tapes]]->bdrv->device_name, sizeof([[tapes]]->bdrv->device_name), "xvd%c", 'a' + [[tapes]]->unit); xen_be_printf(NULL, 1, "config disk %d [%s]: %s\n", [[tapes]]->unit, [[tapes]]->bdrv->device_name, [[tapes]]->bdrv->filename); xen_config_dev_dirs("vbd", "qdisk", [[hurley]], fe, be, sizeof(fe)); xenstore_write_int(fe, "virtual-device", [[hurley]]); xenstore_write_str(fe, "device-type", [[thomson]]); xenstore_write_str(be, "dev", [[tapes]]->bdrv->device_name); xenstore_write_str(be, "type", "file"); xenstore_write_str(be, "params", [[tapes]]->bdrv->filename); xenstore_write_str(be, "mode", mode); return xen_config_dev_all(fe, be); }
--------------------------------------------- Result 237 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 35 / 106 / 237:   9%|         | 237/2690 [01:57<20:16,  2.02it/s][Succeeded / Failed / Skipped / Total] 96 / 35 / 107 / 238:   9%|         | 238/2690 [01:57<20:11,  2.02it/s][[0 (54%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline void gen_intermediate_code_internal(OpenRISCCPU *cpu, TranslationBlock *tb, int search_pc) { CPUState *cs = CPU(cpu); struct DisasContext ctx, *dc = &ctx; uint16_t *gen_opc_end; uint32_t pc_start; int j, k; uint32_t next_page_start; int num_insns; int max_insns; pc_start = tb->pc; dc->tb = tb; gen_opc_end = tcg_ctx.gen_opc_buf + OPC_MAX_SIZE; dc->is_jmp = DISAS_NEXT; dc->ppc = pc_start; dc->pc = pc_start; dc->flags = cpu->env.cpucfgr; dc->mem_idx = cpu_mmu_index(&cpu->env); dc->synced_flags = dc->tb_flags = tb->flags; dc->delayed_branch = !!(dc->tb_flags & D_FLAG); dc->singlestep_enabled = cs->singlestep_enabled; if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("-----------------------------------------\n"); log_cpu_state(CPU(cpu), 0); } next_page_start = (pc_start & TARGET_PAGE_MASK) + TARGET_PAGE_SIZE; k = -1; num_insns = 0; max_insns = tb->cflags & CF_COUNT_MASK; if (max_insns == 0) { max_insns = CF_COUNT_MASK; } gen_tb_start(); do { check_breakpoint(cpu, dc); if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; if (k < j) { k++; while (k < j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } tcg_ctx.gen_opc_pc[k] = dc->pc; tcg_ctx.gen_opc_instr_start[k] = 1; tcg_ctx.gen_opc_icount[k] = num_insns; } if (unlikely(qemu_loglevel_mask(CPU_LOG_TB_OP | CPU_LOG_TB_OP_OPT))) { tcg_gen_debug_insn_start(dc->pc); } if (num_insns + 1 == max_insns && (tb->cflags & CF_LAST_IO)) { gen_io_start(); } dc->ppc = dc->pc - 4; dc->npc = dc->pc + 4; tcg_gen_movi_tl(cpu_ppc, dc->ppc); tcg_gen_movi_tl(cpu_npc, dc->npc); disas_openrisc_insn(dc, cpu); dc->pc = dc->npc; num_insns++; if (dc->delayed_branch) { dc->delayed_branch--; if (!dc->delayed_branch) { dc->tb_flags &= ~D_FLAG; gen_sync_flags(dc); tcg_gen_mov_tl(cpu_pc, jmp_pc); tcg_gen_mov_tl(cpu_npc, jmp_pc); tcg_gen_movi_tl(jmp_pc, 0); tcg_gen_exit_tb(0); dc->is_jmp = DISAS_JUMP; break; } } } while (!dc->is_jmp && tcg_ctx.gen_opc_ptr < gen_opc_end && !cs->singlestep_enabled && !singlestep && (dc->pc < next_page_start) && num_insns < max_insns); if (tb->cflags & CF_LAST_IO) { gen_io_end(); } if (dc->is_jmp == DISAS_NEXT) { dc->is_jmp = DISAS_UPDATE; tcg_gen_movi_tl(cpu_pc, dc->pc); } if (unlikely(cs->singlestep_enabled)) { if (dc->is_jmp == DISAS_NEXT) { tcg_gen_movi_tl(cpu_pc, dc->pc); } gen_exception(dc, EXCP_DEBUG); } else { switch (dc->is_jmp) { case DISAS_NEXT: gen_goto_tb(dc, 0, dc->pc); break; default: case DISAS_JUMP: break; case DISAS_UPDATE: tcg_gen_exit_tb(0); break; case DISAS_TB_JUMP: break; } } gen_tb_end(tb, num_insns); *tcg_ctx.gen_opc_ptr = INDEX_op_end; if (search_pc) { j = tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf; k++; while (k <= j) { tcg_ctx.gen_opc_instr_start[k++] = 0; } } else { tb->size = dc->pc - pc_start; tb->icount = num_insns; } #ifdef DEBUG_DISAS if (qemu_loglevel_mask(CPU_LOG_TB_IN_ASM)) { qemu_log("\n"); log_target_disas(&cpu->env, pc_start, dc->pc - pc_start, 0); qemu_log("\nisize=%d osize=%td\n", dc->pc - pc_start, tcg_ctx.gen_opc_ptr - tcg_ctx.gen_opc_buf); } #endif }
--------------------------------------------- Result 238 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void pci_ivshmem_realize(PCIDevice *dev, Error **errp) { IVShmemState *s = IVSHMEM(dev); Error *err = NULL; uint8_t *pci_conf; uint8_t attr = PCI_BASE_ADDRESS_SPACE_MEMORY | PCI_BASE_ADDRESS_MEM_PREFETCH; if (!!s->server_chr + !!s->shmobj + !!s->hostmem != 1) { error_setg(errp, "You must specify either 'shm', 'chardev' or 'x-memdev'"); return; } if (s->hostmem) { MemoryRegion *mr; if (s->sizearg) { g_warning("size argument ignored with hostmem"); } mr = host_memory_backend_get_memory(s->hostmem, &error_abort); s->ivshmem_size = memory_region_size(mr); } else if (s->sizearg == NULL) { s->ivshmem_size = 4 << 20; } else { char *end; int64_t size = qemu_strtosz(s->sizearg, &end); if (size < 0 || *end != '\0' || !is_power_of_2(size)) { error_setg(errp, "Invalid size %s", s->sizearg); return; } s->ivshmem_size = size; } if (ivshmem_has_feature(s, IVSHMEM_IOEVENTFD) && !ivshmem_has_feature(s, IVSHMEM_MSI)) { error_setg(errp, "ioeventfd/irqfd requires MSI"); return; } if (s->role) { if (strncmp(s->role, "peer", 5) == 0) { s->role_val = IVSHMEM_PEER; } else if (strncmp(s->role, "master", 7) == 0) { s->role_val = IVSHMEM_MASTER; } else { error_setg(errp, "'role' must be 'peer' or 'master'"); return; } } else { s->role_val = IVSHMEM_MASTER; } pci_conf = dev->config; pci_conf[PCI_COMMAND] = PCI_COMMAND_IO | PCI_COMMAND_MEMORY; pci_config_set_interrupt_pin(pci_conf, 1); memory_region_init_io(&s->ivshmem_mmio, OBJECT(s), &ivshmem_mmio_ops, s, "ivshmem-mmio", IVSHMEM_REG_BAR_SIZE); pci_register_bar(dev, 0, PCI_BASE_ADDRESS_SPACE_MEMORY, &s->ivshmem_mmio); memory_region_init(&s->bar, OBJECT(s), "ivshmem-bar2-container", s->ivshmem_size); if (s->ivshmem_64bit) { attr |= PCI_BASE_ADDRESS_MEM_TYPE_64; } if (s->hostmem != NULL) { MemoryRegion *mr; IVSHMEM_DPRINTF("using hostmem\n"); mr = host_memory_backend_get_memory(MEMORY_BACKEND(s->hostmem), &error_abort); vmstate_register_ram(mr, DEVICE(s)); memory_region_add_subregion(&s->bar, 0, mr); pci_register_bar(PCI_DEVICE(s), 2, attr, &s->bar); } else if (s->server_chr != NULL) { if (strncmp(s->server_chr->filename, "unix:", 5)) { error_setg(errp, "chardev is not a unix client socket"); return; } IVSHMEM_DPRINTF("using shared memory server (socket = %s)\n", s->server_chr->filename); if (ivshmem_setup_interrupts(s) < 0) { error_setg(errp, "failed to initialize interrupts"); return; } resize_peers(s, 16); s->vm_id = -1; pci_register_bar(dev, 2, attr, &s->bar); qemu_chr_add_handlers(s->server_chr, ivshmem_can_receive, ivshmem_check_version, NULL, s); } else { int fd; IVSHMEM_DPRINTF("using shm_open (shm object = %s)\n", s->shmobj); if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR|O_EXCL, S_IRWXU|S_IRWXG|S_IRWXO)) > 0) { if (ftruncate(fd, s->ivshmem_size) != 0) { error_report("could not truncate shared file"); } } else if ((fd = shm_open(s->shmobj, O_CREAT|O_RDWR, S_IRWXU|S_IRWXG|S_IRWXO)) < 0) { error_setg(errp, "could not open shared file"); return; } if (check_shm_size(s, fd, errp) == -1) { return; } create_shared_memory_BAR(s, fd, attr, &err); if (err) { error_propagate(errp, err); return; } } fifo8_create(&s->incoming_fifo, sizeof(int64_t)); if (s->role_val == IVSHMEM_PEER) { error_setg(&s->migration_blocker, "Migration is disabled when using feature 'peer mode' in device 'ivshmem'"); migrate_add_blocker(s->migration_blocker); } }
--------------------------------------------- Result 239 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 35 / 108 / 239:   9%|         | 239/2690 [01:57<20:05,  2.03it/s][Succeeded / Failed / Skipped / Total] 96 / 35 / 108 / 239:   9%|         | 240/2690 [01:57<20:02,  2.04it/s][Succeeded / Failed / Skipped / Total] 97 / 35 / 108 / 240:   9%|         | 240/2690 [01:57<20:02,  2.04it/s][Succeeded / Failed / Skipped / Total] 98 / 35 / 108 / 241:   9%|         | 241/2690 [01:57<19:58,  2.04it/s][[0 (36%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int print_insn_lm32(bfd_vma memaddr, struct disassemble_info *info) { fprintf_function fprintf_fn = info->fprintf_func; void *stream = info->stream; int rc; uint8_t insn[4]; const Lm32OpcodeInfo *opc_info; uint32_t op; const char *args_fmt; rc = info->read_memory_func(memaddr, insn, 4, info); if (rc != 0) { info->memory_error_func(rc, memaddr, info); return -1; } fprintf_fn(stream, "%02x %02x %02x %02x ", insn[0], insn[1], insn[2], insn[3]); op = bfd_getb32(insn); opc_info = find_opcode_info(op); if (opc_info) { fprintf_fn(stream, "%-8s ", opc_info->name); args_fmt = opc_info->args_fmt; while (args_fmt && *args_fmt) { if (*args_fmt == '%') { switch (*(++args_fmt)) { case '0': { uint8_t r0; const char *r0_name; r0 = (op >> 21) & 0x1f; r0_name = find_reg_info(r0)->name; fprintf_fn(stream, "%s", r0_name); break; } case '1': { uint8_t r1; const char *r1_name; r1 = (op >> 16) & 0x1f; r1_name = find_reg_info(r1)->name; fprintf_fn(stream, "%s", r1_name); break; } case '2': { uint8_t r2; const char *r2_name; r2 = (op >> 11) & 0x1f; r2_name = find_reg_info(r2)->name; fprintf_fn(stream, "%s", r2_name); break; } case 'c': { uint8_t csr; const char *csr_name; csr = (op >> 21) & 0x1f; csr_name = find_csr_info(csr)->name; if (csr_name) { fprintf_fn(stream, "%s", csr_name); } else { fprintf_fn(stream, "0x%x", csr); } break; } case 'u': { uint16_t u16; u16 = op & 0xffff; fprintf_fn(stream, "0x%x", u16); break; } case 's': { int16_t s16; s16 = (int16_t)(op & 0xffff); fprintf_fn(stream, "%d", s16); break; } case 'r': { uint32_t rela; rela = memaddr + (((int16_t)(op & 0xffff)) << 2); fprintf_fn(stream, "%x", rela); break; } case 'R': { uint32_t rela; int32_t imm26; imm26 = (int32_t)((op & 0x3ffffff) << 6) >> 4; rela = memaddr + imm26; fprintf_fn(stream, "%x", rela); break; } case 'h': { uint8_t u5; u5 = (op & 0x1f); fprintf_fn(stream, "%d", u5); break; } default: break; } } else { fprintf_fn(stream, "%c", *args_fmt); } args_fmt++; } } else { fprintf_fn(stream, ".word 0x%x", op); } return 4; }
--------------------------------------------- Result 240 ---------------------------------------------
[[0 (43%)]] --> [[0 (56%)]] --> Socre: 0.5583290457725525

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *[[c]], uint8_t *[[properties]]) { int compno; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); compno = bytestream_get_byte(&s->buf); [[c]] += compno; [[c]]->csty = bytestream_get_byte(&s->buf); get_cox(s, [[c]]); [[properties]][compno] |= HAD_COC; return 0; }

[[[[Adv]]]]: static int get_coc(Jpeg2000DecoderContext *s, Jpeg2000CodingStyle *[[ii]], uint8_t *[[character]]) { int compno; if (s->buf_end - s->buf < 2) return AVERROR(EINVAL); compno = bytestream_get_byte(&s->buf); [[ii]] += compno; [[ii]]->csty = bytestream_get_byte(&s->buf); get_cox(s, [[ii]]); [[character]][compno] |= HAD_COC; return 0; }
--------------------------------------------- Result 241 ---------------------------------------------
[[0 (53%)]] --> [[0 (36%)]] --> Socre: 0.6444462537765503

[[[[Adv]]]]: static void curses_setup(void) { int i, colour_default[8] = { COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN, COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE, }; initscr(); noecho(); intrflush(stdscr, "False" != "False"); nodelay(stdscr, "[[True]]" == "[[True]]"); nonl(); keypad(stdscr, "[[True]]" == "[[True]]"); start_color(); raw(); scrollok(stdscr, "False" != "False"); for (i = 0; i < 64; i ++) init_pair(i, colour_default[i & 7], colour_default[i >> 3]); }

[[[[Adv]]]]: static void curses_setup(void) { int i, colour_default[8] = { COLOR_BLACK, COLOR_BLUE, COLOR_GREEN, COLOR_CYAN, COLOR_RED, COLOR_MAGENTA, COLOR_YELLOW, COLOR_WHITE, }; initscr(); noecho(); intrflush(stdscr, "False" != "False"); nodelay(stdscr, "[[Honestly]]" == "[[Honestly]]"); nonl(); keypad(stdscr, "[[Honestly]]" == "[[Honestly]]"); start_color(); raw(); scrollok(stdscr, "False" != "False"); for (i = 0; i < 64; i ++) init_pair(i, colour_default[i & 7], colour_default[i >> 3]); }
--------------------------------------------- Result 242 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 99 / 35 / 108 / 242:   9%|         | 242/2690 [01:58<19:55,  2.05it/s][Succeeded / Failed / Skipped / Total] 100 / 35 / 108 / 243:   9%|         | 243/2690 [02:00<20:11,  2.02it/s][Succeeded / Failed / Skipped / Total] 100 / 35 / 108 / 243:   9%|         | 244/2690 [02:00<20:06,  2.03it/s][Succeeded / Failed / Skipped / Total] 101 / 35 / 108 / 244:   9%|         | 244/2690 [02:00<20:06,  2.03it/s][[0 (53%)]] --> [[0 (48%)]] --> Socre: 0.5226098597049713

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int i; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "[[m]]" (src), "m" (dst), "m" (dstWidth), "m" ((xInc*4)>>16), "m" ((xInc*4)&0xFFFF), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" (dst), "m" (dstWidth), "m" (xInc>>16), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for(i=0;i<dstWidth;i++) { register unsigned int xx=xpos>>16; register unsigned int [[xalpha]]=(xpos&0xFFFF)>>9; dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*[[xalpha]]; xpos+=xInc; } #endif } }

[[[[Adv]]]]: static inline void RENAME(hyscale)(uint16_t *dst, int dstWidth, uint8_t *src, int srcW, int xInc) { #ifdef HAVE_MMX if(sws_flags != SWS_FAST_BILINEAR || (!canMMX2BeUsed)) #else if(sws_flags != SWS_FAST_BILINEAR) #endif { RENAME(hScale)(dst, dstWidth, src, srcW, xInc, hLumFilter, hLumFilterPos, hLumFilterSize); } else { #ifdef ARCH_X86 #ifdef HAVE_MMX2 int i; if(canMMX2BeUsed) { asm volatile( "pxor %%mm7, %%mm7 \n\t" "pxor %%mm2, %%mm2 \n\t" "movd %5, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "movq %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "paddw %%mm6, %%mm2 \n\t" "psllq $16, %%mm2 \n\t" "movq %%mm2, "MANGLE(temp0)" \n\t" "movd %4, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "punpcklwd %%mm6, %%mm6 \n\t" "xorl %%eax, %%eax \n\t" "movl %0, %%esi \n\t" "movl %1, %%edi \n\t" "movl %3, %%edx \n\t" "xorl %%ecx, %%ecx \n\t" "xorl %%ebx, %%ebx \n\t" "movw %4, %%bx \n\t" #define FUNNY_Y_CODE \ PREFETCH" 1024(%%esi) \n\t"\ PREFETCH" 1056(%%esi) \n\t"\ PREFETCH" 1088(%%esi) \n\t"\ "call "MANGLE(funnyYCode)" \n\t"\ "movq "MANGLE(temp0)", %%mm2 \n\t"\ "xorl %%ecx, %%ecx \n\t" FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE FUNNY_Y_CODE :: "[[billions]]" (src), "m" (dst), "m" (dstWidth), "m" ((xInc*4)>>16), "m" ((xInc*4)&0xFFFF), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edx", "%esi", "%edi" ); for(i=dstWidth-1; (i*xInc)>>16 >=srcW-1; i--) dst[i] = src[srcW-1]*128; } else { #endif asm volatile( "xorl %%eax, %%eax \n\t" "xorl %%ebx, %%ebx \n\t" "xorl %%ecx, %%ecx \n\t" ".balign 16 \n\t" "1: \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, (%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "movzbl (%0, %%ebx), %%edi \n\t" "movzbl 1(%0, %%ebx), %%esi \n\t" "subl %%edi, %%esi \n\t" "imull %%ecx, %%esi \n\t" "shll $16, %%edi \n\t" "addl %%edi, %%esi \n\t" "movl %1, %%edi \n\t" "shrl $9, %%esi \n\t" "movw %%si, 2(%%edi, %%eax, 2) \n\t" "addw %4, %%cx \n\t" "adcl %3, %%ebx \n\t" "addl $2, %%eax \n\t" "cmpl %2, %%eax \n\t" " jb 1b \n\t" :: "r" (src), "m" (dst), "m" (dstWidth), "m" (xInc>>16), "m" (xInc&0xFFFF) : "%eax", "%ebx", "%ecx", "%edi", "%esi" ); #ifdef HAVE_MMX2 } #endif #else int i; unsigned int xpos=0; for(i=0;i<dstWidth;i++) { register unsigned int xx=xpos>>16; register unsigned int [[wilmore]]=(xpos&0xFFFF)>>9; dst[i]= (src[xx]<<7) + (src[xx+1] - src[xx])*[[wilmore]]; xpos+=xInc; } #endif } }
--------------------------------------------- Result 243 ---------------------------------------------
[[0 (89%)]] --> [[0 (47%)]] --> Socre: 0.5304560661315918

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *[[f]], void *[[pv]], size_t size) { uint16_t *[[v]] = [[pv]]; uint16_t [[v2]]; qemu_get_be16s([[f]], &[[v2]]); if (*[[v]] == [[v2]]) { return 0; } return -EINVAL; }

[[[[Adv]]]]: static int get_uint16_equal(QEMUFile *[[w]], void *[[lamborghini]], size_t size) { uint16_t *[[iii]] = [[lamborghini]]; uint16_t [[burning]]; qemu_get_be16s([[w]], &[[burning]]); if (*[[iii]] == [[burning]]) { return 0; } return -EINVAL; }
--------------------------------------------- Result 244 ---------------------------------------------
[[0 (16%)]] --> [[0 (57%)]] --> Socre: 0.5661923289299011

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *[[s]], int [[ret]], tcg_target_long [[arg]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[arg]] != ([[arg]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[arg]]); if ([[arg]] != ([[arg]] & 0xfff)) tcg_out32([[s]], SETHI | INSN_RD([[ret]]) | (((uint32_t)[[arg]] & 0xfffffc00) >> 10)); tcg_out32([[s]], LDX | INSN_RD([[ret]]) | INSN_RS1([[ret]]) | INSN_IMM13([[arg]] & 0x3ff)); #else tcg_out_ld_raw([[s]], [[ret]], [[arg]]); #endif }

[[[[Adv]]]]: static inline void tcg_out_ld_ptr(TCGContext *[[y]], int [[retire]], tcg_target_long [[denying]]) { #if defined(__sparc_v9__) && !defined(__sparc_v8plus__) if ([[denying]] != ([[denying]] & 0xffffffff)) fprintf(stderr, "unimplemented %s with offset %ld\n", __func__, [[denying]]); if ([[denying]] != ([[denying]] & 0xfff)) tcg_out32([[y]], SETHI | INSN_RD([[retire]]) | (((uint32_t)[[denying]] & 0xfffffc00) >> 10)); tcg_out32([[y]], LDX | INSN_RD([[retire]]) | INSN_RS1([[retire]]) | INSN_IMM13([[denying]] & 0x3ff)); #else tcg_out_ld_raw([[y]], [[retire]], [[denying]]); #endif }
--------------------------------------------- Result 245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 102 / 35 / 108 / 245:   9%|         | 245/2690 [02:09<21:34,  1.89it/s][Succeeded / Failed / Skipped / Total] 102 / 35 / 109 / 246:   9%|         | 246/2690 [02:09<21:28,  1.90it/s][[0 (63%)]] --> [[0 (46%)]] --> Socre: 0.5353831052780151

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *[[ctx]], PayloadContext *data, AVStream *[[st]], AVPacket *pkt, uint32_t *[[timestamp]], const uint8_t *[[buf]], int len, uint16_t seq, int flags) { uint8_t nal; uint8_t type; int result = 0; if (!len) { av_log([[ctx]], AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = [[buf]][0]; type = nal & 0x1f; assert(data); assert([[buf]]); if (type >= 1 && type <= 23) type = 1; switch (type) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), [[buf]], len); COUNT_NAL_TYPE(data, nal); break; case 24: [[buf]]++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *src = [[buf]]; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16(src); src += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, src, nal_size); COUNT_NAL_TYPE(data, *src); dst += nal_size; } } else { av_log([[ctx]], AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } src += nal_size; src_len -= nal_size; if (src_len < 0) av_log([[ctx]], AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log([[ctx]], AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", type); result = AVERROR(ENOSYS); break; case 28: [[buf]]++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *[[buf]]; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; [[buf]]++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), [[buf]], len); } else { av_new_packet(pkt, len); memcpy(pkt->data, [[buf]], len); } } else { av_log([[ctx]], AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log([[ctx]], AV_LOG_ERROR, "Undefined type (%d)\n", type); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = [[st]]->index; return result; }

[[[[Adv]]]]: static int h264_handle_packet(AVFormatContext *[[atan]], PayloadContext *data, AVStream *[[shing]], AVPacket *pkt, uint32_t *[[preaching]], const uint8_t *[[yarmulke]], int len, uint16_t seq, int flags) { uint8_t nal; uint8_t type; int result = 0; if (!len) { av_log([[atan]], AV_LOG_ERROR, "Empty H264 RTP packet\n"); return AVERROR_INVALIDDATA; } nal = [[yarmulke]][0]; type = nal & 0x1f; assert(data); assert([[yarmulke]]); if (type >= 1 && type <= 23) type = 1; switch (type) { case 0: case 1: av_new_packet(pkt, len + sizeof(start_sequence)); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); memcpy(pkt->data + sizeof(start_sequence), [[yarmulke]], len); COUNT_NAL_TYPE(data, nal); break; case 24: [[yarmulke]]++; len--; { int pass = 0; int total_length = 0; uint8_t *dst = NULL; for (pass = 0; pass < 2; pass++) { const uint8_t *src = [[yarmulke]]; int src_len = len; while (src_len > 2) { uint16_t nal_size = AV_RB16(src); src += 2; src_len -= 2; if (nal_size <= src_len) { if (pass == 0) { total_length += sizeof(start_sequence) + nal_size; } else { assert(dst); memcpy(dst, start_sequence, sizeof(start_sequence)); dst += sizeof(start_sequence); memcpy(dst, src, nal_size); COUNT_NAL_TYPE(data, *src); dst += nal_size; } } else { av_log([[atan]], AV_LOG_ERROR, "nal size exceeds length: %d %d\n", nal_size, src_len); } src += nal_size; src_len -= nal_size; if (src_len < 0) av_log([[atan]], AV_LOG_ERROR, "Consumed more bytes than we got! (%d)\n", src_len); } if (pass == 0) { av_new_packet(pkt, total_length); dst = pkt->data; } else { assert(dst - pkt->data == total_length); } } } break; case 25: case 26: case 27: case 29: av_log([[atan]], AV_LOG_ERROR, "Unhandled type (%d) (See RFC for implementation details\n", type); result = AVERROR(ENOSYS); break; case 28: [[yarmulke]]++; len--; if (len > 1) { uint8_t fu_indicator = nal; uint8_t fu_header = *[[yarmulke]]; uint8_t start_bit = fu_header >> 7; uint8_t av_unused end_bit = (fu_header & 0x40) >> 6; uint8_t nal_type = fu_header & 0x1f; uint8_t reconstructed_nal; reconstructed_nal = fu_indicator & 0xe0; reconstructed_nal |= nal_type; [[yarmulke]]++; len--; if (start_bit) COUNT_NAL_TYPE(data, nal_type); if (start_bit) { av_new_packet(pkt, sizeof(start_sequence) + sizeof(nal) + len); memcpy(pkt->data, start_sequence, sizeof(start_sequence)); pkt->data[sizeof(start_sequence)] = reconstructed_nal; memcpy(pkt->data + sizeof(start_sequence) + sizeof(nal), [[yarmulke]], len); } else { av_new_packet(pkt, len); memcpy(pkt->data, [[yarmulke]], len); } } else { av_log([[atan]], AV_LOG_ERROR, "Too short data for FU-A H264 RTP packet\n"); result = AVERROR_INVALIDDATA; } break; case 30: case 31: default: av_log([[atan]], AV_LOG_ERROR, "Undefined type (%d)\n", type); result = AVERROR_INVALIDDATA; break; } pkt->stream_index = [[shing]]->index; return result; }
--------------------------------------------- Result 246 ---------------------------------------------
[[0 (61%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool cpu_handle_exception(CPUState *cpu, int *ret) { if (cpu->exception_index >= 0) { if (cpu->exception_index >= EXCP_INTERRUPT) { *ret = cpu->exception_index; if (*ret == EXCP_DEBUG) { cpu_handle_debug_exception(cpu); } cpu->exception_index = -1; return "True" == "True"; } else { #if defined(CONFIG_USER_ONLY) #if defined(TARGET_I386) CPUClass *cc = CPU_GET_CLASS(cpu); cc->do_interrupt(cpu); #endif *ret = cpu->exception_index; cpu->exception_index = -1; return "True" == "True"; #else if (replay_exception()) { CPUClass *cc = CPU_GET_CLASS(cpu); qemu_mutex_lock_iothread(); cc->do_interrupt(cpu); qemu_mutex_unlock_iothread(); cpu->exception_index = -1; } else if (!replay_has_interrupt()) { *ret = EXCP_INTERRUPT; return "True" == "True"; } #endif } #ifndef CONFIG_USER_ONLY } else if (replay_has_exception() && cpu->icount_decr.u16.low + cpu->icount_extra == 0) { cpu_exec_nocache(cpu, 1, tb_find(cpu, NULL, 0), "True" == "True"); *ret = -1; return "True" == "True"; #endif } return "False" != "False"; }
--------------------------------------------- Result 247 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 102 / 36 / 109 / 247:   9%|         | 247/2690 [02:17<22:39,  1.80it/s][Succeeded / Failed / Skipped / Total] 102 / 36 / 109 / 247:   9%|         | 248/2690 [02:19<22:51,  1.78it/s][Succeeded / Failed / Skipped / Total] 102 / 37 / 109 / 248:   9%|         | 248/2690 [02:19<22:51,  1.78it/s][Succeeded / Failed / Skipped / Total] 102 / 37 / 109 / 248:   9%|         | 249/2690 [02:25<23:49,  1.71it/s][Succeeded / Failed / Skipped / Total] 102 / 38 / 109 / 249:   9%|         | 249/2690 [02:25<23:49,  1.71it/s][Succeeded / Failed / Skipped / Total] 102 / 38 / 109 / 249:   9%|         | 250/2690 [02:35<25:17,  1.61it/s][[0 (35%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void bdrv_refresh_filename(BlockDriverState *bs) { BlockDriver *drv = bs->drv; QDict *opts; if (!drv) { return; } if (bs->file) { bdrv_refresh_filename(bs->file->bs); } if (drv->bdrv_refresh_filename) { bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } drv->bdrv_refresh_filename(bs); } else if (bs->file) { bool has_open_options; bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } opts = qdict_new(); has_open_options = append_open_options(opts, bs); if (bs->file->bs->exact_filename[0] && !has_open_options) { strcpy(bs->exact_filename, bs->file->bs->exact_filename); } if (bs->file->bs->full_open_options) { qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); QINCREF(bs->file->bs->full_open_options); qdict_put_obj(opts, "file", QOBJECT(bs->file->bs->full_open_options)); bs->full_open_options = opts; } else { QDECREF(opts); } } else if (!bs->full_open_options && qdict_size(bs->options)) { opts = qdict_new(); append_open_options(opts, bs); qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); if (bs->exact_filename[0]) { qdict_put_obj(opts, "filename", QOBJECT(qstring_from_str(bs->exact_filename))); } bs->full_open_options = opts; } if (bs->exact_filename[0]) { pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename); } else if (bs->full_open_options) { QString *json = qobject_to_json(QOBJECT(bs->full_open_options)); snprintf(bs->filename, sizeof(bs->filename), "json:%s", qstring_get_str(json)); QDECREF(json); } }

[[[[Adv]]]]: void bdrv_refresh_filename(BlockDriverState *bs) { BlockDriver *drv = bs->drv; QDict *opts; if (!drv) { return; } if (bs->file) { bdrv_refresh_filename(bs->file->bs); } if (drv->bdrv_refresh_filename) { bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } drv->bdrv_refresh_filename(bs); } else if (bs->file) { bool has_open_options; bs->exact_filename[0] = '\0'; if (bs->full_open_options) { QDECREF(bs->full_open_options); bs->full_open_options = NULL; } opts = qdict_new(); has_open_options = append_open_options(opts, bs); if (bs->file->bs->exact_filename[0] && !has_open_options) { strcpy(bs->exact_filename, bs->file->bs->exact_filename); } if (bs->file->bs->full_open_options) { qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); QINCREF(bs->file->bs->full_open_options); qdict_put_obj(opts, "file", QOBJECT(bs->file->bs->full_open_options)); bs->full_open_options = opts; } else { QDECREF(opts); } } else if (!bs->full_open_options && qdict_size(bs->options)) { opts = qdict_new(); append_open_options(opts, bs); qdict_put_obj(opts, "driver", QOBJECT(qstring_from_str(drv->format_name))); if (bs->exact_filename[0]) { qdict_put_obj(opts, "filename", QOBJECT(qstring_from_str(bs->exact_filename))); } bs->full_open_options = opts; } if (bs->exact_filename[0]) { pstrcpy(bs->filename, sizeof(bs->filename), bs->exact_filename); } else if (bs->full_open_options) { QString *json = qobject_to_json(QOBJECT(bs->full_open_options)); snprintf(bs->filename, sizeof(bs->filename), "json:%s", qstring_get_str(json)); QDECREF(json); } }
--------------------------------------------- Result 248 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if (ctx->cid_table->bit_depth == 8) ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }

[[[[Adv]]]]: void ff_dnxhdenc_init_x86(DNXHDEncContext *ctx) { #if HAVE_INLINE_ASM if (av_get_cpu_flags() & AV_CPU_FLAG_SSE2) { if (ctx->cid_table->bit_depth == 8) ctx->get_pixels_8x4_sym = get_pixels_8x4_sym_sse2; } #endif }
--------------------------------------------- Result 249 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2, src - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }

[[[[Adv]]]]: void ff_avg_h264_qpel4_mc31_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_hv_qrt_and_aver_dst_4x4_msa(src - 2, src - (stride * 2) + sizeof(uint8_t), stride, dst, stride); }
--------------------------------------------- Result 250 ---------------------------------------------
[[0 (34%)]] --> [[0 (52%)]] --> Socre: 0.5169410109519958

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *ctx, int [[rd]], int rs, int rt) { const char *[[opn]] = "loongson_cp2"; uint32_t opc, shift_max; TCGv_i64 [[t0]], t1; opc = MASK_LMI(ctx->opcode); switch (opc) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: [[t0]] = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: [[t0]] = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64(ctx, [[t0]], rs); gen_load_fpr64(ctx, t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch (opc) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 0, 16); [[opn]] = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 16, 16); [[opn]] = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 32, 16); [[opn]] = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64([[t0]], [[t0]], t1, 48, 16); [[opn]] = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64([[t0]], [[t0]], t1); tcg_gen_ext16u_i64([[t0]], [[t0]]); [[opn]] = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64([[t0]], [[t0]], t1); tcg_gen_ext32s_i64([[t0]], [[t0]]); [[opn]] = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64([[t0]], [[t0]], t1); tcg_gen_ext32s_i64([[t0]], [[t0]]); [[opn]] = "addu"; break; case OPC_SLL_CP2: [[opn]] = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: [[opn]] = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: [[opn]] = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: [[opn]] = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: [[opn]] = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: [[opn]] = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch (opc) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64([[t0]], [[t0]], t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64([[t0]], [[t0]], t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64([[t0]], [[t0]]); case OPC_DSRL_CP2: tcg_gen_shr_i64([[t0]], [[t0]], t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64([[t0]], [[t0]], t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 [[t2]] = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64([[t2]], [[t0]]); tcg_gen_add_i64([[t0]], t1, [[t2]]); if (opc == OPC_ADD_CP2) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_xor_i64(t1, t1, [[t2]]); tcg_gen_xor_i64([[t2]], [[t2]], [[t0]]); tcg_gen_andc_i64(t1, [[t2]], t1); tcg_temp_free_i64([[t2]]); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); [[opn]] = (opc == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 [[t2]] = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64([[t2]], [[t0]]); tcg_gen_sub_i64([[t0]], t1, [[t2]]); if (opc == OPC_SUB_CP2) { tcg_gen_ext32s_i64([[t0]], [[t0]]); } tcg_gen_xor_i64(t1, t1, [[t2]]); tcg_gen_xor_i64([[t2]], [[t2]], [[t0]]); tcg_gen_and_i64(t1, t1, [[t2]]); tcg_temp_free_i64([[t2]]); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); [[opn]] = (opc == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64([[t0]], [[t0]]); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64([[t0]], [[t0]], t1); [[opn]] = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL([[opn]]); generate_exception(ctx, EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64(ctx, [[t0]], [[rd]]); (void)[[opn]]; MIPS_DEBUG("%s %s, %s, %s", [[opn]], fregnames[[[rd]]], fregnames[rs], fregnames[rt]); tcg_temp_free_i64([[t0]]); tcg_temp_free_i64(t1); }

[[[[Adv]]]]: static void gen_loongson_multimedia(DisasContext *ctx, int [[brookhaven]], int rs, int rt) { const char *[[lago]] = "loongson_cp2"; uint32_t opc, shift_max; TCGv_i64 [[suisse]], t1; opc = MASK_LMI(ctx->opcode); switch (opc) { case OPC_ADD_CP2: case OPC_SUB_CP2: case OPC_DADD_CP2: case OPC_DSUB_CP2: [[suisse]] = tcg_temp_local_new_i64(); t1 = tcg_temp_local_new_i64(); break; default: [[suisse]] = tcg_temp_new_i64(); t1 = tcg_temp_new_i64(); break; } gen_load_fpr64(ctx, [[suisse]], rs); gen_load_fpr64(ctx, t1, rt); #define LMI_HELPER(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0, t1); opn = #LO; break #define LMI_HELPER_1(UP, LO) \ case OPC_##UP: gen_helper_##LO(t0, t0); opn = #LO; break #define LMI_DIRECT(UP, LO, OP) \ case OPC_##UP: tcg_gen_##OP##_i64(t0, t0, t1); opn = #LO; break switch (opc) { LMI_HELPER(PADDSH, paddsh); LMI_HELPER(PADDUSH, paddush); LMI_HELPER(PADDH, paddh); LMI_HELPER(PADDW, paddw); LMI_HELPER(PADDSB, paddsb); LMI_HELPER(PADDUSB, paddusb); LMI_HELPER(PADDB, paddb); LMI_HELPER(PSUBSH, psubsh); LMI_HELPER(PSUBUSH, psubush); LMI_HELPER(PSUBH, psubh); LMI_HELPER(PSUBW, psubw); LMI_HELPER(PSUBSB, psubsb); LMI_HELPER(PSUBUSB, psubusb); LMI_HELPER(PSUBB, psubb); LMI_HELPER(PSHUFH, pshufh); LMI_HELPER(PACKSSWH, packsswh); LMI_HELPER(PACKSSHB, packsshb); LMI_HELPER(PACKUSHB, packushb); LMI_HELPER(PUNPCKLHW, punpcklhw); LMI_HELPER(PUNPCKHHW, punpckhhw); LMI_HELPER(PUNPCKLBH, punpcklbh); LMI_HELPER(PUNPCKHBH, punpckhbh); LMI_HELPER(PUNPCKLWD, punpcklwd); LMI_HELPER(PUNPCKHWD, punpckhwd); LMI_HELPER(PAVGH, pavgh); LMI_HELPER(PAVGB, pavgb); LMI_HELPER(PMAXSH, pmaxsh); LMI_HELPER(PMINSH, pminsh); LMI_HELPER(PMAXUB, pmaxub); LMI_HELPER(PMINUB, pminub); LMI_HELPER(PCMPEQW, pcmpeqw); LMI_HELPER(PCMPGTW, pcmpgtw); LMI_HELPER(PCMPEQH, pcmpeqh); LMI_HELPER(PCMPGTH, pcmpgth); LMI_HELPER(PCMPEQB, pcmpeqb); LMI_HELPER(PCMPGTB, pcmpgtb); LMI_HELPER(PSLLW, psllw); LMI_HELPER(PSLLH, psllh); LMI_HELPER(PSRLW, psrlw); LMI_HELPER(PSRLH, psrlh); LMI_HELPER(PSRAW, psraw); LMI_HELPER(PSRAH, psrah); LMI_HELPER(PMULLH, pmullh); LMI_HELPER(PMULHH, pmulhh); LMI_HELPER(PMULHUH, pmulhuh); LMI_HELPER(PMADDHW, pmaddhw); LMI_HELPER(PASUBUB, pasubub); LMI_HELPER_1(BIADD, biadd); LMI_HELPER_1(PMOVMSKB, pmovmskb); LMI_DIRECT(PADDD, paddd, add); LMI_DIRECT(PSUBD, psubd, sub); LMI_DIRECT(XOR_CP2, xor, xor); LMI_DIRECT(NOR_CP2, nor, nor); LMI_DIRECT(AND_CP2, and, and); LMI_DIRECT(PANDN, pandn, andc); LMI_DIRECT(OR, or, or); case OPC_PINSRH_0: tcg_gen_deposit_i64([[suisse]], [[suisse]], t1, 0, 16); [[lago]] = "pinsrh_0"; break; case OPC_PINSRH_1: tcg_gen_deposit_i64([[suisse]], [[suisse]], t1, 16, 16); [[lago]] = "pinsrh_1"; break; case OPC_PINSRH_2: tcg_gen_deposit_i64([[suisse]], [[suisse]], t1, 32, 16); [[lago]] = "pinsrh_2"; break; case OPC_PINSRH_3: tcg_gen_deposit_i64([[suisse]], [[suisse]], t1, 48, 16); [[lago]] = "pinsrh_3"; break; case OPC_PEXTRH: tcg_gen_andi_i64(t1, t1, 3); tcg_gen_shli_i64(t1, t1, 4); tcg_gen_shr_i64([[suisse]], [[suisse]], t1); tcg_gen_ext16u_i64([[suisse]], [[suisse]]); [[lago]] = "pextrh"; break; case OPC_ADDU_CP2: tcg_gen_add_i64([[suisse]], [[suisse]], t1); tcg_gen_ext32s_i64([[suisse]], [[suisse]]); [[lago]] = "addu"; break; case OPC_SUBU_CP2: tcg_gen_sub_i64([[suisse]], [[suisse]], t1); tcg_gen_ext32s_i64([[suisse]], [[suisse]]); [[lago]] = "addu"; break; case OPC_SLL_CP2: [[lago]] = "sll"; shift_max = 32; goto do_shift; case OPC_SRL_CP2: [[lago]] = "srl"; shift_max = 32; goto do_shift; case OPC_SRA_CP2: [[lago]] = "sra"; shift_max = 32; goto do_shift; case OPC_DSLL_CP2: [[lago]] = "dsll"; shift_max = 64; goto do_shift; case OPC_DSRL_CP2: [[lago]] = "dsrl"; shift_max = 64; goto do_shift; case OPC_DSRA_CP2: [[lago]] = "dsra"; shift_max = 64; goto do_shift; do_shift: tcg_gen_andi_i64(t1, t1, shift_max - 1); switch (opc) { case OPC_SLL_CP2: case OPC_DSLL_CP2: tcg_gen_shl_i64([[suisse]], [[suisse]], t1); break; case OPC_SRA_CP2: case OPC_DSRA_CP2: tcg_gen_sar_i64([[suisse]], [[suisse]], t1); break; case OPC_SRL_CP2: tcg_gen_ext32u_i64([[suisse]], [[suisse]]); case OPC_DSRL_CP2: tcg_gen_shr_i64([[suisse]], [[suisse]], t1); break; } if (shift_max == 32) { tcg_gen_ext32s_i64([[suisse]], [[suisse]]); } tcg_gen_setcondi_i64(TCG_COND_LTU, t1, t1, shift_max); tcg_gen_neg_i64(t1, t1); tcg_gen_and_i64([[suisse]], [[suisse]], t1); break; case OPC_ADD_CP2: case OPC_DADD_CP2: { TCGv_i64 [[pylon]] = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64([[pylon]], [[suisse]]); tcg_gen_add_i64([[suisse]], t1, [[pylon]]); if (opc == OPC_ADD_CP2) { tcg_gen_ext32s_i64([[suisse]], [[suisse]]); } tcg_gen_xor_i64(t1, t1, [[pylon]]); tcg_gen_xor_i64([[pylon]], [[pylon]], [[suisse]]); tcg_gen_andc_i64(t1, [[pylon]], t1); tcg_temp_free_i64([[pylon]]); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); [[lago]] = (opc == OPC_ADD_CP2 ? "add" : "dadd"); break; } case OPC_SUB_CP2: case OPC_DSUB_CP2: { TCGv_i64 [[pylon]] = tcg_temp_new_i64(); int lab = gen_new_label(); tcg_gen_mov_i64([[pylon]], [[suisse]]); tcg_gen_sub_i64([[suisse]], t1, [[pylon]]); if (opc == OPC_SUB_CP2) { tcg_gen_ext32s_i64([[suisse]], [[suisse]]); } tcg_gen_xor_i64(t1, t1, [[pylon]]); tcg_gen_xor_i64([[pylon]], [[pylon]], [[suisse]]); tcg_gen_and_i64(t1, t1, [[pylon]]); tcg_temp_free_i64([[pylon]]); tcg_gen_brcondi_i64(TCG_COND_GE, t1, 0, lab); generate_exception(ctx, EXCP_OVERFLOW); gen_set_label(lab); [[lago]] = (opc == OPC_SUB_CP2 ? "sub" : "dsub"); break; } case OPC_PMULUW: tcg_gen_ext32u_i64([[suisse]], [[suisse]]); tcg_gen_ext32u_i64(t1, t1); tcg_gen_mul_i64([[suisse]], [[suisse]], t1); [[lago]] = "pmuluw"; break; case OPC_SEQU_CP2: case OPC_SEQ_CP2: case OPC_SLTU_CP2: case OPC_SLT_CP2: case OPC_SLEU_CP2: case OPC_SLE_CP2: default: MIPS_INVAL([[lago]]); generate_exception(ctx, EXCP_RI); return; } #undef LMI_HELPER #undef LMI_DIRECT gen_store_fpr64(ctx, [[suisse]], [[brookhaven]]); (void)[[lago]]; MIPS_DEBUG("%s %s, %s, %s", [[lago]], fregnames[[[brookhaven]]], fregnames[rs], fregnames[rt]); tcg_temp_free_i64([[suisse]]); tcg_temp_free_i64(t1); }[Succeeded / Failed / Skipped / Total] 103 / 38 / 109 / 250:   9%|         | 250/2690 [02:35<25:17,  1.61it/s][Succeeded / Failed / Skipped / Total] 103 / 38 / 110 / 251:   9%|         | 251/2690 [02:35<25:10,  1.61it/s][Succeeded / Failed / Skipped / Total] 103 / 38 / 110 / 251:   9%|         | 252/2690 [02:36<25:09,  1.62it/s][Succeeded / Failed / Skipped / Total] 103 / 39 / 110 / 252:   9%|         | 252/2690 [02:36<25:09,  1.62it/s][Succeeded / Failed / Skipped / Total] 104 / 39 / 110 / 253:   9%|         | 253/2690 [02:36<25:09,  1.61it/s][Succeeded / Failed / Skipped / Total] 104 / 39 / 110 / 253:   9%|         | 254/2690 [02:36<25:03,  1.62it/s][Succeeded / Failed / Skipped / Total] 105 / 39 / 110 / 254:   9%|         | 254/2690 [02:36<25:03,  1.62it/s][Succeeded / Failed / Skipped / Total] 105 / 39 / 111 / 255:   9%|         | 255/2690 [02:36<24:56,  1.63it/s][Succeeded / Failed / Skipped / Total] 105 / 39 / 111 / 255:  10%|         | 256/2690 [02:40<25:22,  1.60it/s]
--------------------------------------------- Result 251 ---------------------------------------------
[[0 (65%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void v9fs_stat(void *opaque) { int32_t fid; V9fsStat v9stat; ssize_t err = 0; size_t offset = 7; struct stat stbuf; V9fsFidState *fidp; V9fsPDU *pdu = opaque; V9fsState *s = pdu->s; pdu_unmarshal(pdu, offset, "d", &fid); trace_v9fs_stat(pdu->tag, pdu->id, fid); fidp = get_fid(pdu, fid); if (fidp == NULL) { err = -ENOENT; goto out_nofid; } err = v9fs_co_lstat(pdu, &fidp->path, &stbuf); if (err < 0) { goto out; } err = stat_to_v9stat(pdu, &fidp->path, &stbuf, &v9stat); if (err < 0) { goto out; } offset += pdu_marshal(pdu, offset, "wS", 0, &v9stat); err = offset; trace_v9fs_stat_return(pdu->tag, pdu->id, v9stat.mode, v9stat.atime, v9stat.mtime, v9stat.length); v9fs_stat_free(&v9stat); out: put_fid(pdu, fidp); out_nofid: complete_pdu(s, pdu, err); }
--------------------------------------------- Result 252 ---------------------------------------------
[[0 (9%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *credp) { int retval; V9fsString fullname, target; v9fs_string_init(&fullname); v9fs_string_init(&target); v9fs_string_sprintf(&fullname, "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &fullname, credp->fc_uid, credp->fc_gid); v9fs_string_free(&fullname); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }

[[[[Adv]]]]: static int proxy_symlink(FsContext *fs_ctx, const char *oldpath, V9fsPath *dir_path, const char *name, FsCred *credp) { int retval; V9fsString fullname, target; v9fs_string_init(&fullname); v9fs_string_init(&target); v9fs_string_sprintf(&fullname, "%s/%s", dir_path->data, name); v9fs_string_sprintf(&target, "%s", oldpath); retval = v9fs_request(fs_ctx->private, T_SYMLINK, NULL, "ssdd", &target, &fullname, credp->fc_uid, credp->fc_gid); v9fs_string_free(&fullname); v9fs_string_free(&target); if (retval < 0) { errno = -retval; retval = -1; } return retval; }
--------------------------------------------- Result 253 ---------------------------------------------
[[0 (84%)]] --> [[0 (50%)]] --> Socre: 0.5025937557220459

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t [[op1]], uint64_t [[op2]]) { uint64_t tmp = [[op1]]; [[op1]] = (uint32_t)([[op1]] + [[op2]]); if (unlikely((tmp ^ [[op2]] ^ (-1UL)) & (tmp ^ [[op1]]) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return [[op1]]; }

[[[[Adv]]]]: uint64_t helper_addlv (uint64_t [[surroundings]], uint64_t [[ba]]) { uint64_t tmp = [[surroundings]]; [[surroundings]] = (uint32_t)([[surroundings]] + [[ba]]); if (unlikely((tmp ^ [[ba]] ^ (-1UL)) & (tmp ^ [[surroundings]]) & (1UL << 31))) { arith_excp(env, GETPC(), EXC_M_IOV, 0); } return [[surroundings]]; }
--------------------------------------------- Result 254 ---------------------------------------------
[[0 (63%)]] --> [[0 (42%)]] --> Socre: 0.575604110956192

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *[[group]], RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } [[group]]->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0(([[group]]->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free([[group]]->l2_flood.group_ids); [[group]]->l2_flood.group_ids = g_malloc0([[group]]->l2_flood.group_count * sizeof(uint32_t)); if (![[group]]->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, [[group]]->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < [[group]]->l2_flood.group_count; i++) { [[group]]->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < [[group]]->l2_flood.group_count; i++) { l2_group = of_dpa_group_find(of_dpa, [[group]]->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET([[group]]->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", [[group]]->l2_flood.group_ids[i], [[group]]->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: [[group]]->l2_flood.group_count = 0; g_free([[group]]->l2_flood.group_ids); g_free(tlvs); return err; }

[[[[Adv]]]]: static int of_dpa_cmd_add_l2_flood(OfDpa *of_dpa, OfDpaGroup *[[syndicates]], RockerTlv **group_tlvs) { OfDpaGroup *l2_group; RockerTlv **tlvs; int err; int i; if (!group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT] || !group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]) { return -ROCKER_EINVAL; } [[syndicates]]->l2_flood.group_count = rocker_tlv_get_le16(group_tlvs[ROCKER_TLV_OF_DPA_GROUP_COUNT]); tlvs = g_malloc0(([[syndicates]]->l2_flood.group_count + 1) * sizeof(RockerTlv *)); if (!tlvs) { return -ROCKER_ENOMEM; } g_free([[syndicates]]->l2_flood.group_ids); [[syndicates]]->l2_flood.group_ids = g_malloc0([[syndicates]]->l2_flood.group_count * sizeof(uint32_t)); if (![[syndicates]]->l2_flood.group_ids) { err = -ROCKER_ENOMEM; goto err_out; } rocker_tlv_parse_nested(tlvs, [[syndicates]]->l2_flood.group_count, group_tlvs[ROCKER_TLV_OF_DPA_GROUP_IDS]); for (i = 0; i < [[syndicates]]->l2_flood.group_count; i++) { [[syndicates]]->l2_flood.group_ids[i] = rocker_tlv_get_le32(tlvs[i + 1]); } for (i = 0; i < [[syndicates]]->l2_flood.group_count; i++) { l2_group = of_dpa_group_find(of_dpa, [[syndicates]]->l2_flood.group_ids[i]); if (!l2_group) { continue; } if ((ROCKER_GROUP_TYPE_GET(l2_group->id) == ROCKER_OF_DPA_GROUP_TYPE_L2_INTERFACE) && (ROCKER_GROUP_VLAN_GET(l2_group->id) != ROCKER_GROUP_VLAN_GET([[syndicates]]->id))) { DPRINTF("l2 interface group 0x%08x VLAN doesn't match l2 " "flood group 0x%08x\n", [[syndicates]]->l2_flood.group_ids[i], [[syndicates]]->id); err = -ROCKER_EINVAL; goto err_out; } } g_free(tlvs); return ROCKER_OK; err_out: [[syndicates]]->l2_flood.group_count = 0; g_free([[syndicates]]->l2_flood.group_ids); g_free(tlvs); return err; }
--------------------------------------------- Result 255 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int LLVMFuzzerTestOneInput(const uint8_t *data, size_t size) { const uint64_t fuzz_tag = FUZZ_TAG; FuzzDataBuffer buffer; const uint8_t *last = data; const uint8_t *end = data + size; uint32_t it = 0; if (!c) c = AVCodecInitialize(FFMPEG_CODEC); AVCodecContext* ctx = avcodec_alloc_context3(NULL); if (!ctx) error("Failed memory allocation"); ctx->max_pixels = 4096 * 4096; int res = avcodec_open2(ctx, c, NULL); if (res < 0) return res; FDBCreate(&buffer); int got_frame; AVFrame *frame = av_frame_alloc(); if (!frame) error("Failed memory allocation"); AVPacket avpkt; while (data < end && it < maxiteration) { while (data + sizeof(fuzz_tag) < end) { if (data[0] == (fuzz_tag & 0xFF) && *(const uint64_t *)(data) == fuzz_tag) break; data++; } if (data + sizeof(fuzz_tag) > end) data = end; FDBPrepare(&buffer, &avpkt, last, data - last); data += sizeof(fuzz_tag); last = data; while (avpkt.size > 0 && it++ < maxiteration) { av_frame_unref(frame); int ret = decode_handler(ctx, frame, &got_frame, &avpkt); if (it > 20) ctx->error_concealment = 0; if (ret <= 0 || ret > avpkt.size) break; avpkt.data += ret; avpkt.size -= ret; } } av_init_packet(&avpkt); avpkt.data = NULL; avpkt.size = 0; do { got_frame = 0; decode_handler(ctx, frame, &got_frame, &avpkt); } while (got_frame == 1 && it++ < maxiteration); av_frame_free(&frame); avcodec_free_context(&ctx); av_freep(&ctx); FDBDesroy(&buffer); return 0; }
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 105 / 40 / 111 / 256:  10%|         | 256/2690 [02:40<25:22,  1.60it/s][Succeeded / Failed / Skipped / Total] 105 / 40 / 112 / 257:  10%|         | 257/2690 [02:40<25:16,  1.60it/s][Succeeded / Failed / Skipped / Total] 105 / 40 / 112 / 257:  10%|         | 258/2690 [02:42<25:34,  1.58it/s][Succeeded / Failed / Skipped / Total] 105 / 41 / 112 / 258:  10%|         | 258/2690 [02:42<25:34,  1.58it/s][Succeeded / Failed / Skipped / Total] 106 / 41 / 112 / 259:  10%|         | 259/2690 [02:43<25:33,  1.59it/s][Succeeded / Failed / Skipped / Total] 106 / 41 / 112 / 259:  10%|         | 260/2690 [02:43<25:29,  1.59it/s][[0 (21%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src) { int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, dest, src); #ifndef CONFIG_USER_ONLY if ((l > 32) && (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) && (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) { if (dest == (src + 1)) { mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src)); return; } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, l + 1, dest, src); return; } } #else if (dest == (src + 1)) { memset(g2h(dest), cpu_ldub_data(env, src), l + 1); return; } else if ((dest < src) || (src + l < dest)) { memmove(g2h(dest), g2h(src), l + 1); return; } #endif if ((dest + 8 <= src) || (src + 8 <= dest)) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x)); x += 8; } } for (i = x; i <= l; i++) { cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i)); } }

[[[[Adv]]]]: void HELPER(mvc)(CPUS390XState *env, uint32_t l, uint64_t dest, uint64_t src) { int i = 0; int x = 0; uint32_t l_64 = (l + 1) / 8; HELPER_LOG("%s l %d dest %" PRIx64 " src %" PRIx64 "\n", __func__, l, dest, src); #ifndef CONFIG_USER_ONLY if ((l > 32) && (src & TARGET_PAGE_MASK) == ((src + l) & TARGET_PAGE_MASK) && (dest & TARGET_PAGE_MASK) == ((dest + l) & TARGET_PAGE_MASK)) { if (dest == (src + 1)) { mvc_fast_memset(env, l + 1, dest, cpu_ldub_data(env, src)); return; } else if ((src & TARGET_PAGE_MASK) != (dest & TARGET_PAGE_MASK)) { mvc_fast_memmove(env, l + 1, dest, src); return; } } #else if (dest == (src + 1)) { memset(g2h(dest), cpu_ldub_data(env, src), l + 1); return; } else if ((dest < src) || (src + l < dest)) { memmove(g2h(dest), g2h(src), l + 1); return; } #endif if ((dest + 8 <= src) || (src + 8 <= dest)) { for (i = 0; i < l_64; i++) { cpu_stq_data(env, dest + x, cpu_ldq_data(env, src + x)); x += 8; } } for (i = x; i <= l; i++) { cpu_stb_data(env, dest + i, cpu_ldub_data(env, src + i)); } }
--------------------------------------------- Result 257 ---------------------------------------------
[[0 (52%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int hdev_open(BlockDriverState *bs, const char *filename, int flags) { BDRVRawState *s = bs->opaque; int access_flags, create_flags; DWORD overlapped; char device_name[64]; if (strstart(filename, "/dev/cdrom", NULL)) { if (find_cdrom(device_name, sizeof(device_name)) < 0) return -ENOENT; filename = device_name; } else { if (((filename[0] >= 'a' && filename[0] <= 'z') || (filename[0] >= 'A' && filename[0] <= 'Z')) && filename[1] == ':' && filename[2] == '\0') { snprintf(device_name, sizeof(device_name), "\\\\.\\%c:", filename[0]); filename = device_name; } } s->type = find_device_type(bs, filename); if ((flags & BDRV_O_ACCESS) == O_RDWR) { access_flags = GENERIC_READ | GENERIC_WRITE; } else { access_flags = GENERIC_READ; } create_flags = OPEN_EXISTING; #ifdef QEMU_TOOL overlapped = FILE_ATTRIBUTE_NORMAL; #else overlapped = FILE_FLAG_OVERLAPPED; #endif s->hfile = CreateFile(filename, access_flags, FILE_SHARE_READ, NULL, create_flags, overlapped, NULL); if (s->hfile == INVALID_HANDLE_VALUE) return -1; return 0; }
--------------------------------------------- Result 258 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void omap_pwt_write(void *opaque, target_phys_addr_t addr, uint64_t value, unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) opaque; int offset = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8(opaque, addr, value); } switch (offset) { case 0x00: s->frc = value & 0x3f; break; case 0x04: if ((value ^ s->vrc) & 1) { if (value & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate(s->clk) >> 3) / ((s->gcr & 2) ? 1 : 154) / (2 << (value & 3)) * ((value & (1 << 2)) ? 101 : 107) * ((value & (1 << 3)) ? 49 : 55) * ((value & (1 << 4)) ? 50 : 63) * ((value & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } s->vrc = value & 0x7f; break; case 0x08: s->gcr = value & 3; break; default: OMAP_BAD_REG(addr); return; } }

[[[[Adv]]]]: static void omap_pwt_write(void *opaque, target_phys_addr_t addr, uint64_t value, unsigned size) { struct omap_pwt_s *s = (struct omap_pwt_s *) opaque; int offset = addr & OMAP_MPUI_REG_MASK; if (size != 1) { return omap_badwidth_write8(opaque, addr, value); } switch (offset) { case 0x00: s->frc = value & 0x3f; break; case 0x04: if ((value ^ s->vrc) & 1) { if (value & 1) printf("%s: %iHz buzz on\n", __FUNCTION__, (int) ((omap_clk_getrate(s->clk) >> 3) / ((s->gcr & 2) ? 1 : 154) / (2 << (value & 3)) * ((value & (1 << 2)) ? 101 : 107) * ((value & (1 << 3)) ? 49 : 55) * ((value & (1 << 4)) ? 50 : 63) * ((value & (1 << 5)) ? 80 : 127) / (107 * 55 * 63 * 127))); else printf("%s: silence!\n", __FUNCTION__); } s->vrc = value & 0x7f; break; case 0x08: s->gcr = value & 3; break; default: OMAP_BAD_REG(addr); return; } }
--------------------------------------------- Result 259 ---------------------------------------------
[[0 (40%)]] --> [[0 (50%)]] --> Socre: 0.5039162635803223

[[[[Adv]]]]: static int cpu_gdb_write_register(CPUState *[[env]], uint8_t *[[mem_buf]], int [[n]]) { target_ulong [[tmp]]; [[tmp]] = ldtul_p([[mem_buf]]); if ([[n]] < 32) { [[env]]->active_tc.gpr[[[n]]] = [[tmp]]; return sizeof(target_ulong); } if ([[env]]->CP0_Config1 & (1 << CP0C1_FP) && [[n]] >= 38 && [[n]] < 73) { if ([[n]] < 70) { if ([[env]]->CP0_Status & (1 << CP0St_FR)) [[env]]->active_fpu.fpr[[[n]] - 38].d = [[tmp]]; else [[env]]->active_fpu.fpr[[[n]] - 38].w[FP_ENDIAN_IDX] = [[tmp]]; } switch ([[n]]) { case 70: [[env]]->active_fpu.fcr31 = [[tmp]] & 0xFF83FFFF; RESTORE_ROUNDING_MODE; #ifndef CONFIG_SOFTFLOAT SET_FP_ENABLE([[env]]->active_fpu.fcr31, 0); #endif break; case 71: [[env]]->active_fpu.fcr0 = [[tmp]]; break; } return sizeof(target_ulong); } switch ([[n]]) { case 32: [[env]]->CP0_Status = [[tmp]]; break; case 33: [[env]]->active_tc.LO[0] = [[tmp]]; break; case 34: [[env]]->active_tc.HI[0] = [[tmp]]; break; case 35: [[env]]->CP0_BadVAddr = [[tmp]]; break; case 36: [[env]]->CP0_Cause = [[tmp]]; break; case 37: [[env]]->active_tc.PC = [[tmp]]; break; case 72: break; default: if ([[n]] > 89) return 0; break; } return sizeof(target_ulong); }

[[[[Adv]]]]: static int cpu_gdb_write_register(CPUState *[[heebie]], uint8_t *[[roadworks]], int [[northerly]]) { target_ulong [[quantum]]; [[quantum]] = ldtul_p([[roadworks]]); if ([[northerly]] < 32) { [[heebie]]->active_tc.gpr[[[northerly]]] = [[quantum]]; return sizeof(target_ulong); } if ([[heebie]]->CP0_Config1 & (1 << CP0C1_FP) && [[northerly]] >= 38 && [[northerly]] < 73) { if ([[northerly]] < 70) { if ([[heebie]]->CP0_Status & (1 << CP0St_FR)) [[heebie]]->active_fpu.fpr[[[northerly]] - 38].d = [[quantum]]; else [[heebie]]->active_fpu.fpr[[[northerly]] - 38].w[FP_ENDIAN_IDX] = [[quantum]]; } switch ([[northerly]]) { case 70: [[heebie]]->active_fpu.fcr31 = [[quantum]] & 0xFF83FFFF; RESTORE_ROUNDING_MODE; #ifndef CONFIG_SOFTFLOAT SET_FP_ENABLE([[heebie]]->active_fpu.fcr31, 0); #endif break; case 71: [[heebie]]->active_fpu.fcr0 = [[quantum]]; break; } return sizeof(target_ulong); } switch ([[northerly]]) { case 32: [[heebie]]->CP0_Status = [[quantum]]; break; case 33: [[heebie]]->active_tc.LO[0] = [[quantum]]; break; case 34: [[heebie]]->active_tc.HI[0] = [[quantum]]; break; case 35: [[heebie]]->CP0_BadVAddr = [[quantum]]; break; case 36: [[heebie]]->CP0_Cause = [[quantum]]; break; case 37: [[heebie]]->active_tc.PC = [[quantum]]; break; case 72: break; default: if ([[northerly]] > 89) return 0; break; } return sizeof(target_ulong); }
--------------------------------------------- Result 260 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 107 / 41 / 112 / 260:  10%|         | 260/2690 [02:43<25:29,  1.59it/s][Succeeded / Failed / Skipped / Total] 108 / 41 / 112 / 261:  10%|         | 261/2690 [02:44<25:35,  1.58it/s][Succeeded / Failed / Skipped / Total] 108 / 41 / 112 / 261:  10%|         | 262/2690 [02:44<25:29,  1.59it/s][Succeeded / Failed / Skipped / Total] 108 / 41 / 113 / 262:  10%|         | 262/2690 [02:44<25:29,  1.59it/s][[0 (43%)]] --> [[0 (53%)]] --> Socre: 0.5279613733291626

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[opaque]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[opaque]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }

[[[[Adv]]]]: QEMUBH *aio_bh_new(AioContext *ctx, QEMUBHFunc *cb, void *[[incomprehensible]]) { QEMUBH *bh; bh = g_malloc0(sizeof(QEMUBH)); bh->ctx = ctx; bh->cb = cb; bh->opaque = [[incomprehensible]]; qemu_mutex_lock(&ctx->bh_lock); bh->next = ctx->first_bh; smp_wmb(); ctx->first_bh = bh; qemu_mutex_unlock(&ctx->bh_lock); return bh; }
--------------------------------------------- Result 261 ---------------------------------------------
[[0 (42%)]] --> [[0 (52%)]] --> Socre: 0.5208030343055725

[[[[Adv]]]]: static void audiogen(void *[[data]], enum AVSampleFormat sample_fmt, int channels, int sample_rate, int nb_samples) { int [[i]], ch, k; double v, f, a, ampa; double tabf1[SWR_CH_MAX]; double tabf2[SWR_CH_MAX]; double taba[SWR_CH_MAX]; unsigned static rnd; #define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v); #define uint_rand(x) (x = x * 1664525 + 1013904223) #define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1) k = 0; a = 0; for ([[i]] = 0; [[i]] < 1 * sample_rate && k < nb_samples; [[i]]++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE a += M_PI * 1000.0 * 2.0 / sample_rate; } a = 0; for ([[i]] = 0; [[i]] < 1 * sample_rate && k < nb_samples; [[i]]++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE f = 100.0 + (((10000.0 - 100.0) * [[i]]) / sample_rate); a += M_PI * f * 2.0 / sample_rate; } for ([[i]] = 0; [[i]] < sample_rate / 2 && k < nb_samples; [[i]]++, k++) { v = dbl_rand(rnd) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for ([[i]] = 0; [[i]] < sample_rate / 2 && k < nb_samples; [[i]]++, k++) { v = dbl_rand(rnd); for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (ch = 0; ch < channels; ch++) { taba[ch] = 0; tabf1[ch] = 100 + uint_rand(rnd) % 5000; tabf2[ch] = 100 + uint_rand(rnd) % 5000; } for ([[i]] = 0; [[i]] < 1 * sample_rate && k < nb_samples; [[i]]++, k++) { for (ch = 0; ch < channels; ch++) { v = sin(taba[ch]) * 0.30; PUT_SAMPLE f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * [[i]]) / sample_rate); taba[ch] += M_PI * f * 2.0 / sample_rate; } } a = 0; ampa = 0; for ([[i]] = 0; [[i]] < 2 * sample_rate && k < nb_samples; [[i]]++, k++) { for (ch = 0; ch < channels; ch++) { double amp = (1.0 + sin(ampa)) * 0.15; if (ch & 1) amp = 0.30 - amp; v = sin(a) * amp; PUT_SAMPLE a += M_PI * 500.0 * 2.0 / sample_rate; ampa += M_PI * 2.0 / sample_rate; } } }

[[[[Adv]]]]: static void audiogen(void *[[stats]], enum AVSampleFormat sample_fmt, int channels, int sample_rate, int nb_samples) { int [[gonna]], ch, k; double v, f, a, ampa; double tabf1[SWR_CH_MAX]; double tabf2[SWR_CH_MAX]; double taba[SWR_CH_MAX]; unsigned static rnd; #define PUT_SAMPLE set(data, ch, k, channels, sample_fmt, v); #define uint_rand(x) (x = x * 1664525 + 1013904223) #define dbl_rand(x) (uint_rand(x)*2.0 / (double)UINT_MAX - 1) k = 0; a = 0; for ([[gonna]] = 0; [[gonna]] < 1 * sample_rate && k < nb_samples; [[gonna]]++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE a += M_PI * 1000.0 * 2.0 / sample_rate; } a = 0; for ([[gonna]] = 0; [[gonna]] < 1 * sample_rate && k < nb_samples; [[gonna]]++, k++) { v = sin(a) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE f = 100.0 + (((10000.0 - 100.0) * [[gonna]]) / sample_rate); a += M_PI * f * 2.0 / sample_rate; } for ([[gonna]] = 0; [[gonna]] < sample_rate / 2 && k < nb_samples; [[gonna]]++, k++) { v = dbl_rand(rnd) * 0.30; for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for ([[gonna]] = 0; [[gonna]] < sample_rate / 2 && k < nb_samples; [[gonna]]++, k++) { v = dbl_rand(rnd); for (ch = 0; ch < channels; ch++) PUT_SAMPLE } for (ch = 0; ch < channels; ch++) { taba[ch] = 0; tabf1[ch] = 100 + uint_rand(rnd) % 5000; tabf2[ch] = 100 + uint_rand(rnd) % 5000; } for ([[gonna]] = 0; [[gonna]] < 1 * sample_rate && k < nb_samples; [[gonna]]++, k++) { for (ch = 0; ch < channels; ch++) { v = sin(taba[ch]) * 0.30; PUT_SAMPLE f = tabf1[ch] + (((tabf2[ch] - tabf1[ch]) * [[gonna]]) / sample_rate); taba[ch] += M_PI * f * 2.0 / sample_rate; } } a = 0; ampa = 0; for ([[gonna]] = 0; [[gonna]] < 2 * sample_rate && k < nb_samples; [[gonna]]++, k++) { for (ch = 0; ch < channels; ch++) { double amp = (1.0 + sin(ampa)) * 0.15; if (ch & 1) amp = 0.30 - amp; v = sin(a) * amp; PUT_SAMPLE a += M_PI * 500.0 * 2.0 / sample_rate; ampa += M_PI * 2.0 / sample_rate; } } }
--------------------------------------------- Result 262 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void paint_mouse_pointer(AVFormatContext *s1, struct gdigrab *gdigrab) { CURSORINFO ci = {0}; #define CURSOR_ERROR(str) \ if (!gdigrab->cursor_error_printed) { \ WIN32_API_ERROR(str); \ gdigrab->cursor_error_printed = 1; \ } ci.cbSize = sizeof(ci); if (GetCursorInfo(&ci)) { HCURSOR icon = CopyCursor(ci.hCursor); ICONINFO info; POINT pos; RECT clip_rect = gdigrab->clip_rect; HWND hwnd = gdigrab->hwnd; info.hbmMask = NULL; info.hbmColor = NULL; if (ci.flags != CURSOR_SHOWING) return; if (!icon) { icon = CopyCursor(LoadCursor(NULL, IDC_ARROW)); } if (!GetIconInfo(icon, &info)) { CURSOR_ERROR("Could not get icon info"); goto icon_error; } pos.x = ci.ptScreenPos.x - clip_rect.left - info.xHotspot; pos.y = ci.ptScreenPos.y - clip_rect.top - info.yHotspot; if (hwnd) { RECT rect; if (GetWindowRect(hwnd, &rect)) { pos.x -= rect.left; pos.y -= rect.top; } else { CURSOR_ERROR("Couldn't get window rectangle"); goto icon_error; } } av_log(s1, AV_LOG_DEBUG, "Cursor pos (%li,%li) -> (%li,%li)\n", ci.ptScreenPos.x, ci.ptScreenPos.y, pos.x, pos.y); if (pos.x >= 0 && pos.x <= clip_rect.right - clip_rect.left && pos.y >= 0 && pos.y <= clip_rect.bottom - clip_rect.top) { if (!DrawIcon(gdigrab->dest_hdc, pos.x, pos.y, icon)) CURSOR_ERROR("Couldn't draw icon"); } icon_error: if (icon) DestroyCursor(icon); } else { CURSOR_ERROR("Couldn't get cursor info"); } }
--------------------------------------------- Result 263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 108 / 41 / 114 / 263:  10%|         | 263/2690 [02:45<25:22,  1.59it/s][Succeeded / Failed / Skipped / Total] 109 / 41 / 114 / 264:  10%|         | 264/2690 [02:45<25:16,  1.60it/s][Succeeded / Failed / Skipped / Total] 109 / 41 / 115 / 265:  10%|         | 265/2690 [02:45<25:10,  1.61it/s][Succeeded / Failed / Skipped / Total] 110 / 41 / 115 / 266:  10%|         | 266/2690 [02:45<25:04,  1.61it/s][Succeeded / Failed / Skipped / Total] 110 / 41 / 115 / 266:  10%|         | 267/2690 [02:45<24:58,  1.62it/s][Succeeded / Failed / Skipped / Total] 110 / 41 / 116 / 267:  10%|         | 267/2690 [02:45<24:58,  1.62it/s][Succeeded / Failed / Skipped / Total] 110 / 41 / 117 / 268:  10%|         | 268/2690 [02:45<24:52,  1.62it/s][[0 (44%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void machine_initfn(Object *obj) { MachineState *ms = MACHINE(obj); ms->kernel_irqchip_allowed = "True" == "True"; ms->kvm_shadow_mem = -1; ms->dump_guest_core = "True" == "True"; object_property_add_str(obj, "accel", machine_get_accel, machine_set_accel, NULL); object_property_set_description(obj, "accel", "Accelerator list", NULL); object_property_add_bool(obj, "kernel-irqchip", NULL, machine_set_kernel_irqchip, NULL); object_property_set_description(obj, "kernel-irqchip", "Use KVM in-kernel irqchip", NULL); object_property_add(obj, "kvm-shadow-mem", "int", machine_get_kvm_shadow_mem, machine_set_kvm_shadow_mem, NULL, NULL, NULL); object_property_set_description(obj, "kvm-shadow-mem", "KVM shadow MMU size", NULL); object_property_add_str(obj, "kernel", machine_get_kernel, machine_set_kernel, NULL); object_property_set_description(obj, "kernel", "Linux kernel image file", NULL); object_property_add_str(obj, "initrd", machine_get_initrd, machine_set_initrd, NULL); object_property_set_description(obj, "initrd", "Linux initial ramdisk file", NULL); object_property_add_str(obj, "append", machine_get_append, machine_set_append, NULL); object_property_set_description(obj, "append", "Linux kernel command line", NULL); object_property_add_str(obj, "dtb", machine_get_dtb, machine_set_dtb, NULL); object_property_set_description(obj, "dtb", "Linux kernel device tree file", NULL); object_property_add_str(obj, "dumpdtb", machine_get_dumpdtb, machine_set_dumpdtb, NULL); object_property_set_description(obj, "dumpdtb", "Dump current dtb to a file and quit", NULL); object_property_add(obj, "phandle-start", "int", machine_get_phandle_start, machine_set_phandle_start, NULL, NULL, NULL); object_property_set_description(obj, "phandle-start", "The first phandle ID we may generate dynamically", NULL); object_property_add_str(obj, "dt-compatible", machine_get_dt_compatible, machine_set_dt_compatible, NULL); object_property_set_description(obj, "dt-compatible", "Overrides the \"compatible\" property of the dt root node", NULL); object_property_add_bool(obj, "dump-guest-core", machine_get_dump_guest_core, machine_set_dump_guest_core, NULL); object_property_set_description(obj, "dump-guest-core", "Include guest memory in a core dump", NULL); object_property_add_bool(obj, "mem-merge", machine_get_mem_merge, machine_set_mem_merge, NULL); object_property_set_description(obj, "mem-merge", "Enable/disable memory merge support", NULL); object_property_add_bool(obj, "usb", machine_get_usb, machine_set_usb, NULL); object_property_set_description(obj, "usb", "Set on/off to enable/disable usb", NULL); object_property_add_str(obj, "firmware", machine_get_firmware, machine_set_firmware, NULL); object_property_set_description(obj, "firmware", "Firmware image", NULL); object_property_add_bool(obj, "iommu", machine_get_iommu, machine_set_iommu, NULL); object_property_set_description(obj, "iommu", "Set on/off to enable/disable Intel IOMMU (VT-d)", NULL); ms->sysbus_notifier.notify = machine_init_notify; qemu_add_machine_init_done_notifier(&ms->sysbus_notifier); }
--------------------------------------------- Result 264 ---------------------------------------------
[[0 (5%)]] --> [[0 (71%)]] --> Socre: 0.7132117748260498

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *s) { uint32_t [[insn]]; [[insn]] = arm_ldl_code(env, s->pc, s->bswap_code); s->insn = [[insn]]; s->pc += 4; switch (([[insn]] >> 24) & 0x1f) { default: unallocated_encoding(s); break; } if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) { s->is_jmp = DISAS_JUMP; } }

[[[[Adv]]]]: void disas_a64_insn(CPUARMState *env, DisasContext *s) { uint32_t [[unreal]]; [[unreal]] = arm_ldl_code(env, s->pc, s->bswap_code); s->insn = [[unreal]]; s->pc += 4; switch (([[unreal]] >> 24) & 0x1f) { default: unallocated_encoding(s); break; } if (unlikely(s->singlestep_enabled) && (s->is_jmp == DISAS_TB_JUMP)) { s->is_jmp = DISAS_JUMP; } }
--------------------------------------------- Result 265 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void hmp_migrate_status_cb(void *opaque) { MigrationStatus *status = opaque; MigrationInfo *info; info = qmp_query_migrate(NULL); if (!info->has_status || strcmp(info->status, "active") == 0) { if (info->has_disk) { int progress; if (info->disk->remaining) { progress = info->disk->transferred * 100 / info->disk->total; } else { progress = 100; } monitor_printf(status->mon, "Completed %d %%\r", progress); monitor_flush(status->mon); } timer_mod(status->timer, qemu_clock_get_ms(QEMU_CLOCK_REALTIME) + 1000); } else { if (status->is_block_migration) { monitor_printf(status->mon, "\n"); } monitor_resume(status->mon); timer_del(status->timer); g_free(status); } qapi_free_MigrationInfo(info); }
--------------------------------------------- Result 266 ---------------------------------------------
[[0 (53%)]] --> [[0 (37%)]] --> Socre: 0.6297080814838409

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[bs]]) { assert(![[bs]]->peer); if ([[bs]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[bs]], list); } bdrv_close([[bs]]); if ([[bs]]->file != NULL) { bdrv_delete([[bs]]->file); } assert([[bs]] != bs_snapshots); qemu_free([[bs]]); }

[[[[Adv]]]]: void bdrv_delete(BlockDriverState *[[bolivia]]) { assert(![[bolivia]]->peer); if ([[bolivia]]->device_name[0] != '\0') { QTAILQ_REMOVE(&bdrv_states, [[bolivia]], list); } bdrv_close([[bolivia]]); if ([[bolivia]]->file != NULL) { bdrv_delete([[bolivia]]->file); } assert([[bolivia]] != bs_snapshots); qemu_free([[bolivia]]); }
--------------------------------------------- Result 267 ---------------------------------------------
[[0 (47%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: coroutine_fn iscsi_co_pdiscard(BlockDriverState *bs, int64_t offset, int bytes) { IscsiLun *iscsilun = bs->opaque; struct IscsiTask iTask; struct unmap_list list; int r = 0; if (!is_byte_request_lun_aligned(offset, bytes, iscsilun)) { return -ENOTSUP; } if (!iscsilun->lbp.lbpu) { return 0; } list.lba = offset / iscsilun->block_size; list.num = bytes / iscsilun->block_size; iscsi_co_init_iscsitask(iscsilun, &iTask); qemu_mutex_lock(&iscsilun->mutex); retry: if (iscsi_unmap_task(iscsilun->iscsi, iscsilun->lun, 0, 0, &list, 1, iscsi_co_generic_cb, &iTask) == NULL) { r = -ENOMEM; goto out_unlock; } while (!iTask.complete) { iscsi_set_events(iscsilun); qemu_mutex_unlock(&iscsilun->mutex); qemu_coroutine_yield(); qemu_mutex_lock(&iscsilun->mutex); } if (iTask.task != NULL) { scsi_free_scsi_task(iTask.task); iTask.task = NULL; } if (iTask.do_retry) { iTask.complete = 0; goto retry; } if (iTask.status == SCSI_STATUS_CHECK_CONDITION) { goto out_unlock; } if (iTask.status != SCSI_STATUS_GOOD) { r = iTask.err_code; goto out_unlock; } iscsi_allocmap_set_invalid(iscsilun, offset >> BDRV_SECTOR_BITS, bytes >> BDRV_SECTOR_BITS); out_unlock: qemu_mutex_unlock(&iscsilun->mutex); return r; }
--------------------------------------------- Result 268 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int mips_cpu_handle_mmu_fault(CPUState *cs, vaddr address, int rw, int mmu_idx) { MIPSCPU *cpu = MIPS_CPU(cs); CPUMIPSState *env = &cpu->env; #if !defined(CONFIG_USER_ONLY) hwaddr physical; int prot; int access_type; #endif int ret = 0; #if 0 log_cpu_state(cs, 0); #endif qemu_log_mask(CPU_LOG_MMU, "%s pc " TARGET_FMT_lx " ad %" VADDR_PRIx " rw %d mmu_idx %d\n", __func__, env->active_tc.PC, address, rw, mmu_idx); #if !defined(CONFIG_USER_ONLY) access_type = ACCESS_INT; ret = get_physical_address(env, &physical, &prot, address, rw, access_type); qemu_log_mask(CPU_LOG_MMU, "%s address=%" VADDR_PRIx " ret %d physical " TARGET_FMT_plx " prot %d\n", __func__, address, ret, physical, prot); if (ret == TLBRET_MATCH) { tlb_set_page(cs, address & TARGET_PAGE_MASK, physical & TARGET_PAGE_MASK, prot | PAGE_EXEC, mmu_idx, TARGET_PAGE_SIZE); ret = 0; } else if (ret < 0) #endif { raise_mmu_exception(env, address, rw, ret); ret = 1; } return ret; }
--------------------------------------------- Result 269 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 111 / 41 / 117 / 269:  10%|         | 269/2690 [02:45<24:46,  1.63it/s][Succeeded / Failed / Skipped / Total] 112 / 41 / 117 / 270:  10%|         | 270/2690 [02:45<24:41,  1.63it/s][Succeeded / Failed / Skipped / Total] 113 / 41 / 117 / 271:  10%|         | 271/2690 [02:45<24:35,  1.64it/s][Succeeded / Failed / Skipped / Total] 113 / 41 / 117 / 271:  10%|         | 272/2690 [03:00<26:43,  1.51it/s][Succeeded / Failed / Skipped / Total] 114 / 41 / 117 / 272:  10%|         | 272/2690 [03:00<26:43,  1.51it/s][Succeeded / Failed / Skipped / Total] 114 / 41 / 117 / 272:  10%|         | 273/2690 [03:00<26:38,  1.51it/s][Succeeded / Failed / Skipped / Total] 115 / 41 / 117 / 273:  10%|         | 273/2690 [03:00<26:38,  1.51it/s][Succeeded / Failed / Skipped / Total] 115 / 41 / 118 / 274:  10%|         | 274/2690 [03:00<26:31,  1.52it/s][Succeeded / Failed / Skipped / Total] 115 / 41 / 118 / 274:  10%|         | 275/2690 [03:00<26:27,  1.52it/s][Succeeded / Failed / Skipped / Total] 116 / 41 / 118 / 275:  10%|         | 275/2690 [03:00<26:27,  1.52it/s][Succeeded / Failed / Skipped / Total] 116 / 41 / 119 / 276:  10%|         | 276/2690 [03:00<26:20,  1.53it/s][Succeeded / Failed / Skipped / Total] 116 / 41 / 119 / 276:  10%|         | 277/2690 [03:01<26:20,  1.53it/s][[0 (16%)]] --> [[0 (53%)]] --> Socre: 0.532581090927124

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[type]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[type]]]; return l; }

[[[[Adv]]]]: static ModuleTypeList *find_type(module_init_type [[blokes]]) { ModuleTypeList *l; init_types(); l = &init_type_list[[[blokes]]]; return l; }
--------------------------------------------- Result 270 ---------------------------------------------
[[0 (41%)]] --> [[0 (62%)]] --> Socre: 0.6160147190093994

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[r]] = suspend_requested; suspend_requested = 0; return [[r]]; }

[[[[Adv]]]]: static int qemu_suspend_requested(void) { int [[ies]] = suspend_requested; suspend_requested = 0; return [[ies]]; }
--------------------------------------------- Result 271 ---------------------------------------------
[[0 (47%)]] --> [[0 (51%)]] --> Socre: 0.5116822123527527

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *[[addr]]) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && [[addr]] && code == BUS_MCEERR_AO) { void *[[vaddr]]; ram_addr_t [[ram_addr]]; target_phys_addr_t [[paddr]]; [[vaddr]] = [[addr]]; if (qemu_ram_addr_from_host([[vaddr]], &[[ram_addr]]) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, [[ram_addr]], &[[paddr]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", [[addr]]); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[paddr]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }

[[[[Adv]]]]: int kvm_arch_on_sigbus(int code, void *[[capito]]) { #ifdef KVM_CAP_MCE if ((first_cpu->mcg_cap & MCG_SER_P) && [[capito]] && code == BUS_MCEERR_AO) { void *[[dessie]]; ram_addr_t [[mash]]; target_phys_addr_t [[arrhythmia]]; [[dessie]] = [[capito]]; if (qemu_ram_addr_from_host([[dessie]], &[[mash]]) || !kvm_physical_memory_addr_from_ram(first_cpu->kvm_state, [[mash]], &[[arrhythmia]])) { fprintf(stderr, "Hardware memory error for memory used by " "QEMU itself instead of guest system!: %p\n", [[capito]]); return 0; } kvm_mce_inj_srao_memscrub2(first_cpu, [[arrhythmia]]); } else #endif { if (code == BUS_MCEERR_AO) { return 0; } else if (code == BUS_MCEERR_AR) { hardware_memory_error(); } else { return 1; } } return 0; }
--------------------------------------------- Result 272 ---------------------------------------------
[[0 (8%)]] --> [[0 (54%)]] --> Socre: 0.5434802770614624

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int [[ot]], TCGv [[t0]], int [[reg]]) { switch([[ot]]) { case OT_BYTE: if ([[reg]] < 4 X86_64_DEF( || [[reg]] >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[t0]], cpu_regs[[[reg]] - 4], 8); tcg_gen_ext8u_tl([[t0]], [[t0]]); } break; default: std_case: tcg_gen_mov_tl([[t0]], cpu_regs[[[reg]]]); break; } }

[[[[Adv]]]]: static inline void gen_op_mov_v_reg(int [[osu]], TCGv [[johanne]], int [[denzel]]) { switch([[osu]]) { case OT_BYTE: if ([[denzel]] < 4 X86_64_DEF( || [[denzel]] >= 8 || x86_64_hregs)) { goto std_case; } else { tcg_gen_shri_tl([[johanne]], cpu_regs[[[denzel]] - 4], 8); tcg_gen_ext8u_tl([[johanne]], [[johanne]]); } break; default: std_case: tcg_gen_mov_tl([[johanne]], cpu_regs[[[denzel]]]); break; } }
--------------------------------------------- Result 273 ---------------------------------------------
[[0 (73%)]] --> [[0 (50%)]] --> Socre: 0.5049982964992523

[[[[Adv]]]]: static void serial_tx_done(void *opaque) { SerialState *s = opaque; if (s->tx_burst < 0) { uint16_t [[divider]]; if (s->divider) [[divider]] = s->divider; else [[divider]] = 1; s->tx_burst = THROTTLE_TX_INTERVAL * 1000 / (1000000 * 10 / (s->baudbase / [[divider]])); } s->thr_ipending = 1; s->lsr |= UART_LSR_THRE; s->lsr |= UART_LSR_TEMT; serial_update_irq(s); }

[[[[Adv]]]]: static void serial_tx_done(void *opaque) { SerialState *s = opaque; if (s->tx_burst < 0) { uint16_t [[mixers]]; if (s->divider) [[mixers]] = s->divider; else [[mixers]] = 1; s->tx_burst = THROTTLE_TX_INTERVAL * 1000 / (1000000 * 10 / (s->baudbase / [[mixers]])); } s->thr_ipending = 1; s->lsr |= UART_LSR_THRE; s->lsr |= UART_LSR_TEMT; serial_update_irq(s); }
--------------------------------------------- Result 274 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void qemu_spice_create_host_primary(SimpleSpiceDisplay *ssd) { QXLDevSurfaceCreate surface; memset(&surface, 0, sizeof(surface)); dprint(1, "%s/%d: %dx%d\n", __func__, ssd->qxl.id, surface_width(ssd->ds), surface_height(ssd->ds)); surface.format = SPICE_SURFACE_FMT_32_xRGB; surface.width = surface_width(ssd->ds); surface.height = surface_height(ssd->ds); surface.stride = -surface.width * 4; surface.mouse_mode = "True" == "True"; surface.flags = 0; surface.type = 0; surface.mem = (uintptr_t)ssd->buf; surface.group_id = MEMSLOT_GROUP_HOST; qemu_spice_create_primary_surface(ssd, 0, &surface, QXL_SYNC); }
--------------------------------------------- Result 275 ---------------------------------------------
[[0 (67%)]] --> [[0 (49%)]] --> Socre: 0.5121833682060242

[[[[Adv]]]]: static void init_proc_750fx (CPUPPCState *[[env]]) { gen_spr_ne_601([[env]]); gen_spr_7xx([[env]]); spr_register([[env]], SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_tbl([[env]]); gen_spr_thrm([[env]]); spr_register([[env]], SPR_750_THRM4, "THRM4", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[env]], SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[env]], SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[env]], SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); gen_low_BATs([[env]]); gen_high_BATs([[env]]); init_excp_7x0([[env]]); [[env]]->dcache_line_size = 32; [[env]]->icache_line_size = 32; ppc6xx_irq_init([[env]]); }

[[[[Adv]]]]: static void init_proc_750fx (CPUPPCState *[[arrowhead]]) { gen_spr_ne_601([[arrowhead]]); gen_spr_7xx([[arrowhead]]); spr_register([[arrowhead]], SPR_L2CR, "L2CR", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, NULL, 0x00000000); gen_tbl([[arrowhead]]); gen_spr_thrm([[arrowhead]]); spr_register([[arrowhead]], SPR_750_THRM4, "THRM4", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[arrowhead]], SPR_HID0, "HID0", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[arrowhead]], SPR_HID1, "HID1", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); spr_register([[arrowhead]], SPR_750FX_HID2, "HID2", SPR_NOACCESS, SPR_NOACCESS, &spr_read_generic, &spr_write_generic, 0x00000000); gen_low_BATs([[arrowhead]]); gen_high_BATs([[arrowhead]]); init_excp_7x0([[arrowhead]]); [[arrowhead]]->dcache_line_size = 32; [[arrowhead]]->icache_line_size = 32; ppc6xx_irq_init([[arrowhead]]); }
--------------------------------------------- Result 276 ---------------------------------------------
[[0 (5%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void st_print_trace_file_status(FILE *stream, int (*stream_printf)(FILE *stream, const char *fmt, ...)) { stream_printf(stream, "Trace file \"%s\" %s.\n", trace_file_name, trace_file_enabled ? "on" : "off"); }
--------------------------------------------- Result 277 ---------------------------------------------
[[0 (36%)]] --> [[0 (66%)]] --> Socre: 0.6557914614677429

[[[[Adv]]]]: static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *[[tag]]; int [[ret]], i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, "webm")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->metadata, "alpha_mode", NULL, 0)) version = 4; if (s->nb_streams > MAX_TRACKS) { av_log(s, AV_LOG_ERROR, "At most %d streams are supported for muxing in Matroska\n", MAX_TRACKS); return AVERROR(EINVAL); } for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, "The Matroska muxer does not yet support muxing %s\n", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->streams[i]->metadata, "alpha_mode", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { [[ret]] = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { [[ret]] = AVERROR(ENOMEM); goto fail; } [[ret]] = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if ([[ret]] < 0) goto fail; [[ret]] = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0); if ([[ret]] < 0) return [[ret]]; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if (([[tag]] = av_dict_get(s->metadata, "title", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, [[tag]]->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if (([[tag]] = av_dict_get(s->metadata, "encoding_tool", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, [[tag]]->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t [[segment_uid]][4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) [[segment_uid]][i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, [[segment_uid]], 16); } } else { const char *ident = "Lavf"; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t [[date_utc_buf]][8]; AV_WB64([[date_utc_buf]], date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, [[date_utc_buf]], 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration); } else { put_ebml_void(pb, 11); } } if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info); else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); [[ret]] = mkv_write_tracks(s); if ([[ret]] < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); [[ret]] = mkv_write_chapters(s); if ([[ret]] < 0) goto fail; if (mkv->mode != MODE_WEBM) { [[ret]] = mkv_write_attachments(s); if ([[ret]] < 0) goto fail; } [[ret]] = mkv_write_tags(s); if ([[ret]] < 0) goto fail; if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { [[ret]] = AVERROR(ENOMEM); goto fail; } if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable & AVIO_SEEKABLE_NORMAL) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return [[ret]]; }

[[[[Adv]]]]: static int mkv_write_header(AVFormatContext *s) { MatroskaMuxContext *mkv = s->priv_data; AVIOContext *pb = s->pb; ebml_master ebml_header; AVDictionaryEntry *[[branding]]; int [[retraction]], i, version = 2; int64_t creation_time; if (!strcmp(s->oformat->name, "webm")) mkv->mode = MODE_WEBM; else mkv->mode = MODE_MATROSKAv2; if (mkv->mode != MODE_WEBM || av_dict_get(s->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->metadata, "alpha_mode", NULL, 0)) version = 4; if (s->nb_streams > MAX_TRACKS) { av_log(s, AV_LOG_ERROR, "At most %d streams are supported for muxing in Matroska\n", MAX_TRACKS); return AVERROR(EINVAL); } for (i = 0; i < s->nb_streams; i++) { if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_ATRAC3 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_COOK || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RA_288 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_SIPR || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV10 || s->streams[i]->codecpar->codec_id == AV_CODEC_ID_RV20) { av_log(s, AV_LOG_ERROR, "The Matroska muxer does not yet support muxing %s\n", avcodec_get_name(s->streams[i]->codecpar->codec_id)); return AVERROR_PATCHWELCOME; } if (s->streams[i]->codecpar->codec_id == AV_CODEC_ID_OPUS || av_dict_get(s->streams[i]->metadata, "stereo_mode", NULL, 0) || av_dict_get(s->streams[i]->metadata, "alpha_mode", NULL, 0)) version = 4; } mkv->tracks = av_mallocz_array(s->nb_streams, sizeof(*mkv->tracks)); if (!mkv->tracks) { [[retraction]] = AVERROR(ENOMEM); goto fail; } ebml_header = start_ebml_master(pb, EBML_ID_HEADER, 0); put_ebml_uint (pb, EBML_ID_EBMLVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLREADVERSION , 1); put_ebml_uint (pb, EBML_ID_EBMLMAXIDLENGTH , 4); put_ebml_uint (pb, EBML_ID_EBMLMAXSIZELENGTH , 8); put_ebml_string (pb, EBML_ID_DOCTYPE , s->oformat->name); put_ebml_uint (pb, EBML_ID_DOCTYPEVERSION , version); put_ebml_uint (pb, EBML_ID_DOCTYPEREADVERSION , 2); end_ebml_master(pb, ebml_header); mkv->segment = start_ebml_master(pb, MATROSKA_ID_SEGMENT, 0); mkv->segment_offset = avio_tell(pb); mkv->main_seekhead = mkv_start_seekhead(pb, mkv->segment_offset, 10); if (!mkv->main_seekhead) { [[retraction]] = AVERROR(ENOMEM); goto fail; } [[retraction]] = mkv_add_seekhead_entry(mkv->main_seekhead, MATROSKA_ID_INFO, avio_tell(pb)); if ([[retraction]] < 0) goto fail; [[retraction]] = start_ebml_master_crc32(pb, &mkv->info_bc, mkv, &mkv->info, MATROSKA_ID_INFO, 0); if ([[retraction]] < 0) return [[retraction]]; pb = mkv->info_bc; put_ebml_uint(pb, MATROSKA_ID_TIMECODESCALE, 1000000); if (([[branding]] = av_dict_get(s->metadata, "title", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_TITLE, [[branding]]->value); if (!(s->flags & AVFMT_FLAG_BITEXACT)) { put_ebml_string(pb, MATROSKA_ID_MUXINGAPP, LIBAVFORMAT_IDENT); if (([[branding]] = av_dict_get(s->metadata, "encoding_tool", NULL, 0))) put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, [[branding]]->value); else put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, LIBAVFORMAT_IDENT); if (mkv->mode != MODE_WEBM) { uint32_t [[goodie]][4]; AVLFG lfg; av_lfg_init(&lfg, av_get_random_seed()); for (i = 0; i < 4; i++) [[goodie]][i] = av_lfg_get(&lfg); put_ebml_binary(pb, MATROSKA_ID_SEGMENTUID, [[goodie]], 16); } } else { const char *ident = "Lavf"; put_ebml_string(pb, MATROSKA_ID_MUXINGAPP , ident); put_ebml_string(pb, MATROSKA_ID_WRITINGAPP, ident); } if (ff_parse_creation_time_metadata(s, &creation_time, 0) > 0) { int64_t date_utc = (creation_time - 978307200000000LL) * 1000; uint8_t [[platts]][8]; AV_WB64([[platts]], date_utc); put_ebml_binary(pb, MATROSKA_ID_DATEUTC, [[platts]], 8); } mkv->duration = 0; mkv->duration_offset = avio_tell(pb); if (!mkv->is_live) { int64_t metadata_duration = get_metadata_duration(s); if (s->duration > 0) { int64_t scaledDuration = av_rescale(s->duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from recording time = %" PRIu64 "\n", scaledDuration); } else if (metadata_duration > 0) { int64_t scaledDuration = av_rescale(metadata_duration, 1000, AV_TIME_BASE); put_ebml_float(pb, MATROSKA_ID_DURATION, scaledDuration); av_log(s, AV_LOG_DEBUG, "Write early duration from metadata = %" PRIu64 "\n", scaledDuration); } else { put_ebml_void(pb, 11); } } if ((s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) end_ebml_master_crc32_preliminary(s->pb, &mkv->info_bc, mkv, mkv->info); else end_ebml_master_crc32(s->pb, &mkv->info_bc, mkv, mkv->info); pb = s->pb; mkv->stream_durations = av_mallocz(s->nb_streams * sizeof(int64_t)); mkv->stream_duration_offsets = av_mallocz(s->nb_streams * sizeof(int64_t)); [[retraction]] = mkv_write_tracks(s); if ([[retraction]] < 0) goto fail; for (i = 0; i < s->nb_chapters; i++) mkv->chapter_id_offset = FFMAX(mkv->chapter_id_offset, 1LL - s->chapters[i]->id); [[retraction]] = mkv_write_chapters(s); if ([[retraction]] < 0) goto fail; if (mkv->mode != MODE_WEBM) { [[retraction]] = mkv_write_attachments(s); if ([[retraction]] < 0) goto fail; } [[retraction]] = mkv_write_tags(s); if ([[retraction]] < 0) goto fail; if (!(s->pb->seekable & AVIO_SEEKABLE_NORMAL) && !mkv->is_live) mkv_write_seekhead(pb, mkv); mkv->cues = mkv_start_cues(mkv->segment_offset); if (!mkv->cues) { [[retraction]] = AVERROR(ENOMEM); goto fail; } if ((pb->seekable & AVIO_SEEKABLE_NORMAL) && mkv->reserve_cues_space) { mkv->cues_pos = avio_tell(pb); put_ebml_void(pb, mkv->reserve_cues_space); } av_init_packet(&mkv->cur_audio_pkt); mkv->cur_audio_pkt.size = 0; mkv->cluster_pos = -1; avio_flush(pb); if (pb->seekable & AVIO_SEEKABLE_NORMAL) { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 5000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 5 * 1024 * 1024; } else { if (mkv->cluster_time_limit < 0) mkv->cluster_time_limit = 1000; if (mkv->cluster_size_limit < 0) mkv->cluster_size_limit = 32 * 1024; } return 0; fail: mkv_free(mkv); return [[retraction]]; }[Succeeded / Failed / Skipped / Total] 117 / 41 / 119 / 277:  10%|         | 277/2690 [03:01<26:20,  1.53it/s][Succeeded / Failed / Skipped / Total] 118 / 41 / 119 / 278:  10%|         | 278/2690 [03:01<26:15,  1.53it/s][Succeeded / Failed / Skipped / Total] 118 / 41 / 119 / 278:  10%|         | 279/2690 [03:07<27:01,  1.49it/s][Succeeded / Failed / Skipped / Total] 118 / 42 / 119 / 279:  10%|         | 279/2690 [03:07<27:01,  1.49it/s][Succeeded / Failed / Skipped / Total] 118 / 42 / 120 / 280:  10%|         | 280/2690 [03:07<26:54,  1.49it/s][Succeeded / Failed / Skipped / Total] 118 / 42 / 120 / 280:  10%|         | 281/2690 [03:08<26:57,  1.49it/s][Succeeded / Failed / Skipped / Total] 119 / 42 / 120 / 281:  10%|         | 281/2690 [03:08<26:58,  1.49it/s][Succeeded / Failed / Skipped / Total] 119 / 42 / 121 / 282:  10%|         | 282/2690 [03:08<26:51,  1.49it/s][Succeeded / Failed / Skipped / Total] 119 / 42 / 121 / 282:  11%|         | 283/2690 [03:08<26:47,  1.50it/s][Succeeded / Failed / Skipped / Total] 120 / 42 / 121 / 283:  11%|         | 283/2690 [03:08<26:47,  1.50it/s][Succeeded / Failed / Skipped / Total] 120 / 42 / 122 / 284:  11%|         | 284/2690 [03:08<26:40,  1.50it/s][Succeeded / Failed / Skipped / Total] 120 / 42 / 123 / 285:  11%|         | 285/2690 [03:08<26:34,  1.51it/s][Succeeded / Failed / Skipped / Total] 120 / 42 / 123 / 285:  11%|         | 286/2690 [03:09<26:31,  1.51it/s]
--------------------------------------------- Result 278 ---------------------------------------------
[[0 (63%)]] --> [[0 (36%)]] --> Socre: 0.6419012248516083

[[[[Adv]]]]: e1000_can_receive(void *opaque) { E1000State *[[s]] = opaque; return (!([[s]]->mac_reg[RCTL] & E1000_RCTL_EN) || [[s]]->mac_reg[RDH] != [[s]]->mac_reg[RDT]); }

[[[[Adv]]]]: e1000_can_receive(void *opaque) { E1000State *[[w]] = opaque; return (!([[w]]->mac_reg[RCTL] & E1000_RCTL_EN) || [[w]]->mac_reg[RDH] != [[w]]->mac_reg[RDT]); }
--------------------------------------------- Result 279 ---------------------------------------------
[[0 (8%)]] --> [[[FAILED]]]

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU farg; float32 f32; farg.ll = arg; if (unlikely(float64_is_signaling_nan(farg.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } f32 = float64_to_float32(farg.d, &env->fp_status); farg.d = float32_to_float64(f32, &env->fp_status); return farg.ll; }

[[[[Adv]]]]: uint64_t helper_frsp(CPUPPCState *env, uint64_t arg) { CPU_DoubleU farg; float32 f32; farg.ll = arg; if (unlikely(float64_is_signaling_nan(farg.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } f32 = float64_to_float32(farg.d, &env->fp_status); farg.d = float32_to_float64(f32, &env->fp_status); return farg.ll; }
--------------------------------------------- Result 280 ---------------------------------------------
[[0 (6%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static unsigned tget(const uint8_t **p, int type, int le) { switch (type) { case TIFF_BYTE: return *(*p)++; case TIFF_SHORT: return tget_short(p, le); case TIFF_LONG: return tget_long(p, le); default: return UINT_MAX; } }
--------------------------------------------- Result 281 ---------------------------------------------
[[0 (63%)]] --> [[0 (49%)]] --> Socre: 0.5054349303245544

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *avctx, void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *s = avctx->priv_data; DiracSlice *[[slice]] = arg; GetBitContext *gb = &[[slice]]->gb; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = s->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t bits_end = get_bits_count(gb) + bits_left; if (bits_end >= INT_MAX) { av_log(s->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband(s, gb, quants[level][orientation], [[slice]]->slice_x, [[slice]]->slice_y, bits_end, &s->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }

[[[[Adv]]]]: static int decode_hq_slice(AVCodecContext *avctx, void *arg) { int i, quant, level, orientation, quant_idx; uint8_t quants[MAX_DWT_LEVELS][4]; DiracContext *s = avctx->priv_data; DiracSlice *[[snip]] = arg; GetBitContext *gb = &[[snip]]->gb; skip_bits_long(gb, 8*s->highquality.prefix_bytes); quant_idx = get_bits(gb, 8); for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { quant = FFMAX(quant_idx - s->lowdelay.quant[level][orientation], 0); quants[level][orientation] = quant; } } for (i = 0; i < 3; i++) { int64_t length = s->highquality.size_scaler * get_bits(gb, 8); int64_t bits_left = 8 * length; int64_t bits_end = get_bits_count(gb) + bits_left; if (bits_end >= INT_MAX) { av_log(s->avctx, AV_LOG_ERROR, "end too far away\n"); return AVERROR_INVALIDDATA; } for (level = 0; level < s->wavelet_depth; level++) { for (orientation = !!level; orientation < 4; orientation++) { decode_subband(s, gb, quants[level][orientation], [[snip]]->slice_x, [[snip]]->slice_y, bits_end, &s->plane[i].band[level][orientation], NULL); } } skip_bits_long(gb, bits_end - get_bits_count(gb)); } return 0; }
--------------------------------------------- Result 282 ---------------------------------------------
[[0 (17%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold int amr_wb_encode_init(AVCodecContext *avctx) { AMRWBContext *s = avctx->priv_data; if (avctx->sample_rate != 16000) { av_log(avctx, AV_LOG_ERROR, "Only 16000Hz sample rate supported\n"); return AVERROR(ENOSYS); } if (avctx->channels != 1) { av_log(avctx, AV_LOG_ERROR, "Only mono supported\n"); return AVERROR(ENOSYS); } s->mode = get_wb_bitrate_mode(avctx->bit_rate, avctx); s->last_bitrate = avctx->bit_rate; avctx->frame_size = 320; avctx->coded_frame = avcodec_alloc_frame(); s->state = E_IF_init(); return 0; }
--------------------------------------------- Result 283 ---------------------------------------------
[[0 (72%)]] --> [[0 (39%)]] --> Socre: 0.6085566878318787

[[[[Adv]]]]: uint32_t div32(uint32_t *[[q_ptr]], uint64_t num, uint32_t [[den]]) { *[[q_ptr]] = num / [[den]]; return num % [[den]]; }

[[[[Adv]]]]: uint32_t div32(uint32_t *[[loris]], uint64_t num, uint32_t [[hibernation]]) { *[[loris]] = num / [[hibernation]]; return num % [[hibernation]]; }
--------------------------------------------- Result 284 ---------------------------------------------
[[0 (50%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void ff_fetch_timestamp(AVCodecParserContext *s, int off, int remove) { int i; s->dts = s->pts = AV_NOPTS_VALUE; s->pos = -1; s->offset = 0; for (i = 0; i < AV_PARSER_PTS_NB; i++) { if (s->cur_offset + off >= s->cur_frame_offset[i] && (s->frame_offset < s->cur_frame_offset[i] || (!s->frame_offset && !s->next_frame_offset)) && s->cur_frame_end[i]){ s->dts = s->cur_frame_dts[i]; s->pts = s->cur_frame_pts[i]; s->pos = s->cur_frame_pos[i]; s->offset = s->next_frame_offset - s->cur_frame_offset[i]; if (remove) s->cur_frame_offset[i] = INT64_MAX; if (s->cur_offset + off < s->cur_frame_end[i]) break; } } }
--------------------------------------------- Result 285 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void simple_whitespace(void) { int i; struct { const char *encoded; LiteralQObject decoded; } test_cases[] = { { .encoded = " [ 43 , 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { .encoded = " [ 43 , { 'h' : 'b' , 'a' : 32 }, [ ], 42 ]", .decoded = QLIT_QLIST(((LiteralQObject[]){ QLIT_QINT(43), QLIT_QDICT(((LiteralQDictEntry[]){ { "h", QLIT_QSTR("b") }, { "a", QLIT_QINT(32) }, { }})), QLIT_QLIST(((LiteralQObject[]){ { }})), QLIT_QINT(42), { } })), }, { } }; for (i = 0; test_cases[i].encoded; i++) { QObject *obj; QString *str; obj = qobject_from_json(test_cases[i].encoded, NULL); g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1); str = qobject_to_json(obj); qobject_decref(obj); obj = qobject_from_json(qstring_get_str(str), NULL); g_assert(compare_litqobj_to_qobj(&test_cases[i].decoded, obj) == 1); qobject_decref(obj); QDECREF(str); } }
--------------------------------------------- Result 286 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 121 / 42 / 123 / 286:  11%|         | 286/2690 [03:09<26:31,  1.51it/s][Succeeded / Failed / Skipped / Total] 121 / 42 / 124 / 287:  11%|         | 287/2690 [03:09<26:25,  1.52it/s][Succeeded / Failed / Skipped / Total] 121 / 42 / 125 / 288:  11%|         | 288/2690 [03:09<26:19,  1.52it/s][Succeeded / Failed / Skipped / Total] 121 / 42 / 125 / 288:  11%|         | 289/2690 [03:09<26:15,  1.52it/s][Succeeded / Failed / Skipped / Total] 122 / 42 / 125 / 289:  11%|         | 289/2690 [03:09<26:15,  1.52it/s][Succeeded / Failed / Skipped / Total] 122 / 43 / 125 / 290:  11%|         | 290/2690 [03:15<26:56,  1.48it/s][[0 (75%)]] --> [[0 (33%)]] --> Socre: 0.6652482748031616

[[[[Adv]]]]: static void gen_check_sr(DisasContext *[[dc]], uint32_t [[sr]], unsigned [[access]]) { if (!xtensa_option_bits_enabled([[dc]]->config, sregnames[[[sr]]].opt_bits)) { if (sregnames[[[sr]]].name) { qemu_log("SR %s is not configured\n", sregnames[[[sr]]].name); } else { qemu_log("SR %d is not implemented\n", [[sr]]); } gen_exception_cause([[dc]], ILLEGAL_INSTRUCTION_CAUSE); } else if (!(sregnames[[[sr]]].access & [[access]])) { static const char * const access_text[] = { [SR_R] = "rsr", [SR_W] = "wsr", [SR_X] = "xsr", }; assert([[access]] < ARRAY_SIZE(access_text) && access_text[[[access]]]); qemu_log("SR %s is not available for %s\n", sregnames[[[sr]]].name, access_text[[[access]]]); gen_exception_cause([[dc]], ILLEGAL_INSTRUCTION_CAUSE); } }

[[[[Adv]]]]: static void gen_check_sr(DisasContext *[[montgomery]], uint32_t [[kansas]], unsigned [[availability]]) { if (!xtensa_option_bits_enabled([[montgomery]]->config, sregnames[[[kansas]]].opt_bits)) { if (sregnames[[[kansas]]].name) { qemu_log("SR %s is not configured\n", sregnames[[[kansas]]].name); } else { qemu_log("SR %d is not implemented\n", [[kansas]]); } gen_exception_cause([[montgomery]], ILLEGAL_INSTRUCTION_CAUSE); } else if (!(sregnames[[[kansas]]].access & [[availability]])) { static const char * const access_text[] = { [SR_R] = "rsr", [SR_W] = "wsr", [SR_X] = "xsr", }; assert([[availability]] < ARRAY_SIZE(access_text) && access_text[[[availability]]]); qemu_log("SR %s is not available for %s\n", sregnames[[[kansas]]].name, access_text[[[availability]]]); gen_exception_cause([[montgomery]], ILLEGAL_INSTRUCTION_CAUSE); } }
--------------------------------------------- Result 287 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void gen_lswi(DisasContext *ctx) { TCGv t0; TCGv_i32 t1, t2; int nb = NB(ctx->opcode); int start = rD(ctx->opcode); int ra = rA(ctx->opcode); int nr; if (nb == 0) nb = 32; nr = (nb + 3) / 4; if (unlikely(lsw_reg_in_range(start, nr, ra))) { gen_inval_exception(ctx, POWERPC_EXCP_INVAL_LSWX); return; } gen_set_access_type(ctx, ACCESS_INT); gen_update_nip(ctx, ctx->nip - 4); t0 = tcg_temp_new(); gen_addr_register(ctx, t0); t1 = tcg_const_i32(nb); t2 = tcg_const_i32(start); gen_helper_lsw(cpu_env, t0, t1, t2); tcg_temp_free(t0); tcg_temp_free_i32(t1); tcg_temp_free_i32(t2); }
--------------------------------------------- Result 288 ---------------------------------------------
[[0 (69%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int decode_frame(AVCodecContext *avctx, const uint8_t *databuf, float **out_samples) { ATRAC3Context *q = avctx->priv_data; int ret, i; uint8_t *ptr1; if (q->coding_mode == JOINT_STEREO) { init_get_bits(&q->gb, databuf, avctx->block_align * 8); ret = decode_channel_sound_unit(q, &q->gb, q->units, out_samples[0], 0, JOINT_STEREO); if (ret != 0) return ret; if (databuf == q->decoded_bytes_buffer) { uint8_t *ptr2 = q->decoded_bytes_buffer + avctx->block_align - 1; ptr1 = q->decoded_bytes_buffer; for (i = 0; i < avctx->block_align / 2; i++, ptr1++, ptr2--) FFSWAP(uint8_t, *ptr1, *ptr2); } else { const uint8_t *ptr2 = databuf + avctx->block_align - 1; for (i = 0; i < avctx->block_align; i++) q->decoded_bytes_buffer[i] = *ptr2--; } ptr1 = q->decoded_bytes_buffer; for (i = 4; *ptr1 == 0xF8; i++, ptr1++) { if (i >= avctx->block_align) return AVERROR_INVALIDDATA; } init_get_bits8(&q->gb, ptr1, q->decoded_bytes_buffer + avctx->block_align - ptr1); memmove(q->weighting_delay, &q->weighting_delay[2], 4 * sizeof(*q->weighting_delay)); q->weighting_delay[4] = get_bits1(&q->gb); q->weighting_delay[5] = get_bits(&q->gb, 3); for (i = 0; i < 4; i++) { q->matrix_coeff_index_prev[i] = q->matrix_coeff_index_now[i]; q->matrix_coeff_index_now[i] = q->matrix_coeff_index_next[i]; q->matrix_coeff_index_next[i] = get_bits(&q->gb, 2); } ret = decode_channel_sound_unit(q, &q->gb, &q->units[1], out_samples[1], 1, JOINT_STEREO); if (ret != 0) return ret; reverse_matrixing(out_samples[0], out_samples[1], q->matrix_coeff_index_prev, q->matrix_coeff_index_now); channel_weighting(out_samples[0], out_samples[1], q->weighting_delay); } else { for (i = 0; i < avctx->channels; i++) { init_get_bits(&q->gb, databuf + i * avctx->block_align / avctx->channels, avctx->block_align * 8 / avctx->channels); ret = decode_channel_sound_unit(q, &q->gb, &q->units[i], out_samples[i], i, q->coding_mode); if (ret != 0) return ret; } } for (i = 0; i < avctx->channels; i++) { float *p1 = out_samples[i]; float *p2 = p1 + 256; float *p3 = p2 + 256; float *p4 = p3 + 256; ff_atrac_iqmf(p1, p2, 256, p1, q->units[i].delay_buf1, q->temp_buf); ff_atrac_iqmf(p4, p3, 256, p3, q->units[i].delay_buf2, q->temp_buf); ff_atrac_iqmf(p1, p3, 512, p1, q->units[i].delay_buf3, q->temp_buf); } return 0; }
--------------------------------------------- Result 289 ---------------------------------------------
[[0 (83%)]] --> [[0 (33%)]] --> Socre: 0.6663965880870819

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t [[shift]]) { uint64_t [[temp]]; uint32_t [[result]]; [[shift]] &= 63; [[temp]] = (uint64_t)val << 32 >> [[shift]]; [[result]] = [[temp]] >> 32; env->cc_c = ([[temp]] >> 31) & 1; env->cc_n = [[result]]; env->cc_z = [[result]]; env->cc_v = 0; env->cc_x = [[shift]] ? env->cc_c : env->cc_x; return [[result]]; }

[[[[Adv]]]]: uint32_t HELPER(shr_cc)(CPUM68KState *env, uint32_t val, uint32_t [[changed]]) { uint64_t [[momentarily]]; uint32_t [[effect]]; [[changed]] &= 63; [[momentarily]] = (uint64_t)val << 32 >> [[changed]]; [[effect]] = [[momentarily]] >> 32; env->cc_c = ([[momentarily]] >> 31) & 1; env->cc_n = [[effect]]; env->cc_z = [[effect]]; env->cc_v = 0; env->cc_x = [[changed]] ? env->cc_c : env->cc_x; return [[effect]]; }
--------------------------------------------- Result 290 ---------------------------------------------
[[0 (6%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x) { int rex; if (opc & P_GS) { tcg_out8(s, 0x65); } if (opc & P_DATA16) { assert((opc & P_REXW) == 0); tcg_out8(s, 0x66); } if (opc & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= (opc & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= (rm & 8) >> 3; rex |= opc & (r >= 4 ? P_REXB_R : 0); rex |= opc & (rm >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if (opc & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if (opc & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, opc); }

[[[[Adv]]]]: static void tcg_out_opc(TCGContext *s, int opc, int r, int rm, int x) { int rex; if (opc & P_GS) { tcg_out8(s, 0x65); } if (opc & P_DATA16) { assert((opc & P_REXW) == 0); tcg_out8(s, 0x66); } if (opc & P_ADDR32) { tcg_out8(s, 0x67); } rex = 0; rex |= (opc & P_REXW) ? 0x8 : 0x0; rex |= (r & 8) >> 1; rex |= (x & 8) >> 2; rex |= (rm & 8) >> 3; rex |= opc & (r >= 4 ? P_REXB_R : 0); rex |= opc & (rm >= 4 ? P_REXB_RM : 0); if (rex) { tcg_out8(s, (uint8_t)(rex | 0x40)); } if (opc & (P_EXT | P_EXT38)) { tcg_out8(s, 0x0f); if (opc & P_EXT38) { tcg_out8(s, 0x38); } } tcg_out8(s, opc); }
--------------------------------------------- Result 291 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 123 / 43 / 125 / 291:  11%|         | 291/2690 [03:15<26:51,  1.49it/s][Succeeded / Failed / Skipped / Total] 123 / 43 / 125 / 291:  11%|         | 292/2690 [03:27<28:27,  1.40it/s][Succeeded / Failed / Skipped / Total] 123 / 44 / 125 / 292:  11%|         | 292/2690 [03:27<28:27,  1.40it/s][Succeeded / Failed / Skipped / Total] 123 / 44 / 125 / 292:  11%|         | 293/2690 [03:28<28:24,  1.41it/s][Succeeded / Failed / Skipped / Total] 124 / 44 / 125 / 293:  11%|         | 293/2690 [03:28<28:24,  1.41it/s][Succeeded / Failed / Skipped / Total] 124 / 44 / 126 / 294:  11%|         | 294/2690 [03:28<28:18,  1.41it/s][Succeeded / Failed / Skipped / Total] 124 / 44 / 127 / 295:  11%|         | 295/2690 [03:28<28:12,  1.42it/s][Succeeded / Failed / Skipped / Total] 124 / 44 / 127 / 295:  11%|         | 296/2690 [03:28<28:08,  1.42it/s][Succeeded / Failed / Skipped / Total] 125 / 44 / 127 / 296:  11%|         | 296/2690 [03:28<28:08,  1.42it/s][[0 (67%)]] --> [[0 (38%)]] --> Socre: 0.6218944489955902

[[[[Adv]]]]: void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *[[q]]) { QSVFrame *cur; AVPacket pkt; int ret = 0; mfxVideoParam param = { { 0 } }; if ([[q]]->reinit_pending) { close_decoder([[q]]); } else if ([[q]]->engine_ready) { ret = MFXVideoDECODE_GetVideoParam([[q]]->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode get param error %d\n", ret); } ret = MFXVideoDECODE_Reset([[q]]->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode reset error %d\n", ret); } cur = [[q]]->work_frames; while (cur) { [[q]]->work_frames = cur->next; av_frame_free(&cur->frame); av_freep(&cur); cur = [[q]]->work_frames; } } av_fifo_reset([[q]]->async_fifo); while (av_fifo_size([[q]]->pkt_fifo)) { av_fifo_generic_read([[q]]->pkt_fifo, &pkt, sizeof(pkt), NULL); av_packet_unref(&pkt); } av_fifo_reset([[q]]->input_fifo); }

[[[[Adv]]]]: void ff_qsv_decode_reset(AVCodecContext *avctx, QSVContext *[[asks]]) { QSVFrame *cur; AVPacket pkt; int ret = 0; mfxVideoParam param = { { 0 } }; if ([[asks]]->reinit_pending) { close_decoder([[asks]]); } else if ([[asks]]->engine_ready) { ret = MFXVideoDECODE_GetVideoParam([[asks]]->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode get param error %d\n", ret); } ret = MFXVideoDECODE_Reset([[asks]]->session, &param); if (ret < 0) { av_log(avctx, AV_LOG_ERROR, "MFX decode reset error %d\n", ret); } cur = [[asks]]->work_frames; while (cur) { [[asks]]->work_frames = cur->next; av_frame_free(&cur->frame); av_freep(&cur); cur = [[asks]]->work_frames; } } av_fifo_reset([[asks]]->async_fifo); while (av_fifo_size([[asks]]->pkt_fifo)) { av_fifo_generic_read([[asks]]->pkt_fifo, &pkt, sizeof(pkt), NULL); av_packet_unref(&pkt); } av_fifo_reset([[asks]]->input_fifo); }
--------------------------------------------- Result 292 ---------------------------------------------
[[0 (7%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void test_io_channel_ipv4(bool async) { SocketAddress *listen_addr = g_new0(SocketAddress, 1); SocketAddress *connect_addr = g_new0(SocketAddress, 1); listen_addr->type = SOCKET_ADDRESS_KIND_INET; listen_addr->u.inet = g_new0(InetSocketAddress, 1); listen_addr->u.inet->host = g_strdup("0.0.0.0"); listen_addr->u.inet->port = NULL; connect_addr->type = SOCKET_ADDRESS_KIND_INET; connect_addr->u.inet = g_new0(InetSocketAddress, 1); connect_addr->u.inet->host = g_strdup("127.0.0.1"); connect_addr->u.inet->port = NULL; test_io_channel(async, listen_addr, connect_addr); qapi_free_SocketAddress(listen_addr); qapi_free_SocketAddress(connect_addr); }

[[[[Adv]]]]: static void test_io_channel_ipv4(bool async) { SocketAddress *listen_addr = g_new0(SocketAddress, 1); SocketAddress *connect_addr = g_new0(SocketAddress, 1); listen_addr->type = SOCKET_ADDRESS_KIND_INET; listen_addr->u.inet = g_new0(InetSocketAddress, 1); listen_addr->u.inet->host = g_strdup("0.0.0.0"); listen_addr->u.inet->port = NULL; connect_addr->type = SOCKET_ADDRESS_KIND_INET; connect_addr->u.inet = g_new0(InetSocketAddress, 1); connect_addr->u.inet->host = g_strdup("127.0.0.1"); connect_addr->u.inet->port = NULL; test_io_channel(async, listen_addr, connect_addr); qapi_free_SocketAddress(listen_addr); qapi_free_SocketAddress(connect_addr); }
--------------------------------------------- Result 293 ---------------------------------------------
[[0 (66%)]] --> [[0 (50%)]] --> Socre: 0.500957190990448

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[dev]]) { XHCIState *xhci = XHCI([[dev]]); int [[i]]; trace_usb_xhci_reset(); if (!(xhci->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } xhci->usbcmd = 0; xhci->usbsts = USBSTS_HCH; xhci->dnctrl = 0; xhci->crcr_low = 0; xhci->crcr_high = 0; xhci->dcbaap_low = 0; xhci->dcbaap_high = 0; xhci->config = 0; for ([[i]] = 0; [[i]] < xhci->numslots; [[i]]++) { xhci_disable_slot(xhci, [[i]]+1); } for ([[i]] = 0; [[i]] < xhci->numports; [[i]]++) { xhci_port_update(xhci->ports + [[i]], 0); } for ([[i]] = 0; [[i]] < xhci->numintrs; [[i]]++) { xhci->intr[[[i]]].iman = 0; xhci->intr[[[i]]].imod = 0; xhci->intr[[[i]]].erstsz = 0; xhci->intr[[[i]]].erstba_low = 0; xhci->intr[[[i]]].erstba_high = 0; xhci->intr[[[i]]].erdp_low = 0; xhci->intr[[[i]]].erdp_high = 0; xhci->intr[[[i]]].msix_used = 0; xhci->intr[[[i]]].er_ep_idx = 0; xhci->intr[[[i]]].er_pcs = 1; xhci->intr[[[i]]].er_full = 0; xhci->intr[[[i]]].ev_buffer_put = 0; xhci->intr[[[i]]].ev_buffer_get = 0; } xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update(xhci); }

[[[[Adv]]]]: static void xhci_reset(DeviceState *[[kapil]]) { XHCIState *xhci = XHCI([[kapil]]); int [[did]]; trace_usb_xhci_reset(); if (!(xhci->usbsts & USBSTS_HCH)) { DPRINTF("xhci: reset while running!\n"); } xhci->usbcmd = 0; xhci->usbsts = USBSTS_HCH; xhci->dnctrl = 0; xhci->crcr_low = 0; xhci->crcr_high = 0; xhci->dcbaap_low = 0; xhci->dcbaap_high = 0; xhci->config = 0; for ([[did]] = 0; [[did]] < xhci->numslots; [[did]]++) { xhci_disable_slot(xhci, [[did]]+1); } for ([[did]] = 0; [[did]] < xhci->numports; [[did]]++) { xhci_port_update(xhci->ports + [[did]], 0); } for ([[did]] = 0; [[did]] < xhci->numintrs; [[did]]++) { xhci->intr[[[did]]].iman = 0; xhci->intr[[[did]]].imod = 0; xhci->intr[[[did]]].erstsz = 0; xhci->intr[[[did]]].erstba_low = 0; xhci->intr[[[did]]].erstba_high = 0; xhci->intr[[[did]]].erdp_low = 0; xhci->intr[[[did]]].erdp_high = 0; xhci->intr[[[did]]].msix_used = 0; xhci->intr[[[did]]].er_ep_idx = 0; xhci->intr[[[did]]].er_pcs = 1; xhci->intr[[[did]]].er_full = 0; xhci->intr[[[did]]].ev_buffer_put = 0; xhci->intr[[[did]]].ev_buffer_get = 0; } xhci->mfindex_start = qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL); xhci_mfwrap_update(xhci); }
--------------------------------------------- Result 294 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ppc_find_by_pvr (uint32_t pvr, ppc_def_t **def) { int i, ret; ret = -1; *def = NULL; for (i = 0; ppc_defs[i].name != NULL; i++) { if ((pvr & ppc_defs[i].pvr_mask) == (ppc_defs[i].pvr & ppc_defs[i].pvr_mask)) { *def = &ppc_defs[i]; ret = 0; break; } } return ret; }
--------------------------------------------- Result 295 ---------------------------------------------
[[0 (84%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void helper_tlb_update(uint32_t T0) { #if !defined(CONFIG_USER_ONLY) uint32_t vaddr; uint32_t srs = env->pregs[PR_SRS]; if (srs != 1 && srs != 2) return; vaddr = cris_mmu_tlb_latest_update(env, T0); D(printf("flush old_vaddr=%x vaddr=%x T0=%x\n", vaddr, env->sregs[SFR_R_MM_CAUSE] & TARGET_PAGE_MASK, T0)); tlb_flush_page(env, vaddr); #endif }
--------------------------------------------- Result 296 ---------------------------------------------
[[0 (29%)]] --> [[0 (67%)]] --> Socre: 0.6701873540878296

[[[[Adv]]]]: static void patch_pcihp(int [[slot]], uint8_t *ssdt_ptr, uint32_t eject) { ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex([[slot]] >> 4); ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex([[slot]]); ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = [[slot]]; ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = [[slot]]; assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }

[[[[Adv]]]]: static void patch_pcihp(int [[groove]], uint8_t *ssdt_ptr, uint32_t eject) { ssdt_ptr[ACPI_PCIHP_OFFSET_HEX] = acpi_get_hex([[groove]] >> 4); ssdt_ptr[ACPI_PCIHP_OFFSET_HEX + 1] = acpi_get_hex([[groove]]); ssdt_ptr[ACPI_PCIHP_OFFSET_ID] = [[groove]]; ssdt_ptr[ACPI_PCIHP_OFFSET_ADR + 2] = [[groove]]; assert(!memcmp(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "_EJ0", 4)); if (!eject) { memcpy(ssdt_ptr + ACPI_PCIHP_OFFSET_EJ0, "EJ0_", 4); } }
--------------------------------------------- Result 297 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 126 / 44 / 127 / 297:  11%|         | 297/2690 [03:37<29:16,  1.36it/s][Succeeded / Failed / Skipped / Total] 126 / 44 / 128 / 298:  11%|         | 298/2690 [03:37<29:09,  1.37it/s][Succeeded / Failed / Skipped / Total] 126 / 44 / 128 / 298:  11%|         | 299/2690 [03:39<29:11,  1.36it/s][Succeeded / Failed / Skipped / Total] 127 / 44 / 128 / 299:  11%|         | 299/2690 [03:39<29:11,  1.36it/s][Succeeded / Failed / Skipped / Total] 127 / 44 / 129 / 300:  11%|         | 300/2690 [03:39<29:05,  1.37it/s][Succeeded / Failed / Skipped / Total] 127 / 44 / 130 / 301:  11%|         | 301/2690 [03:39<28:59,  1.37it/s][Succeeded / Failed / Skipped / Total] 127 / 44 / 130 / 301:  11%|         | 302/2690 [03:43<29:30,  1.35it/s][[0 (87%)]] --> [[0 (41%)]] --> Socre: 0.5905298888683319

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong [[a]], target_ulong [[b]]) { int64_t [[x0]]; int32_t [[x1]]; [[x0]] = ([[a]] & 0xffffffff) | ((int64_t) (env->y) << 32); [[x1]] = ([[b]] & 0xffffffff); if ([[x1]] == 0) { raise_exception(TT_DIV_ZERO); } [[x0]] = [[x0]] / [[x1]]; if ((int32_t) [[x0]] != [[x0]]) { env->cc_src2 = 1; return [[x0]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[x0]]; } }

[[[[Adv]]]]: target_ulong helper_sdiv(target_ulong [[avec]], target_ulong [[johnson]]) { int64_t [[contributed]]; int32_t [[coupling]]; [[contributed]] = ([[avec]] & 0xffffffff) | ((int64_t) (env->y) << 32); [[coupling]] = ([[johnson]] & 0xffffffff); if ([[coupling]] == 0) { raise_exception(TT_DIV_ZERO); } [[contributed]] = [[contributed]] / [[coupling]]; if ((int32_t) [[contributed]] != [[contributed]]) { env->cc_src2 = 1; return [[contributed]] < 0? 0x80000000: 0x7fffffff; } else { env->cc_src2 = 0; return [[contributed]]; } }
--------------------------------------------- Result 298 ---------------------------------------------
[[0 (8%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_instance_init(Object *obj) { object_property_add(obj, "bootindex", "int32", nvme_get_bootindex, nvme_set_bootindex, NULL, NULL, NULL); object_property_set_int(obj, -1, "bootindex", NULL); }
--------------------------------------------- Result 299 ---------------------------------------------
[[0 (73%)]] --> [[0 (49%)]] --> Socre: 0.5078178942203522

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *[[options]], int flags, Error **[[errp]]) { BDRVBlkverifyState *s = bs->opaque; QemuOpts *[[opts]]; Error *local_err = NULL; int [[ret]]; [[opts]] = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict([[opts]], [[options]], &local_err); if (local_err) { error_propagate([[errp]], local_err); [[ret]] = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get([[opts]], "x-raw"), [[options]], "raw", bs, &child_file, "[[False]]" != "[[False]]", &local_err); if (local_err) { [[ret]] = -EINVAL; error_propagate([[errp]], local_err); goto fail; s->test_file = bdrv_open_child(qemu_opt_get([[opts]], "x-image"), [[options]], "test", bs, &child_format, "[[False]]" != "[[False]]", &local_err); if (local_err) { [[ret]] = -EINVAL; error_propagate([[errp]], local_err); goto fail; [[ret]] = 0; fail: qemu_opts_del([[opts]]); return [[ret]];

[[[[Adv]]]]: static int blkverify_open(BlockDriverState *bs, QDict *[[selection]], int flags, Error **[[fiind]]) { BDRVBlkverifyState *s = bs->opaque; QemuOpts *[[audra]]; Error *local_err = NULL; int [[pensioners]]; [[audra]] = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort); qemu_opts_absorb_qdict([[audra]], [[selection]], &local_err); if (local_err) { error_propagate([[fiind]], local_err); [[pensioners]] = -EINVAL; goto fail; bs->file = bdrv_open_child(qemu_opt_get([[audra]], "x-raw"), [[selection]], "raw", bs, &child_file, "[[Forgeries]]" != "[[Forgeries]]", &local_err); if (local_err) { [[pensioners]] = -EINVAL; error_propagate([[fiind]], local_err); goto fail; s->test_file = bdrv_open_child(qemu_opt_get([[audra]], "x-image"), [[selection]], "test", bs, &child_format, "[[Forgeries]]" != "[[Forgeries]]", &local_err); if (local_err) { [[pensioners]] = -EINVAL; error_propagate([[fiind]], local_err); goto fail; [[pensioners]] = 0; fail: qemu_opts_del([[audra]]); return [[pensioners]];
--------------------------------------------- Result 300 ---------------------------------------------
[[0 (19%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void tcg_out_tlb_read(TCGContext *s, TCGReg addrlo, TCGReg addrhi, int s_bits, int tlb_offset) { TCGReg base = TCG_AREG0; # if CPU_TLB_BITS > 8 # error # endif tcg_out_dat_reg(s, COND_AL, ARITH_MOV, TCG_REG_TMP, 0, addrlo, SHIFT_IMM_LSR(TARGET_PAGE_BITS)); assert((tlb_offset & ~0xffff) == 0); if (tlb_offset > 0xff) { tcg_out_dat_imm(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, (24 << 7) | (tlb_offset >> 8)); tlb_offset &= 0xff; base = TCG_REG_R2; } tcg_out_dat_imm(s, COND_AL, ARITH_AND, TCG_REG_R0, TCG_REG_TMP, CPU_TLB_SIZE - 1); tcg_out_dat_reg(s, COND_AL, ARITH_ADD, TCG_REG_R2, base, TCG_REG_R0, SHIFT_IMM_LSL(CPU_TLB_ENTRY_BITS)); if (use_armv6_instructions && TARGET_LONG_BITS == 64) { tcg_out_memop_8(s, COND_AL, INSN_LDRD_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); } else { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R0, TCG_REG_R2, tlb_offset, 1, 1); if (TARGET_LONG_BITS == 64) { tcg_out_memop_12(s, COND_AL, INSN_LDR_IMM, TCG_REG_R1, TCG_REG_R2, 4, 1, 0); } } if (s_bits) { tcg_out_dat_imm(s, COND_AL, ARITH_TST, 0, addrlo, (1 << s_bits) - 1); } tcg_out_dat_reg(s, (s_bits ? COND_EQ : COND_AL), ARITH_CMP, 0, TCG_REG_R0, TCG_REG_TMP, SHIFT_IMM_LSL(TARGET_PAGE_BITS)); if (TARGET_LONG_BITS == 64) { tcg_out_dat_reg(s, COND_EQ, ARITH_CMP, 0, TCG_REG_R1, addrhi, SHIFT_IMM_LSL(0)); } }
--------------------------------------------- Result 301 ---------------------------------------------
[[0 (53%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qdm2_decode_super_block(QDM2Context *q) { GetBitContext gb; QDM2SubPacket header, *packet; int i, packet_bytes, sub_packet_size, sub_packets_D; unsigned int next_index = 0; memset(q->tone_level_idx_hi1, 0, sizeof(q->tone_level_idx_hi1)); memset(q->tone_level_idx_mid, 0, sizeof(q->tone_level_idx_mid)); memset(q->tone_level_idx_hi2, 0, sizeof(q->tone_level_idx_hi2)); q->sub_packets_B = 0; sub_packets_D = 0; average_quantized_coeffs(q); init_get_bits(&gb, q->compressed_data, q->compressed_size * 8); qdm2_decode_sub_packet_header(&gb, &header); if (header.type < 2 || header.type >= 8) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad superblock type\n"); return; } q->superblocktype_2_3 = (header.type == 2 || header.type == 3); packet_bytes = (q->compressed_size - get_bits_count(&gb) / 8); init_get_bits(&gb, header.data, header.size * 8); if (header.type == 2 || header.type == 4 || header.type == 5) { int csum = 257 * get_bits(&gb, 8); csum += 2 * get_bits(&gb, 8); csum = qdm2_packet_checksum(q->compressed_data, q->checksum_size, csum); if (csum != 0) { q->has_errors = 1; av_log(NULL, AV_LOG_ERROR, "bad packet checksum\n"); return; } } q->sub_packet_list_B[0].packet = NULL; q->sub_packet_list_D[0].packet = NULL; for (i = 0; i < 6; i++) if (--q->fft_level_exp[i] < 0) q->fft_level_exp[i] = 0; for (i = 0; packet_bytes > 0; i++) { int j; if (i >= FF_ARRAY_ELEMS(q->sub_packet_list_A)) { SAMPLES_NEEDED_2("too many packet bytes"); return; } q->sub_packet_list_A[i].next = NULL; if (i > 0) { q->sub_packet_list_A[i - 1].next = &q->sub_packet_list_A[i]; init_get_bits(&gb, header.data, header.size * 8); skip_bits(&gb, next_index * 8); if (next_index >= header.size) break; } packet = &q->sub_packets[i]; qdm2_decode_sub_packet_header(&gb, packet); next_index = packet->size + get_bits_count(&gb) / 8; sub_packet_size = ((packet->size > 0xff) ? 1 : 0) + packet->size + 2; if (packet->type == 0) break; if (sub_packet_size > packet_bytes) { if (packet->type != 10 && packet->type != 11 && packet->type != 12) break; packet->size += packet_bytes - sub_packet_size; } packet_bytes -= sub_packet_size; q->sub_packet_list_A[i].packet = packet; if (packet->type == 8) { SAMPLES_NEEDED_2("packet type 8"); return; } else if (packet->type >= 9 && packet->type <= 12) { QDM2_LIST_ADD(q->sub_packet_list_D, sub_packets_D, packet); } else if (packet->type == 13) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = get_bits(&gb, 6); } else if (packet->type == 14) { for (j = 0; j < 6; j++) q->fft_level_exp[j] = qdm2_get_vlc(&gb, &fft_level_exp_vlc, 0, 2); } else if (packet->type == 15) { SAMPLES_NEEDED_2("packet type 15") return; } else if (packet->type >= 16 && packet->type < 48 && !fft_subpackets[packet->type - 16]) { QDM2_LIST_ADD(q->sub_packet_list_B, q->sub_packets_B, packet); } } if (q->sub_packet_list_D[0].packet != NULL) { process_synthesis_subpackets(q, q->sub_packet_list_D); q->do_synth_filter = 1; } else if (q->do_synth_filter) { process_subpacket_10(q, NULL); process_subpacket_11(q, NULL); process_subpacket_12(q, NULL); } }
[Succeeded / Failed / Skipped / Total] 128 / 44 / 130 / 302:  11%|         | 302/2690 [03:43<29:30,  1.35it/s][Succeeded / Failed / Skipped / Total] 128 / 44 / 131 / 303:  11%|        | 303/2690 [03:43<29:24,  1.35it/s][Succeeded / Failed / Skipped / Total] 128 / 45 / 131 / 304:  11%|        | 304/2690 [03:47<29:42,  1.34it/s][Succeeded / Failed / Skipped / Total] 128 / 45 / 131 / 304:  11%|        | 305/2690 [03:47<29:36,  1.34it/s][Succeeded / Failed / Skipped / Total] 128 / 45 / 132 / 305:  11%|        | 305/2690 [03:47<29:36,  1.34it/s][Succeeded / Failed / Skipped / Total] 129 / 45 / 132 / 306:  11%|        | 306/2690 [03:47<29:35,  1.34it/s][Succeeded / Failed / Skipped / Total] 129 / 46 / 132 / 307:  11%|        | 307/2690 [03:48<29:35,  1.34it/s][Succeeded / Failed / Skipped / Total] 129 / 46 / 132 / 307:  11%|        | 308/2690 [03:48<29:28,  1.35it/s][Succeeded / Failed / Skipped / Total] 129 / 46 / 133 / 308:  11%|        | 308/2690 [03:48<29:28,  1.35it/s]--------------------------------------------- Result 302 ---------------------------------------------
[[0 (84%)]] --> [[0 (47%)]] --> Socre: 0.5251759588718414

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int [[dstW]], const uint8_t *[[src]], const int16_t *filter, const int16_t *filterPos, int filterSize) { int i; for (i=0; i<[[dstW]]; i++) { int j; int [[srcPos]]= filterPos[i]; int val=0; for (j=0; j<filterSize; j++) { val += ((int)[[src]][[[srcPos]] + j])*filter[filterSize*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }

[[[[Adv]]]]: static void hScale8To15_c(SwsContext *c, int16_t *dst, int [[porra]], const uint8_t *[[hix]], const int16_t *filter, const int16_t *filterPos, int filterSize) { int i; for (i=0; i<[[porra]]; i++) { int j; int [[unshakable]]= filterPos[i]; int val=0; for (j=0; j<filterSize; j++) { val += ((int)[[hix]][[[unshakable]] + j])*filter[filterSize*i + j]; } dst[i] = FFMIN(val>>7, (1<<15)-1); } }
--------------------------------------------- Result 303 ---------------------------------------------
[[0 (39%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: MigrationState *migrate_get_current(void) { static MigrationState current_migration = { .state = MIG_STATE_NONE, .bandwidth_limit = MAX_THROTTLE, .xbzrle_cache_size = DEFAULT_MIGRATE_CACHE_SIZE, .mbps = -1, }; return &current_migration; }
--------------------------------------------- Result 304 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0); }

[[[[Adv]]]]: void ff_put_h264_qpel8_mc21_msa(uint8_t *dst, const uint8_t *src, ptrdiff_t stride) { avc_luma_midv_qrt_8w_msa(src - (2 * stride) - 2, stride, dst, stride, 8, 0); }
--------------------------------------------- Result 305 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qcow2_change_backing_file(BlockDriverState *bs, const char *backing_file, const char *backing_fmt) { return qcow2_update_ext_header(bs, backing_file, backing_fmt); }
--------------------------------------------- Result 306 ---------------------------------------------
[[0 (9%)]] --> [[0 (58%)]] --> Socre: 0.5760956406593323

[[[[Adv]]]]: static float ssim_plane(uint8_t *[[main]], int main_stride, uint8_t *[[ref]], int [[ref_stride]], int width, int height, void *[[temp]]) { int z = 0; int x, y; float [[ssim]] = 0.0; int (*sum0)[4] = [[temp]]; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&[[main]][4 * (x + z * main_stride)], main_stride, &[[ref]][4 * (x + z * [[ref_stride]])], [[ref_stride]], &sum0[x]); } [[ssim]] += ssim_endn(sum0, sum1, width - 1); } return [[ssim]] / ((height - 1) * (width - 1)); }

[[[[Adv]]]]: static float ssim_plane(uint8_t *[[elementary]], int main_stride, uint8_t *[[umpires]], int [[electrifying]], int width, int height, void *[[provisionally]]) { int z = 0; int x, y; float [[truancy]] = 0.0; int (*sum0)[4] = [[provisionally]]; int (*sum1)[4] = sum0 + (width >> 2) + 3; width >>= 2; height >>= 2; for (y = 1; y < height; y++) { for (; z <= y; z++) { FFSWAP(void*, sum0, sum1); for (x = 0; x < width; x+=2) ssim_4x4x2_core(&[[elementary]][4 * (x + z * main_stride)], main_stride, &[[umpires]][4 * (x + z * [[electrifying]])], [[electrifying]], &sum0[x]); } [[truancy]] += ssim_endn(sum0, sum1, width - 1); } return [[truancy]] / ((height - 1) * (width - 1)); }
--------------------------------------------- Result 307 ---------------------------------------------
[[0 (10%)]] --> [[[FAILED]]]

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2) { CPU_DoubleU farg1, farg2; farg1.ll = arg1; farg2.ll = arg2; if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d))) { farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) { farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan(farg1.d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status); } return farg1.ll; }

[[[[Adv]]]]: uint64_t helper_fdiv(CPUPPCState *env, uint64_t arg1, uint64_t arg2) { CPU_DoubleU farg1, farg2; farg1.ll = arg1; farg2.ll = arg2; if (unlikely(float64_is_infinity(farg1.d) && float64_is_infinity(farg2.d))) { farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXIDI); } else if (unlikely(float64_is_zero(farg1.d) && float64_is_zero(farg2.d))) { farg1.ll = fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXZDZ); } else { if (unlikely(float64_is_signaling_nan(farg1.d) || float64_is_signaling_nan(farg2.d))) { fload_invalid_op_excp(env, POWERPC_EXCP_FP_VXSNAN); } farg1.d = float64_div(farg1.d, farg2.d, &env->fp_status); } return farg1.ll; }
--------------------------------------------- Result 308 ---------------------------------------------
[[0 (82%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int qemu_rdma_block_for_wrid(RDMAContext *rdma, int wrid_requested) { int num_cq_events = 0, ret = 0; struct ibv_cq *cq; void *cq_ctx; uint64_t wr_id = RDMA_WRID_NONE, wr_id_in; if (ibv_req_notify_cq(rdma->cq, 0)) { return -1; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { return ret; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("A Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { return 0; } while (1) { if (rdma->migration_started_on_destination) { yield_until_fd_readable(rdma->comp_channel->fd); } if (ibv_get_cq_event(rdma->comp_channel, &cq, &cq_ctx)) { perror("ibv_get_cq_event"); goto err_block_for_wrid; } num_cq_events++; if (ibv_req_notify_cq(cq, 0)) { goto err_block_for_wrid; } while (wr_id != wrid_requested) { ret = qemu_rdma_poll(rdma, &wr_id_in); if (ret < 0) { goto err_block_for_wrid; } wr_id = wr_id_in & RDMA_WRID_TYPE_MASK; if (wr_id == RDMA_WRID_NONE) { break; } if (wr_id != wrid_requested) { DDDPRINTF("B Wanted wrid %s (%d) but got %s (%" PRIu64 ")\n", print_wrid(wrid_requested), wrid_requested, print_wrid(wr_id), wr_id); } } if (wr_id == wrid_requested) { goto success_block_for_wrid; } } success_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return 0; err_block_for_wrid: if (num_cq_events) { ibv_ack_cq_events(cq, num_cq_events); } return ret; }
--------------------------------------------- Result 309 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 47 / 133 / 309:  11%|        | 309/2690 [03:57<30:33,  1.30it/s][Succeeded / Failed / Skipped / Total] 129 / 48 / 133 / 310:  12%|        | 310/2690 [03:57<30:27,  1.30it/s][Succeeded / Failed / Skipped / Total] 129 / 48 / 133 / 310:  12%|        | 311/2690 [03:58<30:20,  1.31it/s][Succeeded / Failed / Skipped / Total] 129 / 48 / 134 / 311:  12%|        | 311/2690 [03:58<30:20,  1.31it/s][Succeeded / Failed / Skipped / Total] 129 / 48 / 135 / 312:  12%|        | 312/2690 [03:58<30:14,  1.31it/s][[0 (17%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *h) { int cbp_b, cbp_a, ctx, cbp = 0; cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1; cbp_b = h->slice_table[h->top_mb_xy] == h->slice_num ? h->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !(cbp_b & 0x08); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3; return cbp; }

[[[[Adv]]]]: static int decode_cabac_mb_cbp_luma( H264Context *h) { int cbp_b, cbp_a, ctx, cbp = 0; cbp_a = h->slice_table[h->left_mb_xy[0]] == h->slice_num ? h->left_cbp : -1; cbp_b = h->slice_table[h->top_mb_xy] == h->slice_num ? h->top_cbp : -1; ctx = !(cbp_a & 0x02) + 2 * !(cbp_b & 0x04); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]); ctx = !(cbp & 0x01) + 2 * !(cbp_b & 0x08); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 1; ctx = !(cbp_a & 0x08) + 2 * !(cbp & 0x01); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 2; ctx = !(cbp & 0x04) + 2 * !(cbp & 0x02); cbp |= get_cabac_noinline(&h->cabac, &h->cabac_state[73 + ctx]) << 3; return cbp; }
--------------------------------------------- Result 310 ---------------------------------------------
[[0 (75%)]] --> [[[FAILED]]]

[[[[Adv]]]]: qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt, size_t offset, size_t bytes, bool do_send) { size_t done = 0; ssize_t ret; while (done < bytes) { ret = iov_send_recv(sockfd, iov, offset + done, bytes - done, do_send); if (ret > 0) { done += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if (done == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return done; }

[[[[Adv]]]]: qemu_co_sendv_recvv(int sockfd, struct iovec *iov, unsigned iov_cnt, size_t offset, size_t bytes, bool do_send) { size_t done = 0; ssize_t ret; while (done < bytes) { ret = iov_send_recv(sockfd, iov, offset + done, bytes - done, do_send); if (ret > 0) { done += ret; } else if (ret < 0) { if (errno == EAGAIN) { qemu_coroutine_yield(); } else if (done == 0) { return -1; } else { break; } } else if (ret == 0 && !do_send) { break; } } return done; }
--------------------------------------------- Result 311 ---------------------------------------------
[[0 (31%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static inline bool vtd_queued_inv_enable_check(IntelIOMMUState *s) { return s->iq_tail == 0; }
--------------------------------------------- Result 312 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_always_inline void hcscale(SwsContext *c, int16_t *dst1, int16_t *dst2, int dstWidth, const uint8_t *src_in[4], int srcW, int xInc, const int16_t *hChrFilter, const int16_t *hChrFilterPos, int hChrFilterSize, uint8_t *formatConvBuffer, uint32_t *pal) { const uint8_t *src1 = src_in[1], *src2 = src_in[2]; if (c->chrToYV12) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->chrToYV12(formatConvBuffer, buf2, src1, src2, srcW, pal); src1= formatConvBuffer; src2= buf2; } else if (c->readChrPlanar) { uint8_t *buf2 = formatConvBuffer + FFALIGN(srcW * FFALIGN(c->srcBpc, 8) >> 3, 16); c->readChrPlanar(formatConvBuffer, buf2, src_in, srcW); src1= formatConvBuffer; src2= buf2; } if (!c->hcscale_fast) { c->hcScale(c, dst1, dstWidth, src1, hChrFilter, hChrFilterPos, hChrFilterSize); c->hcScale(c, dst2, dstWidth, src2, hChrFilter, hChrFilterPos, hChrFilterSize); } else { c->hcscale_fast(c, dst1, dst2, dstWidth, src1, src2, srcW, xInc); } if (c->chrConvertRange) c->chrConvertRange(dst1, dst2, dstWidth); }
--------------------------------------------- Result 313 ---------------------------------------------
[[0 (35%)]] --> [[0 (52%)]] --> Socre: 0.5224619507789612

[[[[Adv]]]]: static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size, const char *[[boot_device]], DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[env]], *envs[MAX_CPUS]; unsigned int i; void *[[iounits]][MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi; qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq, *espdma_irq, *ledma_irq; qemu_irq *[[esp_reset]], *le_reset; ram_addr_t ram_offset, prom_offset, tcx_offset; unsigned long kernel_size; int [[ret]]; char buf[1024]; int drive_index; void *fw_cfg; if (!cpu_model) cpu_model = hwdef->default_cpu_model; for (i = 0; i < smp_cpus; i++) { [[env]] = cpu_init(cpu_model); if (![[env]]) { fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n"); exit(1); } cpu_sparc_set_id([[env]], i); envs[i] = [[env]]; if (i == 0) { qemu_register_reset(main_cpu_reset, [[env]]); } else { qemu_register_reset(secondary_cpu_reset, [[env]]); [[env]]->halted = 1; } cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS); [[env]]->prom_addr = hwdef->slavio_base; } for (i = smp_cpus; i < MAX_CPUS; i++) cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS); if ((uint64_t)RAM_size > hwdef->max_mem) { fprintf(stderr, "qemu: Too much memory for this machine: %d, maximum %d\n", (unsigned int)(RAM_size / (1024 * 1024)), (unsigned int)(hwdef->max_mem / (1024 * 1024))); exit(1); } ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->slavio_base, (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name); [[ret]] = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL); if ([[ret]] < 0 || [[ret]] > PROM_SIZE_MAX) [[ret]] = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX); if ([[ret]] < 0 || [[ret]] > PROM_SIZE_MAX) { fprintf(stderr, "qemu: could not load prom '%s'\n", buf); exit(1); } sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs); for (i = 0; i < MAX_IOUNITS; i++) if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1) [[iounits]][i] = iommu_init(hwdef->iounit_bases[i], hwdef->iounit_version, sbi_irq[hwdef->me_irq]); espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq], [[iounits]][0], &espdma_irq, &[[esp_reset]]); ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq], [[iounits]][0], &ledma_irq, &le_reset); if (graphic_depth != 8 && graphic_depth != 24) { fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth); exit (1); } tcx_offset = qemu_ram_alloc(hwdef->vram_size); tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset, hwdef->vram_size, graphic_width, graphic_height, graphic_depth); if (nd_table[0].model == NULL) nd_table[0].model = "lance"; if (strcmp(nd_table[0].model, "lance") == 0) { lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset); } else if (strcmp(nd_table[0].model, "?") == 0) { fprintf(stderr, "qemu: Supported NICs: lance\n"); exit (1); } else { fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model); exit (1); } nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, hwdef->nvram_size, 8); slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq], sbi_cpu_irq, smp_cpus); slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq], nographic, ESCC_CLOCK, 1); escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1], serial_hds[0], ESCC_CLOCK, 1); if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } main_esp = esp_init(hwdef->esp_base, 2, espdma_memory_read, espdma_memory_write, espdma, *espdma_irq, [[esp_reset]]); for (i = 0; i < ESP_MAX_DEVS; i++) { drive_index = drive_get_index(IF_SCSI, 0, i); if (drive_index == -1) continue; esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i); } kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename, RAM_size); nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline, [[boot_device]], RAM_size, kernel_size, graphic_width, graphic_height, graphic_depth, hwdef->nvram_machine_id, "Sun4d"); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); }

[[[[Adv]]]]: static void sun4d_hw_init(const struct sun4d_hwdef *hwdef, ram_addr_t RAM_size, const char *[[nevada]], DisplayState *ds, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { CPUState *[[kaneda]], *envs[MAX_CPUS]; unsigned int i; void *[[departs]][MAX_IOUNITS], *espdma, *ledma, *main_esp, *nvram, *sbi; qemu_irq *cpu_irqs[MAX_CPUS], *sbi_irq, *sbi_cpu_irq, *espdma_irq, *ledma_irq; qemu_irq *[[ungh]], *le_reset; ram_addr_t ram_offset, prom_offset, tcx_offset; unsigned long kernel_size; int [[reform]]; char buf[1024]; int drive_index; void *fw_cfg; if (!cpu_model) cpu_model = hwdef->default_cpu_model; for (i = 0; i < smp_cpus; i++) { [[kaneda]] = cpu_init(cpu_model); if (![[kaneda]]) { fprintf(stderr, "qemu: Unable to find Sparc CPU definition\n"); exit(1); } cpu_sparc_set_id([[kaneda]], i); envs[i] = [[kaneda]]; if (i == 0) { qemu_register_reset(main_cpu_reset, [[kaneda]]); } else { qemu_register_reset(secondary_cpu_reset, [[kaneda]]); [[kaneda]]->halted = 1; } cpu_irqs[i] = qemu_allocate_irqs(cpu_set_irq, envs[i], MAX_PILS); [[kaneda]]->prom_addr = hwdef->slavio_base; } for (i = smp_cpus; i < MAX_CPUS; i++) cpu_irqs[i] = qemu_allocate_irqs(dummy_cpu_set_irq, NULL, MAX_PILS); if ((uint64_t)RAM_size > hwdef->max_mem) { fprintf(stderr, "qemu: Too much memory for this machine: %d, maximum %d\n", (unsigned int)(RAM_size / (1024 * 1024)), (unsigned int)(hwdef->max_mem / (1024 * 1024))); exit(1); } ram_offset = qemu_ram_alloc(RAM_size); cpu_register_physical_memory(0, RAM_size, ram_offset); prom_offset = qemu_ram_alloc(PROM_SIZE_MAX); cpu_register_physical_memory(hwdef->slavio_base, (PROM_SIZE_MAX + TARGET_PAGE_SIZE - 1) & TARGET_PAGE_MASK, prom_offset | IO_MEM_ROM); if (bios_name == NULL) bios_name = PROM_FILENAME; snprintf(buf, sizeof(buf), "%s/%s", bios_dir, bios_name); [[reform]] = load_elf(buf, hwdef->slavio_base - PROM_VADDR, NULL, NULL, NULL); if ([[reform]] < 0 || [[reform]] > PROM_SIZE_MAX) [[reform]] = load_image_targphys(buf, hwdef->slavio_base, PROM_SIZE_MAX); if ([[reform]] < 0 || [[reform]] > PROM_SIZE_MAX) { fprintf(stderr, "qemu: could not load prom '%s'\n", buf); exit(1); } sbi = sbi_init(hwdef->sbi_base, &sbi_irq, &sbi_cpu_irq, cpu_irqs); for (i = 0; i < MAX_IOUNITS; i++) if (hwdef->iounit_bases[i] != (target_phys_addr_t)-1) [[departs]][i] = iommu_init(hwdef->iounit_bases[i], hwdef->iounit_version, sbi_irq[hwdef->me_irq]); espdma = sparc32_dma_init(hwdef->espdma_base, sbi_irq[hwdef->esp_irq], [[departs]][0], &espdma_irq, &[[ungh]]); ledma = sparc32_dma_init(hwdef->ledma_base, sbi_irq[hwdef->le_irq], [[departs]][0], &ledma_irq, &le_reset); if (graphic_depth != 8 && graphic_depth != 24) { fprintf(stderr, "qemu: Unsupported depth: %d\n", graphic_depth); exit (1); } tcx_offset = qemu_ram_alloc(hwdef->vram_size); tcx_init(ds, hwdef->tcx_base, phys_ram_base + tcx_offset, tcx_offset, hwdef->vram_size, graphic_width, graphic_height, graphic_depth); if (nd_table[0].model == NULL) nd_table[0].model = "lance"; if (strcmp(nd_table[0].model, "lance") == 0) { lance_init(&nd_table[0], hwdef->le_base, ledma, *ledma_irq, le_reset); } else if (strcmp(nd_table[0].model, "?") == 0) { fprintf(stderr, "qemu: Supported NICs: lance\n"); exit (1); } else { fprintf(stderr, "qemu: Unsupported NIC: %s\n", nd_table[0].model); exit (1); } nvram = m48t59_init(sbi_irq[0], hwdef->nvram_base, 0, hwdef->nvram_size, 8); slavio_timer_init_all(hwdef->counter_base, sbi_irq[hwdef->clock1_irq], sbi_cpu_irq, smp_cpus); slavio_serial_ms_kbd_init(hwdef->ms_kb_base, sbi_irq[hwdef->ms_kb_irq], nographic, ESCC_CLOCK, 1); escc_init(hwdef->serial_base, sbi_irq[hwdef->ser_irq], serial_hds[1], serial_hds[0], ESCC_CLOCK, 1); if (drive_get_max_bus(IF_SCSI) > 0) { fprintf(stderr, "qemu: too many SCSI bus\n"); exit(1); } main_esp = esp_init(hwdef->esp_base, 2, espdma_memory_read, espdma_memory_write, espdma, *espdma_irq, [[ungh]]); for (i = 0; i < ESP_MAX_DEVS; i++) { drive_index = drive_get_index(IF_SCSI, 0, i); if (drive_index == -1) continue; esp_scsi_attach(main_esp, drives_table[drive_index].bdrv, i); } kernel_size = sun4m_load_kernel(kernel_filename, initrd_filename, RAM_size); nvram_init(nvram, (uint8_t *)&nd_table[0].macaddr, kernel_cmdline, [[nevada]], RAM_size, kernel_size, graphic_width, graphic_height, graphic_depth, hwdef->nvram_machine_id, "Sun4d"); fw_cfg = fw_cfg_init(0, 0, CFG_ADDR, CFG_ADDR + 2); fw_cfg_add_i32(fw_cfg, FW_CFG_ID, 1); fw_cfg_add_i64(fw_cfg, FW_CFG_RAM_SIZE, (uint64_t)ram_size); fw_cfg_add_i16(fw_cfg, FW_CFG_MACHINE_ID, hwdef->machine_id); }[Succeeded / Failed / Skipped / Total] 130 / 48 / 135 / 313:  12%|        | 313/2690 [03:59<30:21,  1.31it/s][Succeeded / Failed / Skipped / Total] 130 / 48 / 135 / 313:  12%|        | 314/2690 [04:00<30:17,  1.31it/s][Succeeded / Failed / Skipped / Total] 131 / 48 / 135 / 314:  12%|        | 314/2690 [04:00<30:17,  1.31it/s][Succeeded / Failed / Skipped / Total] 131 / 48 / 136 / 315:  12%|        | 315/2690 [04:00<30:10,  1.31it/s][Succeeded / Failed / Skipped / Total] 132 / 48 / 136 / 316:  12%|        | 316/2690 [04:01<30:15,  1.31it/s][Succeeded / Failed / Skipped / Total] 132 / 48 / 136 / 316:  12%|        | 317/2690 [04:02<30:16,  1.31it/s]
--------------------------------------------- Result 314 ---------------------------------------------
[[0 (80%)]] --> [[0 (49%)]] --> Socre: 0.5086661279201508

[[[[Adv]]]]: static void virtio_scsi_device_unrealize(DeviceState *[[dev]], Error **[[errp]]) { virtio_scsi_common_unrealize([[dev]], [[errp]]); }

[[[[Adv]]]]: static void virtio_scsi_device_unrealize(DeviceState *[[kunal]], Error **[[overlooked]]) { virtio_scsi_common_unrealize([[kunal]], [[overlooked]]); }
--------------------------------------------- Result 315 ---------------------------------------------
[[0 (37%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int protocol_client_init(VncState *vs, uint8_t *data, size_t len) { char buf[1024]; VncShareMode mode; int size; mode = data[0] ? VNC_SHARE_MODE_SHARED : VNC_SHARE_MODE_EXCLUSIVE; switch (vs->vd->share_policy) { case VNC_SHARE_POLICY_IGNORE: break; case VNC_SHARE_POLICY_ALLOW_EXCLUSIVE: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { VncState *client; QTAILQ_FOREACH(client, &vs->vd->clients, next) { if (vs == client) { continue; } if (client->share_mode != VNC_SHARE_MODE_EXCLUSIVE && client->share_mode != VNC_SHARE_MODE_SHARED) { continue; } vnc_disconnect_start(client); } } if (mode == VNC_SHARE_MODE_SHARED) { if (vs->vd->num_exclusive > 0) { vnc_disconnect_start(vs); return 0; } } break; case VNC_SHARE_POLICY_FORCE_SHARED: if (mode == VNC_SHARE_MODE_EXCLUSIVE) { vnc_disconnect_start(vs); return 0; } break; } vnc_set_share_mode(vs, mode); vs->client_width = surface_width(vs->vd->ds); vs->client_height = surface_height(vs->vd->ds); vnc_write_u16(vs, vs->client_width); vnc_write_u16(vs, vs->client_height); pixel_format_message(vs); if (qemu_name) size = snprintf(buf, sizeof(buf), "QEMU (%s)", qemu_name); else size = snprintf(buf, sizeof(buf), "QEMU"); vnc_write_u32(vs, size); vnc_write(vs, buf, size); vnc_flush(vs); vnc_client_cache_auth(vs); vnc_qmp_event(vs, QAPI_EVENT_VNC_INITIALIZED); vnc_read_when(vs, protocol_client_msg, 1); return 0; }
--------------------------------------------- Result 316 ---------------------------------------------
[[0 (58%)]] --> [[0 (46%)]] --> Socre: 0.5351190268993378

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; void *[[bounce_buffer]]; BlockDriver *drv = bs->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t cluster_offset; int64_t cluster_bytes; size_t skip_bytes; int ret; int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes); skip_bytes = offset - cluster_offset; trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes); [[bounce_buffer]] = qemu_try_blockalign(bs, MIN(MIN(max_transfer, cluster_bytes), MAX_BOUNCE_BUFFER)); if ([[bounce_buffer]] == NULL) { ret = -ENOMEM; goto err; while (cluster_bytes) { int64_t pnum; ret = bdrv_is_allocated(bs, cluster_offset, MIN(cluster_bytes, max_transfer), &pnum); if (ret < 0) { pnum = MIN(cluster_bytes, max_transfer); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = [[bounce_buffer]]; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event(bs, BLKDBG_COR_WRITE); if (drv->bdrv_co_pwrite_zeroes && buffer_is_zero([[bounce_buffer]], pnum)) { ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0); } else { ret = bdrv_driver_pwritev(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, [[bounce_buffer]] + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; cluster_offset += pnum; cluster_bytes -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree([[bounce_buffer]]); return ret;

[[[[Adv]]]]: static int coroutine_fn bdrv_co_do_copy_on_readv(BdrvChild *child, int64_t offset, unsigned int bytes, QEMUIOVector *qiov) { BlockDriverState *bs = child->bs; void *[[chefs]]; BlockDriver *drv = bs->drv; struct iovec iov; QEMUIOVector local_qiov; int64_t cluster_offset; int64_t cluster_bytes; size_t skip_bytes; int ret; int max_transfer = MIN_NON_ZERO(bs->bl.max_transfer, BDRV_REQUEST_MAX_BYTES); unsigned int progress = 0; bdrv_round_to_clusters(bs, offset, bytes, &cluster_offset, &cluster_bytes); skip_bytes = offset - cluster_offset; trace_bdrv_co_do_copy_on_readv(bs, offset, bytes, cluster_offset, cluster_bytes); [[chefs]] = qemu_try_blockalign(bs, MIN(MIN(max_transfer, cluster_bytes), MAX_BOUNCE_BUFFER)); if ([[chefs]] == NULL) { ret = -ENOMEM; goto err; while (cluster_bytes) { int64_t pnum; ret = bdrv_is_allocated(bs, cluster_offset, MIN(cluster_bytes, max_transfer), &pnum); if (ret < 0) { pnum = MIN(cluster_bytes, max_transfer); assert(skip_bytes < pnum); if (ret <= 0) { iov.iov_base = [[chefs]]; iov.iov_len = pnum = MIN(pnum, MAX_BOUNCE_BUFFER); qemu_iovec_init_external(&local_qiov, &iov, 1); ret = bdrv_driver_preadv(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; bdrv_debug_event(bs, BLKDBG_COR_WRITE); if (drv->bdrv_co_pwrite_zeroes && buffer_is_zero([[chefs]], pnum)) { ret = bdrv_co_do_pwrite_zeroes(bs, cluster_offset, pnum, 0); } else { ret = bdrv_driver_pwritev(bs, cluster_offset, pnum, &local_qiov, 0); if (ret < 0) { goto err; qemu_iovec_from_buf(qiov, progress, [[chefs]] + skip_bytes, pnum - skip_bytes); } else { qemu_iovec_init(&local_qiov, qiov->niov); qemu_iovec_concat(&local_qiov, qiov, progress, pnum - skip_bytes); ret = bdrv_driver_preadv(bs, offset + progress, local_qiov.size, &local_qiov, 0); qemu_iovec_destroy(&local_qiov); if (ret < 0) { goto err; cluster_offset += pnum; cluster_bytes -= pnum; progress += pnum - skip_bytes; skip_bytes = 0; ret = 0; err: qemu_vfree([[chefs]]); return ret;
--------------------------------------------- Result 317 ---------------------------------------------
[[0 (16%)]] --> [[[FAILED]]]

[[[[Adv]]]]: av_cold void ff_sws_init_swScale_mmx(SwsContext *c) { int cpu_flags = av_get_cpu_flags(); #if HAVE_INLINE_ASM if (cpu_flags & AV_CPU_FLAG_MMX) sws_init_swScale_MMX(c); #if HAVE_MMXEXT_INLINE if (cpu_flags & AV_CPU_FLAG_MMXEXT) sws_init_swScale_MMX2(c); #endif #endif #if HAVE_YASM #define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \ if (c->srcBpc == 8) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \ ff_hscale8to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 9) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \ ff_hscale9to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 10) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \ ff_hscale10to19_ ## filtersize ## _ ## opt1; \ } else { \ hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \ ff_hscale16to19_ ## filtersize ## _ ## opt1; \ } \ } while (0) #define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \ } #define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \ switch(c->dstBpc){ \ case 16: do_16_case; break; \ case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \ case 9: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_ ## opt; break; \ default: if (condition_8bit) vscalefn = ff_yuv2planeX_8_ ## opt; break; \ } #define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \ switch(c->dstBpc){ \ case 16: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2plane1_16_ ## opt1; break; \ case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \ case 9: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_ ## opt2; break; \ default: vscalefn = ff_yuv2plane1_8_ ## opt1; break; \ } #define case_rgb(x, X, opt) \ case PIX_FMT_ ## X: \ c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \ if (!c->chrSrcHSubSample) \ c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \ break #if ARCH_X86_32 if (cpu_flags & AV_CPU_FLAG_MMX) { ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx); ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx); ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_mmx; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_mmx; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_mmx; c->chrToYV12 = ff_yuyvToUV_mmx; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_mmx; c->chrToYV12 = ff_uyvyToUV_mmx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_mmx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_mmx; break; case_rgb(rgb24, RGB24, mmx); case_rgb(bgr24, BGR24, mmx); case_rgb(bgra, BGRA, mmx); case_rgb(rgba, RGBA, mmx); case_rgb(abgr, ABGR, mmx); case_rgb(argb, ARGB, mmx); default: break; } } if (cpu_flags & AV_CPU_FLAG_MMXEXT) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1); } #endif #define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \ else ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \ break; \ } if (cpu_flags & AV_CPU_FLAG_SSE2) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_sse2; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_sse2; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_sse2; c->chrToYV12 = ff_yuyvToUV_sse2; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_sse2; c->chrToYV12 = ff_uyvyToUV_sse2; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_sse2; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_sse2; break; case_rgb(rgb24, RGB24, sse2); case_rgb(bgr24, BGR24, sse2); case_rgb(bgra, BGRA, sse2); case_rgb(rgba, RGBA, sse2); case_rgb(abgr, ABGR, sse2); case_rgb(argb, ARGB, sse2); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSSE3) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3); switch (c->srcFormat) { case_rgb(rgb24, RGB24, ssse3); case_rgb(bgr24, BGR24, ssse3); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSE4) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4, if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4, HAVE_ALIGNED_STACK || ARCH_X86_64); if (c->dstBpc == 16 && !isBE(c->dstFormat)) c->yuv2plane1 = ff_yuv2plane1_16_sse4; } if (cpu_flags & AV_CPU_FLAG_AVX) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1); switch (c->srcFormat) { case PIX_FMT_YUYV422: c->chrToYV12 = ff_yuyvToUV_avx; break; case PIX_FMT_UYVY422: c->chrToYV12 = ff_uyvyToUV_avx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_avx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_avx; break; case_rgb(rgb24, RGB24, avx); case_rgb(bgr24, BGR24, avx); case_rgb(bgra, BGRA, avx); case_rgb(rgba, RGBA, avx); case_rgb(abgr, ABGR, avx); case_rgb(argb, ARGB, avx); default: break; } } #endif }

[[[[Adv]]]]: av_cold void ff_sws_init_swScale_mmx(SwsContext *c) { int cpu_flags = av_get_cpu_flags(); #if HAVE_INLINE_ASM if (cpu_flags & AV_CPU_FLAG_MMX) sws_init_swScale_MMX(c); #if HAVE_MMXEXT_INLINE if (cpu_flags & AV_CPU_FLAG_MMXEXT) sws_init_swScale_MMX2(c); #endif #endif #if HAVE_YASM #define ASSIGN_SCALE_FUNC2(hscalefn, filtersize, opt1, opt2) do { \ if (c->srcBpc == 8) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale8to15_ ## filtersize ## _ ## opt2 : \ ff_hscale8to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 9) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale9to15_ ## filtersize ## _ ## opt2 : \ ff_hscale9to19_ ## filtersize ## _ ## opt1; \ } else if (c->srcBpc == 10) { \ hscalefn = c->dstBpc <= 10 ? ff_hscale10to15_ ## filtersize ## _ ## opt2 : \ ff_hscale10to19_ ## filtersize ## _ ## opt1; \ } else { \ hscalefn = c->dstBpc <= 10 ? ff_hscale16to15_ ## filtersize ## _ ## opt2 : \ ff_hscale16to19_ ## filtersize ## _ ## opt1; \ } \ } while (0) #define ASSIGN_MMX_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: ASSIGN_SCALE_FUNC2(hscalefn, X, opt1, opt2); break; \ } #define ASSIGN_VSCALEX_FUNC(vscalefn, opt, do_16_case, condition_8bit) \ switch(c->dstBpc){ \ case 16: do_16_case; break; \ case 10: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_10_ ## opt; break; \ case 9: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2planeX_9_ ## opt; break; \ default: if (condition_8bit) vscalefn = ff_yuv2planeX_8_ ## opt; break; \ } #define ASSIGN_VSCALE_FUNC(vscalefn, opt1, opt2, opt2chk) \ switch(c->dstBpc){ \ case 16: if (!isBE(c->dstFormat)) vscalefn = ff_yuv2plane1_16_ ## opt1; break; \ case 10: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_10_ ## opt2; break; \ case 9: if (!isBE(c->dstFormat) && opt2chk) vscalefn = ff_yuv2plane1_9_ ## opt2; break; \ default: vscalefn = ff_yuv2plane1_8_ ## opt1; break; \ } #define case_rgb(x, X, opt) \ case PIX_FMT_ ## X: \ c->lumToYV12 = ff_ ## x ## ToY_ ## opt; \ if (!c->chrSrcHSubSample) \ c->chrToYV12 = ff_ ## x ## ToUV_ ## opt; \ break #if ARCH_X86_32 if (cpu_flags & AV_CPU_FLAG_MMX) { ASSIGN_MMX_SCALE_FUNC(c->hyScale, c->hLumFilterSize, mmx, mmx); ASSIGN_MMX_SCALE_FUNC(c->hcScale, c->hChrFilterSize, mmx, mmx); ASSIGN_VSCALE_FUNC(c->yuv2plane1, mmx, mmx2, cpu_flags & AV_CPU_FLAG_MMXEXT); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_mmx; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_mmx; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_mmx; c->chrToYV12 = ff_yuyvToUV_mmx; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_mmx; c->chrToYV12 = ff_uyvyToUV_mmx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_mmx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_mmx; break; case_rgb(rgb24, RGB24, mmx); case_rgb(bgr24, BGR24, mmx); case_rgb(bgra, BGRA, mmx); case_rgb(rgba, RGBA, mmx); case_rgb(abgr, ABGR, mmx); case_rgb(argb, ARGB, mmx); default: break; } } if (cpu_flags & AV_CPU_FLAG_MMXEXT) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, mmx2, , 1); } #endif #define ASSIGN_SSE_SCALE_FUNC(hscalefn, filtersize, opt1, opt2) \ switch (filtersize) { \ case 4: ASSIGN_SCALE_FUNC2(hscalefn, 4, opt1, opt2); break; \ case 8: ASSIGN_SCALE_FUNC2(hscalefn, 8, opt1, opt2); break; \ default: if (filtersize & 4) ASSIGN_SCALE_FUNC2(hscalefn, X4, opt1, opt2); \ else ASSIGN_SCALE_FUNC2(hscalefn, X8, opt1, opt2); \ break; \ } if (cpu_flags & AV_CPU_FLAG_SSE2) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse2, sse2); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse2, sse2); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse2, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, sse2, sse2, 1); switch (c->srcFormat) { case PIX_FMT_Y400A: c->lumToYV12 = ff_yuyvToY_sse2; if (c->alpPixBuf) c->alpToYV12 = ff_uyvyToY_sse2; break; case PIX_FMT_YUYV422: c->lumToYV12 = ff_yuyvToY_sse2; c->chrToYV12 = ff_yuyvToUV_sse2; break; case PIX_FMT_UYVY422: c->lumToYV12 = ff_uyvyToY_sse2; c->chrToYV12 = ff_uyvyToUV_sse2; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_sse2; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_sse2; break; case_rgb(rgb24, RGB24, sse2); case_rgb(bgr24, BGR24, sse2); case_rgb(bgra, BGRA, sse2); case_rgb(rgba, RGBA, sse2); case_rgb(abgr, ABGR, sse2); case_rgb(argb, ARGB, sse2); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSSE3) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, ssse3, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, ssse3, ssse3); switch (c->srcFormat) { case_rgb(rgb24, RGB24, ssse3); case_rgb(bgr24, BGR24, ssse3); default: break; } } if (cpu_flags & AV_CPU_FLAG_SSE4) { ASSIGN_SSE_SCALE_FUNC(c->hyScale, c->hLumFilterSize, sse4, ssse3); ASSIGN_SSE_SCALE_FUNC(c->hcScale, c->hChrFilterSize, sse4, ssse3); ASSIGN_VSCALEX_FUNC(c->yuv2planeX, sse4, if (!isBE(c->dstFormat)) c->yuv2planeX = ff_yuv2planeX_16_sse4, HAVE_ALIGNED_STACK || ARCH_X86_64); if (c->dstBpc == 16 && !isBE(c->dstFormat)) c->yuv2plane1 = ff_yuv2plane1_16_sse4; } if (cpu_flags & AV_CPU_FLAG_AVX) { ASSIGN_VSCALEX_FUNC(c->yuv2planeX, avx, , HAVE_ALIGNED_STACK || ARCH_X86_64); ASSIGN_VSCALE_FUNC(c->yuv2plane1, avx, avx, 1); switch (c->srcFormat) { case PIX_FMT_YUYV422: c->chrToYV12 = ff_yuyvToUV_avx; break; case PIX_FMT_UYVY422: c->chrToYV12 = ff_uyvyToUV_avx; break; case PIX_FMT_NV12: c->chrToYV12 = ff_nv12ToUV_avx; break; case PIX_FMT_NV21: c->chrToYV12 = ff_nv21ToUV_avx; break; case_rgb(rgb24, RGB24, avx); case_rgb(bgr24, BGR24, avx); case_rgb(bgra, BGRA, avx); case_rgb(rgba, RGBA, avx); case_rgb(abgr, ABGR, avx); case_rgb(argb, ARGB, avx); default: break; } } #endif }[Succeeded / Failed / Skipped / Total] 132 / 49 / 136 / 317:  12%|        | 317/2690 [04:02<30:16,  1.31it/s][Succeeded / Failed / Skipped / Total] 133 / 49 / 136 / 318:  12%|        | 318/2690 [04:04<30:21,  1.30it/s][Succeeded / Failed / Skipped / Total] 134 / 49 / 136 / 319:  12%|        | 319/2690 [04:06<30:31,  1.29it/s][Succeeded / Failed / Skipped / Total] 134 / 49 / 136 / 319:  12%|        | 320/2690 [04:06<30:25,  1.30it/s][Succeeded / Failed / Skipped / Total] 134 / 49 / 137 / 320:  12%|        | 320/2690 [04:06<30:25,  1.30it/s][Succeeded / Failed / Skipped / Total] 134 / 50 / 137 / 321:  12%|        | 321/2690 [04:06<30:21,  1.30it/s][Succeeded / Failed / Skipped / Total] 134 / 50 / 138 / 322:  12%|        | 322/2690 [04:06<30:15,  1.30it/s][Succeeded / Failed / Skipped / Total] 134 / 50 / 138 / 322:  12%|        | 323/2690 [04:06<30:08,  1.31it/s]
--------------------------------------------- Result 318 ---------------------------------------------
[[0 (29%)]] --> [[0 (51%)]] --> Socre: 0.5079983472824097

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *[[bs]], int64_t sector_num, QEMUIOVector *[[qiov]], int [[nb_sectors]], BlockDriverCompletionFunc *cb, void *opaque) { BDRVRawState *[[s]] = [[bs]]->opaque; return paio_submit([[bs]], [[s]]->hfile, sector_num, [[qiov]], [[nb_sectors]], cb, opaque, QEMU_AIO_READ); }

[[[[Adv]]]]: static BlockDriverAIOCB *raw_aio_readv(BlockDriverState *[[peruvian]], int64_t sector_num, QEMUIOVector *[[machinist]], int [[jelly]], BlockDriverCompletionFunc *cb, void *opaque) { BDRVRawState *[[n]] = [[peruvian]]->opaque; return paio_submit([[peruvian]], [[n]]->hfile, sector_num, [[machinist]], [[jelly]], cb, opaque, QEMU_AIO_READ); }
--------------------------------------------- Result 319 ---------------------------------------------
[[0 (78%)]] --> [[0 (42%)]] --> Socre: 0.5800104141235352

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *[[src]], uint8_t *[[dst]], int src_size) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = [[dst]]; const uint16_t *[[s]] = (const uint16_t *)[[src]]; end = [[s]] + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); mm_end = end - 3; while ([[s]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*[[s]]),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; [[s]] += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[s]] < end) { register uint16_t [[bgr]]; [[bgr]] = *[[s]]++; *d++ = ([[bgr]]&0x1F)<<3; *d++ = ([[bgr]]&0x3E0)>>2; *d++ = ([[bgr]]&0x7C00)>>7; *d++ = 255; } }

[[[[Adv]]]]: static inline void RENAME(rgb15to32)(const uint8_t *[[lipo]], uint8_t *[[jags]], int src_size) { const uint16_t *end; const uint16_t *mm_end; uint8_t *d = [[jags]]; const uint16_t *[[of]] = (const uint16_t *)[[lipo]]; end = [[of]] + src_size/2; __asm__ volatile(PREFETCH" %0"::"m"(*s):"memory"); __asm__ volatile("pxor %%mm7,%%mm7 \n\t":::"memory"); __asm__ volatile("pcmpeqd %%mm6,%%mm6 \n\t":::"memory"); mm_end = end - 3; while ([[of]] < mm_end) { __asm__ volatile( PREFETCH" 32%1 \n\t" "movq %1, %%mm0 \n\t" "movq %1, %%mm1 \n\t" "movq %1, %%mm2 \n\t" "pand %2, %%mm0 \n\t" "pand %3, %%mm1 \n\t" "pand %4, %%mm2 \n\t" "psllq $3, %%mm0 \n\t" "psrlq $2, %%mm1 \n\t" "psrlq $7, %%mm2 \n\t" PACK_RGB32 :"=m"(*d) :"m"(*[[of]]),"m"(mask15b),"m"(mask15g),"m"(mask15r) :"memory"); d += 16; [[of]] += 4; } __asm__ volatile(SFENCE:::"memory"); __asm__ volatile(EMMS:::"memory"); while ([[of]] < end) { register uint16_t [[festivity]]; [[festivity]] = *[[of]]++; *d++ = ([[festivity]]&0x1F)<<3; *d++ = ([[festivity]]&0x3E0)>>2; *d++ = ([[festivity]]&0x7C00)>>7; *d++ = 255; } }
--------------------------------------------- Result 320 ---------------------------------------------
[[0 (45%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_h261_handle_packet(AVFormatContext *ctx, PayloadContext *data, AVStream *st, AVPacket *pkt, uint32_t *timestamp, const uint8_t *buf, int len, uint16_t seq, int flags) { int sbit, ebit, gobn, mbap, quant; int res; if (data->buf && data->timestamp != *timestamp) { h261_free_dyn_buffer(&data->buf); } if (len < 5 ) { av_log(ctx, AV_LOG_ERROR, "Too short H.261 RTP packet\n"); return AVERROR_INVALIDDATA; } sbit = (buf[0] >> 5) & 0x07; ebit = (buf[0] >> 2) & 0x07; gobn = (buf[1] >> 4) & 0x0f; mbap = ((buf[1] << 1) & 0x1e) | ((buf[1] >> 7) & 0x01); quant = (buf[1] >> 4) & 0x0f; buf += RTP_H261_PAYLOAD_HEADER_SIZE; len -= RTP_H261_PAYLOAD_HEADER_SIZE; if (!data->buf) { if (!gobn && !sbit && !mbap && !quant){ res = avio_open_dyn_buf(&data->buf); if (res < 0) return res; data->timestamp = *timestamp; } else { return AVERROR(EAGAIN); } } if (data->endbyte_bits || sbit) { if (data->endbyte_bits == sbit) { data->endbyte |= buf[0] & (0xff >> sbit); data->endbyte_bits = 0; buf++; len--; avio_w8(data->buf, data->endbyte); } else { GetBitContext gb; init_get_bits(&gb, buf, len*8 - ebit); skip_bits(&gb, sbit); if (data->endbyte_bits) { data->endbyte |= get_bits(&gb, 8 - data->endbyte_bits); avio_w8(data->buf, data->endbyte); } while (get_bits_left(&gb) >= 8) avio_w8(data->buf, get_bits(&gb, 8)); data->endbyte_bits = get_bits_left(&gb); if (data->endbyte_bits) data->endbyte = get_bits(&gb, data->endbyte_bits) << (8 - data->endbyte_bits); ebit = 0; len = 0; } } if (ebit) { if (len > 0) avio_write(data->buf, buf, len - 1); data->endbyte_bits = 8 - ebit; data->endbyte = buf[len - 1] & (0xff << ebit); } else { avio_write(data->buf, buf, len); } if (!(flags & RTP_FLAG_MARKER)) return AVERROR(EAGAIN); if (data->endbyte_bits) avio_w8(data->buf, data->endbyte); data->endbyte_bits = 0; res = ff_rtp_finalize_packet(pkt, &data->buf, st->index); if (res < 0) return res; return 0; }
--------------------------------------------- Result 321 ---------------------------------------------
[[0 (27%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg) { S390CPU *cpu = S390_CPU(cs); SigpInfo *si = arg.host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status(si, SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) { set_sigp_status(si, SIGP_STAT_INCORRECT_STATE); return; } if (si->param & 0x3ff) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state(cs); if (kvm_s390_store_adtl_status(cpu, si->param)) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } si->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }

[[[[Adv]]]]: static void sigp_store_adtl_status(CPUState *cs, run_on_cpu_data arg) { S390CPU *cpu = S390_CPU(cs); SigpInfo *si = arg.host_ptr; if (!s390_has_feat(S390_FEAT_VECTOR)) { set_sigp_status(si, SIGP_STAT_INVALID_ORDER); return; } if (s390_cpu_get_state(cpu) != CPU_STATE_STOPPED) { set_sigp_status(si, SIGP_STAT_INCORRECT_STATE); return; } if (si->param & 0x3ff) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } cpu_synchronize_state(cs); if (kvm_s390_store_adtl_status(cpu, si->param)) { set_sigp_status(si, SIGP_STAT_INVALID_PARAMETER); return; } si->cc = SIGP_CC_ORDER_CODE_ACCEPTED; }
--------------------------------------------- Result 322 ---------------------------------------------
[[0 (49%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void h263_decode_init_vlc(MpegEncContext *s) { static int done = 0; if (!done) { done = 1; init_vlc(&intra_MCBPC_vlc, INTRA_MCBPC_VLC_BITS, 9, intra_MCBPC_bits, 1, 1, intra_MCBPC_code, 1, 1); init_vlc(&inter_MCBPC_vlc, INTER_MCBPC_VLC_BITS, 28, inter_MCBPC_bits, 1, 1, inter_MCBPC_code, 1, 1); init_vlc(&cbpy_vlc, CBPY_VLC_BITS, 16, &cbpy_tab[0][1], 2, 1, &cbpy_tab[0][0], 2, 1); init_vlc(&mv_vlc, MV_VLC_BITS, 33, &mvtab[0][1], 2, 1, &mvtab[0][0], 2, 1); init_rl(&rl_inter); init_rl(&rl_intra); init_rl(&rvlc_rl_inter); init_rl(&rvlc_rl_intra); init_rl(&rl_intra_aic); init_vlc_rl(&rl_inter); init_vlc_rl(&rl_intra); init_vlc_rl(&rvlc_rl_inter); init_vlc_rl(&rvlc_rl_intra); init_vlc_rl(&rl_intra_aic); init_vlc(&dc_lum, DC_VLC_BITS, 10 , &DCtab_lum[0][1], 2, 1, &DCtab_lum[0][0], 2, 1); init_vlc(&dc_chrom, DC_VLC_BITS, 10 , &DCtab_chrom[0][1], 2, 1, &DCtab_chrom[0][0], 2, 1); init_vlc(&sprite_trajectory, SPRITE_TRAJ_VLC_BITS, 15, &sprite_trajectory_tab[0][1], 4, 2, &sprite_trajectory_tab[0][0], 4, 2); init_vlc(&mb_type_b_vlc, MB_TYPE_B_VLC_BITS, 4, &mb_type_b_tab[0][1], 2, 1, &mb_type_b_tab[0][0], 2, 1); init_vlc(&h263_mbtype_b_vlc, H263_MBTYPE_B_VLC_BITS, 15, &h263_mbtype_b_tab[0][1], 2, 1, &h263_mbtype_b_tab[0][0], 2, 1); init_vlc(&cbpc_b_vlc, CBPC_B_VLC_BITS, 4, &cbpc_b_tab[0][1], 2, 1, &cbpc_b_tab[0][0], 2, 1); } }
--------------------------------------------- Result 323 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 134 / 50 / 139 / 323:  12%|        | 323/2690 [04:06<30:08,  1.31it/s][Succeeded / Failed / Skipped / Total] 135 / 50 / 139 / 324:  12%|        | 324/2690 [04:08<30:12,  1.31it/s][Succeeded / Failed / Skipped / Total] 136 / 50 / 139 / 325:  12%|        | 325/2690 [04:09<30:12,  1.30it/s][Succeeded / Failed / Skipped / Total] 136 / 50 / 139 / 325:  12%|        | 326/2690 [04:09<30:07,  1.31it/s][[0 (3%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static uint64_t icp_pit_read(void *opaque, target_phys_addr_t offset, unsigned size) { icp_pit_state *s = (icp_pit_state *)opaque; int n; n = offset >> 8; if (n > 3) { hw_error("sp804_read: Bad timer %d\n", n); } return arm_timer_read(s->timer[n], offset & 0xff); }
--------------------------------------------- Result 324 ---------------------------------------------
[[0 (60%)]] --> [[0 (50%)]] --> Socre: 0.5022907257080078

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *[[s1]] = avctx->priv_data; MpegEncContext *s = &[[s1]]->mpeg_enc_ctx; int width, height, i, v, j; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); skip_bits(&s->gb, 4); s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if ([[s1]]->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; s->has_b_frames = 1; s->avctx = avctx; avctx->width = width; avctx->height = height; avctx->frame_rate = frame_rate_tab[s->frame_rate_index]; s->frame_rate = avctx->frame_rate; avctx->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; mpeg1_init_vlc(s); [[s1]]->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_intra_matrix[i]; s->intra_matrix[i] = v; s->chroma_intra_matrix[i] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->non_intra_matrix[j] = v; s->chroma_non_intra_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->non_intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_non_intra_matrix[i]; s->non_intra_matrix[i] = v; s->chroma_non_intra_matrix[i] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; return 0; }

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *avctx, UINT8 *buf, int buf_size) { Mpeg1Context *[[discoveries]] = avctx->priv_data; MpegEncContext *s = &[[discoveries]]->mpeg_enc_ctx; int width, height, i, v, j; init_get_bits(&s->gb, buf, buf_size); width = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); skip_bits(&s->gb, 4); s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if (width <= 0 || height <= 0 || (width % 2) != 0 || (height % 2) != 0) return -1; if (width != s->width || height != s->height) { s->out_format = FMT_MPEG1; if ([[discoveries]]->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = width; s->height = height; s->has_b_frames = 1; s->avctx = avctx; avctx->width = width; avctx->height = height; avctx->frame_rate = frame_rate_tab[s->frame_rate_index]; s->frame_rate = avctx->frame_rate; avctx->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; mpeg1_init_vlc(s); [[discoveries]]->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_intra_matrix[i]; s->intra_matrix[i] = v; s->chroma_intra_matrix[i] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = zigzag_direct[i]; s->non_intra_matrix[j] = v; s->chroma_non_intra_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->non_intra_matrix[zigzag_direct[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { v = default_non_intra_matrix[i]; s->non_intra_matrix[i] = v; s->chroma_non_intra_matrix[i] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; return 0; }
--------------------------------------------- Result 325 ---------------------------------------------
[[0 (64%)]] --> [[0 (47%)]] --> Socre: 0.5286892652511597

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *ic) { int i, j; for (i = 0; i<ic->nb_streams; i++) { AVStream *st = ic->streams[i]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int num = 0; double best_error= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int [[k]]; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for([[k]]=0; [[k]]<2; [[k]]++){ int n= st->info->duration_count; double a= st->info->duration_error[[[k]]][0][j] / n; double error= st->info->duration_error[[[k]]][1][j]/n - a*a; if(error < best_error && best_error> 0.000000001){ best_error= error; num = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }

[[[[Adv]]]]: void ff_rfps_calculate(AVFormatContext *ic) { int i, j; for (i = 0; i<ic->nb_streams; i++) { AVStream *st = ic->streams[i]; if (st->codec->codec_type != AVMEDIA_TYPE_VIDEO) if (tb_unreliable(st->codec) && st->info->duration_count > 15 && st->info->duration_gcd > FFMAX(1, st->time_base.den/(500LL*st->time_base.num)) && !st->r_frame_rate.num) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, st->time_base.den, st->time_base.num * st->info->duration_gcd, INT_MAX); if (st->info->duration_count>1 && !st->r_frame_rate.num && tb_unreliable(st->codec)) { int num = 0; double best_error= 0.01; for (j=0; j<MAX_STD_TIMEBASES; j++) { int [[p]]; if(st->info->codec_info_duration && st->info->codec_info_duration*av_q2d(st->time_base) < (1001*12.0)/get_std_framerate(j)) if(!st->info->codec_info_duration && 1.0 < (1001*12.0)/get_std_framerate(j)) for([[p]]=0; [[p]]<2; [[p]]++){ int n= st->info->duration_count; double a= st->info->duration_error[[[p]]][0][j] / n; double error= st->info->duration_error[[[p]]][1][j]/n - a*a; if(error < best_error && best_error> 0.000000001){ best_error= error; num = get_std_framerate(j); } if(error < 0.02) av_log(NULL, AV_LOG_DEBUG, "rfps: %f %f\n", get_std_framerate(j) / 12.0/1001, error); } } if (num && (!st->r_frame_rate.num || (double)num/(12*1001) < 1.01 * av_q2d(st->r_frame_rate))) av_reduce(&st->r_frame_rate.num, &st->r_frame_rate.den, num, 12*1001, INT_MAX); } av_freep(&st->info->duration_error); st->info->last_dts = AV_NOPTS_VALUE; st->info->duration_count = 0; st->info->rfps_duration_sum = 0; } }
--------------------------------------------- Result 326 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 137 / 50 / 139 / 326:  12%|        | 326/2690 [04:09<30:07,  1.31it/s][Succeeded / Failed / Skipped / Total] 137 / 51 / 139 / 327:  12%|        | 327/2690 [04:09<30:03,  1.31it/s][Succeeded / Failed / Skipped / Total] 137 / 52 / 139 / 328:  12%|        | 328/2690 [04:16<30:49,  1.28it/s][Succeeded / Failed / Skipped / Total] 137 / 52 / 139 / 328:  12%|        | 329/2690 [04:16<30:42,  1.28it/s][Succeeded / Failed / Skipped / Total] 137 / 52 / 140 / 329:  12%|        | 329/2690 [04:16<30:42,  1.28it/s][Succeeded / Failed / Skipped / Total] 137 / 52 / 141 / 330:  12%|        | 330/2690 [04:16<30:36,  1.28it/s][Succeeded / Failed / Skipped / Total] 138 / 52 / 141 / 331:  12%|        | 331/2690 [04:17<30:35,  1.29it/s][Succeeded / Failed / Skipped / Total] 138 / 52 / 141 / 331:  12%|        | 332/2690 [04:17<30:29,  1.29it/s][[0 (24%)]] --> [[0 (58%)]] --> Socre: 0.5756887793540955

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *[[s]], TCGv [[reg]]) { gen_compute_eflags([[s]]); tcg_gen_shri_tl([[reg]], cpu_cc_src, 11); tcg_gen_andi_tl([[reg]], [[reg]], 1); }

[[[[Adv]]]]: static void gen_compute_eflags_o(DisasContext *[[rs]], TCGv [[prod]]) { gen_compute_eflags([[rs]]); tcg_gen_shri_tl([[prod]], cpu_cc_src, 11); tcg_gen_andi_tl([[prod]], [[prod]], 1); }
--------------------------------------------- Result 327 ---------------------------------------------
[[0 (63%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int mux_chr_can_read(void *opaque) { CharDriverState *chr = opaque; MuxDriver *d = chr->opaque; if ((d->prod - d->cons) < MUX_BUFFER_SIZE) return 1; if (d->chr_can_read[chr->focus]) return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]); return 0; }

[[[[Adv]]]]: static int mux_chr_can_read(void *opaque) { CharDriverState *chr = opaque; MuxDriver *d = chr->opaque; if ((d->prod - d->cons) < MUX_BUFFER_SIZE) return 1; if (d->chr_can_read[chr->focus]) return d->chr_can_read[chr->focus](d->ext_opaque[chr->focus]); return 0; }
--------------------------------------------- Result 328 ---------------------------------------------
[[0 (14%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { TCXState *s = opaque; uint32_t adsr, len; int i; if (!(addr & 4)) { s->tmpblit = val; } else { addr = (addr >> 3) & 0xfffff; adsr = val & 0xffffff; len = ((val >> 24) & 0x1f) + 1; if (adsr == 0xffffff) { memset(&s->vram[addr], s->tmpblit, len); if (s->depth == 24) { val = s->tmpblit & 0xffffff; val = cpu_to_be32(val); for (i = 0; i < len; i++) { s->vram24[addr + i] = val; } } } else { memcpy(&s->vram[addr], &s->vram[adsr], len); if (s->depth == 24) { memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4); } } memory_region_set_dirty(&s->vram_mem, addr, len); } }

[[[[Adv]]]]: static void tcx_blit_writel(void *opaque, hwaddr addr, uint64_t val, unsigned size) { TCXState *s = opaque; uint32_t adsr, len; int i; if (!(addr & 4)) { s->tmpblit = val; } else { addr = (addr >> 3) & 0xfffff; adsr = val & 0xffffff; len = ((val >> 24) & 0x1f) + 1; if (adsr == 0xffffff) { memset(&s->vram[addr], s->tmpblit, len); if (s->depth == 24) { val = s->tmpblit & 0xffffff; val = cpu_to_be32(val); for (i = 0; i < len; i++) { s->vram24[addr + i] = val; } } } else { memcpy(&s->vram[addr], &s->vram[adsr], len); if (s->depth == 24) { memcpy(&s->vram24[addr], &s->vram24[adsr], len * 4); } } memory_region_set_dirty(&s->vram_mem, addr, len); } }
--------------------------------------------- Result 329 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: void cpu_loop(CPUMIPSState *env) { target_siginfo_t info; int trapnr, ret; unsigned int syscall_num; for(;;) { trapnr = cpu_mips_exec(env); switch(trapnr) { case EXCP_SYSCALL: syscall_num = env->active_tc.gpr[2] - 4000; env->active_tc.PC += 4; if (syscall_num >= sizeof(mips_syscall_args)) { ret = -ENOSYS; } else { int nb_args; abi_ulong sp_reg; abi_ulong arg5 = 0, arg6 = 0, arg7 = 0, arg8 = 0; nb_args = mips_syscall_args[syscall_num]; sp_reg = env->active_tc.gpr[29]; switch (nb_args) { case 8: get_user_ual(arg8, sp_reg + 28); case 7: get_user_ual(arg7, sp_reg + 24); case 6: get_user_ual(arg6, sp_reg + 20); case 5: get_user_ual(arg5, sp_reg + 16); default: ret = do_syscall(env, env->active_tc.gpr[2], env->active_tc.gpr[4], env->active_tc.gpr[5], env->active_tc.gpr[6], env->active_tc.gpr[7], arg5, arg6 ); if ((unsigned int)ret >= (unsigned int)(-1133)) { env->active_tc.gpr[7] = 1; ret = -ret; } else { env->active_tc.gpr[7] = 0; env->active_tc.gpr[2] = ret; case EXCP_TLBL: case EXCP_TLBS: info.si_signo = TARGET_SIGSEGV; info.si_errno = 0; info.si_code = TARGET_SEGV_MAPERR; info._sifields._sigfault._addr = env->CP0_BadVAddr; queue_signal(env, info.si_signo, &info); case EXCP_CpU: case EXCP_RI: info.si_signo = TARGET_SIGILL; info.si_errno = 0; info.si_code = 0; queue_signal(env, info.si_signo, &info); case EXCP_INTERRUPT: case EXCP_DEBUG: { int sig; sig = gdb_handlesig (env, TARGET_SIGTRAP); if (sig) { info.si_signo = sig; info.si_errno = 0; info.si_code = TARGET_TRAP_BRKPT; queue_signal(env, info.si_signo, &info); default: fprintf(stderr, "qemu: unhandled CPU exception 0x%x - aborting\n", trapnr); cpu_dump_state(env, stderr, fprintf, 0); abort(); process_pending_signals(env);
--------------------------------------------- Result 330 ---------------------------------------------
[[0 (33%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int tmv_read_seek(AVFormatContext *s, int stream_index, int64_t timestamp, int flags) { TMVContext *tmv = s->priv_data; int64_t pos; if (stream_index) return -1; pos = timestamp * (tmv->audio_chunk_size + tmv->video_chunk_size + tmv->padding); avio_seek(s->pb, pos + TMV_HEADER_SIZE, SEEK_SET); tmv->stream_index = 0; return 0; }
--------------------------------------------- Result 331 ---------------------------------------------
[[0 (78%)]] --> [[0 (33%)]] --> Socre: 0.6714309751987457

[[[[Adv]]]]: static void bonito_ldma_writel(void *opaque, hwaddr addr, uint64_t [[val]], unsigned [[size]]) { PCIBonitoState *[[s]] = opaque; ((uint32_t *)(&[[s]]->bonldma))[addr/sizeof(uint32_t)] = [[val]] & 0xffffffff;

[[[[Adv]]]]: static void bonito_ldma_writel(void *opaque, hwaddr addr, uint64_t [[voter]], unsigned [[calibrate]]) { PCIBonitoState *[[secs]] = opaque; ((uint32_t *)(&[[secs]]->bonldma))[addr/sizeof(uint32_t)] = [[voter]] & 0xffffffff;
--------------------------------------------- Result 332 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 138 / 52 / 142 / 332:  12%|        | 332/2690 [04:17<30:29,  1.29it/s][Succeeded / Failed / Skipped / Total] 139 / 52 / 142 / 333:  12%|        | 333/2690 [04:17<30:23,  1.29it/s][[0 (24%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int jpeg2000_decode_packet(Jpeg2000DecoderContext *s, Jpeg2000Tile *tile, int *tp_index, Jpeg2000CodingStyle *codsty, Jpeg2000ResLevel *rlevel, int precno, int layno, uint8_t *expn, int numgbits) { int bandno, cblkno, ret, nb_code_blocks; int cwsno; if (layno < rlevel->band[0].prec[precno].decoded_layers) return 0; rlevel->band[0].prec[precno].decoded_layers = layno + 1; if (bytestream2_get_bytes_left(&s->g) == 0 && s->bit_index == 8) { if (*tp_index < FF_ARRAY_ELEMS(tile->tile_part) - 1) { s->g = tile->tile_part[++(*tp_index)].tpg; } } if (bytestream2_peek_be32(&s->g) == JPEG2000_SOP_FIXED_BYTES) bytestream2_skip(&s->g, JPEG2000_SOP_BYTE_LENGTH); if (!(ret = get_bits(s, 1))) { jpeg2000_flush(s); return 0; } else if (ret < 0) return ret; for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; if (band->coord[0][0] == band->coord[0][1] || band->coord[1][0] == band->coord[1][1]) continue; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; int incl, newpasses, llen; if (cblk->npasses) incl = get_bits(s, 1); else incl = tag_tree_decode(s, prec->cblkincl + cblkno, layno + 1) == layno; if (!incl) continue; else if (incl < 0) return incl; if (!cblk->npasses) { int v = expn[bandno] + numgbits - 1 - tag_tree_decode(s, prec->zerobits + cblkno, 100); if (v < 0 || v > 30) { av_log(s->avctx, AV_LOG_ERROR, "nonzerobits %d invalid or unsupported\n", v); return AVERROR_INVALIDDATA; } cblk->nonzerobits = v; } if ((newpasses = getnpasses(s)) < 0) return newpasses; av_assert2(newpasses > 0); if (cblk->npasses + newpasses >= JPEG2000_MAX_PASSES) { avpriv_request_sample(s->avctx, "Too many passes"); return AVERROR_PATCHWELCOME; } if ((llen = getlblockinc(s)) < 0) return llen; if (cblk->lblock + llen + av_log2(newpasses) > 16) { avpriv_request_sample(s->avctx, "Block with length beyond 16 bits"); return AVERROR_PATCHWELCOME; } cblk->lblock += llen; cblk->nb_lengthinc = 0; cblk->nb_terminationsinc = 0; do { int newpasses1 = 0; while (newpasses1 < newpasses) { newpasses1 ++; if (needs_termination(codsty->cblk_style, cblk->npasses + newpasses1 - 1)) { cblk->nb_terminationsinc ++; break; } } if ((ret = get_bits(s, av_log2(newpasses1) + cblk->lblock)) < 0) return ret; if (ret > sizeof(cblk->data)) { avpriv_request_sample(s->avctx, "Block with lengthinc greater than %"SIZE_SPECIFIER"", sizeof(cblk->data)); return AVERROR_PATCHWELCOME; } cblk->lengthinc[cblk->nb_lengthinc++] = ret; cblk->npasses += newpasses1; newpasses -= newpasses1; } while(newpasses); } } jpeg2000_flush(s); if (codsty->csty & JPEG2000_CSTY_EPH) { if (bytestream2_peek_be16(&s->g) == JPEG2000_EPH) bytestream2_skip(&s->g, 2); else av_log(s->avctx, AV_LOG_ERROR, "EPH marker not found. instead %X\n", bytestream2_peek_be32(&s->g)); } for (bandno = 0; bandno < rlevel->nbands; bandno++) { Jpeg2000Band *band = rlevel->band + bandno; Jpeg2000Prec *prec = band->prec + precno; nb_code_blocks = prec->nb_codeblocks_height * prec->nb_codeblocks_width; for (cblkno = 0; cblkno < nb_code_blocks; cblkno++) { Jpeg2000Cblk *cblk = prec->cblk + cblkno; for (cwsno = 0; cwsno < cblk->nb_lengthinc; cwsno ++) { if ( bytestream2_get_bytes_left(&s->g) < cblk->lengthinc[cwsno] || sizeof(cblk->data) < cblk->length + cblk->lengthinc[cwsno] + 4 ) { av_log(s->avctx, AV_LOG_ERROR, "Block length %"PRIu16" or lengthinc %d is too large, left %d\n", cblk->length, cblk->lengthinc[cwsno], bytestream2_get_bytes_left(&s->g)); return AVERROR_INVALIDDATA; } bytestream2_get_bufferu(&s->g, cblk->data + cblk->length, cblk->lengthinc[cwsno]); cblk->length += cblk->lengthinc[cwsno]; cblk->lengthinc[cwsno] = 0; if (cblk->nb_terminationsinc) { cblk->nb_terminationsinc--; cblk->nb_terminations++; cblk->data[cblk->length++] = 0xFF; cblk->data[cblk->length++] = 0xFF; cblk->data_start[cblk->nb_terminations] = cblk->length; } } } } return 0; }
--------------------------------------------- Result 333 ---------------------------------------------
[[0 (74%)]] --> [[0 (45%)]] --> Socre: 0.5512434542179108

[[[[Adv]]]]: static int vdpau_mpeg_start_frame(AVCodecContext *[[avctx]], const uint8_t *buffer, uint32_t size) { MpegEncContext * const [[s]] = [[avctx]]->priv_data; Picture *[[pic]] = [[s]]->current_picture_ptr; struct vdpau_picture_context *pic_ctx = [[pic]]->hwaccel_picture_private; VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg; VdpVideoSurface ref; int i; info->forward_reference = VDP_INVALID_HANDLE; info->backward_reference = VDP_INVALID_HANDLE; switch ([[s]]->pict_type) { case AV_PICTURE_TYPE_B: ref = ff_vdpau_get_surface_id(&[[s]]->next_picture.f); assert(ref != VDP_INVALID_HANDLE); info->backward_reference = ref; case AV_PICTURE_TYPE_P: ref = ff_vdpau_get_surface_id(&[[s]]->last_picture.f); info->forward_reference = ref; } info->slice_count = 0; info->picture_structure = [[s]]->picture_structure; info->picture_coding_type = [[s]]->pict_type; info->intra_dc_precision = [[s]]->intra_dc_precision; info->frame_pred_frame_dct = [[s]]->frame_pred_frame_dct; info->concealment_motion_vectors = [[s]]->concealment_motion_vectors; info->intra_vlc_format = [[s]]->intra_vlc_format; info->alternate_scan = [[s]]->alternate_scan; info->q_scale_type = [[s]]->q_scale_type; info->top_field_first = [[s]]->top_field_first; info->full_pel_forward_vector = [[s]]->full_pel[0]; info->full_pel_backward_vector = [[s]]->full_pel[1]; info->f_code[0][0] = [[s]]->mpeg_f_code[0][0]; info->f_code[0][1] = [[s]]->mpeg_f_code[0][1]; info->f_code[1][0] = [[s]]->mpeg_f_code[1][0]; info->f_code[1][1] = [[s]]->mpeg_f_code[1][1]; for (i = 0; i < 64; ++i) { info->intra_quantizer_matrix[i] = [[s]]->intra_matrix[i]; info->non_intra_quantizer_matrix[i] = [[s]]->inter_matrix[i]; } return ff_vdpau_common_start_frame(pic_ctx, buffer, size); }

[[[[Adv]]]]: static int vdpau_mpeg_start_frame(AVCodecContext *[[scull]], const uint8_t *buffer, uint32_t size) { MpegEncContext * const [[avec]] = [[scull]]->priv_data; Picture *[[pics]] = [[avec]]->current_picture_ptr; struct vdpau_picture_context *pic_ctx = [[pics]]->hwaccel_picture_private; VdpPictureInfoMPEG1Or2 *info = &pic_ctx->info.mpeg; VdpVideoSurface ref; int i; info->forward_reference = VDP_INVALID_HANDLE; info->backward_reference = VDP_INVALID_HANDLE; switch ([[avec]]->pict_type) { case AV_PICTURE_TYPE_B: ref = ff_vdpau_get_surface_id(&[[avec]]->next_picture.f); assert(ref != VDP_INVALID_HANDLE); info->backward_reference = ref; case AV_PICTURE_TYPE_P: ref = ff_vdpau_get_surface_id(&[[avec]]->last_picture.f); info->forward_reference = ref; } info->slice_count = 0; info->picture_structure = [[avec]]->picture_structure; info->picture_coding_type = [[avec]]->pict_type; info->intra_dc_precision = [[avec]]->intra_dc_precision; info->frame_pred_frame_dct = [[avec]]->frame_pred_frame_dct; info->concealment_motion_vectors = [[avec]]->concealment_motion_vectors; info->intra_vlc_format = [[avec]]->intra_vlc_format; info->alternate_scan = [[avec]]->alternate_scan; info->q_scale_type = [[avec]]->q_scale_type; info->top_field_first = [[avec]]->top_field_first; info->full_pel_forward_vector = [[avec]]->full_pel[0]; info->full_pel_backward_vector = [[avec]]->full_pel[1]; info->f_code[0][0] = [[avec]]->mpeg_f_code[0][0]; info->f_code[0][1] = [[avec]]->mpeg_f_code[0][1]; info->f_code[1][0] = [[avec]]->mpeg_f_code[1][0]; info->f_code[1][1] = [[avec]]->mpeg_f_code[1][1]; for (i = 0; i < 64; ++i) { info->intra_quantizer_matrix[i] = [[avec]]->intra_matrix[i]; info->non_intra_quantizer_matrix[i] = [[avec]]->inter_matrix[i]; } return ff_vdpau_common_start_frame(pic_ctx, buffer, size); }
--------------------------------------------- Result 334 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 140 / 52 / 142 / 334:  12%|        | 334/2690 [04:17<30:18,  1.30it/s][Succeeded / Failed / Skipped / Total] 140 / 52 / 142 / 334:  12%|        | 335/2690 [04:18<30:14,  1.30it/s][Succeeded / Failed / Skipped / Total] 141 / 52 / 142 / 335:  12%|        | 335/2690 [04:18<30:14,  1.30it/s][[0 (59%)]] --> [[0 (30%)]] --> Socre: 0.6960980296134949

[[[[Adv]]]]: static int64_t read_ts(char **line, int *duration) { int64_t [[start]], end; if (sscanf(*line, "%"SCNd64",%"SCNd64, &[[start]], &end) == 2) { *line += strcspn(*line, "\"") + 1; *duration = end - [[start]]; return [[start]]; } return AV_NOPTS_VALUE; }

[[[[Adv]]]]: static int64_t read_ts(char **line, int *duration) { int64_t [[initiated]], end; if (sscanf(*line, "%"SCNd64",%"SCNd64, &[[initiated]], &end) == 2) { *line += strcspn(*line, "\"") + 1; *duration = end - [[initiated]]; return [[initiated]]; } return AV_NOPTS_VALUE; }
--------------------------------------------- Result 335 ---------------------------------------------
[[0 (65%)]] --> [[0 (45%)]] --> Socre: 0.5492334961891174

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[dcl]]) { int chr, nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) chr = getch(); else { chr = nextchr; nextchr = ERR; } if (chr == ERR) break; #ifdef KEY_RESIZE if (chr == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[dcl]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[chr]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { chr = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if (chr < CURSES_KEYS) keysym = curses2keysym[chr]; if (keysym == -1) { if (chr < ' ') { keysym = chr + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = chr; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "[[True]]" == "[[True]]"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "[[True]]" == "[[True]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "[[True]]" == "[[True]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "[[True]]" == "[[True]]"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "[[True]]" == "[[True]]"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "[[False]]" != "[[False]]"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "[[False]]" != "[[False]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "[[False]]" != "[[False]]"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "[[False]]" != "[[False]]"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "[[False]]" != "[[False]]"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[chr]; if (keysym == -1) keysym = chr; kbd_put_keysym(keysym); } } }

[[[[Adv]]]]: static void curses_refresh(DisplayChangeListener *[[lds]]) { int chr, nextchr, keysym, keycode, keycode_alt; curses_winch_check(); if (invalidate) { clear(); refresh(); curses_calc_pad(); graphic_hw_invalidate(NULL); invalidate = 0; } graphic_hw_text_update(NULL, screen); nextchr = ERR; while (1) { if (nextchr == ERR) chr = getch(); else { chr = nextchr; nextchr = ERR; } if (chr == ERR) break; #ifdef KEY_RESIZE if (chr == KEY_RESIZE) { clear(); refresh(); curses_calc_pad(); curses_update([[lds]], 0, 0, width, height); continue; } #endif keycode = curses2keycode[chr]; keycode_alt = 0; if (keycode == 1) { nextchr = getch(); if (nextchr != ERR) { chr = nextchr; keycode_alt = ALT; keycode = curses2keycode[nextchr]; nextchr = ERR; if (keycode != -1) { keycode |= ALT; if (keycode >= QEMU_KEY_CONSOLE0 && keycode < QEMU_KEY_CONSOLE0 + 9) { erase(); wnoutrefresh(stdscr); console_select(keycode - QEMU_KEY_CONSOLE0); invalidate = 1; continue; } } } } if (kbd_layout) { keysym = -1; if (chr < CURSES_KEYS) keysym = curses2keysym[chr]; if (keysym == -1) { if (chr < ' ') { keysym = chr + '@'; if (keysym >= 'A' && keysym <= 'Z') keysym += 'a' - 'A'; keysym |= KEYSYM_CNTRL; } else keysym = chr; } keycode = keysym2scancode(kbd_layout, keysym & KEYSYM_MASK); if (keycode == 0) continue; keycode |= (keysym & ~KEYSYM_MASK) >> 16; keycode |= keycode_alt; } if (keycode == -1) continue; if (qemu_console_is_graphic(NULL)) { if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "[[Authentic]]" == "[[Authentic]]"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "[[Authentic]]" == "[[Authentic]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "[[Authentic]]" == "[[Authentic]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "[[Authentic]]" == "[[Authentic]]"); qemu_input_event_send_key_delay(0); } qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "[[Authentic]]" == "[[Authentic]]"); qemu_input_event_send_key_delay(0); qemu_input_event_send_key_number(NULL, keycode & KEY_MASK, "[[Imposter]]" != "[[Imposter]]"); qemu_input_event_send_key_delay(0); if (keycode & ALTGR) { qemu_input_event_send_key_number(NULL, GREY | ALT_CODE, "[[Imposter]]" != "[[Imposter]]"); qemu_input_event_send_key_delay(0); } if (keycode & ALT) { qemu_input_event_send_key_number(NULL, ALT_CODE, "[[Imposter]]" != "[[Imposter]]"); qemu_input_event_send_key_delay(0); } if (keycode & CNTRL) { qemu_input_event_send_key_number(NULL, CNTRL_CODE, "[[Imposter]]" != "[[Imposter]]"); qemu_input_event_send_key_delay(0); } if (keycode & SHIFT) { qemu_input_event_send_key_number(NULL, SHIFT_CODE, "[[Imposter]]" != "[[Imposter]]"); qemu_input_event_send_key_delay(0); } } else { keysym = curses2qemu[chr]; if (keysym == -1) keysym = chr; kbd_put_keysym(keysym); } } }
--------------------------------------------- Result 336 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 141 / 53 / 142 / 336:  12%|        | 336/2690 [04:18<30:09,  1.30it/s][Succeeded / Failed / Skipped / Total] 141 / 53 / 143 / 337:  13%|        | 337/2690 [04:18<30:03,  1.30it/s][Succeeded / Failed / Skipped / Total] 141 / 53 / 143 / 337:  13%|        | 338/2690 [04:18<29:57,  1.31it/s][Succeeded / Failed / Skipped / Total] 141 / 53 / 144 / 338:  13%|        | 338/2690 [04:18<29:57,  1.31it/s][Succeeded / Failed / Skipped / Total] 142 / 53 / 144 / 339:  13%|        | 339/2690 [04:18<29:53,  1.31it/s][[0 (51%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom, Error **errp) { int size; char *path; void *ptr; char name[32]; const VMStateDescription *vmsd; if (!pdev->romfile) return; if (strlen(pdev->romfile) == 0) return; if (!pdev->rom_bar) { int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE); if (DEVICE(pdev)->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga(pdev->romfile); } else { rom_add_option(pdev->romfile, -1); } return; } path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile); if (path == NULL) { path = g_strdup(pdev->romfile); } size = get_image_size(path); if (size < 0) { error_setg(errp, "failed to find romfile \"%s\"", pdev->romfile); g_free(path); return; } else if (size == 0) { error_setg(errp, "romfile \"%s\" is empty", pdev->romfile); g_free(path); return; } size = pow2ceil(size); vmsd = qdev_get_vmsd(DEVICE(pdev)); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT(pdev))); } pdev->has_rom = "True" == "True"; memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort); vmstate_register_ram(&pdev->rom, &pdev->qdev); ptr = memory_region_get_ram_ptr(&pdev->rom); load_image(path, ptr); g_free(path); if (is_default_rom) { pci_patch_ids(pdev, ptr, size); } pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom); }

[[[[Adv]]]]: static void pci_add_option_rom(PCIDevice *pdev, bool is_default_rom, Error **errp) { int size; char *path; void *ptr; char name[32]; const VMStateDescription *vmsd; if (!pdev->romfile) return; if (strlen(pdev->romfile) == 0) return; if (!pdev->rom_bar) { int class = pci_get_word(pdev->config + PCI_CLASS_DEVICE); if (DEVICE(pdev)->hotplugged) { error_setg(errp, "Hot-plugged device without ROM bar" " can't have an option ROM"); return; } if (class == 0x0300) { rom_add_vga(pdev->romfile); } else { rom_add_option(pdev->romfile, -1); } return; } path = qemu_find_file(QEMU_FILE_TYPE_BIOS, pdev->romfile); if (path == NULL) { path = g_strdup(pdev->romfile); } size = get_image_size(path); if (size < 0) { error_setg(errp, "failed to find romfile \"%s\"", pdev->romfile); g_free(path); return; } else if (size == 0) { error_setg(errp, "romfile \"%s\" is empty", pdev->romfile); g_free(path); return; } size = pow2ceil(size); vmsd = qdev_get_vmsd(DEVICE(pdev)); if (vmsd) { snprintf(name, sizeof(name), "%s.rom", vmsd->name); } else { snprintf(name, sizeof(name), "%s.rom", object_get_typename(OBJECT(pdev))); } pdev->has_rom = "True" == "True"; memory_region_init_ram(&pdev->rom, OBJECT(pdev), name, size, &error_abort); vmstate_register_ram(&pdev->rom, &pdev->qdev); ptr = memory_region_get_ram_ptr(&pdev->rom); load_image(path, ptr); g_free(path); if (is_default_rom) { pci_patch_ids(pdev, ptr, size); } pci_register_bar(pdev, PCI_ROM_SLOT, 0, &pdev->rom); }
--------------------------------------------- Result 337 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mov_write_uuidprof_tag(AVIOContext *pb, AVFormatContext *s) { AVStream *video_st = s->streams[0]; AVCodecParameters *video_par = s->streams[0]->codecpar; AVCodecParameters *audio_par = s->streams[1]->codecpar; int audio_rate = audio_par->sample_rate; int frame_rate = ((video_st->time_base.den) * (0x10000)) / (video_st->time_base.num); int audio_kbitrate = audio_par->bit_rate / 1000; int video_kbitrate = FFMIN(video_par->bit_rate / 1000, 800 - audio_kbitrate); avio_wb32(pb, 0x94); ffio_wfourcc(pb, "uuid"); ffio_wfourcc(pb, "PROF"); avio_wb32(pb, 0x21d24fce); avio_wb32(pb, 0xbb88695c); avio_wb32(pb, 0xfac9c740); avio_wb32(pb, 0x0); avio_wb32(pb, 0x3); avio_wb32(pb, 0x14); ffio_wfourcc(pb, "FPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2c); ffio_wfourcc(pb, "APRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x2); ffio_wfourcc(pb, "mp4a"); avio_wb32(pb, 0x20f); avio_wb32(pb, 0x0); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_kbitrate); avio_wb32(pb, audio_rate); avio_wb32(pb, audio_par->channels); avio_wb32(pb, 0x34); ffio_wfourcc(pb, "VPRF"); avio_wb32(pb, 0x0); avio_wb32(pb, 0x1); if (video_par->codec_id == AV_CODEC_ID_H264) { ffio_wfourcc(pb, "avc1"); avio_wb16(pb, 0x014D); avio_wb16(pb, 0x0015); } else { ffio_wfourcc(pb, "mp4v"); avio_wb16(pb, 0x0000); avio_wb16(pb, 0x0103); } avio_wb32(pb, 0x0); avio_wb32(pb, video_kbitrate); avio_wb32(pb, video_kbitrate); avio_wb32(pb, frame_rate); avio_wb32(pb, frame_rate); avio_wb16(pb, video_par->width); avio_wb16(pb, video_par->height); avio_wb32(pb, 0x010001); }
--------------------------------------------- Result 338 ---------------------------------------------
[[0 (40%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static char *spapr_phb_vfio_get_loc_code(sPAPRPHBState *sphb, PCIDevice *pdev) { char *path = NULL, *buf = NULL, *host = NULL; host = object_property_get_str(OBJECT(pdev), "host", NULL); if (!host) { goto err_out; } path = g_strdup_printf("/sys/bus/pci/devices/%s/devspec", host); g_free(host); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } g_free(path); path = g_strdup_printf("/proc/device-tree%s/ibm,loc-code", buf); g_free(buf); if (!path || !g_file_get_contents(path, &buf, NULL, NULL)) { goto err_out; } return buf; err_out: g_free(path); return NULL; }
--------------------------------------------- Result 339 ---------------------------------------------
[[0 (60%)]] --> [[0 (49%)]] --> Socre: 0.5100707411766052

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int [[chrDstW]], int dstFormat) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if (dstFormat == PIX_FMT_NV12) for (i=0; i<[[chrDstW]]; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<[[chrDstW]]; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }

[[[[Adv]]]]: static inline void yuv2nv12XinC(int16_t *lumFilter, int16_t **lumSrc, int lumFilterSize, int16_t *chrFilter, int16_t **chrSrc, int chrFilterSize, uint8_t *dest, uint8_t *uDest, int dstW, int [[onl]], int dstFormat) { int i; for (i=0; i<dstW; i++) { int val=1<<18; int j; for (j=0; j<lumFilterSize; j++) val += lumSrc[j][i] * lumFilter[j]; dest[i]= av_clip_uint8(val>>19); } if (!uDest) return; if (dstFormat == PIX_FMT_NV12) for (i=0; i<[[onl]]; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(u>>19); uDest[2*i+1]= av_clip_uint8(v>>19); } else for (i=0; i<[[onl]]; i++) { int u=1<<18; int v=1<<18; int j; for (j=0; j<chrFilterSize; j++) { u += chrSrc[j][i] * chrFilter[j]; v += chrSrc[j][i + 2048] * chrFilter[j]; } uDest[2*i]= av_clip_uint8(v>>19); uDest[2*i+1]= av_clip_uint8(u>>19); } }
--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 53 / 145 / 340:  13%|        | 340/2690 [04:18<29:47,  1.31it/s][Succeeded / Failed / Skipped / Total] 142 / 53 / 145 / 340:  13%|        | 341/2690 [04:18<29:41,  1.32it/s][Succeeded / Failed / Skipped / Total] 142 / 53 / 146 / 341:  13%|        | 341/2690 [04:18<29:41,  1.32it/s][Succeeded / Failed / Skipped / Total] 143 / 53 / 146 / 342:  13%|        | 342/2690 [04:18<29:37,  1.32it/s][Succeeded / Failed / Skipped / Total] 143 / 53 / 147 / 343:  13%|        | 343/2690 [04:18<29:31,  1.33it/s][Succeeded / Failed / Skipped / Total] 143 / 53 / 147 / 343:  13%|        | 344/2690 [04:19<29:26,  1.33it/s][Succeeded / Failed / Skipped / Total] 144 / 53 / 147 / 344:  13%|        | 344/2690 [04:19<29:26,  1.33it/s][Succeeded / Failed / Skipped / Total] 144 / 53 / 148 / 345:  13%|        | 345/2690 [04:19<29:21,  1.33it/s][[0 (27%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void nvme_process_db(NvmeCtrl *n, hwaddr addr, int val) { uint32_t qid; if (addr & ((1 << 2) - 1)) { return; } if (((addr - 0x1000) >> 2) & 1) { uint16_t new_head = val & 0xffff; int start_sqs; NvmeCQueue *cq; qid = (addr - (0x1000 + (1 << 2))) >> 3; if (nvme_check_cqid(n, qid)) { return; } cq = n->cq[qid]; if (new_head >= cq->size) { return; } start_sqs = nvme_cq_full(cq) ? 1 : 0; cq->head = new_head; if (start_sqs) { NvmeSQueue *sq; QTAILQ_FOREACH(sq, &cq->sq_list, entry) { timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } timer_mod(cq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } if (cq->tail != cq->head) { nvme_isr_notify(n, cq); } } else { uint16_t new_tail = val & 0xffff; NvmeSQueue *sq; qid = (addr - 0x1000) >> 3; if (nvme_check_sqid(n, qid)) { return; } sq = n->sq[qid]; if (new_tail >= sq->size) { return; } sq->tail = new_tail; timer_mod(sq->timer, qemu_clock_get_ns(QEMU_CLOCK_VIRTUAL) + 500); } }
--------------------------------------------- Result 341 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static av_cold void build_modpred(Indeo3DecodeContext *s) { int i, j; s->ModPred = av_malloc(8 * 128); for (i=0; i < 128; ++i) { s->ModPred[i+0*128] = i > 126 ? 254 : 2*(i + 1 - ((i + 1) % 2)); s->ModPred[i+1*128] = i == 7 ? 20 : i == 119 || i == 120 ? 236 : 2*(i + 2 - ((i + 1) % 3)); s->ModPred[i+2*128] = i > 125 ? 248 : 2*(i + 2 - ((i + 2) % 4)); s->ModPred[i+3*128] = 2*(i + 1 - ((i - 3) % 5)); s->ModPred[i+4*128] = i == 8 ? 20 : 2*(i + 1 - ((i - 3) % 6)); s->ModPred[i+5*128] = 2*(i + 4 - ((i + 3) % 7)); s->ModPred[i+6*128] = i > 123 ? 240 : 2*(i + 4 - ((i + 4) % 8)); s->ModPred[i+7*128] = 2*(i + 5 - ((i + 4) % 9)); } s->corrector_type = av_malloc(24 * 256); for (i=0; i < 24; ++i) { for (j=0; j < 256; ++j) { s->corrector_type[i*256+j] = j < corrector_type_0[i] ? 1 : j < 248 || (i == 16 && j == 248) ? 0 : corrector_type_2[j - 248]; } } }
--------------------------------------------- Result 342 ---------------------------------------------
[[0 (92%)]] --> [[0 (49%)]] --> Socre: 0.5116923451423645

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *[[s]], int [[rlow]], int [[rhigh]], TCGv_i64 [[val]]) { TCGv [[tmp]]; [[tmp]] = new_tmp(); tcg_gen_trunc_i64_i32([[tmp]], [[val]]); store_reg([[s]], [[rlow]], [[tmp]]); [[tmp]] = new_tmp(); tcg_gen_shri_i64([[val]], [[val]], 32); tcg_gen_trunc_i64_i32([[tmp]], [[val]]); store_reg([[s]], [[rhigh]], [[tmp]]); }

[[[[Adv]]]]: static void gen_storeq_reg(DisasContext *[[und]], int [[oakley]], int [[yorkie]], TCGv_i64 [[autumn]]) { TCGv [[jilting]]; [[jilting]] = new_tmp(); tcg_gen_trunc_i64_i32([[jilting]], [[autumn]]); store_reg([[und]], [[oakley]], [[jilting]]); [[jilting]] = new_tmp(); tcg_gen_shri_i64([[autumn]], [[autumn]], 32); tcg_gen_trunc_i64_i32([[jilting]], [[autumn]]); store_reg([[und]], [[yorkie]], [[jilting]]); }
--------------------------------------------- Result 343 ---------------------------------------------
[[0 (38%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int ccid_bulk_in_copy_to_guest(USBCCIDState *s, uint8_t *data, int len) { int ret = 0; assert(len > 0); ccid_bulk_in_get(s); if (s->current_bulk_in != NULL) { ret = MIN(s->current_bulk_in->len - s->current_bulk_in->pos, len); memcpy(data, s->current_bulk_in->data + s->current_bulk_in->pos, ret); s->current_bulk_in->pos += ret; if (s->current_bulk_in->pos == s->current_bulk_in->len) { ccid_bulk_in_release(s); } } else { ret = USB_RET_NAK; } if (ret > 0) { DPRINTF(s, D_MORE_INFO, "%s: %d/%d req/act to guest (BULK_IN)\n", __func__, len, ret); } if (ret != USB_RET_NAK && ret < len) { DPRINTF(s, 1, "%s: returning short (EREMOTEIO) %d < %d\n", __func__, ret, len); } return ret; }
--------------------------------------------- Result 344 ---------------------------------------------
[[0 (56%)]] --> [[0 (46%)]] --> Socre: 0.5422319769859314

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *[[s]], int ich, int ilms, int16_t input, int16_t pred) { int16_t icoef; int recent = [[s]]->cdlms[ich][ilms].recent; int16_t range = 1 << ([[s]]->bits_per_sample - 1); int bps = [[s]]->bits_per_sample > 16 ? 4 : 2; if (input > pred) { for (icoef = 0; icoef < [[s]]->cdlms[ich][ilms].order; icoef++) [[s]]->cdlms[ich][ilms].coefs[icoef] += [[s]]->cdlms[ich][ilms].lms_updates[icoef + recent]; } else { for (icoef = 0; icoef < [[s]]->cdlms[ich][ilms].order; icoef++) [[s]]->cdlms[ich][ilms].coefs[icoef] -= [[s]]->cdlms[ich][ilms].lms_updates[icoef]; } [[s]]->cdlms[ich][ilms].recent--; [[s]]->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1); if (input > pred) [[s]]->cdlms[ich][ilms].lms_updates[recent] = [[s]]->update_speed[ich]; else if (input < pred) [[s]]->cdlms[ich][ilms].lms_updates[recent] = -[[s]]->update_speed[ich]; [[s]]->cdlms[ich][ilms].lms_updates[recent + [[s]]->cdlms[ich][ilms].order >> 4] >>= 2; [[s]]->cdlms[ich][ilms].lms_updates[recent + [[s]]->cdlms[ich][ilms].order >> 3] >>= 1; if ([[s]]->cdlms[ich][ilms].recent == 0) { memcpy([[s]]->cdlms[ich][ilms].lms_prevvalues + [[s]]->cdlms[ich][ilms].order, [[s]]->cdlms[ich][ilms].lms_prevvalues, bps * [[s]]->cdlms[ich][ilms].order); memcpy([[s]]->cdlms[ich][ilms].lms_updates + [[s]]->cdlms[ich][ilms].order, [[s]]->cdlms[ich][ilms].lms_updates, bps * [[s]]->cdlms[ich][ilms].order); [[s]]->cdlms[ich][ilms].recent = [[s]]->cdlms[ich][ilms].order; } }

[[[[Adv]]]]: static void lms_update(WmallDecodeCtx *[[to]], int ich, int ilms, int16_t input, int16_t pred) { int16_t icoef; int recent = [[to]]->cdlms[ich][ilms].recent; int16_t range = 1 << ([[to]]->bits_per_sample - 1); int bps = [[to]]->bits_per_sample > 16 ? 4 : 2; if (input > pred) { for (icoef = 0; icoef < [[to]]->cdlms[ich][ilms].order; icoef++) [[to]]->cdlms[ich][ilms].coefs[icoef] += [[to]]->cdlms[ich][ilms].lms_updates[icoef + recent]; } else { for (icoef = 0; icoef < [[to]]->cdlms[ich][ilms].order; icoef++) [[to]]->cdlms[ich][ilms].coefs[icoef] -= [[to]]->cdlms[ich][ilms].lms_updates[icoef]; } [[to]]->cdlms[ich][ilms].recent--; [[to]]->cdlms[ich][ilms].lms_prevvalues[recent] = av_clip(input, -range, range - 1); if (input > pred) [[to]]->cdlms[ich][ilms].lms_updates[recent] = [[to]]->update_speed[ich]; else if (input < pred) [[to]]->cdlms[ich][ilms].lms_updates[recent] = -[[to]]->update_speed[ich]; [[to]]->cdlms[ich][ilms].lms_updates[recent + [[to]]->cdlms[ich][ilms].order >> 4] >>= 2; [[to]]->cdlms[ich][ilms].lms_updates[recent + [[to]]->cdlms[ich][ilms].order >> 3] >>= 1; if ([[to]]->cdlms[ich][ilms].recent == 0) { memcpy([[to]]->cdlms[ich][ilms].lms_prevvalues + [[to]]->cdlms[ich][ilms].order, [[to]]->cdlms[ich][ilms].lms_prevvalues, bps * [[to]]->cdlms[ich][ilms].order); memcpy([[to]]->cdlms[ich][ilms].lms_updates + [[to]]->cdlms[ich][ilms].order, [[to]]->cdlms[ich][ilms].lms_updates, bps * [[to]]->cdlms[ich][ilms].order); [[to]]->cdlms[ich][ilms].recent = [[to]]->cdlms[ich][ilms].order; } }
--------------------------------------------- Result 345 ---------------------------------------------
[[0 (48%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int create_filter(AVFilterContext **filt_ctx, AVFilterGraph *ctx, int index, const char *filt_name, const char *args, AVClass *log_ctx) { AVFilter *filt; char inst_name[30]; char tmp_args[256]; int ret; snprintf(inst_name, sizeof(inst_name), "Parsed filter %d %s", index, filt_name); filt = avfilter_get_by_name(filt_name); if (!filt) { av_log(log_ctx, AV_LOG_ERROR, "No such filter: '%s'\n", filt_name); return AVERROR(EINVAL); } ret = avfilter_open(filt_ctx, filt, inst_name); if (!*filt_ctx) { av_log(log_ctx, AV_LOG_ERROR, "Error creating filter '%s'\n", filt_name); return ret; } if ((ret = avfilter_graph_add_filter(ctx, *filt_ctx)) < 0) { avfilter_free(*filt_ctx); return ret; } if (!strcmp(filt_name, "scale") && !strstr(args, "flags")) { snprintf(tmp_args, sizeof(tmp_args), "%s:%s", args, ctx->scale_sws_opts); args = tmp_args; } if ((ret = avfilter_init_filter(*filt_ctx, args, NULL)) < 0) { av_log(log_ctx, AV_LOG_ERROR, "Error initializing filter '%s' with args '%s'\n", filt_name, args); return ret; } return 0; }
[Succeeded / Failed / Skipped / Total] 145 / 53 / 148 / 346:  13%|        | 346/2690 [04:19<29:16,  1.33it/s][Succeeded / Failed / Skipped / Total] 145 / 53 / 148 / 346:  13%|        | 347/2690 [04:19<29:10,  1.34it/s][Succeeded / Failed / Skipped / Total] 145 / 53 / 149 / 347:  13%|        | 347/2690 [04:19<29:10,  1.34it/s]--------------------------------------------- Result 346 ---------------------------------------------
[[0 (55%)]] --> [[0 (40%)]] --> Socre: 0.5953734815120697

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *[[s]]) { [[s]]->mclms_order = (get_bits(&[[s]]->gb, 4) + 1) * 2; [[s]]->mclms_scaling = get_bits(&[[s]]->gb, 4); if(get_bits1(&[[s]]->gb)) { int i; int send_coef_bits; int cbits = av_log2([[s]]->mclms_scaling + 1); assert(cbits == my_log2([[s]]->mclms_scaling + 1)); if(1 << cbits < [[s]]->mclms_scaling + 1) cbits++; send_coef_bits = (cbits ? get_bits(&[[s]]->gb, cbits) : 0) + 2; for(i = 0; i < [[s]]->mclms_order * [[s]]->num_channels * [[s]]->num_channels; i++) { [[s]]->mclms_coeffs[i] = get_bits(&[[s]]->gb, send_coef_bits); } for(i = 0; i < [[s]]->num_channels; i++) { int c; for(c = 0; c < i; c++) { [[s]]->mclms_coeffs_cur[i * [[s]]->num_channels + c] = get_bits(&[[s]]->gb, send_coef_bits); } } } }

[[[[Adv]]]]: static void decode_mclms(WmallDecodeCtx *[[avec]]) { [[avec]]->mclms_order = (get_bits(&[[avec]]->gb, 4) + 1) * 2; [[avec]]->mclms_scaling = get_bits(&[[avec]]->gb, 4); if(get_bits1(&[[avec]]->gb)) { int i; int send_coef_bits; int cbits = av_log2([[avec]]->mclms_scaling + 1); assert(cbits == my_log2([[avec]]->mclms_scaling + 1)); if(1 << cbits < [[avec]]->mclms_scaling + 1) cbits++; send_coef_bits = (cbits ? get_bits(&[[avec]]->gb, cbits) : 0) + 2; for(i = 0; i < [[avec]]->mclms_order * [[avec]]->num_channels * [[avec]]->num_channels; i++) { [[avec]]->mclms_coeffs[i] = get_bits(&[[avec]]->gb, send_coef_bits); } for(i = 0; i < [[avec]]->num_channels; i++) { int c; for(c = 0; c < i; c++) { [[avec]]->mclms_coeffs_cur[i * [[avec]]->num_channels + c] = get_bits(&[[avec]]->gb, send_coef_bits); } } } }
--------------------------------------------- Result 347 ---------------------------------------------
[[0 (28%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(ram_addr_t ram_size, const char *boot_device, const char *kernel_filename, const char *kernel_cmdline, const char *initrd_filename, const char *cpu_model) { PowerPCCPU *cpu; CPUPPCState *env; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); target_phys_addr_t rma_alloc_size, rma_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; long pteg_shift = 17; char *filename; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { rma_size = rma_alloc_size; } else { rma_size = ram_size; } rtas_limit = MIN(rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; cpu_ppc_tb_init(env, TIMEBASE_FREQ); qemu_register_reset(spapr_cpu_reset, cpu); env->hreset_vector = 0x60; env->hreset_excp_prefix = 0; env->gpr[3] = env->cpu_index; } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } spapr->htab_size = 1ULL << (pteg_shift + 7); spapr->htab = qemu_memalign(spapr->htab_size, spapr->htab_size); for (env = first_cpu; env != NULL; env = env->next_cpu) { env->external_htab = spapr->htab; env->htab_base = -1; env->htab_mask = spapr->htab_size - 1; env->spr[SPR_SDR1] = (unsigned long)spapr->htab | ((pteg_shift + 7) - 18); env->spr[SPR_HIOR] = 0; if (kvm_enabled()) { kvmppc_set_papr(env); } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr->icp = xics_system_init(XICS_IRQS); spapr->next_irq = 16; spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_phb(spapr, "pci", SPAPR_PCI_BUID, SPAPR_PCI_MEM_WIN_ADDR, SPAPR_PCI_MEM_WIN_SIZE, SPAPR_PCI_IO_WIN_ADDR); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } fprintf(stderr, "sPAPR memory map:\n"); fprintf(stderr, "RTAS : 0x%08lx..%08lx\n", (unsigned long)spapr->rtas_addr, (unsigned long)(spapr->rtas_addr + spapr->rtas_size - 1)); fprintf(stderr, "FDT : 0x%08lx..%08lx\n", (unsigned long)spapr->fdt_addr, (unsigned long)(spapr->fdt_addr + FDT_MAX_SIZE - 1)); if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } fprintf(stderr, "Kernel : 0x%08x..%08lx\n", KERNEL_LOAD_ADDR, KERNEL_LOAD_ADDR + kernel_size - 1); if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } fprintf(stderr, "Ramdisk : 0x%08lx..%08lx\n", (long)initrd_base, (long)(initrd_base + initrd_size - 1)); } else { initrd_base = 0; initrd_size = 0; } } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, FW_FILE_NAME); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); fprintf(stderr, "Firmware load : 0x%08x..%08lx\n", 0, fw_size); fprintf(stderr, "Firmware runtime : 0x%08lx..%08lx\n", load_limit, (unsigned long)spapr->fdt_addr); spapr->entry_point = 0x100; for (env = first_cpu; env != NULL; env = env->next_cpu) { env->halted = 1; } spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, rma_size, initrd_base, initrd_size, kernel_size, boot_device, kernel_cmdline, pteg_shift + 7); assert(spapr->fdt_skel != NULL); qemu_register_reset(spapr_reset, spapr); }
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 53 / 149 / 348:  13%|        | 348/2690 [04:19<29:06,  1.34it/s][Succeeded / Failed / Skipped / Total] 146 / 54 / 149 / 349:  13%|        | 349/2690 [04:28<30:03,  1.30it/s][Succeeded / Failed / Skipped / Total] 146 / 54 / 149 / 349:  13%|        | 350/2690 [05:32<37:04,  1.05it/s][Succeeded / Failed / Skipped / Total] 146 / 55 / 149 / 350:  13%|        | 350/2690 [05:32<37:04,  1.05it/s][Succeeded / Failed / Skipped / Total] 146 / 55 / 149 / 350:  13%|        | 351/2690 [05:35<37:14,  1.05it/s][[0 (40%)]] --> [[0 (52%)]] --> Socre: 0.5205896496772766

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[avctx]]) { SonicContext *s = [[avctx]]->priv_data; PutBitContext pb; int i, version = 0; if ([[avctx]]->channels > MAX_CHANNELS) { av_log([[avctx]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[avctx]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[avctx]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[avctx]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[avctx]]->channels; s->samplerate = [[avctx]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[avctx]]->extradata = av_mallocz(16); if (![[avctx]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[avctx]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[avctx]]->extradata_size = put_bits_count(&pb)/8; av_log([[avctx]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[avctx]]->frame_size = s->block_align*s->downsampling; return 0; }

[[[[Adv]]]]: static av_cold int sonic_encode_init(AVCodecContext *[[pheromone]]) { SonicContext *s = [[pheromone]]->priv_data; PutBitContext pb; int i, version = 0; if ([[pheromone]]->channels > MAX_CHANNELS) { av_log([[pheromone]], AV_LOG_ERROR, "Only mono and stereo streams are supported by now\n"); return AVERROR(EINVAL); } if ([[pheromone]]->channels == 2) s->decorrelation = MID_SIDE; else s->decorrelation = 3; if ([[pheromone]]->codec->id == AV_CODEC_ID_SONIC_LS) { s->lossless = 1; s->num_taps = 32; s->downsampling = 1; s->quantization = 0.0; } else { s->num_taps = 128; s->downsampling = 2; s->quantization = 1.0; } if ((s->num_taps < 32) || (s->num_taps > 1024) || ((s->num_taps>>5)<<5 != s->num_taps)) { av_log([[pheromone]], AV_LOG_ERROR, "Invalid number of taps\n"); return AVERROR_INVALIDDATA; } s->tap_quant = av_calloc(s->num_taps, sizeof(*s->tap_quant)); for (i = 0; i < s->num_taps; i++) s->tap_quant[i] = ff_sqrt(i+1); s->channels = [[pheromone]]->channels; s->samplerate = [[pheromone]]->sample_rate; s->block_align = 2048LL*s->samplerate/(44100*s->downsampling); s->frame_size = s->channels*s->block_align*s->downsampling; s->tail_size = s->num_taps*s->channels; s->tail = av_calloc(s->tail_size, sizeof(*s->tail)); if (!s->tail) return AVERROR(ENOMEM); s->predictor_k = av_calloc(s->num_taps, sizeof(*s->predictor_k) ); if (!s->predictor_k) return AVERROR(ENOMEM); for (i = 0; i < s->channels; i++) { s->coded_samples[i] = av_calloc(s->block_align, sizeof(**s->coded_samples)); if (!s->coded_samples[i]) return AVERROR(ENOMEM); } s->int_samples = av_calloc(s->frame_size, sizeof(*s->int_samples)); s->window_size = ((2*s->tail_size)+s->frame_size); s->window = av_calloc(s->window_size, sizeof(*s->window)); if (!s->window) return AVERROR(ENOMEM); [[pheromone]]->extradata = av_mallocz(16); if (![[pheromone]]->extradata) return AVERROR(ENOMEM); init_put_bits(&pb, [[pheromone]]->extradata, 16*8); put_bits(&pb, 2, version); if (version == 1) { put_bits(&pb, 2, s->channels); put_bits(&pb, 4, code_samplerate(s->samplerate)); } put_bits(&pb, 1, s->lossless); if (!s->lossless) put_bits(&pb, 3, SAMPLE_SHIFT); put_bits(&pb, 2, s->decorrelation); put_bits(&pb, 2, s->downsampling); put_bits(&pb, 5, (s->num_taps >> 5)-1); put_bits(&pb, 1, 0); flush_put_bits(&pb); [[pheromone]]->extradata_size = put_bits_count(&pb)/8; av_log([[pheromone]], AV_LOG_INFO, "Sonic: ver: %d ls: %d dr: %d taps: %d block: %d frame: %d downsamp: %d\n", version, s->lossless, s->decorrelation, s->num_taps, s->block_align, s->frame_size, s->downsampling); [[pheromone]]->frame_size = s->block_align*s->downsampling; return 0; }
--------------------------------------------- Result 349 ---------------------------------------------
[[0 (67%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static void raven_class_init(ObjectClass *klass, void *data) { PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); DeviceClass *dc = DEVICE_CLASS(klass); k->init = raven_init; k->vendor_id = PCI_VENDOR_ID_MOTOROLA; k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; k->revision = 0x00; k->class_id = PCI_CLASS_BRIDGE_HOST; dc->desc = "PReP Host Bridge - Motorola Raven"; dc->vmsd = &vmstate_raven; dc->no_user = 1; }

[[[[Adv]]]]: static void raven_class_init(ObjectClass *klass, void *data) { PCIDeviceClass *k = PCI_DEVICE_CLASS(klass); DeviceClass *dc = DEVICE_CLASS(klass); k->init = raven_init; k->vendor_id = PCI_VENDOR_ID_MOTOROLA; k->device_id = PCI_DEVICE_ID_MOTOROLA_RAVEN; k->revision = 0x00; k->class_id = PCI_CLASS_BRIDGE_HOST; dc->desc = "PReP Host Bridge - Motorola Raven"; dc->vmsd = &vmstate_raven; dc->no_user = 1; }
--------------------------------------------- Result 350 ---------------------------------------------
[[0 (16%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as) { int bits = 8, sign = 0, shift = 0; switch (as->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: bits = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: bits = 32; shift = 2; break; } info->freq = as->freq; info->bits = bits; info->sign = sign; info->nchannels = as->nchannels; info->shift = (as->nchannels == 2) + shift; info->align = (1 << info->shift) - 1; info->bytes_per_second = info->freq << info->shift; info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS); }

[[[[Adv]]]]: void audio_pcm_init_info (struct audio_pcm_info *info, audsettings_t *as) { int bits = 8, sign = 0, shift = 0; switch (as->fmt) { case AUD_FMT_S8: sign = 1; case AUD_FMT_U8: break; case AUD_FMT_S16: sign = 1; case AUD_FMT_U16: bits = 16; shift = 1; break; case AUD_FMT_S32: sign = 1; case AUD_FMT_U32: bits = 32; shift = 2; break; } info->freq = as->freq; info->bits = bits; info->sign = sign; info->nchannels = as->nchannels; info->shift = (as->nchannels == 2) + shift; info->align = (1 << info->shift) - 1; info->bytes_per_second = info->freq << info->shift; info->swap_endianness = (as->endianness != AUDIO_HOST_ENDIANNESS); }
--------------------------------------------- Result 351 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 55 / 149 / 351:  13%|        | 351/2690 [05:35<37:14,  1.05it/s][Succeeded / Failed / Skipped / Total] 147 / 55 / 149 / 351:  13%|        | 352/2690 [05:35<37:10,  1.05it/s][Succeeded / Failed / Skipped / Total] 148 / 55 / 149 / 352:  13%|        | 352/2690 [05:35<37:10,  1.05it/s][Succeeded / Failed / Skipped / Total] 148 / 55 / 149 / 352:  13%|        | 353/2690 [05:45<38:09,  1.02it/s][Succeeded / Failed / Skipped / Total] 148 / 56 / 149 / 353:  13%|        | 353/2690 [05:45<38:09,  1.02it/s][Succeeded / Failed / Skipped / Total] 148 / 56 / 149 / 353:  13%|        | 354/2690 [05:46<38:05,  1.02it/s][[0 (42%)]] --> [[0 (50%)]] --> Socre: 0.5036792755126953

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *[[job]]) { AioContext *ctx; BlockJobTxn *[[txn]] = [[job]]->txn; BlockJob *[[other_job]], *next; if ([[txn]]->aborting) { return; } [[txn]]->aborting = "True" == "True"; QLIST_FOREACH([[other_job]], &[[txn]]->jobs, txn_list) { ctx = blk_get_aio_context([[other_job]]->blk); aio_context_acquire(ctx); } QLIST_FOREACH([[other_job]], &[[txn]]->jobs, txn_list) { if ([[other_job]] == [[job]] || [[other_job]]->completed) { if ([[other_job]] != [[job]]) { block_job_cancel_async([[other_job]]); } continue; } block_job_cancel_sync([[other_job]]); assert([[other_job]]->completed); } QLIST_FOREACH_SAFE([[other_job]], &[[txn]]->jobs, txn_list, next) { ctx = blk_get_aio_context([[other_job]]->blk); block_job_completed_single([[other_job]]); aio_context_release(ctx); } }

[[[[Adv]]]]: static void block_job_completed_txn_abort(BlockJob *[[employing]]) { AioContext *ctx; BlockJobTxn *[[quivering]] = [[employing]]->txn; BlockJob *[[giron]], *next; if ([[quivering]]->aborting) { return; } [[quivering]]->aborting = "True" == "True"; QLIST_FOREACH([[giron]], &[[quivering]]->jobs, txn_list) { ctx = blk_get_aio_context([[giron]]->blk); aio_context_acquire(ctx); } QLIST_FOREACH([[giron]], &[[quivering]]->jobs, txn_list) { if ([[giron]] == [[employing]] || [[giron]]->completed) { if ([[giron]] != [[employing]]) { block_job_cancel_async([[giron]]); } continue; } block_job_cancel_sync([[giron]]); assert([[giron]]->completed); } QLIST_FOREACH_SAFE([[giron]], &[[quivering]]->jobs, txn_list, next) { ctx = blk_get_aio_context([[giron]]->blk); block_job_completed_single([[giron]]); aio_context_release(ctx); } }
--------------------------------------------- Result 352 ---------------------------------------------
[[0 (18%)]] --> [[0 (50%)]] --> Socre: 0.5023717880249023

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t [[size]]) { memory_region_init_io(mr, &isa_mmio_ops, NULL, "isa-mmio", [[size]]); }

[[[[Adv]]]]: void isa_mmio_setup(MemoryRegion *mr, target_phys_addr_t [[tonnage]]) { memory_region_init_io(mr, &isa_mmio_ops, NULL, "isa-mmio", [[tonnage]]); }
--------------------------------------------- Result 353 ---------------------------------------------
[[0 (22%)]] --> [[[FAILED]]]

[[[[Adv]]]]: int opt_cpuflags(const char *opt, const char *arg) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption cpuflags_opts[] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = cpuflags_opts, .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }

[[[[Adv]]]]: int opt_cpuflags(const char *opt, const char *arg) { #define CPUFLAG_MMX2 (AV_CPU_FLAG_MMX | AV_CPU_FLAG_MMX2) #define CPUFLAG_3DNOW (AV_CPU_FLAG_3DNOW | AV_CPU_FLAG_MMX) #define CPUFLAG_3DNOWEXT (AV_CPU_FLAG_3DNOWEXT | CPUFLAG_3DNOW) #define CPUFLAG_SSE (AV_CPU_FLAG_SSE | CPUFLAG_MMX2) #define CPUFLAG_SSE2 (AV_CPU_FLAG_SSE2 | CPUFLAG_SSE) #define CPUFLAG_SSE2SLOW (AV_CPU_FLAG_SSE2SLOW | CPUFLAG_SSE2) #define CPUFLAG_SSE3 (AV_CPU_FLAG_SSE3 | CPUFLAG_SSE2) #define CPUFLAG_SSE3SLOW (AV_CPU_FLAG_SSE3SLOW | CPUFLAG_SSE3) #define CPUFLAG_SSSE3 (AV_CPU_FLAG_SSSE3 | CPUFLAG_SSE3) #define CPUFLAG_SSE4 (AV_CPU_FLAG_SSE4 | CPUFLAG_SSSE3) #define CPUFLAG_SSE42 (AV_CPU_FLAG_SSE42 | CPUFLAG_SSE4) #define CPUFLAG_AVX (AV_CPU_FLAG_AVX | CPUFLAG_SSE42) #define CPUFLAG_XOP (AV_CPU_FLAG_XOP | CPUFLAG_AVX) #define CPUFLAG_FMA4 (AV_CPU_FLAG_FMA4 | CPUFLAG_AVX) static const AVOption cpuflags_opts[] = { { "flags" , NULL, 0, AV_OPT_TYPE_FLAGS, { 0 }, INT64_MIN, INT64_MAX, .unit = "flags" }, { "altivec" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ALTIVEC }, .unit = "flags" }, { "mmx" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_MMX }, .unit = "flags" }, { "mmx2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_MMX2 }, .unit = "flags" }, { "sse" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE }, .unit = "flags" }, { "sse2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2 }, .unit = "flags" }, { "sse2slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE2SLOW }, .unit = "flags" }, { "sse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3 }, .unit = "flags" }, { "sse3slow", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE3SLOW }, .unit = "flags" }, { "ssse3" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSSE3 }, .unit = "flags" }, { "atom" , NULL, 0, AV_OPT_TYPE_CONST, { AV_CPU_FLAG_ATOM }, .unit = "flags" }, { "sse4.1" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE4 }, .unit = "flags" }, { "sse4.2" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_SSE42 }, .unit = "flags" }, { "avx" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_AVX }, .unit = "flags" }, { "xop" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_XOP }, .unit = "flags" }, { "fma4" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_FMA4 }, .unit = "flags" }, { "3dnow" , NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOW }, .unit = "flags" }, { "3dnowext", NULL, 0, AV_OPT_TYPE_CONST, { CPUFLAG_3DNOWEXT }, .unit = "flags" }, { NULL }, }; static const AVClass class = { .class_name = "cpuflags", .item_name = av_default_item_name, .option = cpuflags_opts, .version = LIBAVUTIL_VERSION_INT, }; int flags = av_get_cpu_flags(); int ret; const AVClass *pclass = &class; if ((ret = av_opt_eval_flags(&pclass, &cpuflags_opts[0], arg, &flags)) < 0) return ret; av_force_cpu_flags(flags); return 0; }
--------------------------------------------- Result 354 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 149 / 56 / 149 / 354:  13%|        | 354/2690 [05:46<38:05,  1.02it/s]