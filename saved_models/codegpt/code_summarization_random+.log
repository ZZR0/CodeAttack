Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [06:14<104:02:30, 374.93s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [06:14<104:02:31, 374.93s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 2/1000 [06:57<57:49:57, 208.61s/it] [Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [06:57<57:49:58, 208.62s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 3/1000 [07:39<42:27:46, 153.33s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 3/1000 [07:39<42:27:46, 153.33s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 4/1000 [10:45<44:37:19, 161.29s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 4/1000 [10:45<44:37:20, 161.29s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 5/1000 [11:46<39:04:16, 141.36s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   0%|          | 5/1000 [11:46<39:04:16, 141.36s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   1%|          | 6/1000 [12:53<35:36:06, 128.94s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [12:53<35:36:06, 128.94s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [14:25<34:05:17, 123.58s/it]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[tuki]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> LAY MAN FLAT METHOD --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[layman]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 3 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[obsolete]] ( Comparator < ? super T > [[everyone]] ) { ObjectHelper . requireNonNull ( [[everyone]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[everyone]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[scamper]] ( int [[embarassing]] ) { return new UnicastProcessor < T > ( [[embarassing]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Resets this scheduler. --> zuzu --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[zuzu]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 6 ---------------------------------------------
Retries the specified number of times. --> Optimized version of CheckReturnValue --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[optimal]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [14:25<34:05:17, 123.58s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [17:58<37:09:10, 134.83s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 8/1000 [17:58<37:09:11, 134.83s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 9/1000 [18:56<34:45:54, 126.29s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [18:56<34:45:54, 126.29s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [20:04<33:08:05, 120.49s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 10/1000 [20:04<33:08:05, 120.49s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 11/1000 [20:13<30:19:04, 110.36s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 11/1000 [20:13<30:19:04, 110.36s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 12/1000 [21:33<29:34:40, 107.77s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|          | 12/1000 [21:33<29:34:40, 107.77s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|▏         | 13/1000 [21:50<27:38:29, 100.82s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 13/1000 [21:50<27:38:29, 100.82s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 14/1000 [25:08<29:30:54, 107.76s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   1%|▏         | 14/1000 [25:08<29:30:54, 107.76s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   2%|▏         | 15/1000 [25:37<28:02:48, 102.51s/it]Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[impaled]] ( int capacityHint , Runnable [[laundry]] ) { ObjectHelper . requireNonNull ( [[laundry]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[laundry]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[macadamia]] ( CompletableSource [[unrealistic]] ) { ObjectHelper . requireNonNull ( [[unrealistic]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[unrealistic]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[turnoff]] > [[turnoff]] requireNonNull ( [[turnoff]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 10 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[gradient]] ( SingleSource < T > [[coach]] ) { ObjectHelper . requireNonNull ( [[coach]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[coach]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a cast function from the given class. --> Escaping functions --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[escaping]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 13 ---------------------------------------------
Returns an identity function. --> Lifecycle methods --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[appetizers]] > Function < [[appetizers]] , [[appetizers]] > [[slams]] ( ) { return ( Function < [[appetizers]] , [[appetizers]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 14 ---------------------------------------------
Creates a new non-blocking producer. --> Create a new non-blocking non-blocking subject@param < T> the type parameter@param < R> the type parameter@return the non-blocking subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[morena]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 8 / 0 / 15:   2%|▏         | 15/1000 [25:37<28:02:48, 102.51s/it][Succeeded / Failed / Skipped / Total] 7 / 8 / 0 / 15:   2%|▏         | 16/1000 [26:46<27:27:06, 100.43s/it][Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 16/1000 [26:46<27:27:06, 100.43s/it][Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 17/1000 [27:38<26:38:13, 97.55s/it] [Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 17/1000 [27:38<26:38:13, 97.55s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 18/1000 [28:00<25:28:15, 93.38s/it][Succeeded / Failed / Skipped / Total] 9 / 9 / 0 / 18:   2%|▏         | 18/1000 [28:00<25:28:15, 93.38s/it][Succeeded / Failed / Skipped / Total] 9 / 9 / 0 / 18:   2%|▏         | 19/1000 [33:30<28:49:43, 105.79s/it][Succeeded / Failed / Skipped / Total] 9 / 10 / 0 / 19:   2%|▏         | 19/1000 [33:30<28:49:43, 105.79s/it][Succeeded / Failed / Skipped / Total] 9 / 10 / 0 / 19:   2%|▏         | 20/1000 [34:16<27:59:33, 102.83s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 20/1000 [34:16<27:59:33, 102.83s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 21/1000 [36:31<28:22:30, 104.34s/it]Creates a new subject with the specified capacity. --> Create a non-supervised subject@param capacityHint@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[mamoru]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[Unsupervised]]" == "[[Unsupervised]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 16 ---------------------------------------------
Blocking get error. --> Yoshiro yoshiro --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[yoshiko]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 17 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > [[co]] , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = [[co]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[pedrosa]] ( final ConnectableObservable < T > [[fireball]] , final Scheduler [[endeavour]] ) { final Observable < T > [[boules]] = [[fireball]] . observeOn ( [[endeavour]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[fireball]] , [[boules]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> Create a non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[fairies]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[yorkshire]] ( T [[sexiness]] ) { return new JustValue < Object , T > ( [[sexiness]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 20 ---------------------------------------------
Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 21/1000 [36:31<28:22:30, 104.34s/it][Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 22/1000 [38:07<28:14:34, 103.96s/it][Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 22/1000 [38:07<28:14:34, 103.96s/it][Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 23/1000 [39:33<28:00:07, 103.18s/it][Succeeded / Failed / Skipped / Total] 11 / 12 / 0 / 23:   2%|▏         | 23/1000 [39:33<28:00:07, 103.18s/it][Succeeded / Failed / Skipped / Total] 11 / 12 / 0 / 23:   2%|▏         | 24/1000 [40:13<27:16:01, 100.58s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▏         | 24/1000 [40:13<27:16:01, 100.58s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▎         | 25/1000 [40:34<26:22:44, 97.40s/it] [Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   2%|▎         | 25/1000 [40:34<26:22:44, 97.40s/it][Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   3%|▎         | 26/1000 [40:45<25:27:07, 94.07s/it][Succeeded / Failed / Skipped / Total] 13 / 13 / 0 / 26:   3%|▎         | 26/1000 [40:45<25:27:07, 94.07s/it][Succeeded / Failed / Skipped / Total] 13 / 13 / 0 / 26:   3%|▎         | 27/1000 [43:27<26:05:51, 96.56s/it][Succeeded / Failed / Skipped / Total] 14 / 13 / 0 / 27:   3%|▎         | 27/1000 [43:27<26:05:51, 96.56s/it][Succeeded / Failed / Skipped / Total] 14 / 13 / 0 / 27:   3%|▎         | 28/1000 [45:18<26:12:50, 97.09s/it][Succeeded / Failed / Skipped / Total] 14 / 14 / 0 / 28:   3%|▎         | 28/1000 [45:18<26:12:50, 97.09s/it][Succeeded / Failed / Skipped / Total] 14 / 14 / 0 / 28:   3%|▎         | 29/1000 [52:52<29:30:33, 109.41s/it]Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> Z-Sha-Sha-Sha-Sha-Sha-Sh --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[ziya]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Method]]" == "[[Method]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 22 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[burnable]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 23 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> Request a bengt subscription --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[stubborn]] , int [[bengt]] ) { [[stubborn]] . request ( [[bengt]] < 0 ? Long . MAX_VALUE : [[bengt]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[rashid]] , U > Function < [[rashid]] , U > [[visionary]] ( U [[simultaneous]] ) { return new JustValue < [[rashid]] , U > ( [[simultaneous]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 25 ---------------------------------------------
Completes this stream. --> Spaghetti --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[spaghetti]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 26 ---------------------------------------------
Gets the error associated with this notification. --> burnable --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[burnable]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Returns the value associated with this notification. --> SCHRADER --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[schrader]] ( ) { Object [[breached]] = value ; if ( [[breached]] != null && ! NotificationLite . isError ( [[breached]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 28 ---------------------------------------------
Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[vendetta]] ( int [[newswoman]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[newswoman]] , onTerminate , "[[Greenpeace]]" == "[[Greenpeace]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 14 / 0 / 29:   3%|▎         | 29/1000 [52:52<29:30:33, 109.41s/it][Succeeded / Failed / Skipped / Total] 15 / 14 / 0 / 29:   3%|▎         | 30/1000 [53:40<28:55:28, 107.35s/it][Succeeded / Failed / Skipped / Total] 16 / 14 / 0 / 30:   3%|▎         | 30/1000 [53:40<28:55:28, 107.35s/it][Succeeded / Failed / Skipped / Total] 16 / 14 / 0 / 30:   3%|▎         | 31/1000 [57:12<29:48:18, 110.73s/it][Succeeded / Failed / Skipped / Total] 16 / 15 / 0 / 31:   3%|▎         | 31/1000 [57:12<29:48:18, 110.73s/it][Succeeded / Failed / Skipped / Total] 16 / 15 / 0 / 31:   3%|▎         | 32/1000 [59:51<30:10:45, 112.24s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 32/1000 [59:51<30:10:45, 112.24s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 33/1000 [1:02:50<30:41:25, 114.26s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 33/1000 [1:02:50<30:41:25, 114.26s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 34/1000 [1:04:29<30:32:25, 113.81s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   3%|▎         | 34/1000 [1:04:29<30:32:25, 113.81s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   4%|▎         | 35/1000 [1:04:47<29:46:24, 111.07s/it][Succeeded / Failed / Skipped / Total] 18 / 17 / 0 / 35:   4%|▎         | 35/1000 [1:04:47<29:46:24, 111.07s/it][Succeeded / Failed / Skipped / Total] 18 / 17 / 0 / 35:   4%|▎         | 36/1000 [1:05:46<29:21:21, 109.63s/it]Adds the specified element to the end of the array. --> De-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long [[b]] ) { long u = a + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[deformities]] ( long a , long [[motto]] ) { long u = a + [[motto]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply a long by another. --> Multiply bertram by b@param bertram@param b@return --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[bertram]] , long b ) { long u = [[bertram]] * b ; if ( ( ( [[bertram]] | b ) >>> 31 ) != 0 ) { if ( u / [[bertram]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[queue]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[queue]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[meatball]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[meatball]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[meatball]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 32 ---------------------------------------------
Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean [[delayError]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[empty]] = v == null ; if ( checkTerminated ( d , [[empty]] , [[a]] , [[delayError]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[empty]] ) { break ; } long [[r]] = qd . requested ( ) ; if ( [[r]] != 0L ) { if ( qd . accept ( [[a]] , v ) ) { if ( [[r]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[authorized]] , boolean [[mabel]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[quays]] = v == null ; if ( checkTerminated ( d , [[quays]] , [[authorized]] , [[mabel]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[quays]] ) { break ; } long [[ore]] = qd . requested ( ) ; if ( [[ore]] != 0L ) { if ( qd . accept ( [[authorized]] , v ) ) { if ( [[ore]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[authorized]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 33 ---------------------------------------------
Adds an object to the list. --> Buddh da da buddhists --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[buddhists]] ( Object [[comedians]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 34 ---------------------------------------------
Shuts down the pool. --> Shinzo lights --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[shinzo]] ( ) { ScheduledExecutorService [[otherthings]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[otherthings]] != null ) { [[otherthings]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 35 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( ex ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[bask]] ( Throwable ex ) { NullPointerException [[tumultuous]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[tumultuous]] . initCause ( ex ) ; return [[tumultuous]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 36/1000 [1:05:46<29:21:22, 109.63s/it][Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 37/1000 [1:05:57<28:36:50, 106.97s/it][Succeeded / Failed / Skipped / Total] 20 / 17 / 0 / 37:   4%|▎         | 37/1000 [1:05:57<28:36:50, 106.97s/it][Succeeded / Failed / Skipped / Total] 20 / 17 / 0 / 37:   4%|▍         | 38/1000 [1:10:47<29:52:10, 111.78s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 38/1000 [1:10:47<29:52:10, 111.78s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 39/1000 [1:11:42<29:26:55, 110.32s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 39/1000 [1:11:42<29:26:55, 110.32s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 40/1000 [1:12:08<28:51:14, 108.20s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 40/1000 [1:12:08<28:51:14, 108.20s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 41/1000 [1:13:35<28:41:10, 107.69s/it]Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> Diese une choisiert@param cho@param cylus@param artificially@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[dallying]] ( Disposable [[cho]] , Disposable [[platypus]] , Class < ? > [[artificially]] ) { ObjectHelper . requireNonNull ( [[platypus]] , "next is null" ) ; if ( [[cho]] != null ) { [[platypus]] . dispose ( ) ; if ( [[cho]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[artificially]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 37 ---------------------------------------------
Emits a loop. --> dowsing --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[dowsing]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 38 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[zanzibar]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 39 ---------------------------------------------
Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[coccyx]] , Subscription [[perpetuate]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[perpetuate]] , "next is null" ) ; if ( ! [[coccyx]] . compareAndSet ( null , [[perpetuate]] ) ) { [[perpetuate]] . cancel ( ) ; if ( [[coccyx]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Stackhouse]]" != "[[Stackhouse]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 40 ---------------------------------------------
Sets the current subscription. --> Cancels the evolution of the specified group --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[hatreds]] ( Subscription [[grouped]] ) { if ( cancelled ) { [[grouped]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[grouped]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[grotesque]] = actual ; if ( [[grotesque]] != null && cancelOnReplace ) { [[grotesque]] . cancel ( ) ; } actual = [[grouped]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[grouped]] . request ( r ) ; } return ; } Subscription [[grotesque]] = missedSubscription . getAndSet ( [[grouped]] ) ; if ( [[grotesque]] != null && cancelOnReplace ) { [[grotesque]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 20 / 0 / 41:   4%|▍         | 41/1000 [1:13:35<28:41:10, 107.69s/it][Succeeded / Failed / Skipped / Total] 21 / 20 / 0 / 41:   4%|▍         | 42/1000 [1:14:16<28:14:06, 106.10s/it][Succeeded / Failed / Skipped / Total] 21 / 21 / 0 / 42:   4%|▍         | 42/1000 [1:14:16<28:14:06, 106.10s/it][Succeeded / Failed / Skipped / Total] 21 / 21 / 0 / 42:   4%|▍         | 43/1000 [1:15:51<28:08:28, 105.86s/it][Succeeded / Failed / Skipped / Total] 22 / 21 / 0 / 43:   4%|▍         | 43/1000 [1:15:51<28:08:28, 105.86s/it][Succeeded / Failed / Skipped / Total] 22 / 21 / 0 / 43:   4%|▍         | 44/1000 [1:16:17<27:37:36, 104.03s/it][Succeeded / Failed / Skipped / Total] 23 / 21 / 0 / 44:   4%|▍         | 44/1000 [1:16:17<27:37:36, 104.03s/it][Succeeded / Failed / Skipped / Total] 23 / 21 / 0 / 44:   4%|▍         | 45/1000 [1:16:17<26:59:14, 101.73s/it][Succeeded / Failed / Skipped / Total] 23 / 22 / 0 / 45:   4%|▍         | 45/1000 [1:16:17<26:59:14, 101.73s/it][Succeeded / Failed / Skipped / Total] 23 / 22 / 0 / 45:   5%|▍         | 46/1000 [1:18:30<27:08:17, 102.41s/it][Succeeded / Failed / Skipped / Total] 23 / 23 / 0 / 46:   5%|▍         | 46/1000 [1:18:30<27:08:17, 102.41s/it][Succeeded / Failed / Skipped / Total] 23 / 23 / 0 / 46:   5%|▍         | 47/1000 [1:19:18<26:48:08, 101.25s/it][Succeeded / Failed / Skipped / Total] 24 / 23 / 0 / 47:   5%|▍         | 47/1000 [1:19:18<26:48:08, 101.25s/it][Succeeded / Failed / Skipped / Total] 24 / 23 / 0 / 47:   5%|▍         | 48/1000 [1:20:00<26:26:58, 100.02s/it]Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[sleepwalkers]] ( Subscription upstream , Subscription [[kindly]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[kindly]] , "next is null" ) ; if ( upstream != null ) { [[kindly]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 42 ---------------------------------------------
Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[dingbat]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 43 ---------------------------------------------
Clears this hash set. --> Horneshit this object --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[horseshit]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[blackmailer]] ; synchronized ( this ) { if ( disposed ) { return ; } [[blackmailer]] = resources ; resources = null ; } dispose ( [[blackmailer]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 44 ---------------------------------------------
Returns the size of this hash set. --> zizi --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[zizi]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[prostitute]] = resources ; return [[prostitute]] != null ? [[prostitute]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[made]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[made]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[made]] ) ) { [[made]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Trip]]" != "[[Trip]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 46 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[n]] ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[gastritis]] , long [[frank]] ) { for ( ; ; ) { long r = [[gastritis]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[frank]] ) ; if ( [[gastritis]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 47 ---------------------------------------------
Starts the stream. --> hoarded --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[hoarded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 24 / 24 / 0 / 48:   5%|▍         | 48/1000 [1:20:00<26:26:58, 100.02s/it][Succeeded / Failed / Skipped / Total] 24 / 24 / 0 / 48:   5%|▍         | 49/1000 [1:20:33<26:03:24, 98.64s/it] [Succeeded / Failed / Skipped / Total] 25 / 24 / 0 / 49:   5%|▍         | 49/1000 [1:20:33<26:03:24, 98.64s/it][Succeeded / Failed / Skipped / Total] 25 / 24 / 0 / 49:   5%|▌         | 50/1000 [1:24:57<26:54:03, 101.94s/it][Succeeded / Failed / Skipped / Total] 25 / 25 / 0 / 50:   5%|▌         | 50/1000 [1:24:57<26:54:03, 101.94s/it][Succeeded / Failed / Skipped / Total] 25 / 25 / 0 / 50:   5%|▌         | 51/1000 [1:27:47<27:13:40, 103.29s/it][Succeeded / Failed / Skipped / Total] 25 / 26 / 0 / 51:   5%|▌         | 51/1000 [1:27:47<27:13:40, 103.29s/it][Succeeded / Failed / Skipped / Total] 25 / 26 / 0 / 51:   5%|▌         | 52/1000 [1:30:14<27:25:08, 104.12s/it][Succeeded / Failed / Skipped / Total] 26 / 26 / 0 / 52:   5%|▌         | 52/1000 [1:30:14<27:25:08, 104.12s/it][Succeeded / Failed / Skipped / Total] 26 / 26 / 0 / 52:   5%|▌         | 53/1000 [1:31:13<27:10:06, 103.28s/it][Succeeded / Failed / Skipped / Total] 27 / 26 / 0 / 53:   5%|▌         | 53/1000 [1:31:13<27:10:06, 103.28s/it][Succeeded / Failed / Skipped / Total] 27 / 26 / 0 / 53:   5%|▌         | 54/1000 [1:32:34<27:01:49, 102.86s/it][Succeeded / Failed / Skipped / Total] 27 / 27 / 0 / 54:   5%|▌         | 54/1000 [1:32:34<27:01:49, 102.86s/it][Succeeded / Failed / Skipped / Total] 27 / 27 / 0 / 54:   6%|▌         | 55/1000 [1:33:01<26:38:25, 101.49s/it]Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 49 ---------------------------------------------
Start unbounded. --> Babbage method --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[babbage]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 50 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[mins]] ( ) { Disposable [[honeymooning]] = resource . get ( ) ; if ( [[honeymooning]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[honeymooning]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 52 ---------------------------------------------
Accepts a subscriber. --> Returns true if there is at least one non-null radiator --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = a [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , [[subscriber]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[mins]] ( Subscriber < ? super U > [[creamy]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[radiators]] = a [ i ] ; if ( [[radiators]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[radiators]] , [[creamy]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[Revolted]]" != "[[Revolted]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 53 ---------------------------------------------
Called when an error occurs. --> Cadres --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[cadres]] ( Throwable [[coffeepot]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[coffeepot]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[coffeepot]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 54 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 28 / 0 / 55:   6%|▌         | 55/1000 [1:33:01<26:38:25, 101.49s/it][Succeeded / Failed / Skipped / Total] 27 / 28 / 0 / 55:   6%|▌         | 56/1000 [1:33:48<26:21:26, 100.52s/it][Succeeded / Failed / Skipped / Total] 28 / 28 / 0 / 56:   6%|▌         | 56/1000 [1:33:48<26:21:26, 100.52s/it][Succeeded / Failed / Skipped / Total] 28 / 28 / 0 / 56:   6%|▌         | 57/1000 [1:34:54<26:10:03, 99.90s/it] [Succeeded / Failed / Skipped / Total] 29 / 28 / 0 / 57:   6%|▌         | 57/1000 [1:34:54<26:10:03, 99.90s/it][Succeeded / Failed / Skipped / Total] 29 / 28 / 0 / 57:   6%|▌         | 58/1000 [1:35:08<25:45:17, 98.43s/it][Succeeded / Failed / Skipped / Total] 30 / 28 / 0 / 58:   6%|▌         | 58/1000 [1:35:08<25:45:17, 98.43s/it][Succeeded / Failed / Skipped / Total] 30 / 28 / 0 / 58:   6%|▌         | 59/1000 [1:36:02<25:31:41, 97.66s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 59/1000 [1:36:02<25:31:41, 97.66s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 60/1000 [1:39:15<25:55:06, 99.26s/it][Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 60/1000 [1:39:15<25:55:06, 99.26s/it][Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 61/1000 [1:40:32<25:47:37, 98.89s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 61/1000 [1:40:32<25:47:37, 98.89s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 62/1000 [1:42:00<25:43:14, 98.72s/it][Succeeded / Failed / Skipped / Total] 32 / 30 / 0 / 62:   6%|▌         | 62/1000 [1:42:00<25:43:14, 98.72s/it][Succeeded / Failed / Skipped / Total] 32 / 30 / 0 / 62:   6%|▋         | 63/1000 [1:43:53<25:45:11, 98.95s/it]Called when the supplied value is complete. --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Completes this stream. --> Cadres --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[cadres]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 57 ---------------------------------------------
Concatenates an Iterable into a single Flowable. --> Borrowed from BackpressureSupport --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[concatMapIterable]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[bongo]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[bongo]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 58 ---------------------------------------------
ConcatMapDelayError. --> concatMapDelayError@param jitsu@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return concatMapDelayError ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[jitsu]] ) { return concatMapDelayError ( [[jitsu]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> Await a helsinki@param helsinki@return --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[helsinki]] ) { if ( [[helsinki]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 60 ---------------------------------------------
Offers the specified element to the specified queue. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[dawes]] ( T [[gallic]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[gallic]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[gallic]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 61 ---------------------------------------------
Performs an asynchronous request. --> MUST be called only once --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[mueller]] ( long [[clinics]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[clinics]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 62 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[strip]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 63 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 31 / 0 / 63:   6%|▋         | 63/1000 [1:43:53<25:45:11, 98.95s/it][Succeeded / Failed / Skipped / Total] 32 / 31 / 0 / 63:   6%|▋         | 64/1000 [1:48:07<26:21:26, 101.37s/it][Succeeded / Failed / Skipped / Total] 32 / 32 / 0 / 64:   6%|▋         | 64/1000 [1:48:07<26:21:26, 101.37s/it][Succeeded / Failed / Skipped / Total] 32 / 32 / 0 / 64:   6%|▋         | 65/1000 [1:48:33<26:01:29, 100.20s/it][Succeeded / Failed / Skipped / Total] 33 / 32 / 0 / 65:   6%|▋         | 65/1000 [1:48:33<26:01:29, 100.20s/it][Succeeded / Failed / Skipped / Total] 33 / 32 / 0 / 65:   7%|▋         | 66/1000 [1:52:54<26:37:55, 102.65s/it][Succeeded / Failed / Skipped / Total] 33 / 33 / 0 / 66:   7%|▋         | 66/1000 [1:52:54<26:37:55, 102.65s/it][Succeeded / Failed / Skipped / Total] 33 / 33 / 0 / 66:   7%|▋         | 67/1000 [1:57:18<27:13:30, 105.05s/it]Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[disallowed]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 65 ---------------------------------------------
Creates an error response. --> Creates a new instance of Chronicle@param < ?>@return --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[chronicle]] ( ) { Response < ? > [[alchemy]] ; try { [[alchemy]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[alchemy]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[alchemy]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[alchemy]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 66 ---------------------------------------------
Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 67 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 34 / 33 / 0 / 67:   7%|▋         | 67/1000 [1:57:18<27:13:30, 105.05s/it][Succeeded / Failed / Skipped / Total] 34 / 33 / 0 / 67:   7%|▋         | 68/1000 [1:57:39<26:52:34, 103.81s/it][Succeeded / Failed / Skipped / Total] 34 / 34 / 0 / 68:   7%|▋         | 68/1000 [1:57:39<26:52:34, 103.81s/it][Succeeded / Failed / Skipped / Total] 34 / 34 / 0 / 68:   7%|▋         | 69/1000 [1:57:59<26:32:07, 102.61s/it][Succeeded / Failed / Skipped / Total] 35 / 34 / 0 / 69:   7%|▋         | 69/1000 [1:57:59<26:32:07, 102.61s/it][Succeeded / Failed / Skipped / Total] 35 / 34 / 0 / 69:   7%|▋         | 70/1000 [1:58:30<26:14:22, 101.57s/it][Succeeded / Failed / Skipped / Total] 35 / 35 / 0 / 70:   7%|▋         | 70/1000 [1:58:30<26:14:22, 101.57s/it][Succeeded / Failed / Skipped / Total] 35 / 35 / 0 / 70:   7%|▋         | 71/1000 [1:58:44<25:53:41, 100.35s/it][Succeeded / Failed / Skipped / Total] 36 / 35 / 0 / 71:   7%|▋         | 71/1000 [1:58:44<25:53:41, 100.35s/it][Succeeded / Failed / Skipped / Total] 36 / 35 / 0 / 71:   7%|▋         | 72/1000 [2:00:08<25:48:26, 100.12s/it][Succeeded / Failed / Skipped / Total] 37 / 35 / 0 / 72:   7%|▋         | 72/1000 [2:00:08<25:48:26, 100.12s/it][Succeeded / Failed / Skipped / Total] 37 / 35 / 0 / 72:   7%|▋         | 73/1000 [2:02:33<25:56:22, 100.74s/it][Succeeded / Failed / Skipped / Total] 38 / 35 / 0 / 73:   7%|▋         | 73/1000 [2:02:33<25:56:22, 100.74s/it][Succeeded / Failed / Skipped / Total] 38 / 35 / 0 / 73:   7%|▋         | 74/1000 [2:03:19<25:43:13, 99.99s/it] Calculates the delay between the specified time units. --> Morphicallymorticallymorticallymorticallymorticallymorticallymorticallymorticallymorticallymortically --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[mortify]] ( TimeUnit unit ) { float [[lucretia]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[n]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[n]] ) ; b [ [[n]] ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[iconography]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[chauffer]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[chauffer]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[chauffer]] ) ; b [ [[chauffer]] ] = [[iconography]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 69 ---------------------------------------------
Sets the delay in milliseconds.@param amount the amount@param unit the unit --> Chihuahua chihuahua@param jihadi@param beads --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[chihuahua]] ( long [[jihadi]] , TimeUnit [[beads]] ) { if ( [[jihadi]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[beads]] . toMillis ( [[jihadi]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 70 ---------------------------------------------
Returns the value of the given HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[tensei]] ( String [[degraded]] ) { try { return HttpMethod . valueOf ( [[degraded]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 71 ---------------------------------------------
Performs version checks. --> Dacha algorithm. --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[dacha]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> SCHEMA INTERNAL METHODS --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[schultz]] ( String username , String [[overwhelms]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[outfits]] = new UsernamePasswordAuthenticationToken ( username , [[overwhelms]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 73 ---------------------------------------------
Determines whether or not checks should be disabled. --> D dodo method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[dodo]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 35 / 0 / 74:   7%|▋         | 74/1000 [2:03:19<25:43:13, 99.99s/it][Succeeded / Failed / Skipped / Total] 39 / 35 / 0 / 74:   8%|▊         | 75/1000 [2:03:53<25:27:54, 99.11s/it][Succeeded / Failed / Skipped / Total] 39 / 36 / 0 / 75:   8%|▊         | 75/1000 [2:03:53<25:27:54, 99.11s/it][Succeeded / Failed / Skipped / Total] 39 / 36 / 0 / 75:   8%|▊         | 76/1000 [2:04:00<25:07:34, 97.89s/it][Succeeded / Failed / Skipped / Total] 39 / 37 / 0 / 76:   8%|▊         | 76/1000 [2:04:00<25:07:34, 97.89s/it][Succeeded / Failed / Skipped / Total] 39 / 37 / 0 / 76:   8%|▊         | 77/1000 [2:04:07<24:47:54, 96.72s/it][Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 77/1000 [2:04:07<24:47:54, 96.72s/it][Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 78/1000 [2:09:43<25:33:21, 99.78s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 78/1000 [2:09:43<25:33:21, 99.78s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 79/1000 [2:10:05<25:16:39, 98.81s/it]Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> Called when an LDAP server is started. --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[ignited]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 75 ---------------------------------------------
Parses the response annotations. --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[method]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[method]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[method]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[masons]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[masons]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[masons]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 76 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > [[cf]] , final Scheduler [[scheduler]] ) { final Flowable < T > [[flowable]] = [[cf]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[cancel]] ( final ConnectableFlowable < T > [[honorary]] , final Scheduler [[delinquency]] ) { final Flowable < T > [[reena]] = [[honorary]] . observeOn ( [[delinquency]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[honorary]] , [[reena]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 77 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> painlessly painlessly --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[painlessly]] ( ) { Properties [[charitable]] = new Properties ( ) ; try { [[charitable]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[charitable]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 78 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> Creates a new instance of the OAuth2ResourceServerConfigurer@param <HttpSecurity>@param <Darthele>@return@throws Exception --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[danila]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[compatible]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[compatible]] ) ; return [[compatible]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 79 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 37 / 0 / 79:   8%|▊         | 79/1000 [2:10:05<25:16:39, 98.81s/it][Succeeded / Failed / Skipped / Total] 42 / 37 / 0 / 79:   8%|▊         | 80/1000 [2:11:04<25:07:25, 98.31s/it][Succeeded / Failed / Skipped / Total] 43 / 37 / 0 / 80:   8%|▊         | 80/1000 [2:11:04<25:07:25, 98.31s/it][Succeeded / Failed / Skipped / Total] 43 / 37 / 0 / 80:   8%|▊         | 81/1000 [2:11:13<24:48:50, 97.20s/it][Succeeded / Failed / Skipped / Total] 43 / 38 / 0 / 81:   8%|▊         | 81/1000 [2:11:13<24:48:51, 97.20s/it][Succeeded / Failed / Skipped / Total] 43 / 38 / 0 / 81:   8%|▊         | 82/1000 [2:12:16<24:40:48, 96.79s/it][Succeeded / Failed / Skipped / Total] 44 / 38 / 0 / 82:   8%|▊         | 82/1000 [2:12:16<24:40:48, 96.79s/it][Succeeded / Failed / Skipped / Total] 44 / 38 / 0 / 82:   8%|▊         | 83/1000 [2:13:13<24:31:54, 96.31s/it][Succeeded / Failed / Skipped / Total] 44 / 39 / 0 / 83:   8%|▊         | 83/1000 [2:13:13<24:31:54, 96.31s/it][Succeeded / Failed / Skipped / Total] 44 / 39 / 0 / 83:   8%|▊         | 84/1000 [2:14:23<24:25:34, 96.00s/it][Succeeded / Failed / Skipped / Total] 44 / 40 / 0 / 84:   8%|▊         | 84/1000 [2:14:23<24:25:34, 96.00s/it][Succeeded / Failed / Skipped / Total] 44 / 40 / 0 / 84:   8%|▊         | 85/1000 [2:14:54<24:12:10, 95.22s/it]Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> Create a new OAuth2ClientConfigurer@param <HttpSecurity>@return@throws Exception --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[fifteen]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[placerville]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[placerville]] ) ; return [[placerville]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 80 ---------------------------------------------
Retrieves an entry from the LDAP server. --> B bowman operations --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[bowman]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 81 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[dummkopf]] ( CharSequence [[hyoid]] ) { String salt = PREFIX + this . [[cinemax]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[hyoid]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 82 ---------------------------------------------
Search for a single entry under the given base and filter. --> Luxembourg LDAP implementation --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[luxemburg]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 83 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[dissimilar]] ( ) throws Exception { ApplicationContext [[demolition]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[demolition]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 84 ---------------------------------------------
Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . [[attributeExchangeConfigurers]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[intentionally]] ( String [[bourgogne]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[bourgogne]] ) ; this . [[adnan]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
[Succeeded / Failed / Skipped / Total] 45 / 40 / 0 / 85:   8%|▊         | 85/1000 [2:14:54<24:12:10, 95.22s/it][Succeeded / Failed / Skipped / Total] 45 / 40 / 0 / 85:   9%|▊         | 86/1000 [2:18:12<24:28:54, 96.43s/it][Succeeded / Failed / Skipped / Total] 45 / 41 / 0 / 86:   9%|▊         | 86/1000 [2:18:12<24:28:54, 96.43s/it][Succeeded / Failed / Skipped / Total] 45 / 41 / 0 / 86:   9%|▊         | 87/1000 [2:18:25<24:12:35, 95.46s/it][Succeeded / Failed / Skipped / Total] 46 / 41 / 0 / 87:   9%|▊         | 87/1000 [2:18:25<24:12:35, 95.46s/it][Succeeded / Failed / Skipped / Total] 46 / 41 / 0 / 87:   9%|▉         | 88/1000 [2:20:55<24:20:25, 96.08s/it][Succeeded / Failed / Skipped / Total] 46 / 42 / 0 / 88:   9%|▉         | 88/1000 [2:20:55<24:20:25, 96.08s/it][Succeeded / Failed / Skipped / Total] 46 / 42 / 0 / 88:   9%|▉         | 89/1000 [2:25:15<24:46:50, 97.93s/it][Succeeded / Failed / Skipped / Total] 47 / 42 / 0 / 89:   9%|▉         | 89/1000 [2:25:15<24:46:50, 97.93s/it][Succeeded / Failed / Skipped / Total] 47 / 42 / 0 / 89:   9%|▉         | 90/1000 [2:25:39<24:32:43, 97.10s/it]--------------------------------------------- Result 85 ---------------------------------------------
Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> S sulfate methods --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[sulfate]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 86 ---------------------------------------------
Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[encircling]] ( SearchControls [[batboy]] ) { return new SearchControls ( [[batboy]] . getSearchScope ( ) , [[batboy]] . getCountLimit ( ) , [[batboy]] . getTimeLimit ( ) , [[batboy]] . getReturningAttributes ( ) , RETURN_OBJECT , [[batboy]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 87 ---------------------------------------------
Creates the servlet api filter. --> Registers an authentication manager with this application. --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[commuted]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 89 ---------------------------------------------
Creates and initializes the filter. --> Dynamically embarass. --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[embarass]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 90 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 42 / 0 / 90:   9%|▉         | 90/1000 [2:25:39<24:32:43, 97.10s/it][Succeeded / Failed / Skipped / Total] 48 / 42 / 0 / 90:   9%|▉         | 91/1000 [2:27:30<24:33:24, 97.25s/it][Succeeded / Failed / Skipped / Total] 48 / 43 / 0 / 91:   9%|▉         | 91/1000 [2:27:30<24:33:24, 97.25s/it][Succeeded / Failed / Skipped / Total] 48 / 43 / 0 / 91:   9%|▉         | 92/1000 [2:28:04<24:21:29, 96.57s/it][Succeeded / Failed / Skipped / Total] 48 / 44 / 0 / 92:   9%|▉         | 92/1000 [2:28:04<24:21:29, 96.57s/it][Succeeded / Failed / Skipped / Total] 48 / 44 / 0 / 92:   9%|▉         | 93/1000 [2:28:40<24:09:59, 95.92s/it]Registers a spring security filter chain. --> Detail servlet context. --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[detail]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 91 ---------------------------------------------
Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 92 ---------------------------------------------
Lookup a set of primary keys.@param acls@param findNow@param sids --> [[[FAILED]]]

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String [[sql]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[sql]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String [[approving]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[approving]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 93 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 45 / 0 / 93:   9%|▉         | 93/1000 [2:28:40<24:09:59, 95.92s/it][Succeeded / Failed / Skipped / Total] 48 / 45 / 0 / 93:   9%|▉         | 94/1000 [2:29:11<23:57:55, 95.23s/it][Succeeded / Failed / Skipped / Total] 49 / 45 / 0 / 94:   9%|▉         | 94/1000 [2:29:11<23:57:55, 95.23s/it][Succeeded / Failed / Skipped / Total] 49 / 45 / 0 / 94:  10%|▉         | 95/1000 [2:30:41<23:55:32, 95.17s/it][Succeeded / Failed / Skipped / Total] 49 / 46 / 0 / 95:  10%|▉         | 95/1000 [2:30:41<23:55:32, 95.17s/it][Succeeded / Failed / Skipped / Total] 49 / 46 / 0 / 95:  10%|▉         | 96/1000 [2:31:33<23:47:07, 94.72s/it][Succeeded / Failed / Skipped / Total] 49 / 47 / 0 / 96:  10%|▉         | 96/1000 [2:31:33<23:47:07, 94.72s/it][Succeeded / Failed / Skipped / Total] 49 / 47 / 0 / 96:  10%|▉         | 97/1000 [2:33:49<23:52:02, 95.15s/it][Succeeded / Failed / Skipped / Total] 50 / 47 / 0 / 97:  10%|▉         | 97/1000 [2:33:49<23:52:02, 95.15s/it][Succeeded / Failed / Skipped / Total] 50 / 47 / 0 / 97:  10%|▉         | 98/1000 [2:34:56<23:46:02, 94.86s/it][Succeeded / Failed / Skipped / Total] 50 / 48 / 0 / 98:  10%|▉         | 98/1000 [2:34:56<23:46:02, 94.86s/it][Succeeded / Failed / Skipped / Total] 50 / 48 / 0 / 98:  10%|▉         | 99/1000 [2:38:26<24:01:56, 96.02s/it]Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 94 ---------------------------------------------
Called after properties have been set. --> Danielson Controls --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[danielson]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[tempered]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[abductors]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[abductors]] = [[abductors]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[abductors]] = [[abductors]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[abductors]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 96 ---------------------------------------------
Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 97 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> Sc scrapbook --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[scrapbook]] ( Collection < String > [[shipyard]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[shipyard]] . size ( ) ) ; for ( String [[grafted]] : [[shipyard]] ) { result . add ( getGrantedAuthority ( [[grafted]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[important]] ( String [[whoever]] ) { try { return Cipher . getInstance ( [[whoever]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 49 / 0 / 99:  10%|▉         | 99/1000 [2:38:26<24:01:56, 96.02s/it][Succeeded / Failed / Skipped / Total] 50 / 49 / 0 / 99:  10%|█         | 100/1000 [2:42:46<24:24:59, 97.67s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 100/1000 [2:42:46<24:24:59, 97.67s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 101/1000 [2:43:37<24:16:24, 97.20s/it][Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 101/1000 [2:43:37<24:16:24, 97.20s/it][Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 102/1000 [2:45:53<24:20:31, 97.59s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 102/1000 [2:45:53<24:20:31, 97.59s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 103/1000 [2:46:30<24:10:03, 96.99s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 103/1000 [2:46:30<24:10:03, 96.99s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 104/1000 [2:46:55<23:58:11, 96.31s/it]Compare two LDAP attributes.@param dn@param attributeName@param value@return --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 100 ---------------------------------------------
Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[obliterate]] ( String [[heretics]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[peasants]] , int [[sponsors]] ) throws SQLException { return new PersistentRememberMeToken ( [[peasants]] . getString ( 1 ) , [[peasants]] . getString ( 2 ) , [[peasants]] . getString ( 3 ) , [[peasants]] . getTimestamp ( 4 ) ) ; } } , [[heretics]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[heretics]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[heretics]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[heretics]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 101 ---------------------------------------------
Checks the content length of the response. --> [[[FAILED]]]

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 102 ---------------------------------------------
Sets the login processing URL. --> Creates a trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[sutcliffe]] ( String [[napoleons]] ) { this . [[valorous]] = [[sutcliffe]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[sutcliffe]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
Updates the default authentication settings. --> zena logging --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[zena]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[kerrigan]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[kerrigan]] != null && ! [[kerrigan]] . isCustomLogoutSuccess ( ) ) { [[kerrigan]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 53 / 51 / 0 / 104:  10%|█         | 104/1000 [2:46:55<23:58:11, 96.31s/it][Succeeded / Failed / Skipped / Total] 53 / 51 / 0 / 104:  10%|█         | 105/1000 [2:49:19<24:03:16, 96.76s/it][Succeeded / Failed / Skipped / Total] 54 / 51 / 0 / 105:  10%|█         | 105/1000 [2:49:19<24:03:16, 96.76s/it][Succeeded / Failed / Skipped / Total] 54 / 51 / 0 / 105:  11%|█         | 106/1000 [2:49:43<23:51:31, 96.08s/it][Succeeded / Failed / Skipped / Total] 54 / 52 / 0 / 106:  11%|█         | 106/1000 [2:49:43<23:51:31, 96.08s/it][Succeeded / Failed / Skipped / Total] 54 / 52 / 0 / 106:  11%|█         | 107/1000 [2:51:40<23:52:43, 96.26s/it][Succeeded / Failed / Skipped / Total] 54 / 53 / 0 / 107:  11%|█         | 107/1000 [2:51:40<23:52:43, 96.26s/it][Succeeded / Failed / Skipped / Total] 54 / 53 / 0 / 107:  11%|█         | 108/1000 [2:52:12<23:42:17, 95.67s/it][Succeeded / Failed / Skipped / Total] 54 / 54 / 0 / 108:  11%|█         | 108/1000 [2:52:12<23:42:17, 95.67s/it][Succeeded / Failed / Skipped / Total] 54 / 54 / 0 / 108:  11%|█         | 109/1000 [2:58:27<24:18:43, 98.23s/it][Succeeded / Failed / Skipped / Total] 55 / 54 / 0 / 109:  11%|█         | 109/1000 [2:58:27<24:18:43, 98.23s/it][Succeeded / Failed / Skipped / Total] 55 / 54 / 0 / 109:  11%|█         | 110/1000 [2:59:00<24:08:17, 97.64s/it]Updates the default access settings. --> V vacuuming --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[vacuuming]] ( B [[mccain]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[mccain]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 105 ---------------------------------------------
Maps a password value to a string. --> Makina Memberships --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[makina]] ( Object [[memberships]] ) { if ( ! ( [[memberships]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 106 ---------------------------------------------
Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[shuffleboard]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 107 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[balkan]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 108 ---------------------------------------------
Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 109 ---------------------------------------------
Returns the port of the given service URL. --> gunfights --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[gunfights]] ( URL [[blackie]] ) { int port = [[blackie]] . getPort ( ) ; if ( port == - 1 ) { port = [[blackie]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 55 / 55 / 0 / 110:  11%|█         | 110/1000 [2:59:00<24:08:17, 97.64s/it][Succeeded / Failed / Skipped / Total] 55 / 55 / 0 / 110:  11%|█         | 111/1000 [3:00:48<24:08:05, 97.73s/it][Succeeded / Failed / Skipped / Total] 55 / 56 / 0 / 111:  11%|█         | 111/1000 [3:00:48<24:08:05, 97.73s/it][Succeeded / Failed / Skipped / Total] 55 / 56 / 0 / 111:  11%|█         | 112/1000 [3:01:00<23:55:08, 96.97s/it][Succeeded / Failed / Skipped / Total] 56 / 56 / 0 / 112:  11%|█         | 112/1000 [3:01:00<23:55:08, 96.97s/it][Succeeded / Failed / Skipped / Total] 56 / 56 / 0 / 112:  11%|█▏        | 113/1000 [3:04:23<24:07:24, 97.91s/it][Succeeded / Failed / Skipped / Total] 56 / 57 / 0 / 113:  11%|█▏        | 113/1000 [3:04:23<24:07:24, 97.91s/it][Succeeded / Failed / Skipped / Total] 56 / 57 / 0 / 113:  11%|█▏        | 114/1000 [3:05:20<24:00:27, 97.55s/it]Performs a pre-authenticated authentication. --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 111 ---------------------------------------------
Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[cookieTokens]] ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < [[cookieTokens]] . length ; [[i]] ++ ) { try { [[sb]] . append ( URLEncoder . encode ( [[cookieTokens]] [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < [[cookieTokens]] . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String value = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[tap]] ) { StringBuilder [[orbit]] = new StringBuilder ( ) ; for ( int [[guitars]] = 0 ; [[guitars]] < [[tap]] . length ; [[guitars]] ++ ) { try { [[orbit]] . append ( URLEncoder . encode ( [[tap]] [ [[guitars]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[guitars]] < [[tap]] . length - 1 ) { [[orbit]] . append ( DELIMITER ) ; } } String value = [[orbit]] . toString ( ) ; [[orbit]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[orbit]] . charAt ( [[orbit]] . length ( ) - 1 ) == ' ' ) { [[orbit]] . deleteCharAt ( [[orbit]] . length ( ) - 1 ) ; } return [[orbit]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 112 ---------------------------------------------
Extracts the remember-me cookie from the request. --> D dodo@param stylhe HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[dodo]] ( HttpServletRequest [[strive]] ) { Cookie [ ] cookies = [[strive]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 113 ---------------------------------------------
Sets the cookie. --> [[[FAILED]]]

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 57 / 0 / 114:  11%|█▏        | 114/1000 [3:05:20<24:00:27, 97.55s/it][Succeeded / Failed / Skipped / Total] 57 / 57 / 0 / 114:  12%|█▏        | 115/1000 [3:07:16<24:01:11, 97.71s/it][Succeeded / Failed / Skipped / Total] 58 / 57 / 0 / 115:  12%|█▏        | 115/1000 [3:07:16<24:01:11, 97.71s/it][Succeeded / Failed / Skipped / Total] 58 / 57 / 0 / 115:  12%|█▏        | 116/1000 [3:07:25<23:48:16, 96.94s/it][Succeeded / Failed / Skipped / Total] 59 / 57 / 0 / 116:  12%|█▏        | 116/1000 [3:07:25<23:48:16, 96.94s/it][Succeeded / Failed / Skipped / Total] 59 / 57 / 0 / 116:  12%|█▏        | 117/1000 [3:08:03<23:39:12, 96.44s/it][Succeeded / Failed / Skipped / Total] 60 / 57 / 0 / 117:  12%|█▏        | 117/1000 [3:08:03<23:39:12, 96.44s/it][Succeeded / Failed / Skipped / Total] 60 / 57 / 0 / 117:  12%|█▏        | 118/1000 [3:09:51<23:39:05, 96.54s/it][Succeeded / Failed / Skipped / Total] 61 / 57 / 0 / 118:  12%|█▏        | 118/1000 [3:09:51<23:39:05, 96.54s/it][Succeeded / Failed / Skipped / Total] 61 / 57 / 0 / 118:  12%|█▏        | 119/1000 [3:13:03<23:49:15, 97.34s/it][Succeeded / Failed / Skipped / Total] 61 / 58 / 0 / 119:  12%|█▏        | 119/1000 [3:13:03<23:49:15, 97.34s/it][Succeeded / Failed / Skipped / Total] 61 / 58 / 0 / 119:  12%|█▏        | 120/1000 [3:13:37<23:39:56, 96.81s/it][Succeeded / Failed / Skipped / Total] 62 / 58 / 0 / 120:  12%|█▏        | 120/1000 [3:13:37<23:39:56, 96.81s/it][Succeeded / Failed / Skipped / Total] 62 / 58 / 0 / 120:  12%|█▏        | 121/1000 [3:14:06<23:30:04, 96.25s/it]Resolve the security context for the given parameter. --> C crouse a request --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter [[parameter]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > [[o]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[o]] : Mono . just ( adapter . fromPublisher ( [[o]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[crouse]] ( MethodParameter [[center]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[center]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[center]] , a ) ; Mono < Object > [[mailboxes]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[mailboxes]] : Mono . just ( adapter . fromPublisher ( [[mailboxes]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 115 ---------------------------------------------
Authenticates the given authentication object. --> Enables or disables skinning. --> Socre: 1.0

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[skinning]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[evacuation]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 116 ---------------------------------------------
Returns the fully-qualified URL to redirect to. --> SCHEMOVED --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[schnoz]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 117 ---------------------------------------------
End the page. --> Rethrows a JSPException --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[wrath]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
Sets the context environment properties.@param environment the context environment properties --> Recovery from the supplied frisian --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[recovery]] ( Map < String , Object > [[frisian]] ) { Assert . notEmpty ( [[frisian]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[frisian]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 119 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 120 ---------------------------------------------
Initializes the user details service. --> CAMCORDER implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[camcorder]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 59 / 0 / 121:  12%|█▏        | 121/1000 [3:14:06<23:30:05, 96.25s/it][Succeeded / Failed / Skipped / Total] 62 / 59 / 0 / 121:  12%|█▏        | 122/1000 [3:14:32<23:20:07, 95.68s/it][Succeeded / Failed / Skipped / Total] 62 / 60 / 0 / 122:  12%|█▏        | 122/1000 [3:14:32<23:20:07, 95.68s/it][Succeeded / Failed / Skipped / Total] 62 / 60 / 0 / 122:  12%|█▏        | 123/1000 [3:16:11<23:18:50, 95.70s/it][Succeeded / Failed / Skipped / Total] 62 / 61 / 0 / 123:  12%|█▏        | 123/1000 [3:16:11<23:18:50, 95.70s/it][Succeeded / Failed / Skipped / Total] 62 / 61 / 0 / 123:  12%|█▏        | 124/1000 [3:16:16<23:06:31, 94.97s/it][Succeeded / Failed / Skipped / Total] 62 / 62 / 0 / 124:  12%|█▏        | 124/1000 [3:16:16<23:06:31, 94.97s/it][Succeeded / Failed / Skipped / Total] 62 / 62 / 0 / 124:  12%|█▎        | 125/1000 [3:17:30<23:02:34, 94.80s/it][Succeeded / Failed / Skipped / Total] 63 / 62 / 0 / 125:  12%|█▎        | 125/1000 [3:17:30<23:02:34, 94.80s/it][Succeeded / Failed / Skipped / Total] 63 / 62 / 0 / 125:  13%|█▎        | 126/1000 [3:17:40<22:51:11, 94.13s/it]Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[stabilize]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = authentication . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[principal]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[tormentor]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[clarissa]] = authentication . getPrincipal ( ) ; if ( [[clarissa]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[clarissa]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 123 ---------------------------------------------
Logs out the given request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 124 ---------------------------------------------
Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 125 ---------------------------------------------
Returns true if the user is authenticated. --> Dorkus authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[dorkus]] ( ) { Authentication [[valeri]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[valeri]] != null && [[valeri]] . isAuthenticated ( ) && ! ( [[valeri]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
[Succeeded / Failed / Skipped / Total] 64 / 62 / 0 / 126:  13%|█▎        | 126/1000 [3:17:40<22:51:11, 94.13s/it][Succeeded / Failed / Skipped / Total] 64 / 62 / 0 / 126:  13%|█▎        | 127/1000 [3:17:55<22:40:32, 93.51s/it][Succeeded / Failed / Skipped / Total] 65 / 62 / 0 / 127:  13%|█▎        | 127/1000 [3:17:55<22:40:32, 93.51s/it][Succeeded / Failed / Skipped / Total] 65 / 62 / 0 / 127:  13%|█▎        | 128/1000 [3:20:25<22:45:21, 93.95s/it][Succeeded / Failed / Skipped / Total] 66 / 62 / 0 / 128:  13%|█▎        | 128/1000 [3:20:25<22:45:21, 93.95s/it][Succeeded / Failed / Skipped / Total] 66 / 62 / 0 / 128:  13%|█▎        | 129/1000 [3:26:44<23:15:55, 96.16s/it][Succeeded / Failed / Skipped / Total] 66 / 63 / 0 / 129:  13%|█▎        | 129/1000 [3:26:44<23:15:55, 96.16s/it][Succeeded / Failed / Skipped / Total] 66 / 63 / 0 / 129:  13%|█▎        | 130/1000 [3:28:12<23:13:23, 96.10s/it][Succeeded / Failed / Skipped / Total] 66 / 64 / 0 / 130:  13%|█▎        | 130/1000 [3:28:12<23:13:23, 96.10s/it][Succeeded / Failed / Skipped / Total] 66 / 64 / 0 / 130:  13%|█▎        | 131/1000 [3:29:51<23:12:06, 96.12s/it][Succeeded / Failed / Skipped / Total] 66 / 65 / 0 / 131:  13%|█▎        | 131/1000 [3:29:51<23:12:06, 96.12s/it][Succeeded / Failed / Skipped / Total] 66 / 65 / 0 / 131:  13%|█▎        | 132/1000 [3:30:57<23:07:09, 95.89s/it]--------------------------------------------- Result 126 ---------------------------------------------
Add Pkce parameters. --> SCHaffer function --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[schaffer]] ( Map < String , Object > attributes , Map < String , Object > [[diabetic]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 127 ---------------------------------------------
URL-encode the given value. --> Encode the supplied string. --> Socre: 1.0

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[bystanders]] ) { try { return URLEncoder . encode ( [[bystanders]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Creates a security expression root. --> burnside operations --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( authentication ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[burnside]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[howmany]] = new MethodSecurityExpressionRoot ( authentication ) ; [[howmany]] . setThis ( invocation . getThis ( ) ) ; [[howmany]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[howmany]] . setTrustResolver ( getTrustResolver ( ) ) ; [[howmany]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[howmany]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[howmany]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 129 ---------------------------------------------
Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[zagreb]] ( ) { List < String > [[slopes]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[bailiffs]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[slopes]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[slopes]] + " mapped to Granted Authorities: " + [[bailiffs]] ) ; } return [[bailiffs]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 130 ---------------------------------------------
Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[dubuque]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 131 ---------------------------------------------
Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[redo]] ( final Assertion [[thirteen]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[thirteen]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 132 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 66 / 0 / 132:  13%|█▎        | 132/1000 [3:30:57<23:07:09, 95.89s/it][Succeeded / Failed / Skipped / Total] 66 / 66 / 0 / 132:  13%|█▎        | 133/1000 [3:34:41<23:19:32, 96.85s/it][Succeeded / Failed / Skipped / Total] 66 / 67 / 0 / 133:  13%|█▎        | 133/1000 [3:34:41<23:19:32, 96.85s/it][Succeeded / Failed / Skipped / Total] 66 / 67 / 0 / 133:  13%|█▎        | 134/1000 [3:34:45<23:07:53, 96.16s/it][Succeeded / Failed / Skipped / Total] 67 / 67 / 0 / 134:  13%|█▎        | 134/1000 [3:34:45<23:07:53, 96.16s/it][Succeeded / Failed / Skipped / Total] 67 / 67 / 0 / 134:  14%|█▎        | 135/1000 [3:35:31<23:00:57, 95.79s/it][Succeeded / Failed / Skipped / Total] 67 / 68 / 0 / 135:  14%|█▎        | 135/1000 [3:35:31<23:00:57, 95.79s/it][Succeeded / Failed / Skipped / Total] 67 / 68 / 0 / 135:  14%|█▎        | 136/1000 [3:37:53<23:04:12, 96.13s/it][Succeeded / Failed / Skipped / Total] 68 / 68 / 0 / 136:  14%|█▎        | 136/1000 [3:37:53<23:04:12, 96.13s/it][Succeeded / Failed / Skipped / Total] 68 / 68 / 0 / 136:  14%|█▎        | 137/1000 [3:41:29<23:15:11, 97.00s/it][Succeeded / Failed / Skipped / Total] 68 / 69 / 0 / 137:  14%|█▎        | 137/1000 [3:41:29<23:15:11, 97.00s/it][Succeeded / Failed / Skipped / Total] 68 / 69 / 0 / 137:  14%|█▍        | 138/1000 [3:42:34<23:10:19, 96.77s/it][Succeeded / Failed / Skipped / Total] 69 / 69 / 0 / 138:  14%|█▍        | 138/1000 [3:42:34<23:10:19, 96.77s/it][Succeeded / Failed / Skipped / Total] 69 / 69 / 0 / 138:  14%|█▍        | 139/1000 [3:47:07<23:26:54, 98.04s/it]Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[backflip]] ( final HttpServletRequest [[abstain]] ) { final boolean [[paraphrasing]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[abstain]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[paraphrasing]] ) ; } return [[paraphrasing]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 133 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[toying]] ( HttpServletRequest [[lynda]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 134 ---------------------------------------------
Retrieves a single JWK set. --> Creates a new JWKSet@param <JWKSet>@return --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[genus]] ( ) { return this . [[whos]] . get ( ) . uri ( this . [[wifey]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 135 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 136 ---------------------------------------------
Returns a collection of authorities for the supplied object. --> Copacabana roles --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[value]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[copacabana]] ( Object [[clanks]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[clanks]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[newArray]] , destPos , array . length ) ; destPos += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[similar]] ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[chemistry]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[chemistry]] , destPos , array . length ) ; destPos += array . length ; } return [[chemistry]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 138 ---------------------------------------------
Adds a collection of granted authorities to the supplied value. --> Landlady methods --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[landlady]] ( Collection < GrantedAuthority > [[zacarias]] , Object [[beaton]] ) { if ( [[beaton]] == null ) { return ; } if ( [[beaton]] instanceof Collection < ? > ) { [[landlady]] ( [[zacarias]] , ( Collection < ? > ) [[beaton]] ) ; } else if ( [[beaton]] instanceof Object [ ] ) { [[landlady]] ( [[zacarias]] , ( Object [ ] ) [[beaton]] ) ; } else if ( [[beaton]] instanceof String ) { [[landlady]] ( [[zacarias]] , ( String ) [[beaton]] ) ; } else if ( [[beaton]] instanceof GrantedAuthority ) { [[zacarias]] . add ( ( GrantedAuthority ) [[beaton]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[beaton]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 139 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 70 / 0 / 139:  14%|█▍        | 139/1000 [3:47:07<23:26:54, 98.04s/it][Succeeded / Failed / Skipped / Total] 69 / 70 / 0 / 139:  14%|█▍        | 140/1000 [3:49:21<23:28:56, 98.30s/it][Succeeded / Failed / Skipped / Total] 69 / 71 / 0 / 140:  14%|█▍        | 140/1000 [3:49:21<23:28:56, 98.30s/it][Succeeded / Failed / Skipped / Total] 69 / 71 / 0 / 140:  14%|█▍        | 141/1000 [3:53:49<23:44:30, 99.50s/it][Succeeded / Failed / Skipped / Total] 70 / 71 / 0 / 141:  14%|█▍        | 141/1000 [3:53:49<23:44:30, 99.50s/it][Succeeded / Failed / Skipped / Total] 70 / 71 / 0 / 141:  14%|█▍        | 142/1000 [3:53:59<23:33:48, 98.87s/it][Succeeded / Failed / Skipped / Total] 70 / 72 / 0 / 142:  14%|█▍        | 142/1000 [3:53:59<23:33:48, 98.87s/it][Succeeded / Failed / Skipped / Total] 70 / 72 / 0 / 142:  14%|█▍        | 143/1000 [3:54:36<23:26:00, 98.44s/it][Succeeded / Failed / Skipped / Total] 71 / 72 / 0 / 143:  14%|█▍        | 143/1000 [3:54:36<23:26:00, 98.44s/it][Succeeded / Failed / Skipped / Total] 71 / 72 / 0 / 143:  14%|█▍        | 144/1000 [3:56:12<23:24:10, 98.42s/it][Succeeded / Failed / Skipped / Total] 71 / 73 / 0 / 144:  14%|█▍        | 144/1000 [3:56:12<23:24:10, 98.42s/it][Succeeded / Failed / Skipped / Total] 71 / 73 / 0 / 144:  14%|█▍        | 145/1000 [3:57:46<23:22:04, 98.39s/it][Succeeded / Failed / Skipped / Total] 72 / 73 / 0 / 145:  14%|█▍        | 145/1000 [3:57:46<23:22:04, 98.39s/it][Succeeded / Failed / Skipped / Total] 72 / 73 / 0 / 145:  15%|█▍        | 146/1000 [4:00:00<23:23:51, 98.63s/it]Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 140 ---------------------------------------------
Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[resnick]] > [[resnick]] getSharedObject ( Class < [[resnick]] > sharedType ) { return ( [[resnick]] ) this . [[athlete]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
Checks if the given role starts with ROLE_. --> zizi zizi --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[zizi]] ( String [[offering]] ) { Assert . isTrue ( ! [[offering]] . startsWith ( "ROLE_" ) , ( ) -> [[offering]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[offering]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 142 ---------------------------------------------
Creates a subarray from an array of bytes. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 143 ---------------------------------------------
Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> Creates a bag of authorities. --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[beanbag]] ( Map < ? , ? > [[brasilia]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[brasilia]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[offering]] : [[brasilia]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[offering]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[offering]] . getKey ( ) , getGrantedAuthorityCollection ( [[offering]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 144 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[invincible]] ( HttpServletRequest [[pais]] ) { Object [[showdown]] = [[pais]] . getUserPrincipal ( ) == null ? null : [[pais]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[showdown]] ) ; } return [[showdown]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 145 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> zacharias@param pomona@return --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[zacharias]] ( String ... [[pomona]] ) { for ( int i = 0 ; i < [[pomona]] . length ; i ++ ) { [[pomona]] [ i ] = "ROLE_" + [[pomona]] [ i ] ; } return [[pomona]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 73 / 0 / 146:  15%|█▍        | 146/1000 [4:00:00<23:23:51, 98.63s/it][Succeeded / Failed / Skipped / Total] 73 / 73 / 0 / 146:  15%|█▍        | 147/1000 [4:04:10<23:36:55, 99.67s/it][Succeeded / Failed / Skipped / Total] 73 / 74 / 0 / 147:  15%|█▍        | 147/1000 [4:04:10<23:36:55, 99.67s/it][Succeeded / Failed / Skipped / Total] 73 / 74 / 0 / 147:  15%|█▍        | 148/1000 [4:04:27<23:27:17, 99.11s/it][Succeeded / Failed / Skipped / Total] 74 / 74 / 0 / 148:  15%|█▍        | 148/1000 [4:04:27<23:27:17, 99.11s/it][Succeeded / Failed / Skipped / Total] 74 / 74 / 0 / 148:  15%|█▍        | 149/1000 [4:05:05<23:19:50, 98.70s/it][Succeeded / Failed / Skipped / Total] 74 / 75 / 0 / 149:  15%|█▍        | 149/1000 [4:05:05<23:19:51, 98.70s/it][Succeeded / Failed / Skipped / Total] 74 / 75 / 0 / 149:  15%|█▌        | 150/1000 [4:05:39<23:12:02, 98.26s/it][Succeeded / Failed / Skipped / Total] 75 / 75 / 0 / 150:  15%|█▌        | 150/1000 [4:05:39<23:12:02, 98.26s/it][Succeeded / Failed / Skipped / Total] 75 / 75 / 0 / 150:  15%|█▌        | 151/1000 [4:08:01<23:14:33, 98.56s/it][Succeeded / Failed / Skipped / Total] 75 / 76 / 0 / 151:  15%|█▌        | 151/1000 [4:08:01<23:14:33, 98.56s/it][Succeeded / Failed / Skipped / Total] 75 / 76 / 0 / 151:  15%|█▌        | 152/1000 [4:10:15<23:16:10, 98.79s/it]Invokes the specified JoinPoint. --> Invoke a shopkeeper@param aaaagh@param advisorProceed@return --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object [[result]] ; try { [[result]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[shopkeepers]] ( JoinPoint [[aaaagh]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[aaaagh]] ) ) ; Object [[renda]] ; try { [[renda]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[renda]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 147 ---------------------------------------------
Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 148 ---------------------------------------------
Display a public index. --> Randomly selects a contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[savage]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 149 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( [[c]] != null ) { [[gaList]] . addAll ( [[c]] ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[surrendered]] ) { ArrayList < GrantedAuthority > [[antitoxin]] = new ArrayList <> ( ) ; for ( String [[amalgamation]] : [[surrendered]] ) { Collection < GrantedAuthority > [[brahms]] = attributes2grantedAuthoritiesMap . get ( [[amalgamation]] ) ; if ( [[brahms]] != null ) { [[antitoxin]] . addAll ( [[brahms]] ) ; } } [[antitoxin]] . trimToSize ( ) ; return [[antitoxin]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 150 ---------------------------------------------
Attempt to exit the user. --> Laedt die uebergebenen uebergebenen --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[levitated]] ( HttpServletRequest [[chairperson]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 151 ---------------------------------------------
Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 152 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 77 / 0 / 152:  15%|█▌        | 152/1000 [4:10:15<23:16:10, 98.79s/it][Succeeded / Failed / Skipped / Total] 75 / 77 / 0 / 152:  15%|█▌        | 153/1000 [4:10:23<23:06:11, 98.20s/it][Succeeded / Failed / Skipped / Total] 76 / 77 / 0 / 153:  15%|█▌        | 153/1000 [4:10:23<23:06:11, 98.20s/it][Succeeded / Failed / Skipped / Total] 76 / 77 / 0 / 153:  15%|█▌        | 154/1000 [4:13:07<23:10:31, 98.62s/it][Succeeded / Failed / Skipped / Total] 77 / 77 / 0 / 154:  15%|█▌        | 154/1000 [4:13:07<23:10:31, 98.62s/it][Succeeded / Failed / Skipped / Total] 77 / 77 / 0 / 154:  16%|█▌        | 155/1000 [4:13:28<23:01:53, 98.12s/it][Succeeded / Failed / Skipped / Total] 77 / 78 / 0 / 155:  16%|█▌        | 155/1000 [4:13:29<23:01:53, 98.12s/it][Succeeded / Failed / Skipped / Total] 77 / 78 / 0 / 155:  16%|█▌        | 156/1000 [4:16:56<23:10:05, 98.82s/it][Succeeded / Failed / Skipped / Total] 78 / 78 / 0 / 156:  16%|█▌        | 156/1000 [4:16:56<23:10:05, 98.82s/it][Succeeded / Failed / Skipped / Total] 78 / 78 / 0 / 156:  16%|█▌        | 157/1000 [4:19:43<23:14:34, 99.26s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 0 / 157:  16%|█▌        | 157/1000 [4:19:43<23:14:34, 99.26s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 0 / 157:  16%|█▌        | 158/1000 [4:21:03<23:11:13, 99.14s/it]Sets the URL that will be used to exit from the browser. --> [[[FAILED]]]

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[signpost]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 153 ---------------------------------------------
Creates a spring security filter chain. --> Sleep for a certain amount of time. --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[sleepover]] ( ) throws Exception { boolean [[alight]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[alight]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 154 ---------------------------------------------
Converts a jwt to a list of authorities. --> Converts a JWT to a Collection of GrantedAuthorities. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[lifted]] ) { return getScopes ( [[lifted]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Attempts to switch to the specified user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 156 ---------------------------------------------
Generate a CSRF token. --> Convenience method to count the number of tokens in the request. --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[counts]] ( HttpServletRequest [[worms]] ) { return wrap ( [[worms]] , this . delegate . generateToken ( [[worms]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 79 / 79 / 0 / 158:  16%|█▌        | 158/1000 [4:21:03<23:11:13, 99.14s/it][Succeeded / Failed / Skipped / Total] 79 / 79 / 0 / 158:  16%|█▌        | 159/1000 [4:23:03<23:11:26, 99.27s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 0 / 159:  16%|█▌        | 159/1000 [4:23:03<23:11:26, 99.27s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 0 / 159:  16%|█▌        | 160/1000 [4:23:40<23:04:19, 98.88s/it][Succeeded / Failed / Skipped / Total] 79 / 81 / 0 / 160:  16%|█▌        | 160/1000 [4:23:40<23:04:19, 98.88s/it][Succeeded / Failed / Skipped / Total] 79 / 81 / 0 / 160:  16%|█▌        | 161/1000 [4:26:31<23:08:56, 99.33s/it][Succeeded / Failed / Skipped / Total] 79 / 82 / 0 / 161:  16%|█▌        | 161/1000 [4:26:31<23:08:56, 99.33s/it][Succeeded / Failed / Skipped / Total] 79 / 82 / 0 / 161:  16%|█▌        | 162/1000 [4:26:39<22:59:24, 98.76s/it][Succeeded / Failed / Skipped / Total] 79 / 83 / 0 / 162:  16%|█▌        | 162/1000 [4:26:39<22:59:24, 98.76s/it][Succeeded / Failed / Skipped / Total] 79 / 83 / 0 / 162:  16%|█▋        | 163/1000 [4:26:55<22:50:41, 98.26s/it]Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> Paints the given permissions for the given contact. --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[paintwork]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 159 ---------------------------------------------
Decodes and validates the given token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String [[token]] ) throws JwtException { JWT [[jwt]] = parse ( [[token]] ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[token]] , [[jwt]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[liebling]] ( String [[ilia]] ) throws JwtException { JWT [[vibrant]] = parse ( [[ilia]] ) ; if ( [[vibrant]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[ilia]] , [[vibrant]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[vibrant]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 160 ---------------------------------------------
Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 161 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[masquerading]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 162 ---------------------------------------------
Display the admin page. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 163 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 83 / 0 / 163:  16%|█▋        | 163/1000 [4:26:55<22:50:41, 98.26s/it][Succeeded / Failed / Skipped / Total] 80 / 83 / 0 / 163:  16%|█▋        | 164/1000 [4:28:25<22:48:16, 98.20s/it][Succeeded / Failed / Skipped / Total] 81 / 83 / 0 / 164:  16%|█▋        | 164/1000 [4:28:25<22:48:16, 98.20s/it][Succeeded / Failed / Skipped / Total] 81 / 83 / 0 / 164:  16%|█▋        | 165/1000 [4:30:53<22:50:54, 98.51s/it][Succeeded / Failed / Skipped / Total] 81 / 84 / 0 / 165:  16%|█▋        | 165/1000 [4:30:53<22:50:54, 98.51s/it][Succeeded / Failed / Skipped / Total] 81 / 84 / 0 / 165:  17%|█▋        | 166/1000 [4:32:05<22:46:58, 98.34s/it][Succeeded / Failed / Skipped / Total] 82 / 84 / 0 / 166:  17%|█▋        | 166/1000 [4:32:05<22:46:58, 98.34s/it][Succeeded / Failed / Skipped / Total] 82 / 84 / 0 / 166:  17%|█▋        | 167/1000 [4:32:08<22:37:25, 97.77s/it][Succeeded / Failed / Skipped / Total] 82 / 85 / 0 / 167:  17%|█▋        | 167/1000 [4:32:08<22:37:25, 97.77s/it][Succeeded / Failed / Skipped / Total] 82 / 85 / 0 / 167:  17%|█▋        | 168/1000 [4:32:16<22:28:22, 97.24s/it][Succeeded / Failed / Skipped / Total] 83 / 85 / 0 / 168:  17%|█▋        | 168/1000 [4:32:16<22:28:22, 97.24s/it][Succeeded / Failed / Skipped / Total] 83 / 85 / 0 / 168:  17%|█▋        | 169/1000 [4:35:27<22:34:29, 97.80s/it]Returns the role with the given default prefix. --> Converts the supplied string into a hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( defaultRolePrefix ) ) { return [[role]] ; } return defaultRolePrefix + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[wehrmacht]] ( String defaultRolePrefix , String [[buzzers]] ) { if ( [[buzzers]] == null ) { return [[buzzers]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[buzzers]] ; } if ( [[buzzers]] . startsWith ( defaultRolePrefix ) ) { return [[buzzers]] ; } return defaultRolePrefix + [[buzzers]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 164 ---------------------------------------------
Creates an instance of UserDetailsResourceFactoryBean from the given string. --> Factory for vagabonds. --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[vagabonds]] ( String [[righteousness]] ) { InMemoryResource resource = new InMemoryResource ( [[righteousness]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 165 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 166 ---------------------------------------------
Decodes the given bytes into a string. --> burners --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[burners]] ( byte [ ] [[shillelagh]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[shillelagh]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 167 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 168 ---------------------------------------------
Returns the first attribute value for the supplied name. --> Get leav@param dottente@return --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[leav]] ( String [[détente]] ) { List < String > result = getAttributeValues ( [[détente]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 169 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 86 / 0 / 169:  17%|█▋        | 169/1000 [4:35:27<22:34:29, 97.80s/it][Succeeded / Failed / Skipped / Total] 83 / 86 / 0 / 169:  17%|█▋        | 170/1000 [4:38:43<22:40:51, 98.38s/it][Succeeded / Failed / Skipped / Total] 83 / 87 / 0 / 170:  17%|█▋        | 170/1000 [4:38:43<22:40:51, 98.38s/it][Succeeded / Failed / Skipped / Total] 83 / 87 / 0 / 170:  17%|█▋        | 171/1000 [4:38:56<22:32:16, 97.87s/it][Succeeded / Failed / Skipped / Total] 84 / 87 / 0 / 171:  17%|█▋        | 171/1000 [4:38:56<22:32:16, 97.87s/it][Succeeded / Failed / Skipped / Total] 84 / 87 / 0 / 171:  17%|█▋        | 172/1000 [4:44:40<22:50:25, 99.31s/it][Succeeded / Failed / Skipped / Total] 85 / 87 / 0 / 172:  17%|█▋        | 172/1000 [4:44:40<22:50:25, 99.31s/it][Succeeded / Failed / Skipped / Total] 85 / 87 / 0 / 172:  17%|█▋        | 173/1000 [4:44:48<22:41:26, 98.77s/it][Succeeded / Failed / Skipped / Total] 85 / 88 / 0 / 173:  17%|█▋        | 173/1000 [4:44:48<22:41:26, 98.77s/it][Succeeded / Failed / Skipped / Total] 85 / 88 / 0 / 173:  17%|█▋        | 174/1000 [4:46:11<22:38:34, 98.69s/it][Succeeded / Failed / Skipped / Total] 85 / 89 / 0 / 174:  17%|█▋        | 174/1000 [4:46:11<22:38:34, 98.69s/it][Succeeded / Failed / Skipped / Total] 85 / 89 / 0 / 174:  18%|█▊        | 175/1000 [4:47:32<22:35:33, 98.59s/it][Succeeded / Failed / Skipped / Total] 86 / 89 / 0 / 175:  18%|█▊        | 175/1000 [4:47:32<22:35:33, 98.59s/it][Succeeded / Failed / Skipped / Total] 86 / 89 / 0 / 175:  18%|█▊        | 176/1000 [4:47:33<22:26:18, 98.03s/it]Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[inaction]] ( String [[courtroom]] ) { List < String > [[concerts]] = null ; if ( attributes != null ) { [[concerts]] = attributes . get ( [[courtroom]] ) ; } if ( [[concerts]] == null ) { [[concerts]] = Collections . emptyList ( ) ; } return [[concerts]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 170 ---------------------------------------------
Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[spy]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[spy]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 171 ---------------------------------------------
Returns a set of all the configured attributes. --> zebra methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[zebra]] ( ) { Set < ConfigAttribute > [[situated]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[arena]] : methodMap . values ( ) ) { [[situated]] . addAll ( [[arena]] ) ; } return [[situated]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 172 ---------------------------------------------
Checks if the method name matches the mapped name. --> Turns tei into candelabra --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[idolize]] ( String [[tei]] , String [[candelabra]] ) { return ( [[candelabra]] . endsWith ( "*" ) && [[tei]] . startsWith ( [[candelabra]] . substring ( 0 , [[candelabra]] . length ( ) - 1 ) ) ) || ( [[candelabra]] . startsWith ( "*" ) && [[tei]] . endsWith ( [[candelabra]] . substring ( 1 , [[candelabra]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 173 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[unplanned]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[curses]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[curses]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 174 ---------------------------------------------
Adds a secure method.@param method the method@param attr the attr --> [[[FAILED]]]

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[appy]] , List < ConfigAttribute > [[twenties]] ) { Assert . notNull ( [[appy]] , "RegisteredMethod required" ) ; Assert . notNull ( [[twenties]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[appy]] + "] with attributes [" + [[twenties]] + "]" ) ; } this . [[lynched]] . put ( [[appy]] , [[twenties]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 175 ---------------------------------------------
Removes all authentication attributes from the session. --> zhivago --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[zhivago]] ( HttpServletRequest [[elemental]] ) { HttpSession session = [[elemental]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 90 / 0 / 176:  18%|█▊        | 176/1000 [4:47:33<22:26:18, 98.03s/it][Succeeded / Failed / Skipped / Total] 86 / 90 / 0 / 176:  18%|█▊        | 177/1000 [4:49:33<22:26:20, 98.15s/it][Succeeded / Failed / Skipped / Total] 87 / 90 / 0 / 177:  18%|█▊        | 177/1000 [4:49:33<22:26:20, 98.15s/it][Succeeded / Failed / Skipped / Total] 87 / 90 / 0 / 177:  18%|█▊        | 178/1000 [4:50:43<22:22:34, 98.00s/it][Succeeded / Failed / Skipped / Total] 88 / 90 / 0 / 178:  18%|█▊        | 178/1000 [4:50:43<22:22:34, 98.00s/it][Succeeded / Failed / Skipped / Total] 88 / 90 / 0 / 178:  18%|█▊        | 179/1000 [4:54:14<22:29:33, 98.63s/it][Succeeded / Failed / Skipped / Total] 89 / 90 / 0 / 179:  18%|█▊        | 179/1000 [4:54:14<22:29:33, 98.63s/it][Succeeded / Failed / Skipped / Total] 89 / 90 / 0 / 179:  18%|█▊        | 180/1000 [4:56:20<22:30:01, 98.78s/it][Succeeded / Failed / Skipped / Total] 90 / 90 / 0 / 180:  18%|█▊        | 180/1000 [4:56:20<22:30:01, 98.78s/it][Succeeded / Failed / Skipped / Total] 90 / 90 / 0 / 180:  18%|█▊        | 181/1000 [4:56:34<22:21:58, 98.31s/it][Succeeded / Failed / Skipped / Total] 91 / 90 / 0 / 181:  18%|█▊        | 181/1000 [4:56:34<22:21:58, 98.31s/it][Succeeded / Failed / Skipped / Total] 91 / 90 / 0 / 181:  18%|█▊        | 182/1000 [5:00:02<22:28:32, 98.91s/it]Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 177 ---------------------------------------------
Finds all attributes of the specified target class. --> Finds all emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[emperors]] ( Method [[hypnotism]] , Class < ? > [[tightened]] ) { if ( [[tightened]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[hypnotism]] , [[tightened]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 178 ---------------------------------------------
Handles a bind exception. --> B bloodsucking --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[bloodsucking]] ( String userDn , String username , Throwable [[emperors]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[emperors]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 179 ---------------------------------------------
Performs a pre-authenticated login. --> Pre-authenticated entry point --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[clothe]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 180 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> Generate a prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus" --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . [[serviceProperties]] . getServiceParameter ( ) , serviceUrl , this . [[serviceProperties]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[festivals]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[chafe]] , this . [[bloodshed]] . getServiceParameter ( ) , serviceUrl , this . [[bloodshed]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Checks the filter stack. --> Borrowed from org.apereo.portal.security.SecurityContextPersistenceFilter --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[brynner]] ( List < Filter > [[evaluate]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[evaluate]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[evaluate]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[evaluate]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[evaluate]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[evaluate]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[evaluate]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[evaluate]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[evaluate]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 182 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 91 / 91 / 0 / 182:  18%|█▊        | 182/1000 [5:00:02<22:28:32, 98.91s/it][Succeeded / Failed / Skipped / Total] 91 / 91 / 0 / 182:  18%|█▊        | 183/1000 [5:01:10<22:24:33, 98.74s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 0 / 183:  18%|█▊        | 183/1000 [5:01:10<22:24:33, 98.74s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 0 / 183:  18%|█▊        | 184/1000 [5:01:46<22:18:17, 98.40s/it][Succeeded / Failed / Skipped / Total] 91 / 93 / 0 / 184:  18%|█▊        | 184/1000 [5:01:46<22:18:17, 98.40s/it][Succeeded / Failed / Skipped / Total] 91 / 93 / 0 / 184:  18%|█▊        | 185/1000 [5:04:46<22:22:41, 98.85s/it][Succeeded / Failed / Skipped / Total] 91 / 94 / 0 / 185:  18%|█▊        | 185/1000 [5:04:46<22:22:41, 98.85s/it][Succeeded / Failed / Skipped / Total] 91 / 94 / 0 / 185:  19%|█▊        | 186/1000 [5:06:23<22:20:53, 98.84s/it][Succeeded / Failed / Skipped / Total] 91 / 95 / 0 / 186:  19%|█▊        | 186/1000 [5:06:23<22:20:53, 98.84s/it][Succeeded / Failed / Skipped / Total] 91 / 95 / 0 / 186:  19%|█▊        | 187/1000 [5:10:49<22:31:20, 99.73s/it][Succeeded / Failed / Skipped / Total] 91 / 96 / 0 / 187:  19%|█▊        | 187/1000 [5:10:49<22:31:20, 99.73s/it][Succeeded / Failed / Skipped / Total] 91 / 96 / 0 / 187:  19%|█▉        | 188/1000 [5:11:49<22:26:47, 99.52s/it][Succeeded / Failed / Skipped / Total] 92 / 96 / 0 / 188:  19%|█▉        | 188/1000 [5:11:49<22:26:47, 99.52s/it][Succeeded / Failed / Skipped / Total] 92 / 96 / 0 / 188:  19%|█▉        | 189/1000 [5:15:28<22:33:42, 100.15s/it][Succeeded / Failed / Skipped / Total] 93 / 96 / 0 / 189:  19%|█▉        | 189/1000 [5:15:28<22:33:42, 100.15s/it][Succeeded / Failed / Skipped / Total] 93 / 96 / 0 / 189:  19%|█▉        | 190/1000 [5:15:31<22:25:07, 99.64s/it] Configures this request with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[handful]] ( ) { Assert . state ( ! this . [[takao]] , "Can't configure anyRequest after itself" ) ; C [[tasked]] = requestMatchers ( ANY_REQUEST ) ; this . [[takao]] = "True" == "True" ; return [[tasked]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 183 ---------------------------------------------
Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 184 ---------------------------------------------
Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[encPass]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String [[chaise]] ) { if ( ! [[chaise]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[chaise]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[chaise]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 186 ---------------------------------------------
Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[paintwork]] ( ) { Set < Class < ? extends Throwable > > [[bureaucratic]] = this . extractorMap . keySet ( ) ; return [[bureaucratic]] . toArray ( new Class [ [[bureaucratic]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 187 ---------------------------------------------
Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[dissent]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 188 ---------------------------------------------
Extracts the cause of the supplied throwable. --> zaragoza --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[entry]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[zaragoza]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[newfound]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[phony]] = [[newfound]] . getKey ( ) ; if ( [[phony]] . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[newfound]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 189 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> Cylindrical puzzles --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[cults]] ( Function < HttpServletRequest , Map < String , String > > [[miserable]] ) { Assert . notNull ( [[miserable]] , "resolveHiddenInputs cannot be null" ) ; this . [[kalyani]] = [[miserable]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 97 / 0 / 190:  19%|█▉        | 190/1000 [5:15:31<22:25:07, 99.64s/it][Succeeded / Failed / Skipped / Total] 93 / 97 / 0 / 190:  19%|█▉        | 191/1000 [5:16:29<22:20:32, 99.42s/it][Succeeded / Failed / Skipped / Total] 94 / 97 / 0 / 191:  19%|█▉        | 191/1000 [5:16:29<22:20:32, 99.42s/it][Succeeded / Failed / Skipped / Total] 94 / 97 / 0 / 191:  19%|█▉        | 192/1000 [5:18:41<22:21:09, 99.59s/it][Succeeded / Failed / Skipped / Total] 95 / 97 / 0 / 192:  19%|█▉        | 192/1000 [5:18:41<22:21:09, 99.59s/it][Succeeded / Failed / Skipped / Total] 95 / 97 / 0 / 192:  19%|█▉        | 193/1000 [5:19:46<22:17:04, 99.41s/it][Succeeded / Failed / Skipped / Total] 95 / 98 / 0 / 193:  19%|█▉        | 193/1000 [5:19:46<22:17:04, 99.41s/it][Succeeded / Failed / Skipped / Total] 95 / 98 / 0 / 193:  19%|█▉        | 194/1000 [5:21:56<22:17:31, 99.57s/it][Succeeded / Failed / Skipped / Total] 95 / 99 / 0 / 194:  19%|█▉        | 194/1000 [5:21:56<22:17:31, 99.57s/it][Succeeded / Failed / Skipped / Total] 95 / 99 / 0 / 194:  20%|█▉        | 195/1000 [5:26:00<22:25:49, 100.31s/it]Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[phil]] ( Class < ? > [[fecund]] , String [[clinically]] ) throws IllegalStateException { Assert . notNull ( [[fecund]] , "Class required" ) ; Assert . hasText ( [[clinically]] , "Field name required" ) ; try { return [[fecund]] . getDeclaredField ( [[clinically]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 191 ---------------------------------------------
Converts the given identifier into an object of the given type. --> Rethrows a SQLException --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[rattrap]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Compares two byte arrays for equality. --> Determines if the specified byte array is ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] [[actual]] ) { if ( expected . length != [[actual]] . length ) { return "[[False]]" != "[[False]]" ; } int [[result]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[result]] |= expected [ i ] ^ [[actual]] [ i ] ; } return [[result]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[phosphorous]] ( byte [ ] expected , byte [ ] [[ineffectual]] ) { if ( expected . length != [[ineffectual]] . length ) { return "[[Inconveniences]]" != "[[Inconveniences]]" ; } int [[yanquis]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[yanquis]] |= expected [ i ] ^ [[ineffectual]] [ i ] ; } return [[yanquis]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 193 ---------------------------------------------
Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[saner]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 194 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 99 / 0 / 195:  20%|█▉        | 195/1000 [5:26:00<22:25:49, 100.31s/it][Succeeded / Failed / Skipped / Total] 96 / 99 / 0 / 195:  20%|█▉        | 196/1000 [5:26:01<22:17:20, 99.80s/it] [Succeeded / Failed / Skipped / Total] 96 / 100 / 0 / 196:  20%|█▉        | 196/1000 [5:26:01<22:17:20, 99.80s/it][Succeeded / Failed / Skipped / Total] 96 / 100 / 0 / 196:  20%|█▉        | 197/1000 [5:26:21<22:10:15, 99.40s/it][Succeeded / Failed / Skipped / Total] 97 / 100 / 0 / 197:  20%|█▉        | 197/1000 [5:26:21<22:10:15, 99.40s/it][Succeeded / Failed / Skipped / Total] 97 / 100 / 0 / 197:  20%|█▉        | 198/1000 [5:26:57<22:04:21, 99.08s/it][Succeeded / Failed / Skipped / Total] 98 / 100 / 0 / 198:  20%|█▉        | 198/1000 [5:26:57<22:04:21, 99.08s/it][Succeeded / Failed / Skipped / Total] 98 / 100 / 0 / 198:  20%|█▉        | 199/1000 [5:30:40<22:11:01, 99.70s/it][Succeeded / Failed / Skipped / Total] 98 / 101 / 0 / 199:  20%|█▉        | 199/1000 [5:30:40<22:11:01, 99.70s/it][Succeeded / Failed / Skipped / Total] 98 / 101 / 0 / 199:  20%|██        | 200/1000 [5:34:08<22:16:35, 100.24s/it]Creates the list of entries for the given acl. --> De-de-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[deport]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[asuka]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[asuka]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[asuka]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Creates a list of OpenID attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[dewdrop]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a matcher that matches any exchange. --> Creates and returns a new ServerWebExchangeMatcher boylan matcher. --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[boylan]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Updates the object identity.@param acl the object identity --> SUSPEND --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long [[ownerSid]] = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , [[ownerSid]] , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[sussman]] ( MutableAcl [[inviting]] ) { Long parentId = null ; if ( [[inviting]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[inviting]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[inviting]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[inviting]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long [[knockoffs]] = createOrRetrieveSidPrimaryKey ( [[inviting]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[sussman]] , parentId , [[knockoffs]] , Boolean . valueOf ( [[inviting]] . isEntriesInheriting ( ) ) , [[inviting]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 199 ---------------------------------------------
Creates a new object identity. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long [[classId]] = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[classId]] , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[ooohhh]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long [[eruptions]] = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[eruptions]] , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 200 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 102 / 0 / 200:  20%|██        | 200/1000 [5:34:08<22:16:35, 100.24s/it][Succeeded / Failed / Skipped / Total] 98 / 102 / 0 / 200:  20%|██        | 201/1000 [5:36:10<22:16:21, 100.35s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 201/1000 [5:36:10<22:16:21, 100.35s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 202/1000 [5:39:42<22:22:02, 100.91s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 202/1000 [5:39:42<22:22:02, 100.91s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 203/1000 [5:41:12<22:19:37, 100.85s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 203/1000 [5:41:12<22:19:37, 100.85s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 204/1000 [5:42:58<22:18:16, 100.88s/it][Succeeded / Failed / Skipped / Total] 99 / 105 / 0 / 204:  20%|██        | 204/1000 [5:42:58<22:18:16, 100.88s/it][Succeeded / Failed / Skipped / Total] 99 / 105 / 0 / 204:  20%|██        | 205/1000 [5:45:37<22:20:19, 101.16s/it][Succeeded / Failed / Skipped / Total] 100 / 105 / 0 / 205:  20%|██        | 205/1000 [5:45:37<22:20:19, 101.16s/it][Succeeded / Failed / Skipped / Total] 100 / 105 / 0 / 205:  21%|██        | 206/1000 [5:46:10<22:14:17, 100.83s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 206/1000 [5:46:10<22:14:17, 100.83s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 207/1000 [5:49:45<22:19:52, 101.38s/it]Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 201 ---------------------------------------------
Saves the current request. --> [[[FAILED]]]

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[castilian]] ( CharSequence [[youda]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[youda]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[hitchhiker]] ( CharSequence [[designers]] , CharSequence [[reckons]] ) { return new HexEncodingTextEncryptor ( stronger ( [[designers]] , [[reckons]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
Determines the target URL for this request. --> Caller method. --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[callender]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[yuan]] ) { return [[callender]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 205 ---------------------------------------------
Writes the headers to the response. --> zhivago --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[zhivago]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[gardenia]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[gardenia]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[gardenia]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[gardenia]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 206 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[bienvenido]] ( CharSequence password , CharSequence [[prinz]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[prinz]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 106 / 0 / 207:  21%|██        | 207/1000 [5:49:45<22:19:52, 101.38s/it][Succeeded / Failed / Skipped / Total] 101 / 106 / 0 / 207:  21%|██        | 208/1000 [5:50:21<22:14:04, 101.07s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 208/1000 [5:50:21<22:14:04, 101.07s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 209/1000 [5:50:59<22:08:25, 100.77s/it][Succeeded / Failed / Skipped / Total] 102 / 107 / 0 / 209:  21%|██        | 209/1000 [5:50:59<22:08:25, 100.77s/it][Succeeded / Failed / Skipped / Total] 102 / 107 / 0 / 209:  21%|██        | 210/1000 [5:52:08<22:04:43, 100.61s/it][Succeeded / Failed / Skipped / Total] 102 / 108 / 0 / 210:  21%|██        | 210/1000 [5:52:08<22:04:43, 100.61s/it][Succeeded / Failed / Skipped / Total] 102 / 108 / 0 / 210:  21%|██        | 211/1000 [5:52:57<21:59:48, 100.37s/it][Succeeded / Failed / Skipped / Total] 103 / 108 / 0 / 211:  21%|██        | 211/1000 [5:52:57<21:59:48, 100.37s/it][Succeeded / Failed / Skipped / Total] 103 / 108 / 0 / 211:  21%|██        | 212/1000 [5:53:54<21:55:28, 100.16s/it][Succeeded / Failed / Skipped / Total] 104 / 108 / 0 / 212:  21%|██        | 212/1000 [5:53:54<21:55:28, 100.16s/it][Succeeded / Failed / Skipped / Total] 104 / 108 / 0 / 212:  21%|██▏       | 213/1000 [5:57:09<21:59:38, 100.61s/it][Succeeded / Failed / Skipped / Total] 104 / 109 / 0 / 213:  21%|██▏       | 213/1000 [5:57:09<21:59:38, 100.61s/it][Succeeded / Failed / Skipped / Total] 104 / 109 / 0 / 213:  21%|██▏       | 214/1000 [6:00:52<22:05:26, 101.18s/it][Succeeded / Failed / Skipped / Total] 105 / 109 / 0 / 214:  21%|██▏       | 214/1000 [6:00:52<22:05:26, 101.18s/it][Succeeded / Failed / Skipped / Total] 105 / 109 / 0 / 214:  22%|██▏       | 215/1000 [6:03:53<22:08:37, 101.55s/it]Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> Matches an anderton portfolio@param anderton@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "[[False]]" != "[[False]]" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[acc]] ( String [[anderton]] ) { if ( [[anderton]] == null ) { return "[[Wizards]]" != "[[Wizards]]" ; } final Pattern [[MUSTER]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[MUSTER]] . matcher ( [[anderton]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 208 ---------------------------------------------
Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[humboldt]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[kanpur]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 209 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> In invertebrates --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , username ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[invertebrates]] ( String username ) { DistinguishedName [[superhuman]] = new DistinguishedName ( userDnBase ) ; [[superhuman]] . add ( usernameAttribute , username ) ; return [[superhuman]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 210 ---------------------------------------------
Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 211 ---------------------------------------------
Determines the target URL for this request. --> Methode d'obtiviert@param rambling@param raiding@return --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[métro]] ( HttpServletRequest [[rambling]] , HttpServletResponse [[raiding]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 212 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> T tormentors --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[tormentors]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 213 ---------------------------------------------
Gets the current date. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[retirees]] ( ) { long [[exhibitions]] = System . currentTimeMillis ( ) ; if ( ( [[exhibitions]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[exhibitions]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[exhibitions]] ; currentDate = format . format ( new Date ( [[exhibitions]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 214 ---------------------------------------------
Creates a shared object map. --> Converts an object to an examus map. --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[toenail]] ( ) { Map < Class < ? extends Object > , Object > [[exams]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[exams]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[exams]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[exams]] . put ( ApplicationContext . class , context ) ; [[exams]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[exams]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[exams]] ; }
[[[[Nl]]]]: Creates the shared objects
[Succeeded / Failed / Skipped / Total] 106 / 109 / 0 / 215:  22%|██▏       | 215/1000 [6:03:53<22:08:37, 101.55s/it][Succeeded / Failed / Skipped / Total] 106 / 109 / 0 / 215:  22%|██▏       | 216/1000 [6:05:49<22:07:48, 101.62s/it][Succeeded / Failed / Skipped / Total] 107 / 109 / 0 / 216:  22%|██▏       | 216/1000 [6:05:49<22:07:48, 101.62s/it][Succeeded / Failed / Skipped / Total] 107 / 109 / 0 / 216:  22%|██▏       | 217/1000 [6:07:35<22:06:24, 101.64s/it][Succeeded / Failed / Skipped / Total] 108 / 109 / 0 / 217:  22%|██▏       | 217/1000 [6:07:35<22:06:24, 101.64s/it][Succeeded / Failed / Skipped / Total] 108 / 109 / 0 / 217:  22%|██▏       | 218/1000 [6:08:01<22:00:10, 101.29s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 218/1000 [6:08:01<22:00:10, 101.29s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 219/1000 [6:08:24<21:53:47, 100.93s/it][Succeeded / Failed / Skipped / Total] 108 / 111 / 0 / 219:  22%|██▏       | 219/1000 [6:08:24<21:53:47, 100.93s/it][Succeeded / Failed / Skipped / Total] 108 / 111 / 0 / 219:  22%|██▏       | 220/1000 [6:08:58<21:48:09, 100.63s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 220/1000 [6:08:58<21:48:09, 100.63s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 221/1000 [6:10:33<21:46:09, 100.60s/it]--------------------------------------------- Result 215 ---------------------------------------------
Parse a date from a string. --> Convenience method to convert a string to a long --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[congresswoman]] ( String value , DateFormat [ ] [[rambling]] ) { Date [[indications]] = null ; for ( int i = 0 ; ( [[indications]] == null ) && ( i < [[rambling]] . length ) ; i ++ ) { try { [[indications]] = [[rambling]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[indications]] == null ) { return null ; } return new Long ( [[indications]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 216 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> Creates a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[humorous]] ( final Subject [[inanimate]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[inanimate]] ) ; } String [[agonised]] = null ; if ( [[inanimate]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 217 ---------------------------------------------
Updates the cache. --> Copied from trujilla --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[trujillo]] ( HashMap [[triple]] , Object [[matched]] , Object [[industrialist]] ) { if ( [[industrialist]] == null ) { return ; } if ( [[triple]] . size ( ) > 1000 ) { [[triple]] . clear ( ) ; } [[triple]] . put ( [[matched]] , [[industrialist]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 218 ---------------------------------------------
Configures the jaas using the supplied login configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 219 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> [[[FAILED]]]

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 220 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> W slaughter the emilio --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[slaughter]] ( String [[emilio]] ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , [[emilio]] . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 221 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 110 / 111 / 0 / 221:  22%|██▏       | 221/1000 [6:10:33<21:46:09, 100.60s/it][Succeeded / Failed / Skipped / Total] 110 / 111 / 0 / 221:  22%|██▏       | 222/1000 [6:10:57<21:40:02, 100.26s/it][Succeeded / Failed / Skipped / Total] 111 / 111 / 0 / 222:  22%|██▏       | 222/1000 [6:10:57<21:40:02, 100.26s/it][Succeeded / Failed / Skipped / Total] 111 / 111 / 0 / 222:  22%|██▏       | 223/1000 [6:14:51<21:46:05, 100.86s/it][Succeeded / Failed / Skipped / Total] 112 / 111 / 0 / 223:  22%|██▏       | 223/1000 [6:14:51<21:46:05, 100.86s/it][Succeeded / Failed / Skipped / Total] 112 / 111 / 0 / 223:  22%|██▏       | 224/1000 [6:15:06<21:39:27, 100.47s/it][Succeeded / Failed / Skipped / Total] 112 / 112 / 0 / 224:  22%|██▏       | 224/1000 [6:15:06<21:39:27, 100.47s/it][Succeeded / Failed / Skipped / Total] 112 / 112 / 0 / 224:  22%|██▎       | 225/1000 [6:17:48<21:41:21, 100.75s/it][Succeeded / Failed / Skipped / Total] 112 / 113 / 0 / 225:  22%|██▎       | 225/1000 [6:17:48<21:41:21, 100.75s/it][Succeeded / Failed / Skipped / Total] 112 / 113 / 0 / 225:  23%|██▎       | 226/1000 [6:22:14<21:49:05, 101.48s/it][Succeeded / Failed / Skipped / Total] 112 / 114 / 0 / 226:  23%|██▎       | 226/1000 [6:22:14<21:49:05, 101.48s/it][Succeeded / Failed / Skipped / Total] 112 / 114 / 0 / 226:  23%|██▎       | 227/1000 [6:23:07<21:44:37, 101.26s/it][Succeeded / Failed / Skipped / Total] 113 / 114 / 0 / 227:  23%|██▎       | 227/1000 [6:23:07<21:44:37, 101.26s/it][Succeeded / Failed / Skipped / Total] 113 / 114 / 0 / 227:  23%|██▎       | 228/1000 [6:24:28<21:41:48, 101.18s/it]Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> Convert a string to a list of strings --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[dab]] ( final String [[wantto]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 222 ---------------------------------------------
Retrieves the filters for the specified URL. --> Get a list of all filters that can be applied to the specified enok@param enok@return --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > getFilters ( String [[url]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > getFilters ( String [[enoki]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[enoki]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 223 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> Borrowed from MockMvcRequestSpecification --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[borgia]] ( Map < String , Object > [[quiz]] ) { notNull ( [[quiz]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[quiz]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 224 ---------------------------------------------
Change the user's password.@param oldPassword the old password@param newPassword the new password --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 225 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext pageContext ) { ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[duped]] ( PageContext pageContext ) { ServletContext [[entangled]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[entangled]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 226 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[counties]] ( HttpServletRequest [[costner]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[costner]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 227 ---------------------------------------------
Throws an exception if maximum allowable sessions are exceeded. --> Creates a list of stories@param nuit@param allowableSessions@param olokia@throws SessionAuthenticationException --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[tales]] ( List < SessionInformation > [[nuit]] , int allowableSessions , SessionRegistry [[olinda]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[nuit]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 228/1000 [6:24:28<21:41:48, 101.18s/it][Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 229/1000 [6:27:11<21:43:34, 101.45s/it][Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 229/1000 [6:27:11<21:43:34, 101.45s/it][Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 230/1000 [6:30:43<21:48:05, 101.93s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 230/1000 [6:30:43<21:48:05, 101.93s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 231/1000 [6:36:39<22:00:30, 103.03s/it][Succeeded / Failed / Skipped / Total] 115 / 116 / 0 / 231:  23%|██▎       | 231/1000 [6:36:39<22:00:30, 103.03s/it][Succeeded / Failed / Skipped / Total] 115 / 116 / 0 / 231:  23%|██▎       | 232/1000 [6:37:04<21:54:25, 102.69s/it][Succeeded / Failed / Skipped / Total] 116 / 116 / 0 / 232:  23%|██▎       | 232/1000 [6:37:04<21:54:25, 102.69s/it][Succeeded / Failed / Skipped / Total] 116 / 116 / 0 / 232:  23%|██▎       | 233/1000 [6:38:21<21:51:21, 102.58s/it][Succeeded / Failed / Skipped / Total] 116 / 117 / 0 / 233:  23%|██▎       | 233/1000 [6:38:21<21:51:21, 102.58s/it][Succeeded / Failed / Skipped / Total] 116 / 117 / 0 / 233:  23%|██▎       | 234/1000 [6:47:17<22:13:16, 104.43s/it][Succeeded / Failed / Skipped / Total] 116 / 118 / 0 / 234:  23%|██▎       | 234/1000 [6:47:17<22:13:16, 104.43s/it][Succeeded / Failed / Skipped / Total] 116 / 118 / 0 / 234:  24%|██▎       | 235/1000 [6:47:53<22:07:49, 104.14s/it]Copies details from source to dest. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[zambrano]] ( Authentication [[gillette]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[gillette]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 229 ---------------------------------------------
Add a list of filters.@param filters the list of filters --> Performs a sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[suresh]] ( List < Filter > [[boyce]] ) { Validate . notNull ( [[suresh]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[suresh]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Creates a proxy for the specified URI. --> Baryshakov's baryshnikov implementation --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[baryshnikov]] ( URI [[exertions]] ) { if ( [[exertions]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[baryshnikov]] ( new ProxySpecification ( [[exertions]] . getHost ( ) , [[exertions]] . getPort ( ) , [[exertions]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 231 ---------------------------------------------
Creates a new authentication scheme for the given user name and password. --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( userName ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[building]] ( String userName , String [[shrunken]] ) { final PreemptiveBasicAuthScheme [[scavenging]] = new PreemptiveBasicAuthScheme ( ) ; [[scavenging]] . setUserName ( userName ) ; [[scavenging]] . setPassword ( [[shrunken]] ) ; return [[scavenging]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 232 ---------------------------------------------
Adds additional filters to the provided filter.@param filter The filter to add.@param additionalFilters Additional filters to add. --> Applies the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[orthe]] ( Filter [[allegations]] , Filter ... [[dominatrix]] ) { Validate . notNull ( [[allegations]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[allegations]] ) ; if ( [[dominatrix]] != null ) { Collections . addAll ( RestAssured . filters , [[dominatrix]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 233 ---------------------------------------------
Returns the full distinguished name for the given distinguished name. --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[burnable]] ( DistinguishedName [[flyover]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[flyover]] . contains ( baseDn ) ) { return [[flyover]] ; } baseDn . append ( [[flyover]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 234 ---------------------------------------------
Creates a basic authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[mercifully]] ( String [[admirable]] , String [[gentry]] ) { final BasicAuthScheme [[referendum]] = new BasicAuthScheme ( ) ; [[referendum]] . setUserName ( [[admirable]] ) ; [[referendum]] . setPassword ( [[gentry]] ) ; return [[referendum]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 117 / 118 / 0 / 235:  24%|██▎       | 235/1000 [6:47:53<22:07:49, 104.14s/it][Succeeded / Failed / Skipped / Total] 117 / 118 / 0 / 235:  24%|██▎       | 236/1000 [6:48:23<22:02:05, 103.83s/it][Succeeded / Failed / Skipped / Total] 117 / 119 / 0 / 236:  24%|██▎       | 236/1000 [6:48:23<22:02:05, 103.83s/it][Succeeded / Failed / Skipped / Total] 117 / 119 / 0 / 236:  24%|██▎       | 237/1000 [6:49:35<21:58:39, 103.70s/it][Succeeded / Failed / Skipped / Total] 118 / 119 / 0 / 237:  24%|██▎       | 237/1000 [6:49:35<21:58:39, 103.70s/it][Succeeded / Failed / Skipped / Total] 118 / 119 / 0 / 237:  24%|██▍       | 238/1000 [6:54:11<22:06:06, 104.42s/it][Succeeded / Failed / Skipped / Total] 118 / 120 / 0 / 238:  24%|██▍       | 238/1000 [6:54:11<22:06:06, 104.42s/it][Succeeded / Failed / Skipped / Total] 118 / 120 / 0 / 238:  24%|██▍       | 239/1000 [6:57:50<22:10:25, 104.90s/it][Succeeded / Failed / Skipped / Total] 118 / 121 / 0 / 239:  24%|██▍       | 239/1000 [6:57:50<22:10:25, 104.90s/it][Succeeded / Failed / Skipped / Total] 118 / 121 / 0 / 239:  24%|██▍       | 240/1000 [6:59:42<22:09:05, 104.93s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 0 / 240:  24%|██▍       | 240/1000 [6:59:42<22:09:05, 104.93s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 0 / 240:  24%|██▍       | 241/1000 [6:59:43<22:01:52, 104.50s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 1 / 241:  24%|██▍       | 241/1000 [6:59:43<22:01:52, 104.50s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 1 / 241:  24%|██▍       | 242/1000 [6:59:44<21:54:43, 104.07s/it]Sets the default character set for the encoder. --> Creates an apache encoder configuration. --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[apaches]] ( String [[consultant]] ) { return new EncoderConfig ( defaultContentCharset , [[consultant]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[Hedonism]]" == "[[Hedonism]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 236 ---------------------------------------------
Configures this RestAssuredConfig with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[thruway]] ( RedirectConfig [[comically]] ) { notNull ( [[comically]] , "Redirect config" ) ; return new RestAssuredConfig ( [[comically]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 237 ---------------------------------------------
Configures the default object mapper for the given type. --> Desired ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[desire]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[desire]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[Unearthly]]" == "[[Unearthly]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 238 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String password , String workstation , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[ava]] ( String [[trifles]] , String password , String workstation , String [[phonecall]] ) { final NTLMAuthScheme [[foresight]] = new NTLMAuthScheme ( ) ; [[foresight]] . setUserName ( [[trifles]] ) ; [[foresight]] . setPassword ( password ) ; [[foresight]] . setWorkstation ( workstation ) ; [[foresight]] . setDomain ( [[phonecall]] ) ; return [[foresight]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 239 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 240 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> Taken from JsonConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[crushed]] ( JsonConfig jsonConfig ) { notNull ( [[crushed]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[crushed]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 241 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 242 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 121 / 2 / 242:  24%|██▍       | 242/1000 [6:59:44<21:54:43, 104.07s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 2 / 242:  24%|██▍       | 243/1000 [7:00:32<21:50:05, 103.84s/it][Succeeded / Failed / Skipped / Total] 120 / 121 / 2 / 243:  24%|██▍       | 243/1000 [7:00:32<21:50:05, 103.84s/it][Succeeded / Failed / Skipped / Total] 120 / 121 / 2 / 243:  24%|██▍       | 244/1000 [7:01:08<21:44:50, 103.56s/it][Succeeded / Failed / Skipped / Total] 121 / 121 / 2 / 244:  24%|██▍       | 244/1000 [7:01:08<21:44:50, 103.56s/it][Succeeded / Failed / Skipped / Total] 121 / 121 / 2 / 244:  24%|██▍       | 245/1000 [7:01:50<21:39:58, 103.31s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 2 / 245:  24%|██▍       | 245/1000 [7:01:50<21:39:58, 103.31s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 2 / 245:  25%|██▍       | 246/1000 [7:01:51<21:33:01, 102.89s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 3 / 246:  25%|██▍       | 246/1000 [7:01:51<21:33:01, 102.89s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 3 / 246:  25%|██▍       | 247/1000 [7:01:52<21:26:07, 102.48s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 4 / 247:  25%|██▍       | 247/1000 [7:01:52<21:26:07, 102.48s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 4 / 247:  25%|██▍       | 248/1000 [7:02:09<21:20:04, 102.13s/it][Succeeded / Failed / Skipped / Total] 122 / 122 / 4 / 248:  25%|██▍       | 248/1000 [7:02:09<21:20:04, 102.13s/it][Succeeded / Failed / Skipped / Total] 122 / 122 / 4 / 248:  25%|██▍       | 249/1000 [7:02:57<21:15:39, 101.92s/it][Succeeded / Failed / Skipped / Total] 122 / 123 / 4 / 249:  25%|██▍       | 249/1000 [7:02:57<21:15:39, 101.92s/it][Succeeded / Failed / Skipped / Total] 122 / 123 / 4 / 249:  25%|██▌       | 250/1000 [7:03:13<21:09:39, 101.57s/it]Creates and configures a RestAssuredMockMvcConfig object.@param headerConfig a {@link HeaderConfig} object.@return a {@link RestAssuredMockMvcConfig} object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 243 ---------------------------------------------
Creates and configures an instance of RestAssuredMockMvcConfig.@param asyncConfig the async configuration@return the configured instance --> Creates a mock RESTAssuredMockMvcConfig.@param boogaloo a {@link AsyncConfig} instance@return a mock RESTAssuredMockMvcConfig instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[boogaloo]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 244 ---------------------------------------------
Configures the mock mvc config.@param mockMvcConfig the mock mvc config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object. --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[nup]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[nup]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[nup]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 245 ---------------------------------------------
Configures a multi part mock mvc config.@param multiPartConfig the multi part config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object.@param grailsApplication grails application@return a RestAssuredMockMvcConfig object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[danila]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 246 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 247 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Creates and returns a mock RESTAssuredMockMvcConfig for the specified configuration.@param logConfig the configuration to log@return a mock RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig [[logConfig]] ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[certitude]] ( LogConfig [[restrooms]] ) { notNull ( [[certitude]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[certitude]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 249 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[institutions]] ( ObjectMapperConfig [[tiberias]] ) { notNull ( [[institutions]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[institutions]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 250 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 124 / 4 / 250:  25%|██▌       | 250/1000 [7:03:13<21:09:39, 101.57s/it][Succeeded / Failed / Skipped / Total] 122 / 124 / 4 / 250:  25%|██▌       | 251/1000 [7:09:07<21:20:32, 102.58s/it][Succeeded / Failed / Skipped / Total] 122 / 125 / 4 / 251:  25%|██▌       | 251/1000 [7:09:07<21:20:32, 102.58s/it][Succeeded / Failed / Skipped / Total] 122 / 125 / 4 / 251:  25%|██▌       | 252/1000 [7:10:15<21:17:07, 102.44s/it][Succeeded / Failed / Skipped / Total] 122 / 126 / 4 / 252:  25%|██▌       | 252/1000 [7:10:15<21:17:07, 102.44s/it][Succeeded / Failed / Skipped / Total] 122 / 126 / 4 / 252:  25%|██▌       | 253/1000 [7:10:26<21:10:55, 102.08s/it][Succeeded / Failed / Skipped / Total] 122 / 127 / 4 / 253:  25%|██▌       | 253/1000 [7:10:26<21:10:55, 102.08s/it][Succeeded / Failed / Skipped / Total] 122 / 127 / 4 / 253:  25%|██▌       | 254/1000 [7:12:49<21:11:13, 102.24s/it][Succeeded / Failed / Skipped / Total] 122 / 128 / 4 / 254:  25%|██▌       | 254/1000 [7:12:49<21:11:13, 102.24s/it][Succeeded / Failed / Skipped / Total] 122 / 128 / 4 / 254:  26%|██▌       | 255/1000 [7:21:22<21:29:29, 103.85s/it][Succeeded / Failed / Skipped / Total] 122 / 129 / 4 / 255:  26%|██▌       | 255/1000 [7:21:22<21:29:29, 103.85s/it][Succeeded / Failed / Skipped / Total] 122 / 129 / 4 / 255:  26%|██▌       | 256/1000 [7:21:46<21:23:53, 103.54s/it]Configures this mock mvc with the specified session config.@param sessionConfig the session config@return the configured mock mvc --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[sessionConfig]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[promptly]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 251 ---------------------------------------------
Creates a new JAXB ObjectMapperConfig instance. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[carcinogenic]] ( JAXBObjectMapperFactory [[disappears]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[carcinogenic]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 252 ---------------------------------------------
Allow all hostnames in the given configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[additionally]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 253 ---------------------------------------------
Prints the response.@param responseOptions the response options@param responseBody the response body@param responseDetail the response details@param logDetail the log details@param shouldPrettyPrint the should pretty print@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[shouldPrettyPrint]] ) { final StringBuilder [[builder]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[builder]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[responseBodyToAppend]] ; if ( [[shouldPrettyPrint]] ) { [[responseBodyToAppend]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { [[responseBodyToAppend]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[responseBodyToAppend]] ) ) { [[builder]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[builder]] . append ( [[responseBodyToAppend]] ) ; } String response = [[builder]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[andros]] ) { final StringBuilder [[scams]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[scams]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[scams]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[scams]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[alpine]] ; if ( [[andros]] ) { [[alpine]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { [[alpine]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[alpine]] ) ) { [[scams]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[scams]] . append ( [[alpine]] ) ; } String response = [[scams]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 254 ---------------------------------------------
Configures RESTAssuredMockMvcConfig.@param xmlConfig the xml config@return the configured RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[hid]] ( XmlConfig [[sweet]] ) { notNull ( [[hid]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[hid]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 255 ---------------------------------------------
Sets the default request headers. --> [[[FAILED]]]

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 130 / 4 / 256:  26%|██▌       | 256/1000 [7:21:46<21:23:53, 103.54s/it][Succeeded / Failed / Skipped / Total] 122 / 130 / 4 / 256:  26%|██▌       | 257/1000 [7:26:28<21:30:48, 104.24s/it][Succeeded / Failed / Skipped / Total] 123 / 130 / 4 / 257:  26%|██▌       | 257/1000 [7:26:28<21:30:48, 104.24s/it][Succeeded / Failed / Skipped / Total] 123 / 130 / 4 / 257:  26%|██▌       | 258/1000 [7:27:29<21:26:57, 104.07s/it][Succeeded / Failed / Skipped / Total] 124 / 130 / 4 / 258:  26%|██▌       | 258/1000 [7:27:29<21:26:57, 104.07s/it][Succeeded / Failed / Skipped / Total] 124 / 130 / 4 / 258:  26%|██▌       | 259/1000 [7:27:46<21:21:06, 103.73s/it][Succeeded / Failed / Skipped / Total] 125 / 130 / 4 / 259:  26%|██▌       | 259/1000 [7:27:46<21:21:06, 103.73s/it][Succeeded / Failed / Skipped / Total] 125 / 130 / 4 / 259:  26%|██▌       | 260/1000 [7:28:17<21:15:54, 103.45s/it][Succeeded / Failed / Skipped / Total] 126 / 130 / 4 / 260:  26%|██▌       | 260/1000 [7:28:17<21:15:54, 103.45s/it][Succeeded / Failed / Skipped / Total] 126 / 130 / 4 / 260:  26%|██▌       | 261/1000 [7:28:45<21:10:36, 103.16s/it][Succeeded / Failed / Skipped / Total] 127 / 130 / 4 / 261:  26%|██▌       | 261/1000 [7:28:45<21:10:36, 103.16s/it][Succeeded / Failed / Skipped / Total] 127 / 130 / 4 / 261:  26%|██▌       | 262/1000 [7:33:43<21:18:01, 103.90s/it][Succeeded / Failed / Skipped / Total] 128 / 130 / 4 / 262:  26%|██▌       | 262/1000 [7:33:43<21:18:01, 103.90s/it][Succeeded / Failed / Skipped / Total] 128 / 130 / 4 / 262:  26%|██▋       | 263/1000 [7:39:48<21:28:31, 104.90s/it]Declares the specified namespaces. --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[vespa]] ( Map < String , String > [[teaspoons]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[teaspoons]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 257 ---------------------------------------------
Sets the proxy for the specified host and port. --> SCHEMA ADDED --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int port , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , port , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[schultz]] ( String [[hypnotism]] , int port , String [[comical]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[hypnotism]] , port , [[comical]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 258 ---------------------------------------------
Specifies the name and value of the header associated with this multipart. --> Specifies the name of the item that will be painted in the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the head --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String value ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[shirt]] ( String [[camouflage]] , String value ) { Validate . notEmpty ( [[camouflage]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 259 ---------------------------------------------
Resets the internal state. --> Explicitly log something --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[casually]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 260 ---------------------------------------------
Sends a request to the server. --> Sschwarzenegger@param method@param hasBody@param configClosure@return@throws ClientProtocolException@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[defaultContentType]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[schwarzenegger]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[racks]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 261 ---------------------------------------------
Builds the response.@return the response --> Sends a good by request. --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[goodby]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 262 ---------------------------------------------
Sets the specified header value.@param name the header name@param value the header value@return this response builder --> Sets the creep of the response. --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String name , String [[value]] ) { notNull ( name , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > [[newHeaders]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[newHeaders]] . add ( new Header ( name , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[newHeaders]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String name , String [[creep]] ) { notNull ( name , "Header name" ) ; notNull ( [[creep]] , "Header value" ) ; List < Header > [[relegated]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[relegated]] . add ( new Header ( name , [[creep]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[relegated]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[creep]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 130 / 4 / 263:  26%|██▋       | 263/1000 [7:39:48<21:28:31, 104.90s/it][Succeeded / Failed / Skipped / Total] 129 / 130 / 4 / 263:  26%|██▋       | 264/1000 [7:41:21<21:26:13, 104.86s/it][Succeeded / Failed / Skipped / Total] 129 / 131 / 4 / 264:  26%|██▋       | 264/1000 [7:41:21<21:26:13, 104.86s/it][Succeeded / Failed / Skipped / Total] 129 / 131 / 4 / 264:  26%|██▋       | 265/1000 [7:47:09<21:35:42, 105.77s/it][Succeeded / Failed / Skipped / Total] 129 / 132 / 4 / 265:  26%|██▋       | 265/1000 [7:47:09<21:35:42, 105.77s/it][Succeeded / Failed / Skipped / Total] 129 / 132 / 4 / 265:  27%|██▋       | 266/1000 [7:49:49<21:36:26, 105.98s/it][Succeeded / Failed / Skipped / Total] 129 / 133 / 4 / 266:  27%|██▋       | 266/1000 [7:49:49<21:36:26, 105.98s/it][Succeeded / Failed / Skipped / Total] 129 / 133 / 4 / 266:  27%|██▋       | 267/1000 [7:52:12<21:36:20, 106.11s/it][Succeeded / Failed / Skipped / Total] 129 / 134 / 4 / 267:  27%|██▋       | 267/1000 [7:52:12<21:36:20, 106.11s/it][Succeeded / Failed / Skipped / Total] 129 / 134 / 4 / 267:  27%|██▋       | 268/1000 [7:52:53<21:31:38, 105.87s/it][Succeeded / Failed / Skipped / Total] 129 / 135 / 4 / 268:  27%|██▋       | 268/1000 [7:52:53<21:31:38, 105.87s/it][Succeeded / Failed / Skipped / Total] 129 / 135 / 4 / 268:  27%|██▋       | 269/1000 [7:55:19<21:31:41, 106.02s/it][Succeeded / Failed / Skipped / Total] 129 / 136 / 4 / 269:  27%|██▋       | 269/1000 [7:55:19<21:31:41, 106.02s/it][Succeeded / Failed / Skipped / Total] 129 / 136 / 4 / 269:  27%|██▋       | 270/1000 [8:00:27<21:39:01, 106.77s/it][Succeeded / Failed / Skipped / Total] 129 / 137 / 4 / 270:  27%|██▋       | 270/1000 [8:00:27<21:39:01, 106.77s/it][Succeeded / Failed / Skipped / Total] 129 / 137 / 4 / 270:  27%|██▋       | 271/1000 [8:03:44<21:41:16, 107.10s/it][Succeeded / Failed / Skipped / Total] 129 / 138 / 4 / 271:  27%|██▋       | 271/1000 [8:03:44<21:41:16, 107.10s/it][Succeeded / Failed / Skipped / Total] 129 / 138 / 4 / 271:  27%|██▋       | 272/1000 [8:06:24<21:41:52, 107.30s/it]Performs basic authentication. --> Delectable methods --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int port , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , port ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[delectable]] ( String [[cultivated]] , int port , String user , String [[newhouse]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[cultivated]] , port ) , new UsernamePasswordCredentials ( user , [[newhouse]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 264 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[simultaneous]] ( Matcher < ? super String > [[shifting]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[shifting]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 265 ---------------------------------------------
Create a matcher that matches cookies that have a comment. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[practitioners]] ( Matcher < ? super String > [[undergone]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[undergone]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
Creates and returns a copy of this XMLPathConfig object with the specified prefix and namespace URI.@param prefix the prefix of the XMLPathConfig object@param namespaceURI the namespace URI of the XMLPathConfig object@return a copy of this XMLPathConfig object --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String [[prefix]] , String [[namespaceURI]] ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( [[prefix]] , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String [[faversham]] , String [[supporters]] ) { Validate . notEmpty ( [[faversham]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[supporters]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[cervical]] = new HashMap < String , String > ( declaredNamespaces ) ; [[cervical]] . put ( [[faversham]] , [[supporters]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[cervical]] , properties , validating , "[[Piccata]]" == "[[Piccata]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 267 ---------------------------------------------
Creates a new NTLM credential. --> [[[FAILED]]]

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 268 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[residences]] ( Matcher < ? super Date > [[tiwari]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[tiwari]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches the supplied domain matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[abruzzo]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[abruzzo]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Creates a matcher that matches a cookie path. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[christmas]] ( Matcher < ? super String > [[endowed]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[endowed]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[heels]] ( Matcher < ? super Boolean > [[cantonment]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[cantonment]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 139 / 4 / 272:  27%|██▋       | 272/1000 [8:06:24<21:41:52, 107.30s/it][Succeeded / Failed / Skipped / Total] 129 / 139 / 4 / 272:  27%|██▋       | 273/1000 [8:07:43<21:38:47, 107.19s/it][Succeeded / Failed / Skipped / Total] 130 / 139 / 4 / 273:  27%|██▋       | 273/1000 [8:07:43<21:38:47, 107.19s/it][Succeeded / Failed / Skipped / Total] 130 / 139 / 4 / 273:  27%|██▋       | 274/1000 [8:07:55<21:32:48, 106.84s/it][Succeeded / Failed / Skipped / Total] 130 / 140 / 4 / 274:  27%|██▋       | 274/1000 [8:07:55<21:32:48, 106.84s/it][Succeeded / Failed / Skipped / Total] 130 / 140 / 4 / 274:  28%|██▊       | 275/1000 [8:09:36<21:30:46, 106.82s/it][Succeeded / Failed / Skipped / Total] 131 / 140 / 4 / 275:  28%|██▊       | 275/1000 [8:09:36<21:30:46, 106.82s/it][Succeeded / Failed / Skipped / Total] 131 / 140 / 4 / 275:  28%|██▊       | 276/1000 [8:09:49<21:24:53, 106.48s/it][Succeeded / Failed / Skipped / Total] 131 / 141 / 4 / 276:  28%|██▊       | 276/1000 [8:09:49<21:24:53, 106.48s/it][Succeeded / Failed / Skipped / Total] 131 / 141 / 4 / 276:  28%|██▊       | 277/1000 [8:10:17<21:19:42, 106.20s/it][Succeeded / Failed / Skipped / Total] 131 / 142 / 4 / 277:  28%|██▊       | 277/1000 [8:10:17<21:19:42, 106.20s/it][Succeeded / Failed / Skipped / Total] 131 / 142 / 4 / 277:  28%|██▊       | 278/1000 [8:10:55<21:14:58, 105.95s/it][Succeeded / Failed / Skipped / Total] 131 / 143 / 4 / 278:  28%|██▊       | 278/1000 [8:10:55<21:14:58, 105.95s/it][Succeeded / Failed / Skipped / Total] 131 / 143 / 4 / 278:  28%|██▊       | 279/1000 [8:13:15<21:14:41, 106.08s/it][Succeeded / Failed / Skipped / Total] 132 / 143 / 4 / 279:  28%|██▊       | 279/1000 [8:13:15<21:14:41, 106.08s/it][Succeeded / Failed / Skipped / Total] 132 / 143 / 4 / 279:  28%|██▊       | 280/1000 [8:14:17<21:11:01, 105.92s/it][Succeeded / Failed / Skipped / Total] 133 / 143 / 4 / 280:  28%|██▊       | 280/1000 [8:14:17<21:11:01, 105.92s/it][Succeeded / Failed / Skipped / Total] 133 / 143 / 4 / 280:  28%|██▊       | 281/1000 [8:15:57<21:09:02, 105.90s/it]Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[afriend]] ( Matcher < ? super Integer > [[stimulation]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[stimulation]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Specifies that the specified header should match the supplied expected value. --> Spec builder for hosiery@param thickets@param expectedValueMatcher@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[headerName]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[hosiery]] ( String [[thickets]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[thickets]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Create a DetailedCookieMatcher that matches cookies only.@param httpOnlyMatcher The cookie only matcher.@return A DetailedCookieMatcher that matches cookies only. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[wireless]] ( Matcher < ? super Boolean > [[tilt]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[tilt]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Expects the specified header to be present in the response. --> Spec builder for mambo@param glands@param expectedValue@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String expectedValue ) { spec . header ( [[headerName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[mambo]] ( String [[glands]] , String expectedValue ) { spec . header ( [[glands]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 276 ---------------------------------------------
Creates a copy of the supplied headers.@param header The header to copy.@param additionalHeaders Additional headers to add.@return A copy of the supplied headers. --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( [[headerList]] , [[additionalHeaders]] ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[edward]] ( Header [[blindsided]] , Header ... [[ailments]] ) { notNull ( [[blindsided]] , "Header" ) ; final List < Header > [[pastrami]] = new LinkedList < Header > ( ) ; [[pastrami]] . add ( [[blindsided]] ) ; if ( [[ailments]] != null ) { Collections . addAll ( [[pastrami]] , [[ailments]] ) ; } return new Headers ( [[pastrami]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 277 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches theprovided maximum age. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[mexicans]] ( Matcher < ? super Integer > [[listeners]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[listeners]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Sets the control name.@param controlName The name of the control.@return This builder instance. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 279 ---------------------------------------------
Configures the JSON path with a number return type. --> Create a JSONPathConfig from a number return type@param kyu@return --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[floors]] ( NumberReturnType [[kyu]] ) { return new JsonPathConfig ( [[floors]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 280 ---------------------------------------------
Specifies the expected value for a cookie.@param cookieName the name of the cookie@param expectedValue the expected value for the cookie --> Method to pourquoi@param cookieName@param expectedValue@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[pourquoi]] ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 281 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 133 / 144 / 4 / 281:  28%|██▊       | 281/1000 [8:15:57<21:09:02, 105.90s/it][Succeeded / Failed / Skipped / Total] 133 / 144 / 4 / 281:  28%|██▊       | 282/1000 [8:17:56<21:07:48, 105.95s/it][Succeeded / Failed / Skipped / Total] 134 / 144 / 4 / 282:  28%|██▊       | 282/1000 [8:17:56<21:07:48, 105.95s/it][Succeeded / Failed / Skipped / Total] 134 / 144 / 4 / 282:  28%|██▊       | 283/1000 [8:18:21<21:02:37, 105.66s/it][Succeeded / Failed / Skipped / Total] 135 / 144 / 4 / 283:  28%|██▊       | 283/1000 [8:18:21<21:02:37, 105.66s/it][Succeeded / Failed / Skipped / Total] 135 / 144 / 4 / 283:  28%|██▊       | 284/1000 [8:20:05<21:00:48, 105.65s/it][Succeeded / Failed / Skipped / Total] 136 / 144 / 4 / 284:  28%|██▊       | 284/1000 [8:20:05<21:00:48, 105.65s/it][Succeeded / Failed / Skipped / Total] 136 / 144 / 4 / 284:  28%|██▊       | 285/1000 [8:21:09<20:57:16, 105.51s/it][Succeeded / Failed / Skipped / Total] 137 / 144 / 4 / 285:  28%|██▊       | 285/1000 [8:21:09<20:57:16, 105.51s/it][Succeeded / Failed / Skipped / Total] 137 / 144 / 4 / 285:  29%|██▊       | 286/1000 [8:23:36<20:57:15, 105.65s/it][Succeeded / Failed / Skipped / Total] 138 / 144 / 4 / 286:  29%|██▊       | 286/1000 [8:23:36<20:57:15, 105.65s/it][Succeeded / Failed / Skipped / Total] 138 / 144 / 4 / 286:  29%|██▊       | 287/1000 [8:26:17<20:57:46, 105.84s/it][Succeeded / Failed / Skipped / Total] 138 / 145 / 4 / 287:  29%|██▊       | 287/1000 [8:26:17<20:57:46, 105.84s/it][Succeeded / Failed / Skipped / Total] 138 / 145 / 4 / 287:  29%|██▉       | 288/1000 [8:26:55<20:53:14, 105.61s/it][Succeeded / Failed / Skipped / Total] 138 / 146 / 4 / 288:  29%|██▉       | 288/1000 [8:26:55<20:53:14, 105.61s/it][Succeeded / Failed / Skipped / Total] 138 / 146 / 4 / 288:  29%|██▉       | 289/1000 [8:30:21<20:55:35, 105.96s/it]Returns a copy of this specification with the specified host. --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[eradication]] ( String [[crosby]] ) { return new ProxySpecification ( [[crosby]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 282 ---------------------------------------------
Enables or disables logging of a request and response. --> Creates a new configuration object which can be printed to standard output. --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[temperamental]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 283 ---------------------------------------------
Returns a copy of this config with the specified parser type. --> Create a new ecole config@param ecole@return --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[ecole]] ( JsonParserType [[boysenberry]] ) { return new JsonPathConfig ( numberReturnType , [[ecole]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute to the request spec. --> Adds a curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[equate]] , Object [[cavemen]] ) { spec . attribute ( [[equate]] , [[cavemen]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Creates a new HTTP request based on the given URI and HTTP method. --> Converts a URI to a HttpRequestBase@param uri@param httpMethod@param hasBody@return --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[respectably]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[hypnotism]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 286 ---------------------------------------------
Add result handlers.@param resultHandler the result handler@param additionalResultHandlers the additional result handlers --> M marchin request spec builder. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[marchin]] ( ResultHandler [[fille]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[fille]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 287 ---------------------------------------------
Configures the default boundary for this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[mmmmm]] ( String [[emotional]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[mmmmm]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Creates a default log configuration for this log. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[additional]] ( PrintStream [[decelerate]] ) { return new LogConfig ( [[decelerate]] , "[[Housekeeping]]" == "[[Housekeeping]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Housekeeping]]" == "[[Housekeeping]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 289 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 146 / 4 / 289:  29%|██▉       | 289/1000 [8:30:21<20:55:35, 105.96s/it][Succeeded / Failed / Skipped / Total] 139 / 146 / 4 / 289:  29%|██▉       | 290/1000 [8:36:23<21:04:16, 106.84s/it][Succeeded / Failed / Skipped / Total] 140 / 146 / 4 / 290:  29%|██▉       | 290/1000 [8:36:23<21:04:16, 106.84s/it][Succeeded / Failed / Skipped / Total] 140 / 146 / 4 / 290:  29%|██▉       | 291/1000 [8:38:42<21:03:47, 106.95s/it][Succeeded / Failed / Skipped / Total] 140 / 147 / 4 / 291:  29%|██▉       | 291/1000 [8:38:42<21:03:47, 106.95s/it][Succeeded / Failed / Skipped / Total] 140 / 147 / 4 / 291:  29%|██▉       | 292/1000 [8:40:53<21:02:59, 107.03s/it][Succeeded / Failed / Skipped / Total] 140 / 148 / 4 / 292:  29%|██▉       | 292/1000 [8:40:53<21:02:59, 107.03s/it][Succeeded / Failed / Skipped / Total] 140 / 148 / 4 / 292:  29%|██▉       | 293/1000 [8:41:27<20:58:16, 106.78s/it][Succeeded / Failed / Skipped / Total] 141 / 148 / 4 / 293:  29%|██▉       | 293/1000 [8:41:27<20:58:16, 106.78s/it][Succeeded / Failed / Skipped / Total] 141 / 148 / 4 / 293:  29%|██▉       | 294/1000 [8:43:49<20:57:53, 106.90s/it][Succeeded / Failed / Skipped / Total] 142 / 148 / 4 / 294:  29%|██▉       | 294/1000 [8:43:49<20:57:53, 106.90s/it][Succeeded / Failed / Skipped / Total] 142 / 148 / 4 / 294:  30%|██▉       | 295/1000 [8:46:00<20:57:04, 106.99s/it][Succeeded / Failed / Skipped / Total] 142 / 149 / 4 / 295:  30%|██▉       | 295/1000 [8:46:00<20:57:04, 106.99s/it][Succeeded / Failed / Skipped / Total] 142 / 149 / 4 / 295:  30%|██▉       | 296/1000 [8:46:39<20:52:34, 106.75s/it][Succeeded / Failed / Skipped / Total] 142 / 150 / 4 / 296:  30%|██▉       | 296/1000 [8:46:39<20:52:34, 106.75s/it][Succeeded / Failed / Skipped / Total] 142 / 150 / 4 / 296:  30%|██▉       | 297/1000 [8:48:17<20:50:29, 106.73s/it]Creates and returns a new instance of the HttpClientConfig class. --> Customise HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[specialise]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[specialise]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Ibogaine]]" == "[[Ibogaine]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 290 ---------------------------------------------
Retrieve an integer value from the supplied path. --> Diese Methode die Methode mit dem die Methode mit dem die Methode mit dem die Methode mit dem die Methode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieM --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[diddling]] ( String [[cholesterol]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Adds a header to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[adorns]] ( String [[twinky]] , String [[outing]] ) { spec . header ( [[twinky]] , [[outing]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 292 ---------------------------------------------
Adds a multi part request specification. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String mimeType ) { spec . multiPart ( [[controlName]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[recalibrate]] ( String [[gobbled]] , String contentBody , String mimeType ) { spec . multiPart ( [[gobbled]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 293 ---------------------------------------------
Configures this HttpClientConfig with the given HTTP MultipartMode. --> Creates a new instance of HttpClientConfig@param preserve@return --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[whose]] ( HttpMultipartMode [[preserve]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[whose]] , shouldReuseHttpClientInstance , httpClient , "[[Dagon]]" == "[[Dagon]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 294 ---------------------------------------------
Retrieve a byte value from the supplied resource. --> R roughed@param falter@return --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[roughed]] ( String [[falter]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 295 ---------------------------------------------
Gets the value of the specified JSON path.@param < T> the type parameter@param path the path@return the value --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[economic]] > [[economic]] get ( String path ) { final JSONAssertion [[overprotected]] = createJsonAssertion ( path , params ) ; final Object [[attend]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[economic]] ) [[overprotected]] . getResult ( [[attend]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Creates a new HTTP client configuration with the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[pollen]] = new HashMap < String , Object > ( this . [[chastised]] ) ; [[pollen]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[pollen]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 297 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 151 / 4 / 297:  30%|██▉       | 297/1000 [8:48:17<20:50:29, 106.73s/it][Succeeded / Failed / Skipped / Total] 142 / 151 / 4 / 297:  30%|██▉       | 298/1000 [8:48:39<20:45:22, 106.44s/it][Succeeded / Failed / Skipped / Total] 143 / 151 / 4 / 298:  30%|██▉       | 298/1000 [8:48:39<20:45:22, 106.44s/it][Succeeded / Failed / Skipped / Total] 143 / 151 / 4 / 298:  30%|██▉       | 299/1000 [8:48:58<20:40:10, 106.15s/it][Succeeded / Failed / Skipped / Total] 144 / 151 / 4 / 299:  30%|██▉       | 299/1000 [8:48:58<20:40:10, 106.15s/it][Succeeded / Failed / Skipped / Total] 144 / 151 / 4 / 299:  30%|███       | 300/1000 [8:55:00<20:48:20, 107.00s/it][Succeeded / Failed / Skipped / Total] 145 / 151 / 4 / 300:  30%|███       | 300/1000 [8:55:00<20:48:20, 107.00s/it][Succeeded / Failed / Skipped / Total] 145 / 151 / 4 / 300:  30%|███       | 301/1000 [8:58:13<20:49:53, 107.29s/it][Succeeded / Failed / Skipped / Total] 145 / 152 / 4 / 301:  30%|███       | 301/1000 [8:58:13<20:49:53, 107.29s/it][Succeeded / Failed / Skipped / Total] 145 / 152 / 4 / 301:  30%|███       | 302/1000 [9:02:07<20:52:58, 107.71s/it][Succeeded / Failed / Skipped / Total] 145 / 153 / 4 / 302:  30%|███       | 302/1000 [9:02:07<20:52:58, 107.71s/it][Succeeded / Failed / Skipped / Total] 145 / 153 / 4 / 302:  30%|███       | 303/1000 [9:07:36<20:59:41, 108.44s/it][Succeeded / Failed / Skipped / Total] 145 / 154 / 4 / 303:  30%|███       | 303/1000 [9:07:36<20:59:41, 108.44s/it][Succeeded / Failed / Skipped / Total] 145 / 154 / 4 / 303:  30%|███       | 304/1000 [9:10:08<20:59:31, 108.58s/it][Succeeded / Failed / Skipped / Total] 145 / 155 / 4 / 304:  30%|███       | 304/1000 [9:10:08<20:59:31, 108.58s/it][Succeeded / Failed / Skipped / Total] 145 / 155 / 4 / 304:  30%|███       | 305/1000 [9:10:12<20:53:44, 108.24s/it][Succeeded / Failed / Skipped / Total] 146 / 155 / 4 / 305:  30%|███       | 305/1000 [9:10:12<20:53:44, 108.24s/it][Succeeded / Failed / Skipped / Total] 146 / 155 / 4 / 305:  31%|███       | 306/1000 [9:12:43<20:53:33, 108.38s/it][Succeeded / Failed / Skipped / Total] 147 / 155 / 4 / 306:  31%|███       | 306/1000 [9:12:43<20:53:33, 108.38s/it][Succeeded / Failed / Skipped / Total] 147 / 155 / 4 / 306:  31%|███       | 307/1000 [9:13:44<20:49:57, 108.22s/it][Succeeded / Failed / Skipped / Total] 147 / 156 / 4 / 307:  31%|███       | 307/1000 [9:13:44<20:49:57, 108.22s/it][Succeeded / Failed / Skipped / Total] 147 / 156 / 4 / 307:  31%|███       | 308/1000 [9:15:05<20:47:08, 108.13s/it]Sets the value of the specified HTTP parameter.@param parameterName Name of the HTTP parameter to set.@param parameterValue Value of the HTTP parameter to set.@return Never <code>null</code>. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Supernatural]]" == "[[Supernatural]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 298 ---------------------------------------------
Retrieve a Short object from the given path. --> Compare two Pinhole objects@param pinhole@return --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[similarly]] ( String [[pinhole]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 299 ---------------------------------------------
Retrieve a long value. --> Returns artemisia@param rudeness@return --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[artemisia]] ( String [[rudeness]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieve a property as a float. --> Hydromatrix hydromatrix --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[hydrotherapy]] ( String [[fiorello]] ) { final Object [[aircrafts]] = get ( [[fiorello]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Retrieve a property as a double. --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[sentimentalist]] ( String [[offensive]] ) { final Object [[legislate]] = get ( [[offensive]] ) ; if ( [[legislate]] instanceof Double ) { return ( Double ) [[legislate]] ; } return ObjectConverter . convertObjectTo ( [[legislate]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 302 ---------------------------------------------
Sets the body of the request. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[salman]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 303 ---------------------------------------------
Gets a map from a path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[rel]] , V > Map < [[rel]] , V > [[cleanse]] ( String [[biographical]] ) { return get ( [[biographical]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 304 ---------------------------------------------
Retrieves an object from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[sulked]] > [[sulked]] getObject ( String path , Class < [[sulked]] > objectType ) { Object [[unwitting]] = getFromPath ( path , "[[Phoenician]]" != "[[Phoenician]]" ) ; return getObjectAsType ( [[unwitting]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the spec. --> Disallowed requests --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[disallowed]] ( String [[imaginations]] , Object ... [[realizes]] ) { spec . param ( [[imaginations]] , [[realizes]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Creates and returns a builder for a parameter update strategy. --> Create a new instance of MockMvcParamConfig@param kamikazes@return --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[berto]] ( UpdateStrategy [[kamikazes]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[kamikazes]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 307 ---------------------------------------------
Adds a cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[screwing]] ( String [[egyptian]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[egyptian]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 148 / 156 / 4 / 308:  31%|███       | 308/1000 [9:15:05<20:47:08, 108.13s/it][Succeeded / Failed / Skipped / Total] 148 / 156 / 4 / 308:  31%|███       | 309/1000 [9:16:31<20:44:30, 108.06s/it][Succeeded / Failed / Skipped / Total] 149 / 156 / 4 / 309:  31%|███       | 309/1000 [9:16:31<20:44:30, 108.06s/it][Succeeded / Failed / Skipped / Total] 149 / 156 / 4 / 309:  31%|███       | 310/1000 [9:17:08<20:40:04, 107.83s/it][Succeeded / Failed / Skipped / Total] 149 / 157 / 4 / 310:  31%|███       | 310/1000 [9:17:08<20:40:04, 107.83s/it][Succeeded / Failed / Skipped / Total] 149 / 157 / 4 / 310:  31%|███       | 311/1000 [9:17:26<20:34:58, 107.55s/it][Succeeded / Failed / Skipped / Total] 150 / 157 / 4 / 311:  31%|███       | 311/1000 [9:17:26<20:34:58, 107.55s/it][Succeeded / Failed / Skipped / Total] 150 / 157 / 4 / 311:  31%|███       | 312/1000 [9:20:38<20:36:16, 107.82s/it][Succeeded / Failed / Skipped / Total] 151 / 157 / 4 / 312:  31%|███       | 312/1000 [9:20:38<20:36:16, 107.82s/it][Succeeded / Failed / Skipped / Total] 151 / 157 / 4 / 312:  31%|███▏      | 313/1000 [9:24:20<20:38:41, 108.18s/it][Succeeded / Failed / Skipped / Total] 151 / 158 / 4 / 313:  31%|███▏      | 313/1000 [9:24:20<20:38:41, 108.18s/it][Succeeded / Failed / Skipped / Total] 151 / 158 / 4 / 313:  31%|███▏      | 314/1000 [9:25:06<20:34:36, 107.98s/it][Succeeded / Failed / Skipped / Total] 152 / 158 / 4 / 314:  31%|███▏      | 314/1000 [9:25:06<20:34:36, 107.98s/it][Succeeded / Failed / Skipped / Total] 152 / 158 / 4 / 314:  32%|███▏      | 315/1000 [9:25:36<20:29:58, 107.73s/it]Adds all bindings to the map. --> fawcett --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[fawcett]] ( ) { for ( Binding < ? > [[calisthenics]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[calisthenics]] . getKey ( ) . getTypeLiteral ( ) , [[calisthenics]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 309 ---------------------------------------------
Removes all keys and sources from the backing map. --> judd --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[keysAndSources]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[judd]] ( Set < KeyAndSource > [[drinking]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[drinking]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 310 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[pause]] ( String [[hairstylist]] , Collection < ? > [[combat]] ) { spec . param ( [[hairstylist]] , [[combat]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 311 ---------------------------------------------
Creates a filter that logs responses that match the provided matcher. --> Log response to if matches@param kyu@return --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[possess]] , Matcher < Integer > [[kyu]] ) { return new ResponseLoggingFilter ( [[possess]] , [[kyu]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 312 ---------------------------------------------
Removes a failed JIT binding. --> Cavorting methods --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[cavorting]] ( Binding < ? > [[exterminate]] , InjectionPoint ip ) { failedJitBindings . add ( [[exterminate]] . getKey ( ) ) ; jitBindings . remove ( [[exterminate]] . getKey ( ) ) ; membersInjectorStore . remove ( [[exterminate]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[exterminate]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 313 ---------------------------------------------
Returns the internal dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[decorate]] ( BindingImpl < ? > [[hypnotized]] ) { if ( [[hypnotized]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[hypnotized]] ) . getInternalDependencies ( ) ; } else if ( [[hypnotized]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[hypnotized]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 314 ---------------------------------------------
Binds an injector. --> slowpoke --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[slowpoke]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 315 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 158 / 4 / 315:  32%|███▏      | 315/1000 [9:25:36<20:29:58, 107.73s/it][Succeeded / Failed / Skipped / Total] 153 / 158 / 4 / 315:  32%|███▏      | 316/1000 [9:27:19<20:27:59, 107.72s/it][Succeeded / Failed / Skipped / Total] 153 / 159 / 4 / 316:  32%|███▏      | 316/1000 [9:27:19<20:27:59, 107.72s/it][Succeeded / Failed / Skipped / Total] 153 / 159 / 4 / 316:  32%|███▏      | 317/1000 [9:31:31<20:31:24, 108.18s/it][Succeeded / Failed / Skipped / Total] 154 / 159 / 4 / 317:  32%|███▏      | 317/1000 [9:31:31<20:31:24, 108.18s/it][Succeeded / Failed / Skipped / Total] 154 / 159 / 4 / 317:  32%|███▏      | 318/1000 [9:31:42<20:26:07, 107.87s/it][Succeeded / Failed / Skipped / Total] 155 / 159 / 4 / 318:  32%|███▏      | 318/1000 [9:31:42<20:26:07, 107.87s/it][Succeeded / Failed / Skipped / Total] 155 / 159 / 4 / 318:  32%|███▏      | 319/1000 [9:32:10<20:21:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 156 / 159 / 4 / 319:  32%|███▏      | 319/1000 [9:32:10<20:21:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 156 / 159 / 4 / 319:  32%|███▏      | 320/1000 [9:33:09<20:17:57, 107.47s/it][Succeeded / Failed / Skipped / Total] 157 / 159 / 4 / 320:  32%|███▏      | 320/1000 [9:33:09<20:17:57, 107.47s/it][Succeeded / Failed / Skipped / Total] 157 / 159 / 4 / 320:  32%|███▏      | 321/1000 [9:35:26<20:17:13, 107.56s/it][Succeeded / Failed / Skipped / Total] 158 / 159 / 4 / 321:  32%|███▏      | 321/1000 [9:35:26<20:17:13, 107.56s/it][Succeeded / Failed / Skipped / Total] 158 / 159 / 4 / 321:  32%|███▏      | 322/1000 [9:35:34<20:11:54, 107.25s/it][Succeeded / Failed / Skipped / Total] 159 / 159 / 4 / 322:  32%|███▏      | 322/1000 [9:35:34<20:11:54, 107.25s/it][Succeeded / Failed / Skipped / Total] 159 / 159 / 4 / 322:  32%|███▏      | 323/1000 [9:37:16<20:09:56, 107.23s/it]Binds a logger to the given injector. --> Bendy methods --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[bendy]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 316 ---------------------------------------------
Gets a list from the specified path.@param path the path@param genericType the generic type@return the list --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > [[genericType]] ) { if ( [[genericType]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T t : [[original]] ) { T [[e]] ; if ( t instanceof Map && ! [[genericType]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > [[dominatrix]] ) { if ( [[dominatrix]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[knockdown]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[knockdown]] != null ) { for ( T t : [[knockdown]] ) { T [[canadiens]] ; if ( t instanceof Map && ! [[dominatrix]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 317 ---------------------------------------------
Returns all the parameters in the given injectors. --> Performs a stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[size]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[hypnotized]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[democracies]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[democracies]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 318 ---------------------------------------------
Checks for misplaced binding annotations. --> Dostoevsky method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[dostoevsky]] ( Member [[populist]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[populist]] , ( ( AnnotatedElement ) [[populist]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 319 ---------------------------------------------
Initializes the delegate members. --> MUST NOT BE CALLED --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[mucking]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 320 ---------------------------------------------
Converts a string constant binding to a binding. --> Convenience factory method for creating an instance of an illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[offences]] ( Key < T > [[podemos]] , Errors [[pige]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 321 ---------------------------------------------
Checks if two methods are overrides of each other. --> Chesterfield method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[chesterfield]] ( Method [[brazen]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 322 ---------------------------------------------
Get the provider type. --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[handcuff]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 323 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 159 / 4 / 323:  32%|███▏      | 323/1000 [9:37:16<20:09:56, 107.23s/it][Succeeded / Failed / Skipped / Total] 160 / 159 / 4 / 323:  32%|███▏      | 324/1000 [9:37:26<20:04:47, 106.93s/it][Succeeded / Failed / Skipped / Total] 160 / 160 / 4 / 324:  32%|███▏      | 324/1000 [9:37:26<20:04:47, 106.93s/it][Succeeded / Failed / Skipped / Total] 160 / 160 / 4 / 324:  32%|███▎      | 325/1000 [9:38:54<20:02:20, 106.87s/it][Succeeded / Failed / Skipped / Total] 161 / 160 / 4 / 325:  32%|███▎      | 325/1000 [9:38:54<20:02:20, 106.87s/it][Succeeded / Failed / Skipped / Total] 161 / 160 / 4 / 325:  33%|███▎      | 326/1000 [9:41:28<20:02:10, 107.02s/it][Succeeded / Failed / Skipped / Total] 161 / 161 / 4 / 326:  33%|███▎      | 326/1000 [9:41:28<20:02:10, 107.02s/it][Succeeded / Failed / Skipped / Total] 161 / 161 / 4 / 326:  33%|███▎      | 327/1000 [9:43:23<20:00:41, 107.04s/it][Succeeded / Failed / Skipped / Total] 161 / 162 / 4 / 327:  33%|███▎      | 327/1000 [9:43:23<20:00:41, 107.04s/it][Succeeded / Failed / Skipped / Total] 161 / 162 / 4 / 327:  33%|███▎      | 328/1000 [9:43:29<19:55:26, 106.74s/it][Succeeded / Failed / Skipped / Total] 162 / 162 / 4 / 328:  33%|███▎      | 328/1000 [9:43:29<19:55:26, 106.74s/it][Succeeded / Failed / Skipped / Total] 162 / 162 / 4 / 328:  33%|███▎      | 329/1000 [9:43:47<19:50:39, 106.47s/it][Succeeded / Failed / Skipped / Total] 162 / 163 / 4 / 329:  33%|███▎      | 329/1000 [9:43:47<19:50:39, 106.47s/it][Succeeded / Failed / Skipped / Total] 162 / 163 / 4 / 329:  33%|███▎      | 330/1000 [9:45:02<19:47:48, 106.37s/it]Resolve all of the given types. --> Creates a trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { result [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[distrust]] ( Type [ ] [[therapies]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[therapies]] . length ] ; for ( int t = 0 ; t < [[therapies]] . length ; t ++ ) { result [ t ] = resolve ( [[therapies]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 324 ---------------------------------------------
Cleans up the dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[lavalle]] ( BindingImpl < ? > [[hatchery]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[hatchery]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 325 ---------------------------------------------
Prepare all built-in converters. --> A convenience method to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[abdo]] ( InjectorImpl [[sentimentalist]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 326 ---------------------------------------------
Canonicalizes the given class loader. --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[sneeze]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 327 ---------------------------------------------
Creates an uninitialized binding. --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 328 ---------------------------------------------
Converts the specified key into an appropriate annotation. --> Diese Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[drinking]] ( Key < ? > [[norberto]] ) { return [[norberto]] . getAnnotation ( ) == null ? [[norberto]] : Key . get ( [[norberto]] . getTypeLiteral ( ) , [[norberto]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 329 ---------------------------------------------
Creates a new Cookies instance with the specified cookies.@param cookie the cookie@param additionalCookies the additional cookies@return a new cookies instance --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cookie]] , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( [[cookie]] ) ; Collections . addAll ( [[cookieList]] , [[additionalCookies]] ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[fossey]] , Cookie ... [[juggling]] ) { AssertParameter . notNull ( [[fossey]] , "Cookie" ) ; final List < Cookie > [[viscount]] = new LinkedList < Cookie > ( ) ; [[viscount]] . add ( [[fossey]] ) ; Collections . addAll ( [[viscount]] , [[juggling]] ) ; return new Cookies ( [[viscount]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 330 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 163 / 4 / 330:  33%|███▎      | 330/1000 [9:45:02<19:47:48, 106.37s/it][Succeeded / Failed / Skipped / Total] 163 / 163 / 4 / 330:  33%|███▎      | 331/1000 [9:48:29<19:49:25, 106.68s/it][Succeeded / Failed / Skipped / Total] 164 / 163 / 4 / 331:  33%|███▎      | 331/1000 [9:48:29<19:49:25, 106.68s/it][Succeeded / Failed / Skipped / Total] 164 / 163 / 4 / 331:  33%|███▎      | 332/1000 [9:49:05<19:45:16, 106.46s/it][Succeeded / Failed / Skipped / Total] 165 / 163 / 4 / 332:  33%|███▎      | 332/1000 [9:49:05<19:45:16, 106.46s/it][Succeeded / Failed / Skipped / Total] 165 / 163 / 4 / 332:  33%|███▎      | 333/1000 [9:49:59<19:41:44, 106.30s/it][Succeeded / Failed / Skipped / Total] 166 / 163 / 4 / 333:  33%|███▎      | 333/1000 [9:49:59<19:41:44, 106.30s/it][Succeeded / Failed / Skipped / Total] 166 / 163 / 4 / 333:  33%|███▎      | 334/1000 [9:50:37<19:37:42, 106.10s/it][Succeeded / Failed / Skipped / Total] 166 / 164 / 4 / 334:  33%|███▎      | 334/1000 [9:50:37<19:37:42, 106.10s/it][Succeeded / Failed / Skipped / Total] 166 / 164 / 4 / 334:  34%|███▎      | 335/1000 [9:55:26<19:41:59, 106.65s/it][Succeeded / Failed / Skipped / Total] 166 / 165 / 4 / 335:  34%|███▎      | 335/1000 [9:55:26<19:41:59, 106.65s/it][Succeeded / Failed / Skipped / Total] 166 / 165 / 4 / 335:  34%|███▎      | 336/1000 [9:58:29<19:42:44, 106.87s/it]Dispatches a servlet request to the dispatcher. --> Performs a "Performs a "Performs a "perform a "perform a "perform a"perform a "perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a" --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[democracies]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 331 ---------------------------------------------
Validates that the injections are valid. --> zay (errors) --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[zay]] ( Errors errors ) { validationStarted = "[[Hecht]]" == "[[Hecht]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 332 ---------------------------------------------
Checks if the given class loader has the same version of the current one. --> M mulligan --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[mulligan]] ( ClassLoader [[andale]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[andale]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 333 ---------------------------------------------
Creates an injectable scope. --> W slaughterhouse --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[slaughterhouse]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 334 ---------------------------------------------
Injects the given instance into the given injector.@param injector the injector@param instance the instance@param binding the binding@param source the source@param injectionPoints the injection points --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[revelation]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 335 ---------------------------------------------
Generates an annotation for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[scrambles]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 336 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 167 / 165 / 4 / 336:  34%|███▎      | 336/1000 [9:58:29<19:42:44, 106.87s/it][Succeeded / Failed / Skipped / Total] 167 / 165 / 4 / 336:  34%|███▎      | 337/1000 [9:59:42<19:39:51, 106.77s/it][Succeeded / Failed / Skipped / Total] 167 / 166 / 4 / 337:  34%|███▎      | 337/1000 [9:59:42<19:39:51, 106.77s/it][Succeeded / Failed / Skipped / Total] 167 / 166 / 4 / 337:  34%|███▍      | 338/1000 [10:01:40<19:38:25, 106.81s/it][Succeeded / Failed / Skipped / Total] 167 / 167 / 4 / 338:  34%|███▍      | 338/1000 [10:01:40<19:38:25, 106.81s/it][Succeeded / Failed / Skipped / Total] 167 / 167 / 4 / 338:  34%|███▍      | 339/1000 [10:02:13<19:34:15, 106.59s/it][Succeeded / Failed / Skipped / Total] 168 / 167 / 4 / 339:  34%|███▍      | 339/1000 [10:02:13<19:34:15, 106.59s/it][Succeeded / Failed / Skipped / Total] 168 / 167 / 4 / 339:  34%|███▍      | 340/1000 [10:02:44<19:30:01, 106.37s/it][Succeeded / Failed / Skipped / Total] 169 / 167 / 4 / 340:  34%|███▍      | 340/1000 [10:02:44<19:30:01, 106.37s/it][Succeeded / Failed / Skipped / Total] 169 / 167 / 4 / 340:  34%|███▍      | 341/1000 [10:03:31<19:26:21, 106.19s/it][Succeeded / Failed / Skipped / Total] 169 / 168 / 4 / 341:  34%|███▍      | 341/1000 [10:03:31<19:26:21, 106.19s/it][Succeeded / Failed / Skipped / Total] 169 / 168 / 4 / 341:  34%|███▍      | 342/1000 [10:07:58<19:29:43, 106.66s/it][Succeeded / Failed / Skipped / Total] 170 / 168 / 4 / 342:  34%|███▍      | 342/1000 [10:07:58<19:29:43, 106.66s/it][Succeeded / Failed / Skipped / Total] 170 / 168 / 4 / 342:  34%|███▍      | 343/1000 [10:15:15<19:38:28, 107.62s/it]Normalizes a path. --> Bouncy castle version --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder [[sb]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[bouncer]] ( String path ) { StringBuilder [[ladyhawke]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Converts a TypeLiteral into a canonical type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 338 ---------------------------------------------
Returns true if the given member is public, false otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider. --> region barracuda --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[barracuda]] ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Adds the direct type binding. --> region barbara --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[barbara]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[koryu]] ( Object [ ] [[paints]] ) throws Throwable { constructor . setAccessible ( "[[Pullover]]" == "[[Pullover]]" ) ; try { return constructor . newInstance ( [[paints]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 342 ---------------------------------------------
Returns true if the given annotation is retained at runtime. --> Diesu dieu@param pacts@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[dieu]] ( Class < ? extends Annotation > [[pacts]] ) { Retention [[nintendo]] = [[pacts]] . getAnnotation ( Retention . class ) ; return [[nintendo]] != null && [[nintendo]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 343 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 168 / 4 / 343:  34%|███▍      | 343/1000 [10:15:15<19:38:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 171 / 168 / 4 / 343:  34%|███▍      | 344/1000 [10:15:23<19:33:32, 107.34s/it][Succeeded / Failed / Skipped / Total] 172 / 168 / 4 / 344:  34%|███▍      | 344/1000 [10:15:23<19:33:32, 107.34s/it][Succeeded / Failed / Skipped / Total] 172 / 168 / 4 / 344:  34%|███▍      | 345/1000 [10:23:27<19:43:39, 108.43s/it][Succeeded / Failed / Skipped / Total] 172 / 169 / 4 / 345:  34%|███▍      | 345/1000 [10:23:27<19:43:39, 108.43s/it][Succeeded / Failed / Skipped / Total] 172 / 169 / 4 / 345:  35%|███▍      | 346/1000 [10:23:33<19:38:38, 108.13s/it][Succeeded / Failed / Skipped / Total] 172 / 170 / 4 / 346:  35%|███▍      | 346/1000 [10:23:33<19:38:38, 108.13s/it][Succeeded / Failed / Skipped / Total] 172 / 170 / 4 / 346:  35%|███▍      | 347/1000 [10:26:29<19:38:57, 108.33s/it][Succeeded / Failed / Skipped / Total] 172 / 171 / 4 / 347:  35%|███▍      | 347/1000 [10:26:29<19:38:57, 108.33s/it][Succeeded / Failed / Skipped / Total] 172 / 171 / 4 / 347:  35%|███▍      | 348/1000 [10:27:06<19:34:55, 108.12s/it][Succeeded / Failed / Skipped / Total] 172 / 172 / 4 / 348:  35%|███▍      | 348/1000 [10:27:06<19:34:55, 108.12s/it][Succeeded / Failed / Skipped / Total] 172 / 172 / 4 / 348:  35%|███▍      | 349/1000 [10:27:37<19:30:44, 107.90s/it]Returns the name of the given key. --> Handlebars --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[handlebar]] ( Key < ? > [[vettori]] ) { Annotation annotation = [[vettori]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[vettori]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[vettori]] . getAnnotation ( ) . toString ( ) ; } else if ( [[vettori]] . getAnnotationType ( ) != null ) { return "@" + [[vettori]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 344 ---------------------------------------------
Create a new RealMapBinder. --> Sailboat implementation --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[sailboat]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[sailboat]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 345 ---------------------------------------------
Returns the key for a new value. --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 346 ---------------------------------------------
Creates a factory for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 347 ---------------------------------------------
Returns the key for the specified type and member. --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 348 ---------------------------------------------
Finds the scope annotation for the given annotations. --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[annotation]] : annotations ) { Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[annotationType]] ) ; } else { found = [[annotationType]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[blackballed]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[jokes]] : annotations ) { Class < ? extends Annotation > [[conjoined]] = [[jokes]] . annotationType ( ) ; if ( isScopeAnnotation ( [[conjoined]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[conjoined]] ) ; } else { found = [[conjoined]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 349 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 173 / 4 / 349:  35%|███▍      | 349/1000 [10:27:37<19:30:44, 107.90s/it][Succeeded / Failed / Skipped / Total] 172 / 173 / 4 / 349:  35%|███▌      | 350/1000 [10:28:50<19:27:50, 107.80s/it][Succeeded / Failed / Skipped / Total] 172 / 174 / 4 / 350:  35%|███▌      | 350/1000 [10:28:50<19:27:50, 107.80s/it][Succeeded / Failed / Skipped / Total] 172 / 174 / 4 / 350:  35%|███▌      | 351/1000 [10:31:08<19:26:59, 107.89s/it][Succeeded / Failed / Skipped / Total] 172 / 175 / 4 / 351:  35%|███▌      | 351/1000 [10:31:08<19:26:59, 107.89s/it][Succeeded / Failed / Skipped / Total] 172 / 175 / 4 / 351:  35%|███▌      | 352/1000 [10:31:19<19:22:12, 107.61s/it][Succeeded / Failed / Skipped / Total] 172 / 176 / 4 / 352:  35%|███▌      | 352/1000 [10:31:19<19:22:12, 107.61s/it][Succeeded / Failed / Skipped / Total] 172 / 176 / 4 / 352:  35%|███▌      | 353/1000 [10:33:34<19:21:16, 107.69s/it][Succeeded / Failed / Skipped / Total] 173 / 176 / 4 / 353:  35%|███▌      | 353/1000 [10:33:34<19:21:16, 107.69s/it][Succeeded / Failed / Skipped / Total] 173 / 176 / 4 / 353:  35%|███▌      | 354/1000 [10:43:30<19:34:17, 109.07s/it][Succeeded / Failed / Skipped / Total] 173 / 177 / 4 / 354:  35%|███▌      | 354/1000 [10:43:30<19:34:17, 109.07s/it][Succeeded / Failed / Skipped / Total] 173 / 177 / 4 / 354:  36%|███▌      | 355/1000 [10:48:46<19:38:45, 109.65s/it][Succeeded / Failed / Skipped / Total] 173 / 178 / 4 / 355:  36%|███▌      | 355/1000 [10:48:46<19:38:45, 109.65s/it][Succeeded / Failed / Skipped / Total] 173 / 178 / 4 / 355:  36%|███▌      | 356/1000 [10:49:41<19:35:17, 109.50s/it][Succeeded / Failed / Skipped / Total] 174 / 178 / 4 / 356:  36%|███▌      | 356/1000 [10:49:41<19:35:17, 109.50s/it][Succeeded / Failed / Skipped / Total] 174 / 178 / 4 / 356:  36%|███▌      | 357/1000 [10:49:57<19:30:39, 109.24s/it]Checks if the interceptor class has a scope annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 350 ---------------------------------------------
Returns the module for the given module. --> [[[FAILED]]]

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[copacetic]] ( Module [[dogma]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 351 ---------------------------------------------
Returns a collection of all methods of this class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[chlorine]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Returns a ConstructorInjector for the given InjectionPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[meteorite]] ( InjectionPoint [[spontaneity]] , Errors [[currants]] ) throws ErrorsException { return cache . get ( [[spontaneity]] , [[currants]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 353 ---------------------------------------------
Writes a message to the supplied object. --> Dostoevsky lights --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[dostoevsky]] ( ) throws ObjectStreamException { Object [ ] [[flashlight]] = sources . toArray ( ) ; for ( int [[counselors]] = 0 ; [[counselors]] < [[flashlight]] . length ; [[counselors]] ++ ) { [[flashlight]] [ [[counselors]] ] = Errors . convert ( [[flashlight]] [ [[counselors]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[flashlight]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 354 ---------------------------------------------
Creates a new instance of the proxy for the given context. --> [[[FAILED]]]

[[[[Adv]]]]: private T provision ( InternalContext [[context]] , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] [[parameters]] = SingleParameterInjector . getAll ( [[context]] , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( [[parameters]] ) ; [[constructionContext]] . setProxyDelegates ( [[t]] ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext [[twine]] , ConstructionContext < T > [[moran]] ) throws InternalProvisionException { try { T [[outward]] ; try { Object [ ] [[hangnail]] = SingleParameterInjector . getAll ( [[twine]] , parameterInjectors ) ; [[outward]] = constructionProxy . newInstance ( [[hangnail]] ) ; [[moran]] . setProxyDelegates ( [[outward]] ) ; } finally { [[moran]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 355 ---------------------------------------------
Returns the set of dependencies for the given injection point. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 356 ---------------------------------------------
Creates an error message for the given key. --> Appends an error message to the log. --> Socre: 1.0

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[conductor]] = new StringBuilder ( ) ; [[conductor]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 175 / 178 / 4 / 357:  36%|███▌      | 357/1000 [10:49:57<19:30:39, 109.24s/it][Succeeded / Failed / Skipped / Total] 175 / 178 / 4 / 357:  36%|███▌      | 358/1000 [10:57:57<19:39:55, 110.27s/it][Succeeded / Failed / Skipped / Total] 175 / 179 / 4 / 358:  36%|███▌      | 358/1000 [10:57:57<19:39:55, 110.27s/it][Succeeded / Failed / Skipped / Total] 175 / 179 / 4 / 358:  36%|███▌      | 359/1000 [11:00:54<19:40:04, 110.46s/it][Succeeded / Failed / Skipped / Total] 175 / 180 / 4 / 359:  36%|███▌      | 359/1000 [11:00:54<19:40:04, 110.46s/it][Succeeded / Failed / Skipped / Total] 175 / 180 / 4 / 359:  36%|███▌      | 360/1000 [11:01:13<19:35:30, 110.20s/it][Succeeded / Failed / Skipped / Total] 176 / 180 / 4 / 360:  36%|███▌      | 360/1000 [11:01:13<19:35:30, 110.20s/it][Succeeded / Failed / Skipped / Total] 176 / 180 / 4 / 360:  36%|███▌      | 361/1000 [11:01:45<19:31:21, 109.99s/it][Succeeded / Failed / Skipped / Total] 176 / 181 / 4 / 361:  36%|███▌      | 361/1000 [11:01:45<19:31:21, 109.99s/it][Succeeded / Failed / Skipped / Total] 176 / 181 / 4 / 361:  36%|███▌      | 362/1000 [11:02:25<19:27:29, 109.80s/it][Succeeded / Failed / Skipped / Total] 177 / 181 / 4 / 362:  36%|███▌      | 362/1000 [11:02:25<19:27:29, 109.80s/it][Succeeded / Failed / Skipped / Total] 177 / 181 / 4 / 362:  36%|███▋      | 363/1000 [11:04:06<19:25:23, 109.77s/it][Succeeded / Failed / Skipped / Total] 178 / 181 / 4 / 363:  36%|███▋      | 363/1000 [11:04:06<19:25:23, 109.77s/it][Succeeded / Failed / Skipped / Total] 178 / 181 / 4 / 363:  36%|███▋      | 364/1000 [11:09:33<19:29:54, 110.37s/it]Checks if the given type literal is not specified in the configuration. --> Diese Methode@param demy@param division@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[dally]] ( TypeLiteral < ? > [[demy]] , ConfigurationException [[division]] ) { Collection < Message > [[techno]] = [[division]] . getErrorMessages ( ) ; if ( [[techno]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[demy]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[techno]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 358 ---------------------------------------------
Create a binding from a new injector. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 359 ---------------------------------------------
Removes the given set of dependencies from the given set. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[builder]] . add ( dep ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[humbleness]] ( Set < Dependency < ? > > [[manpower]] ) { ImmutableSet . Builder < Dependency < ? > > [[credibility]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[manpower]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[credibility]] . add ( dep ) ; } } return [[credibility]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 360 ---------------------------------------------
Gets the internal constructor. --> Sc scrapping --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[scrapping]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 361 ---------------------------------------------
Find the next filter. --> [[[FAILED]]]

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[acquire]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 362 ---------------------------------------------
Invokes the specified method on the specified object. --> Hijacker methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object [[proxy]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[hijacker]] ( Object [[antero]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 363 ---------------------------------------------
Create a new set-binder for the specified key. --> Instantiates a Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > [[key]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( binder , [[key]] ) ; binder . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[automaton]] ( Binder binder , Key < T > [[honour]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[soapy]] = new RealMultibinder <> ( binder , [[honour]] ) ; binder . install ( [[soapy]] ) ; return [[soapy]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 364 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 182 / 4 / 364:  36%|███▋      | 364/1000 [11:09:33<19:29:54, 110.37s/it][Succeeded / Failed / Skipped / Total] 178 / 182 / 4 / 364:  36%|███▋      | 365/1000 [11:11:00<19:27:22, 110.30s/it][Succeeded / Failed / Skipped / Total] 178 / 183 / 4 / 365:  36%|███▋      | 365/1000 [11:11:00<19:27:22, 110.30s/it][Succeeded / Failed / Skipped / Total] 178 / 183 / 4 / 365:  37%|███▋      | 366/1000 [11:12:13<19:24:26, 110.20s/it][Succeeded / Failed / Skipped / Total] 178 / 184 / 4 / 366:  37%|███▋      | 366/1000 [11:12:13<19:24:26, 110.20s/it][Succeeded / Failed / Skipped / Total] 178 / 184 / 4 / 366:  37%|███▋      | 367/1000 [11:13:46<19:22:06, 110.15s/it][Succeeded / Failed / Skipped / Total] 179 / 184 / 4 / 367:  37%|███▋      | 367/1000 [11:13:46<19:22:06, 110.15s/it][Succeeded / Failed / Skipped / Total] 179 / 184 / 4 / 367:  37%|███▋      | 368/1000 [11:15:38<19:20:21, 110.16s/it][Succeeded / Failed / Skipped / Total] 179 / 185 / 4 / 368:  37%|███▋      | 368/1000 [11:15:38<19:20:21, 110.16s/it][Succeeded / Failed / Skipped / Total] 179 / 185 / 4 / 368:  37%|███▋      | 369/1000 [11:20:03<19:22:55, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 185 / 4 / 369:  37%|███▋      | 369/1000 [11:20:03<19:22:55, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 185 / 4 / 369:  37%|███▋      | 370/1000 [11:21:53<19:21:04, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 186 / 4 / 370:  37%|███▋      | 370/1000 [11:21:53<19:21:04, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 186 / 4 / 370:  37%|███▋      | 371/1000 [11:23:37<19:19:02, 110.56s/it]Checks if the given set of dependencies is valid for the given factory type. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 365 ---------------------------------------------
Returns true if the given constructor has at least one annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[taxi]] ( Constructor [[patients]] ) { return [[patients]] . isAnnotationPresent ( Inject . class ) || [[patients]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 366 ---------------------------------------------
Returns the set of internal dependencies for the given factory. --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[sneer]] ( ) { ImmutableSet . Builder < InjectionPoint > [[cleanser]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[cleanser]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 367 ---------------------------------------------
Initializes the lookups. --> F frankenstein --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[frankenstein]] ( Errors [[providers]] ) { injector . lookups = injector ; new LookupProcessor ( [[providers]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 368 ---------------------------------------------
Returns the line number for the given member. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[suffer]] ( Member [[chairing]] ) { Preconditions . checkArgument ( type == [[chairing]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[chairing]] , [[chairing]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[chairing]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Validates that the supplied object is compatible with the supplied key. --> copacetic copacetic implementation --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[copacetic]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 370 ---------------------------------------------
Returns the annotation for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 371 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 187 / 4 / 371:  37%|███▋      | 371/1000 [11:23:37<19:19:02, 110.56s/it][Succeeded / Failed / Skipped / Total] 180 / 187 / 4 / 371:  37%|███▋      | 372/1000 [11:24:21<19:15:19, 110.38s/it][Succeeded / Failed / Skipped / Total] 180 / 188 / 4 / 372:  37%|███▋      | 372/1000 [11:24:21<19:15:19, 110.38s/it][Succeeded / Failed / Skipped / Total] 180 / 188 / 4 / 372:  37%|███▋      | 373/1000 [11:25:02<19:11:32, 110.20s/it][Succeeded / Failed / Skipped / Total] 181 / 188 / 4 / 373:  37%|███▋      | 373/1000 [11:25:02<19:11:32, 110.20s/it][Succeeded / Failed / Skipped / Total] 181 / 188 / 4 / 373:  37%|███▋      | 374/1000 [11:32:21<19:18:51, 111.07s/it][Succeeded / Failed / Skipped / Total] 182 / 188 / 4 / 374:  37%|███▋      | 374/1000 [11:32:21<19:18:51, 111.07s/it][Succeeded / Failed / Skipped / Total] 182 / 188 / 4 / 374:  38%|███▊      | 375/1000 [11:34:52<19:18:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 182 / 189 / 4 / 375:  38%|███▊      | 375/1000 [11:34:52<19:18:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 182 / 189 / 4 / 375:  38%|███▊      | 376/1000 [11:35:44<19:14:37, 111.02s/it][Succeeded / Failed / Skipped / Total] 182 / 190 / 4 / 376:  38%|███▊      | 376/1000 [11:35:44<19:14:37, 111.02s/it]Wraps a callable with a transfer request. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[regression]] ( Callable < T > [[attest]] ) { return wrap ( [[attest]] , [[regression]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 372 ---------------------------------------------
Checks if the given constructor has all the required parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 373 ---------------------------------------------
Returns a module for the given module annotated method. --> Loretta --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[lion]] ( Object [[mathis]] , ModuleAnnotatedMethodScanner [[referees]] ) { return forObject ( [[mathis]] , "[[Loretta]]" != "[[Loretta]]" , [[referees]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 374 ---------------------------------------------
Returns an annotation strategy for the given annotation. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[crosswalk]] ( Annotation [[mockingly]] ) { checkNotNull ( [[mockingly]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[mockingly]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[mockingly]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[mockingly]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 375 ---------------------------------------------
Wraps a callable with a request seed map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , [[continueRequest]] ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[magnate]] ( Callable < T > [[impassable]] , Map < Key < ? > , Object > [[backyard]] ) { return wrap ( [[impassable]] , [[magnate]] ( [[backyard]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 376 ---------------------------------------------
Gets the source of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[dissident]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 377 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 182 / 191 / 4 / 377:  38%|███▊      | 377/1000 [11:35:44<19:09:43, 110.73s/it][Succeeded / Failed / Skipped / Total] 182 / 191 / 4 / 377:  38%|███▊      | 378/1000 [11:36:51<19:06:41, 110.61s/it][Succeeded / Failed / Skipped / Total] 182 / 192 / 4 / 378:  38%|███▊      | 378/1000 [11:36:51<19:06:41, 110.61s/it][Succeeded / Failed / Skipped / Total] 182 / 192 / 4 / 378:  38%|███▊      | 379/1000 [11:41:58<19:10:11, 111.13s/it][Succeeded / Failed / Skipped / Total] 182 / 193 / 4 / 379:  38%|███▊      | 379/1000 [11:41:58<19:10:11, 111.13s/it][Succeeded / Failed / Skipped / Total] 182 / 193 / 4 / 379:  38%|███▊      | 380/1000 [11:42:33<19:06:16, 110.93s/it][Succeeded / Failed / Skipped / Total] 182 / 194 / 4 / 380:  38%|███▊      | 380/1000 [11:42:33<19:06:16, 110.93s/it][Succeeded / Failed / Skipped / Total] 182 / 194 / 4 / 380:  38%|███▊      | 381/1000 [11:45:48<19:06:41, 111.15s/it][Succeeded / Failed / Skipped / Total] 183 / 194 / 4 / 381:  38%|███▊      | 381/1000 [11:45:48<19:06:41, 111.15s/it][Succeeded / Failed / Skipped / Total] 183 / 194 / 4 / 381:  38%|███▊      | 382/1000 [11:55:05<19:16:52, 112.32s/it][Succeeded / Failed / Skipped / Total] 183 / 195 / 4 / 382:  38%|███▊      | 382/1000 [11:55:05<19:16:52, 112.32s/it][Succeeded / Failed / Skipped / Total] 183 / 195 / 4 / 382:  38%|███▊      | 383/1000 [11:58:17<19:17:09, 112.53s/it]Prune the stacktrace from the exception. --> [[[FAILED]]]

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 378 ---------------------------------------------
Returns an annotation strategy for the given annotation type. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[backache]] ( Class < ? extends Annotation > [[princess]] ) { [[princess]] = Annotations . canonicalizeIfNamed ( [[princess]] ) ; if ( isAllDefaultMethods ( [[princess]] ) ) { return [[backache]] ( generateAnnotation ( [[princess]] ) ) ; } checkNotNull ( [[princess]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[princess]] ) ; ensureIsBindingAnnotation ( [[princess]] ) ; return new AnnotationTypeStrategy ( [[princess]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 379 ---------------------------------------------
Gets the injectors for the given injection points. --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 380 ---------------------------------------------
Returns a new instance of the given annotation strategy. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[physiotherapy]] ( Class < T > [[pseudo]] , AnnotationStrategy [[engaging]] ) { return new Key < T > ( [[pseudo]] , [[engaging]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 381 ---------------------------------------------
Converts an object to an object. --> Hijackers method --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[hijackers]] ( Object o ) { ElementSource [[accretion]] = null ; if ( o instanceof ElementSource ) { [[accretion]] = ( ElementSource ) o ; o = [[accretion]] . getDeclaringSource ( ) ; } return [[hijackers]] ( o , [[accretion]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Checks if the given class should be skipped. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[alarmed]] ( String [[tenzin]] ) { return ( parent != null && parent . shouldBeSkipped ( [[tenzin]] ) ) || classNamesToSkip . contains ( [[tenzin]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 383 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 183 / 196 / 4 / 383:  38%|███▊      | 383/1000 [11:58:17<19:17:09, 112.53s/it][Succeeded / Failed / Skipped / Total] 183 / 196 / 4 / 383:  38%|███▊      | 384/1000 [11:59:35<19:14:20, 112.44s/it][Succeeded / Failed / Skipped / Total] 183 / 197 / 4 / 384:  38%|███▊      | 384/1000 [11:59:35<19:14:20, 112.44s/it][Succeeded / Failed / Skipped / Total] 183 / 197 / 4 / 384:  38%|███▊      | 385/1000 [12:05:19<19:18:38, 113.04s/it][Succeeded / Failed / Skipped / Total] 183 / 198 / 4 / 385:  38%|███▊      | 385/1000 [12:05:19<19:18:38, 113.04s/it][Succeeded / Failed / Skipped / Total] 183 / 198 / 4 / 385:  39%|███▊      | 386/1000 [12:07:16<19:16:51, 113.05s/it][Succeeded / Failed / Skipped / Total] 183 / 199 / 4 / 386:  39%|███▊      | 386/1000 [12:07:16<19:16:51, 113.05s/it][Succeeded / Failed / Skipped / Total] 183 / 199 / 4 / 386:  39%|███▊      | 387/1000 [12:07:24<19:12:11, 112.78s/it]Formats the given collection of messages into a human readable string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 384 ---------------------------------------------
Creates a message with the specified format and arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[seats]] ( String [[vindicated]] , Object ... [[deceptive]] ) { return [[seats]] ( null , [[vindicated]] , [[deceptive]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 385 ---------------------------------------------
Creates a new instance of MembersInjectorImpl. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 386 ---------------------------------------------
Creates a new message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > sources , String [[messageFormat]] , Object ... [[arguments]] ) { String message = format ( [[messageFormat]] , [[arguments]] ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[strip]] ( Throwable [[supplement]] , List < Object > sources , String [[patched]] , Object ... [[prostitutes]] ) { String message = format ( [[patched]] , [[prostitutes]] ) ; return new Message ( sources , message , [[supplement]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 199 / 4 / 387:  39%|███▊      | 387/1000 [12:07:24<19:12:11, 112.78s/it][Succeeded / Failed / Skipped / Total] 184 / 199 / 4 / 387:  39%|███▉      | 388/1000 [12:07:52<19:08:05, 112.56s/it][Succeeded / Failed / Skipped / Total] 184 / 200 / 4 / 388:  39%|███▉      | 388/1000 [12:07:52<19:08:05, 112.56s/it][Succeeded / Failed / Skipped / Total] 184 / 200 / 4 / 388:  39%|███▉      | 389/1000 [12:08:21<19:04:02, 112.34s/it][Succeeded / Failed / Skipped / Total] 185 / 200 / 4 / 389:  39%|███▉      | 389/1000 [12:08:21<19:04:02, 112.34s/it][Succeeded / Failed / Skipped / Total] 185 / 200 / 4 / 389:  39%|███▉      | 390/1000 [12:13:17<19:06:56, 112.81s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 4 / 390:  39%|███▉      | 390/1000 [12:13:17<19:06:56, 112.81s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 4 / 390:  39%|███▉      | 391/1000 [12:13:17<19:02:08, 112.53s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 5 / 391:  39%|███▉      | 391/1000 [12:13:17<19:02:08, 112.53s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 5 / 391:  39%|███▉      | 392/1000 [12:14:13<18:58:48, 112.38s/it][Succeeded / Failed / Skipped / Total] 185 / 202 / 5 / 392:  39%|███▉      | 392/1000 [12:14:13<18:58:48, 112.38s/it][Succeeded / Failed / Skipped / Total] 185 / 202 / 5 / 392:  39%|███▉      | 393/1000 [12:21:05<19:04:38, 113.14s/it][Succeeded / Failed / Skipped / Total] 186 / 202 / 5 / 393:  39%|███▉      | 393/1000 [12:21:05<19:04:38, 113.14s/it][Succeeded / Failed / Skipped / Total] 186 / 202 / 5 / 393:  39%|███▉      | 394/1000 [12:24:34<19:05:13, 113.39s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 5 / 394:  39%|███▉      | 394/1000 [12:24:34<19:05:13, 113.39s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 5 / 394:  40%|███▉      | 395/1000 [12:24:35<19:00:27, 113.10s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 6 / 395:  40%|███▉      | 395/1000 [12:24:35<19:00:27, 113.10s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 6 / 395:  40%|███▉      | 396/1000 [12:26:31<18:58:38, 113.11s/it]Starts the remote JMX server. --> Strips a carpet --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector [[injector]] = Guice . createInjector ( [[module]] ) ; manage ( [[args]] [ 0 ] , [[injector]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[birdseed]] ( String [ ] [[strain]] ) throws Exception { if ( [[strain]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[quicksilver]] = ( Module ) Class . forName ( [[strain]] [ 0 ] ) . newInstance ( ) ; Injector [[agnès]] = Guice . createInjector ( [[quicksilver]] ) ; manage ( [[strain]] [ 0 ] , [[agnès]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 388 ---------------------------------------------
Returns the source of the specified module class names. --> [[[FAILED]]]

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[loggers]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[loggers]] ) ) { return new StackTraceElement ( [[loggers]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 389 ---------------------------------------------
Pushes a state onto the cache. --> F feli --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[feli]] ( com . google . inject . Key < ? > [[lavonne]] , Object source ) { doPushState ( [[lavonne]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[minimally]] ( Throwable [[hallucinogen]] , String [[excavations]] , Object ... [[magnum]] ) { return [[minimally]] ( [[hallucinogen]] , ImmutableList . of ( ) , [[excavations]] , [[magnum]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 391 ---------------------------------------------
Rethrows an unchecked exception. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[spinnaker]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 393 ---------------------------------------------
Registers a default processor. --> C crucifixions --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[crucifixions]] ( RemotingProcessor < ? > [[infomercial]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[infomercial]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 394 ---------------------------------------------
Called when a connection event occurs. --> Process an incoming connection event@param nosebleeds@param sha@param leong --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType [[type]] , String [[remoteAddr]] , Connection [[conn]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[remoteAddr]] , [[conn]] ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[illinois]] ( ConnectionEventType [[nosebleeds]] , String [[shaka]] , Connection [[leong]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[nosebleeds]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[shaka]] , [[leong]] ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 395 ---------------------------------------------
Returns the Url for the given URL. --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 187 / 203 / 6 / 396:  40%|███▉      | 396/1000 [12:26:31<18:58:38, 113.11s/it][Succeeded / Failed / Skipped / Total] 187 / 203 / 6 / 396:  40%|███▉      | 397/1000 [12:27:01<18:54:38, 112.90s/it][Succeeded / Failed / Skipped / Total] 187 / 204 / 6 / 397:  40%|███▉      | 397/1000 [12:27:01<18:54:38, 112.90s/it][Succeeded / Failed / Skipped / Total] 187 / 204 / 6 / 397:  40%|███▉      | 398/1000 [12:27:17<18:50:19, 112.66s/it][Succeeded / Failed / Skipped / Total] 188 / 204 / 6 / 398:  40%|███▉      | 398/1000 [12:27:17<18:50:19, 112.66s/it][Succeeded / Failed / Skipped / Total] 188 / 204 / 6 / 398:  40%|███▉      | 399/1000 [12:27:57<18:46:36, 112.47s/it][Succeeded / Failed / Skipped / Total] 189 / 204 / 6 / 399:  40%|███▉      | 399/1000 [12:27:57<18:46:36, 112.47s/it][Succeeded / Failed / Skipped / Total] 189 / 204 / 6 / 399:  40%|████      | 400/1000 [12:28:31<18:42:46, 112.28s/it][Succeeded / Failed / Skipped / Total] 190 / 204 / 6 / 400:  40%|████      | 400/1000 [12:28:31<18:42:46, 112.28s/it][Succeeded / Failed / Skipped / Total] 190 / 204 / 6 / 400:  40%|████      | 401/1000 [12:29:19<18:39:19, 112.12s/it][Succeeded / Failed / Skipped / Total] 190 / 205 / 6 / 401:  40%|████      | 401/1000 [12:29:19<18:39:19, 112.12s/it][Succeeded / Failed / Skipped / Total] 190 / 205 / 6 / 401:  40%|████      | 402/1000 [12:29:21<18:34:43, 111.85s/it][Succeeded / Failed / Skipped / Total] 191 / 205 / 6 / 402:  40%|████      | 402/1000 [12:29:21<18:34:43, 111.85s/it][Succeeded / Failed / Skipped / Total] 191 / 205 / 6 / 402:  40%|████      | 403/1000 [12:30:15<18:31:25, 111.70s/it]Pushes the specified dependency onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 397 ---------------------------------------------
Gets the future task result.@param < T> the type parameter@param task the task@param logger the logger@return the future task result --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[mosque]] > [[mosque]] getFutureTaskResult ( RunStateRecordedFutureTask < [[mosque]] > task , Logger logger ) { [[mosque]] [[nosebleeds]] = null ; if ( null != task ) { try { [[nosebleeds]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[nosebleeds]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 398 ---------------------------------------------
Scans the connection pool. --> Scans the pool. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[iter]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { String poolKey = [[iter]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[iter]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[noticeably]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[noticeably]] . hasNext ( ) ) { String poolKey = [[noticeably]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[noticeably]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Get and create a connection if it doesn't exist. --> Throws an InterruptedException@param url@return@throws InterruptedException@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[vitriol]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 400 ---------------------------------------------
Create a connection and heal if needed. --> Overrides this method to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[panky]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 401 ---------------------------------------------
Registers a processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( [[cmdCode]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[akemi]] ( CommandCode [[discussing]] , RemotingProcessor < ? > processor ) { if ( this . [[bennett]] . containsKey ( [[discussing]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[discussing]] , cmd2processors . get ( [[discussing]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[bennett]] . put ( [[discussing]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 402 ---------------------------------------------
Decodes a protocol code. --> Coherence. --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[coherence]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 403 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 192 / 205 / 6 / 403:  40%|████      | 403/1000 [12:30:15<18:31:25, 111.70s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 6 / 403:  40%|████      | 404/1000 [12:30:15<18:26:49, 111.42s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 7 / 404:  40%|████      | 404/1000 [12:30:15<18:26:49, 111.42s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 7 / 404:  40%|████      | 405/1000 [12:31:04<18:23:25, 111.27s/it][Succeeded / Failed / Skipped / Total] 192 / 206 / 7 / 405:  40%|████      | 405/1000 [12:31:04<18:23:25, 111.27s/it][Succeeded / Failed / Skipped / Total] 192 / 206 / 7 / 405:  41%|████      | 406/1000 [12:31:16<18:19:09, 111.03s/it][Succeeded / Failed / Skipped / Total] 193 / 206 / 7 / 406:  41%|████      | 406/1000 [12:31:16<18:19:09, 111.03s/it][Succeeded / Failed / Skipped / Total] 193 / 206 / 7 / 406:  41%|████      | 407/1000 [12:35:18<18:20:29, 111.35s/it][Succeeded / Failed / Skipped / Total] 194 / 206 / 7 / 407:  41%|████      | 407/1000 [12:35:18<18:20:29, 111.35s/it][Succeeded / Failed / Skipped / Total] 194 / 206 / 7 / 407:  41%|████      | 408/1000 [12:38:59<18:21:16, 111.62s/it]Create a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param syncCreateNumWhenNotWarmup the sync create number when not warmup@throws RemotingException --> Creates a connection pool.@param url the url@param pool the connection pool@param antonioni the antonioni@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[taskName]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[taskName]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[antonioni]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[antonioni]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 404 ---------------------------------------------
Closes the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
Adds a new connection event processor.@param type the event type@param processor the event processor --> [[[FAILED]]]

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 406 ---------------------------------------------
Removes a task from the pool. --> Removes the specified backstreets. --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String [[poolKey]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[connTasks]] . remove ( [[poolKey]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String [[backstreets]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[pastry]] . remove ( [[backstreets]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 407 ---------------------------------------------
Called when a connection is closed. --> SODO --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[sodomy]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 206 / 7 / 408:  41%|████      | 408/1000 [12:38:59<18:21:16, 111.62s/it][Succeeded / Failed / Skipped / Total] 195 / 206 / 7 / 408:  41%|████      | 409/1000 [12:39:07<18:16:56, 111.36s/it][Succeeded / Failed / Skipped / Total] 195 / 207 / 7 / 409:  41%|████      | 409/1000 [12:39:07<18:16:56, 111.36s/it][Succeeded / Failed / Skipped / Total] 195 / 207 / 7 / 409:  41%|████      | 410/1000 [12:39:40<18:13:10, 111.17s/it][Succeeded / Failed / Skipped / Total] 195 / 208 / 7 / 410:  41%|████      | 410/1000 [12:39:40<18:13:10, 111.17s/it]