Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [06:18<105:06:37, 378.78s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [06:18<105:06:40, 378.78s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 2/1000 [07:01<58:28:22, 210.92s/it] [Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [07:01<58:28:23, 210.93s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 3/1000 [07:20<40:39:17, 146.80s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 3/1000 [07:20<40:39:17, 146.80s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 4/1000 [10:59<45:35:21, 164.78s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 4/1000 [10:59<45:35:21, 164.78s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 5/1000 [11:56<39:37:01, 143.34s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   0%|          | 5/1000 [11:56<39:37:01, 143.34s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   1%|          | 6/1000 [13:04<36:06:13, 130.76s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [13:04<36:06:13, 130.76s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [14:48<34:59:41, 126.87s/it]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[tuki]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> LAY MAN FLAT METHOD --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[layman]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 3 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[obsolete]] ( Comparator < ? super T > [[everyone]] ) { ObjectHelper . requireNonNull ( [[everyone]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[everyone]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[scamper]] ( int [[embarassing]] ) { return new UnicastProcessor < T > ( [[embarassing]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Resets this scheduler. --> zuzu --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[zuzu]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 6 ---------------------------------------------
Retries the specified number of times. --> Optimized version of CheckReturnValue --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[optimal]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [14:48<34:59:41, 126.87s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [17:29<36:08:03, 131.13s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 8/1000 [17:29<36:08:03, 131.13s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 9/1000 [19:10<35:11:28, 127.84s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [19:10<35:11:28, 127.84s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [20:39<34:05:38, 123.98s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 10/1000 [20:39<34:05:38, 123.98s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 11/1000 [22:11<33:15:46, 121.08s/it][Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 11/1000 [22:11<33:15:46, 121.08s/it][Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 12/1000 [22:35<30:59:23, 112.92s/it][Succeeded / Failed / Skipped / Total] 5 / 7 / 0 / 12:   1%|          | 12/1000 [22:35<30:59:23, 112.92s/it][Succeeded / Failed / Skipped / Total] 5 / 7 / 0 / 12:   1%|▏         | 13/1000 [22:59<29:05:16, 106.10s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 13/1000 [22:59<29:05:16, 106.10s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 14/1000 [26:50<31:30:29, 115.04s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   1%|▏         | 14/1000 [26:50<31:30:29, 115.04s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   2%|▏         | 15/1000 [27:36<30:12:32, 110.41s/it]Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[impaled]] ( int capacityHint , Runnable [[laundry]] ) { ObjectHelper . requireNonNull ( [[laundry]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[laundry]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[macadamia]] ( CompletableSource [[unrealistic]] ) { ObjectHelper . requireNonNull ( [[unrealistic]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[unrealistic]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[turnoff]] > [[turnoff]] requireNonNull ( [[turnoff]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 10 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[gradient]] ( SingleSource < T > [[coach]] ) { ObjectHelper . requireNonNull ( [[coach]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[coach]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Creates a cast function from the given class. --> Escaping functions --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[escaping]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 12 ---------------------------------------------
Returns an identity function. --> Lifecycle methods --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[appetizers]] > Function < [[appetizers]] , [[appetizers]] > [[slams]] ( ) { return ( Function < [[appetizers]] , [[appetizers]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 13 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 14 ---------------------------------------------
Creates a new non-blocking producer. --> Create a new non-blocking non-blocking subject@param < T> the type parameter@param < R> the type parameter@return the non-blocking subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[morena]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 9 / 0 / 15:   2%|▏         | 15/1000 [27:36<30:12:32, 110.41s/it][Succeeded / Failed / Skipped / Total] 6 / 9 / 0 / 15:   2%|▏         | 16/1000 [29:49<30:34:22, 111.85s/it][Succeeded / Failed / Skipped / Total] 7 / 9 / 0 / 16:   2%|▏         | 16/1000 [29:49<30:34:22, 111.85s/it][Succeeded / Failed / Skipped / Total] 7 / 9 / 0 / 16:   2%|▏         | 17/1000 [30:15<29:09:28, 106.78s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 17/1000 [30:15<29:09:28, 106.78s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 18/1000 [32:33<29:36:08, 108.52s/it][Succeeded / Failed / Skipped / Total] 8 / 10 / 0 / 18:   2%|▏         | 18/1000 [32:33<29:36:08, 108.52s/it][Succeeded / Failed / Skipped / Total] 8 / 10 / 0 / 18:   2%|▏         | 19/1000 [33:25<28:46:07, 105.57s/it][Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 19/1000 [33:25<28:46:08, 105.57s/it][Succeeded / Failed / Skipped / Total] 8 / 11 / 0 / 19:   2%|▏         | 20/1000 [35:52<29:17:47, 107.62s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 20/1000 [35:52<29:17:47, 107.62s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 21/1000 [38:51<30:11:30, 111.02s/it][Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 21/1000 [38:51<30:11:30, 111.02s/it][Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 22/1000 [40:31<30:01:35, 110.53s/it]Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > [[co]] , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = [[co]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[pedrosa]] ( final ConnectableObservable < T > [[fireball]] , final Scheduler [[endeavour]] ) { final Observable < T > [[boules]] = [[fireball]] . observeOn ( [[endeavour]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[fireball]] , [[boules]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> Create a non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[fairies]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 17 ---------------------------------------------
Blocking get error. --> C coughing --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[coughing]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[yorkshire]] ( T [[sexiness]] ) { return new JustValue < Object , T > ( [[sexiness]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 19 ---------------------------------------------
Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a new subject with the specified capacity. --> Create a new non-sticky non-sticky subject@param exhumation@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[stencil]] ( int [[exhumation]] ) { return new UnicastSubject < T > ( [[exhumation]] , "[[Ballsy]]" == "[[Ballsy]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 21 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> Request a trond --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[cackling]] , int [[trond]] ) { [[cackling]] . request ( [[trond]] < 0 ? Long . MAX_VALUE : [[trond]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
[Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 22/1000 [40:31<30:01:35, 110.53s/it][Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 23/1000 [41:45<29:33:51, 108.94s/it][Succeeded / Failed / Skipped / Total] 10 / 13 / 0 / 23:   2%|▏         | 23/1000 [41:45<29:33:51, 108.94s/it][Succeeded / Failed / Skipped / Total] 10 / 13 / 0 / 23:   2%|▏         | 24/1000 [42:02<28:29:30, 105.09s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▏         | 24/1000 [42:02<28:29:30, 105.09s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▎         | 25/1000 [45:00<29:15:24, 108.02s/it][Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   2%|▎         | 25/1000 [45:00<29:15:24, 108.02s/it][Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   3%|▎         | 26/1000 [45:22<28:19:48, 104.71s/it][Succeeded / Failed / Skipped / Total] 12 / 14 / 0 / 26:   3%|▎         | 26/1000 [45:22<28:19:48, 104.71s/it][Succeeded / Failed / Skipped / Total] 12 / 14 / 0 / 26:   3%|▎         | 27/1000 [48:56<29:23:55, 108.77s/it][Succeeded / Failed / Skipped / Total] 13 / 14 / 0 / 27:   3%|▎         | 27/1000 [48:56<29:23:55, 108.77s/it][Succeeded / Failed / Skipped / Total] 13 / 14 / 0 / 27:   3%|▎         | 28/1000 [52:24<30:19:16, 112.30s/it][Succeeded / Failed / Skipped / Total] 13 / 15 / 0 / 28:   3%|▎         | 28/1000 [52:24<30:19:16, 112.30s/it][Succeeded / Failed / Skipped / Total] 13 / 15 / 0 / 28:   3%|▎         | 29/1000 [1:00:09<33:34:21, 124.47s/it]--------------------------------------------- Result 22 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[rashid]] , U > Function < [[rashid]] , U > [[visionary]] ( U [[simultaneous]] ) { return new JustValue < [[rashid]] , U > ( [[simultaneous]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 23 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[saverio]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
Gets the error associated with this notification. --> Vibrato support --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[vibrato]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
Returns the value associated with this notification. --> Sakuma lights --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[sakuma]] ( ) { Object [[blackout]] = value ; if ( [[blackout]] != null && ! NotificationLite . isError ( [[blackout]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 26 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[chaining]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 27 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> Borrowed from Subscriber interface --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , queue , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[bolen]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[vegetation]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[vegetation]] . get ( ) , actual , queue , [[vegetation]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[vegetation]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[arguments]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 28 ---------------------------------------------
Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[destroyers]] ( long [[deposit]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[deposit]] , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Procession]]" == "[[Procession]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 16 / 0 / 29:   3%|▎         | 29/1000 [1:00:09<33:34:21, 124.47s/it][Succeeded / Failed / Skipped / Total] 13 / 16 / 0 / 29:   3%|▎         | 30/1000 [1:01:01<32:53:11, 122.05s/it][Succeeded / Failed / Skipped / Total] 14 / 16 / 0 / 30:   3%|▎         | 30/1000 [1:01:01<32:53:11, 122.05s/it][Succeeded / Failed / Skipped / Total] 14 / 16 / 0 / 30:   3%|▎         | 31/1000 [1:02:14<32:25:29, 120.46s/it][Succeeded / Failed / Skipped / Total] 15 / 16 / 0 / 31:   3%|▎         | 31/1000 [1:02:14<32:25:29, 120.46s/it][Succeeded / Failed / Skipped / Total] 15 / 16 / 0 / 31:   3%|▎         | 32/1000 [1:06:56<33:44:44, 125.50s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 32/1000 [1:06:56<33:44:44, 125.50s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 33/1000 [1:06:59<32:43:15, 121.82s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 33/1000 [1:06:59<32:43:15, 121.82s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 34/1000 [1:09:05<32:42:56, 121.92s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   3%|▎         | 34/1000 [1:09:05<32:42:56, 121.92s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   4%|▎         | 35/1000 [1:10:11<32:15:23, 120.33s/it][Succeeded / Failed / Skipped / Total] 19 / 16 / 0 / 35:   4%|▎         | 35/1000 [1:10:11<32:15:23, 120.33s/it][Succeeded / Failed / Skipped / Total] 19 / 16 / 0 / 35:   4%|▎         | 36/1000 [1:11:32<31:55:42, 119.23s/it]Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( capacityHint , [[onTerminate]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[andr]] ( int capacityHint , Runnable [[agro]] ) { return new UnicastSubject < T > ( capacityHint , [[agro]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply a long by another. --> Multiply arable by b@param arable@param b@return --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[arable]] , long b ) { long u = [[arable]] * b ; if ( ( ( [[arable]] | b ) >>> 31 ) != 0 ) { if ( u / [[arable]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> Validates an unflinching trajectory@param unflinching@param trajectory@param observer@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable [[unflinching]] , Disposable [[trajectory]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[trajectory]] , "next is null" ) ; if ( [[unflinching]] != null ) { [[trajectory]] . dispose ( ) ; if ( [[unflinching]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[Rampaging]]" == "[[Rampaging]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
Adds the specified element to the end of the array. --> burn e@param nally@param b@return --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long [[a]] , long b ) { long [[u]] = [[a]] + b ; if ( [[u]] < 0L ) { return Long . MAX_VALUE ; } return [[u]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[burne]] ( long [[nally]] , long b ) { long [[indecency]] = [[nally]] + b ; if ( [[indecency]] < 0L ) { return Long . MAX_VALUE ; } return [[indecency]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> zuckerberg --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[ex]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[zuckerberg]] ( Throwable [[kubrick]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[kubrick]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 34 ---------------------------------------------
Shuts down the pool. --> D dribbles --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[dribbles]] ( ) { ScheduledExecutorService [[activism]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[activism]] != null ) { [[activism]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 35 ---------------------------------------------
Adds an object to the list. --> CICOGRAPHY@param admiral --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[cicero]] ( Object [[admiral]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 36 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 36/1000 [1:11:32<31:55:42, 119.23s/it][Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 37/1000 [1:12:56<31:38:35, 118.29s/it][Succeeded / Failed / Skipped / Total] 19 / 18 / 0 / 37:   4%|▎         | 37/1000 [1:12:56<31:38:35, 118.29s/it][Succeeded / Failed / Skipped / Total] 19 / 18 / 0 / 37:   4%|▍         | 38/1000 [1:14:08<31:16:56, 117.06s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 38/1000 [1:14:08<31:16:56, 117.06s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 39/1000 [1:14:15<30:29:39, 114.23s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 39/1000 [1:14:15<30:29:39, 114.23s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 40/1000 [1:14:19<29:43:39, 111.48s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 40/1000 [1:14:19<29:43:39, 111.48s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 41/1000 [1:16:33<29:50:36, 112.03s/it]Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean [[delayError]] , Disposable [[dispose]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , [[delayError]] , q , qd ) ) { if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean [[ahhhhh]] , Disposable [[rewriting]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , [[ahhhhh]] , q , qd ) ) { if ( [[rewriting]] != null ) { [[rewriting]] . [[rewriting]] ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( [[rewriting]] != null ) { [[rewriting]] . [[rewriting]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 37 ---------------------------------------------
Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[unflinching]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[unflinching]] != null ) { next . cancel ( ) ; if ( [[unflinching]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Addict]]" != "[[Addict]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 38 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> Loploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploploplopl --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[lobotomy]] ( AtomicReference < Disposable > upstream , Disposable [[weapons]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[weapons]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[weapons]] ) ) { [[weapons]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[Acropolis]]" == "[[Acropolis]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 39 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , [[n]] ) ; if ( [[requested]] . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[kindhearted]] , long [[nord]] ) { for ( ; ; ) { long [[bunsen]] = [[kindhearted]] . get ( ) ; if ( [[bunsen]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[bunsen]] , [[nord]] ) ; if ( [[kindhearted]] . compareAndSet ( [[bunsen]] , u ) ) { return [[bunsen]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 40 ---------------------------------------------
Emits a loop. --> athenian --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[athenian]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[Comments]]" != "[[Comments]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 22 / 19 / 0 / 41:   4%|▍         | 41/1000 [1:16:33<29:50:36, 112.03s/it][Succeeded / Failed / Skipped / Total] 22 / 19 / 0 / 41:   4%|▍         | 42/1000 [1:17:38<29:30:56, 110.92s/it][Succeeded / Failed / Skipped / Total] 23 / 19 / 0 / 42:   4%|▍         | 42/1000 [1:17:38<29:30:56, 110.92s/it][Succeeded / Failed / Skipped / Total] 23 / 19 / 0 / 42:   4%|▍         | 43/1000 [1:17:42<28:49:31, 108.43s/it][Succeeded / Failed / Skipped / Total] 23 / 20 / 0 / 43:   4%|▍         | 43/1000 [1:17:42<28:49:31, 108.43s/it][Succeeded / Failed / Skipped / Total] 23 / 20 / 0 / 43:   4%|▍         | 44/1000 [1:18:53<28:34:07, 107.58s/it][Succeeded / Failed / Skipped / Total] 24 / 20 / 0 / 44:   4%|▍         | 44/1000 [1:18:53<28:34:07, 107.58s/it][Succeeded / Failed / Skipped / Total] 24 / 20 / 0 / 44:   4%|▍         | 45/1000 [1:19:54<28:15:50, 106.54s/it][Succeeded / Failed / Skipped / Total] 24 / 21 / 0 / 45:   4%|▍         | 45/1000 [1:19:54<28:15:50, 106.54s/it][Succeeded / Failed / Skipped / Total] 24 / 21 / 0 / 45:   5%|▍         | 46/1000 [1:21:02<28:00:45, 105.71s/it][Succeeded / Failed / Skipped / Total] 24 / 22 / 0 / 46:   5%|▍         | 46/1000 [1:21:02<28:00:45, 105.71s/it][Succeeded / Failed / Skipped / Total] 24 / 22 / 0 / 46:   5%|▍         | 47/1000 [1:21:41<27:36:35, 104.30s/it][Succeeded / Failed / Skipped / Total] 25 / 22 / 0 / 47:   5%|▍         | 47/1000 [1:21:41<27:36:35, 104.30s/it][Succeeded / Failed / Skipped / Total] 25 / 22 / 0 / 47:   5%|▍         | 48/1000 [1:22:07<27:08:44, 102.65s/it]Clears this hash set. --> zizi --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[zizi]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[racketeering]] ; synchronized ( this ) { if ( disposed ) { return ; } [[racketeering]] = resources ; resources = null ; } dispose ( [[racketeering]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 42 ---------------------------------------------
Sets the current subscription. --> Reduces the number of subscribers to the specified nic --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[improve]] ( Subscription [[nicaragua]] ) { if ( cancelled ) { [[nicaragua]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[nicaragua]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[nicaragua]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[nicaragua]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[nicaragua]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 43 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[mourners]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 44 ---------------------------------------------
Returns the size of this hash set. --> hoarded --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[hoarded]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[protestants]] = resources ; return [[protestants]] != null ? [[protestants]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[delightfully]] ( ThreadFactory [[ecstatically]] ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , [[ecstatically]] ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 46 ---------------------------------------------
Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[headed]] , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[headed]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[headed]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Busboys]]" != "[[Busboys]]" ; } return "[[Acropolis]]" == "[[Acropolis]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 47 ---------------------------------------------
Starts the stream. --> F aggressors --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[aggressors]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 22 / 0 / 48:   5%|▍         | 48/1000 [1:22:07<27:08:44, 102.65s/it][Succeeded / Failed / Skipped / Total] 26 / 22 / 0 / 48:   5%|▍         | 49/1000 [1:22:55<26:49:20, 101.54s/it][Succeeded / Failed / Skipped / Total] 26 / 23 / 0 / 49:   5%|▍         | 49/1000 [1:22:55<26:49:20, 101.54s/it][Succeeded / Failed / Skipped / Total] 26 / 23 / 0 / 49:   5%|▌         | 50/1000 [1:28:38<28:04:18, 106.38s/it][Succeeded / Failed / Skipped / Total] 26 / 24 / 0 / 50:   5%|▌         | 50/1000 [1:28:38<28:04:18, 106.38s/it][Succeeded / Failed / Skipped / Total] 26 / 24 / 0 / 50:   5%|▌         | 51/1000 [1:29:23<27:43:18, 105.16s/it][Succeeded / Failed / Skipped / Total] 27 / 24 / 0 / 51:   5%|▌         | 51/1000 [1:29:23<27:43:18, 105.16s/it][Succeeded / Failed / Skipped / Total] 27 / 24 / 0 / 51:   5%|▌         | 52/1000 [1:34:16<28:38:48, 108.78s/it][Succeeded / Failed / Skipped / Total] 27 / 25 / 0 / 52:   5%|▌         | 52/1000 [1:34:16<28:38:48, 108.78s/it][Succeeded / Failed / Skipped / Total] 27 / 25 / 0 / 52:   5%|▌         | 53/1000 [1:34:26<28:07:21, 106.91s/it][Succeeded / Failed / Skipped / Total] 28 / 25 / 0 / 53:   5%|▌         | 53/1000 [1:34:26<28:07:21, 106.91s/it][Succeeded / Failed / Skipped / Total] 28 / 25 / 0 / 53:   5%|▌         | 54/1000 [1:34:49<27:41:19, 105.37s/it][Succeeded / Failed / Skipped / Total] 29 / 25 / 0 / 54:   5%|▌         | 54/1000 [1:34:49<27:41:19, 105.37s/it][Succeeded / Failed / Skipped / Total] 29 / 25 / 0 / 54:   6%|▌         | 55/1000 [1:35:45<27:25:20, 104.47s/it]Start unbounded. --> zizi --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[zizi]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 50 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
Offers the specified element to the specified queue. --> Hydrocycycycycycycy@param bitches@return --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[hydrochloric]] ( T [[bitches]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[bitches]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[bitches]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 52 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[evenings]] ( ) { Disposable [[ght]] = resource . get ( ) ; if ( [[ght]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[ght]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 53 ---------------------------------------------
Called when an error occurs. --> B birnbaum condition --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[birnbaum]] ( Throwable [[conditioning]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[conditioning]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[conditioning]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 54 ---------------------------------------------
Called when the supplied value is complete. --> Siegel's siegel@param celine --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[siegel]] ( T [[celine]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[celine]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[celine]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 30 / 25 / 0 / 55:   6%|▌         | 55/1000 [1:35:45<27:25:20, 104.47s/it][Succeeded / Failed / Skipped / Total] 30 / 25 / 0 / 55:   6%|▌         | 56/1000 [1:37:43<27:27:20, 104.70s/it][Succeeded / Failed / Skipped / Total] 30 / 26 / 0 / 56:   6%|▌         | 56/1000 [1:37:43<27:27:20, 104.70s/it][Succeeded / Failed / Skipped / Total] 30 / 26 / 0 / 56:   6%|▌         | 57/1000 [1:37:50<26:58:42, 102.99s/it][Succeeded / Failed / Skipped / Total] 30 / 27 / 0 / 57:   6%|▌         | 57/1000 [1:37:50<26:58:42, 102.99s/it][Succeeded / Failed / Skipped / Total] 30 / 27 / 0 / 57:   6%|▌         | 58/1000 [1:37:59<26:31:33, 101.37s/it][Succeeded / Failed / Skipped / Total] 31 / 27 / 0 / 58:   6%|▌         | 58/1000 [1:37:59<26:31:33, 101.37s/it][Succeeded / Failed / Skipped / Total] 31 / 27 / 0 / 58:   6%|▌         | 59/1000 [1:38:19<26:08:18, 100.00s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 59/1000 [1:38:19<26:08:18, 100.00s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 60/1000 [1:39:03<25:51:52, 99.06s/it] [Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 60/1000 [1:39:03<25:51:52, 99.06s/it][Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 61/1000 [1:42:47<26:22:22, 101.11s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 61/1000 [1:42:47<26:22:22, 101.11s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 62/1000 [1:44:04<26:14:32, 100.72s/it][Succeeded / Failed / Skipped / Total] 33 / 29 / 0 / 62:   6%|▌         | 62/1000 [1:44:04<26:14:32, 100.72s/it][Succeeded / Failed / Skipped / Total] 33 / 29 / 0 / 62:   6%|▋         | 63/1000 [1:45:21<26:06:53, 100.33s/it]ConcatMapDelayError. --> concatMapDelayError@param mapper@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "[[Majeure]]" == "[[Majeure]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 56 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[pera]] ( T [[anatomically]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[cinder]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[anatomically]] , [[cinder]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 57 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[lays]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 58 ---------------------------------------------
Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> B bloodier consumer --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[bloodier]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[bloodier]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 59 ---------------------------------------------
Accepts a subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 60 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 61 ---------------------------------------------
Concatenates an Iterable into a single Flowable. --> Borrowed from BackpressureSupport --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[bourdieu]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[milords]] ) { return [[bourdieu]] ( [[milords]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 62 ---------------------------------------------
Performs an asynchronous request. --> Request an anti-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long [[n]] ) { Subscription [[s]] = this . [[upstream]] ; if ( [[s]] != null ) { [[s]] . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long [[antitoxin]] ) { Subscription [[acute]] = this . [[lapsed]] ; if ( [[acute]] != null ) { [[acute]] . request ( [[antitoxin]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 63 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 30 / 0 / 63:   6%|▋         | 63/1000 [1:45:21<26:06:53, 100.33s/it][Succeeded / Failed / Skipped / Total] 33 / 30 / 0 / 63:   6%|▋         | 64/1000 [1:46:11<25:52:56, 99.55s/it] [Succeeded / Failed / Skipped / Total] 34 / 30 / 0 / 64:   6%|▋         | 64/1000 [1:46:11<25:52:56, 99.55s/it][Succeeded / Failed / Skipped / Total] 34 / 30 / 0 / 64:   6%|▋         | 65/1000 [1:50:38<26:31:36, 102.14s/it][Succeeded / Failed / Skipped / Total] 34 / 31 / 0 / 65:   6%|▋         | 65/1000 [1:50:38<26:31:36, 102.14s/it][Succeeded / Failed / Skipped / Total] 34 / 31 / 0 / 65:   7%|▋         | 66/1000 [1:52:14<26:28:17, 102.03s/it][Succeeded / Failed / Skipped / Total] 34 / 32 / 0 / 66:   7%|▋         | 66/1000 [1:52:14<26:28:17, 102.03s/it][Succeeded / Failed / Skipped / Total] 34 / 32 / 0 / 66:   7%|▋         | 67/1000 [1:52:39<26:08:52, 100.89s/it][Succeeded / Failed / Skipped / Total] 35 / 32 / 0 / 67:   7%|▋         | 67/1000 [1:52:39<26:08:52, 100.89s/it][Succeeded / Failed / Skipped / Total] 35 / 32 / 0 / 67:   7%|▋         | 68/1000 [1:55:46<26:26:41, 102.15s/it]Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[playtime]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Creates an error response. --> De-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[deformity]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 65 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 66 ---------------------------------------------
Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 67 ---------------------------------------------
Calculates the delay between the specified time units. --> leopoldo@param jitsu@return --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[leopoldo]] ( TimeUnit [[jitsu]] ) { float [[sleepy]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 32 / 0 / 68:   7%|▋         | 68/1000 [1:55:46<26:26:41, 102.15s/it][Succeeded / Failed / Skipped / Total] 36 / 32 / 0 / 68:   7%|▋         | 69/1000 [1:56:07<26:06:57, 100.99s/it][Succeeded / Failed / Skipped / Total] 37 / 32 / 0 / 69:   7%|▋         | 69/1000 [1:56:08<26:06:57, 100.99s/it][Succeeded / Failed / Skipped / Total] 37 / 32 / 0 / 69:   7%|▋         | 70/1000 [1:59:12<26:23:47, 102.18s/it][Succeeded / Failed / Skipped / Total] 38 / 32 / 0 / 70:   7%|▋         | 70/1000 [1:59:12<26:23:47, 102.18s/it][Succeeded / Failed / Skipped / Total] 38 / 32 / 0 / 70:   7%|▋         | 71/1000 [1:59:26<26:02:46, 100.93s/it][Succeeded / Failed / Skipped / Total] 39 / 32 / 0 / 71:   7%|▋         | 71/1000 [1:59:26<26:02:46, 100.93s/it][Succeeded / Failed / Skipped / Total] 39 / 32 / 0 / 71:   7%|▋         | 72/1000 [2:00:16<25:50:13, 100.23s/it][Succeeded / Failed / Skipped / Total] 39 / 33 / 0 / 72:   7%|▋         | 72/1000 [2:00:16<25:50:13, 100.23s/it][Succeeded / Failed / Skipped / Total] 39 / 33 / 0 / 72:   7%|▋         | 73/1000 [2:05:45<26:36:54, 103.36s/it][Succeeded / Failed / Skipped / Total] 39 / 34 / 0 / 73:   7%|▋         | 73/1000 [2:05:45<26:36:54, 103.36s/it][Succeeded / Failed / Skipped / Total] 39 / 34 / 0 / 73:   7%|▋         | 74/1000 [2:05:51<26:14:50, 102.04s/it][Succeeded / Failed / Skipped / Total] 40 / 34 / 0 / 74:   7%|▋         | 74/1000 [2:05:51<26:14:50, 102.04s/it][Succeeded / Failed / Skipped / Total] 40 / 34 / 0 / 74:   8%|▊         | 75/1000 [2:05:59<25:53:59, 100.80s/it]Returns the value of the given HTTP method. --> Diese Methode die Methode mit dem die Methode mit dem die Methode mit dem dieMethode mit dem dieMethode mit dem dieMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode mitMethode --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[overdoses]] ( String [[miao]] ) { try { return HttpMethod . valueOf ( [[miao]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 69 ---------------------------------------------
Sets the delay in milliseconds.@param amount the amount@param unit the unit --> Sikeston statistics --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[sikeston]] ( long amount , TimeUnit [[proficiency]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[typefaces]] = [[proficiency]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 70 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> Taken from Wikitext --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[trop]] ( String username , String [[kung]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[attitudes]] = new UsernamePasswordAuthenticationToken ( username , [[kung]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 71 ---------------------------------------------
Performs version checks. --> Bataan information. --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[bataan]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 73 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > [[cf]] , final Scheduler [[scheduler]] ) { final Flowable < T > [[flowable]] = [[cf]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[gravitationally]] ( final ConnectableFlowable < T > [[endo]] , final Scheduler [[ministerial]] ) { final Flowable < T > [[amplify]] = [[endo]] . observeOn ( [[ministerial]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[endo]] , [[amplify]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 74 ---------------------------------------------
Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> Denzel LDAP query. --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[denzel]] ( String [[passkey]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[passkey]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[passkey]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[passkey]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 75 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 35 / 0 / 75:   8%|▊         | 75/1000 [2:05:59<25:53:59, 100.80s/it][Succeeded / Failed / Skipped / Total] 40 / 35 / 0 / 75:   8%|▊         | 76/1000 [2:07:00<25:44:08, 100.27s/it][Succeeded / Failed / Skipped / Total] 40 / 36 / 0 / 76:   8%|▊         | 76/1000 [2:07:00<25:44:08, 100.27s/it][Succeeded / Failed / Skipped / Total] 40 / 36 / 0 / 76:   8%|▊         | 77/1000 [2:07:04<25:23:12, 99.02s/it] [Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 77/1000 [2:07:04<25:23:12, 99.02s/it][Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 78/1000 [2:12:34<26:07:07, 101.98s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 78/1000 [2:12:34<26:07:07, 101.98s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 79/1000 [2:14:14<26:04:57, 101.95s/it][Succeeded / Failed / Skipped / Total] 41 / 38 / 0 / 79:   8%|▊         | 79/1000 [2:14:14<26:04:57, 101.95s/it][Succeeded / Failed / Skipped / Total] 41 / 38 / 0 / 79:   8%|▊         | 80/1000 [2:16:57<26:14:55, 102.71s/it][Succeeded / Failed / Skipped / Total] 41 / 39 / 0 / 80:   8%|▊         | 80/1000 [2:16:57<26:14:55, 102.71s/it][Succeeded / Failed / Skipped / Total] 41 / 39 / 0 / 80:   8%|▊         | 81/1000 [2:17:45<26:02:54, 102.04s/it][Succeeded / Failed / Skipped / Total] 41 / 40 / 0 / 81:   8%|▊         | 81/1000 [2:17:45<26:02:54, 102.04s/it][Succeeded / Failed / Skipped / Total] 41 / 40 / 0 / 81:   8%|▊         | 82/1000 [2:19:22<26:00:14, 101.98s/it]Parses the response annotations. --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 76 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[unwrapping]] ( CharSequence [[tripathi]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[tripathi]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 77 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[sailfish]] ( ) { Properties [[horoscopes]] = new Properties ( ) ; try { [[horoscopes]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[horoscopes]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 78 ---------------------------------------------
Determines whether or not checks should be disabled. --> Dummkopf function --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String springSecurityVersion ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[dummkopf]] ( String [[fluctuate]] , String springSecurityVersion ) { if ( [[fluctuate]] == null || [[fluctuate]] . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 79 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[addictions]] ( ) throws Exception { ApplicationContext [[aurora]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[aurora]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 80 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[legos]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[mcgraw]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[mcgraw]] ) ; return [[mcgraw]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 81 ---------------------------------------------
Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[trickle]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[sufficient]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[sufficient]] ) ; return [[sufficient]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 82 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 41 / 0 / 82:   8%|▊         | 82/1000 [2:19:22<26:00:14, 101.98s/it][Succeeded / Failed / Skipped / Total] 41 / 41 / 0 / 82:   8%|▊         | 83/1000 [2:19:25<25:40:24, 100.79s/it][Succeeded / Failed / Skipped / Total] 42 / 41 / 0 / 83:   8%|▊         | 83/1000 [2:19:25<25:40:24, 100.79s/it][Succeeded / Failed / Skipped / Total] 42 / 41 / 0 / 83:   8%|▊         | 84/1000 [2:20:00<25:26:42, 100.00s/it][Succeeded / Failed / Skipped / Total] 42 / 42 / 0 / 84:   8%|▊         | 84/1000 [2:20:00<25:26:42, 100.00s/it][Succeeded / Failed / Skipped / Total] 42 / 42 / 0 / 84:   8%|▊         | 85/1000 [2:20:47<25:15:34, 99.38s/it] [Succeeded / Failed / Skipped / Total] 43 / 42 / 0 / 85:   8%|▊         | 85/1000 [2:20:47<25:15:34, 99.38s/it][Succeeded / Failed / Skipped / Total] 43 / 42 / 0 / 85:   9%|▊         | 86/1000 [2:25:28<25:46:01, 101.49s/it]Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 83 ---------------------------------------------
Search for a single entry under the given base and filter. --> Rethrows an NamingException --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[tosspot]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 84 ---------------------------------------------
Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[victorious]] ( String [[cortex]] ) { AttributeExchangeConfigurer [[arks]] = new AttributeExchangeConfigurer ( [[cortex]] ) ; this . attributeExchangeConfigurers . add ( [[arks]] ) ; return [[arks]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 85 ---------------------------------------------
Compare two LDAP attributes.@param dn@param attributeName@param value@return --> Yoshima yoshima@param dn@param attributeName@param theater@return --> Socre: 1.0

[[[[Adv]]]]: public boolean [[compare]] ( final String dn , final String attributeName , final Object [[value]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[match]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[yoshimoto]] ( final String dn , final String attributeName , final Object [[theater]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[theater]] } , ctls ) ; Boolean [[patient]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[patient]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 43 / 43 / 0 / 86:   9%|▊         | 86/1000 [2:25:28<25:46:01, 101.49s/it][Succeeded / Failed / Skipped / Total] 43 / 43 / 0 / 86:   9%|▊         | 87/1000 [2:31:43<26:32:14, 104.64s/it][Succeeded / Failed / Skipped / Total] 44 / 43 / 0 / 87:   9%|▊         | 87/1000 [2:31:43<26:32:14, 104.64s/it][Succeeded / Failed / Skipped / Total] 44 / 43 / 0 / 87:   9%|▉         | 88/1000 [2:33:08<26:27:06, 104.41s/it][Succeeded / Failed / Skipped / Total] 44 / 44 / 0 / 88:   9%|▉         | 88/1000 [2:33:08<26:27:06, 104.41s/it][Succeeded / Failed / Skipped / Total] 44 / 44 / 0 / 88:   9%|▉         | 89/1000 [2:33:13<26:08:28, 103.30s/it][Succeeded / Failed / Skipped / Total] 44 / 45 / 0 / 89:   9%|▉         | 89/1000 [2:33:13<26:08:28, 103.30s/it][Succeeded / Failed / Skipped / Total] 44 / 45 / 0 / 89:   9%|▉         | 90/1000 [2:33:26<25:51:24, 102.29s/it]Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[stirrup]] ( SearchControls [[hiatus]] ) { return new SearchControls ( [[hiatus]] . getSearchScope ( ) , [[hiatus]] . getCountLimit ( ) , [[hiatus]] . getTimeLimit ( ) , [[hiatus]] . getReturningAttributes ( ) , RETURN_OBJECT , [[hiatus]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 87 ---------------------------------------------
Retrieves an entry from the LDAP server. --> SUGGEST IT --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes attrs = [[ctx]] . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[suckling]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[astrology]] ) throws NamingException { Attributes attrs = [[astrology]] . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 88 ---------------------------------------------
Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 89 ---------------------------------------------
Creates the servlet api filter. --> [[[FAILED]]]

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 90 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 45 / 0 / 90:   9%|▉         | 90/1000 [2:33:26<25:51:24, 102.29s/it][Succeeded / Failed / Skipped / Total] 45 / 45 / 0 / 90:   9%|▉         | 91/1000 [2:34:13<25:40:30, 101.68s/it][Succeeded / Failed / Skipped / Total] 45 / 46 / 0 / 91:   9%|▉         | 91/1000 [2:34:13<25:40:30, 101.68s/it][Succeeded / Failed / Skipped / Total] 45 / 46 / 0 / 91:   9%|▉         | 92/1000 [2:34:22<25:23:38, 100.68s/it][Succeeded / Failed / Skipped / Total] 45 / 47 / 0 / 92:   9%|▉         | 92/1000 [2:34:22<25:23:38, 100.68s/it][Succeeded / Failed / Skipped / Total] 45 / 47 / 0 / 92:   9%|▉         | 93/1000 [2:34:31<25:07:02, 99.69s/it] [Succeeded / Failed / Skipped / Total] 46 / 47 / 0 / 93:   9%|▉         | 93/1000 [2:34:31<25:07:02, 99.69s/it][Succeeded / Failed / Skipped / Total] 46 / 47 / 0 / 93:   9%|▉         | 94/1000 [2:35:02<24:54:15, 98.96s/it][Succeeded / Failed / Skipped / Total] 47 / 47 / 0 / 94:   9%|▉         | 94/1000 [2:35:02<24:54:15, 98.96s/it][Succeeded / Failed / Skipped / Total] 47 / 47 / 0 / 94:  10%|▉         | 95/1000 [2:35:13<24:38:43, 98.04s/it][Succeeded / Failed / Skipped / Total] 48 / 47 / 0 / 95:  10%|▉         | 95/1000 [2:35:13<24:38:43, 98.04s/it][Succeeded / Failed / Skipped / Total] 48 / 47 / 0 / 95:  10%|▉         | 96/1000 [2:35:26<24:23:45, 97.15s/it]Registers a spring security filter chain. --> Register an eeps filter. --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[eeps]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 91 ---------------------------------------------
Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 92 ---------------------------------------------
Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 93 ---------------------------------------------
Creates and initializes the filter. --> Dynamically embarass. --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[embarass]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 94 ---------------------------------------------
Called after properties have been set. --> Duck Controls --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[ducking]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Lookup a set of primary keys.@param acls@param findNow@param sids --> FRIENY LOAD --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > [[acls]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[acls]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[parentsToLookup]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[acls]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[phony]] ( final Map < Serializable , Acl > [[armory]] , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( [[armory]] , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > [[cinemax]] = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( [[armory]] , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 96 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 48 / 0 / 96:  10%|▉         | 96/1000 [2:35:26<24:23:45, 97.15s/it][Succeeded / Failed / Skipped / Total] 48 / 48 / 0 / 96:  10%|▉         | 97/1000 [2:41:29<25:03:21, 99.89s/it][Succeeded / Failed / Skipped / Total] 48 / 49 / 0 / 97:  10%|▉         | 97/1000 [2:41:29<25:03:21, 99.89s/it][Succeeded / Failed / Skipped / Total] 48 / 49 / 0 / 97:  10%|▉         | 98/1000 [2:42:23<24:54:36, 99.42s/it][Succeeded / Failed / Skipped / Total] 49 / 49 / 0 / 98:  10%|▉         | 98/1000 [2:42:23<24:54:36, 99.42s/it][Succeeded / Failed / Skipped / Total] 49 / 49 / 0 / 98:  10%|▉         | 99/1000 [2:44:01<24:52:50, 99.41s/it][Succeeded / Failed / Skipped / Total] 49 / 50 / 0 / 99:  10%|▉         | 99/1000 [2:44:01<24:52:50, 99.41s/it][Succeeded / Failed / Skipped / Total] 49 / 50 / 0 / 99:  10%|█         | 100/1000 [2:49:29<25:25:28, 101.70s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 100/1000 [2:49:29<25:25:28, 101.70s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 101/1000 [2:50:27<25:17:12, 101.26s/it]Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 97 ---------------------------------------------
Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[mindanao]] ( String [[howitzers]] ) { try { return Cipher . getInstance ( [[howitzers]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 98 ---------------------------------------------
Checks the content length of the response. --> Bhaiyya --> Socre: 1.0

[[[[Adv]]]]: private void [[checkContentLength]] ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[bhaiyya]] ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 99 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[devalued]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[gregg]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[gregg]] = [[gregg]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[gregg]] = [[gregg]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[gregg]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 100 ---------------------------------------------
Performs a pre-authenticated authentication. --> zod@param request@param response@throws IOException@throws ServletException --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken [[authRequest]] = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( [[authRequest]] ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[zod]] ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken [[blackest]] = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; [[blackest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( [[blackest]] ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 101 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 101/1000 [2:50:27<25:17:12, 101.26s/it][Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 102/1000 [2:51:22<25:08:45, 100.81s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 102/1000 [2:51:22<25:08:45, 100.81s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 103/1000 [2:51:43<24:55:31, 100.03s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 103/1000 [2:51:43<24:55:31, 100.03s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 104/1000 [2:53:27<24:54:21, 100.07s/it][Succeeded / Failed / Skipped / Total] 52 / 52 / 0 / 104:  10%|█         | 104/1000 [2:53:27<24:54:21, 100.07s/it][Succeeded / Failed / Skipped / Total] 52 / 52 / 0 / 104:  10%|█         | 105/1000 [2:53:31<24:39:06, 99.16s/it] [Succeeded / Failed / Skipped / Total] 53 / 52 / 0 / 105:  10%|█         | 105/1000 [2:53:31<24:39:06, 99.16s/it][Succeeded / Failed / Skipped / Total] 53 / 52 / 0 / 105:  11%|█         | 106/1000 [2:53:48<24:25:52, 98.38s/it][Succeeded / Failed / Skipped / Total] 53 / 53 / 0 / 106:  11%|█         | 106/1000 [2:53:48<24:25:52, 98.38s/it][Succeeded / Failed / Skipped / Total] 53 / 53 / 0 / 106:  11%|█         | 107/1000 [2:55:48<24:27:15, 98.58s/it]Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > [[result]] = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { [[result]] . add ( getGrantedAuthority ( attribute ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[airports]] ( Collection < String > [[tasked]] ) { List < GrantedAuthority > [[deodorants]] = new ArrayList <> ( [[tasked]] . size ( ) ) ; for ( String attribute : [[tasked]] ) { [[deodorants]] . add ( getGrantedAuthority ( attribute ) ) ; } return [[deodorants]] ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 102 ---------------------------------------------
Updates the default authentication settings. --> zambi --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[zamboni]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 103 ---------------------------------------------
Maps a password value to a string. --> Converts an obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfusc --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[exhibits]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 104 ---------------------------------------------
Sets the login processing URL. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[inconvenience]] ( String loginProcessingUrl ) { this . [[valorous]] = [[inconvenience]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[inconvenience]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 105 ---------------------------------------------
Updates the default access settings. --> Not permit all --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[impartiality]] ( B [[matsushima]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[matsushima]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 106 ---------------------------------------------
Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[stiles]] ( String [[reviewers]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[peasants]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[peasants]] . getString ( 1 ) , [[peasants]] . getString ( 2 ) , [[peasants]] . getString ( 3 ) , [[peasants]] . getTimestamp ( 4 ) ) ; } } , [[reviewers]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[reviewers]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[reviewers]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[reviewers]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 107 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 53 / 54 / 0 / 107:  11%|█         | 107/1000 [2:55:48<24:27:15, 98.58s/it][Succeeded / Failed / Skipped / Total] 53 / 54 / 0 / 107:  11%|█         | 108/1000 [2:56:09<24:14:58, 97.87s/it][Succeeded / Failed / Skipped / Total] 53 / 55 / 0 / 108:  11%|█         | 108/1000 [2:56:09<24:14:58, 97.87s/it][Succeeded / Failed / Skipped / Total] 53 / 55 / 0 / 108:  11%|█         | 109/1000 [2:59:04<24:23:45, 98.57s/it][Succeeded / Failed / Skipped / Total] 53 / 56 / 0 / 109:  11%|█         | 109/1000 [2:59:04<24:23:45, 98.57s/it][Succeeded / Failed / Skipped / Total] 53 / 56 / 0 / 109:  11%|█         | 110/1000 [3:04:01<24:48:51, 100.37s/it][Succeeded / Failed / Skipped / Total] 53 / 57 / 0 / 110:  11%|█         | 110/1000 [3:04:01<24:48:51, 100.37s/it][Succeeded / Failed / Skipped / Total] 53 / 57 / 0 / 110:  11%|█         | 111/1000 [3:06:39<24:54:54, 100.89s/it][Succeeded / Failed / Skipped / Total] 53 / 58 / 0 / 111:  11%|█         | 111/1000 [3:06:39<24:54:54, 100.89s/it][Succeeded / Failed / Skipped / Total] 53 / 58 / 0 / 111:  11%|█         | 112/1000 [3:07:13<24:44:27, 100.30s/it]Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[boathouse]] ( HttpServletRequest request , Authentication [[foetus]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[foetus]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[foetus]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "[[Bronwyn]]" == "[[Bronwyn]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 108 ---------------------------------------------
Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[authorities]] ) { [[mapped]] . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[bask]] ) { HashSet < GrantedAuthority > [[centrist]] = new HashSet <> ( [[bask]] . size ( ) ) ; for ( GrantedAuthority [[incompetence]] : [[bask]] ) { [[centrist]] . add ( mapAuthority ( [[incompetence]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[centrist]] . add ( defaultAuthority ) ; } return [[centrist]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 109 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( request , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[pickpocket]] ( ServletRequest request , ServletResponse [[kashi]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[kashi]] ) ; } chain . doFilter ( request , [[kashi]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 110 ---------------------------------------------
Returns the port of the given service URL. --> [[[FAILED]]]

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[fitzsimmons]] ( URL [[briefly]] ) { int port = [[briefly]] . getPort ( ) ; if ( port == - 1 ) { port = [[briefly]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 111 ---------------------------------------------
Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 58 / 0 / 112:  11%|█         | 112/1000 [3:07:13<24:44:27, 100.30s/it][Succeeded / Failed / Skipped / Total] 54 / 58 / 0 / 112:  11%|█▏        | 113/1000 [3:07:45<24:33:47, 99.69s/it] [Succeeded / Failed / Skipped / Total] 55 / 58 / 0 / 113:  11%|█▏        | 113/1000 [3:07:45<24:33:47, 99.69s/it][Succeeded / Failed / Skipped / Total] 55 / 58 / 0 / 113:  11%|█▏        | 114/1000 [3:08:15<24:23:08, 99.08s/it][Succeeded / Failed / Skipped / Total] 55 / 59 / 0 / 114:  11%|█▏        | 114/1000 [3:08:15<24:23:08, 99.08s/it][Succeeded / Failed / Skipped / Total] 55 / 59 / 0 / 114:  12%|█▏        | 115/1000 [3:11:31<24:33:55, 99.93s/it][Succeeded / Failed / Skipped / Total] 55 / 60 / 0 / 115:  12%|█▏        | 115/1000 [3:11:31<24:33:55, 99.93s/it][Succeeded / Failed / Skipped / Total] 55 / 60 / 0 / 115:  12%|█▏        | 116/1000 [3:11:53<24:22:21, 99.26s/it][Succeeded / Failed / Skipped / Total] 56 / 60 / 0 / 116:  12%|█▏        | 116/1000 [3:11:53<24:22:21, 99.26s/it][Succeeded / Failed / Skipped / Total] 56 / 60 / 0 / 116:  12%|█▏        | 117/1000 [3:11:58<24:08:49, 98.45s/it][Succeeded / Failed / Skipped / Total] 56 / 61 / 0 / 117:  12%|█▏        | 117/1000 [3:11:58<24:08:49, 98.45s/it][Succeeded / Failed / Skipped / Total] 56 / 61 / 0 / 117:  12%|█▏        | 118/1000 [3:12:08<23:56:10, 97.70s/it]Sets the cookie. --> Registers an anti-antisantisantisantisantisantisantisantisantisantisantisantisantis --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] [[tokens]] , int [[maxAge]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[maxAge]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[True]]" == "[[True]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[prohibit]] ( String [ ] [[lecturer]] , int [[bigotry]] , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[lecturer]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[bigotry]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[bigotry]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[Questionnaire]]" == "[[Questionnaire]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 113 ---------------------------------------------
Logs out the given request and response. --> zhuo authentication --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[context]] = SecurityContextHolder . getContext ( ) ; [[context]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[zhuo]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[armchairs]] = SecurityContextHolder . getContext ( ) ; [[armchairs]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 114 ---------------------------------------------
Extracts the remember-me cookie from the request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : [[cookies]] ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[zahara]] ( HttpServletRequest [[blush]] ) { Cookie [ ] [[malika]] = [[blush]] . getCookies ( ) ; if ( ( [[malika]] == null ) || ( [[malika]] . length == 0 ) ) { return null ; } for ( Cookie [[launches]] : [[malika]] ) { if ( cookieName . equals ( [[launches]] . getName ( ) ) ) { return [[launches]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 115 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 116 ---------------------------------------------
End the page. --> R rubik@throws JspException --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[rubik]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 117 ---------------------------------------------
Resolve the security context for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 118 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 61 / 0 / 118:  12%|█▏        | 118/1000 [3:12:08<23:56:10, 97.70s/it][Succeeded / Failed / Skipped / Total] 57 / 61 / 0 / 118:  12%|█▏        | 119/1000 [3:13:33<23:52:55, 97.59s/it][Succeeded / Failed / Skipped / Total] 57 / 62 / 0 / 119:  12%|█▏        | 119/1000 [3:13:33<23:52:55, 97.59s/it][Succeeded / Failed / Skipped / Total] 57 / 62 / 0 / 119:  12%|█▏        | 120/1000 [3:14:46<23:48:20, 97.39s/it][Succeeded / Failed / Skipped / Total] 57 / 63 / 0 / 120:  12%|█▏        | 120/1000 [3:14:46<23:48:20, 97.39s/it][Succeeded / Failed / Skipped / Total] 57 / 63 / 0 / 120:  12%|█▏        | 121/1000 [3:16:55<23:50:32, 97.65s/it][Succeeded / Failed / Skipped / Total] 58 / 63 / 0 / 121:  12%|█▏        | 121/1000 [3:16:55<23:50:32, 97.65s/it][Succeeded / Failed / Skipped / Total] 58 / 63 / 0 / 121:  12%|█▏        | 122/1000 [3:17:33<23:41:46, 97.16s/it][Succeeded / Failed / Skipped / Total] 58 / 64 / 0 / 122:  12%|█▏        | 122/1000 [3:17:33<23:41:46, 97.16s/it][Succeeded / Failed / Skipped / Total] 58 / 64 / 0 / 122:  12%|█▏        | 123/1000 [3:18:54<23:38:17, 97.03s/it][Succeeded / Failed / Skipped / Total] 59 / 64 / 0 / 123:  12%|█▏        | 123/1000 [3:18:54<23:38:17, 97.03s/it][Succeeded / Failed / Skipped / Total] 59 / 64 / 0 / 123:  12%|█▏        | 124/1000 [3:21:14<23:41:40, 97.37s/it]Sets the context environment properties.@param environment the context environment properties --> Shruti shruti --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[shruti]] ( Map < String , Object > [[aoki]] ) { Assert . notEmpty ( [[aoki]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[aoki]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 119 ---------------------------------------------
Returns the fully-qualified URL to redirect to. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[schwartz]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 120 ---------------------------------------------
Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[tormentor]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 121 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> D dodo@param request@param response@return --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[dodo]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 122 ---------------------------------------------
Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[unqualified]] ( ) { Map < String , ? > [[leadville]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[leadville]] . size ( ) == 0 ) { [[leadville]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[leadville]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[leadville]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[leadville]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 123 ---------------------------------------------
Authenticates the given authentication object. --> Creates a UsernamePasswordAuthenticationToken from a UsernamePasswordAuthenticationToken. --> Socre: 1.0

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[tuna]] ( Authentication [[brute]] ) throws AuthenticationException { if ( ! ( [[brute]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[drinkers]] = ( UsernamePasswordAuthenticationToken ) [[brute]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 124 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 65 / 0 / 124:  12%|█▏        | 124/1000 [3:21:14<23:41:40, 97.37s/it][Succeeded / Failed / Skipped / Total] 59 / 65 / 0 / 124:  12%|█▎        | 125/1000 [3:22:03<23:34:27, 96.99s/it][Succeeded / Failed / Skipped / Total] 60 / 65 / 0 / 125:  12%|█▎        | 125/1000 [3:22:03<23:34:27, 96.99s/it][Succeeded / Failed / Skipped / Total] 60 / 65 / 0 / 125:  13%|█▎        | 126/1000 [3:25:02<23:42:13, 97.64s/it][Succeeded / Failed / Skipped / Total] 60 / 66 / 0 / 126:  13%|█▎        | 126/1000 [3:25:02<23:42:13, 97.64s/it][Succeeded / Failed / Skipped / Total] 60 / 66 / 0 / 126:  13%|█▎        | 127/1000 [3:25:07<23:30:02, 96.91s/it][Succeeded / Failed / Skipped / Total] 60 / 67 / 0 / 127:  13%|█▎        | 127/1000 [3:25:07<23:30:02, 96.91s/it][Succeeded / Failed / Skipped / Total] 60 / 67 / 0 / 127:  13%|█▎        | 128/1000 [3:25:15<23:18:22, 96.22s/it][Succeeded / Failed / Skipped / Total] 61 / 67 / 0 / 128:  13%|█▎        | 128/1000 [3:25:15<23:18:22, 96.22s/it][Succeeded / Failed / Skipped / Total] 61 / 67 / 0 / 128:  13%|█▎        | 129/1000 [3:27:54<23:23:48, 96.70s/it][Succeeded / Failed / Skipped / Total] 62 / 67 / 0 / 129:  13%|█▎        | 129/1000 [3:27:54<23:23:48, 96.70s/it][Succeeded / Failed / Skipped / Total] 62 / 67 / 0 / 129:  13%|█▎        | 130/1000 [3:32:44<23:43:45, 98.19s/it]Initializes the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[islam]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 125 ---------------------------------------------
Add Pkce parameters. --> B bloodier method --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[bloodier]] ( Map < String , Object > attributes , Map < String , Object > [[maddy]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[maddy]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[maddy]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[maddy]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 126 ---------------------------------------------
Returns true if the user is authenticated. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[localize]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 127 ---------------------------------------------
Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 128 ---------------------------------------------
URL-encode the given value. --> Encodes the given value. --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[actin]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 129 ---------------------------------------------
Creates a security expression root. --> MethodSecurityExpressionOperations@param están@param invocation@return --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( [[authentication]] ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[axes]] ( Authentication [[están]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[swims]] = new MethodSecurityExpressionRoot ( [[están]] ) ; [[swims]] . setThis ( invocation . getThis ( ) ) ; [[swims]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[swims]] . setTrustResolver ( getTrustResolver ( ) ) ; [[swims]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[swims]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[swims]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 130 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 68 / 0 / 130:  13%|█▎        | 130/1000 [3:32:44<23:43:45, 98.19s/it][Succeeded / Failed / Skipped / Total] 62 / 68 / 0 / 130:  13%|█▎        | 131/1000 [3:33:43<23:37:47, 97.89s/it][Succeeded / Failed / Skipped / Total] 62 / 69 / 0 / 131:  13%|█▎        | 131/1000 [3:33:43<23:37:47, 97.89s/it][Succeeded / Failed / Skipped / Total] 62 / 69 / 0 / 131:  13%|█▎        | 132/1000 [3:35:36<23:37:45, 98.00s/it][Succeeded / Failed / Skipped / Total] 62 / 70 / 0 / 132:  13%|█▎        | 132/1000 [3:35:36<23:37:46, 98.00s/it][Succeeded / Failed / Skipped / Total] 62 / 70 / 0 / 132:  13%|█▎        | 133/1000 [3:36:03<23:28:23, 97.47s/it][Succeeded / Failed / Skipped / Total] 62 / 71 / 0 / 133:  13%|█▎        | 133/1000 [3:36:03<23:28:23, 97.47s/it][Succeeded / Failed / Skipped / Total] 62 / 71 / 0 / 133:  13%|█▎        | 134/1000 [3:38:03<23:29:15, 97.64s/it][Succeeded / Failed / Skipped / Total] 62 / 72 / 0 / 134:  13%|█▎        | 134/1000 [3:38:03<23:29:15, 97.64s/it][Succeeded / Failed / Skipped / Total] 62 / 72 / 0 / 134:  14%|█▎        | 135/1000 [3:41:15<23:37:41, 98.34s/it][Succeeded / Failed / Skipped / Total] 62 / 73 / 0 / 135:  14%|█▎        | 135/1000 [3:41:15<23:37:41, 98.34s/it][Succeeded / Failed / Skipped / Total] 62 / 73 / 0 / 135:  14%|█▎        | 136/1000 [3:43:16<23:38:29, 98.51s/it][Succeeded / Failed / Skipped / Total] 63 / 73 / 0 / 136:  14%|█▎        | 136/1000 [3:43:16<23:38:29, 98.51s/it][Succeeded / Failed / Skipped / Total] 63 / 73 / 0 / 136:  14%|█▎        | 137/1000 [3:46:52<23:49:08, 99.36s/it]Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean result = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[rite]] ( final HttpServletRequest request , final HttpServletResponse [[afterthat]] ) { boolean result = super . requiresAuthentication ( request , [[afterthat]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 131 ---------------------------------------------
Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[request]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[pressing]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[pressing]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 132 ---------------------------------------------
Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[cried]] ( final Assertion [[debris]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[debris]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 133 ---------------------------------------------
Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[chambre]] ( ) { List < String > [[resolutely]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[apostate]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[resolutely]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[resolutely]] + " mapped to Granted Authorities: " + [[apostate]] ) ; } return [[apostate]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 134 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[asylums]] ( HttpServletRequest [[derringer]] ) { Object [[exporting]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[exporting]] ) ; } return [[exporting]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 135 ---------------------------------------------
Retrieves a single JWK set. --> [[[FAILED]]]

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[cachedJWKSet]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[comparisons]] ( ) { return this . [[wanzer]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . [[hose]] . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 136 ---------------------------------------------
Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> Sleep for a certain amount of time. --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[sleepover]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[crap]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[crap]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[crap]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 137 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 63 / 74 / 0 / 137:  14%|█▎        | 137/1000 [3:46:52<23:49:08, 99.36s/it][Succeeded / Failed / Skipped / Total] 63 / 74 / 0 / 137:  14%|█▍        | 138/1000 [3:47:56<23:43:50, 99.11s/it][Succeeded / Failed / Skipped / Total] 64 / 74 / 0 / 138:  14%|█▍        | 138/1000 [3:47:56<23:43:50, 99.11s/it][Succeeded / Failed / Skipped / Total] 64 / 74 / 0 / 138:  14%|█▍        | 139/1000 [3:47:57<23:31:59, 98.40s/it][Succeeded / Failed / Skipped / Total] 65 / 74 / 0 / 139:  14%|█▍        | 139/1000 [3:47:57<23:31:59, 98.40s/it][Succeeded / Failed / Skipped / Total] 65 / 74 / 0 / 139:  14%|█▍        | 140/1000 [3:51:13<23:40:20, 99.09s/it][Succeeded / Failed / Skipped / Total] 65 / 75 / 0 / 140:  14%|█▍        | 140/1000 [3:51:13<23:40:20, 99.09s/it][Succeeded / Failed / Skipped / Total] 65 / 75 / 0 / 140:  14%|█▍        | 141/1000 [3:52:13<23:34:48, 98.82s/it][Succeeded / Failed / Skipped / Total] 66 / 75 / 0 / 141:  14%|█▍        | 141/1000 [3:52:13<23:34:48, 98.82s/it][Succeeded / Failed / Skipped / Total] 66 / 75 / 0 / 141:  14%|█▍        | 142/1000 [3:53:38<23:31:43, 98.72s/it][Succeeded / Failed / Skipped / Total] 66 / 76 / 0 / 142:  14%|█▍        | 142/1000 [3:53:38<23:31:43, 98.72s/it][Succeeded / Failed / Skipped / Total] 66 / 76 / 0 / 142:  14%|█▍        | 143/1000 [3:53:55<23:21:56, 98.15s/it]Returns a collection of authorities for the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , [[value]] ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[nauseating]] ( Object [[masturbating]] ) { Collection < GrantedAuthority > [[unbiased]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[unbiased]] , [[masturbating]] ) ; return [[unbiased]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 138 ---------------------------------------------
Creates a subarray from an array of bytes. --> Liefert die angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen angegebenen --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] array , int beginIndex , int [[endIndex]] ) { int length = [[endIndex]] - beginIndex ; byte [ ] [[subarray]] = new byte [ length ] ; System . arraycopy ( array , beginIndex , [[subarray]] , 0 , length ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[lavonne]] ( byte [ ] array , int beginIndex , int [[bullfights]] ) { int length = [[bullfights]] - beginIndex ; byte [ ] [[unlawfully]] = new byte [ length ] ; System . arraycopy ( array , beginIndex , [[unlawfully]] , 0 , length ) ; return [[unlawfully]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 139 ---------------------------------------------
Adds a collection of granted authorities to the supplied value. --> SICILINE SICILINE --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[sicilian]] ( Collection < GrantedAuthority > [[asai]] , Object [[arsenio]] ) { if ( [[arsenio]] == null ) { return ; } if ( [[arsenio]] instanceof Collection < ? > ) { [[sicilian]] ( [[asai]] , ( Collection < ? > ) [[arsenio]] ) ; } else if ( [[arsenio]] instanceof Object [ ] ) { [[sicilian]] ( [[asai]] , ( Object [ ] ) [[arsenio]] ) ; } else if ( [[arsenio]] instanceof String ) { [[sicilian]] ( [[asai]] , ( String ) [[arsenio]] ) ; } else if ( [[arsenio]] instanceof GrantedAuthority ) { [[asai]] . add ( ( GrantedAuthority ) [[arsenio]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[arsenio]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 140 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[unproductive]] ( HttpServletRequest [[insipid]] ) { Object [[fansubs]] = [[insipid]] . getUserPrincipal ( ) == null ? null : [[insipid]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[fansubs]] ) ; } return [[fansubs]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 141 ---------------------------------------------
Invokes the specified JoinPoint. --> zizi --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[zizi]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 142 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 143 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 77 / 0 / 143:  14%|█▍        | 143/1000 [3:53:55<23:21:56, 98.15s/it][Succeeded / Failed / Skipped / Total] 66 / 77 / 0 / 143:  14%|█▍        | 144/1000 [3:56:32<23:26:05, 98.56s/it][Succeeded / Failed / Skipped / Total] 66 / 78 / 0 / 144:  14%|█▍        | 144/1000 [3:56:32<23:26:05, 98.56s/it][Succeeded / Failed / Skipped / Total] 66 / 78 / 0 / 144:  14%|█▍        | 145/1000 [3:57:49<23:22:18, 98.41s/it][Succeeded / Failed / Skipped / Total] 66 / 79 / 0 / 145:  14%|█▍        | 145/1000 [3:57:49<23:22:18, 98.41s/it][Succeeded / Failed / Skipped / Total] 66 / 79 / 0 / 145:  15%|█▍        | 146/1000 [3:59:00<23:18:00, 98.22s/it][Succeeded / Failed / Skipped / Total] 67 / 79 / 0 / 146:  15%|█▍        | 146/1000 [3:59:00<23:18:00, 98.22s/it][Succeeded / Failed / Skipped / Total] 67 / 79 / 0 / 146:  15%|█▍        | 147/1000 [4:00:55<23:18:00, 98.34s/it][Succeeded / Failed / Skipped / Total] 68 / 79 / 0 / 147:  15%|█▍        | 147/1000 [4:00:55<23:18:00, 98.34s/it][Succeeded / Failed / Skipped / Total] 68 / 79 / 0 / 147:  15%|█▍        | 148/1000 [4:01:13<23:08:42, 97.80s/it][Succeeded / Failed / Skipped / Total] 69 / 79 / 0 / 148:  15%|█▍        | 148/1000 [4:01:13<23:08:42, 97.80s/it][Succeeded / Failed / Skipped / Total] 69 / 79 / 0 / 148:  15%|█▍        | 149/1000 [4:01:26<22:59:01, 97.23s/it][Succeeded / Failed / Skipped / Total] 70 / 79 / 0 / 149:  15%|█▍        | 149/1000 [4:01:26<22:59:01, 97.23s/it][Succeeded / Failed / Skipped / Total] 70 / 79 / 0 / 149:  15%|█▌        | 150/1000 [4:02:13<22:52:39, 96.89s/it][Succeeded / Failed / Skipped / Total] 70 / 80 / 0 / 150:  15%|█▌        | 150/1000 [4:02:13<22:52:39, 96.89s/it][Succeeded / Failed / Skipped / Total] 70 / 80 / 0 / 150:  15%|█▌        | 151/1000 [4:06:25<23:05:31, 97.92s/it]Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[backstretch]] ( final boolean [[parents]] , final HttpServletRequest [[landscape]] ) { if ( [[parents]] ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[landscape]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 144 ---------------------------------------------
Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[arabella]] > [[arabella]] getSharedObject ( Class < [[arabella]] > sharedType ) { return ( [[arabella]] ) this . [[bull]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 145 ---------------------------------------------
Checks if the given role starts with ROLE_. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[subscribers]] ( String [[church]] ) { Assert . isTrue ( ! [[church]] . startsWith ( "ROLE_" ) , ( ) -> [[church]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[church]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 146 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> Removes 'ROLE_ROLE_ROLE_ROLE_ --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[obliterating]] ( String ... [[dvorak]] ) { for ( int [[childless]] = 0 ; [[childless]] < [[dvorak]] . length ; [[childless]] ++ ) { [[dvorak]] [ [[childless]] ] = "ROLE_" + [[dvorak]] [ [[childless]] ] ; } return [[dvorak]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 147 ---------------------------------------------
Sets the URL that will be used to exit from the browser. --> B bloodsucking implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[bloodsucking]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 148 ---------------------------------------------
Display a public index. --> Returns a ModelAndView with a random name --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[christof]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 149 ---------------------------------------------
Attempt to exit the user. --> zeljko authentication mechanism --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[zeljko]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 151 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 81 / 0 / 151:  15%|█▌        | 151/1000 [4:06:25<23:05:31, 97.92s/it][Succeeded / Failed / Skipped / Total] 70 / 81 / 0 / 151:  15%|█▌        | 152/1000 [4:06:25<22:54:49, 97.28s/it][Succeeded / Failed / Skipped / Total] 71 / 81 / 0 / 152:  15%|█▌        | 152/1000 [4:06:25<22:54:49, 97.28s/it][Succeeded / Failed / Skipped / Total] 71 / 81 / 0 / 152:  15%|█▌        | 153/1000 [4:07:55<22:52:27, 97.22s/it][Succeeded / Failed / Skipped / Total] 71 / 82 / 0 / 153:  15%|█▌        | 153/1000 [4:07:55<22:52:27, 97.22s/it][Succeeded / Failed / Skipped / Total] 71 / 82 / 0 / 153:  15%|█▌        | 154/1000 [4:09:57<22:53:06, 97.38s/it][Succeeded / Failed / Skipped / Total] 72 / 82 / 0 / 154:  15%|█▌        | 154/1000 [4:09:57<22:53:06, 97.38s/it][Succeeded / Failed / Skipped / Total] 72 / 82 / 0 / 154:  16%|█▌        | 155/1000 [4:10:11<22:43:57, 96.85s/it][Succeeded / Failed / Skipped / Total] 73 / 82 / 0 / 155:  16%|█▌        | 155/1000 [4:10:11<22:43:57, 96.85s/it][Succeeded / Failed / Skipped / Total] 73 / 82 / 0 / 155:  16%|█▌        | 156/1000 [4:11:30<22:40:43, 96.73s/it][Succeeded / Failed / Skipped / Total] 74 / 82 / 0 / 156:  16%|█▌        | 156/1000 [4:11:30<22:40:43, 96.73s/it][Succeeded / Failed / Skipped / Total] 74 / 82 / 0 / 156:  16%|█▌        | 157/1000 [4:15:16<22:50:39, 97.56s/it]Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[successfulAuthentication]] ) { String [[username]] = [[successfulAuthentication]] . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[username]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[username]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[dso]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[diabolic]] ) { String [[shootin]] = [[diabolic]] . getName ( ) ; logger . debug ( "Creating new persistent login for user " + [[shootin]] ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( [[shootin]] , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 152 ---------------------------------------------
Attempts to switch to the specified user. --> zeljko authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[targetUser]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[targetUser]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[zeljko]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[threatened]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[threatened]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 153 ---------------------------------------------
Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 154 ---------------------------------------------
Generate a CSRF token. --> Overrides the default implementation of Override. --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . [[delegate]] . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[contradictory]] ( HttpServletRequest request ) { return wrap ( request , this . [[raincoat]] . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 155 ---------------------------------------------
Creates a spring security filter chain. --> Performs bioprocessing. --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[biopsy]] ( ) throws Exception { boolean [[lilacs]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[lilacs]] ) { WebSecurityConfigurerAdapter [[enlisted]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[enlisted]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 156 ---------------------------------------------
Converts a jwt to a list of authorities. --> Provides a list of contributors. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[contributors]] ( Jwt [[ninja]] ) { return getScopes ( [[ninja]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 157 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 82 / 0 / 157:  16%|█▌        | 157/1000 [4:15:16<22:50:39, 97.56s/it][Succeeded / Failed / Skipped / Total] 75 / 82 / 0 / 157:  16%|█▌        | 158/1000 [4:16:04<22:44:41, 97.25s/it][Succeeded / Failed / Skipped / Total] 75 / 83 / 0 / 158:  16%|█▌        | 158/1000 [4:16:04<22:44:41, 97.25s/it][Succeeded / Failed / Skipped / Total] 75 / 83 / 0 / 158:  16%|█▌        | 159/1000 [4:16:22<22:36:03, 96.75s/it][Succeeded / Failed / Skipped / Total] 76 / 83 / 0 / 159:  16%|█▌        | 159/1000 [4:16:22<22:36:03, 96.75s/it][Succeeded / Failed / Skipped / Total] 76 / 83 / 0 / 159:  16%|█▌        | 160/1000 [4:19:13<22:40:57, 97.21s/it][Succeeded / Failed / Skipped / Total] 77 / 83 / 0 / 160:  16%|█▌        | 160/1000 [4:19:13<22:40:57, 97.21s/it][Succeeded / Failed / Skipped / Total] 77 / 83 / 0 / 160:  16%|█▌        | 161/1000 [4:19:30<22:32:21, 96.71s/it][Succeeded / Failed / Skipped / Total] 78 / 83 / 0 / 161:  16%|█▌        | 161/1000 [4:19:30<22:32:21, 96.71s/it][Succeeded / Failed / Skipped / Total] 78 / 83 / 0 / 161:  16%|█▌        | 162/1000 [4:20:15<22:26:14, 96.39s/it]Display the admin page. --> Handles "adminPermission" requests --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[contact]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[bitchin]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact [[bamboozled]] = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[bamboozled]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[bamboozled]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 158 ---------------------------------------------
Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 159 ---------------------------------------------
Decodes and validates the given token. --> Validates an easiness token.@param valli@return@throws JwtException --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String [[token]] ) throws JwtException { JWT jwt = parse ( [[token]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[token]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[easiness]] ( String [[valli]] ) throws JwtException { JWT jwt = parse ( [[valli]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[valli]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 160 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> Inflate a request@param request@return@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[inflamed]] ( ) throws IOException { String [[coutinho]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[mulberry]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[coutinho]] , getUrl ( ) , getMethod ( ) , [[mulberry]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 161 ---------------------------------------------
Returns the role with the given default prefix. --> Converts a string to a grisly string --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String role ) { if ( role == null ) { return role ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[defaultRolePrefix]] ) ) { return role ; } return [[defaultRolePrefix]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[grisly]] ( String [[alibis]] , String role ) { if ( role == null ) { return role ; } if ( [[alibis]] == null || [[alibis]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[alibis]] ) ) { return role ; } return [[alibis]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 78 / 84 / 0 / 162:  16%|█▌        | 162/1000 [4:20:15<22:26:14, 96.39s/it][Succeeded / Failed / Skipped / Total] 78 / 84 / 0 / 162:  16%|█▋        | 163/1000 [4:23:42<22:34:07, 97.07s/it][Succeeded / Failed / Skipped / Total] 78 / 85 / 0 / 163:  16%|█▋        | 163/1000 [4:23:42<22:34:07, 97.07s/it][Succeeded / Failed / Skipped / Total] 78 / 85 / 0 / 163:  16%|█▋        | 164/1000 [4:23:54<22:25:17, 96.55s/it][Succeeded / Failed / Skipped / Total] 78 / 86 / 0 / 164:  16%|█▋        | 164/1000 [4:23:54<22:25:17, 96.55s/it][Succeeded / Failed / Skipped / Total] 78 / 86 / 0 / 164:  16%|█▋        | 165/1000 [4:25:41<22:24:32, 96.61s/it][Succeeded / Failed / Skipped / Total] 78 / 87 / 0 / 165:  16%|█▋        | 165/1000 [4:25:41<22:24:32, 96.61s/it][Succeeded / Failed / Skipped / Total] 78 / 87 / 0 / 165:  17%|█▋        | 166/1000 [4:29:58<22:36:25, 97.58s/it][Succeeded / Failed / Skipped / Total] 78 / 88 / 0 / 166:  17%|█▋        | 166/1000 [4:29:58<22:36:25, 97.58s/it][Succeeded / Failed / Skipped / Total] 78 / 88 / 0 / 166:  17%|█▋        | 167/1000 [4:32:13<22:37:51, 97.81s/it]Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 163 ---------------------------------------------
Creates an instance of UserDetailsResourceFactoryBean from the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[unchain]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 165 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long [[contactId]] ) { Contact contact = contactManager . getById ( [[contactId]] ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , addPermission ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[pals]] ( @ RequestParam ( "contactId" ) long [[canvasses]] ) { Contact contact = contactManager . getById ( [[canvasses]] ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[alonso]] = new HashMap <> ( ) ; [[alonso]] . put ( "addPermission" , addPermission ) ; [[alonso]] . put ( "recipients" , listRecipients ( ) ) ; [[alonso]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[alonso]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 166 ---------------------------------------------
Decodes the given bytes into a string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[resume]] ( byte [ ] [[integration]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[integration]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 167 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 79 / 88 / 0 / 167:  17%|█▋        | 167/1000 [4:32:13<22:37:51, 97.81s/it][Succeeded / Failed / Skipped / Total] 79 / 88 / 0 / 167:  17%|█▋        | 168/1000 [4:32:48<22:31:04, 97.43s/it][Succeeded / Failed / Skipped / Total] 79 / 89 / 0 / 168:  17%|█▋        | 168/1000 [4:32:48<22:31:04, 97.43s/it][Succeeded / Failed / Skipped / Total] 79 / 89 / 0 / 168:  17%|█▋        | 169/1000 [4:34:22<22:29:07, 97.41s/it][Succeeded / Failed / Skipped / Total] 79 / 90 / 0 / 169:  17%|█▋        | 169/1000 [4:34:22<22:29:07, 97.41s/it][Succeeded / Failed / Skipped / Total] 79 / 90 / 0 / 169:  17%|█▋        | 170/1000 [4:34:40<22:21:04, 96.94s/it][Succeeded / Failed / Skipped / Total] 80 / 90 / 0 / 170:  17%|█▋        | 170/1000 [4:34:40<22:21:04, 96.94s/it][Succeeded / Failed / Skipped / Total] 80 / 90 / 0 / 170:  17%|█▋        | 171/1000 [4:38:23<22:29:39, 97.68s/it][Succeeded / Failed / Skipped / Total] 80 / 91 / 0 / 171:  17%|█▋        | 171/1000 [4:38:23<22:29:39, 97.68s/it][Succeeded / Failed / Skipped / Total] 80 / 91 / 0 / 171:  17%|█▋        | 172/1000 [4:40:40<22:31:10, 97.91s/it][Succeeded / Failed / Skipped / Total] 81 / 91 / 0 / 172:  17%|█▋        | 172/1000 [4:40:40<22:31:10, 97.91s/it][Succeeded / Failed / Skipped / Total] 81 / 91 / 0 / 172:  17%|█▋        | 173/1000 [4:43:10<22:33:42, 98.21s/it][Succeeded / Failed / Skipped / Total] 82 / 91 / 0 / 173:  17%|█▋        | 173/1000 [4:43:10<22:33:42, 98.21s/it][Succeeded / Failed / Skipped / Total] 82 / 91 / 0 / 173:  17%|█▋        | 174/1000 [4:43:52<22:27:37, 97.89s/it]Returns the first attribute value for the supplied name. --> playgirls@param merged@return --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > [[result]] = getAttributeValues ( [[name]] ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[playgirl]] ( String [[merged]] ) { List < String > [[kono]] = getAttributeValues ( [[merged]] ) ; if ( [[kono]] . isEmpty ( ) ) { return null ; } else { return [[kono]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 168 ---------------------------------------------
Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[geek]] ( String [[waived]] ) { List < String > [[bounty]] = null ; if ( attributes != null ) { [[bounty]] = attributes . get ( [[waived]] ) ; } if ( [[bounty]] == null ) { [[bounty]] = Collections . emptyList ( ) ; } return [[bounty]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 169 ---------------------------------------------
Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[paintwork]] ( CharSequence [[operatives]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[operatives]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 170 ---------------------------------------------
Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> Handles "deletePermission" requests. --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[sid]] , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid [[sidObject]] = new PrincipalSid ( [[sid]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , [[sidObject]] , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , [[sidObject]] ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[dressmaker]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[acrobatic]] , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid [[cougars]] = new PrincipalSid ( [[acrobatic]] ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , [[cougars]] , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , [[cougars]] ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 171 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[egyptologist]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 172 ---------------------------------------------
Returns a set of all the configured attributes. --> Buddda methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[budd]] ( ) { Set < ConfigAttribute > [[chairperson]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[chairperson]] . addAll ( attributeList ) ; } return [[chairperson]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 173 ---------------------------------------------
Adds a secure method.@param method the method@param attr the attr --> zloty applies to all registered methods --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[zloty]] ( RegisteredMethod [[delicto]] , List < ConfigAttribute > [[squeezes]] ) { Assert . notNull ( [[delicto]] , "RegisteredMethod required" ) ; Assert . notNull ( [[squeezes]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[delicto]] + "] with attributes [" + [[squeezes]] + "]" ) ; } this . [[pests]] . put ( [[delicto]] , [[squeezes]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
[Succeeded / Failed / Skipped / Total] 83 / 91 / 0 / 174:  17%|█▋        | 174/1000 [4:43:52<22:27:37, 97.89s/it][Succeeded / Failed / Skipped / Total] 83 / 91 / 0 / 174:  18%|█▊        | 175/1000 [4:45:30<22:25:59, 97.89s/it][Succeeded / Failed / Skipped / Total] 84 / 91 / 0 / 175:  18%|█▊        | 175/1000 [4:45:30<22:25:59, 97.89s/it][Succeeded / Failed / Skipped / Total] 84 / 91 / 0 / 175:  18%|█▊        | 176/1000 [4:45:38<22:17:20, 97.38s/it][Succeeded / Failed / Skipped / Total] 84 / 92 / 0 / 176:  18%|█▊        | 176/1000 [4:45:38<22:17:20, 97.38s/it][Succeeded / Failed / Skipped / Total] 84 / 92 / 0 / 176:  18%|█▊        | 177/1000 [4:48:44<22:22:32, 97.88s/it][Succeeded / Failed / Skipped / Total] 85 / 92 / 0 / 177:  18%|█▊        | 177/1000 [4:48:44<22:22:32, 97.88s/it][Succeeded / Failed / Skipped / Total] 85 / 92 / 0 / 177:  18%|█▊        | 178/1000 [4:48:48<22:13:43, 97.35s/it][Succeeded / Failed / Skipped / Total] 86 / 92 / 0 / 178:  18%|█▊        | 178/1000 [4:48:48<22:13:43, 97.35s/it][Succeeded / Failed / Skipped / Total] 86 / 92 / 0 / 178:  18%|█▊        | 179/1000 [4:50:04<22:10:28, 97.23s/it][Succeeded / Failed / Skipped / Total] 86 / 93 / 0 / 179:  18%|█▊        | 179/1000 [4:50:04<22:10:28, 97.23s/it][Succeeded / Failed / Skipped / Total] 86 / 93 / 0 / 179:  18%|█▊        | 180/1000 [4:52:24<22:12:02, 97.47s/it]--------------------------------------------- Result 174 ---------------------------------------------
Finds all attributes of the specified target class. --> Searches for methods that are annotated with @Cult --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[cults]] ( Method [[shadowless]] , Class < ? > [[faculties]] ) { if ( [[faculties]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[shadowless]] , [[faculties]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the method name matches the mapped name. --> burners --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[burners]] ( String [[posturing]] , String [[fanclub]] ) { return ( [[fanclub]] . endsWith ( "*" ) && [[posturing]] . startsWith ( [[fanclub]] . substring ( 0 , [[fanclub]] . length ( ) - 1 ) ) ) || ( [[fanclub]] . startsWith ( "*" ) && [[posturing]] . endsWith ( [[fanclub]] . substring ( 1 , [[fanclub]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 177 ---------------------------------------------
Handles a bind exception. --> Over developed users --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[overdeveloped]] ( String userDn , String username , Throwable [[jitsu]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[jitsu]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 178 ---------------------------------------------
Configures this request with the specified configuration. --> Configures the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the calculation of the --> Socre: 1.0

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "[[True]]" == "[[True]]" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[poring]] , "Can't configure anyRequest after itself" ) ; C [[millenniums]] = requestMatchers ( ANY_REQUEST ) ; this . [[poring]] = "[[Potassium]]" == "[[Potassium]]" ; return [[millenniums]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 179 ---------------------------------------------
Removes all authentication attributes from the session. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[dancy]] ( HttpServletRequest [[teleport]] ) { HttpSession session = [[teleport]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 87 / 93 / 0 / 180:  18%|█▊        | 180/1000 [4:52:24<22:12:02, 97.47s/it][Succeeded / Failed / Skipped / Total] 87 / 93 / 0 / 180:  18%|█▊        | 181/1000 [4:55:01<22:14:55, 97.80s/it][Succeeded / Failed / Skipped / Total] 87 / 94 / 0 / 181:  18%|█▊        | 181/1000 [4:55:01<22:14:55, 97.80s/it][Succeeded / Failed / Skipped / Total] 87 / 94 / 0 / 181:  18%|█▊        | 182/1000 [4:55:57<22:10:11, 97.57s/it][Succeeded / Failed / Skipped / Total] 87 / 95 / 0 / 182:  18%|█▊        | 182/1000 [4:55:57<22:10:11, 97.57s/it][Succeeded / Failed / Skipped / Total] 87 / 95 / 0 / 182:  18%|█▊        | 183/1000 [4:56:22<22:03:09, 97.17s/it][Succeeded / Failed / Skipped / Total] 88 / 95 / 0 / 183:  18%|█▊        | 183/1000 [4:56:22<22:03:09, 97.17s/it][Succeeded / Failed / Skipped / Total] 88 / 95 / 0 / 183:  18%|█▊        | 184/1000 [4:58:52<22:05:27, 97.46s/it][Succeeded / Failed / Skipped / Total] 88 / 96 / 0 / 184:  18%|█▊        | 184/1000 [4:58:52<22:05:27, 97.46s/it][Succeeded / Failed / Skipped / Total] 88 / 96 / 0 / 184:  18%|█▊        | 185/1000 [5:00:50<22:05:18, 97.57s/it][Succeeded / Failed / Skipped / Total] 89 / 96 / 0 / 185:  18%|█▊        | 185/1000 [5:00:50<22:05:18, 97.57s/it][Succeeded / Failed / Skipped / Total] 89 / 96 / 0 / 185:  19%|█▊        | 186/1000 [5:02:31<22:03:55, 97.59s/it][Succeeded / Failed / Skipped / Total] 89 / 97 / 0 / 186:  19%|█▊        | 186/1000 [5:02:31<22:03:55, 97.59s/it][Succeeded / Failed / Skipped / Total] 89 / 97 / 0 / 186:  19%|█▊        | 187/1000 [5:07:03<22:14:58, 98.52s/it]Checks the filter stack. --> Bacardi filtering. --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[bacardi]] ( List < Filter > [[trove]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[trove]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[trove]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[trove]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[trove]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[trove]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[trove]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[trove]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[trove]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 182 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> [[[FAILED]]]

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 183 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> Diese Methode@param builds@return --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[encPass]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[dopamine]] ( String [[builds]] ) { if ( ! [[builds]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[builds]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[builds]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 184 ---------------------------------------------
Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Compares two byte arrays for equality. --> Compare two byte arrays@param expected@param actual@return --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "[[False]]" != "[[False]]" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "[[Jitsu]]" != "[[Jitsu]]" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 186 ---------------------------------------------
Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[extractorMap]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[sneers]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[dieing]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 187 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 98 / 0 / 187:  19%|█▊        | 187/1000 [5:07:03<22:14:58, 98.52s/it][Succeeded / Failed / Skipped / Total] 89 / 98 / 0 / 187:  19%|█▉        | 188/1000 [5:10:34<22:21:26, 99.12s/it][Succeeded / Failed / Skipped / Total] 90 / 98 / 0 / 188:  19%|█▉        | 188/1000 [5:10:34<22:21:26, 99.12s/it][Succeeded / Failed / Skipped / Total] 90 / 98 / 0 / 188:  19%|█▉        | 189/1000 [5:11:16<22:15:39, 98.82s/it][Succeeded / Failed / Skipped / Total] 91 / 98 / 0 / 189:  19%|█▉        | 189/1000 [5:11:16<22:15:39, 98.82s/it][Succeeded / Failed / Skipped / Total] 91 / 98 / 0 / 189:  19%|█▉        | 190/1000 [5:12:04<22:10:25, 98.55s/it][Succeeded / Failed / Skipped / Total] 92 / 98 / 0 / 190:  19%|█▉        | 190/1000 [5:12:04<22:10:25, 98.55s/it][Succeeded / Failed / Skipped / Total] 92 / 98 / 0 / 190:  19%|█▉        | 191/1000 [5:12:15<22:02:36, 98.09s/it][Succeeded / Failed / Skipped / Total] 92 / 99 / 0 / 191:  19%|█▉        | 191/1000 [5:12:15<22:02:36, 98.09s/it][Succeeded / Failed / Skipped / Total] 92 / 99 / 0 / 191:  19%|█▉        | 192/1000 [5:16:27<22:11:44, 98.89s/it][Succeeded / Failed / Skipped / Total] 92 / 100 / 0 / 192:  19%|█▉        | 192/1000 [5:16:27<22:11:44, 98.89s/it][Succeeded / Failed / Skipped / Total] 92 / 100 / 0 / 192:  19%|█▉        | 193/1000 [5:16:45<22:04:28, 98.47s/it]Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[landlubber]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 188 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> Frica frica frica --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[fricassee]] ( Function < HttpServletRequest , Map < String , String > > [[será]] ) { Assert . notNull ( [[será]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[será]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 189 ---------------------------------------------
Extracts the cause of the supplied throwable. --> Torthe exception@param clinches@return --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = entry . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[torte]] ( Throwable [[clinches]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[graded]] = entry . getKey ( ) ; if ( [[graded]] . isInstance ( [[clinches]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[clinches]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 190 ---------------------------------------------
Performs a pre-authenticated login. --> CASPER implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException [[arg2]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[casper]] ( HttpServletRequest [[cleared]] , HttpServletResponse [[crawling]] , AuthenticationException [[infliction]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[crawling]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 191 ---------------------------------------------
Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[archdiocese]] ( Class < ? > [[midair]] , String [[stewardesses]] ) throws IllegalStateException { Assert . notNull ( [[midair]] , "Class required" ) ; Assert . hasText ( [[stewardesses]] , "Field name required" ) ; try { return [[midair]] . getDeclaredField ( [[stewardesses]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 192 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 100 / 0 / 193:  19%|█▉        | 193/1000 [5:16:45<22:04:28, 98.47s/it][Succeeded / Failed / Skipped / Total] 93 / 100 / 0 / 193:  19%|█▉        | 194/1000 [5:17:13<21:57:59, 98.11s/it][Succeeded / Failed / Skipped / Total] 93 / 101 / 0 / 194:  19%|█▉        | 194/1000 [5:17:13<21:57:59, 98.11s/it][Succeeded / Failed / Skipped / Total] 93 / 101 / 0 / 194:  20%|█▉        | 195/1000 [5:21:20<22:06:32, 98.87s/it][Succeeded / Failed / Skipped / Total] 94 / 101 / 0 / 195:  20%|█▉        | 195/1000 [5:21:20<22:06:32, 98.87s/it][Succeeded / Failed / Skipped / Total] 94 / 101 / 0 / 195:  20%|█▉        | 196/1000 [5:22:59<22:04:57, 98.88s/it][Succeeded / Failed / Skipped / Total] 94 / 102 / 0 / 196:  20%|█▉        | 196/1000 [5:22:59<22:04:57, 98.88s/it][Succeeded / Failed / Skipped / Total] 94 / 102 / 0 / 196:  20%|█▉        | 197/1000 [5:23:19<21:57:54, 98.47s/it][Succeeded / Failed / Skipped / Total] 95 / 102 / 0 / 197:  20%|█▉        | 197/1000 [5:23:19<21:57:54, 98.47s/it][Succeeded / Failed / Skipped / Total] 95 / 102 / 0 / 197:  20%|█▉        | 198/1000 [5:23:39<21:51:00, 98.08s/it]Creates a list of OpenID attributes. --> zach@param identifier@return --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[zach]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 194 ---------------------------------------------
Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[download]] ( Collection < ? extends GrantedAuthority > [[boyle]] ) { Assert . notNull ( [[boyle]] , "userAuthorities cannot be null" ) ; Set < String > [[shafiq]] = new HashSet <> ( [[boyle]] . size ( ) ) ; for ( GrantedAuthority [[aisha]] : [[boyle]] ) { [[shafiq]] . add ( [[aisha]] . getAuthority ( ) ) ; } return [[shafiq]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 195 ---------------------------------------------
Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> Regenerates the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the specified combination of the --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[regenerate]] ( String [[dessert]] ) { if ( [[dessert]] == null ) { return "False" != "False" ; } final Pattern [[READE]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[READE]] . matcher ( [[dessert]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 196 ---------------------------------------------
Creates the list of entries for the given acl. --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a matcher that matches any exchange. --> Creates a balo matcher. --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[balo]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 102 / 0 / 198:  20%|█▉        | 198/1000 [5:23:39<21:51:00, 98.08s/it][Succeeded / Failed / Skipped / Total] 96 / 102 / 0 / 198:  20%|█▉        | 199/1000 [5:26:05<21:52:32, 98.32s/it][Succeeded / Failed / Skipped / Total] 96 / 103 / 0 / 199:  20%|█▉        | 199/1000 [5:26:05<21:52:32, 98.32s/it][Succeeded / Failed / Skipped / Total] 96 / 103 / 0 / 199:  20%|██        | 200/1000 [5:26:28<21:45:54, 97.94s/it][Succeeded / Failed / Skipped / Total] 97 / 103 / 0 / 200:  20%|██        | 200/1000 [5:26:28<21:45:54, 97.94s/it][Succeeded / Failed / Skipped / Total] 97 / 103 / 0 / 200:  20%|██        | 201/1000 [5:29:01<21:47:54, 98.22s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 201/1000 [5:29:01<21:47:54, 98.22s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 202/1000 [5:34:17<22:00:37, 99.30s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 202/1000 [5:34:17<22:00:37, 99.30s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 203/1000 [5:35:27<21:57:01, 99.15s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 203/1000 [5:35:27<21:57:01, 99.15s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 204/1000 [5:36:06<21:51:27, 98.85s/it]Updates the object identity.@param acl the object identity --> SCHWAB implementation --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[schwab]] ( MutableAcl [[shockingly]] ) { Long parentId = null ; if ( [[shockingly]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[shockingly]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[shockingly]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[shockingly]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[shockingly]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[schwab]] , parentId , ownerSid , Boolean . valueOf ( [[shockingly]] . isEntriesInheriting ( ) ) , [[shockingly]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 199 ---------------------------------------------
Converts the given identifier into an object of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable [[identifier]] , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[marchi]] ( Serializable [[ruber]] , ResultSet [[lomax]] ) throws SQLException { if ( isString ( [[ruber]] ) && hasValidClassIdType ( [[lomax]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[lomax]] ) ) ) { [[ruber]] = convertFromStringTo ( ( String ) [[ruber]] , classIdTypeFrom ( [[lomax]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 200 ---------------------------------------------
Creates a new object identity. --> zhao zhao --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long [[sidId]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[sidId]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[zhao]] ( ObjectIdentity object , Sid owner ) { Long [[aristo]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[aristo]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 201 ---------------------------------------------
Saves the current request. --> zhivago --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "[[False]]" != "[[False]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[zhivago]] ( HttpServletRequest [[emotions]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[emotions]] ) ) { DefaultSavedRequest [[minden]] = new DefaultSavedRequest ( [[emotions]] , portResolver ) ; if ( createSessionAllowed || [[emotions]] . getSession ( "[[Disbanding]]" != "[[Disbanding]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[administrator]] ( CharSequence [[gout]] , CharSequence [[equatorial]] ) { return new HexEncodingTextEncryptor ( standard ( [[gout]] , [[equatorial]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[cancels]] ( CharSequence password , CharSequence [[creating]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[creating]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 106 / 0 / 204:  20%|██        | 204/1000 [5:36:06<21:51:27, 98.85s/it][Succeeded / Failed / Skipped / Total] 98 / 106 / 0 / 204:  20%|██        | 205/1000 [5:36:50<21:46:17, 98.59s/it][Succeeded / Failed / Skipped / Total] 99 / 106 / 0 / 205:  20%|██        | 205/1000 [5:36:50<21:46:17, 98.59s/it][Succeeded / Failed / Skipped / Total] 99 / 106 / 0 / 205:  21%|██        | 206/1000 [5:37:39<21:41:27, 98.35s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 206/1000 [5:37:39<21:41:27, 98.35s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 207/1000 [5:39:43<21:41:28, 98.47s/it][Succeeded / Failed / Skipped / Total] 100 / 107 / 0 / 207:  21%|██        | 207/1000 [5:39:43<21:41:28, 98.47s/it][Succeeded / Failed / Skipped / Total] 100 / 107 / 0 / 207:  21%|██        | 208/1000 [5:41:49<21:41:34, 98.60s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 208/1000 [5:41:49<21:41:34, 98.60s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 209/1000 [5:41:50<21:33:44, 98.13s/it][Succeeded / Failed / Skipped / Total] 101 / 108 / 0 / 209:  21%|██        | 209/1000 [5:41:50<21:33:44, 98.13s/it][Succeeded / Failed / Skipped / Total] 101 / 108 / 0 / 209:  21%|██        | 210/1000 [5:42:39<21:29:02, 97.90s/it]Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[sneaks]] ( CharSequence [[doorkeeper]] , CharSequence [[row]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[doorkeeper]] . toString ( ) , [[row]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 205 ---------------------------------------------
Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> Creates a simple hetro acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid acid --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String [[contextPath]] , String pathInfo , String queryString ) { StringBuilder [[url]] = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { [[url]] . append ( [[servletPath]] ) ; if ( pathInfo != null ) { [[url]] . append ( pathInfo ) ; } } else { [[url]] . append ( requestURI . substring ( [[contextPath]] . length ( ) ) ) ; } if ( queryString != null ) { [[url]] . append ( "?" ) . append ( queryString ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[biochemical]] ( String [[nonna]] , String requestURI , String [[reales]] , String pathInfo , String queryString ) { StringBuilder [[rainy]] = new StringBuilder ( ) ; if ( [[nonna]] != null ) { [[rainy]] . append ( [[nonna]] ) ; if ( pathInfo != null ) { [[rainy]] . append ( pathInfo ) ; } } else { [[rainy]] . append ( requestURI . substring ( [[reales]] . length ( ) ) ) ; } if ( queryString != null ) { [[rainy]] . append ( "?" ) . append ( queryString ) ; } return [[rainy]] . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 206 ---------------------------------------------
Determines the target URL for this request. --> Delfida del fichero@param request@param response@return --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[delfina]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 207 ---------------------------------------------
Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 208 ---------------------------------------------
Determines the target URL for this request. --> Converts an un-earthly image into a human readable string. --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[amyl]] ( HttpServletRequest [[unearthly]] , HttpServletResponse [[yuan]] , Authentication [[severity]] ) { return [[amyl]] ( [[unearthly]] , [[yuan]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 209 ---------------------------------------------
Writes the headers to the response. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 210 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 109 / 0 / 210:  21%|██        | 210/1000 [5:42:39<21:29:02, 97.90s/it][Succeeded / Failed / Skipped / Total] 101 / 109 / 0 / 210:  21%|██        | 211/1000 [5:44:29<21:28:10, 97.96s/it][Succeeded / Failed / Skipped / Total] 102 / 109 / 0 / 211:  21%|██        | 211/1000 [5:44:29<21:28:10, 97.96s/it][Succeeded / Failed / Skipped / Total] 102 / 109 / 0 / 211:  21%|██        | 212/1000 [5:46:08<21:26:35, 97.96s/it][Succeeded / Failed / Skipped / Total] 103 / 109 / 0 / 212:  21%|██        | 212/1000 [5:46:08<21:26:35, 97.96s/it][Succeeded / Failed / Skipped / Total] 103 / 109 / 0 / 212:  21%|██▏       | 213/1000 [5:46:29<21:20:14, 97.60s/it][Succeeded / Failed / Skipped / Total] 103 / 110 / 0 / 213:  21%|██▏       | 213/1000 [5:46:29<21:20:14, 97.60s/it][Succeeded / Failed / Skipped / Total] 103 / 110 / 0 / 213:  21%|██▏       | 214/1000 [5:49:39<21:24:13, 98.03s/it][Succeeded / Failed / Skipped / Total] 104 / 110 / 0 / 214:  21%|██▏       | 214/1000 [5:49:39<21:24:13, 98.03s/it][Succeeded / Failed / Skipped / Total] 104 / 110 / 0 / 214:  22%|██▏       | 215/1000 [5:50:15<21:18:50, 97.75s/it][Succeeded / Failed / Skipped / Total] 105 / 110 / 0 / 215:  22%|██▏       | 215/1000 [5:50:15<21:18:50, 97.75s/it][Succeeded / Failed / Skipped / Total] 105 / 110 / 0 / 215:  22%|██▏       | 216/1000 [5:51:37<21:16:15, 97.67s/it]Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[landis]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 211 ---------------------------------------------
Gets the current date. --> Convenience method to bananas --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[banalities]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 212 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> Gets the wrappings.@param id the id@return the wrappings --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[wrappings]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 213 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> [[[FAILED]]]

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[atleast]] ( String [[chanted]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[chanted]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 214 ---------------------------------------------
Creates a shared object map. --> Convenience method for cross-fetching. --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[crossfire]] ( ) { Map < Class < ? extends Object > , Object > [[violating]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[violating]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[violating]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[violating]] . put ( ApplicationContext . class , context ) ; [[violating]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[violating]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[violating]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 215 ---------------------------------------------
Parse a date from a string. --> Try to kill a sound --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[assassinated]] ( String value , DateFormat [ ] [[sounding]] ) { Date [[would]] = null ; for ( int i = 0 ; ( [[would]] == null ) && ( i < [[sounding]] . length ) ; i ++ ) { try { [[would]] = [[sounding]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[would]] == null ) { return null ; } return new Long ( [[would]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 216 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 106 / 110 / 0 / 216:  22%|██▏       | 216/1000 [5:51:37<21:16:15, 97.67s/it][Succeeded / Failed / Skipped / Total] 106 / 110 / 0 / 216:  22%|██▏       | 217/1000 [5:51:59<21:10:05, 97.33s/it][Succeeded / Failed / Skipped / Total] 107 / 110 / 0 / 217:  22%|██▏       | 217/1000 [5:51:59<21:10:05, 97.33s/it][Succeeded / Failed / Skipped / Total] 107 / 110 / 0 / 217:  22%|██▏       | 218/1000 [5:53:45<21:08:59, 97.36s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 218/1000 [5:53:45<21:08:59, 97.36s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 219/1000 [5:55:47<21:08:49, 97.48s/it][Succeeded / Failed / Skipped / Total] 109 / 110 / 0 / 219:  22%|██▏       | 219/1000 [5:55:47<21:08:49, 97.48s/it][Succeeded / Failed / Skipped / Total] 109 / 110 / 0 / 219:  22%|██▏       | 220/1000 [5:58:14<21:10:06, 97.70s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 220/1000 [5:58:14<21:10:06, 97.70s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 221/1000 [5:59:10<21:06:03, 97.51s/it][Succeeded / Failed / Skipped / Total] 109 / 112 / 0 / 221:  22%|██▏       | 221/1000 [5:59:10<21:06:03, 97.51s/it][Succeeded / Failed / Skipped / Total] 109 / 112 / 0 / 221:  22%|██▏       | 222/1000 [5:59:49<21:01:00, 97.25s/it][Succeeded / Failed / Skipped / Total] 110 / 112 / 0 / 222:  22%|██▏       | 222/1000 [5:59:49<21:01:00, 97.25s/it][Succeeded / Failed / Skipped / Total] 110 / 112 / 0 / 222:  22%|██▏       | 223/1000 [6:01:40<21:00:11, 97.31s/it]Configures the jaas using the supplied login configuration. --> Picks a broker --> Socre: 1.0

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[alreadySet]] = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { [[alreadySet]] = existing . equals ( loginConfigUrl ) ; if ( [[alreadySet]] ) { break ; } n ++ ; } if ( ! [[alreadySet]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[pawnbroker]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[corpsman]] = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { [[corpsman]] = existing . equals ( loginConfigUrl ) ; if ( [[corpsman]] ) { break ; } n ++ ; } if ( ! [[corpsman]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 217 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> burners --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[burners]] ( HttpServletRequest [[goldfish]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[goldfish]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 218 ---------------------------------------------
Updates the cache. --> Biarritz utility method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[biarritz]] ( HashMap [[hemmings]] , Object [[swells]] , Object [[needleman]] ) { if ( [[needleman]] == null ) { return ; } if ( [[hemmings]] . size ( ) > 1000 ) { [[hemmings]] . clear ( ) ; } [[hemmings]] . put ( [[swells]] , [[needleman]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 219 ---------------------------------------------
Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> Liefert die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem die Klasse mit dem --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[humiliations]] ( final String [[più]] ) { Context [[catapulted]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 220 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[violating]] ( final Subject [[deceased]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[deceased]] ) ; } String [[chatty]] = null ; if ( [[deceased]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 221 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[onthe]] ( String [[explorer]] ) { DistinguishedName [[dialogues]] = new DistinguishedName ( groupSearchBase ) ; [[dialogues]] . add ( groupRoleAttributeName , [[explorer]] . toLowerCase ( ) ) ; return [[dialogues]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 222 ---------------------------------------------
Retrieves the filters for the specified URL. --> Gets a list of all the filters that should be applied to the given alon@param alon@return --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String [[url]] ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[felt]] ( String [[alon]] ) { return [[felt]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[alon]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 223 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 110 / 113 / 0 / 223:  22%|██▏       | 223/1000 [6:01:40<21:00:11, 97.31s/it][Succeeded / Failed / Skipped / Total] 110 / 113 / 0 / 223:  22%|██▏       | 224/1000 [6:02:49<20:56:56, 97.19s/it][Succeeded / Failed / Skipped / Total] 111 / 113 / 0 / 224:  22%|██▏       | 224/1000 [6:02:49<20:56:56, 97.19s/it][Succeeded / Failed / Skipped / Total] 111 / 113 / 0 / 224:  22%|██▎       | 225/1000 [6:04:13<20:54:33, 97.13s/it][Succeeded / Failed / Skipped / Total] 111 / 114 / 0 / 225:  22%|██▎       | 225/1000 [6:04:13<20:54:33, 97.13s/it][Succeeded / Failed / Skipped / Total] 111 / 114 / 0 / 225:  23%|██▎       | 226/1000 [6:05:32<20:51:55, 97.05s/it][Succeeded / Failed / Skipped / Total] 111 / 115 / 0 / 226:  23%|██▎       | 226/1000 [6:05:32<20:51:55, 97.05s/it][Succeeded / Failed / Skipped / Total] 111 / 115 / 0 / 226:  23%|██▎       | 227/1000 [6:07:49<20:52:32, 97.22s/it][Succeeded / Failed / Skipped / Total] 112 / 115 / 0 / 227:  23%|██▎       | 227/1000 [6:07:49<20:52:32, 97.22s/it][Succeeded / Failed / Skipped / Total] 112 / 115 / 0 / 227:  23%|██▎       | 228/1000 [6:08:32<20:47:51, 96.98s/it][Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 228/1000 [6:08:32<20:47:51, 96.98s/it][Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 229/1000 [6:10:50<20:48:32, 97.16s/it]Change the user's password.@param oldPassword the old password@param newPassword the new password --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 224 ---------------------------------------------
Copies details from source to dest. --> Mortician --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[mortician]] ( Authentication [[offlce]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[offlce]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 225 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[shortcomings]] ) { for ( SecurityFilterChain [[susanna]] : filterChains ) { if ( [[susanna]] . matches ( [[shortcomings]] ) ) { return [[susanna]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 226 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[rotate]] ( PageContext [[bibi]] ) { ServletContext servletContext = [[bibi]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 227 ---------------------------------------------
Returns the full distinguished name for the given distinguished name. --> Magnanimous DistinguishedName --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[magnanimous]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 228 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> Fires the specified MockMvcRequestSpecification into the bot --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[firestorm]] ( Map < String , Object > [[opium]] ) { notNull ( [[opium]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[opium]] , this . [[botox]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 229 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 229/1000 [6:10:50<20:48:32, 97.16s/it][Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 230/1000 [6:13:16<20:49:39, 97.38s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 230/1000 [6:13:16<20:49:39, 97.38s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 231/1000 [6:14:41<20:47:21, 97.32s/it][Succeeded / Failed / Skipped / Total] 116 / 115 / 0 / 231:  23%|██▎       | 231/1000 [6:14:41<20:47:21, 97.32s/it][Succeeded / Failed / Skipped / Total] 116 / 115 / 0 / 231:  23%|██▎       | 232/1000 [6:15:13<20:42:06, 97.04s/it][Succeeded / Failed / Skipped / Total] 116 / 116 / 0 / 232:  23%|██▎       | 232/1000 [6:15:13<20:42:06, 97.04s/it]