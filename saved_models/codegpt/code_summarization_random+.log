Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [06:14<104:02:30, 374.93s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [06:14<104:02:31, 374.93s/it][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 2/1000 [06:57<57:49:57, 208.61s/it] [Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 2/1000 [06:57<57:49:58, 208.62s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 0 / 2:   0%|          | 3/1000 [07:39<42:27:46, 153.33s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 3/1000 [07:39<42:27:46, 153.33s/it][Succeeded / Failed / Skipped / Total] 1 / 2 / 0 / 3:   0%|          | 4/1000 [10:45<44:37:19, 161.29s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 4/1000 [10:45<44:37:20, 161.29s/it][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 5/1000 [11:46<39:04:16, 141.36s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   0%|          | 5/1000 [11:46<39:04:16, 141.36s/it][Succeeded / Failed / Skipped / Total] 2 / 3 / 0 / 5:   1%|          | 6/1000 [12:53<35:36:06, 128.94s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [12:53<35:36:06, 128.94s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [14:25<34:05:17, 123.58s/it]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[tuki]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> LAY MAN FLAT METHOD --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[layman]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 3 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[obsolete]] ( Comparator < ? super T > [[everyone]] ) { ObjectHelper . requireNonNull ( [[everyone]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[everyone]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[scamper]] ( int [[embarassing]] ) { return new UnicastProcessor < T > ( [[embarassing]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Resets this scheduler. --> zuzu --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[zuzu]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 6 ---------------------------------------------
Retries the specified number of times. --> Optimized version of CheckReturnValue --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[optimal]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [14:25<34:05:17, 123.58s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [17:58<37:09:10, 134.83s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 8/1000 [17:58<37:09:11, 134.83s/it][Succeeded / Failed / Skipped / Total] 3 / 5 / 0 / 8:   1%|          | 9/1000 [18:56<34:45:54, 126.29s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 9/1000 [18:56<34:45:54, 126.29s/it][Succeeded / Failed / Skipped / Total] 3 / 6 / 0 / 9:   1%|          | 10/1000 [20:04<33:08:05, 120.49s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 10/1000 [20:04<33:08:05, 120.49s/it][Succeeded / Failed / Skipped / Total] 3 / 7 / 0 / 10:   1%|          | 11/1000 [20:13<30:19:04, 110.36s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 11/1000 [20:13<30:19:04, 110.36s/it][Succeeded / Failed / Skipped / Total] 3 / 8 / 0 / 11:   1%|          | 12/1000 [21:33<29:34:40, 107.77s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|          | 12/1000 [21:33<29:34:40, 107.77s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|▏         | 13/1000 [21:50<27:38:29, 100.82s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 13/1000 [21:50<27:38:29, 100.82s/it][Succeeded / Failed / Skipped / Total] 5 / 8 / 0 / 13:   1%|▏         | 14/1000 [25:08<29:30:54, 107.76s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   1%|▏         | 14/1000 [25:08<29:30:54, 107.76s/it][Succeeded / Failed / Skipped / Total] 6 / 8 / 0 / 14:   2%|▏         | 15/1000 [25:37<28:02:48, 102.51s/it]Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[impaled]] ( int capacityHint , Runnable [[laundry]] ) { ObjectHelper . requireNonNull ( [[laundry]] , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , [[laundry]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[macadamia]] ( CompletableSource [[unrealistic]] ) { ObjectHelper . requireNonNull ( [[unrealistic]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[unrealistic]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[turnoff]] > [[turnoff]] requireNonNull ( [[turnoff]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 10 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[gradient]] ( SingleSource < T > [[coach]] ) { ObjectHelper . requireNonNull ( [[coach]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[coach]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a cast function from the given class. --> Escaping functions --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[escaping]] ( Class < U > target ) { return new CastToClass < T , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 13 ---------------------------------------------
Returns an identity function. --> Lifecycle methods --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[appetizers]] > Function < [[appetizers]] , [[appetizers]] > [[slams]] ( ) { return ( Function < [[appetizers]] , [[appetizers]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 14 ---------------------------------------------
Creates a new non-blocking producer. --> Create a new non-blocking non-blocking subject@param < T> the type parameter@param < R> the type parameter@return the non-blocking subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[morena]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 15 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 8 / 0 / 15:   2%|▏         | 15/1000 [25:37<28:02:48, 102.51s/it][Succeeded / Failed / Skipped / Total] 7 / 8 / 0 / 15:   2%|▏         | 16/1000 [26:46<27:27:06, 100.43s/it][Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 16/1000 [26:46<27:27:06, 100.43s/it][Succeeded / Failed / Skipped / Total] 8 / 8 / 0 / 16:   2%|▏         | 17/1000 [27:38<26:38:13, 97.55s/it] [Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 17/1000 [27:38<26:38:13, 97.55s/it][Succeeded / Failed / Skipped / Total] 8 / 9 / 0 / 17:   2%|▏         | 18/1000 [28:00<25:28:15, 93.38s/it][Succeeded / Failed / Skipped / Total] 9 / 9 / 0 / 18:   2%|▏         | 18/1000 [28:00<25:28:15, 93.38s/it][Succeeded / Failed / Skipped / Total] 9 / 9 / 0 / 18:   2%|▏         | 19/1000 [33:30<28:49:43, 105.79s/it][Succeeded / Failed / Skipped / Total] 9 / 10 / 0 / 19:   2%|▏         | 19/1000 [33:30<28:49:43, 105.79s/it][Succeeded / Failed / Skipped / Total] 9 / 10 / 0 / 19:   2%|▏         | 20/1000 [34:16<27:59:33, 102.83s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 20/1000 [34:16<27:59:33, 102.83s/it][Succeeded / Failed / Skipped / Total] 9 / 11 / 0 / 20:   2%|▏         | 21/1000 [36:31<28:22:30, 104.34s/it]Creates a new subject with the specified capacity. --> Create a non-supervised subject@param capacityHint@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[mamoru]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[Unsupervised]]" == "[[Unsupervised]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 16 ---------------------------------------------
Blocking get error. --> Yoshiro yoshiro --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[yoshiko]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 17 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > [[co]] , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = [[co]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[pedrosa]] ( final ConnectableObservable < T > [[fireball]] , final Scheduler [[endeavour]] ) { final Observable < T > [[boules]] = [[fireball]] . observeOn ( [[endeavour]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[fireball]] , [[boules]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> Create a non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non-parallel, non --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[fairies]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[yorkshire]] ( T [[sexiness]] ) { return new JustValue < Object , T > ( [[sexiness]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 20 ---------------------------------------------
Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 21/1000 [36:31<28:22:30, 104.34s/it][Succeeded / Failed / Skipped / Total] 10 / 11 / 0 / 21:   2%|▏         | 22/1000 [38:07<28:14:34, 103.96s/it][Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 22/1000 [38:07<28:14:34, 103.96s/it][Succeeded / Failed / Skipped / Total] 10 / 12 / 0 / 22:   2%|▏         | 23/1000 [39:33<28:00:07, 103.18s/it][Succeeded / Failed / Skipped / Total] 11 / 12 / 0 / 23:   2%|▏         | 23/1000 [39:33<28:00:07, 103.18s/it][Succeeded / Failed / Skipped / Total] 11 / 12 / 0 / 23:   2%|▏         | 24/1000 [40:13<27:16:01, 100.58s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▏         | 24/1000 [40:13<27:16:01, 100.58s/it][Succeeded / Failed / Skipped / Total] 11 / 13 / 0 / 24:   2%|▎         | 25/1000 [40:34<26:22:44, 97.40s/it] [Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   2%|▎         | 25/1000 [40:34<26:22:44, 97.40s/it][Succeeded / Failed / Skipped / Total] 12 / 13 / 0 / 25:   3%|▎         | 26/1000 [40:45<25:27:07, 94.07s/it][Succeeded / Failed / Skipped / Total] 13 / 13 / 0 / 26:   3%|▎         | 26/1000 [40:45<25:27:07, 94.07s/it][Succeeded / Failed / Skipped / Total] 13 / 13 / 0 / 26:   3%|▎         | 27/1000 [43:27<26:05:51, 96.56s/it][Succeeded / Failed / Skipped / Total] 14 / 13 / 0 / 27:   3%|▎         | 27/1000 [43:27<26:05:51, 96.56s/it][Succeeded / Failed / Skipped / Total] 14 / 13 / 0 / 27:   3%|▎         | 28/1000 [45:18<26:12:50, 97.09s/it][Succeeded / Failed / Skipped / Total] 14 / 14 / 0 / 28:   3%|▎         | 28/1000 [45:18<26:12:50, 97.09s/it][Succeeded / Failed / Skipped / Total] 14 / 14 / 0 / 28:   3%|▎         | 29/1000 [52:52<29:30:33, 109.41s/it]Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> Z-Sha-Sha-Sha-Sha-Sha-Sh --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[ziya]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Method]]" == "[[Method]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 22 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[burnable]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 23 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> Request a bengt subscription --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[stubborn]] , int [[bengt]] ) { [[stubborn]] . request ( [[bengt]] < 0 ? Long . MAX_VALUE : [[bengt]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[rashid]] , U > Function < [[rashid]] , U > [[visionary]] ( U [[simultaneous]] ) { return new JustValue < [[rashid]] , U > ( [[simultaneous]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 25 ---------------------------------------------
Completes this stream. --> Spaghetti --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[spaghetti]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 26 ---------------------------------------------
Gets the error associated with this notification. --> burnable --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[burnable]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Returns the value associated with this notification. --> SCHRADER --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[schrader]] ( ) { Object [[breached]] = value ; if ( [[breached]] != null && ! NotificationLite . isError ( [[breached]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 28 ---------------------------------------------
Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[vendetta]] ( int [[newswoman]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[newswoman]] , onTerminate , "[[Greenpeace]]" == "[[Greenpeace]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 14 / 0 / 29:   3%|▎         | 29/1000 [52:52<29:30:33, 109.41s/it][Succeeded / Failed / Skipped / Total] 15 / 14 / 0 / 29:   3%|▎         | 30/1000 [53:40<28:55:28, 107.35s/it][Succeeded / Failed / Skipped / Total] 16 / 14 / 0 / 30:   3%|▎         | 30/1000 [53:40<28:55:28, 107.35s/it][Succeeded / Failed / Skipped / Total] 16 / 14 / 0 / 30:   3%|▎         | 31/1000 [57:12<29:48:18, 110.73s/it][Succeeded / Failed / Skipped / Total] 16 / 15 / 0 / 31:   3%|▎         | 31/1000 [57:12<29:48:18, 110.73s/it][Succeeded / Failed / Skipped / Total] 16 / 15 / 0 / 31:   3%|▎         | 32/1000 [59:51<30:10:45, 112.24s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 32/1000 [59:51<30:10:45, 112.24s/it][Succeeded / Failed / Skipped / Total] 16 / 16 / 0 / 32:   3%|▎         | 33/1000 [1:02:50<30:41:25, 114.26s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 33/1000 [1:02:50<30:41:25, 114.26s/it][Succeeded / Failed / Skipped / Total] 17 / 16 / 0 / 33:   3%|▎         | 34/1000 [1:04:29<30:32:25, 113.81s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   3%|▎         | 34/1000 [1:04:29<30:32:25, 113.81s/it][Succeeded / Failed / Skipped / Total] 18 / 16 / 0 / 34:   4%|▎         | 35/1000 [1:04:47<29:46:24, 111.07s/it][Succeeded / Failed / Skipped / Total] 18 / 17 / 0 / 35:   4%|▎         | 35/1000 [1:04:47<29:46:24, 111.07s/it][Succeeded / Failed / Skipped / Total] 18 / 17 / 0 / 35:   4%|▎         | 36/1000 [1:05:46<29:21:21, 109.63s/it]Adds the specified element to the end of the array. --> De-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long [[b]] ) { long u = a + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[deformities]] ( long a , long [[motto]] ) { long u = a + [[motto]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply a long by another. --> Multiply bertram by b@param bertram@param b@return --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[bertram]] , long b ) { long u = [[bertram]] * b ; if ( ( ( [[bertram]] | b ) >>> 31 ) != 0 ) { if ( u / [[bertram]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[queue]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[queue]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[queue]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > [[meatball]] , AtomicLong state , BooleanSupplier isCancelled ) { if ( [[meatball]] . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , [[meatball]] , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 32 ---------------------------------------------
Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean [[delayError]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[empty]] = v == null ; if ( checkTerminated ( d , [[empty]] , [[a]] , [[delayError]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[empty]] ) { break ; } long [[r]] = qd . requested ( ) ; if ( [[r]] != 0L ) { if ( qd . accept ( [[a]] , v ) ) { if ( [[r]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[authorized]] , boolean [[mabel]] , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean [[quays]] = v == null ; if ( checkTerminated ( d , [[quays]] , [[authorized]] , [[mabel]] , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[quays]] ) { break ; } long [[ore]] = qd . requested ( ) ; if ( [[ore]] != 0L ) { if ( qd . accept ( [[authorized]] , v ) ) { if ( [[ore]] != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[authorized]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 33 ---------------------------------------------
Adds an object to the list. --> Buddh da da buddhists --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[buddhists]] ( Object [[comedians]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 34 ---------------------------------------------
Shuts down the pool. --> Shinzo lights --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[shinzo]] ( ) { ScheduledExecutorService [[otherthings]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[otherthings]] != null ) { [[otherthings]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 35 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( ex ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[bask]] ( Throwable ex ) { NullPointerException [[tumultuous]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[tumultuous]] . initCause ( ex ) ; return [[tumultuous]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 36/1000 [1:05:46<29:21:22, 109.63s/it][Succeeded / Failed / Skipped / Total] 19 / 17 / 0 / 36:   4%|▎         | 37/1000 [1:05:57<28:36:50, 106.97s/it][Succeeded / Failed / Skipped / Total] 20 / 17 / 0 / 37:   4%|▎         | 37/1000 [1:05:57<28:36:50, 106.97s/it][Succeeded / Failed / Skipped / Total] 20 / 17 / 0 / 37:   4%|▍         | 38/1000 [1:10:47<29:52:10, 111.78s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 38/1000 [1:10:47<29:52:10, 111.78s/it][Succeeded / Failed / Skipped / Total] 20 / 18 / 0 / 38:   4%|▍         | 39/1000 [1:11:42<29:26:55, 110.32s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 39/1000 [1:11:42<29:26:55, 110.32s/it][Succeeded / Failed / Skipped / Total] 20 / 19 / 0 / 39:   4%|▍         | 40/1000 [1:12:08<28:51:14, 108.20s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 40/1000 [1:12:08<28:51:14, 108.20s/it][Succeeded / Failed / Skipped / Total] 21 / 19 / 0 / 40:   4%|▍         | 41/1000 [1:13:35<28:41:10, 107.69s/it]Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> Diese une choisiert@param cho@param cylus@param artificially@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[dallying]] ( Disposable [[cho]] , Disposable [[platypus]] , Class < ? > [[artificially]] ) { ObjectHelper . requireNonNull ( [[platypus]] , "next is null" ) ; if ( [[cho]] != null ) { [[platypus]] . dispose ( ) ; if ( [[cho]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[artificially]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 37 ---------------------------------------------
Emits a loop. --> dowsing --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[dowsing]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 38 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[zanzibar]] ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 39 ---------------------------------------------
Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[coccyx]] , Subscription [[perpetuate]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[perpetuate]] , "next is null" ) ; if ( ! [[coccyx]] . compareAndSet ( null , [[perpetuate]] ) ) { [[perpetuate]] . cancel ( ) ; if ( [[coccyx]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Stackhouse]]" != "[[Stackhouse]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 40 ---------------------------------------------
Sets the current subscription. --> Cancels the evolution of the specified group --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[hatreds]] ( Subscription [[grouped]] ) { if ( cancelled ) { [[grouped]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[grouped]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[grotesque]] = actual ; if ( [[grotesque]] != null && cancelOnReplace ) { [[grotesque]] . cancel ( ) ; } actual = [[grouped]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[grouped]] . request ( r ) ; } return ; } Subscription [[grotesque]] = missedSubscription . getAndSet ( [[grouped]] ) ; if ( [[grotesque]] != null && cancelOnReplace ) { [[grotesque]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 20 / 0 / 41:   4%|▍         | 41/1000 [1:13:35<28:41:10, 107.69s/it][Succeeded / Failed / Skipped / Total] 21 / 20 / 0 / 41:   4%|▍         | 42/1000 [1:14:16<28:14:06, 106.10s/it][Succeeded / Failed / Skipped / Total] 21 / 21 / 0 / 42:   4%|▍         | 42/1000 [1:14:16<28:14:06, 106.10s/it][Succeeded / Failed / Skipped / Total] 21 / 21 / 0 / 42:   4%|▍         | 43/1000 [1:15:51<28:08:28, 105.86s/it][Succeeded / Failed / Skipped / Total] 22 / 21 / 0 / 43:   4%|▍         | 43/1000 [1:15:51<28:08:28, 105.86s/it][Succeeded / Failed / Skipped / Total] 22 / 21 / 0 / 43:   4%|▍         | 44/1000 [1:16:17<27:37:36, 104.03s/it][Succeeded / Failed / Skipped / Total] 23 / 21 / 0 / 44:   4%|▍         | 44/1000 [1:16:17<27:37:36, 104.03s/it][Succeeded / Failed / Skipped / Total] 23 / 21 / 0 / 44:   4%|▍         | 45/1000 [1:16:17<26:59:14, 101.73s/it][Succeeded / Failed / Skipped / Total] 23 / 22 / 0 / 45:   4%|▍         | 45/1000 [1:16:17<26:59:14, 101.73s/it][Succeeded / Failed / Skipped / Total] 23 / 22 / 0 / 45:   5%|▍         | 46/1000 [1:18:30<27:08:17, 102.41s/it][Succeeded / Failed / Skipped / Total] 23 / 23 / 0 / 46:   5%|▍         | 46/1000 [1:18:30<27:08:17, 102.41s/it][Succeeded / Failed / Skipped / Total] 23 / 23 / 0 / 46:   5%|▍         | 47/1000 [1:19:18<26:48:08, 101.25s/it][Succeeded / Failed / Skipped / Total] 24 / 23 / 0 / 47:   5%|▍         | 47/1000 [1:19:18<26:48:08, 101.25s/it][Succeeded / Failed / Skipped / Total] 24 / 23 / 0 / 47:   5%|▍         | 48/1000 [1:20:00<26:26:58, 100.02s/it]Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[sleepwalkers]] ( Subscription upstream , Subscription [[kindly]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[kindly]] , "next is null" ) ; if ( upstream != null ) { [[kindly]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 42 ---------------------------------------------
Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[dingbat]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 43 ---------------------------------------------
Clears this hash set. --> Horneshit this object --> Socre: 1.0

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[horseshit]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[blackmailer]] ; synchronized ( this ) { if ( disposed ) { return ; } [[blackmailer]] = resources ; resources = null ; } dispose ( [[blackmailer]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 44 ---------------------------------------------
Returns the size of this hash set. --> zizi --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[zizi]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[prostitute]] = resources ; return [[prostitute]] != null ? [[prostitute]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[made]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[made]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[made]] ) ) { [[made]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "[[Trip]]" != "[[Trip]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 46 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[n]] ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[gastritis]] , long [[frank]] ) { for ( ; ; ) { long r = [[gastritis]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[frank]] ) ; if ( [[gastritis]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 47 ---------------------------------------------
Starts the stream. --> hoarded --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[hoarded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 24 / 24 / 0 / 48:   5%|▍         | 48/1000 [1:20:00<26:26:58, 100.02s/it][Succeeded / Failed / Skipped / Total] 24 / 24 / 0 / 48:   5%|▍         | 49/1000 [1:20:33<26:03:24, 98.64s/it] [Succeeded / Failed / Skipped / Total] 25 / 24 / 0 / 49:   5%|▍         | 49/1000 [1:20:33<26:03:24, 98.64s/it][Succeeded / Failed / Skipped / Total] 25 / 24 / 0 / 49:   5%|▌         | 50/1000 [1:24:57<26:54:03, 101.94s/it][Succeeded / Failed / Skipped / Total] 25 / 25 / 0 / 50:   5%|▌         | 50/1000 [1:24:57<26:54:03, 101.94s/it][Succeeded / Failed / Skipped / Total] 25 / 25 / 0 / 50:   5%|▌         | 51/1000 [1:27:47<27:13:40, 103.29s/it][Succeeded / Failed / Skipped / Total] 25 / 26 / 0 / 51:   5%|▌         | 51/1000 [1:27:47<27:13:40, 103.29s/it][Succeeded / Failed / Skipped / Total] 25 / 26 / 0 / 51:   5%|▌         | 52/1000 [1:30:14<27:25:08, 104.12s/it][Succeeded / Failed / Skipped / Total] 26 / 26 / 0 / 52:   5%|▌         | 52/1000 [1:30:14<27:25:08, 104.12s/it][Succeeded / Failed / Skipped / Total] 26 / 26 / 0 / 52:   5%|▌         | 53/1000 [1:31:13<27:10:06, 103.28s/it][Succeeded / Failed / Skipped / Total] 27 / 26 / 0 / 53:   5%|▌         | 53/1000 [1:31:13<27:10:06, 103.28s/it][Succeeded / Failed / Skipped / Total] 27 / 26 / 0 / 53:   5%|▌         | 54/1000 [1:32:34<27:01:49, 102.86s/it][Succeeded / Failed / Skipped / Total] 27 / 27 / 0 / 54:   5%|▌         | 54/1000 [1:32:34<27:01:49, 102.86s/it][Succeeded / Failed / Skipped / Total] 27 / 27 / 0 / 54:   6%|▌         | 55/1000 [1:33:01<26:38:25, 101.49s/it]Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 49 ---------------------------------------------
Start unbounded. --> Babbage method --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[babbage]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 50 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[mins]] ( ) { Disposable [[honeymooning]] = resource . get ( ) ; if ( [[honeymooning]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[honeymooning]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 52 ---------------------------------------------
Accepts a subscriber. --> Returns true if there is at least one non-null radiator --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = a [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , [[subscriber]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[mins]] ( Subscriber < ? super U > [[creamy]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[radiators]] = a [ i ] ; if ( [[radiators]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[radiators]] , [[creamy]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[Revolted]]" != "[[Revolted]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 53 ---------------------------------------------
Called when an error occurs. --> Cadres --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[cadres]] ( Throwable [[coffeepot]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[coffeepot]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[coffeepot]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 54 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 28 / 0 / 55:   6%|▌         | 55/1000 [1:33:01<26:38:25, 101.49s/it][Succeeded / Failed / Skipped / Total] 27 / 28 / 0 / 55:   6%|▌         | 56/1000 [1:33:48<26:21:26, 100.52s/it][Succeeded / Failed / Skipped / Total] 28 / 28 / 0 / 56:   6%|▌         | 56/1000 [1:33:48<26:21:26, 100.52s/it][Succeeded / Failed / Skipped / Total] 28 / 28 / 0 / 56:   6%|▌         | 57/1000 [1:34:54<26:10:03, 99.90s/it] [Succeeded / Failed / Skipped / Total] 29 / 28 / 0 / 57:   6%|▌         | 57/1000 [1:34:54<26:10:03, 99.90s/it][Succeeded / Failed / Skipped / Total] 29 / 28 / 0 / 57:   6%|▌         | 58/1000 [1:35:08<25:45:17, 98.43s/it][Succeeded / Failed / Skipped / Total] 30 / 28 / 0 / 58:   6%|▌         | 58/1000 [1:35:08<25:45:17, 98.43s/it][Succeeded / Failed / Skipped / Total] 30 / 28 / 0 / 58:   6%|▌         | 59/1000 [1:36:02<25:31:41, 97.66s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 59/1000 [1:36:02<25:31:41, 97.66s/it][Succeeded / Failed / Skipped / Total] 31 / 28 / 0 / 59:   6%|▌         | 60/1000 [1:39:15<25:55:06, 99.26s/it][Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 60/1000 [1:39:15<25:55:06, 99.26s/it][Succeeded / Failed / Skipped / Total] 31 / 29 / 0 / 60:   6%|▌         | 61/1000 [1:40:32<25:47:37, 98.89s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 61/1000 [1:40:32<25:47:37, 98.89s/it][Succeeded / Failed / Skipped / Total] 32 / 29 / 0 / 61:   6%|▌         | 62/1000 [1:42:00<25:43:14, 98.72s/it][Succeeded / Failed / Skipped / Total] 32 / 30 / 0 / 62:   6%|▌         | 62/1000 [1:42:00<25:43:14, 98.72s/it][Succeeded / Failed / Skipped / Total] 32 / 30 / 0 / 62:   6%|▋         | 63/1000 [1:43:53<25:45:11, 98.95s/it]Called when the supplied value is complete. --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Completes this stream. --> Cadres --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[cadres]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 57 ---------------------------------------------
Concatenates an Iterable into a single Flowable. --> Borrowed from BackpressureSupport --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[concatMapIterable]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[bongo]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[bongo]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 58 ---------------------------------------------
ConcatMapDelayError. --> concatMapDelayError@param jitsu@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return concatMapDelayError ( [[mapper]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[jitsu]] ) { return concatMapDelayError ( [[jitsu]] , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> Await a helsinki@param helsinki@return --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[helsinki]] ) { if ( [[helsinki]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 60 ---------------------------------------------
Offers the specified element to the specified queue. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[dawes]] ( T [[gallic]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[gallic]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[gallic]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 61 ---------------------------------------------
Performs an asynchronous request. --> MUST be called only once --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[mueller]] ( long [[clinics]] ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( [[clinics]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 62 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[strip]] ( T value , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( value , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 63 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 32 / 31 / 0 / 63:   6%|▋         | 63/1000 [1:43:53<25:45:11, 98.95s/it][Succeeded / Failed / Skipped / Total] 32 / 31 / 0 / 63:   6%|▋         | 64/1000 [1:48:07<26:21:26, 101.37s/it][Succeeded / Failed / Skipped / Total] 32 / 32 / 0 / 64:   6%|▋         | 64/1000 [1:48:07<26:21:26, 101.37s/it][Succeeded / Failed / Skipped / Total] 32 / 32 / 0 / 64:   6%|▋         | 65/1000 [1:48:33<26:01:29, 100.20s/it][Succeeded / Failed / Skipped / Total] 33 / 32 / 0 / 65:   6%|▋         | 65/1000 [1:48:33<26:01:29, 100.20s/it][Succeeded / Failed / Skipped / Total] 33 / 32 / 0 / 65:   7%|▋         | 66/1000 [1:52:54<26:37:55, 102.65s/it][Succeeded / Failed / Skipped / Total] 33 / 33 / 0 / 66:   7%|▋         | 66/1000 [1:52:54<26:37:55, 102.65s/it][Succeeded / Failed / Skipped / Total] 33 / 33 / 0 / 66:   7%|▋         | 67/1000 [1:57:18<27:13:30, 105.05s/it]Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[disallowed]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , j ) ; System . arraycopy ( a , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 65 ---------------------------------------------
Creates an error response. --> Creates a new instance of Chronicle@param < ?>@return --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[chronicle]] ( ) { Response < ? > [[alchemy]] ; try { [[alchemy]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[alchemy]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[alchemy]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[alchemy]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 66 ---------------------------------------------
Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 67 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 34 / 33 / 0 / 67:   7%|▋         | 67/1000 [1:57:18<27:13:30, 105.05s/it][Succeeded / Failed / Skipped / Total] 34 / 33 / 0 / 67:   7%|▋         | 68/1000 [1:57:39<26:52:34, 103.81s/it][Succeeded / Failed / Skipped / Total] 34 / 34 / 0 / 68:   7%|▋         | 68/1000 [1:57:39<26:52:34, 103.81s/it][Succeeded / Failed / Skipped / Total] 34 / 34 / 0 / 68:   7%|▋         | 69/1000 [1:57:59<26:32:07, 102.61s/it][Succeeded / Failed / Skipped / Total] 35 / 34 / 0 / 69:   7%|▋         | 69/1000 [1:57:59<26:32:07, 102.61s/it][Succeeded / Failed / Skipped / Total] 35 / 34 / 0 / 69:   7%|▋         | 70/1000 [1:58:30<26:14:22, 101.57s/it][Succeeded / Failed / Skipped / Total] 35 / 35 / 0 / 70:   7%|▋         | 70/1000 [1:58:30<26:14:22, 101.57s/it][Succeeded / Failed / Skipped / Total] 35 / 35 / 0 / 70:   7%|▋         | 71/1000 [1:58:44<25:53:41, 100.35s/it][Succeeded / Failed / Skipped / Total] 36 / 35 / 0 / 71:   7%|▋         | 71/1000 [1:58:44<25:53:41, 100.35s/it][Succeeded / Failed / Skipped / Total] 36 / 35 / 0 / 71:   7%|▋         | 72/1000 [2:00:08<25:48:26, 100.12s/it][Succeeded / Failed / Skipped / Total] 37 / 35 / 0 / 72:   7%|▋         | 72/1000 [2:00:08<25:48:26, 100.12s/it][Succeeded / Failed / Skipped / Total] 37 / 35 / 0 / 72:   7%|▋         | 73/1000 [2:02:33<25:56:22, 100.74s/it][Succeeded / Failed / Skipped / Total] 38 / 35 / 0 / 73:   7%|▋         | 73/1000 [2:02:33<25:56:22, 100.74s/it][Succeeded / Failed / Skipped / Total] 38 / 35 / 0 / 73:   7%|▋         | 74/1000 [2:03:19<25:43:13, 99.99s/it] Calculates the delay between the specified time units. --> Morphicallymorticallymorticallymorticallymorticallymorticallymorticallymorticallymorticallymortically --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[mortify]] ( TimeUnit unit ) { float [[lucretia]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[n]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[n]] ) ; b [ [[n]] ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[iconography]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[chauffer]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[chauffer]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[chauffer]] ) ; b [ [[chauffer]] ] = [[iconography]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 69 ---------------------------------------------
Sets the delay in milliseconds.@param amount the amount@param unit the unit --> Chihuahua chihuahua@param jihadi@param beads --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[chihuahua]] ( long [[jihadi]] , TimeUnit [[beads]] ) { if ( [[jihadi]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[beads]] . toMillis ( [[jihadi]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 70 ---------------------------------------------
Returns the value of the given HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[tensei]] ( String [[degraded]] ) { try { return HttpMethod . valueOf ( [[degraded]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 71 ---------------------------------------------
Performs version checks. --> Dacha algorithm. --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[dacha]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> SCHEMA INTERNAL METHODS --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[schultz]] ( String username , String [[overwhelms]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[outfits]] = new UsernamePasswordAuthenticationToken ( username , [[overwhelms]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 73 ---------------------------------------------
Determines whether or not checks should be disabled. --> D dodo method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[dodo]] ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 35 / 0 / 74:   7%|▋         | 74/1000 [2:03:19<25:43:13, 99.99s/it][Succeeded / Failed / Skipped / Total] 39 / 35 / 0 / 74:   8%|▊         | 75/1000 [2:03:53<25:27:54, 99.11s/it][Succeeded / Failed / Skipped / Total] 39 / 36 / 0 / 75:   8%|▊         | 75/1000 [2:03:53<25:27:54, 99.11s/it][Succeeded / Failed / Skipped / Total] 39 / 36 / 0 / 75:   8%|▊         | 76/1000 [2:04:00<25:07:34, 97.89s/it][Succeeded / Failed / Skipped / Total] 39 / 37 / 0 / 76:   8%|▊         | 76/1000 [2:04:00<25:07:34, 97.89s/it][Succeeded / Failed / Skipped / Total] 39 / 37 / 0 / 76:   8%|▊         | 77/1000 [2:04:07<24:47:54, 96.72s/it][Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 77/1000 [2:04:07<24:47:54, 96.72s/it][Succeeded / Failed / Skipped / Total] 40 / 37 / 0 / 77:   8%|▊         | 78/1000 [2:09:43<25:33:21, 99.78s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 78/1000 [2:09:43<25:33:21, 99.78s/it][Succeeded / Failed / Skipped / Total] 41 / 37 / 0 / 78:   8%|▊         | 79/1000 [2:10:05<25:16:39, 98.81s/it]Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> Called when an LDAP server is started. --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[ignited]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 75 ---------------------------------------------
Parses the response annotations. --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[method]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[method]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[method]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method [[masons]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[masons]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[masons]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 76 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > [[cf]] , final Scheduler [[scheduler]] ) { final Flowable < T > [[flowable]] = [[cf]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[cancel]] ( final ConnectableFlowable < T > [[honorary]] , final Scheduler [[delinquency]] ) { final Flowable < T > [[reena]] = [[honorary]] . observeOn ( [[delinquency]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[honorary]] , [[reena]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 77 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> painlessly painlessly --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[painlessly]] ( ) { Properties [[charitable]] = new Properties ( ) ; try { [[charitable]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[charitable]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 78 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> Creates a new instance of the OAuth2ResourceServerConfigurer@param <HttpSecurity>@param <Darthele>@return@throws Exception --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[danila]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[compatible]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[compatible]] ) ; return [[compatible]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 79 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 37 / 0 / 79:   8%|▊         | 79/1000 [2:10:05<25:16:39, 98.81s/it][Succeeded / Failed / Skipped / Total] 42 / 37 / 0 / 79:   8%|▊         | 80/1000 [2:11:04<25:07:25, 98.31s/it][Succeeded / Failed / Skipped / Total] 43 / 37 / 0 / 80:   8%|▊         | 80/1000 [2:11:04<25:07:25, 98.31s/it][Succeeded / Failed / Skipped / Total] 43 / 37 / 0 / 80:   8%|▊         | 81/1000 [2:11:13<24:48:50, 97.20s/it][Succeeded / Failed / Skipped / Total] 43 / 38 / 0 / 81:   8%|▊         | 81/1000 [2:11:13<24:48:51, 97.20s/it][Succeeded / Failed / Skipped / Total] 43 / 38 / 0 / 81:   8%|▊         | 82/1000 [2:12:16<24:40:48, 96.79s/it][Succeeded / Failed / Skipped / Total] 44 / 38 / 0 / 82:   8%|▊         | 82/1000 [2:12:16<24:40:48, 96.79s/it][Succeeded / Failed / Skipped / Total] 44 / 38 / 0 / 82:   8%|▊         | 83/1000 [2:13:13<24:31:54, 96.31s/it][Succeeded / Failed / Skipped / Total] 44 / 39 / 0 / 83:   8%|▊         | 83/1000 [2:13:13<24:31:54, 96.31s/it][Succeeded / Failed / Skipped / Total] 44 / 39 / 0 / 83:   8%|▊         | 84/1000 [2:14:23<24:25:34, 96.00s/it][Succeeded / Failed / Skipped / Total] 44 / 40 / 0 / 84:   8%|▊         | 84/1000 [2:14:23<24:25:34, 96.00s/it][Succeeded / Failed / Skipped / Total] 44 / 40 / 0 / 84:   8%|▊         | 85/1000 [2:14:54<24:12:10, 95.22s/it]Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> Create a new OAuth2ClientConfigurer@param <HttpSecurity>@return@throws Exception --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[fifteen]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[placerville]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[placerville]] ) ; return [[placerville]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 80 ---------------------------------------------
Retrieves an entry from the LDAP server. --> B bowman operations --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[bowman]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 81 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[dummkopf]] ( CharSequence [[hyoid]] ) { String salt = PREFIX + this . [[cinemax]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[hyoid]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 82 ---------------------------------------------
Search for a single entry under the given base and filter. --> Luxembourg LDAP implementation --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[luxemburg]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 83 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[dissimilar]] ( ) throws Exception { ApplicationContext [[demolition]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[demolition]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 84 ---------------------------------------------
Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . [[attributeExchangeConfigurers]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[intentionally]] ( String [[bourgogne]] ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( [[bourgogne]] ) ; this . [[adnan]] . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
[Succeeded / Failed / Skipped / Total] 45 / 40 / 0 / 85:   8%|▊         | 85/1000 [2:14:54<24:12:10, 95.22s/it][Succeeded / Failed / Skipped / Total] 45 / 40 / 0 / 85:   9%|▊         | 86/1000 [2:18:12<24:28:54, 96.43s/it][Succeeded / Failed / Skipped / Total] 45 / 41 / 0 / 86:   9%|▊         | 86/1000 [2:18:12<24:28:54, 96.43s/it][Succeeded / Failed / Skipped / Total] 45 / 41 / 0 / 86:   9%|▊         | 87/1000 [2:18:25<24:12:35, 95.46s/it][Succeeded / Failed / Skipped / Total] 46 / 41 / 0 / 87:   9%|▊         | 87/1000 [2:18:25<24:12:35, 95.46s/it][Succeeded / Failed / Skipped / Total] 46 / 41 / 0 / 87:   9%|▉         | 88/1000 [2:20:55<24:20:25, 96.08s/it][Succeeded / Failed / Skipped / Total] 46 / 42 / 0 / 88:   9%|▉         | 88/1000 [2:20:55<24:20:25, 96.08s/it][Succeeded / Failed / Skipped / Total] 46 / 42 / 0 / 88:   9%|▉         | 89/1000 [2:25:15<24:46:50, 97.93s/it][Succeeded / Failed / Skipped / Total] 47 / 42 / 0 / 89:   9%|▉         | 89/1000 [2:25:15<24:46:50, 97.93s/it][Succeeded / Failed / Skipped / Total] 47 / 42 / 0 / 89:   9%|▉         | 90/1000 [2:25:39<24:32:43, 97.10s/it]--------------------------------------------- Result 85 ---------------------------------------------
Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> S sulfate methods --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[sulfate]] ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 86 ---------------------------------------------
Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[encircling]] ( SearchControls [[batboy]] ) { return new SearchControls ( [[batboy]] . getSearchScope ( ) , [[batboy]] . getCountLimit ( ) , [[batboy]] . getTimeLimit ( ) , [[batboy]] . getReturningAttributes ( ) , RETURN_OBJECT , [[batboy]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 87 ---------------------------------------------
Creates the servlet api filter. --> Registers an authentication manager with this application. --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[commuted]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 89 ---------------------------------------------
Creates and initializes the filter. --> Dynamically embarass. --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[embarass]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 90 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 42 / 0 / 90:   9%|▉         | 90/1000 [2:25:39<24:32:43, 97.10s/it][Succeeded / Failed / Skipped / Total] 48 / 42 / 0 / 90:   9%|▉         | 91/1000 [2:27:30<24:33:24, 97.25s/it][Succeeded / Failed / Skipped / Total] 48 / 43 / 0 / 91:   9%|▉         | 91/1000 [2:27:30<24:33:24, 97.25s/it][Succeeded / Failed / Skipped / Total] 48 / 43 / 0 / 91:   9%|▉         | 92/1000 [2:28:04<24:21:29, 96.57s/it][Succeeded / Failed / Skipped / Total] 48 / 44 / 0 / 92:   9%|▉         | 92/1000 [2:28:04<24:21:29, 96.57s/it][Succeeded / Failed / Skipped / Total] 48 / 44 / 0 / 92:   9%|▉         | 93/1000 [2:28:40<24:09:59, 95.92s/it]Registers a spring security filter chain. --> Detail servlet context. --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[detail]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 91 ---------------------------------------------
Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 92 ---------------------------------------------
Lookup a set of primary keys.@param acls@param findNow@param sids --> [[[FAILED]]]

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String [[sql]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[sql]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String [[approving]] = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( [[approving]] , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 93 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 45 / 0 / 93:   9%|▉         | 93/1000 [2:28:40<24:09:59, 95.92s/it][Succeeded / Failed / Skipped / Total] 48 / 45 / 0 / 93:   9%|▉         | 94/1000 [2:29:11<23:57:55, 95.23s/it][Succeeded / Failed / Skipped / Total] 49 / 45 / 0 / 94:   9%|▉         | 94/1000 [2:29:11<23:57:55, 95.23s/it][Succeeded / Failed / Skipped / Total] 49 / 45 / 0 / 94:  10%|▉         | 95/1000 [2:30:41<23:55:32, 95.17s/it][Succeeded / Failed / Skipped / Total] 49 / 46 / 0 / 95:  10%|▉         | 95/1000 [2:30:41<23:55:32, 95.17s/it][Succeeded / Failed / Skipped / Total] 49 / 46 / 0 / 95:  10%|▉         | 96/1000 [2:31:33<23:47:07, 94.72s/it][Succeeded / Failed / Skipped / Total] 49 / 47 / 0 / 96:  10%|▉         | 96/1000 [2:31:33<23:47:07, 94.72s/it][Succeeded / Failed / Skipped / Total] 49 / 47 / 0 / 96:  10%|▉         | 97/1000 [2:33:49<23:52:02, 95.15s/it][Succeeded / Failed / Skipped / Total] 50 / 47 / 0 / 97:  10%|▉         | 97/1000 [2:33:49<23:52:02, 95.15s/it][Succeeded / Failed / Skipped / Total] 50 / 47 / 0 / 97:  10%|▉         | 98/1000 [2:34:56<23:46:02, 94.86s/it][Succeeded / Failed / Skipped / Total] 50 / 48 / 0 / 98:  10%|▉         | 98/1000 [2:34:56<23:46:02, 94.86s/it][Succeeded / Failed / Skipped / Total] 50 / 48 / 0 / 98:  10%|▉         | 99/1000 [2:38:26<24:01:56, 96.02s/it]Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 94 ---------------------------------------------
Called after properties have been set. --> Danielson Controls --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[danielson]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[tempered]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[abductors]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[abductors]] = [[abductors]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[abductors]] = [[abductors]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[abductors]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 96 ---------------------------------------------
Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 97 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> Sc scrapbook --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[scrapbook]] ( Collection < String > [[shipyard]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[shipyard]] . size ( ) ) ; for ( String [[grafted]] : [[shipyard]] ) { result . add ( getGrantedAuthority ( [[grafted]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[important]] ( String [[whoever]] ) { try { return Cipher . getInstance ( [[whoever]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 50 / 49 / 0 / 99:  10%|▉         | 99/1000 [2:38:26<24:01:56, 96.02s/it][Succeeded / Failed / Skipped / Total] 50 / 49 / 0 / 99:  10%|█         | 100/1000 [2:42:46<24:24:59, 97.67s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 100/1000 [2:42:46<24:24:59, 97.67s/it][Succeeded / Failed / Skipped / Total] 50 / 50 / 0 / 100:  10%|█         | 101/1000 [2:43:37<24:16:24, 97.20s/it][Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 101/1000 [2:43:37<24:16:24, 97.20s/it][Succeeded / Failed / Skipped / Total] 50 / 51 / 0 / 101:  10%|█         | 102/1000 [2:45:53<24:20:31, 97.59s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 102/1000 [2:45:53<24:20:31, 97.59s/it][Succeeded / Failed / Skipped / Total] 51 / 51 / 0 / 102:  10%|█         | 103/1000 [2:46:30<24:10:03, 96.99s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 103/1000 [2:46:30<24:10:03, 96.99s/it][Succeeded / Failed / Skipped / Total] 52 / 51 / 0 / 103:  10%|█         | 104/1000 [2:46:55<23:58:11, 96.31s/it]Compare two LDAP attributes.@param dn@param attributeName@param value@return --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object value ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 100 ---------------------------------------------
Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[obliterate]] ( String [[heretics]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[peasants]] , int [[sponsors]] ) throws SQLException { return new PersistentRememberMeToken ( [[peasants]] . getString ( 1 ) , [[peasants]] . getString ( 2 ) , [[peasants]] . getString ( 3 ) , [[peasants]] . getTimestamp ( 4 ) ) ; } } , [[heretics]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[heretics]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[heretics]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[heretics]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 101 ---------------------------------------------
Checks the content length of the response. --> [[[FAILED]]]

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 102 ---------------------------------------------
Sets the login processing URL. --> Creates a trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[sutcliffe]] ( String [[napoleons]] ) { this . [[valorous]] = [[sutcliffe]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[sutcliffe]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
Updates the default authentication settings. --> zena logging --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[zena]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[kerrigan]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[kerrigan]] != null && ! [[kerrigan]] . isCustomLogoutSuccess ( ) ) { [[kerrigan]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 53 / 51 / 0 / 104:  10%|█         | 104/1000 [2:46:55<23:58:11, 96.31s/it][Succeeded / Failed / Skipped / Total] 53 / 51 / 0 / 104:  10%|█         | 105/1000 [2:49:19<24:03:16, 96.76s/it][Succeeded / Failed / Skipped / Total] 54 / 51 / 0 / 105:  10%|█         | 105/1000 [2:49:19<24:03:16, 96.76s/it][Succeeded / Failed / Skipped / Total] 54 / 51 / 0 / 105:  11%|█         | 106/1000 [2:49:43<23:51:31, 96.08s/it][Succeeded / Failed / Skipped / Total] 54 / 52 / 0 / 106:  11%|█         | 106/1000 [2:49:43<23:51:31, 96.08s/it][Succeeded / Failed / Skipped / Total] 54 / 52 / 0 / 106:  11%|█         | 107/1000 [2:51:40<23:52:43, 96.26s/it][Succeeded / Failed / Skipped / Total] 54 / 53 / 0 / 107:  11%|█         | 107/1000 [2:51:40<23:52:43, 96.26s/it][Succeeded / Failed / Skipped / Total] 54 / 53 / 0 / 107:  11%|█         | 108/1000 [2:52:12<23:42:17, 95.67s/it][Succeeded / Failed / Skipped / Total] 54 / 54 / 0 / 108:  11%|█         | 108/1000 [2:52:12<23:42:17, 95.67s/it][Succeeded / Failed / Skipped / Total] 54 / 54 / 0 / 108:  11%|█         | 109/1000 [2:58:27<24:18:43, 98.23s/it][Succeeded / Failed / Skipped / Total] 55 / 54 / 0 / 109:  11%|█         | 109/1000 [2:58:27<24:18:43, 98.23s/it][Succeeded / Failed / Skipped / Total] 55 / 54 / 0 / 109:  11%|█         | 110/1000 [2:59:00<24:08:17, 97.64s/it]Updates the default access settings. --> V vacuuming --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[vacuuming]] ( B [[mccain]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[mccain]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 105 ---------------------------------------------
Maps a password value to a string. --> Makina Memberships --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[makina]] ( Object [[memberships]] ) { if ( ! ( [[memberships]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 106 ---------------------------------------------
Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[shuffleboard]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 107 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[balkan]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 108 ---------------------------------------------
Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest request , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 109 ---------------------------------------------
Returns the port of the given service URL. --> gunfights --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[gunfights]] ( URL [[blackie]] ) { int port = [[blackie]] . getPort ( ) ; if ( port == - 1 ) { port = [[blackie]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 55 / 55 / 0 / 110:  11%|█         | 110/1000 [2:59:00<24:08:17, 97.64s/it][Succeeded / Failed / Skipped / Total] 55 / 55 / 0 / 110:  11%|█         | 111/1000 [3:00:48<24:08:05, 97.73s/it][Succeeded / Failed / Skipped / Total] 55 / 56 / 0 / 111:  11%|█         | 111/1000 [3:00:48<24:08:05, 97.73s/it][Succeeded / Failed / Skipped / Total] 55 / 56 / 0 / 111:  11%|█         | 112/1000 [3:01:00<23:55:08, 96.97s/it][Succeeded / Failed / Skipped / Total] 56 / 56 / 0 / 112:  11%|█         | 112/1000 [3:01:00<23:55:08, 96.97s/it][Succeeded / Failed / Skipped / Total] 56 / 56 / 0 / 112:  11%|█▏        | 113/1000 [3:04:23<24:07:24, 97.91s/it][Succeeded / Failed / Skipped / Total] 56 / 57 / 0 / 113:  11%|█▏        | 113/1000 [3:04:23<24:07:24, 97.91s/it][Succeeded / Failed / Skipped / Total] 56 / 57 / 0 / 113:  11%|█▏        | 114/1000 [3:05:20<24:00:27, 97.55s/it]Performs a pre-authenticated authentication. --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 111 ---------------------------------------------
Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[cookieTokens]] ) { StringBuilder [[sb]] = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < [[cookieTokens]] . length ; [[i]] ++ ) { try { [[sb]] . append ( URLEncoder . encode ( [[cookieTokens]] [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < [[cookieTokens]] . length - 1 ) { [[sb]] . append ( DELIMITER ) ; } } String value = [[sb]] . toString ( ) ; [[sb]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[sb]] . charAt ( [[sb]] . length ( ) - 1 ) == ' ' ) { [[sb]] . deleteCharAt ( [[sb]] . length ( ) - 1 ) ; } return [[sb]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] [[tap]] ) { StringBuilder [[orbit]] = new StringBuilder ( ) ; for ( int [[guitars]] = 0 ; [[guitars]] < [[tap]] . length ; [[guitars]] ++ ) { try { [[orbit]] . append ( URLEncoder . encode ( [[tap]] [ [[guitars]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[guitars]] < [[tap]] . length - 1 ) { [[orbit]] . append ( DELIMITER ) ; } } String value = [[orbit]] . toString ( ) ; [[orbit]] = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( [[orbit]] . charAt ( [[orbit]] . length ( ) - 1 ) == ' ' ) { [[orbit]] . deleteCharAt ( [[orbit]] . length ( ) - 1 ) ; } return [[orbit]] . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 112 ---------------------------------------------
Extracts the remember-me cookie from the request. --> D dodo@param stylhe HttpServletRequest --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[dodo]] ( HttpServletRequest [[strive]] ) { Cookie [ ] cookies = [[strive]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 113 ---------------------------------------------
Sets the cookie. --> [[[FAILED]]]

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 57 / 0 / 114:  11%|█▏        | 114/1000 [3:05:20<24:00:27, 97.55s/it][Succeeded / Failed / Skipped / Total] 57 / 57 / 0 / 114:  12%|█▏        | 115/1000 [3:07:16<24:01:11, 97.71s/it][Succeeded / Failed / Skipped / Total] 58 / 57 / 0 / 115:  12%|█▏        | 115/1000 [3:07:16<24:01:11, 97.71s/it][Succeeded / Failed / Skipped / Total] 58 / 57 / 0 / 115:  12%|█▏        | 116/1000 [3:07:25<23:48:16, 96.94s/it][Succeeded / Failed / Skipped / Total] 59 / 57 / 0 / 116:  12%|█▏        | 116/1000 [3:07:25<23:48:16, 96.94s/it][Succeeded / Failed / Skipped / Total] 59 / 57 / 0 / 116:  12%|█▏        | 117/1000 [3:08:03<23:39:12, 96.44s/it][Succeeded / Failed / Skipped / Total] 60 / 57 / 0 / 117:  12%|█▏        | 117/1000 [3:08:03<23:39:12, 96.44s/it][Succeeded / Failed / Skipped / Total] 60 / 57 / 0 / 117:  12%|█▏        | 118/1000 [3:09:51<23:39:05, 96.54s/it][Succeeded / Failed / Skipped / Total] 61 / 57 / 0 / 118:  12%|█▏        | 118/1000 [3:09:51<23:39:05, 96.54s/it][Succeeded / Failed / Skipped / Total] 61 / 57 / 0 / 118:  12%|█▏        | 119/1000 [3:13:03<23:49:15, 97.34s/it][Succeeded / Failed / Skipped / Total] 61 / 58 / 0 / 119:  12%|█▏        | 119/1000 [3:13:03<23:49:15, 97.34s/it][Succeeded / Failed / Skipped / Total] 61 / 58 / 0 / 119:  12%|█▏        | 120/1000 [3:13:37<23:39:56, 96.81s/it][Succeeded / Failed / Skipped / Total] 62 / 58 / 0 / 120:  12%|█▏        | 120/1000 [3:13:37<23:39:56, 96.81s/it][Succeeded / Failed / Skipped / Total] 62 / 58 / 0 / 120:  12%|█▏        | 121/1000 [3:14:06<23:30:04, 96.25s/it]Resolve the security context for the given parameter. --> C crouse a request --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter [[parameter]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > [[o]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[o]] : Mono . just ( adapter . fromPublisher ( [[o]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[crouse]] ( MethodParameter [[center]] , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[center]] . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( [[center]] , a ) ; Mono < Object > [[mailboxes]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[mailboxes]] : Mono . just ( adapter . fromPublisher ( [[mailboxes]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 115 ---------------------------------------------
Authenticates the given authentication object. --> Enables or disables skinning. --> Socre: 1.0

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[skinning]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[evacuation]] = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 116 ---------------------------------------------
Returns the fully-qualified URL to redirect to. --> SCHEMOVED --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[schnoz]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 117 ---------------------------------------------
End the page. --> Rethrows a JSPException --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[wrath]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
Sets the context environment properties.@param environment the context environment properties --> Recovery from the supplied frisian --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[recovery]] ( Map < String , Object > [[frisian]] ) { Assert . notEmpty ( [[frisian]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[frisian]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 119 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest request , final Pattern artifactPattern ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 120 ---------------------------------------------
Initializes the user details service. --> CAMCORDER implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[camcorder]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 59 / 0 / 121:  12%|█▏        | 121/1000 [3:14:06<23:30:05, 96.25s/it][Succeeded / Failed / Skipped / Total] 62 / 59 / 0 / 121:  12%|█▏        | 122/1000 [3:14:32<23:20:07, 95.68s/it][Succeeded / Failed / Skipped / Total] 62 / 60 / 0 / 122:  12%|█▏        | 122/1000 [3:14:32<23:20:07, 95.68s/it][Succeeded / Failed / Skipped / Total] 62 / 60 / 0 / 122:  12%|█▏        | 123/1000 [3:16:11<23:18:50, 95.70s/it][Succeeded / Failed / Skipped / Total] 62 / 61 / 0 / 123:  12%|█▏        | 123/1000 [3:16:11<23:18:50, 95.70s/it][Succeeded / Failed / Skipped / Total] 62 / 61 / 0 / 123:  12%|█▏        | 124/1000 [3:16:16<23:06:31, 94.97s/it][Succeeded / Failed / Skipped / Total] 62 / 62 / 0 / 124:  12%|█▏        | 124/1000 [3:16:16<23:06:31, 94.97s/it][Succeeded / Failed / Skipped / Total] 62 / 62 / 0 / 124:  12%|█▎        | 125/1000 [3:17:30<23:02:34, 94.80s/it][Succeeded / Failed / Skipped / Total] 63 / 62 / 0 / 125:  12%|█▎        | 125/1000 [3:17:30<23:02:34, 94.80s/it][Succeeded / Failed / Skipped / Total] 63 / 62 / 0 / 125:  13%|█▎        | 126/1000 [3:17:40<22:51:11, 94.13s/it]Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[stabilize]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = authentication . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[principal]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[tormentor]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[clarissa]] = authentication . getPrincipal ( ) ; if ( [[clarissa]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[clarissa]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 123 ---------------------------------------------
Logs out the given request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 124 ---------------------------------------------
Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 125 ---------------------------------------------
Returns true if the user is authenticated. --> Dorkus authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[dorkus]] ( ) { Authentication [[valeri]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[valeri]] != null && [[valeri]] . isAuthenticated ( ) && ! ( [[valeri]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
[Succeeded / Failed / Skipped / Total] 64 / 62 / 0 / 126:  13%|█▎        | 126/1000 [3:17:40<22:51:11, 94.13s/it][Succeeded / Failed / Skipped / Total] 64 / 62 / 0 / 126:  13%|█▎        | 127/1000 [3:17:55<22:40:32, 93.51s/it][Succeeded / Failed / Skipped / Total] 65 / 62 / 0 / 127:  13%|█▎        | 127/1000 [3:17:55<22:40:32, 93.51s/it][Succeeded / Failed / Skipped / Total] 65 / 62 / 0 / 127:  13%|█▎        | 128/1000 [3:20:25<22:45:21, 93.95s/it][Succeeded / Failed / Skipped / Total] 66 / 62 / 0 / 128:  13%|█▎        | 128/1000 [3:20:25<22:45:21, 93.95s/it][Succeeded / Failed / Skipped / Total] 66 / 62 / 0 / 128:  13%|█▎        | 129/1000 [3:26:44<23:15:55, 96.16s/it][Succeeded / Failed / Skipped / Total] 66 / 63 / 0 / 129:  13%|█▎        | 129/1000 [3:26:44<23:15:55, 96.16s/it][Succeeded / Failed / Skipped / Total] 66 / 63 / 0 / 129:  13%|█▎        | 130/1000 [3:28:12<23:13:23, 96.10s/it][Succeeded / Failed / Skipped / Total] 66 / 64 / 0 / 130:  13%|█▎        | 130/1000 [3:28:12<23:13:23, 96.10s/it][Succeeded / Failed / Skipped / Total] 66 / 64 / 0 / 130:  13%|█▎        | 131/1000 [3:29:51<23:12:06, 96.12s/it][Succeeded / Failed / Skipped / Total] 66 / 65 / 0 / 131:  13%|█▎        | 131/1000 [3:29:51<23:12:06, 96.12s/it][Succeeded / Failed / Skipped / Total] 66 / 65 / 0 / 131:  13%|█▎        | 132/1000 [3:30:57<23:07:09, 95.89s/it]--------------------------------------------- Result 126 ---------------------------------------------
Add Pkce parameters. --> SCHaffer function --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[schaffer]] ( Map < String , Object > attributes , Map < String , Object > [[diabetic]] ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[diabetic]] . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 127 ---------------------------------------------
URL-encode the given value. --> Encode the supplied string. --> Socre: 1.0

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[bystanders]] ) { try { return URLEncoder . encode ( [[bystanders]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Creates a security expression root. --> burnside operations --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( authentication ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[burnside]] ( Authentication authentication , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[howmany]] = new MethodSecurityExpressionRoot ( authentication ) ; [[howmany]] . setThis ( invocation . getThis ( ) ) ; [[howmany]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[howmany]] . setTrustResolver ( getTrustResolver ( ) ) ; [[howmany]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[howmany]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[howmany]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 129 ---------------------------------------------
Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[zagreb]] ( ) { List < String > [[slopes]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[bailiffs]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[slopes]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[slopes]] + " mapped to Granted Authorities: " + [[bailiffs]] ) ; } return [[bailiffs]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 130 ---------------------------------------------
Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[dubuque]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 131 ---------------------------------------------
Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[redo]] ( final Assertion [[thirteen]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[thirteen]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 132 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 66 / 0 / 132:  13%|█▎        | 132/1000 [3:30:57<23:07:09, 95.89s/it][Succeeded / Failed / Skipped / Total] 66 / 66 / 0 / 132:  13%|█▎        | 133/1000 [3:34:41<23:19:32, 96.85s/it][Succeeded / Failed / Skipped / Total] 66 / 67 / 0 / 133:  13%|█▎        | 133/1000 [3:34:41<23:19:32, 96.85s/it][Succeeded / Failed / Skipped / Total] 66 / 67 / 0 / 133:  13%|█▎        | 134/1000 [3:34:45<23:07:53, 96.16s/it][Succeeded / Failed / Skipped / Total] 67 / 67 / 0 / 134:  13%|█▎        | 134/1000 [3:34:45<23:07:53, 96.16s/it][Succeeded / Failed / Skipped / Total] 67 / 67 / 0 / 134:  14%|█▎        | 135/1000 [3:35:31<23:00:57, 95.79s/it][Succeeded / Failed / Skipped / Total] 67 / 68 / 0 / 135:  14%|█▎        | 135/1000 [3:35:31<23:00:57, 95.79s/it][Succeeded / Failed / Skipped / Total] 67 / 68 / 0 / 135:  14%|█▎        | 136/1000 [3:37:53<23:04:12, 96.13s/it][Succeeded / Failed / Skipped / Total] 68 / 68 / 0 / 136:  14%|█▎        | 136/1000 [3:37:53<23:04:12, 96.13s/it][Succeeded / Failed / Skipped / Total] 68 / 68 / 0 / 136:  14%|█▎        | 137/1000 [3:41:29<23:15:11, 97.00s/it][Succeeded / Failed / Skipped / Total] 68 / 69 / 0 / 137:  14%|█▎        | 137/1000 [3:41:29<23:15:11, 97.00s/it][Succeeded / Failed / Skipped / Total] 68 / 69 / 0 / 137:  14%|█▍        | 138/1000 [3:42:34<23:10:19, 96.77s/it][Succeeded / Failed / Skipped / Total] 69 / 69 / 0 / 138:  14%|█▍        | 138/1000 [3:42:34<23:10:19, 96.77s/it][Succeeded / Failed / Skipped / Total] 69 / 69 / 0 / 138:  14%|█▍        | 139/1000 [3:47:07<23:26:54, 98.04s/it]Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[backflip]] ( final HttpServletRequest [[abstain]] ) { final boolean [[paraphrasing]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[abstain]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[paraphrasing]] ) ; } return [[paraphrasing]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 133 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[toying]] ( HttpServletRequest [[lynda]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 134 ---------------------------------------------
Retrieves a single JWK set. --> Creates a new JWKSet@param <JWKSet>@return --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[genus]] ( ) { return this . [[whos]] . get ( ) . uri ( this . [[wifey]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 135 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 136 ---------------------------------------------
Returns a collection of authorities for the supplied object. --> Copacabana roles --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[value]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[copacabana]] ( Object [[clanks]] ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , [[clanks]] ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[newArray]] , destPos , array . length ) ; destPos += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[similar]] ( byte [ ] ... arrays ) { int length = 0 ; for ( byte [ ] array : arrays ) { length += array . length ; } byte [ ] [[chemistry]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : arrays ) { System . arraycopy ( array , 0 , [[chemistry]] , destPos , array . length ) ; destPos += array . length ; } return [[chemistry]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 138 ---------------------------------------------
Adds a collection of granted authorities to the supplied value. --> Landlady methods --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[landlady]] ( Collection < GrantedAuthority > [[zacarias]] , Object [[beaton]] ) { if ( [[beaton]] == null ) { return ; } if ( [[beaton]] instanceof Collection < ? > ) { [[landlady]] ( [[zacarias]] , ( Collection < ? > ) [[beaton]] ) ; } else if ( [[beaton]] instanceof Object [ ] ) { [[landlady]] ( [[zacarias]] , ( Object [ ] ) [[beaton]] ) ; } else if ( [[beaton]] instanceof String ) { [[landlady]] ( [[zacarias]] , ( String ) [[beaton]] ) ; } else if ( [[beaton]] instanceof GrantedAuthority ) { [[zacarias]] . add ( ( GrantedAuthority ) [[beaton]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[beaton]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 139 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 70 / 0 / 139:  14%|█▍        | 139/1000 [3:47:07<23:26:54, 98.04s/it][Succeeded / Failed / Skipped / Total] 69 / 70 / 0 / 139:  14%|█▍        | 140/1000 [3:49:21<23:28:56, 98.30s/it][Succeeded / Failed / Skipped / Total] 69 / 71 / 0 / 140:  14%|█▍        | 140/1000 [3:49:21<23:28:56, 98.30s/it][Succeeded / Failed / Skipped / Total] 69 / 71 / 0 / 140:  14%|█▍        | 141/1000 [3:53:49<23:44:30, 99.50s/it][Succeeded / Failed / Skipped / Total] 70 / 71 / 0 / 141:  14%|█▍        | 141/1000 [3:53:49<23:44:30, 99.50s/it][Succeeded / Failed / Skipped / Total] 70 / 71 / 0 / 141:  14%|█▍        | 142/1000 [3:53:59<23:33:48, 98.87s/it][Succeeded / Failed / Skipped / Total] 70 / 72 / 0 / 142:  14%|█▍        | 142/1000 [3:53:59<23:33:48, 98.87s/it][Succeeded / Failed / Skipped / Total] 70 / 72 / 0 / 142:  14%|█▍        | 143/1000 [3:54:36<23:26:00, 98.44s/it][Succeeded / Failed / Skipped / Total] 71 / 72 / 0 / 143:  14%|█▍        | 143/1000 [3:54:36<23:26:00, 98.44s/it][Succeeded / Failed / Skipped / Total] 71 / 72 / 0 / 143:  14%|█▍        | 144/1000 [3:56:12<23:24:10, 98.42s/it][Succeeded / Failed / Skipped / Total] 71 / 73 / 0 / 144:  14%|█▍        | 144/1000 [3:56:12<23:24:10, 98.42s/it][Succeeded / Failed / Skipped / Total] 71 / 73 / 0 / 144:  14%|█▍        | 145/1000 [3:57:46<23:22:04, 98.39s/it][Succeeded / Failed / Skipped / Total] 72 / 73 / 0 / 145:  14%|█▍        | 145/1000 [3:57:46<23:22:04, 98.39s/it][Succeeded / Failed / Skipped / Total] 72 / 73 / 0 / 145:  15%|█▍        | 146/1000 [4:00:00<23:23:51, 98.63s/it]Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 140 ---------------------------------------------
Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[resnick]] > [[resnick]] getSharedObject ( Class < [[resnick]] > sharedType ) { return ( [[resnick]] ) this . [[athlete]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
Checks if the given role starts with ROLE_. --> zizi zizi --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[zizi]] ( String [[offering]] ) { Assert . isTrue ( ! [[offering]] . startsWith ( "ROLE_" ) , ( ) -> [[offering]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[offering]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 142 ---------------------------------------------
Creates a subarray from an array of bytes. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( array , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 143 ---------------------------------------------
Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> Creates a bag of authorities. --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[beanbag]] ( Map < ? , ? > [[brasilia]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[brasilia]] . size ( ) ) ; for ( Map . Entry < ? , ? > [[offering]] : [[brasilia]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[offering]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[offering]] . getKey ( ) , getGrantedAuthorityCollection ( [[offering]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 144 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[invincible]] ( HttpServletRequest [[pais]] ) { Object [[showdown]] = [[pais]] . getUserPrincipal ( ) == null ? null : [[pais]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[showdown]] ) ; } return [[showdown]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 145 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> zacharias@param pomona@return --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[zacharias]] ( String ... [[pomona]] ) { for ( int i = 0 ; i < [[pomona]] . length ; i ++ ) { [[pomona]] [ i ] = "ROLE_" + [[pomona]] [ i ] ; } return [[pomona]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 73 / 0 / 146:  15%|█▍        | 146/1000 [4:00:00<23:23:51, 98.63s/it][Succeeded / Failed / Skipped / Total] 73 / 73 / 0 / 146:  15%|█▍        | 147/1000 [4:04:10<23:36:55, 99.67s/it][Succeeded / Failed / Skipped / Total] 73 / 74 / 0 / 147:  15%|█▍        | 147/1000 [4:04:10<23:36:55, 99.67s/it][Succeeded / Failed / Skipped / Total] 73 / 74 / 0 / 147:  15%|█▍        | 148/1000 [4:04:27<23:27:17, 99.11s/it][Succeeded / Failed / Skipped / Total] 74 / 74 / 0 / 148:  15%|█▍        | 148/1000 [4:04:27<23:27:17, 99.11s/it][Succeeded / Failed / Skipped / Total] 74 / 74 / 0 / 148:  15%|█▍        | 149/1000 [4:05:05<23:19:50, 98.70s/it][Succeeded / Failed / Skipped / Total] 74 / 75 / 0 / 149:  15%|█▍        | 149/1000 [4:05:05<23:19:51, 98.70s/it][Succeeded / Failed / Skipped / Total] 74 / 75 / 0 / 149:  15%|█▌        | 150/1000 [4:05:39<23:12:02, 98.26s/it][Succeeded / Failed / Skipped / Total] 75 / 75 / 0 / 150:  15%|█▌        | 150/1000 [4:05:39<23:12:02, 98.26s/it][Succeeded / Failed / Skipped / Total] 75 / 75 / 0 / 150:  15%|█▌        | 151/1000 [4:08:01<23:14:33, 98.56s/it][Succeeded / Failed / Skipped / Total] 75 / 76 / 0 / 151:  15%|█▌        | 151/1000 [4:08:01<23:14:33, 98.56s/it][Succeeded / Failed / Skipped / Total] 75 / 76 / 0 / 151:  15%|█▌        | 152/1000 [4:10:15<23:16:10, 98.79s/it]Invokes the specified JoinPoint. --> Invoke a shopkeeper@param aaaagh@param advisorProceed@return --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint [[jp]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object [[result]] ; try { [[result]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[shopkeepers]] ( JoinPoint [[aaaagh]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[aaaagh]] ) ) ; Object [[renda]] ; try { [[renda]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[renda]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 147 ---------------------------------------------
Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( request . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( request . getContextPath ( ) ) ; urlBuilder . setServletPath ( request . getServletPath ( ) ) ; urlBuilder . setPathInfo ( request . getPathInfo ( ) ) ; urlBuilder . setQuery ( request . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 148 ---------------------------------------------
Display a public index. --> Randomly selects a contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[savage]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 149 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( [[c]] != null ) { [[gaList]] . addAll ( [[c]] ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[surrendered]] ) { ArrayList < GrantedAuthority > [[antitoxin]] = new ArrayList <> ( ) ; for ( String [[amalgamation]] : [[surrendered]] ) { Collection < GrantedAuthority > [[brahms]] = attributes2grantedAuthoritiesMap . get ( [[amalgamation]] ) ; if ( [[brahms]] != null ) { [[antitoxin]] . addAll ( [[brahms]] ) ; } } [[antitoxin]] . trimToSize ( ) ; return [[antitoxin]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 150 ---------------------------------------------
Attempt to exit the user. --> Laedt die uebergebenen uebergebenen --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[levitated]] ( HttpServletRequest [[chairperson]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 151 ---------------------------------------------
Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 152 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 77 / 0 / 152:  15%|█▌        | 152/1000 [4:10:15<23:16:10, 98.79s/it][Succeeded / Failed / Skipped / Total] 75 / 77 / 0 / 152:  15%|█▌        | 153/1000 [4:10:23<23:06:11, 98.20s/it][Succeeded / Failed / Skipped / Total] 76 / 77 / 0 / 153:  15%|█▌        | 153/1000 [4:10:23<23:06:11, 98.20s/it][Succeeded / Failed / Skipped / Total] 76 / 77 / 0 / 153:  15%|█▌        | 154/1000 [4:13:07<23:10:31, 98.62s/it][Succeeded / Failed / Skipped / Total] 77 / 77 / 0 / 154:  15%|█▌        | 154/1000 [4:13:07<23:10:31, 98.62s/it][Succeeded / Failed / Skipped / Total] 77 / 77 / 0 / 154:  16%|█▌        | 155/1000 [4:13:28<23:01:53, 98.12s/it][Succeeded / Failed / Skipped / Total] 77 / 78 / 0 / 155:  16%|█▌        | 155/1000 [4:13:29<23:01:53, 98.12s/it][Succeeded / Failed / Skipped / Total] 77 / 78 / 0 / 155:  16%|█▌        | 156/1000 [4:16:56<23:10:05, 98.82s/it][Succeeded / Failed / Skipped / Total] 78 / 78 / 0 / 156:  16%|█▌        | 156/1000 [4:16:56<23:10:05, 98.82s/it][Succeeded / Failed / Skipped / Total] 78 / 78 / 0 / 156:  16%|█▌        | 157/1000 [4:19:43<23:14:34, 99.26s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 0 / 157:  16%|█▌        | 157/1000 [4:19:43<23:14:34, 99.26s/it][Succeeded / Failed / Skipped / Total] 78 / 79 / 0 / 157:  16%|█▌        | 158/1000 [4:21:03<23:11:13, 99.14s/it]Sets the URL that will be used to exit from the browser. --> [[[FAILED]]]

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[signpost]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 153 ---------------------------------------------
Creates a spring security filter chain. --> Sleep for a certain amount of time. --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[sleepover]] ( ) throws Exception { boolean [[alight]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[alight]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 154 ---------------------------------------------
Converts a jwt to a list of authorities. --> Converts a JWT to a Collection of GrantedAuthorities. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt [[lifted]] ) { return getScopes ( [[lifted]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Attempts to switch to the specified user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 156 ---------------------------------------------
Generate a CSRF token. --> Convenience method to count the number of tokens in the request. --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[counts]] ( HttpServletRequest [[worms]] ) { return wrap ( [[worms]] , this . delegate . generateToken ( [[worms]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 79 / 79 / 0 / 158:  16%|█▌        | 158/1000 [4:21:03<23:11:13, 99.14s/it][Succeeded / Failed / Skipped / Total] 79 / 79 / 0 / 158:  16%|█▌        | 159/1000 [4:23:03<23:11:26, 99.27s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 0 / 159:  16%|█▌        | 159/1000 [4:23:03<23:11:26, 99.27s/it][Succeeded / Failed / Skipped / Total] 79 / 80 / 0 / 159:  16%|█▌        | 160/1000 [4:23:40<23:04:19, 98.88s/it][Succeeded / Failed / Skipped / Total] 79 / 81 / 0 / 160:  16%|█▌        | 160/1000 [4:23:40<23:04:19, 98.88s/it][Succeeded / Failed / Skipped / Total] 79 / 81 / 0 / 160:  16%|█▌        | 161/1000 [4:26:31<23:08:56, 99.33s/it][Succeeded / Failed / Skipped / Total] 79 / 82 / 0 / 161:  16%|█▌        | 161/1000 [4:26:31<23:08:56, 99.33s/it][Succeeded / Failed / Skipped / Total] 79 / 82 / 0 / 161:  16%|█▌        | 162/1000 [4:26:39<22:59:24, 98.76s/it][Succeeded / Failed / Skipped / Total] 79 / 83 / 0 / 162:  16%|█▌        | 162/1000 [4:26:39<22:59:24, 98.76s/it][Succeeded / Failed / Skipped / Total] 79 / 83 / 0 / 162:  16%|█▋        | 163/1000 [4:26:55<22:50:41, 98.26s/it]Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> Paints the given permissions for the given contact. --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[paintwork]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 159 ---------------------------------------------
Decodes and validates the given token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String [[token]] ) throws JwtException { JWT [[jwt]] = parse ( [[token]] ) ; if ( [[jwt]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[token]] , [[jwt]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[jwt]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[liebling]] ( String [[ilia]] ) throws JwtException { JWT [[vibrant]] = parse ( [[ilia]] ) ; if ( [[vibrant]] instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[ilia]] , [[vibrant]] ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + [[vibrant]] . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 160 ---------------------------------------------
Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 161 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[masquerading]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 162 ---------------------------------------------
Display the admin page. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 163 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 83 / 0 / 163:  16%|█▋        | 163/1000 [4:26:55<22:50:41, 98.26s/it][Succeeded / Failed / Skipped / Total] 80 / 83 / 0 / 163:  16%|█▋        | 164/1000 [4:28:25<22:48:16, 98.20s/it][Succeeded / Failed / Skipped / Total] 81 / 83 / 0 / 164:  16%|█▋        | 164/1000 [4:28:25<22:48:16, 98.20s/it][Succeeded / Failed / Skipped / Total] 81 / 83 / 0 / 164:  16%|█▋        | 165/1000 [4:30:53<22:50:54, 98.51s/it][Succeeded / Failed / Skipped / Total] 81 / 84 / 0 / 165:  16%|█▋        | 165/1000 [4:30:53<22:50:54, 98.51s/it][Succeeded / Failed / Skipped / Total] 81 / 84 / 0 / 165:  17%|█▋        | 166/1000 [4:32:05<22:46:58, 98.34s/it][Succeeded / Failed / Skipped / Total] 82 / 84 / 0 / 166:  17%|█▋        | 166/1000 [4:32:05<22:46:58, 98.34s/it][Succeeded / Failed / Skipped / Total] 82 / 84 / 0 / 166:  17%|█▋        | 167/1000 [4:32:08<22:37:25, 97.77s/it][Succeeded / Failed / Skipped / Total] 82 / 85 / 0 / 167:  17%|█▋        | 167/1000 [4:32:08<22:37:25, 97.77s/it][Succeeded / Failed / Skipped / Total] 82 / 85 / 0 / 167:  17%|█▋        | 168/1000 [4:32:16<22:28:22, 97.24s/it][Succeeded / Failed / Skipped / Total] 83 / 85 / 0 / 168:  17%|█▋        | 168/1000 [4:32:16<22:28:22, 97.24s/it][Succeeded / Failed / Skipped / Total] 83 / 85 / 0 / 168:  17%|█▋        | 169/1000 [4:35:27<22:34:29, 97.80s/it]Returns the role with the given default prefix. --> Converts the supplied string into a hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular hawkular --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( defaultRolePrefix ) ) { return [[role]] ; } return defaultRolePrefix + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[wehrmacht]] ( String defaultRolePrefix , String [[buzzers]] ) { if ( [[buzzers]] == null ) { return [[buzzers]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[buzzers]] ; } if ( [[buzzers]] . startsWith ( defaultRolePrefix ) ) { return [[buzzers]] ; } return defaultRolePrefix + [[buzzers]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 164 ---------------------------------------------
Creates an instance of UserDetailsResourceFactoryBean from the given string. --> Factory for vagabonds. --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[vagabonds]] ( String [[righteousness]] ) { InMemoryResource resource = new InMemoryResource ( [[righteousness]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 165 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 166 ---------------------------------------------
Decodes the given bytes into a string. --> burners --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[burners]] ( byte [ ] [[shillelagh]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[shillelagh]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 167 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( addPermission , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 168 ---------------------------------------------
Returns the first attribute value for the supplied name. --> Get leav@param dottente@return --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[leav]] ( String [[détente]] ) { List < String > result = getAttributeValues ( [[détente]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 169 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 86 / 0 / 169:  17%|█▋        | 169/1000 [4:35:27<22:34:29, 97.80s/it][Succeeded / Failed / Skipped / Total] 83 / 86 / 0 / 169:  17%|█▋        | 170/1000 [4:38:43<22:40:51, 98.38s/it][Succeeded / Failed / Skipped / Total] 83 / 87 / 0 / 170:  17%|█▋        | 170/1000 [4:38:43<22:40:51, 98.38s/it][Succeeded / Failed / Skipped / Total] 83 / 87 / 0 / 170:  17%|█▋        | 171/1000 [4:38:56<22:32:16, 97.87s/it][Succeeded / Failed / Skipped / Total] 84 / 87 / 0 / 171:  17%|█▋        | 171/1000 [4:38:56<22:32:16, 97.87s/it][Succeeded / Failed / Skipped / Total] 84 / 87 / 0 / 171:  17%|█▋        | 172/1000 [4:44:40<22:50:25, 99.31s/it][Succeeded / Failed / Skipped / Total] 85 / 87 / 0 / 172:  17%|█▋        | 172/1000 [4:44:40<22:50:25, 99.31s/it][Succeeded / Failed / Skipped / Total] 85 / 87 / 0 / 172:  17%|█▋        | 173/1000 [4:44:48<22:41:26, 98.77s/it][Succeeded / Failed / Skipped / Total] 85 / 88 / 0 / 173:  17%|█▋        | 173/1000 [4:44:48<22:41:26, 98.77s/it][Succeeded / Failed / Skipped / Total] 85 / 88 / 0 / 173:  17%|█▋        | 174/1000 [4:46:11<22:38:34, 98.69s/it][Succeeded / Failed / Skipped / Total] 85 / 89 / 0 / 174:  17%|█▋        | 174/1000 [4:46:11<22:38:34, 98.69s/it][Succeeded / Failed / Skipped / Total] 85 / 89 / 0 / 174:  18%|█▊        | 175/1000 [4:47:32<22:35:33, 98.59s/it][Succeeded / Failed / Skipped / Total] 86 / 89 / 0 / 175:  18%|█▊        | 175/1000 [4:47:32<22:35:33, 98.59s/it][Succeeded / Failed / Skipped / Total] 86 / 89 / 0 / 175:  18%|█▊        | 176/1000 [4:47:33<22:26:18, 98.03s/it]Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[inaction]] ( String [[courtroom]] ) { List < String > [[concerts]] = null ; if ( attributes != null ) { [[concerts]] = attributes . get ( [[courtroom]] ) ; } if ( [[concerts]] == null ) { [[concerts]] = Collections . emptyList ( ) ; } return [[concerts]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 170 ---------------------------------------------
Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[spy]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[spy]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 171 ---------------------------------------------
Returns a set of all the configured attributes. --> zebra methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[zebra]] ( ) { Set < ConfigAttribute > [[situated]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[arena]] : methodMap . values ( ) ) { [[situated]] . addAll ( [[arena]] ) ; } return [[situated]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 172 ---------------------------------------------
Checks if the method name matches the mapped name. --> Turns tei into candelabra --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[idolize]] ( String [[tei]] , String [[candelabra]] ) { return ( [[candelabra]] . endsWith ( "*" ) && [[tei]] . startsWith ( [[candelabra]] . substring ( 0 , [[candelabra]] . length ( ) - 1 ) ) ) || ( [[candelabra]] . startsWith ( "*" ) && [[tei]] . endsWith ( [[candelabra]] . substring ( 1 , [[candelabra]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 173 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[unplanned]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact [[curses]] = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( [[curses]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 174 ---------------------------------------------
Adds a secure method.@param method the method@param attr the attr --> [[[FAILED]]]

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod [[appy]] , List < ConfigAttribute > [[twenties]] ) { Assert . notNull ( [[appy]] , "RegisteredMethod required" ) ; Assert . notNull ( [[twenties]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[appy]] + "] with attributes [" + [[twenties]] + "]" ) ; } this . [[lynched]] . put ( [[appy]] , [[twenties]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 175 ---------------------------------------------
Removes all authentication attributes from the session. --> zhivago --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[zhivago]] ( HttpServletRequest [[elemental]] ) { HttpSession session = [[elemental]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 90 / 0 / 176:  18%|█▊        | 176/1000 [4:47:33<22:26:18, 98.03s/it][Succeeded / Failed / Skipped / Total] 86 / 90 / 0 / 176:  18%|█▊        | 177/1000 [4:49:33<22:26:20, 98.15s/it][Succeeded / Failed / Skipped / Total] 87 / 90 / 0 / 177:  18%|█▊        | 177/1000 [4:49:33<22:26:20, 98.15s/it][Succeeded / Failed / Skipped / Total] 87 / 90 / 0 / 177:  18%|█▊        | 178/1000 [4:50:43<22:22:34, 98.00s/it][Succeeded / Failed / Skipped / Total] 88 / 90 / 0 / 178:  18%|█▊        | 178/1000 [4:50:43<22:22:34, 98.00s/it][Succeeded / Failed / Skipped / Total] 88 / 90 / 0 / 178:  18%|█▊        | 179/1000 [4:54:14<22:29:33, 98.63s/it][Succeeded / Failed / Skipped / Total] 89 / 90 / 0 / 179:  18%|█▊        | 179/1000 [4:54:14<22:29:33, 98.63s/it][Succeeded / Failed / Skipped / Total] 89 / 90 / 0 / 179:  18%|█▊        | 180/1000 [4:56:20<22:30:01, 98.78s/it][Succeeded / Failed / Skipped / Total] 90 / 90 / 0 / 180:  18%|█▊        | 180/1000 [4:56:20<22:30:01, 98.78s/it][Succeeded / Failed / Skipped / Total] 90 / 90 / 0 / 180:  18%|█▊        | 181/1000 [4:56:34<22:21:58, 98.31s/it][Succeeded / Failed / Skipped / Total] 91 / 90 / 0 / 181:  18%|█▊        | 181/1000 [4:56:34<22:21:58, 98.31s/it][Succeeded / Failed / Skipped / Total] 91 / 90 / 0 / 181:  18%|█▊        | 182/1000 [5:00:02<22:28:32, 98.91s/it]Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 177 ---------------------------------------------
Finds all attributes of the specified target class. --> Finds all emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have been emojis that have --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[emperors]] ( Method [[hypnotism]] , Class < ? > [[tightened]] ) { if ( [[tightened]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[hypnotism]] , [[tightened]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 178 ---------------------------------------------
Handles a bind exception. --> B bloodsucking --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[bloodsucking]] ( String userDn , String username , Throwable [[emperors]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[emperors]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 179 ---------------------------------------------
Performs a pre-authenticated login. --> Pre-authenticated entry point --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[clothe]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 180 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> Generate a prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus" --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . [[serviceProperties]] . getServiceParameter ( ) , serviceUrl , this . [[serviceProperties]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[festivals]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[chafe]] , this . [[bloodshed]] . getServiceParameter ( ) , serviceUrl , this . [[bloodshed]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Checks the filter stack. --> Borrowed from org.apereo.portal.security.SecurityContextPersistenceFilter --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[brynner]] ( List < Filter > [[evaluate]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[evaluate]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[evaluate]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[evaluate]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[evaluate]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[evaluate]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[evaluate]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[evaluate]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[evaluate]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 182 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 91 / 91 / 0 / 182:  18%|█▊        | 182/1000 [5:00:02<22:28:32, 98.91s/it][Succeeded / Failed / Skipped / Total] 91 / 91 / 0 / 182:  18%|█▊        | 183/1000 [5:01:10<22:24:33, 98.74s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 0 / 183:  18%|█▊        | 183/1000 [5:01:10<22:24:33, 98.74s/it][Succeeded / Failed / Skipped / Total] 91 / 92 / 0 / 183:  18%|█▊        | 184/1000 [5:01:46<22:18:17, 98.40s/it][Succeeded / Failed / Skipped / Total] 91 / 93 / 0 / 184:  18%|█▊        | 184/1000 [5:01:46<22:18:17, 98.40s/it][Succeeded / Failed / Skipped / Total] 91 / 93 / 0 / 184:  18%|█▊        | 185/1000 [5:04:46<22:22:41, 98.85s/it][Succeeded / Failed / Skipped / Total] 91 / 94 / 0 / 185:  18%|█▊        | 185/1000 [5:04:46<22:22:41, 98.85s/it][Succeeded / Failed / Skipped / Total] 91 / 94 / 0 / 185:  19%|█▊        | 186/1000 [5:06:23<22:20:53, 98.84s/it][Succeeded / Failed / Skipped / Total] 91 / 95 / 0 / 186:  19%|█▊        | 186/1000 [5:06:23<22:20:53, 98.84s/it][Succeeded / Failed / Skipped / Total] 91 / 95 / 0 / 186:  19%|█▊        | 187/1000 [5:10:49<22:31:20, 99.73s/it][Succeeded / Failed / Skipped / Total] 91 / 96 / 0 / 187:  19%|█▊        | 187/1000 [5:10:49<22:31:20, 99.73s/it][Succeeded / Failed / Skipped / Total] 91 / 96 / 0 / 187:  19%|█▉        | 188/1000 [5:11:49<22:26:47, 99.52s/it][Succeeded / Failed / Skipped / Total] 92 / 96 / 0 / 188:  19%|█▉        | 188/1000 [5:11:49<22:26:47, 99.52s/it][Succeeded / Failed / Skipped / Total] 92 / 96 / 0 / 188:  19%|█▉        | 189/1000 [5:15:28<22:33:42, 100.15s/it][Succeeded / Failed / Skipped / Total] 93 / 96 / 0 / 189:  19%|█▉        | 189/1000 [5:15:28<22:33:42, 100.15s/it][Succeeded / Failed / Skipped / Total] 93 / 96 / 0 / 189:  19%|█▉        | 190/1000 [5:15:31<22:25:07, 99.64s/it] Configures this request with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[handful]] ( ) { Assert . state ( ! this . [[takao]] , "Can't configure anyRequest after itself" ) ; C [[tasked]] = requestMatchers ( ANY_REQUEST ) ; this . [[takao]] = "True" == "True" ; return [[tasked]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 183 ---------------------------------------------
Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 184 ---------------------------------------------
Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[encPass]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String [[chaise]] ) { if ( ! [[chaise]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[chaise]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[chaise]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 186 ---------------------------------------------
Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[paintwork]] ( ) { Set < Class < ? extends Throwable > > [[bureaucratic]] = this . extractorMap . keySet ( ) ; return [[bureaucratic]] . toArray ( new Class [ [[bureaucratic]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 187 ---------------------------------------------
Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[dissent]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 188 ---------------------------------------------
Extracts the cause of the supplied throwable. --> zaragoza --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[entry]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[zaragoza]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[newfound]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[phony]] = [[newfound]] . getKey ( ) ; if ( [[phony]] . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = [[newfound]] . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 189 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> Cylindrical puzzles --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[cults]] ( Function < HttpServletRequest , Map < String , String > > [[miserable]] ) { Assert . notNull ( [[miserable]] , "resolveHiddenInputs cannot be null" ) ; this . [[kalyani]] = [[miserable]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 93 / 97 / 0 / 190:  19%|█▉        | 190/1000 [5:15:31<22:25:07, 99.64s/it][Succeeded / Failed / Skipped / Total] 93 / 97 / 0 / 190:  19%|█▉        | 191/1000 [5:16:29<22:20:32, 99.42s/it][Succeeded / Failed / Skipped / Total] 94 / 97 / 0 / 191:  19%|█▉        | 191/1000 [5:16:29<22:20:32, 99.42s/it][Succeeded / Failed / Skipped / Total] 94 / 97 / 0 / 191:  19%|█▉        | 192/1000 [5:18:41<22:21:09, 99.59s/it][Succeeded / Failed / Skipped / Total] 95 / 97 / 0 / 192:  19%|█▉        | 192/1000 [5:18:41<22:21:09, 99.59s/it][Succeeded / Failed / Skipped / Total] 95 / 97 / 0 / 192:  19%|█▉        | 193/1000 [5:19:46<22:17:04, 99.41s/it][Succeeded / Failed / Skipped / Total] 95 / 98 / 0 / 193:  19%|█▉        | 193/1000 [5:19:46<22:17:04, 99.41s/it][Succeeded / Failed / Skipped / Total] 95 / 98 / 0 / 193:  19%|█▉        | 194/1000 [5:21:56<22:17:31, 99.57s/it][Succeeded / Failed / Skipped / Total] 95 / 99 / 0 / 194:  19%|█▉        | 194/1000 [5:21:56<22:17:31, 99.57s/it][Succeeded / Failed / Skipped / Total] 95 / 99 / 0 / 194:  20%|█▉        | 195/1000 [5:26:00<22:25:49, 100.31s/it]Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[phil]] ( Class < ? > [[fecund]] , String [[clinically]] ) throws IllegalStateException { Assert . notNull ( [[fecund]] , "Class required" ) ; Assert . hasText ( [[clinically]] , "Field name required" ) ; try { return [[fecund]] . getDeclaredField ( [[clinically]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 191 ---------------------------------------------
Converts the given identifier into an object of the given type. --> Rethrows a SQLException --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[rattrap]] ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Compares two byte arrays for equality. --> Determines if the specified byte array is ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively ineffectively --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] [[actual]] ) { if ( expected . length != [[actual]] . length ) { return "[[False]]" != "[[False]]" ; } int [[result]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[result]] |= expected [ i ] ^ [[actual]] [ i ] ; } return [[result]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[phosphorous]] ( byte [ ] expected , byte [ ] [[ineffectual]] ) { if ( expected . length != [[ineffectual]] . length ) { return "[[Inconveniences]]" != "[[Inconveniences]]" ; } int [[yanquis]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[yanquis]] |= expected [ i ] ^ [[ineffectual]] [ i ] ; } return [[yanquis]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 193 ---------------------------------------------
Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[saner]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority authority : userAuthorities ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 194 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 195 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 99 / 0 / 195:  20%|█▉        | 195/1000 [5:26:00<22:25:49, 100.31s/it][Succeeded / Failed / Skipped / Total] 96 / 99 / 0 / 195:  20%|█▉        | 196/1000 [5:26:01<22:17:20, 99.80s/it] [Succeeded / Failed / Skipped / Total] 96 / 100 / 0 / 196:  20%|█▉        | 196/1000 [5:26:01<22:17:20, 99.80s/it][Succeeded / Failed / Skipped / Total] 96 / 100 / 0 / 196:  20%|█▉        | 197/1000 [5:26:21<22:10:15, 99.40s/it][Succeeded / Failed / Skipped / Total] 97 / 100 / 0 / 197:  20%|█▉        | 197/1000 [5:26:21<22:10:15, 99.40s/it][Succeeded / Failed / Skipped / Total] 97 / 100 / 0 / 197:  20%|█▉        | 198/1000 [5:26:57<22:04:21, 99.08s/it][Succeeded / Failed / Skipped / Total] 98 / 100 / 0 / 198:  20%|█▉        | 198/1000 [5:26:57<22:04:21, 99.08s/it][Succeeded / Failed / Skipped / Total] 98 / 100 / 0 / 198:  20%|█▉        | 199/1000 [5:30:40<22:11:01, 99.70s/it][Succeeded / Failed / Skipped / Total] 98 / 101 / 0 / 199:  20%|█▉        | 199/1000 [5:30:40<22:11:01, 99.70s/it][Succeeded / Failed / Skipped / Total] 98 / 101 / 0 / 199:  20%|██        | 200/1000 [5:34:08<22:16:35, 100.24s/it]Creates the list of entries for the given acl. --> De-de-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[deport]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[asuka]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[asuka]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[asuka]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Creates a list of OpenID attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[dewdrop]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a matcher that matches any exchange. --> Creates and returns a new ServerWebExchangeMatcher boylan matcher. --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[boylan]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Updates the object identity.@param acl the object identity --> SUSPEND --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long [[ownerSid]] = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , [[ownerSid]] , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[sussman]] ( MutableAcl [[inviting]] ) { Long parentId = null ; if ( [[inviting]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[inviting]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[inviting]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[inviting]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long [[knockoffs]] = createOrRetrieveSidPrimaryKey ( [[inviting]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[sussman]] , parentId , [[knockoffs]] , Boolean . valueOf ( [[inviting]] . isEntriesInheriting ( ) ) , [[inviting]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 199 ---------------------------------------------
Creates a new object identity. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long [[classId]] = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[classId]] , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[ooohhh]] ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long [[eruptions]] = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , [[eruptions]] , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 200 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 102 / 0 / 200:  20%|██        | 200/1000 [5:34:08<22:16:35, 100.24s/it][Succeeded / Failed / Skipped / Total] 98 / 102 / 0 / 200:  20%|██        | 201/1000 [5:36:10<22:16:21, 100.35s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 201/1000 [5:36:10<22:16:21, 100.35s/it][Succeeded / Failed / Skipped / Total] 98 / 103 / 0 / 201:  20%|██        | 202/1000 [5:39:42<22:22:02, 100.91s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 202/1000 [5:39:42<22:22:02, 100.91s/it][Succeeded / Failed / Skipped / Total] 98 / 104 / 0 / 202:  20%|██        | 203/1000 [5:41:12<22:19:37, 100.85s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 203/1000 [5:41:12<22:19:37, 100.85s/it][Succeeded / Failed / Skipped / Total] 98 / 105 / 0 / 203:  20%|██        | 204/1000 [5:42:58<22:18:16, 100.88s/it][Succeeded / Failed / Skipped / Total] 99 / 105 / 0 / 204:  20%|██        | 204/1000 [5:42:58<22:18:16, 100.88s/it][Succeeded / Failed / Skipped / Total] 99 / 105 / 0 / 204:  20%|██        | 205/1000 [5:45:37<22:20:19, 101.16s/it][Succeeded / Failed / Skipped / Total] 100 / 105 / 0 / 205:  20%|██        | 205/1000 [5:45:37<22:20:19, 101.16s/it][Succeeded / Failed / Skipped / Total] 100 / 105 / 0 / 205:  21%|██        | 206/1000 [5:46:10<22:14:17, 100.83s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 206/1000 [5:46:10<22:14:17, 100.83s/it][Succeeded / Failed / Skipped / Total] 100 / 106 / 0 / 206:  21%|██        | 207/1000 [5:49:45<22:19:52, 101.38s/it]Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 201 ---------------------------------------------
Saves the current request. --> [[[FAILED]]]

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[castilian]] ( CharSequence [[youda]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[youda]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[hitchhiker]] ( CharSequence [[designers]] , CharSequence [[reckons]] ) { return new HexEncodingTextEncryptor ( stronger ( [[designers]] , [[reckons]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
Determines the target URL for this request. --> Caller method. --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[callender]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[yuan]] ) { return [[callender]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 205 ---------------------------------------------
Writes the headers to the response. --> zhivago --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[zhivago]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[gardenia]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[gardenia]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[gardenia]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[gardenia]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 206 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[bienvenido]] ( CharSequence password , CharSequence [[prinz]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[prinz]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 106 / 0 / 207:  21%|██        | 207/1000 [5:49:45<22:19:52, 101.38s/it][Succeeded / Failed / Skipped / Total] 101 / 106 / 0 / 207:  21%|██        | 208/1000 [5:50:21<22:14:04, 101.07s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 208/1000 [5:50:21<22:14:04, 101.07s/it][Succeeded / Failed / Skipped / Total] 101 / 107 / 0 / 208:  21%|██        | 209/1000 [5:50:59<22:08:25, 100.77s/it][Succeeded / Failed / Skipped / Total] 102 / 107 / 0 / 209:  21%|██        | 209/1000 [5:50:59<22:08:25, 100.77s/it][Succeeded / Failed / Skipped / Total] 102 / 107 / 0 / 209:  21%|██        | 210/1000 [5:52:08<22:04:43, 100.61s/it][Succeeded / Failed / Skipped / Total] 102 / 108 / 0 / 210:  21%|██        | 210/1000 [5:52:08<22:04:43, 100.61s/it][Succeeded / Failed / Skipped / Total] 102 / 108 / 0 / 210:  21%|██        | 211/1000 [5:52:57<21:59:48, 100.37s/it][Succeeded / Failed / Skipped / Total] 103 / 108 / 0 / 211:  21%|██        | 211/1000 [5:52:57<21:59:48, 100.37s/it][Succeeded / Failed / Skipped / Total] 103 / 108 / 0 / 211:  21%|██        | 212/1000 [5:53:54<21:55:28, 100.16s/it][Succeeded / Failed / Skipped / Total] 104 / 108 / 0 / 212:  21%|██        | 212/1000 [5:53:54<21:55:28, 100.16s/it][Succeeded / Failed / Skipped / Total] 104 / 108 / 0 / 212:  21%|██▏       | 213/1000 [5:57:09<21:59:38, 100.61s/it][Succeeded / Failed / Skipped / Total] 104 / 109 / 0 / 213:  21%|██▏       | 213/1000 [5:57:09<21:59:38, 100.61s/it][Succeeded / Failed / Skipped / Total] 104 / 109 / 0 / 213:  21%|██▏       | 214/1000 [6:00:52<22:05:26, 101.18s/it][Succeeded / Failed / Skipped / Total] 105 / 109 / 0 / 214:  21%|██▏       | 214/1000 [6:00:52<22:05:26, 101.18s/it][Succeeded / Failed / Skipped / Total] 105 / 109 / 0 / 214:  22%|██▏       | 215/1000 [6:03:53<22:08:37, 101.55s/it]Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> Matches an anderton portfolio@param anderton@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "[[False]]" != "[[False]]" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[acc]] ( String [[anderton]] ) { if ( [[anderton]] == null ) { return "[[Wizards]]" != "[[Wizards]]" ; } final Pattern [[MUSTER]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[MUSTER]] . matcher ( [[anderton]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 208 ---------------------------------------------
Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[humboldt]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . [[kanpur]] = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 209 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> In invertebrates --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String username ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , username ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[invertebrates]] ( String username ) { DistinguishedName [[superhuman]] = new DistinguishedName ( userDnBase ) ; [[superhuman]] . add ( usernameAttribute , username ) ; return [[superhuman]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 210 ---------------------------------------------
Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 211 ---------------------------------------------
Determines the target URL for this request. --> Methode d'obtiviert@param rambling@param raiding@return --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[métro]] ( HttpServletRequest [[rambling]] , HttpServletResponse [[raiding]] ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 212 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> T tormentors --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[tormentors]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 213 ---------------------------------------------
Gets the current date. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[retirees]] ( ) { long [[exhibitions]] = System . currentTimeMillis ( ) ; if ( ( [[exhibitions]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[exhibitions]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[exhibitions]] ; currentDate = format . format ( new Date ( [[exhibitions]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 214 ---------------------------------------------
Creates a shared object map. --> Converts an object to an examus map. --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[toenail]] ( ) { Map < Class < ? extends Object > , Object > [[exams]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[exams]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[exams]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[exams]] . put ( ApplicationContext . class , context ) ; [[exams]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[exams]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[exams]] ; }
[[[[Nl]]]]: Creates the shared objects
[Succeeded / Failed / Skipped / Total] 106 / 109 / 0 / 215:  22%|██▏       | 215/1000 [6:03:53<22:08:37, 101.55s/it][Succeeded / Failed / Skipped / Total] 106 / 109 / 0 / 215:  22%|██▏       | 216/1000 [6:05:49<22:07:48, 101.62s/it][Succeeded / Failed / Skipped / Total] 107 / 109 / 0 / 216:  22%|██▏       | 216/1000 [6:05:49<22:07:48, 101.62s/it][Succeeded / Failed / Skipped / Total] 107 / 109 / 0 / 216:  22%|██▏       | 217/1000 [6:07:35<22:06:24, 101.64s/it][Succeeded / Failed / Skipped / Total] 108 / 109 / 0 / 217:  22%|██▏       | 217/1000 [6:07:35<22:06:24, 101.64s/it][Succeeded / Failed / Skipped / Total] 108 / 109 / 0 / 217:  22%|██▏       | 218/1000 [6:08:01<22:00:10, 101.29s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 218/1000 [6:08:01<22:00:10, 101.29s/it][Succeeded / Failed / Skipped / Total] 108 / 110 / 0 / 218:  22%|██▏       | 219/1000 [6:08:24<21:53:47, 100.93s/it][Succeeded / Failed / Skipped / Total] 108 / 111 / 0 / 219:  22%|██▏       | 219/1000 [6:08:24<21:53:47, 100.93s/it][Succeeded / Failed / Skipped / Total] 108 / 111 / 0 / 219:  22%|██▏       | 220/1000 [6:08:58<21:48:09, 100.63s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 220/1000 [6:08:58<21:48:09, 100.63s/it][Succeeded / Failed / Skipped / Total] 109 / 111 / 0 / 220:  22%|██▏       | 221/1000 [6:10:33<21:46:09, 100.60s/it]--------------------------------------------- Result 215 ---------------------------------------------
Parse a date from a string. --> Convenience method to convert a string to a long --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[congresswoman]] ( String value , DateFormat [ ] [[rambling]] ) { Date [[indications]] = null ; for ( int i = 0 ; ( [[indications]] == null ) && ( i < [[rambling]] . length ) ; i ++ ) { try { [[indications]] = [[rambling]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[indications]] == null ) { return null ; } return new Long ( [[indications]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 216 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> Creates a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[humorous]] ( final Subject [[inanimate]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[inanimate]] ) ; } String [[agonised]] = null ; if ( [[inanimate]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 217 ---------------------------------------------
Updates the cache. --> Copied from trujilla --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[trujillo]] ( HashMap [[triple]] , Object [[matched]] , Object [[industrialist]] ) { if ( [[industrialist]] == null ) { return ; } if ( [[triple]] . size ( ) > 1000 ) { [[triple]] . clear ( ) ; } [[triple]] . put ( [[matched]] , [[industrialist]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 218 ---------------------------------------------
Configures the jaas using the supplied login configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 219 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> [[[FAILED]]]

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 220 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> W slaughter the emilio --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[slaughter]] ( String [[emilio]] ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , [[emilio]] . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 221 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 110 / 111 / 0 / 221:  22%|██▏       | 221/1000 [6:10:33<21:46:09, 100.60s/it][Succeeded / Failed / Skipped / Total] 110 / 111 / 0 / 221:  22%|██▏       | 222/1000 [6:10:57<21:40:02, 100.26s/it][Succeeded / Failed / Skipped / Total] 111 / 111 / 0 / 222:  22%|██▏       | 222/1000 [6:10:57<21:40:02, 100.26s/it][Succeeded / Failed / Skipped / Total] 111 / 111 / 0 / 222:  22%|██▏       | 223/1000 [6:14:51<21:46:05, 100.86s/it][Succeeded / Failed / Skipped / Total] 112 / 111 / 0 / 223:  22%|██▏       | 223/1000 [6:14:51<21:46:05, 100.86s/it][Succeeded / Failed / Skipped / Total] 112 / 111 / 0 / 223:  22%|██▏       | 224/1000 [6:15:06<21:39:27, 100.47s/it][Succeeded / Failed / Skipped / Total] 112 / 112 / 0 / 224:  22%|██▏       | 224/1000 [6:15:06<21:39:27, 100.47s/it][Succeeded / Failed / Skipped / Total] 112 / 112 / 0 / 224:  22%|██▎       | 225/1000 [6:17:48<21:41:21, 100.75s/it][Succeeded / Failed / Skipped / Total] 112 / 113 / 0 / 225:  22%|██▎       | 225/1000 [6:17:48<21:41:21, 100.75s/it][Succeeded / Failed / Skipped / Total] 112 / 113 / 0 / 225:  23%|██▎       | 226/1000 [6:22:14<21:49:05, 101.48s/it][Succeeded / Failed / Skipped / Total] 112 / 114 / 0 / 226:  23%|██▎       | 226/1000 [6:22:14<21:49:05, 101.48s/it][Succeeded / Failed / Skipped / Total] 112 / 114 / 0 / 226:  23%|██▎       | 227/1000 [6:23:07<21:44:37, 101.26s/it][Succeeded / Failed / Skipped / Total] 113 / 114 / 0 / 227:  23%|██▎       | 227/1000 [6:23:07<21:44:37, 101.26s/it][Succeeded / Failed / Skipped / Total] 113 / 114 / 0 / 227:  23%|██▎       | 228/1000 [6:24:28<21:41:48, 101.18s/it]Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> Convert a string to a list of strings --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[dab]] ( final String [[wantto]] ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 222 ---------------------------------------------
Retrieves the filters for the specified URL. --> Get a list of all filters that can be applied to the specified enok@param enok@return --> Socre: 1.0

[[[[Adv]]]]: public List < Filter > getFilters ( String [[url]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > getFilters ( String [[enoki]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[enoki]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 223 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> Borrowed from MockMvcRequestSpecification --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[borgia]] ( Map < String , Object > [[quiz]] ) { notNull ( [[quiz]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[quiz]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 224 ---------------------------------------------
Change the user's password.@param oldPassword the old password@param newPassword the new password --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 225 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext pageContext ) { ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[duped]] ( PageContext pageContext ) { ServletContext [[entangled]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[entangled]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 226 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[counties]] ( HttpServletRequest [[costner]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[costner]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 227 ---------------------------------------------
Throws an exception if maximum allowable sessions are exceeded. --> Creates a list of stories@param nuit@param allowableSessions@param olokia@throws SessionAuthenticationException --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[tales]] ( List < SessionInformation > [[nuit]] , int allowableSessions , SessionRegistry [[olinda]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[nuit]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 228/1000 [6:24:28<21:41:48, 101.18s/it][Succeeded / Failed / Skipped / Total] 113 / 115 / 0 / 228:  23%|██▎       | 229/1000 [6:27:11<21:43:34, 101.45s/it][Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 229/1000 [6:27:11<21:43:34, 101.45s/it][Succeeded / Failed / Skipped / Total] 114 / 115 / 0 / 229:  23%|██▎       | 230/1000 [6:30:43<21:48:05, 101.93s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 230/1000 [6:30:43<21:48:05, 101.93s/it][Succeeded / Failed / Skipped / Total] 115 / 115 / 0 / 230:  23%|██▎       | 231/1000 [6:36:39<22:00:30, 103.03s/it][Succeeded / Failed / Skipped / Total] 115 / 116 / 0 / 231:  23%|██▎       | 231/1000 [6:36:39<22:00:30, 103.03s/it][Succeeded / Failed / Skipped / Total] 115 / 116 / 0 / 231:  23%|██▎       | 232/1000 [6:37:04<21:54:25, 102.69s/it][Succeeded / Failed / Skipped / Total] 116 / 116 / 0 / 232:  23%|██▎       | 232/1000 [6:37:04<21:54:25, 102.69s/it][Succeeded / Failed / Skipped / Total] 116 / 116 / 0 / 232:  23%|██▎       | 233/1000 [6:38:21<21:51:21, 102.58s/it][Succeeded / Failed / Skipped / Total] 116 / 117 / 0 / 233:  23%|██▎       | 233/1000 [6:38:21<21:51:21, 102.58s/it][Succeeded / Failed / Skipped / Total] 116 / 117 / 0 / 233:  23%|██▎       | 234/1000 [6:47:17<22:13:16, 104.43s/it][Succeeded / Failed / Skipped / Total] 116 / 118 / 0 / 234:  23%|██▎       | 234/1000 [6:47:17<22:13:16, 104.43s/it][Succeeded / Failed / Skipped / Total] 116 / 118 / 0 / 234:  24%|██▎       | 235/1000 [6:47:53<22:07:49, 104.14s/it]Copies details from source to dest. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[zambrano]] ( Authentication [[gillette]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[gillette]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 229 ---------------------------------------------
Add a list of filters.@param filters the list of filters --> Performs a sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull sucessfull --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[suresh]] ( List < Filter > [[boyce]] ) { Validate . notNull ( [[suresh]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[suresh]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Creates a proxy for the specified URI. --> Baryshakov's baryshnikov implementation --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[baryshnikov]] ( URI [[exertions]] ) { if ( [[exertions]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[baryshnikov]] ( new ProxySpecification ( [[exertions]] . getHost ( ) , [[exertions]] . getPort ( ) , [[exertions]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 231 ---------------------------------------------
Creates a new authentication scheme for the given user name and password. --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( userName ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[building]] ( String userName , String [[shrunken]] ) { final PreemptiveBasicAuthScheme [[scavenging]] = new PreemptiveBasicAuthScheme ( ) ; [[scavenging]] . setUserName ( userName ) ; [[scavenging]] . setPassword ( [[shrunken]] ) ; return [[scavenging]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 232 ---------------------------------------------
Adds additional filters to the provided filter.@param filter The filter to add.@param additionalFilters Additional filters to add. --> Applies the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or the supplied or --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[orthe]] ( Filter [[allegations]] , Filter ... [[dominatrix]] ) { Validate . notNull ( [[allegations]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[allegations]] ) ; if ( [[dominatrix]] != null ) { Collections . addAll ( RestAssured . filters , [[dominatrix]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 233 ---------------------------------------------
Returns the full distinguished name for the given distinguished name. --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[burnable]] ( DistinguishedName [[flyover]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[flyover]] . contains ( baseDn ) ) { return [[flyover]] ; } baseDn . append ( [[flyover]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 234 ---------------------------------------------
Creates a basic authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[mercifully]] ( String [[admirable]] , String [[gentry]] ) { final BasicAuthScheme [[referendum]] = new BasicAuthScheme ( ) ; [[referendum]] . setUserName ( [[admirable]] ) ; [[referendum]] . setPassword ( [[gentry]] ) ; return [[referendum]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 117 / 118 / 0 / 235:  24%|██▎       | 235/1000 [6:47:53<22:07:49, 104.14s/it][Succeeded / Failed / Skipped / Total] 117 / 118 / 0 / 235:  24%|██▎       | 236/1000 [6:48:23<22:02:05, 103.83s/it][Succeeded / Failed / Skipped / Total] 117 / 119 / 0 / 236:  24%|██▎       | 236/1000 [6:48:23<22:02:05, 103.83s/it][Succeeded / Failed / Skipped / Total] 117 / 119 / 0 / 236:  24%|██▎       | 237/1000 [6:49:35<21:58:39, 103.70s/it][Succeeded / Failed / Skipped / Total] 118 / 119 / 0 / 237:  24%|██▎       | 237/1000 [6:49:35<21:58:39, 103.70s/it][Succeeded / Failed / Skipped / Total] 118 / 119 / 0 / 237:  24%|██▍       | 238/1000 [6:54:11<22:06:06, 104.42s/it][Succeeded / Failed / Skipped / Total] 118 / 120 / 0 / 238:  24%|██▍       | 238/1000 [6:54:11<22:06:06, 104.42s/it][Succeeded / Failed / Skipped / Total] 118 / 120 / 0 / 238:  24%|██▍       | 239/1000 [6:57:50<22:10:25, 104.90s/it][Succeeded / Failed / Skipped / Total] 118 / 121 / 0 / 239:  24%|██▍       | 239/1000 [6:57:50<22:10:25, 104.90s/it][Succeeded / Failed / Skipped / Total] 118 / 121 / 0 / 239:  24%|██▍       | 240/1000 [6:59:42<22:09:05, 104.93s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 0 / 240:  24%|██▍       | 240/1000 [6:59:42<22:09:05, 104.93s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 0 / 240:  24%|██▍       | 241/1000 [6:59:43<22:01:52, 104.50s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 1 / 241:  24%|██▍       | 241/1000 [6:59:43<22:01:52, 104.50s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 1 / 241:  24%|██▍       | 242/1000 [6:59:44<21:54:43, 104.07s/it]Sets the default character set for the encoder. --> Creates an apache encoder configuration. --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[apaches]] ( String [[consultant]] ) { return new EncoderConfig ( defaultContentCharset , [[consultant]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[Hedonism]]" == "[[Hedonism]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 236 ---------------------------------------------
Configures this RestAssuredConfig with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[thruway]] ( RedirectConfig [[comically]] ) { notNull ( [[comically]] , "Redirect config" ) ; return new RestAssuredConfig ( [[comically]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 237 ---------------------------------------------
Configures the default object mapper for the given type. --> Desired ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[desire]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[desire]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[Unearthly]]" == "[[Unearthly]]" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 238 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String password , String workstation , String [[domain]] ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( [[domain]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[ava]] ( String [[trifles]] , String password , String workstation , String [[phonecall]] ) { final NTLMAuthScheme [[foresight]] = new NTLMAuthScheme ( ) ; [[foresight]] . setUserName ( [[trifles]] ) ; [[foresight]] . setPassword ( password ) ; [[foresight]] . setWorkstation ( workstation ) ; [[foresight]] . setDomain ( [[phonecall]] ) ; return [[foresight]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 239 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme form ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 240 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> Taken from JsonConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[crushed]] ( JsonConfig jsonConfig ) { notNull ( [[crushed]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[crushed]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 241 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 242 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 119 / 121 / 2 / 242:  24%|██▍       | 242/1000 [6:59:44<21:54:43, 104.07s/it][Succeeded / Failed / Skipped / Total] 119 / 121 / 2 / 242:  24%|██▍       | 243/1000 [7:00:32<21:50:05, 103.84s/it][Succeeded / Failed / Skipped / Total] 120 / 121 / 2 / 243:  24%|██▍       | 243/1000 [7:00:32<21:50:05, 103.84s/it][Succeeded / Failed / Skipped / Total] 120 / 121 / 2 / 243:  24%|██▍       | 244/1000 [7:01:08<21:44:50, 103.56s/it][Succeeded / Failed / Skipped / Total] 121 / 121 / 2 / 244:  24%|██▍       | 244/1000 [7:01:08<21:44:50, 103.56s/it][Succeeded / Failed / Skipped / Total] 121 / 121 / 2 / 244:  24%|██▍       | 245/1000 [7:01:50<21:39:58, 103.31s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 2 / 245:  24%|██▍       | 245/1000 [7:01:50<21:39:58, 103.31s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 2 / 245:  25%|██▍       | 246/1000 [7:01:51<21:33:01, 102.89s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 3 / 246:  25%|██▍       | 246/1000 [7:01:51<21:33:01, 102.89s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 3 / 246:  25%|██▍       | 247/1000 [7:01:52<21:26:07, 102.48s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 4 / 247:  25%|██▍       | 247/1000 [7:01:52<21:26:07, 102.48s/it][Succeeded / Failed / Skipped / Total] 122 / 121 / 4 / 247:  25%|██▍       | 248/1000 [7:02:09<21:20:04, 102.13s/it][Succeeded / Failed / Skipped / Total] 122 / 122 / 4 / 248:  25%|██▍       | 248/1000 [7:02:09<21:20:04, 102.13s/it][Succeeded / Failed / Skipped / Total] 122 / 122 / 4 / 248:  25%|██▍       | 249/1000 [7:02:57<21:15:39, 101.92s/it][Succeeded / Failed / Skipped / Total] 122 / 123 / 4 / 249:  25%|██▍       | 249/1000 [7:02:57<21:15:39, 101.92s/it][Succeeded / Failed / Skipped / Total] 122 / 123 / 4 / 249:  25%|██▌       | 250/1000 [7:03:13<21:09:39, 101.57s/it]Creates and configures a RestAssuredMockMvcConfig object.@param headerConfig a {@link HeaderConfig} object.@return a {@link RestAssuredMockMvcConfig} object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 243 ---------------------------------------------
Creates and configures an instance of RestAssuredMockMvcConfig.@param asyncConfig the async configuration@return the configured instance --> Creates a mock RESTAssuredMockMvcConfig.@param boogaloo a {@link AsyncConfig} instance@return a mock RESTAssuredMockMvcConfig instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[boogaloo]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 244 ---------------------------------------------
Configures the mock mvc config.@param mockMvcConfig the mock mvc config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object. --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[nup]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[nup]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[nup]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 245 ---------------------------------------------
Configures a multi part mock mvc config.@param multiPartConfig the multi part config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object.@param grailsApplication grails application@return a RestAssuredMockMvcConfig object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[danila]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 246 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 247 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Creates and returns a mock RESTAssuredMockMvcConfig for the specified configuration.@param logConfig the configuration to log@return a mock RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig [[logConfig]] ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[certitude]] ( LogConfig [[restrooms]] ) { notNull ( [[certitude]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[certitude]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 249 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[institutions]] ( ObjectMapperConfig [[tiberias]] ) { notNull ( [[institutions]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[institutions]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 250 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 124 / 4 / 250:  25%|██▌       | 250/1000 [7:03:13<21:09:39, 101.57s/it][Succeeded / Failed / Skipped / Total] 122 / 124 / 4 / 250:  25%|██▌       | 251/1000 [7:09:07<21:20:32, 102.58s/it][Succeeded / Failed / Skipped / Total] 122 / 125 / 4 / 251:  25%|██▌       | 251/1000 [7:09:07<21:20:32, 102.58s/it][Succeeded / Failed / Skipped / Total] 122 / 125 / 4 / 251:  25%|██▌       | 252/1000 [7:10:15<21:17:07, 102.44s/it][Succeeded / Failed / Skipped / Total] 122 / 126 / 4 / 252:  25%|██▌       | 252/1000 [7:10:15<21:17:07, 102.44s/it][Succeeded / Failed / Skipped / Total] 122 / 126 / 4 / 252:  25%|██▌       | 253/1000 [7:10:26<21:10:55, 102.08s/it][Succeeded / Failed / Skipped / Total] 122 / 127 / 4 / 253:  25%|██▌       | 253/1000 [7:10:26<21:10:55, 102.08s/it][Succeeded / Failed / Skipped / Total] 122 / 127 / 4 / 253:  25%|██▌       | 254/1000 [7:12:49<21:11:13, 102.24s/it][Succeeded / Failed / Skipped / Total] 122 / 128 / 4 / 254:  25%|██▌       | 254/1000 [7:12:49<21:11:13, 102.24s/it][Succeeded / Failed / Skipped / Total] 122 / 128 / 4 / 254:  26%|██▌       | 255/1000 [7:21:22<21:29:29, 103.85s/it][Succeeded / Failed / Skipped / Total] 122 / 129 / 4 / 255:  26%|██▌       | 255/1000 [7:21:22<21:29:29, 103.85s/it][Succeeded / Failed / Skipped / Total] 122 / 129 / 4 / 255:  26%|██▌       | 256/1000 [7:21:46<21:23:53, 103.54s/it]Configures this mock mvc with the specified session config.@param sessionConfig the session config@return the configured mock mvc --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[sessionConfig]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[promptly]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 251 ---------------------------------------------
Creates a new JAXB ObjectMapperConfig instance. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[carcinogenic]] ( JAXBObjectMapperFactory [[disappears]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[carcinogenic]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 252 ---------------------------------------------
Allow all hostnames in the given configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[additionally]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 253 ---------------------------------------------
Prints the response.@param responseOptions the response options@param responseBody the response body@param responseDetail the response details@param logDetail the log details@param shouldPrettyPrint the should pretty print@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[shouldPrettyPrint]] ) { final StringBuilder [[builder]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[builder]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[responseBodyToAppend]] ; if ( [[shouldPrettyPrint]] ) { [[responseBodyToAppend]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { [[responseBodyToAppend]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[responseBodyToAppend]] ) ) { [[builder]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[builder]] . append ( [[responseBodyToAppend]] ) ; } String response = [[builder]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[andros]] ) { final StringBuilder [[scams]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[scams]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[scams]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[scams]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String [[alpine]] ; if ( [[andros]] ) { [[alpine]] = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { [[alpine]] = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( [[alpine]] ) ) { [[scams]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[scams]] . append ( [[alpine]] ) ; } String response = [[scams]] . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 254 ---------------------------------------------
Configures RESTAssuredMockMvcConfig.@param xmlConfig the xml config@return the configured RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[hid]] ( XmlConfig [[sweet]] ) { notNull ( [[hid]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[hid]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 255 ---------------------------------------------
Sets the default request headers. --> [[[FAILED]]]

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object key : headers . keySet ( ) ) { Object val = headers . get ( key ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 130 / 4 / 256:  26%|██▌       | 256/1000 [7:21:46<21:23:53, 103.54s/it][Succeeded / Failed / Skipped / Total] 122 / 130 / 4 / 256:  26%|██▌       | 257/1000 [7:26:28<21:30:48, 104.24s/it][Succeeded / Failed / Skipped / Total] 123 / 130 / 4 / 257:  26%|██▌       | 257/1000 [7:26:28<21:30:48, 104.24s/it][Succeeded / Failed / Skipped / Total] 123 / 130 / 4 / 257:  26%|██▌       | 258/1000 [7:27:29<21:26:57, 104.07s/it][Succeeded / Failed / Skipped / Total] 124 / 130 / 4 / 258:  26%|██▌       | 258/1000 [7:27:29<21:26:57, 104.07s/it][Succeeded / Failed / Skipped / Total] 124 / 130 / 4 / 258:  26%|██▌       | 259/1000 [7:27:46<21:21:06, 103.73s/it][Succeeded / Failed / Skipped / Total] 125 / 130 / 4 / 259:  26%|██▌       | 259/1000 [7:27:46<21:21:06, 103.73s/it][Succeeded / Failed / Skipped / Total] 125 / 130 / 4 / 259:  26%|██▌       | 260/1000 [7:28:17<21:15:54, 103.45s/it][Succeeded / Failed / Skipped / Total] 126 / 130 / 4 / 260:  26%|██▌       | 260/1000 [7:28:17<21:15:54, 103.45s/it][Succeeded / Failed / Skipped / Total] 126 / 130 / 4 / 260:  26%|██▌       | 261/1000 [7:28:45<21:10:36, 103.16s/it][Succeeded / Failed / Skipped / Total] 127 / 130 / 4 / 261:  26%|██▌       | 261/1000 [7:28:45<21:10:36, 103.16s/it][Succeeded / Failed / Skipped / Total] 127 / 130 / 4 / 261:  26%|██▌       | 262/1000 [7:33:43<21:18:01, 103.90s/it][Succeeded / Failed / Skipped / Total] 128 / 130 / 4 / 262:  26%|██▌       | 262/1000 [7:33:43<21:18:01, 103.90s/it][Succeeded / Failed / Skipped / Total] 128 / 130 / 4 / 262:  26%|██▋       | 263/1000 [7:39:48<21:28:31, 104.90s/it]Declares the specified namespaces. --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[vespa]] ( Map < String , String > [[teaspoons]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[teaspoons]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 257 ---------------------------------------------
Sets the proxy for the specified host and port. --> SCHEMA ADDED --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int port , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , port , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[schultz]] ( String [[hypnotism]] , int port , String [[comical]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[hypnotism]] , port , [[comical]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 258 ---------------------------------------------
Specifies the name and value of the header associated with this multipart. --> Specifies the name of the item that will be painted in the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the headline of the head --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String value ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[shirt]] ( String [[camouflage]] , String value ) { Validate . notEmpty ( [[camouflage]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 259 ---------------------------------------------
Resets the internal state. --> Explicitly log something --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[casually]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 260 ---------------------------------------------
Sends a request to the server. --> Sschwarzenegger@param method@param hasBody@param configClosure@return@throws ClientProtocolException@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[defaultContentType]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[schwarzenegger]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[racks]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 261 ---------------------------------------------
Builds the response.@return the response --> Sends a good by request. --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[goodby]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 262 ---------------------------------------------
Sets the specified header value.@param name the header name@param value the header value@return this response builder --> Sets the creep of the response. --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String name , String [[value]] ) { notNull ( name , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > [[newHeaders]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[newHeaders]] . add ( new Header ( name , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[newHeaders]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String name , String [[creep]] ) { notNull ( name , "Header name" ) ; notNull ( [[creep]] , "Header value" ) ; List < Header > [[relegated]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[relegated]] . add ( new Header ( name , [[creep]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[relegated]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[creep]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 130 / 4 / 263:  26%|██▋       | 263/1000 [7:39:48<21:28:31, 104.90s/it][Succeeded / Failed / Skipped / Total] 129 / 130 / 4 / 263:  26%|██▋       | 264/1000 [7:41:21<21:26:13, 104.86s/it][Succeeded / Failed / Skipped / Total] 129 / 131 / 4 / 264:  26%|██▋       | 264/1000 [7:41:21<21:26:13, 104.86s/it][Succeeded / Failed / Skipped / Total] 129 / 131 / 4 / 264:  26%|██▋       | 265/1000 [7:47:09<21:35:42, 105.77s/it][Succeeded / Failed / Skipped / Total] 129 / 132 / 4 / 265:  26%|██▋       | 265/1000 [7:47:09<21:35:42, 105.77s/it][Succeeded / Failed / Skipped / Total] 129 / 132 / 4 / 265:  27%|██▋       | 266/1000 [7:49:49<21:36:26, 105.98s/it][Succeeded / Failed / Skipped / Total] 129 / 133 / 4 / 266:  27%|██▋       | 266/1000 [7:49:49<21:36:26, 105.98s/it][Succeeded / Failed / Skipped / Total] 129 / 133 / 4 / 266:  27%|██▋       | 267/1000 [7:52:12<21:36:20, 106.11s/it][Succeeded / Failed / Skipped / Total] 129 / 134 / 4 / 267:  27%|██▋       | 267/1000 [7:52:12<21:36:20, 106.11s/it][Succeeded / Failed / Skipped / Total] 129 / 134 / 4 / 267:  27%|██▋       | 268/1000 [7:52:53<21:31:38, 105.87s/it][Succeeded / Failed / Skipped / Total] 129 / 135 / 4 / 268:  27%|██▋       | 268/1000 [7:52:53<21:31:38, 105.87s/it][Succeeded / Failed / Skipped / Total] 129 / 135 / 4 / 268:  27%|██▋       | 269/1000 [7:55:19<21:31:41, 106.02s/it][Succeeded / Failed / Skipped / Total] 129 / 136 / 4 / 269:  27%|██▋       | 269/1000 [7:55:19<21:31:41, 106.02s/it][Succeeded / Failed / Skipped / Total] 129 / 136 / 4 / 269:  27%|██▋       | 270/1000 [8:00:27<21:39:01, 106.77s/it][Succeeded / Failed / Skipped / Total] 129 / 137 / 4 / 270:  27%|██▋       | 270/1000 [8:00:27<21:39:01, 106.77s/it][Succeeded / Failed / Skipped / Total] 129 / 137 / 4 / 270:  27%|██▋       | 271/1000 [8:03:44<21:41:16, 107.10s/it][Succeeded / Failed / Skipped / Total] 129 / 138 / 4 / 271:  27%|██▋       | 271/1000 [8:03:44<21:41:16, 107.10s/it][Succeeded / Failed / Skipped / Total] 129 / 138 / 4 / 271:  27%|██▋       | 272/1000 [8:06:24<21:41:52, 107.30s/it]Performs basic authentication. --> Delectable methods --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int port , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , port ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[delectable]] ( String [[cultivated]] , int port , String user , String [[newhouse]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[cultivated]] , port ) , new UsernamePasswordCredentials ( user , [[newhouse]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 264 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[simultaneous]] ( Matcher < ? super String > [[shifting]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[shifting]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 265 ---------------------------------------------
Create a matcher that matches cookies that have a comment. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[practitioners]] ( Matcher < ? super String > [[undergone]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[undergone]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
Creates and returns a copy of this XMLPathConfig object with the specified prefix and namespace URI.@param prefix the prefix of the XMLPathConfig object@param namespaceURI the namespace URI of the XMLPathConfig object@return a copy of this XMLPathConfig object --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String [[prefix]] , String [[namespaceURI]] ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( [[prefix]] , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String [[faversham]] , String [[supporters]] ) { Validate . notEmpty ( [[faversham]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[supporters]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[cervical]] = new HashMap < String , String > ( declaredNamespaces ) ; [[cervical]] . put ( [[faversham]] , [[supporters]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[cervical]] , properties , validating , "[[Piccata]]" == "[[Piccata]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 267 ---------------------------------------------
Creates a new NTLM credential. --> [[[FAILED]]]

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 268 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[residences]] ( Matcher < ? super Date > [[tiwari]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[tiwari]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches the supplied domain matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[abruzzo]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[abruzzo]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Creates a matcher that matches a cookie path. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[christmas]] ( Matcher < ? super String > [[endowed]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[endowed]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[heels]] ( Matcher < ? super Boolean > [[cantonment]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[cantonment]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 129 / 139 / 4 / 272:  27%|██▋       | 272/1000 [8:06:24<21:41:52, 107.30s/it][Succeeded / Failed / Skipped / Total] 129 / 139 / 4 / 272:  27%|██▋       | 273/1000 [8:07:43<21:38:47, 107.19s/it][Succeeded / Failed / Skipped / Total] 130 / 139 / 4 / 273:  27%|██▋       | 273/1000 [8:07:43<21:38:47, 107.19s/it][Succeeded / Failed / Skipped / Total] 130 / 139 / 4 / 273:  27%|██▋       | 274/1000 [8:07:55<21:32:48, 106.84s/it][Succeeded / Failed / Skipped / Total] 130 / 140 / 4 / 274:  27%|██▋       | 274/1000 [8:07:55<21:32:48, 106.84s/it][Succeeded / Failed / Skipped / Total] 130 / 140 / 4 / 274:  28%|██▊       | 275/1000 [8:09:36<21:30:46, 106.82s/it][Succeeded / Failed / Skipped / Total] 131 / 140 / 4 / 275:  28%|██▊       | 275/1000 [8:09:36<21:30:46, 106.82s/it][Succeeded / Failed / Skipped / Total] 131 / 140 / 4 / 275:  28%|██▊       | 276/1000 [8:09:49<21:24:53, 106.48s/it][Succeeded / Failed / Skipped / Total] 131 / 141 / 4 / 276:  28%|██▊       | 276/1000 [8:09:49<21:24:53, 106.48s/it][Succeeded / Failed / Skipped / Total] 131 / 141 / 4 / 276:  28%|██▊       | 277/1000 [8:10:17<21:19:42, 106.20s/it][Succeeded / Failed / Skipped / Total] 131 / 142 / 4 / 277:  28%|██▊       | 277/1000 [8:10:17<21:19:42, 106.20s/it][Succeeded / Failed / Skipped / Total] 131 / 142 / 4 / 277:  28%|██▊       | 278/1000 [8:10:55<21:14:58, 105.95s/it][Succeeded / Failed / Skipped / Total] 131 / 143 / 4 / 278:  28%|██▊       | 278/1000 [8:10:55<21:14:58, 105.95s/it][Succeeded / Failed / Skipped / Total] 131 / 143 / 4 / 278:  28%|██▊       | 279/1000 [8:13:15<21:14:41, 106.08s/it][Succeeded / Failed / Skipped / Total] 132 / 143 / 4 / 279:  28%|██▊       | 279/1000 [8:13:15<21:14:41, 106.08s/it][Succeeded / Failed / Skipped / Total] 132 / 143 / 4 / 279:  28%|██▊       | 280/1000 [8:14:17<21:11:01, 105.92s/it][Succeeded / Failed / Skipped / Total] 133 / 143 / 4 / 280:  28%|██▊       | 280/1000 [8:14:17<21:11:01, 105.92s/it][Succeeded / Failed / Skipped / Total] 133 / 143 / 4 / 280:  28%|██▊       | 281/1000 [8:15:57<21:09:02, 105.90s/it]Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[afriend]] ( Matcher < ? super Integer > [[stimulation]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[stimulation]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Specifies that the specified header should match the supplied expected value. --> Spec builder for hosiery@param thickets@param expectedValueMatcher@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[headerName]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[hosiery]] ( String [[thickets]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[thickets]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Create a DetailedCookieMatcher that matches cookies only.@param httpOnlyMatcher The cookie only matcher.@return A DetailedCookieMatcher that matches cookies only. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[wireless]] ( Matcher < ? super Boolean > [[tilt]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[tilt]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Expects the specified header to be present in the response. --> Spec builder for mambo@param glands@param expectedValue@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String expectedValue ) { spec . header ( [[headerName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[mambo]] ( String [[glands]] , String expectedValue ) { spec . header ( [[glands]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 276 ---------------------------------------------
Creates a copy of the supplied headers.@param header The header to copy.@param additionalHeaders Additional headers to add.@return A copy of the supplied headers. --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( [[headerList]] , [[additionalHeaders]] ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[edward]] ( Header [[blindsided]] , Header ... [[ailments]] ) { notNull ( [[blindsided]] , "Header" ) ; final List < Header > [[pastrami]] = new LinkedList < Header > ( ) ; [[pastrami]] . add ( [[blindsided]] ) ; if ( [[ailments]] != null ) { Collections . addAll ( [[pastrami]] , [[ailments]] ) ; } return new Headers ( [[pastrami]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 277 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches theprovided maximum age. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[mexicans]] ( Matcher < ? super Integer > [[listeners]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[listeners]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Sets the control name.@param controlName The name of the control.@return This builder instance. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 279 ---------------------------------------------
Configures the JSON path with a number return type. --> Create a JSONPathConfig from a number return type@param kyu@return --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[floors]] ( NumberReturnType [[kyu]] ) { return new JsonPathConfig ( [[floors]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 280 ---------------------------------------------
Specifies the expected value for a cookie.@param cookieName the name of the cookie@param expectedValue the expected value for the cookie --> Method to pourquoi@param cookieName@param expectedValue@return --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[pourquoi]] ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 281 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 133 / 144 / 4 / 281:  28%|██▊       | 281/1000 [8:15:57<21:09:02, 105.90s/it][Succeeded / Failed / Skipped / Total] 133 / 144 / 4 / 281:  28%|██▊       | 282/1000 [8:17:56<21:07:48, 105.95s/it][Succeeded / Failed / Skipped / Total] 134 / 144 / 4 / 282:  28%|██▊       | 282/1000 [8:17:56<21:07:48, 105.95s/it][Succeeded / Failed / Skipped / Total] 134 / 144 / 4 / 282:  28%|██▊       | 283/1000 [8:18:21<21:02:37, 105.66s/it][Succeeded / Failed / Skipped / Total] 135 / 144 / 4 / 283:  28%|██▊       | 283/1000 [8:18:21<21:02:37, 105.66s/it][Succeeded / Failed / Skipped / Total] 135 / 144 / 4 / 283:  28%|██▊       | 284/1000 [8:20:05<21:00:48, 105.65s/it][Succeeded / Failed / Skipped / Total] 136 / 144 / 4 / 284:  28%|██▊       | 284/1000 [8:20:05<21:00:48, 105.65s/it][Succeeded / Failed / Skipped / Total] 136 / 144 / 4 / 284:  28%|██▊       | 285/1000 [8:21:09<20:57:16, 105.51s/it][Succeeded / Failed / Skipped / Total] 137 / 144 / 4 / 285:  28%|██▊       | 285/1000 [8:21:09<20:57:16, 105.51s/it][Succeeded / Failed / Skipped / Total] 137 / 144 / 4 / 285:  29%|██▊       | 286/1000 [8:23:36<20:57:15, 105.65s/it][Succeeded / Failed / Skipped / Total] 138 / 144 / 4 / 286:  29%|██▊       | 286/1000 [8:23:36<20:57:15, 105.65s/it][Succeeded / Failed / Skipped / Total] 138 / 144 / 4 / 286:  29%|██▊       | 287/1000 [8:26:17<20:57:46, 105.84s/it][Succeeded / Failed / Skipped / Total] 138 / 145 / 4 / 287:  29%|██▊       | 287/1000 [8:26:17<20:57:46, 105.84s/it][Succeeded / Failed / Skipped / Total] 138 / 145 / 4 / 287:  29%|██▉       | 288/1000 [8:26:55<20:53:14, 105.61s/it][Succeeded / Failed / Skipped / Total] 138 / 146 / 4 / 288:  29%|██▉       | 288/1000 [8:26:55<20:53:14, 105.61s/it][Succeeded / Failed / Skipped / Total] 138 / 146 / 4 / 288:  29%|██▉       | 289/1000 [8:30:21<20:55:35, 105.96s/it]Returns a copy of this specification with the specified host. --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[eradication]] ( String [[crosby]] ) { return new ProxySpecification ( [[crosby]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 282 ---------------------------------------------
Enables or disables logging of a request and response. --> Creates a new configuration object which can be printed to standard output. --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[temperamental]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 283 ---------------------------------------------
Returns a copy of this config with the specified parser type. --> Create a new ecole config@param ecole@return --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[ecole]] ( JsonParserType [[boysenberry]] ) { return new JsonPathConfig ( numberReturnType , [[ecole]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute to the request spec. --> Adds a curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved curved --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[equate]] , Object [[cavemen]] ) { spec . attribute ( [[equate]] , [[cavemen]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Creates a new HTTP request based on the given URI and HTTP method. --> Converts a URI to a HttpRequestBase@param uri@param httpMethod@param hasBody@return --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[respectably]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[hypnotism]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 286 ---------------------------------------------
Add result handlers.@param resultHandler the result handler@param additionalResultHandlers the additional result handlers --> M marchin request spec builder. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[marchin]] ( ResultHandler [[fille]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[fille]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 287 ---------------------------------------------
Configures the default boundary for this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[mmmmm]] ( String [[emotional]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[mmmmm]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Creates a default log configuration for this log. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[additional]] ( PrintStream [[decelerate]] ) { return new LogConfig ( [[decelerate]] , "[[Housekeeping]]" == "[[Housekeeping]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Housekeeping]]" == "[[Housekeeping]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 289 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 146 / 4 / 289:  29%|██▉       | 289/1000 [8:30:21<20:55:35, 105.96s/it][Succeeded / Failed / Skipped / Total] 139 / 146 / 4 / 289:  29%|██▉       | 290/1000 [8:36:23<21:04:16, 106.84s/it][Succeeded / Failed / Skipped / Total] 140 / 146 / 4 / 290:  29%|██▉       | 290/1000 [8:36:23<21:04:16, 106.84s/it][Succeeded / Failed / Skipped / Total] 140 / 146 / 4 / 290:  29%|██▉       | 291/1000 [8:38:42<21:03:47, 106.95s/it][Succeeded / Failed / Skipped / Total] 140 / 147 / 4 / 291:  29%|██▉       | 291/1000 [8:38:42<21:03:47, 106.95s/it][Succeeded / Failed / Skipped / Total] 140 / 147 / 4 / 291:  29%|██▉       | 292/1000 [8:40:53<21:02:59, 107.03s/it][Succeeded / Failed / Skipped / Total] 140 / 148 / 4 / 292:  29%|██▉       | 292/1000 [8:40:53<21:02:59, 107.03s/it][Succeeded / Failed / Skipped / Total] 140 / 148 / 4 / 292:  29%|██▉       | 293/1000 [8:41:27<20:58:16, 106.78s/it][Succeeded / Failed / Skipped / Total] 141 / 148 / 4 / 293:  29%|██▉       | 293/1000 [8:41:27<20:58:16, 106.78s/it][Succeeded / Failed / Skipped / Total] 141 / 148 / 4 / 293:  29%|██▉       | 294/1000 [8:43:49<20:57:53, 106.90s/it][Succeeded / Failed / Skipped / Total] 142 / 148 / 4 / 294:  29%|██▉       | 294/1000 [8:43:49<20:57:53, 106.90s/it][Succeeded / Failed / Skipped / Total] 142 / 148 / 4 / 294:  30%|██▉       | 295/1000 [8:46:00<20:57:04, 106.99s/it][Succeeded / Failed / Skipped / Total] 142 / 149 / 4 / 295:  30%|██▉       | 295/1000 [8:46:00<20:57:04, 106.99s/it][Succeeded / Failed / Skipped / Total] 142 / 149 / 4 / 295:  30%|██▉       | 296/1000 [8:46:39<20:52:34, 106.75s/it][Succeeded / Failed / Skipped / Total] 142 / 150 / 4 / 296:  30%|██▉       | 296/1000 [8:46:39<20:52:34, 106.75s/it][Succeeded / Failed / Skipped / Total] 142 / 150 / 4 / 296:  30%|██▉       | 297/1000 [8:48:17<20:50:29, 106.73s/it]Creates and returns a new instance of the HttpClientConfig class. --> Customise HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[specialise]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[specialise]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Ibogaine]]" == "[[Ibogaine]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 290 ---------------------------------------------
Retrieve an integer value from the supplied path. --> Diese Methode die Methode mit dem die Methode mit dem die Methode mit dem die Methode mit dem die Methode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieMethode mit dem dieM --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[diddling]] ( String [[cholesterol]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Adds a header to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[adorns]] ( String [[twinky]] , String [[outing]] ) { spec . header ( [[twinky]] , [[outing]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 292 ---------------------------------------------
Adds a multi part request specification. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String mimeType ) { spec . multiPart ( [[controlName]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[recalibrate]] ( String [[gobbled]] , String contentBody , String mimeType ) { spec . multiPart ( [[gobbled]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 293 ---------------------------------------------
Configures this HttpClientConfig with the given HTTP MultipartMode. --> Creates a new instance of HttpClientConfig@param preserve@return --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[whose]] ( HttpMultipartMode [[preserve]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[whose]] , shouldReuseHttpClientInstance , httpClient , "[[Dagon]]" == "[[Dagon]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 294 ---------------------------------------------
Retrieve a byte value from the supplied resource. --> R roughed@param falter@return --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[roughed]] ( String [[falter]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 295 ---------------------------------------------
Gets the value of the specified JSON path.@param < T> the type parameter@param path the path@return the value --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[economic]] > [[economic]] get ( String path ) { final JSONAssertion [[overprotected]] = createJsonAssertion ( path , params ) ; final Object [[attend]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[economic]] ) [[overprotected]] . getResult ( [[attend]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Creates a new HTTP client configuration with the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; [[newParams]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > [[pollen]] = new HashMap < String , Object > ( this . [[chastised]] ) ; [[pollen]] . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , [[pollen]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 297 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 142 / 151 / 4 / 297:  30%|██▉       | 297/1000 [8:48:17<20:50:29, 106.73s/it][Succeeded / Failed / Skipped / Total] 142 / 151 / 4 / 297:  30%|██▉       | 298/1000 [8:48:39<20:45:22, 106.44s/it][Succeeded / Failed / Skipped / Total] 143 / 151 / 4 / 298:  30%|██▉       | 298/1000 [8:48:39<20:45:22, 106.44s/it][Succeeded / Failed / Skipped / Total] 143 / 151 / 4 / 298:  30%|██▉       | 299/1000 [8:48:58<20:40:10, 106.15s/it][Succeeded / Failed / Skipped / Total] 144 / 151 / 4 / 299:  30%|██▉       | 299/1000 [8:48:58<20:40:10, 106.15s/it][Succeeded / Failed / Skipped / Total] 144 / 151 / 4 / 299:  30%|███       | 300/1000 [8:55:00<20:48:20, 107.00s/it][Succeeded / Failed / Skipped / Total] 145 / 151 / 4 / 300:  30%|███       | 300/1000 [8:55:00<20:48:20, 107.00s/it][Succeeded / Failed / Skipped / Total] 145 / 151 / 4 / 300:  30%|███       | 301/1000 [8:58:13<20:49:53, 107.29s/it][Succeeded / Failed / Skipped / Total] 145 / 152 / 4 / 301:  30%|███       | 301/1000 [8:58:13<20:49:53, 107.29s/it][Succeeded / Failed / Skipped / Total] 145 / 152 / 4 / 301:  30%|███       | 302/1000 [9:02:07<20:52:58, 107.71s/it][Succeeded / Failed / Skipped / Total] 145 / 153 / 4 / 302:  30%|███       | 302/1000 [9:02:07<20:52:58, 107.71s/it][Succeeded / Failed / Skipped / Total] 145 / 153 / 4 / 302:  30%|███       | 303/1000 [9:07:36<20:59:41, 108.44s/it][Succeeded / Failed / Skipped / Total] 145 / 154 / 4 / 303:  30%|███       | 303/1000 [9:07:36<20:59:41, 108.44s/it][Succeeded / Failed / Skipped / Total] 145 / 154 / 4 / 303:  30%|███       | 304/1000 [9:10:08<20:59:31, 108.58s/it][Succeeded / Failed / Skipped / Total] 145 / 155 / 4 / 304:  30%|███       | 304/1000 [9:10:08<20:59:31, 108.58s/it][Succeeded / Failed / Skipped / Total] 145 / 155 / 4 / 304:  30%|███       | 305/1000 [9:10:12<20:53:44, 108.24s/it][Succeeded / Failed / Skipped / Total] 146 / 155 / 4 / 305:  30%|███       | 305/1000 [9:10:12<20:53:44, 108.24s/it][Succeeded / Failed / Skipped / Total] 146 / 155 / 4 / 305:  31%|███       | 306/1000 [9:12:43<20:53:33, 108.38s/it][Succeeded / Failed / Skipped / Total] 147 / 155 / 4 / 306:  31%|███       | 306/1000 [9:12:43<20:53:33, 108.38s/it][Succeeded / Failed / Skipped / Total] 147 / 155 / 4 / 306:  31%|███       | 307/1000 [9:13:44<20:49:57, 108.22s/it][Succeeded / Failed / Skipped / Total] 147 / 156 / 4 / 307:  31%|███       | 307/1000 [9:13:44<20:49:57, 108.22s/it][Succeeded / Failed / Skipped / Total] 147 / 156 / 4 / 307:  31%|███       | 308/1000 [9:15:05<20:47:08, 108.13s/it]Sets the value of the specified HTTP parameter.@param parameterName Name of the HTTP parameter to set.@param parameterValue Value of the HTTP parameter to set.@return Never <code>null</code>. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Supernatural]]" == "[[Supernatural]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 298 ---------------------------------------------
Retrieve a Short object from the given path. --> Compare two Pinhole objects@param pinhole@return --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[similarly]] ( String [[pinhole]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 299 ---------------------------------------------
Retrieve a long value. --> Returns artemisia@param rudeness@return --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[artemisia]] ( String [[rudeness]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieve a property as a float. --> Hydromatrix hydromatrix --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[hydrotherapy]] ( String [[fiorello]] ) { final Object [[aircrafts]] = get ( [[fiorello]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
Retrieve a property as a double. --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[sentimentalist]] ( String [[offensive]] ) { final Object [[legislate]] = get ( [[offensive]] ) ; if ( [[legislate]] instanceof Double ) { return ( Double ) [[legislate]] ; } return ObjectConverter . convertObjectTo ( [[legislate]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 302 ---------------------------------------------
Sets the body of the request. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[salman]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 303 ---------------------------------------------
Gets a map from a path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[rel]] , V > Map < [[rel]] , V > [[cleanse]] ( String [[biographical]] ) { return get ( [[biographical]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 304 ---------------------------------------------
Retrieves an object from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[sulked]] > [[sulked]] getObject ( String path , Class < [[sulked]] > objectType ) { Object [[unwitting]] = getFromPath ( path , "[[Phoenician]]" != "[[Phoenician]]" ) ; return getObjectAsType ( [[unwitting]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the spec. --> Disallowed requests --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[disallowed]] ( String [[imaginations]] , Object ... [[realizes]] ) { spec . param ( [[imaginations]] , [[realizes]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Creates and returns a builder for a parameter update strategy. --> Create a new instance of MockMvcParamConfig@param kamikazes@return --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[berto]] ( UpdateStrategy [[kamikazes]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[kamikazes]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 307 ---------------------------------------------
Adds a cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[screwing]] ( String [[egyptian]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[egyptian]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 148 / 156 / 4 / 308:  31%|███       | 308/1000 [9:15:05<20:47:08, 108.13s/it][Succeeded / Failed / Skipped / Total] 148 / 156 / 4 / 308:  31%|███       | 309/1000 [9:16:31<20:44:30, 108.06s/it][Succeeded / Failed / Skipped / Total] 149 / 156 / 4 / 309:  31%|███       | 309/1000 [9:16:31<20:44:30, 108.06s/it][Succeeded / Failed / Skipped / Total] 149 / 156 / 4 / 309:  31%|███       | 310/1000 [9:17:08<20:40:04, 107.83s/it][Succeeded / Failed / Skipped / Total] 149 / 157 / 4 / 310:  31%|███       | 310/1000 [9:17:08<20:40:04, 107.83s/it][Succeeded / Failed / Skipped / Total] 149 / 157 / 4 / 310:  31%|███       | 311/1000 [9:17:26<20:34:58, 107.55s/it][Succeeded / Failed / Skipped / Total] 150 / 157 / 4 / 311:  31%|███       | 311/1000 [9:17:26<20:34:58, 107.55s/it][Succeeded / Failed / Skipped / Total] 150 / 157 / 4 / 311:  31%|███       | 312/1000 [9:20:38<20:36:16, 107.82s/it][Succeeded / Failed / Skipped / Total] 151 / 157 / 4 / 312:  31%|███       | 312/1000 [9:20:38<20:36:16, 107.82s/it][Succeeded / Failed / Skipped / Total] 151 / 157 / 4 / 312:  31%|███▏      | 313/1000 [9:24:20<20:38:41, 108.18s/it][Succeeded / Failed / Skipped / Total] 151 / 158 / 4 / 313:  31%|███▏      | 313/1000 [9:24:20<20:38:41, 108.18s/it][Succeeded / Failed / Skipped / Total] 151 / 158 / 4 / 313:  31%|███▏      | 314/1000 [9:25:06<20:34:36, 107.98s/it][Succeeded / Failed / Skipped / Total] 152 / 158 / 4 / 314:  31%|███▏      | 314/1000 [9:25:06<20:34:36, 107.98s/it][Succeeded / Failed / Skipped / Total] 152 / 158 / 4 / 314:  32%|███▏      | 315/1000 [9:25:36<20:29:58, 107.73s/it]Adds all bindings to the map. --> fawcett --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[fawcett]] ( ) { for ( Binding < ? > [[calisthenics]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[calisthenics]] . getKey ( ) . getTypeLiteral ( ) , [[calisthenics]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 309 ---------------------------------------------
Removes all keys and sources from the backing map. --> judd --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[keysAndSources]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[judd]] ( Set < KeyAndSource > [[drinking]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[drinking]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 310 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[pause]] ( String [[hairstylist]] , Collection < ? > [[combat]] ) { spec . param ( [[hairstylist]] , [[combat]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 311 ---------------------------------------------
Creates a filter that logs responses that match the provided matcher. --> Log response to if matches@param kyu@return --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[possess]] , Matcher < Integer > [[kyu]] ) { return new ResponseLoggingFilter ( [[possess]] , [[kyu]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 312 ---------------------------------------------
Removes a failed JIT binding. --> Cavorting methods --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[cavorting]] ( Binding < ? > [[exterminate]] , InjectionPoint ip ) { failedJitBindings . add ( [[exterminate]] . getKey ( ) ) ; jitBindings . remove ( [[exterminate]] . getKey ( ) ) ; membersInjectorStore . remove ( [[exterminate]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[exterminate]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 313 ---------------------------------------------
Returns the internal dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[decorate]] ( BindingImpl < ? > [[hypnotized]] ) { if ( [[hypnotized]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[hypnotized]] ) . getInternalDependencies ( ) ; } else if ( [[hypnotized]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[hypnotized]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 314 ---------------------------------------------
Binds an injector. --> slowpoke --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[slowpoke]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 315 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 158 / 4 / 315:  32%|███▏      | 315/1000 [9:25:36<20:29:58, 107.73s/it][Succeeded / Failed / Skipped / Total] 153 / 158 / 4 / 315:  32%|███▏      | 316/1000 [9:27:19<20:27:59, 107.72s/it][Succeeded / Failed / Skipped / Total] 153 / 159 / 4 / 316:  32%|███▏      | 316/1000 [9:27:19<20:27:59, 107.72s/it][Succeeded / Failed / Skipped / Total] 153 / 159 / 4 / 316:  32%|███▏      | 317/1000 [9:31:31<20:31:24, 108.18s/it][Succeeded / Failed / Skipped / Total] 154 / 159 / 4 / 317:  32%|███▏      | 317/1000 [9:31:31<20:31:24, 108.18s/it][Succeeded / Failed / Skipped / Total] 154 / 159 / 4 / 317:  32%|███▏      | 318/1000 [9:31:42<20:26:07, 107.87s/it][Succeeded / Failed / Skipped / Total] 155 / 159 / 4 / 318:  32%|███▏      | 318/1000 [9:31:42<20:26:07, 107.87s/it][Succeeded / Failed / Skipped / Total] 155 / 159 / 4 / 318:  32%|███▏      | 319/1000 [9:32:10<20:21:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 156 / 159 / 4 / 319:  32%|███▏      | 319/1000 [9:32:10<20:21:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 156 / 159 / 4 / 319:  32%|███▏      | 320/1000 [9:33:09<20:17:57, 107.47s/it][Succeeded / Failed / Skipped / Total] 157 / 159 / 4 / 320:  32%|███▏      | 320/1000 [9:33:09<20:17:57, 107.47s/it][Succeeded / Failed / Skipped / Total] 157 / 159 / 4 / 320:  32%|███▏      | 321/1000 [9:35:26<20:17:13, 107.56s/it][Succeeded / Failed / Skipped / Total] 158 / 159 / 4 / 321:  32%|███▏      | 321/1000 [9:35:26<20:17:13, 107.56s/it][Succeeded / Failed / Skipped / Total] 158 / 159 / 4 / 321:  32%|███▏      | 322/1000 [9:35:34<20:11:54, 107.25s/it][Succeeded / Failed / Skipped / Total] 159 / 159 / 4 / 322:  32%|███▏      | 322/1000 [9:35:34<20:11:54, 107.25s/it][Succeeded / Failed / Skipped / Total] 159 / 159 / 4 / 322:  32%|███▏      | 323/1000 [9:37:16<20:09:56, 107.23s/it]Binds a logger to the given injector. --> Bendy methods --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[bendy]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 316 ---------------------------------------------
Gets a list from the specified path.@param path the path@param genericType the generic type@return the list --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > [[genericType]] ) { if ( [[genericType]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T t : [[original]] ) { T [[e]] ; if ( t instanceof Map && ! [[genericType]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String path , Class < T > [[dominatrix]] ) { if ( [[dominatrix]] == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[knockdown]] = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[knockdown]] != null ) { for ( T t : [[knockdown]] ) { T [[canadiens]] ; if ( t instanceof Map && ! [[dominatrix]] . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 317 ---------------------------------------------
Returns all the parameters in the given injectors. --> Performs a stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless stateless --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[size]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[hypnotized]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[democracies]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[democracies]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 318 ---------------------------------------------
Checks for misplaced binding annotations. --> Dostoevsky method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[dostoevsky]] ( Member [[populist]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[populist]] , ( ( AnnotatedElement ) [[populist]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 319 ---------------------------------------------
Initializes the delegate members. --> MUST NOT BE CALLED --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[mucking]] ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 320 ---------------------------------------------
Converts a string constant binding to a binding. --> Convenience factory method for creating an instance of an illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal illegal --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[offences]] ( Key < T > [[podemos]] , Errors [[pige]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 321 ---------------------------------------------
Checks if two methods are overrides of each other. --> Chesterfield method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[chesterfield]] ( Method [[brazen]] , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 322 ---------------------------------------------
Get the provider type. --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[handcuff]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 323 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 159 / 4 / 323:  32%|███▏      | 323/1000 [9:37:16<20:09:56, 107.23s/it][Succeeded / Failed / Skipped / Total] 160 / 159 / 4 / 323:  32%|███▏      | 324/1000 [9:37:26<20:04:47, 106.93s/it][Succeeded / Failed / Skipped / Total] 160 / 160 / 4 / 324:  32%|███▏      | 324/1000 [9:37:26<20:04:47, 106.93s/it][Succeeded / Failed / Skipped / Total] 160 / 160 / 4 / 324:  32%|███▎      | 325/1000 [9:38:54<20:02:20, 106.87s/it][Succeeded / Failed / Skipped / Total] 161 / 160 / 4 / 325:  32%|███▎      | 325/1000 [9:38:54<20:02:20, 106.87s/it][Succeeded / Failed / Skipped / Total] 161 / 160 / 4 / 325:  33%|███▎      | 326/1000 [9:41:28<20:02:10, 107.02s/it][Succeeded / Failed / Skipped / Total] 161 / 161 / 4 / 326:  33%|███▎      | 326/1000 [9:41:28<20:02:10, 107.02s/it][Succeeded / Failed / Skipped / Total] 161 / 161 / 4 / 326:  33%|███▎      | 327/1000 [9:43:23<20:00:41, 107.04s/it][Succeeded / Failed / Skipped / Total] 161 / 162 / 4 / 327:  33%|███▎      | 327/1000 [9:43:23<20:00:41, 107.04s/it][Succeeded / Failed / Skipped / Total] 161 / 162 / 4 / 327:  33%|███▎      | 328/1000 [9:43:29<19:55:26, 106.74s/it][Succeeded / Failed / Skipped / Total] 162 / 162 / 4 / 328:  33%|███▎      | 328/1000 [9:43:29<19:55:26, 106.74s/it][Succeeded / Failed / Skipped / Total] 162 / 162 / 4 / 328:  33%|███▎      | 329/1000 [9:43:47<19:50:39, 106.47s/it][Succeeded / Failed / Skipped / Total] 162 / 163 / 4 / 329:  33%|███▎      | 329/1000 [9:43:47<19:50:39, 106.47s/it][Succeeded / Failed / Skipped / Total] 162 / 163 / 4 / 329:  33%|███▎      | 330/1000 [9:45:02<19:47:48, 106.37s/it]Resolve all of the given types. --> Creates a trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust trust --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { result [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[distrust]] ( Type [ ] [[therapies]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[therapies]] . length ] ; for ( int t = 0 ; t < [[therapies]] . length ; t ++ ) { result [ t ] = resolve ( [[therapies]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 324 ---------------------------------------------
Cleans up the dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[lavalle]] ( BindingImpl < ? > [[hatchery]] , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[hatchery]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 325 ---------------------------------------------
Prepare all built-in converters. --> A convenience method to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[abdo]] ( InjectorImpl [[sentimentalist]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 326 ---------------------------------------------
Canonicalizes the given class loader. --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[sneeze]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 327 ---------------------------------------------
Creates an uninitialized binding. --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 328 ---------------------------------------------
Converts the specified key into an appropriate annotation. --> Diese Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[drinking]] ( Key < ? > [[norberto]] ) { return [[norberto]] . getAnnotation ( ) == null ? [[norberto]] : Key . get ( [[norberto]] . getTypeLiteral ( ) , [[norberto]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 329 ---------------------------------------------
Creates a new Cookies instance with the specified cookies.@param cookie the cookie@param additionalCookies the additional cookies@return a new cookies instance --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cookie]] , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( [[cookie]] ) ; Collections . addAll ( [[cookieList]] , [[additionalCookies]] ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[fossey]] , Cookie ... [[juggling]] ) { AssertParameter . notNull ( [[fossey]] , "Cookie" ) ; final List < Cookie > [[viscount]] = new LinkedList < Cookie > ( ) ; [[viscount]] . add ( [[fossey]] ) ; Collections . addAll ( [[viscount]] , [[juggling]] ) ; return new Cookies ( [[viscount]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 330 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 163 / 4 / 330:  33%|███▎      | 330/1000 [9:45:02<19:47:48, 106.37s/it][Succeeded / Failed / Skipped / Total] 163 / 163 / 4 / 330:  33%|███▎      | 331/1000 [9:48:29<19:49:25, 106.68s/it][Succeeded / Failed / Skipped / Total] 164 / 163 / 4 / 331:  33%|███▎      | 331/1000 [9:48:29<19:49:25, 106.68s/it][Succeeded / Failed / Skipped / Total] 164 / 163 / 4 / 331:  33%|███▎      | 332/1000 [9:49:05<19:45:16, 106.46s/it][Succeeded / Failed / Skipped / Total] 165 / 163 / 4 / 332:  33%|███▎      | 332/1000 [9:49:05<19:45:16, 106.46s/it][Succeeded / Failed / Skipped / Total] 165 / 163 / 4 / 332:  33%|███▎      | 333/1000 [9:49:59<19:41:44, 106.30s/it][Succeeded / Failed / Skipped / Total] 166 / 163 / 4 / 333:  33%|███▎      | 333/1000 [9:49:59<19:41:44, 106.30s/it][Succeeded / Failed / Skipped / Total] 166 / 163 / 4 / 333:  33%|███▎      | 334/1000 [9:50:37<19:37:42, 106.10s/it][Succeeded / Failed / Skipped / Total] 166 / 164 / 4 / 334:  33%|███▎      | 334/1000 [9:50:37<19:37:42, 106.10s/it][Succeeded / Failed / Skipped / Total] 166 / 164 / 4 / 334:  34%|███▎      | 335/1000 [9:55:26<19:41:59, 106.65s/it][Succeeded / Failed / Skipped / Total] 166 / 165 / 4 / 335:  34%|███▎      | 335/1000 [9:55:26<19:41:59, 106.65s/it][Succeeded / Failed / Skipped / Total] 166 / 165 / 4 / 335:  34%|███▎      | 336/1000 [9:58:29<19:42:44, 106.87s/it]Dispatches a servlet request to the dispatcher. --> Performs a "Performs a "Performs a "perform a "perform a "perform a"perform a "perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a"perform a" --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[democracies]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 331 ---------------------------------------------
Validates that the injections are valid. --> zay (errors) --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[zay]] ( Errors errors ) { validationStarted = "[[Hecht]]" == "[[Hecht]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 332 ---------------------------------------------
Checks if the given class loader has the same version of the current one. --> M mulligan --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[mulligan]] ( ClassLoader [[andale]] ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return [[andale]] . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 333 ---------------------------------------------
Creates an injectable scope. --> W slaughterhouse --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[slaughterhouse]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 334 ---------------------------------------------
Injects the given instance into the given injector.@param injector the injector@param instance the instance@param binding the binding@param source the source@param injectionPoints the injection points --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[revelation]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 335 ---------------------------------------------
Generates an annotation for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[scrambles]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 336 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 167 / 165 / 4 / 336:  34%|███▎      | 336/1000 [9:58:29<19:42:44, 106.87s/it][Succeeded / Failed / Skipped / Total] 167 / 165 / 4 / 336:  34%|███▎      | 337/1000 [9:59:42<19:39:51, 106.77s/it][Succeeded / Failed / Skipped / Total] 167 / 166 / 4 / 337:  34%|███▎      | 337/1000 [9:59:42<19:39:51, 106.77s/it][Succeeded / Failed / Skipped / Total] 167 / 166 / 4 / 337:  34%|███▍      | 338/1000 [10:01:40<19:38:25, 106.81s/it][Succeeded / Failed / Skipped / Total] 167 / 167 / 4 / 338:  34%|███▍      | 338/1000 [10:01:40<19:38:25, 106.81s/it][Succeeded / Failed / Skipped / Total] 167 / 167 / 4 / 338:  34%|███▍      | 339/1000 [10:02:13<19:34:15, 106.59s/it][Succeeded / Failed / Skipped / Total] 168 / 167 / 4 / 339:  34%|███▍      | 339/1000 [10:02:13<19:34:15, 106.59s/it][Succeeded / Failed / Skipped / Total] 168 / 167 / 4 / 339:  34%|███▍      | 340/1000 [10:02:44<19:30:01, 106.37s/it][Succeeded / Failed / Skipped / Total] 169 / 167 / 4 / 340:  34%|███▍      | 340/1000 [10:02:44<19:30:01, 106.37s/it][Succeeded / Failed / Skipped / Total] 169 / 167 / 4 / 340:  34%|███▍      | 341/1000 [10:03:31<19:26:21, 106.19s/it][Succeeded / Failed / Skipped / Total] 169 / 168 / 4 / 341:  34%|███▍      | 341/1000 [10:03:31<19:26:21, 106.19s/it][Succeeded / Failed / Skipped / Total] 169 / 168 / 4 / 341:  34%|███▍      | 342/1000 [10:07:58<19:29:43, 106.66s/it][Succeeded / Failed / Skipped / Total] 170 / 168 / 4 / 342:  34%|███▍      | 342/1000 [10:07:58<19:29:43, 106.66s/it][Succeeded / Failed / Skipped / Total] 170 / 168 / 4 / 342:  34%|███▍      | 343/1000 [10:15:15<19:38:28, 107.62s/it]Normalizes a path. --> Bouncy castle version --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder [[sb]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[bouncer]] ( String path ) { StringBuilder [[ladyhawke]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Converts a TypeLiteral into a canonical type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 338 ---------------------------------------------
Returns true if the given member is public, false otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] parameterTypes ; if ( member instanceof Constructor ) { parameterTypes = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider. --> region barracuda --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[barracuda]] ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Adds the direct type binding. --> region barbara --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[barbara]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[koryu]] ( Object [ ] [[paints]] ) throws Throwable { constructor . setAccessible ( "[[Pullover]]" == "[[Pullover]]" ) ; try { return constructor . newInstance ( [[paints]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 342 ---------------------------------------------
Returns true if the given annotation is retained at runtime. --> Diesu dieu@param pacts@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[dieu]] ( Class < ? extends Annotation > [[pacts]] ) { Retention [[nintendo]] = [[pacts]] . getAnnotation ( Retention . class ) ; return [[nintendo]] != null && [[nintendo]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 343 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 168 / 4 / 343:  34%|███▍      | 343/1000 [10:15:15<19:38:28, 107.62s/it][Succeeded / Failed / Skipped / Total] 171 / 168 / 4 / 343:  34%|███▍      | 344/1000 [10:15:23<19:33:32, 107.34s/it][Succeeded / Failed / Skipped / Total] 172 / 168 / 4 / 344:  34%|███▍      | 344/1000 [10:15:23<19:33:32, 107.34s/it][Succeeded / Failed / Skipped / Total] 172 / 168 / 4 / 344:  34%|███▍      | 345/1000 [10:23:27<19:43:39, 108.43s/it][Succeeded / Failed / Skipped / Total] 172 / 169 / 4 / 345:  34%|███▍      | 345/1000 [10:23:27<19:43:39, 108.43s/it][Succeeded / Failed / Skipped / Total] 172 / 169 / 4 / 345:  35%|███▍      | 346/1000 [10:23:33<19:38:38, 108.13s/it][Succeeded / Failed / Skipped / Total] 172 / 170 / 4 / 346:  35%|███▍      | 346/1000 [10:23:33<19:38:38, 108.13s/it][Succeeded / Failed / Skipped / Total] 172 / 170 / 4 / 346:  35%|███▍      | 347/1000 [10:26:29<19:38:57, 108.33s/it][Succeeded / Failed / Skipped / Total] 172 / 171 / 4 / 347:  35%|███▍      | 347/1000 [10:26:29<19:38:57, 108.33s/it][Succeeded / Failed / Skipped / Total] 172 / 171 / 4 / 347:  35%|███▍      | 348/1000 [10:27:06<19:34:55, 108.12s/it][Succeeded / Failed / Skipped / Total] 172 / 172 / 4 / 348:  35%|███▍      | 348/1000 [10:27:06<19:34:55, 108.12s/it][Succeeded / Failed / Skipped / Total] 172 / 172 / 4 / 348:  35%|███▍      | 349/1000 [10:27:37<19:30:44, 107.90s/it]Returns the name of the given key. --> Handlebars --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[handlebar]] ( Key < ? > [[vettori]] ) { Annotation annotation = [[vettori]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[vettori]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[vettori]] . getAnnotation ( ) . toString ( ) ; } else if ( [[vettori]] . getAnnotationType ( ) != null ) { return "@" + [[vettori]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 344 ---------------------------------------------
Create a new RealMapBinder. --> Sailboat implementation --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[sailboat]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[sailboat]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 345 ---------------------------------------------
Returns the key for a new value. --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 346 ---------------------------------------------
Creates a factory for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 347 ---------------------------------------------
Returns the key for the specified type and member. --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 348 ---------------------------------------------
Finds the scope annotation for the given annotations. --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[annotation]] : annotations ) { Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( [[annotationType]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[annotationType]] ) ; } else { found = [[annotationType]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[blackballed]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[jokes]] : annotations ) { Class < ? extends Annotation > [[conjoined]] = [[jokes]] . annotationType ( ) ; if ( isScopeAnnotation ( [[conjoined]] ) ) { if ( found != null ) { errors . duplicateScopeAnnotations ( found , [[conjoined]] ) ; } else { found = [[conjoined]] ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 349 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 173 / 4 / 349:  35%|███▍      | 349/1000 [10:27:37<19:30:44, 107.90s/it][Succeeded / Failed / Skipped / Total] 172 / 173 / 4 / 349:  35%|███▌      | 350/1000 [10:28:50<19:27:50, 107.80s/it][Succeeded / Failed / Skipped / Total] 172 / 174 / 4 / 350:  35%|███▌      | 350/1000 [10:28:50<19:27:50, 107.80s/it][Succeeded / Failed / Skipped / Total] 172 / 174 / 4 / 350:  35%|███▌      | 351/1000 [10:31:08<19:26:59, 107.89s/it][Succeeded / Failed / Skipped / Total] 172 / 175 / 4 / 351:  35%|███▌      | 351/1000 [10:31:08<19:26:59, 107.89s/it][Succeeded / Failed / Skipped / Total] 172 / 175 / 4 / 351:  35%|███▌      | 352/1000 [10:31:19<19:22:12, 107.61s/it][Succeeded / Failed / Skipped / Total] 172 / 176 / 4 / 352:  35%|███▌      | 352/1000 [10:31:19<19:22:12, 107.61s/it][Succeeded / Failed / Skipped / Total] 172 / 176 / 4 / 352:  35%|███▌      | 353/1000 [10:33:34<19:21:16, 107.69s/it][Succeeded / Failed / Skipped / Total] 173 / 176 / 4 / 353:  35%|███▌      | 353/1000 [10:33:34<19:21:16, 107.69s/it][Succeeded / Failed / Skipped / Total] 173 / 176 / 4 / 353:  35%|███▌      | 354/1000 [10:43:30<19:34:17, 109.07s/it][Succeeded / Failed / Skipped / Total] 173 / 177 / 4 / 354:  35%|███▌      | 354/1000 [10:43:30<19:34:17, 109.07s/it][Succeeded / Failed / Skipped / Total] 173 / 177 / 4 / 354:  36%|███▌      | 355/1000 [10:48:46<19:38:45, 109.65s/it][Succeeded / Failed / Skipped / Total] 173 / 178 / 4 / 355:  36%|███▌      | 355/1000 [10:48:46<19:38:45, 109.65s/it][Succeeded / Failed / Skipped / Total] 173 / 178 / 4 / 355:  36%|███▌      | 356/1000 [10:49:41<19:35:17, 109.50s/it][Succeeded / Failed / Skipped / Total] 174 / 178 / 4 / 356:  36%|███▌      | 356/1000 [10:49:41<19:35:17, 109.50s/it][Succeeded / Failed / Skipped / Total] 174 / 178 / 4 / 356:  36%|███▌      | 357/1000 [10:49:57<19:30:39, 109.24s/it]Checks if the interceptor class has a scope annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 350 ---------------------------------------------
Returns the module for the given module. --> [[[FAILED]]]

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[copacetic]] ( Module [[dogma]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 351 ---------------------------------------------
Returns a collection of all methods of this class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[chlorine]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Returns a ConstructorInjector for the given InjectionPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[meteorite]] ( InjectionPoint [[spontaneity]] , Errors [[currants]] ) throws ErrorsException { return cache . get ( [[spontaneity]] , [[currants]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 353 ---------------------------------------------
Writes a message to the supplied object. --> Dostoevsky lights --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[dostoevsky]] ( ) throws ObjectStreamException { Object [ ] [[flashlight]] = sources . toArray ( ) ; for ( int [[counselors]] = 0 ; [[counselors]] < [[flashlight]] . length ; [[counselors]] ++ ) { [[flashlight]] [ [[counselors]] ] = Errors . convert ( [[flashlight]] [ [[counselors]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[flashlight]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 354 ---------------------------------------------
Creates a new instance of the proxy for the given context. --> [[[FAILED]]]

[[[[Adv]]]]: private T provision ( InternalContext [[context]] , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] [[parameters]] = SingleParameterInjector . getAll ( [[context]] , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( [[parameters]] ) ; [[constructionContext]] . setProxyDelegates ( [[t]] ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T provision ( InternalContext [[twine]] , ConstructionContext < T > [[moran]] ) throws InternalProvisionException { try { T [[outward]] ; try { Object [ ] [[hangnail]] = SingleParameterInjector . getAll ( [[twine]] , parameterInjectors ) ; [[outward]] = constructionProxy . newInstance ( [[hangnail]] ) ; [[moran]] . setProxyDelegates ( [[outward]] ) ; } finally { [[moran]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 355 ---------------------------------------------
Returns the set of dependencies for the given injection point. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 356 ---------------------------------------------
Creates an error message for the given key. --> Appends an error message to the log. --> Socre: 1.0

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[conductor]] = new StringBuilder ( ) ; [[conductor]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 175 / 178 / 4 / 357:  36%|███▌      | 357/1000 [10:49:57<19:30:39, 109.24s/it][Succeeded / Failed / Skipped / Total] 175 / 178 / 4 / 357:  36%|███▌      | 358/1000 [10:57:57<19:39:55, 110.27s/it][Succeeded / Failed / Skipped / Total] 175 / 179 / 4 / 358:  36%|███▌      | 358/1000 [10:57:57<19:39:55, 110.27s/it][Succeeded / Failed / Skipped / Total] 175 / 179 / 4 / 358:  36%|███▌      | 359/1000 [11:00:54<19:40:04, 110.46s/it][Succeeded / Failed / Skipped / Total] 175 / 180 / 4 / 359:  36%|███▌      | 359/1000 [11:00:54<19:40:04, 110.46s/it][Succeeded / Failed / Skipped / Total] 175 / 180 / 4 / 359:  36%|███▌      | 360/1000 [11:01:13<19:35:30, 110.20s/it][Succeeded / Failed / Skipped / Total] 176 / 180 / 4 / 360:  36%|███▌      | 360/1000 [11:01:13<19:35:30, 110.20s/it][Succeeded / Failed / Skipped / Total] 176 / 180 / 4 / 360:  36%|███▌      | 361/1000 [11:01:45<19:31:21, 109.99s/it][Succeeded / Failed / Skipped / Total] 176 / 181 / 4 / 361:  36%|███▌      | 361/1000 [11:01:45<19:31:21, 109.99s/it][Succeeded / Failed / Skipped / Total] 176 / 181 / 4 / 361:  36%|███▌      | 362/1000 [11:02:25<19:27:29, 109.80s/it][Succeeded / Failed / Skipped / Total] 177 / 181 / 4 / 362:  36%|███▌      | 362/1000 [11:02:25<19:27:29, 109.80s/it][Succeeded / Failed / Skipped / Total] 177 / 181 / 4 / 362:  36%|███▋      | 363/1000 [11:04:06<19:25:23, 109.77s/it][Succeeded / Failed / Skipped / Total] 178 / 181 / 4 / 363:  36%|███▋      | 363/1000 [11:04:06<19:25:23, 109.77s/it][Succeeded / Failed / Skipped / Total] 178 / 181 / 4 / 363:  36%|███▋      | 364/1000 [11:09:33<19:29:54, 110.37s/it]Checks if the given type literal is not specified in the configuration. --> Diese Methode@param demy@param division@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[dally]] ( TypeLiteral < ? > [[demy]] , ConfigurationException [[division]] ) { Collection < Message > [[techno]] = [[division]] . getErrorMessages ( ) ; if ( [[techno]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[demy]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[techno]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 358 ---------------------------------------------
Create a binding from a new injector. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 359 ---------------------------------------------
Removes the given set of dependencies from the given set. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[builder]] . add ( dep ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[humbleness]] ( Set < Dependency < ? > > [[manpower]] ) { ImmutableSet . Builder < Dependency < ? > > [[credibility]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[manpower]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[credibility]] . add ( dep ) ; } } return [[credibility]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 360 ---------------------------------------------
Gets the internal constructor. --> Sc scrapping --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[scrapping]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 361 ---------------------------------------------
Find the next filter. --> [[[FAILED]]]

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[acquire]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 362 ---------------------------------------------
Invokes the specified method on the specified object. --> Hijacker methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object [[proxy]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[hijacker]] ( Object [[antero]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 363 ---------------------------------------------
Create a new set-binder for the specified key. --> Instantiates a Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes Bayes --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > [[key]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( binder , [[key]] ) ; binder . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[automaton]] ( Binder binder , Key < T > [[honour]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[soapy]] = new RealMultibinder <> ( binder , [[honour]] ) ; binder . install ( [[soapy]] ) ; return [[soapy]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 364 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 178 / 182 / 4 / 364:  36%|███▋      | 364/1000 [11:09:33<19:29:54, 110.37s/it][Succeeded / Failed / Skipped / Total] 178 / 182 / 4 / 364:  36%|███▋      | 365/1000 [11:11:00<19:27:22, 110.30s/it][Succeeded / Failed / Skipped / Total] 178 / 183 / 4 / 365:  36%|███▋      | 365/1000 [11:11:00<19:27:22, 110.30s/it][Succeeded / Failed / Skipped / Total] 178 / 183 / 4 / 365:  37%|███▋      | 366/1000 [11:12:13<19:24:26, 110.20s/it][Succeeded / Failed / Skipped / Total] 178 / 184 / 4 / 366:  37%|███▋      | 366/1000 [11:12:13<19:24:26, 110.20s/it][Succeeded / Failed / Skipped / Total] 178 / 184 / 4 / 366:  37%|███▋      | 367/1000 [11:13:46<19:22:06, 110.15s/it][Succeeded / Failed / Skipped / Total] 179 / 184 / 4 / 367:  37%|███▋      | 367/1000 [11:13:46<19:22:06, 110.15s/it][Succeeded / Failed / Skipped / Total] 179 / 184 / 4 / 367:  37%|███▋      | 368/1000 [11:15:38<19:20:21, 110.16s/it][Succeeded / Failed / Skipped / Total] 179 / 185 / 4 / 368:  37%|███▋      | 368/1000 [11:15:38<19:20:21, 110.16s/it][Succeeded / Failed / Skipped / Total] 179 / 185 / 4 / 368:  37%|███▋      | 369/1000 [11:20:03<19:22:55, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 185 / 4 / 369:  37%|███▋      | 369/1000 [11:20:03<19:22:55, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 185 / 4 / 369:  37%|███▋      | 370/1000 [11:21:53<19:21:04, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 186 / 4 / 370:  37%|███▋      | 370/1000 [11:21:53<19:21:04, 110.58s/it][Succeeded / Failed / Skipped / Total] 180 / 186 / 4 / 370:  37%|███▋      | 371/1000 [11:23:37<19:19:02, 110.56s/it]Checks if the given set of dependencies is valid for the given factory type. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > dependencies , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 365 ---------------------------------------------
Returns true if the given constructor has at least one annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[taxi]] ( Constructor [[patients]] ) { return [[patients]] . isAnnotationPresent ( Inject . class ) || [[patients]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 366 ---------------------------------------------
Returns the set of internal dependencies for the given factory. --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[sneer]] ( ) { ImmutableSet . Builder < InjectionPoint > [[cleanser]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[cleanser]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 367 ---------------------------------------------
Initializes the lookups. --> F frankenstein --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[frankenstein]] ( Errors [[providers]] ) { injector . lookups = injector ; new LookupProcessor ( [[providers]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 368 ---------------------------------------------
Returns the line number for the given member. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[suffer]] ( Member [[chairing]] ) { Preconditions . checkArgument ( type == [[chairing]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[chairing]] , [[chairing]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[chairing]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Validates that the supplied object is compatible with the supplied key. --> copacetic copacetic implementation --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[copacetic]] ( Key < ? > key , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 370 ---------------------------------------------
Returns the annotation for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 371 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 187 / 4 / 371:  37%|███▋      | 371/1000 [11:23:37<19:19:02, 110.56s/it][Succeeded / Failed / Skipped / Total] 180 / 187 / 4 / 371:  37%|███▋      | 372/1000 [11:24:21<19:15:19, 110.38s/it][Succeeded / Failed / Skipped / Total] 180 / 188 / 4 / 372:  37%|███▋      | 372/1000 [11:24:21<19:15:19, 110.38s/it][Succeeded / Failed / Skipped / Total] 180 / 188 / 4 / 372:  37%|███▋      | 373/1000 [11:25:02<19:11:32, 110.20s/it][Succeeded / Failed / Skipped / Total] 181 / 188 / 4 / 373:  37%|███▋      | 373/1000 [11:25:02<19:11:32, 110.20s/it][Succeeded / Failed / Skipped / Total] 181 / 188 / 4 / 373:  37%|███▋      | 374/1000 [11:32:21<19:18:51, 111.07s/it][Succeeded / Failed / Skipped / Total] 182 / 188 / 4 / 374:  37%|███▋      | 374/1000 [11:32:21<19:18:51, 111.07s/it][Succeeded / Failed / Skipped / Total] 182 / 188 / 4 / 374:  38%|███▊      | 375/1000 [11:34:52<19:18:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 182 / 189 / 4 / 375:  38%|███▊      | 375/1000 [11:34:52<19:18:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 182 / 189 / 4 / 375:  38%|███▊      | 376/1000 [11:35:44<19:14:37, 111.02s/it][Succeeded / Failed / Skipped / Total] 182 / 190 / 4 / 376:  38%|███▊      | 376/1000 [11:35:44<19:14:37, 111.02s/it]Wraps a callable with a transfer request. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[regression]] ( Callable < T > [[attest]] ) { return wrap ( [[attest]] , [[regression]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 372 ---------------------------------------------
Checks if the given constructor has all the required parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 373 ---------------------------------------------
Returns a module for the given module annotated method. --> Loretta --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[lion]] ( Object [[mathis]] , ModuleAnnotatedMethodScanner [[referees]] ) { return forObject ( [[mathis]] , "[[Loretta]]" != "[[Loretta]]" , [[referees]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 374 ---------------------------------------------
Returns an annotation strategy for the given annotation. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[crosswalk]] ( Annotation [[mockingly]] ) { checkNotNull ( [[mockingly]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[mockingly]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[mockingly]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[mockingly]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 375 ---------------------------------------------
Wraps a callable with a request seed map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , [[continueRequest]] ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[magnate]] ( Callable < T > [[impassable]] , Map < Key < ? > , Object > [[backyard]] ) { return wrap ( [[impassable]] , [[magnate]] ( [[backyard]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 376 ---------------------------------------------
Gets the source of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[dissident]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 377 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 182 / 191 / 4 / 377:  38%|███▊      | 377/1000 [11:35:44<19:09:43, 110.73s/it][Succeeded / Failed / Skipped / Total] 182 / 191 / 4 / 377:  38%|███▊      | 378/1000 [11:36:51<19:06:41, 110.61s/it][Succeeded / Failed / Skipped / Total] 182 / 192 / 4 / 378:  38%|███▊      | 378/1000 [11:36:51<19:06:41, 110.61s/it][Succeeded / Failed / Skipped / Total] 182 / 192 / 4 / 378:  38%|███▊      | 379/1000 [11:41:58<19:10:11, 111.13s/it][Succeeded / Failed / Skipped / Total] 182 / 193 / 4 / 379:  38%|███▊      | 379/1000 [11:41:58<19:10:11, 111.13s/it][Succeeded / Failed / Skipped / Total] 182 / 193 / 4 / 379:  38%|███▊      | 380/1000 [11:42:33<19:06:16, 110.93s/it][Succeeded / Failed / Skipped / Total] 182 / 194 / 4 / 380:  38%|███▊      | 380/1000 [11:42:33<19:06:16, 110.93s/it][Succeeded / Failed / Skipped / Total] 182 / 194 / 4 / 380:  38%|███▊      | 381/1000 [11:45:48<19:06:41, 111.15s/it][Succeeded / Failed / Skipped / Total] 183 / 194 / 4 / 381:  38%|███▊      | 381/1000 [11:45:48<19:06:41, 111.15s/it][Succeeded / Failed / Skipped / Total] 183 / 194 / 4 / 381:  38%|███▊      | 382/1000 [11:55:05<19:16:52, 112.32s/it][Succeeded / Failed / Skipped / Total] 183 / 195 / 4 / 382:  38%|███▊      | 382/1000 [11:55:05<19:16:52, 112.32s/it][Succeeded / Failed / Skipped / Total] 183 / 195 / 4 / 382:  38%|███▊      | 383/1000 [11:58:17<19:17:09, 112.53s/it]Prune the stacktrace from the exception. --> [[[FAILED]]]

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 378 ---------------------------------------------
Returns an annotation strategy for the given annotation type. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[backache]] ( Class < ? extends Annotation > [[princess]] ) { [[princess]] = Annotations . canonicalizeIfNamed ( [[princess]] ) ; if ( isAllDefaultMethods ( [[princess]] ) ) { return [[backache]] ( generateAnnotation ( [[princess]] ) ) ; } checkNotNull ( [[princess]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[princess]] ) ; ensureIsBindingAnnotation ( [[princess]] ) ; return new AnnotationTypeStrategy ( [[princess]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 379 ---------------------------------------------
Gets the injectors for the given injection points. --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > injectors = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; injectors . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 380 ---------------------------------------------
Returns a new instance of the given annotation strategy. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[physiotherapy]] ( Class < T > [[pseudo]] , AnnotationStrategy [[engaging]] ) { return new Key < T > ( [[pseudo]] , [[engaging]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 381 ---------------------------------------------
Converts an object to an object. --> Hijackers method --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[hijackers]] ( Object o ) { ElementSource [[accretion]] = null ; if ( o instanceof ElementSource ) { [[accretion]] = ( ElementSource ) o ; o = [[accretion]] . getDeclaringSource ( ) ; } return [[hijackers]] ( o , [[accretion]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Checks if the given class should be skipped. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[alarmed]] ( String [[tenzin]] ) { return ( parent != null && parent . shouldBeSkipped ( [[tenzin]] ) ) || classNamesToSkip . contains ( [[tenzin]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 383 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 183 / 196 / 4 / 383:  38%|███▊      | 383/1000 [11:58:17<19:17:09, 112.53s/it][Succeeded / Failed / Skipped / Total] 183 / 196 / 4 / 383:  38%|███▊      | 384/1000 [11:59:35<19:14:20, 112.44s/it][Succeeded / Failed / Skipped / Total] 183 / 197 / 4 / 384:  38%|███▊      | 384/1000 [11:59:35<19:14:20, 112.44s/it][Succeeded / Failed / Skipped / Total] 183 / 197 / 4 / 384:  38%|███▊      | 385/1000 [12:05:19<19:18:38, 113.04s/it][Succeeded / Failed / Skipped / Total] 183 / 198 / 4 / 385:  38%|███▊      | 385/1000 [12:05:19<19:18:38, 113.04s/it][Succeeded / Failed / Skipped / Total] 183 / 198 / 4 / 385:  39%|███▊      | 386/1000 [12:07:16<19:16:51, 113.05s/it][Succeeded / Failed / Skipped / Total] 183 / 199 / 4 / 386:  39%|███▊      | 386/1000 [12:07:16<19:16:51, 113.05s/it][Succeeded / Failed / Skipped / Total] 183 / 199 / 4 / 386:  39%|███▊      | 387/1000 [12:07:24<19:12:11, 112.78s/it]Formats the given collection of messages into a human readable string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 384 ---------------------------------------------
Creates a message with the specified format and arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[seats]] ( String [[vindicated]] , Object ... [[deceptive]] ) { return [[seats]] ( null , [[vindicated]] , [[deceptive]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 385 ---------------------------------------------
Creates a new instance of MembersInjectorImpl. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 386 ---------------------------------------------
Creates a new message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > sources , String [[messageFormat]] , Object ... [[arguments]] ) { String message = format ( [[messageFormat]] , [[arguments]] ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[strip]] ( Throwable [[supplement]] , List < Object > sources , String [[patched]] , Object ... [[prostitutes]] ) { String message = format ( [[patched]] , [[prostitutes]] ) ; return new Message ( sources , message , [[supplement]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 184 / 199 / 4 / 387:  39%|███▊      | 387/1000 [12:07:24<19:12:11, 112.78s/it][Succeeded / Failed / Skipped / Total] 184 / 199 / 4 / 387:  39%|███▉      | 388/1000 [12:07:52<19:08:05, 112.56s/it][Succeeded / Failed / Skipped / Total] 184 / 200 / 4 / 388:  39%|███▉      | 388/1000 [12:07:52<19:08:05, 112.56s/it][Succeeded / Failed / Skipped / Total] 184 / 200 / 4 / 388:  39%|███▉      | 389/1000 [12:08:21<19:04:02, 112.34s/it][Succeeded / Failed / Skipped / Total] 185 / 200 / 4 / 389:  39%|███▉      | 389/1000 [12:08:21<19:04:02, 112.34s/it][Succeeded / Failed / Skipped / Total] 185 / 200 / 4 / 389:  39%|███▉      | 390/1000 [12:13:17<19:06:56, 112.81s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 4 / 390:  39%|███▉      | 390/1000 [12:13:17<19:06:56, 112.81s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 4 / 390:  39%|███▉      | 391/1000 [12:13:17<19:02:08, 112.53s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 5 / 391:  39%|███▉      | 391/1000 [12:13:17<19:02:08, 112.53s/it][Succeeded / Failed / Skipped / Total] 185 / 201 / 5 / 391:  39%|███▉      | 392/1000 [12:14:13<18:58:48, 112.38s/it][Succeeded / Failed / Skipped / Total] 185 / 202 / 5 / 392:  39%|███▉      | 392/1000 [12:14:13<18:58:48, 112.38s/it][Succeeded / Failed / Skipped / Total] 185 / 202 / 5 / 392:  39%|███▉      | 393/1000 [12:21:05<19:04:38, 113.14s/it][Succeeded / Failed / Skipped / Total] 186 / 202 / 5 / 393:  39%|███▉      | 393/1000 [12:21:05<19:04:38, 113.14s/it][Succeeded / Failed / Skipped / Total] 186 / 202 / 5 / 393:  39%|███▉      | 394/1000 [12:24:34<19:05:13, 113.39s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 5 / 394:  39%|███▉      | 394/1000 [12:24:34<19:05:13, 113.39s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 5 / 394:  40%|███▉      | 395/1000 [12:24:35<19:00:27, 113.10s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 6 / 395:  40%|███▉      | 395/1000 [12:24:35<19:00:27, 113.10s/it][Succeeded / Failed / Skipped / Total] 187 / 202 / 6 / 395:  40%|███▉      | 396/1000 [12:26:31<18:58:38, 113.11s/it]Starts the remote JMX server. --> Strips a carpet --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector [[injector]] = Guice . createInjector ( [[module]] ) ; manage ( [[args]] [ 0 ] , [[injector]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[birdseed]] ( String [ ] [[strain]] ) throws Exception { if ( [[strain]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[quicksilver]] = ( Module ) Class . forName ( [[strain]] [ 0 ] ) . newInstance ( ) ; Injector [[agnès]] = Guice . createInjector ( [[quicksilver]] ) ; manage ( [[strain]] [ 0 ] , [[agnès]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 388 ---------------------------------------------
Returns the source of the specified module class names. --> [[[FAILED]]]

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String [[loggers]] : moduleClassNames ) { if ( ! shouldBeSkipped ( [[loggers]] ) ) { return new StackTraceElement ( [[loggers]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 389 ---------------------------------------------
Pushes a state onto the cache. --> F feli --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[feli]] ( com . google . inject . Key < ? > [[lavonne]] , Object source ) { doPushState ( [[lavonne]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[minimally]] ( Throwable [[hallucinogen]] , String [[excavations]] , Object ... [[magnum]] ) { return [[minimally]] ( [[hallucinogen]] , ImmutableList . of ( ) , [[excavations]] , [[magnum]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 391 ---------------------------------------------
Rethrows an unchecked exception. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[spinnaker]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 393 ---------------------------------------------
Registers a default processor. --> C crucifixions --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[crucifixions]] ( RemotingProcessor < ? > [[infomercial]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[infomercial]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 394 ---------------------------------------------
Called when a connection event occurs. --> Process an incoming connection event@param nosebleeds@param sha@param leong --> Socre: 1.0

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType [[type]] , String [[remoteAddr]] , Connection [[conn]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[remoteAddr]] , [[conn]] ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[illinois]] ( ConnectionEventType [[nosebleeds]] , String [[shaka]] , Connection [[leong]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[nosebleeds]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( [[shaka]] , [[leong]] ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 395 ---------------------------------------------
Returns the Url for the given URL. --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 187 / 203 / 6 / 396:  40%|███▉      | 396/1000 [12:26:31<18:58:38, 113.11s/it][Succeeded / Failed / Skipped / Total] 187 / 203 / 6 / 396:  40%|███▉      | 397/1000 [12:27:01<18:54:38, 112.90s/it][Succeeded / Failed / Skipped / Total] 187 / 204 / 6 / 397:  40%|███▉      | 397/1000 [12:27:01<18:54:38, 112.90s/it][Succeeded / Failed / Skipped / Total] 187 / 204 / 6 / 397:  40%|███▉      | 398/1000 [12:27:17<18:50:19, 112.66s/it][Succeeded / Failed / Skipped / Total] 188 / 204 / 6 / 398:  40%|███▉      | 398/1000 [12:27:17<18:50:19, 112.66s/it][Succeeded / Failed / Skipped / Total] 188 / 204 / 6 / 398:  40%|███▉      | 399/1000 [12:27:57<18:46:36, 112.47s/it][Succeeded / Failed / Skipped / Total] 189 / 204 / 6 / 399:  40%|███▉      | 399/1000 [12:27:57<18:46:36, 112.47s/it][Succeeded / Failed / Skipped / Total] 189 / 204 / 6 / 399:  40%|████      | 400/1000 [12:28:31<18:42:46, 112.28s/it][Succeeded / Failed / Skipped / Total] 190 / 204 / 6 / 400:  40%|████      | 400/1000 [12:28:31<18:42:46, 112.28s/it][Succeeded / Failed / Skipped / Total] 190 / 204 / 6 / 400:  40%|████      | 401/1000 [12:29:19<18:39:19, 112.12s/it][Succeeded / Failed / Skipped / Total] 190 / 205 / 6 / 401:  40%|████      | 401/1000 [12:29:19<18:39:19, 112.12s/it][Succeeded / Failed / Skipped / Total] 190 / 205 / 6 / 401:  40%|████      | 402/1000 [12:29:21<18:34:43, 111.85s/it][Succeeded / Failed / Skipped / Total] 191 / 205 / 6 / 402:  40%|████      | 402/1000 [12:29:21<18:34:43, 111.85s/it][Succeeded / Failed / Skipped / Total] 191 / 205 / 6 / 402:  40%|████      | 403/1000 [12:30:15<18:31:25, 111.70s/it]Pushes the specified dependency onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 397 ---------------------------------------------
Gets the future task result.@param < T> the type parameter@param task the task@param logger the logger@return the future task result --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[mosque]] > [[mosque]] getFutureTaskResult ( RunStateRecordedFutureTask < [[mosque]] > task , Logger logger ) { [[mosque]] [[nosebleeds]] = null ; if ( null != task ) { try { [[nosebleeds]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[nosebleeds]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 398 ---------------------------------------------
Scans the connection pool. --> Scans the pool. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[iter]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { String poolKey = [[iter]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[iter]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > [[noticeably]] = this . connTasks . keySet ( ) . iterator ( ) ; while ( [[noticeably]] . hasNext ( ) ) { String poolKey = [[noticeably]] . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { [[noticeably]] . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Get and create a connection if it doesn't exist. --> Throws an InterruptedException@param url@return@throws InterruptedException@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[vitriol]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 400 ---------------------------------------------
Create a connection and heal if needed. --> Overrides this method to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[panky]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 401 ---------------------------------------------
Registers a processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( [[cmdCode]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[akemi]] ( CommandCode [[discussing]] , RemotingProcessor < ? > processor ) { if ( this . [[bennett]] . containsKey ( [[discussing]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[discussing]] , cmd2processors . get ( [[discussing]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[bennett]] . put ( [[discussing]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 402 ---------------------------------------------
Decodes a protocol code. --> Coherence. --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[coherence]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 403 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 192 / 205 / 6 / 403:  40%|████      | 403/1000 [12:30:15<18:31:25, 111.70s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 6 / 403:  40%|████      | 404/1000 [12:30:15<18:26:49, 111.42s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 7 / 404:  40%|████      | 404/1000 [12:30:15<18:26:49, 111.42s/it][Succeeded / Failed / Skipped / Total] 192 / 205 / 7 / 404:  40%|████      | 405/1000 [12:31:04<18:23:25, 111.27s/it][Succeeded / Failed / Skipped / Total] 192 / 206 / 7 / 405:  40%|████      | 405/1000 [12:31:04<18:23:25, 111.27s/it][Succeeded / Failed / Skipped / Total] 192 / 206 / 7 / 405:  41%|████      | 406/1000 [12:31:16<18:19:09, 111.03s/it][Succeeded / Failed / Skipped / Total] 193 / 206 / 7 / 406:  41%|████      | 406/1000 [12:31:16<18:19:09, 111.03s/it][Succeeded / Failed / Skipped / Total] 193 / 206 / 7 / 406:  41%|████      | 407/1000 [12:35:18<18:20:29, 111.35s/it][Succeeded / Failed / Skipped / Total] 194 / 206 / 7 / 407:  41%|████      | 407/1000 [12:35:18<18:20:29, 111.35s/it][Succeeded / Failed / Skipped / Total] 194 / 206 / 7 / 407:  41%|████      | 408/1000 [12:38:59<18:21:16, 111.62s/it]Create a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param syncCreateNumWhenNotWarmup the sync create number when not warmup@throws RemotingException --> Creates a connection pool.@param url the url@param pool the connection pool@param antonioni the antonioni@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[taskName]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[taskName]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[antonioni]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[antonioni]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 404 ---------------------------------------------
Closes the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
Adds a new connection event processor.@param type the event type@param processor the event processor --> [[[FAILED]]]

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType type , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList == null ) { this . processors . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( type ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 406 ---------------------------------------------
Removes a task from the pool. --> Removes the specified backstreets. --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String [[poolKey]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[connTasks]] . remove ( [[poolKey]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String [[backstreets]] ) { RunStateRecordedFutureTask < ConnectionPool > task = this . [[pastry]] . remove ( [[backstreets]] ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 407 ---------------------------------------------
Called when a connection is closed. --> SODO --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[sodomy]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 195 / 206 / 7 / 408:  41%|████      | 408/1000 [12:38:59<18:21:16, 111.62s/it][Succeeded / Failed / Skipped / Total] 195 / 206 / 7 / 408:  41%|████      | 409/1000 [12:39:07<18:16:56, 111.36s/it][Succeeded / Failed / Skipped / Total] 195 / 207 / 7 / 409:  41%|████      | 409/1000 [12:39:07<18:16:56, 111.36s/it][Succeeded / Failed / Skipped / Total] 195 / 207 / 7 / 409:  41%|████      | 410/1000 [12:39:40<18:13:10, 111.17s/it][Succeeded / Failed / Skipped / Total] 195 / 208 / 7 / 410:  41%|████      | 410/1000 [12:39:40<18:13:10, 111.17s/it][Succeeded / Failed / Skipped / Total] 195 / 208 / 7 / 410:  41%|████      | 411/1000 [12:41:39<18:11:31, 111.19s/it][Succeeded / Failed / Skipped / Total] 195 / 209 / 7 / 411:  41%|████      | 411/1000 [12:41:39<18:11:31, 111.19s/it][Succeeded / Failed / Skipped / Total] 195 / 209 / 7 / 411:  41%|████      | 412/1000 [12:43:35<18:09:47, 111.20s/it][Succeeded / Failed / Skipped / Total] 196 / 209 / 7 / 412:  41%|████      | 412/1000 [12:43:35<18:09:47, 111.20s/it][Succeeded / Failed / Skipped / Total] 196 / 209 / 7 / 412:  41%|████▏     | 413/1000 [12:45:02<18:07:21, 111.14s/it]Associates the specified attribute with the specified value. --> Register an administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String key , Object [[value]] ) { return attributes . putIfAbsent ( key , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[frankfurt]] ( String key , Object [[governmental]] ) { return attributes . putIfAbsent ( key , [[governmental]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 409 ---------------------------------------------
Returns the processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 410 ---------------------------------------------
Creates a new instance of the given provider. --> [[[FAILED]]]

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 411 ---------------------------------------------
Closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "[[Dinozzo]]" != "[[Dinozzo]]" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 412 ---------------------------------------------
E heal if needed --> Sends a bonfires request. --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[bonfires]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 197 / 209 / 7 / 413:  41%|████▏     | 413/1000 [12:45:02<18:07:21, 111.14s/it][Succeeded / Failed / Skipped / Total] 197 / 209 / 7 / 413:  41%|████▏     | 414/1000 [12:49:56<18:09:49, 111.59s/it][Succeeded / Failed / Skipped / Total] 197 / 210 / 7 / 414:  41%|████▏     | 414/1000 [12:49:56<18:09:49, 111.59s/it][Succeeded / Failed / Skipped / Total] 197 / 210 / 7 / 414:  42%|████▏     | 415/1000 [12:51:07<18:07:00, 111.49s/it][Succeeded / Failed / Skipped / Total] 198 / 210 / 7 / 415:  42%|████▏     | 415/1000 [12:51:07<18:07:00, 111.49s/it][Succeeded / Failed / Skipped / Total] 198 / 210 / 7 / 415:  42%|████▏     | 416/1000 [12:52:23<18:04:19, 111.40s/it][Succeeded / Failed / Skipped / Total] 199 / 210 / 7 / 416:  42%|████▏     | 416/1000 [12:52:23<18:04:19, 111.40s/it][Succeeded / Failed / Skipped / Total] 199 / 210 / 7 / 416:  42%|████▏     | 417/1000 [12:53:10<18:00:58, 111.25s/it]Registers a user processor.@param processor The user processor.@param userProcessors The user processors. --> zuzana zuzana --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[zuzana]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[denounce]] ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[zuzana]] ( ( MultiInterestUserProcessor ) processor , [[denounce]] ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[denounce]] . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 414 ---------------------------------------------
Gets all connections.@param <String> the type parameter@param <List<Connection>> the type parameter@return the all connections --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 415 ---------------------------------------------
Registers a user processor with the rpc server. --> Fisher methods --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[interest]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( [[interest]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[interest]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[fishers]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[matlock]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[gustaf]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[matlock]] . putIfAbsent ( [[gustaf]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[gustaf]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 416 ---------------------------------------------
Deserialize request command.@param ctx the remoting context@param cmd the command@param level the level@return true, if successful --> Checks if the RpcRequestCommand can be deserialized. --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean [[result]] ; try { cmd . deserialize ( level ) ; [[result]] = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; [[result]] = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; [[result]] = "False" != "False" ; } return [[result]] ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[advantages]] ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean [[bully]] ; try { cmd . deserialize ( level ) ; [[bully]] = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; [[bully]] = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; [[bully]] = "False" != "False" ; } return [[bully]] ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 417 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 200 / 210 / 7 / 417:  42%|████▏     | 417/1000 [12:53:10<18:00:58, 111.25s/it][Succeeded / Failed / Skipped / Total] 200 / 210 / 7 / 417:  42%|████▏     | 418/1000 [12:56:43<18:01:28, 111.49s/it][Succeeded / Failed / Skipped / Total] 200 / 211 / 7 / 418:  42%|████▏     | 418/1000 [12:56:43<18:01:28, 111.49s/it][Succeeded / Failed / Skipped / Total] 200 / 211 / 7 / 418:  42%|████▏     | 419/1000 [12:59:03<18:00:16, 111.56s/it][Succeeded / Failed / Skipped / Total] 201 / 211 / 7 / 419:  42%|████▏     | 419/1000 [12:59:03<18:00:16, 111.56s/it][Succeeded / Failed / Skipped / Total] 201 / 211 / 7 / 419:  42%|████▏     | 420/1000 [12:59:11<17:56:01, 111.31s/it][Succeeded / Failed / Skipped / Total] 202 / 211 / 7 / 420:  42%|████▏     | 420/1000 [12:59:11<17:56:01, 111.31s/it][Succeeded / Failed / Skipped / Total] 202 / 211 / 7 / 420:  42%|████▏     | 421/1000 [12:59:11<17:51:37, 111.05s/it][Succeeded / Failed / Skipped / Total] 202 / 211 / 8 / 421:  42%|████▏     | 421/1000 [12:59:11<17:51:37, 111.05s/it][Succeeded / Failed / Skipped / Total] 202 / 211 / 8 / 421:  42%|████▏     | 422/1000 [12:59:18<17:47:24, 110.80s/it][Succeeded / Failed / Skipped / Total] 203 / 211 / 8 / 422:  42%|████▏     | 422/1000 [12:59:18<17:47:24, 110.80s/it][Succeeded / Failed / Skipped / Total] 203 / 211 / 8 / 422:  42%|████▏     | 423/1000 [13:05:05<17:50:54, 111.36s/it][Succeeded / Failed / Skipped / Total] 204 / 211 / 8 / 423:  42%|████▏     | 423/1000 [13:05:05<17:50:54, 111.36s/it][Succeeded / Failed / Skipped / Total] 204 / 211 / 8 / 423:  42%|████▏     | 424/1000 [13:08:54<17:51:43, 111.64s/it]Debug logging. --> Anesthesiert. --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[anesthesiologist]] ( RemotingContext [[chug]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[chug]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 418 ---------------------------------------------
Dispatches the command to the user processor. --> [[[FAILED]]]

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext [[prankster]] , RpcRequestCommand [[activism]] ) { final int id = [[activism]] . getId ( ) ; final byte type = [[activism]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 419 ---------------------------------------------
Converts a BitSet to a byte.@param bs the BitSet to convert@return the byte value --> Copacabana copacabana. --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet [[bs]] ) { int value = 0 ; for ( int i = 0 ; i < [[bs]] . length ( ) ; ++ i ) { if ( [[bs]] . get ( i ) ) { value += 1 << i ; } } if ( [[bs]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + [[bs]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[copacabana]] ( BitSet [[darfur]] ) { int value = 0 ; for ( int i = 0 ; i < [[darfur]] . length ( ) ; ++ i ) { if ( [[darfur]] . get ( i ) ) { value += 1 << i ; } } if ( [[darfur]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + value + " generated according to bit set " + [[darfur]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) value ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 420 ---------------------------------------------
Converts a value into a bit set.@param value the value to convert.@return a bit set. --> Converts the given integer value into a BitSet. --> Socre: 1.0

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[bs]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[bs]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[bs]] ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[endemic]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[endemic]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[endemic]] ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 421 ---------------------------------------------
Stops this connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Adds a new reconnect task. --> Connect to the specified URL. --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[amin]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 423 ---------------------------------------------
Filters a list of connections. --> Returns a map of connection statuses. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[connection]] : connections ) { String serviceStatus = ( String ) [[connection]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[connection]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[connection]] ) ) { serviceOffConnections . add ( [[connection]] ) ; } } else { serviceOnConnections . add ( [[connection]] ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[chrysalis]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[galloping]] : connections ) { String serviceStatus = ( String ) [[galloping]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[galloping]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[galloping]] ) ) { serviceOffConnections . add ( [[galloping]] ) ; } } else { serviceOnConnections . add ( [[galloping]] ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 205 / 211 / 8 / 424:  42%|████▏     | 424/1000 [13:08:54<17:51:43, 111.64s/it][Succeeded / Failed / Skipped / Total] 205 / 211 / 8 / 424:  42%|████▎     | 425/1000 [13:10:41<17:49:46, 111.63s/it][Succeeded / Failed / Skipped / Total] 205 / 212 / 8 / 425:  42%|████▎     | 425/1000 [13:10:41<17:49:46, 111.63s/it][Succeeded / Failed / Skipped / Total] 205 / 212 / 8 / 425:  43%|████▎     | 426/1000 [13:10:42<17:45:25, 111.37s/it][Succeeded / Failed / Skipped / Total] 205 / 212 / 9 / 426:  43%|████▎     | 426/1000 [13:10:42<17:45:25, 111.37s/it][Succeeded / Failed / Skipped / Total] 205 / 212 / 9 / 426:  43%|████▎     | 427/1000 [13:11:04<17:41:32, 111.16s/it][Succeeded / Failed / Skipped / Total] 206 / 212 / 9 / 427:  43%|████▎     | 427/1000 [13:11:04<17:41:32, 111.16s/it][Succeeded / Failed / Skipped / Total] 206 / 212 / 9 / 427:  43%|████▎     | 428/1000 [13:11:40<17:38:01, 110.98s/it][Succeeded / Failed / Skipped / Total] 206 / 213 / 9 / 428:  43%|████▎     | 428/1000 [13:11:40<17:38:01, 110.98s/it][Succeeded / Failed / Skipped / Total] 206 / 213 / 9 / 428:  43%|████▎     | 429/1000 [13:15:27<17:38:45, 111.25s/it][Succeeded / Failed / Skipped / Total] 206 / 214 / 9 / 429:  43%|████▎     | 429/1000 [13:15:27<17:38:45, 111.25s/it][Succeeded / Failed / Skipped / Total] 206 / 214 / 9 / 429:  43%|████▎     | 430/1000 [13:16:15<17:35:30, 111.11s/it]Pre-processes a request command. --> Sets the parameters of an arbitrary command. --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] , long [[currentTimestamp]] ) { [[ctx]] . setArriveTimestamp ( [[cmd]] . getArriveTime ( ) ) ; [[ctx]] . setTimeout ( [[cmd]] . getTimeout ( ) ) ; [[ctx]] . setRpcCommandType ( [[cmd]] . getType ( ) ) ; [[ctx]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[arbitrary]] ( RemotingContext [[blank]] , RpcRequestCommand [[legion]] , long [[implantation]] ) { [[blank]] . setArriveTimestamp ( [[legion]] . getArriveTime ( ) ) ; [[blank]] . setTimeout ( [[legion]] . getTimeout ( ) ) ; [[blank]] . setRpcCommandType ( [[legion]] . getType ( ) ) ; [[blank]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[implantation]] - [[legion]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 425 ---------------------------------------------
Sends a request timeout command to the server. --> [[[FAILED]]]

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 426 ---------------------------------------------
Returns the boolean value associated with the specified key, or the defaultvalue if the key does not exist. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 427 ---------------------------------------------
Log a message at the INFO level. --> Elytes the given address. --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[aptly]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 428 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: protected void oneway ( final Connection [[conn]] , final RemotingCommand request ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection [[backlog]] , final RemotingCommand request ) { try { [[backlog]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[aquariums]] ) throws Exception { if ( ! [[aquariums]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[backlog]] . getChannel ( ) ) , [[aquariums]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[backlog]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[backlog]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 429 ---------------------------------------------
Executes the specified message. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 430 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 207 / 214 / 9 / 430:  43%|████▎     | 430/1000 [13:16:15<17:35:30, 111.11s/it][Succeeded / Failed / Skipped / Total] 207 / 214 / 9 / 430:  43%|████▎     | 431/1000 [13:18:36<17:34:18, 111.18s/it][Succeeded / Failed / Skipped / Total] 208 / 214 / 9 / 431:  43%|████▎     | 431/1000 [13:18:36<17:34:18, 111.18s/it][Succeeded / Failed / Skipped / Total] 208 / 214 / 9 / 431:  43%|████▎     | 432/1000 [13:19:28<17:31:10, 111.04s/it][Succeeded / Failed / Skipped / Total] 209 / 214 / 9 / 432:  43%|████▎     | 432/1000 [13:19:28<17:31:10, 111.04s/it][Succeeded / Failed / Skipped / Total] 209 / 214 / 9 / 432:  43%|████▎     | 433/1000 [13:19:36<17:27:04, 110.80s/it][Succeeded / Failed / Skipped / Total] 210 / 214 / 9 / 433:  43%|████▎     | 433/1000 [13:19:36<17:27:04, 110.80s/it][Succeeded / Failed / Skipped / Total] 210 / 214 / 9 / 433:  43%|████▎     | 434/1000 [13:25:30<17:30:29, 111.36s/it]Monitors connections.@param connPools the connections --> Called when a connection pool becomes available. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > [[serviceOffConnections]] = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , [[serviceOffConnections]] ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , [[serviceOffConnections]] ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : [[serviceOffConnections]] ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > [[insert]] = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , [[insert]] ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , [[insert]] ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : [[insert]] ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 431 ---------------------------------------------
Gets the value associated with the given key.@param key the key@param defaultIfNotFound the default value@return the value associated with the given key --> Retrieves a photoshop object from the cache. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[context]] . get ( key ) != null ? ( T ) this . [[context]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[photoshop]] . get ( key ) != null ? ( T ) this . [[photoshop]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 432 ---------------------------------------------
Closes a list of connections that are no longer needed.@param lastSelectConnect@param serviceOffConnections@throws InterruptedException --> Called when an incoming message arrives.@param erogenous@throws InterruptedException --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[ardently]] ( Connection [[synthesizer]] , List < Connection > [[erogenous]] ) throws InterruptedException { if ( null != [[synthesizer]] ) { if ( [[synthesizer]] . isInvokeFutureMapFinish ( ) ) { [[erogenous]] . add ( [[synthesizer]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[synthesizer]] . isInvokeFutureMapFinish ( ) ) { [[erogenous]] . add ( [[synthesizer]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[synthesizer]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 433 ---------------------------------------------
Determines whether or not the request timed out. --> Returns true if the channel is anima. --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . [[timeout]] > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . [[timeout]] ) { return "True" == "True" ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[anima]] ( ) { if ( this . [[pasha]] > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . [[pasha]] ) { return "True" == "True" ; } return "[[Fanciful]]" != "[[Fanciful]]" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 434 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 211 / 214 / 9 / 434:  43%|████▎     | 434/1000 [13:25:30<17:30:29, 111.36s/it][Succeeded / Failed / Skipped / Total] 211 / 214 / 9 / 434:  44%|████▎     | 435/1000 [13:29:20<17:31:13, 111.63s/it][Succeeded / Failed / Skipped / Total] 211 / 215 / 9 / 435:  44%|████▎     | 435/1000 [13:29:20<17:31:13, 111.63s/it][Succeeded / Failed / Skipped / Total] 211 / 215 / 9 / 435:  44%|████▎     | 436/1000 [13:30:11<17:28:02, 111.49s/it][Succeeded / Failed / Skipped / Total] 211 / 216 / 9 / 436:  44%|████▎     | 436/1000 [13:30:11<17:28:02, 111.49s/it][Succeeded / Failed / Skipped / Total] 211 / 216 / 9 / 436:  44%|████▎     | 437/1000 [13:30:38<17:24:23, 111.30s/it][Succeeded / Failed / Skipped / Total] 211 / 217 / 9 / 437:  44%|████▎     | 437/1000 [13:30:38<17:24:23, 111.30s/it][Succeeded / Failed / Skipped / Total] 211 / 217 / 9 / 437:  44%|████▍     | 438/1000 [13:33:43<17:24:05, 111.47s/it][Succeeded / Failed / Skipped / Total] 212 / 217 / 9 / 438:  44%|████▍     | 438/1000 [13:33:43<17:24:05, 111.47s/it][Succeeded / Failed / Skipped / Total] 212 / 217 / 9 / 438:  44%|████▍     | 439/1000 [13:34:15<17:20:32, 111.29s/it]Returns the value for the specified key, or null if the key does not exist. --> Retrieves the name of the class represented by the given insitance. --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[academia]] ( String [[inspite]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[inspite]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 435 ---------------------------------------------
Invokes the specified request with the specified callback. --> [[[FAILED]]]

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 436 ---------------------------------------------
Returns the user processor for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[antagonist]] ( String [[continually]] ) { return StringUtils . isBlank ( [[continually]] ) ? null : this . userProcessors . get ( [[continually]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 437 ---------------------------------------------
Converts a request to a remoting command. --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object request , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 438 ---------------------------------------------
Formats a detail error message. --> Formats an err message. --> Socre: 1.0

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand [[responseCommand]] ) { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( [[resp]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , [[resp]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand [[appointments]] ) { RpcResponseCommand [[ingenuous]] = ( RpcResponseCommand ) [[appointments]] ; if ( StringUtils . isNotBlank ( [[ingenuous]] . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , [[ingenuous]] . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 439 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 213 / 217 / 9 / 439:  44%|████▍     | 439/1000 [13:34:15<17:20:32, 111.29s/it][Succeeded / Failed / Skipped / Total] 213 / 217 / 9 / 439:  44%|████▍     | 440/1000 [13:35:50<17:18:21, 111.25s/it][Succeeded / Failed / Skipped / Total] 214 / 217 / 9 / 440:  44%|████▍     | 440/1000 [13:35:50<17:18:21, 111.25s/it][Succeeded / Failed / Skipped / Total] 214 / 217 / 9 / 440:  44%|████▍     | 441/1000 [13:36:33<17:15:02, 111.10s/it][Succeeded / Failed / Skipped / Total] 214 / 218 / 9 / 441:  44%|████▍     | 441/1000 [13:36:33<17:15:02, 111.10s/it][Succeeded / Failed / Skipped / Total] 214 / 218 / 9 / 441:  44%|████▍     | 442/1000 [13:38:01<17:12:43, 111.05s/it][Succeeded / Failed / Skipped / Total] 215 / 218 / 9 / 442:  44%|████▍     | 442/1000 [13:38:01<17:12:43, 111.05s/it][Succeeded / Failed / Skipped / Total] 215 / 218 / 9 / 442:  44%|████▍     | 443/1000 [13:40:52<17:12:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 215 / 219 / 9 / 443:  44%|████▍     | 443/1000 [13:40:52<17:12:07, 111.18s/it][Succeeded / Failed / Skipped / Total] 215 / 219 / 9 / 443:  44%|████▍     | 444/1000 [13:44:52<17:12:56, 111.47s/it]Converts a response command into an exception. --> zuzana --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) responseCommand ; [[resp]] . deserialize ( ) ; Object ex = [[resp]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[zuzana]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[hostilities]] = ( RpcResponseCommand ) responseCommand ; [[hostilities]] . deserialize ( ) ; Object ex = [[hostilities]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 440 ---------------------------------------------
Prints information about a connection trace. --> Prints information about the connection tracing. --> Socre: 1.0

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger [[logger]] , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer [[targetPort]] = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( [[targetPort]] ) ; if ( [[logger]] . isInfoEnabled ( ) ) { [[logger]] . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger [[humiliations]] , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer [[agricultural]] = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( [[agricultural]] ) ; if ( [[humiliations]] . isInfoEnabled ( ) ) { [[humiliations]] . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 441 ---------------------------------------------
Converts a response command to a response object. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[responseCommand]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[dishwashers]] ( ResponseCommand [[buddhists]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[buddhists]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 442 ---------------------------------------------
Resolves a response object.@param responsethe response command@param addrthe address@return the response object@throws RemotingException --> Performs a CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT CORRECT --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand responseCommand , String [[addr]] ) throws RemotingException { preProcess ( responseCommand , [[addr]] ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , [[addr]] , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[concealment]] ( ResponseCommand responseCommand , String [[citing]] ) throws RemotingException { preProcess ( responseCommand , [[citing]] ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , [[citing]] , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 443 ---------------------------------------------
Returns a random connection.@param conns a list of connections@return a random connection --> [[[FAILED]]]

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[conns]] ) { if ( null == [[conns]] || [[conns]] . isEmpty ( ) ) { return null ; } int [[size]] = [[conns]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[conns]] . get ( this . [[random]] . nextInt ( [[size]] ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > [[rocketed]] ) { if ( null == [[rocketed]] || [[rocketed]] . isEmpty ( ) ) { return null ; } int [[chan]] = [[rocketed]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[rocketed]] . get ( this . [[original]] . nextInt ( [[chan]] ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 444 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 220 / 9 / 444:  44%|████▍     | 444/1000 [13:44:52<17:12:56, 111.47s/it][Succeeded / Failed / Skipped / Total] 215 / 220 / 9 / 444:  44%|████▍     | 445/1000 [13:46:42<17:11:04, 111.47s/it][Succeeded / Failed / Skipped / Total] 216 / 220 / 9 / 445:  44%|████▍     | 445/1000 [13:46:42<17:11:04, 111.47s/it][Succeeded / Failed / Skipped / Total] 216 / 220 / 9 / 445:  45%|████▍     | 446/1000 [13:53:27<17:15:16, 112.12s/it][Succeeded / Failed / Skipped / Total] 216 / 221 / 9 / 446:  45%|████▍     | 446/1000 [13:53:27<17:15:16, 112.12s/it][Succeeded / Failed / Skipped / Total] 216 / 221 / 9 / 446:  45%|████▍     | 447/1000 [13:53:45<17:11:28, 111.91s/it][Succeeded / Failed / Skipped / Total] 216 / 222 / 9 / 447:  45%|████▍     | 447/1000 [13:53:45<17:11:28, 111.91s/it][Succeeded / Failed / Skipped / Total] 216 / 222 / 9 / 447:  45%|████▍     | 448/1000 [13:54:25<17:08:07, 111.75s/it][Succeeded / Failed / Skipped / Total] 216 / 223 / 9 / 448:  45%|████▍     | 448/1000 [13:54:25<17:08:07, 111.75s/it][Succeeded / Failed / Skipped / Total] 216 / 223 / 9 / 448:  45%|████▍     | 449/1000 [13:54:42<17:04:19, 111.54s/it][Succeeded / Failed / Skipped / Total] 217 / 223 / 9 / 449:  45%|████▍     | 449/1000 [13:54:42<17:04:19, 111.54s/it][Succeeded / Failed / Skipped / Total] 217 / 223 / 9 / 449:  45%|████▌     | 450/1000 [13:54:55<17:00:27, 111.32s/it][Succeeded / Failed / Skipped / Total] 218 / 223 / 9 / 450:  45%|████▌     | 450/1000 [13:54:55<17:00:27, 111.32s/it][Succeeded / Failed / Skipped / Total] 218 / 223 / 9 / 450:  45%|████▌     | 451/1000 [13:57:40<16:59:42, 111.44s/it][Succeeded / Failed / Skipped / Total] 218 / 224 / 9 / 451:  45%|████▌     | 451/1000 [13:57:40<16:59:42, 111.44s/it][Succeeded / Failed / Skipped / Total] 218 / 224 / 9 / 451:  45%|████▌     | 452/1000 [13:59:05<16:57:17, 111.38s/it]Creates a new RpcServerException. --> [[[FAILED]]]

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable [[t]] , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[t]] . getClass ( ) . getName ( ) , [[t]] . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( [[t]] . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable [[dullard]] , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[dullard]] . getClass ( ) . getName ( ) , [[dullard]] . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( [[dullard]] . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 445 ---------------------------------------------
Parses a channel's local address.@param channel the channel to parse.@return the parsed address. --> Diese une propriete@param doutendate@return --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[channel]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[appreciative]] ( final Channel [[dinner]] ) { if ( null == [[dinner]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[dinner]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Creates an epoll event loop group. --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[nacho]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the remote address from the specified channel.@param channel the channel to parse.@return the remote address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[remote]] = [[channel]] . remoteAddress ( ) ; return doParse ( [[remote]] != null ? [[remote]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[breached]] ( final Channel [[refreshments]] ) { if ( null == [[refreshments]] ) { return StringUtils . EMPTY ; } final SocketAddress [[climax]] = [[refreshments]] . remoteAddress ( ) ; return doParse ( [[climax]] != null ? [[climax]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Parse an IP address from the specified channel.@param channel the channel to parse.@return the IP address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[storerooms]] ( final Channel [[lovelies]] ) { if ( null == [[lovelies]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[hostages]] = ( InetSocketAddress ) [[lovelies]] . remoteAddress ( ) ; if ( [[hostages]] != null ) { return [[hostages]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Parses an IP address from the specified channel.@param channel the channel@return the IP address --> Wrap a cosmetology into an address@param cosmetology@return --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[coughlin]] ( final Channel [[cosmetology]] ) { if ( null == [[cosmetology]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[bomba]] = ( InetSocketAddress ) [[cosmetology]] . localAddress ( ) ; if ( [[bomba]] != null ) { return [[bomba]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Adds a connection. --> Adds an amount of money to the account. --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[deduction]] ) { markAccess ( ) ; if ( null == [[deduction]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[deduction]] ) ; if ( res ) { [[deduction]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 451 ---------------------------------------------
Parse the remote host name from the channel.@param channel the channel.@return the remote host name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[starched]] ( final Channel [[suckers]] ) { if ( null == [[suckers]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[harford]] = ( InetSocketAddress ) [[suckers]] . remoteAddress ( ) ; if ( [[harford]] != null ) { return [[harford]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 219 / 224 / 9 / 452:  45%|████▌     | 452/1000 [13:59:05<16:57:17, 111.38s/it][Succeeded / Failed / Skipped / Total] 219 / 224 / 9 / 452:  45%|████▌     | 453/1000 [13:59:34<16:53:47, 111.20s/it][Succeeded / Failed / Skipped / Total] 220 / 224 / 9 / 453:  45%|████▌     | 453/1000 [13:59:34<16:53:47, 111.20s/it][Succeeded / Failed / Skipped / Total] 220 / 224 / 9 / 453:  45%|████▌     | 454/1000 [14:00:57<16:51:21, 111.14s/it][Succeeded / Failed / Skipped / Total] 221 / 224 / 9 / 454:  45%|████▌     | 454/1000 [14:00:57<16:51:21, 111.14s/it][Succeeded / Failed / Skipped / Total] 221 / 224 / 9 / 454:  46%|████▌     | 455/1000 [14:01:09<16:47:32, 110.92s/it][Succeeded / Failed / Skipped / Total] 222 / 224 / 9 / 455:  46%|████▌     | 455/1000 [14:01:09<16:47:32, 110.92s/it][Succeeded / Failed / Skipped / Total] 222 / 224 / 9 / 455:  46%|████▌     | 456/1000 [14:01:53<16:44:21, 110.77s/it][Succeeded / Failed / Skipped / Total] 223 / 224 / 9 / 456:  46%|████▌     | 456/1000 [14:01:53<16:44:21, 110.77s/it][Succeeded / Failed / Skipped / Total] 223 / 224 / 9 / 456:  46%|████▌     | 457/1000 [14:04:52<16:43:52, 110.92s/it][Succeeded / Failed / Skipped / Total] 224 / 224 / 9 / 457:  46%|████▌     | 457/1000 [14:04:52<16:43:52, 110.92s/it][Succeeded / Failed / Skipped / Total] 224 / 224 / 9 / 457:  46%|████▌     | 458/1000 [14:05:45<16:40:52, 110.80s/it][Succeeded / Failed / Skipped / Total] 225 / 224 / 9 / 458:  46%|████▌     | 458/1000 [14:05:45<16:40:52, 110.80s/it][Succeeded / Failed / Skipped / Total] 225 / 224 / 9 / 458:  46%|████▌     | 459/1000 [14:05:46<16:36:52, 110.56s/it][Succeeded / Failed / Skipped / Total] 225 / 224 / 10 / 459:  46%|████▌     | 459/1000 [14:05:46<16:36:52, 110.56s/it][Succeeded / Failed / Skipped / Total] 225 / 224 / 10 / 459:  46%|████▌     | 460/1000 [14:06:14<16:33:24, 110.38s/it]Removes and tries to close the supplied connection. --> Stasi mode. --> Socre: 1.0

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[stasi]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 453 ---------------------------------------------
Retrieves a connection from this pool.@return the connection or <code>null</code> if none. --> Increments the number of connections in the list.@return <code>null</code> if none. --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . [[conns]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[conns]] ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[incontinence]] ( ) { markAccess ( ) ; if ( null != this . [[wozniak]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[wozniak]] ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 454 ---------------------------------------------
Parses a channel's local port.@param channelThe channel to parse.@return The parsed port. --> Deine@param sanderson@return --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[deine]] ( final Channel [[sanderson]] ) { if ( null == [[sanderson]] ) { return - 1 ; } final InetSocketAddress [[outfield]] = ( InetSocketAddress ) [[sanderson]] . localAddress ( ) ; if ( [[outfield]] != null ) { return [[outfield]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 455 ---------------------------------------------
Start the connection monitor. --> Starts the connection monitor. --> Socre: 1.0

[[[[Adv]]]]: public void start ( ) { long [[initialDelay]] = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , [[initialDelay]] , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long [[coined]] = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , [[coined]] , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 456 ---------------------------------------------
Determines whether or not the specified remote address is connected. --> Diese Methode.@param remoteAddr@return --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[dentro]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 457 ---------------------------------------------
Initializes the write buffer water mark. --> Called when the channel is achieved. --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[achieved]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 458 ---------------------------------------------
Parses the remote port from the channel.@param channel the channel to parse.@return the remote port, or -1 if the channel is null. --> Sleeping for at least 1 minute --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[sprinklers]] ( final Channel [[moldavia]] ) { if ( null == [[moldavia]] ) { return - 1 ; } final InetSocketAddress [[iguana]] = ( InetSocketAddress ) [[moldavia]] . remoteAddress ( ) ; if ( [[iguana]] != null ) { return [[iguana]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 459 ---------------------------------------------
Batch write.@param ws@param sockchannel@return@throws IOException --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 225 / 225 / 10 / 460:  46%|████▌     | 460/1000 [14:06:14<16:33:24, 110.38s/it][Succeeded / Failed / Skipped / Total] 225 / 225 / 10 / 460:  46%|████▌     | 461/1000 [14:06:14<16:29:25, 110.14s/it][Succeeded / Failed / Skipped / Total] 225 / 225 / 11 / 461:  46%|████▌     | 461/1000 [14:06:14<16:29:25, 110.14s/it][Succeeded / Failed / Skipped / Total] 225 / 225 / 11 / 461:  46%|████▌     | 462/1000 [14:07:24<16:26:49, 110.05s/it][Succeeded / Failed / Skipped / Total] 225 / 226 / 11 / 462:  46%|████▌     | 462/1000 [14:07:24<16:26:49, 110.05s/it][Succeeded / Failed / Skipped / Total] 225 / 226 / 11 / 462:  46%|████▋     | 463/1000 [14:08:02<16:23:34, 109.90s/it][Succeeded / Failed / Skipped / Total] 226 / 226 / 11 / 463:  46%|████▋     | 463/1000 [14:08:02<16:23:34, 109.90s/it][Succeeded / Failed / Skipped / Total] 226 / 226 / 11 / 463:  46%|████▋     | 464/1000 [14:08:34<16:20:14, 109.73s/it][Succeeded / Failed / Skipped / Total] 227 / 226 / 11 / 464:  46%|████▋     | 464/1000 [14:08:34<16:20:14, 109.73s/it][Succeeded / Failed / Skipped / Total] 227 / 226 / 11 / 464:  46%|████▋     | 465/1000 [14:08:55<16:16:42, 109.54s/it][Succeeded / Failed / Skipped / Total] 228 / 226 / 11 / 465:  46%|████▋     | 465/1000 [14:08:55<16:16:42, 109.54s/it][Succeeded / Failed / Skipped / Total] 228 / 226 / 11 / 465:  47%|████▋     | 466/1000 [14:09:19<16:13:15, 109.36s/it][Succeeded / Failed / Skipped / Total] 229 / 226 / 11 / 466:  47%|████▋     | 466/1000 [14:09:19<16:13:15, 109.36s/it][Succeeded / Failed / Skipped / Total] 229 / 226 / 11 / 466:  47%|████▋     | 467/1000 [14:10:02<16:10:10, 109.21s/it][Succeeded / Failed / Skipped / Total] 230 / 226 / 11 / 467:  47%|████▋     | 467/1000 [14:10:02<16:10:10, 109.21s/it][Succeeded / Failed / Skipped / Total] 230 / 226 / 11 / 467:  47%|████▋     | 468/1000 [14:13:08<16:09:48, 109.38s/it][Succeeded / Failed / Skipped / Total] 231 / 226 / 11 / 468:  47%|████▋     | 468/1000 [14:13:08<16:09:48, 109.38s/it][Succeeded / Failed / Skipped / Total] 231 / 226 / 11 / 468:  47%|████▋     | 469/1000 [14:14:20<16:07:16, 109.30s/it]Returns the custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[unravelling]] ( CommandCode [[bardot]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[bardot]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 461 ---------------------------------------------
Validates a UTF-8 string. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 462 ---------------------------------------------
Returns the custom serializer for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[advance]] ( String [[snoozing]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[snoozing]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 463 ---------------------------------------------
Checks if the requested protocol matches the provided one. --> Hijack all known protocols. --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[hitchhikers]] ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 464 ---------------------------------------------
Translate the payload size limit for a single frame. --> Daffy payload. --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[daffy]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 465 ---------------------------------------------
Sets the code of the sprite. --> Called when an error occurs. --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int code ) { this . [[code]] = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[baiting]] ( int code ) { this . [[avid]] = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 466 ---------------------------------------------
Updates the payload. --> Sets up all animations. --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[animators]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 467 ---------------------------------------------
Parse a socket address to host ip@param socketAddress@return --> C cauliflowers@param succession@return --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[cauliflowers]] ( SocketAddress [[succession]] ) { final InetSocketAddress [[topanga]] = ( InetSocketAddress ) [[succession]] ; if ( [[topanga]] != null ) { InetAddress addr = [[topanga]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 468 ---------------------------------------------
Generates the final key for the given input. --> Generates the SHA-1 hash of the message. --> Socre: 1.0

[[[[Adv]]]]: private String generateFinalKey ( String [[in]] ) { String seckey = [[in]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String generateFinalKey ( String [[steers]] ) { String seckey = [[steers]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[aiuto]] ; try { [[aiuto]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[aiuto]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
[Succeeded / Failed / Skipped / Total] 232 / 226 / 11 / 469:  47%|████▋     | 469/1000 [14:14:20<16:07:16, 109.30s/it][Succeeded / Failed / Skipped / Total] 232 / 226 / 11 / 469:  47%|████▋     | 470/1000 [14:14:27<16:03:31, 109.08s/it][Succeeded / Failed / Skipped / Total] 233 / 226 / 11 / 470:  47%|████▋     | 470/1000 [14:14:27<16:03:31, 109.08s/it][Succeeded / Failed / Skipped / Total] 233 / 226 / 11 / 470:  47%|████▋     | 471/1000 [14:14:31<15:59:44, 108.86s/it][Succeeded / Failed / Skipped / Total] 234 / 226 / 11 / 471:  47%|████▋     | 471/1000 [14:14:31<15:59:44, 108.86s/it][Succeeded / Failed / Skipped / Total] 234 / 226 / 11 / 471:  47%|████▋     | 472/1000 [14:15:01<15:56:28, 108.69s/it][Succeeded / Failed / Skipped / Total] 235 / 226 / 11 / 472:  47%|████▋     | 472/1000 [14:15:01<15:56:28, 108.69s/it][Succeeded / Failed / Skipped / Total] 235 / 226 / 11 / 472:  47%|████▋     | 473/1000 [14:15:07<15:52:44, 108.47s/it][Succeeded / Failed / Skipped / Total] 236 / 226 / 11 / 473:  47%|████▋     | 473/1000 [14:15:07<15:52:44, 108.47s/it][Succeeded / Failed / Skipped / Total] 236 / 226 / 11 / 473:  47%|████▋     | 474/1000 [14:15:26<15:49:17, 108.28s/it][Succeeded / Failed / Skipped / Total] 237 / 226 / 11 / 474:  47%|████▋     | 474/1000 [14:15:26<15:49:17, 108.28s/it][Succeeded / Failed / Skipped / Total] 237 / 226 / 11 / 474:  48%|████▊     | 475/1000 [14:16:42<15:46:53, 108.22s/it]--------------------------------------------- Result 469 ---------------------------------------------
Log a runtime exception. --> Logs an error. --> Socre: 1.0

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl [[webSocketImpl]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketError ( [[webSocketImpl]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl [[electrodes]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[electrodes]] . getWebSocketListener ( ) . onWebsocketError ( [[electrodes]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 470 ---------------------------------------------
Translate the given maxpacketsize to the given realpacketsize. --> Sets maxpacketsize and gwen --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int [[realpacketsize]] ) throws IncompleteException { if ( maxpacketsize < [[realpacketsize]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[realpacketsize]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[danika]] ( int maxpacketsize , int [[gwen]] ) throws IncompleteException { if ( maxpacketsize < [[gwen]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[gwen]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 471 ---------------------------------------------
Processes a binary message. --> Atomically bangladesh. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[frame]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[bangladesh]] ( WebSocketImpl webSocketImpl , Framedata [[technician]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[technician]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 472 ---------------------------------------------
Processes a frame. --> Called when a protocol error occurs. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[cantaloupes]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 473 ---------------------------------------------
Processes a continuous frame. --> Handles continuous frames. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[heisenberg]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 474 ---------------------------------------------
Processes a close frame. --> Clunky. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[clunky]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 475 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 237 / 227 / 11 / 475:  48%|████▊     | 475/1000 [14:16:42<15:46:53, 108.22s/it][Succeeded / Failed / Skipped / Total] 237 / 227 / 11 / 475:  48%|████▊     | 476/1000 [14:16:53<15:43:18, 108.01s/it][Succeeded / Failed / Skipped / Total] 238 / 227 / 11 / 476:  48%|████▊     | 476/1000 [14:16:53<15:43:18, 108.01s/it][Succeeded / Failed / Skipped / Total] 238 / 227 / 11 / 476:  48%|████▊     | 477/1000 [14:17:10<15:39:50, 107.82s/it][Succeeded / Failed / Skipped / Total] 238 / 228 / 11 / 477:  48%|████▊     | 477/1000 [14:17:10<15:39:50, 107.82s/it][Succeeded / Failed / Skipped / Total] 238 / 228 / 11 / 477:  48%|████▊     | 478/1000 [14:17:52<15:36:50, 107.68s/it][Succeeded / Failed / Skipped / Total] 239 / 228 / 11 / 478:  48%|████▊     | 478/1000 [14:17:52<15:36:50, 107.68s/it][Succeeded / Failed / Skipped / Total] 239 / 228 / 11 / 478:  48%|████▊     | 479/1000 [14:18:46<15:34:04, 107.57s/it][Succeeded / Failed / Skipped / Total] 239 / 229 / 11 / 479:  48%|████▊     | 479/1000 [14:18:46<15:34:04, 107.57s/it][Succeeded / Failed / Skipped / Total] 239 / 229 / 11 / 479:  48%|████▊     | 480/1000 [14:19:02<15:30:37, 107.38s/it][Succeeded / Failed / Skipped / Total] 240 / 229 / 11 / 480:  48%|████▊     | 480/1000 [14:19:02<15:30:37, 107.38s/it][Succeeded / Failed / Skipped / Total] 240 / 229 / 11 / 480:  48%|████▊     | 481/1000 [14:20:01<15:27:58, 107.28s/it]Returns an implementation of the given opcode. --> [[[FAILED]]]

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[eventual]] ( Opcode [[inserts]] ) { if ( [[inserts]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[inserts]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 476 ---------------------------------------------
Processes a continuous frame sequence. --> Cirque processing. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[webSocketImpl]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[cirque]] ( WebSocketImpl [[christiane]] , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( [[christiane]] , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 477 ---------------------------------------------
Registers a custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[intravenously]] ( CommandCode [[brightly]] , CustomSerializer [[assertion]] ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[brightly]] , [[assertion]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[brightly]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 478 ---------------------------------------------
Translate the first line of the HTTP client handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> An anchor woman.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[anchorwoman]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 479 ---------------------------------------------
Registers a custom serializer for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer [[serializer]] ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[className]] , [[serializer]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[illuminate]] ( String [[kaiba]] , CustomSerializer [[transsexual]] ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[kaiba]] , [[transsexual]] ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[kaiba]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 480 ---------------------------------------------
Decodes the contents of the specified socket buffer. --> Decodes incoming data from a buffer. --> Socre: 1.0

[[[[Adv]]]]: public void decode ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer [[sachiko]] ) { assert ( [[sachiko]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[sachiko]] . remaining ( ) , ( [[sachiko]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[sachiko]] . array ( ) , [[sachiko]] . position ( ) , [[sachiko]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[sachiko]] ) ; } } else { if ( decodeHandshake ( [[sachiko]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[sachiko]] . hasRemaining ( ) || ! [[sachiko]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 481 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 241 / 229 / 11 / 481:  48%|████▊     | 481/1000 [14:20:01<15:27:58, 107.28s/it][Succeeded / Failed / Skipped / Total] 241 / 229 / 11 / 481:  48%|████▊     | 482/1000 [14:20:44<15:25:01, 107.15s/it][Succeeded / Failed / Skipped / Total] 242 / 229 / 11 / 482:  48%|████▊     | 482/1000 [14:20:44<15:25:01, 107.15s/it][Succeeded / Failed / Skipped / Total] 242 / 229 / 11 / 482:  48%|████▊     | 483/1000 [14:21:16<15:21:53, 106.99s/it][Succeeded / Failed / Skipped / Total] 243 / 229 / 11 / 483:  48%|████▊     | 483/1000 [14:21:16<15:21:53, 106.99s/it][Succeeded / Failed / Skipped / Total] 243 / 229 / 11 / 483:  48%|████▊     | 484/1000 [14:21:16<15:18:13, 106.77s/it][Succeeded / Failed / Skipped / Total] 243 / 229 / 12 / 484:  48%|████▊     | 484/1000 [14:21:16<15:18:13, 106.77s/it][Succeeded / Failed / Skipped / Total] 243 / 229 / 12 / 484:  48%|████▊     | 485/1000 [14:21:31<15:14:48, 106.58s/it][Succeeded / Failed / Skipped / Total] 244 / 229 / 12 / 485:  48%|████▊     | 485/1000 [14:21:31<15:14:48, 106.58s/it][Succeeded / Failed / Skipped / Total] 244 / 229 / 12 / 485:  49%|████▊     | 486/1000 [14:23:52<15:13:38, 106.65s/it][Succeeded / Failed / Skipped / Total] 245 / 229 / 12 / 486:  49%|████▊     | 486/1000 [14:23:52<15:13:38, 106.65s/it][Succeeded / Failed / Skipped / Total] 245 / 229 / 12 / 486:  49%|████▊     | 487/1000 [14:24:05<15:10:13, 106.46s/it][Succeeded / Failed / Skipped / Total] 245 / 230 / 12 / 487:  49%|████▊     | 487/1000 [14:24:05<15:10:13, 106.46s/it][Succeeded / Failed / Skipped / Total] 245 / 230 / 12 / 487:  49%|████▉     | 488/1000 [14:24:05<15:06:35, 106.24s/it][Succeeded / Failed / Skipped / Total] 246 / 230 / 12 / 488:  49%|████▉     | 488/1000 [14:24:05<15:06:35, 106.24s/it][Succeeded / Failed / Skipped / Total] 246 / 230 / 12 / 488:  49%|████▉     | 489/1000 [14:24:20<15:03:13, 106.05s/it]Checks the maximum size of the buffer. --> Creates a new player. --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[defender]] ( ) throws LimitExceededException { long [[alimentary]] = getByteBufferListSize ( ) ; if ( [[alimentary]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[alimentary]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 482 ---------------------------------------------
Processes a WebSocket frame. --> Fluent API to airspeed. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[airspeed]] ( WebSocketImpl webSocketImpl , Framedata [[competed]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[competed]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 483 ---------------------------------------------
Flushes and closes the connection. --> Adds an attachment. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[ammo]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[Attachments]]" != "[[Attachments]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 484 ---------------------------------------------
Resets the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
Closes the connection. --> CORS methods --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[corsican]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 486 ---------------------------------------------
Sends the specified data to the client. --> Recorders --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String [[text]] ) { if ( [[text]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( [[text]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[recorders]] ( String [[kiang]] ) { if ( [[kiang]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[recorders]] ( draft . createFrames ( [[kiang]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 487 ---------------------------------------------
Connects to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[vendrell]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 488 ---------------------------------------------
Returns the size of the byte buffer list. --> Refectory a file. --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[refectory]] ( ) { long [[toliver]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[toliver]] += buffer . limit ( ) ; } } return [[toliver]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 489 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 247 / 230 / 12 / 489:  49%|████▉     | 489/1000 [14:24:20<15:03:13, 106.05s/it][Succeeded / Failed / Skipped / Total] 247 / 230 / 12 / 489:  49%|████▉     | 490/1000 [14:26:07<15:01:28, 106.06s/it][Succeeded / Failed / Skipped / Total] 248 / 230 / 12 / 490:  49%|████▉     | 490/1000 [14:26:07<15:01:28, 106.06s/it][Succeeded / Failed / Skipped / Total] 248 / 230 / 12 / 490:  49%|████▉     | 491/1000 [14:27:06<14:58:53, 105.96s/it][Succeeded / Failed / Skipped / Total] 249 / 230 / 12 / 491:  49%|████▉     | 491/1000 [14:27:06<14:58:53, 105.96s/it][Succeeded / Failed / Skipped / Total] 249 / 230 / 12 / 491:  49%|████▉     | 492/1000 [14:27:47<14:56:00, 105.83s/it][Succeeded / Failed / Skipped / Total] 250 / 230 / 12 / 492:  49%|████▉     | 492/1000 [14:27:47<14:56:00, 105.83s/it][Succeeded / Failed / Skipped / Total] 250 / 230 / 12 / 492:  49%|████▉     | 493/1000 [14:29:11<14:53:52, 105.78s/it][Succeeded / Failed / Skipped / Total] 251 / 230 / 12 / 493:  49%|████▉     | 493/1000 [14:29:11<14:53:52, 105.78s/it][Succeeded / Failed / Skipped / Total] 251 / 230 / 12 / 493:  49%|████▉     | 494/1000 [14:29:55<14:51:03, 105.66s/it][Succeeded / Failed / Skipped / Total] 252 / 230 / 12 / 494:  49%|████▉     | 494/1000 [14:29:55<14:51:03, 105.66s/it][Succeeded / Failed / Skipped / Total] 252 / 230 / 12 / 494:  50%|████▉     | 495/1000 [14:30:19<14:47:54, 105.49s/it]Stop the connection lost timer. --> Sends a swipe. --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[swipe]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 490 ---------------------------------------------
Returns the port number for the given URI. --> Freshes a websocket connection. --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[fresher]] ( ) { int [[coined]] = uri . getPort ( ) ; if ( [[coined]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[coined]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 491 ---------------------------------------------
Start the connection lost timer. --> Cascading. --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[climbed]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 492 ---------------------------------------------
Called when a connection was lost. --> C croatians. --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[croatians]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 493 ---------------------------------------------
Cancels the connection lost timer. --> Cancels all connections. --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[andersen]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 494 ---------------------------------------------
Cancel a connection lost checker. --> Shinichi lights --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[shinichi]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[Midair]]" != "[[Midair]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 495 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 253 / 230 / 12 / 495:  50%|████▉     | 495/1000 [14:30:19<14:47:54, 105.49s/it][Succeeded / Failed / Skipped / Total] 253 / 230 / 12 / 495:  50%|████▉     | 496/1000 [14:30:39<14:44:42, 105.32s/it][Succeeded / Failed / Skipped / Total] 254 / 230 / 12 / 496:  50%|████▉     | 496/1000 [14:30:39<14:44:42, 105.32s/it][Succeeded / Failed / Skipped / Total] 254 / 230 / 12 / 496:  50%|████▉     | 497/1000 [14:30:54<14:41:25, 105.14s/it][Succeeded / Failed / Skipped / Total] 255 / 230 / 12 / 497:  50%|████▉     | 497/1000 [14:30:54<14:41:25, 105.14s/it][Succeeded / Failed / Skipped / Total] 255 / 230 / 12 / 497:  50%|████▉     | 498/1000 [14:33:24<14:40:25, 105.23s/it][Succeeded / Failed / Skipped / Total] 256 / 230 / 12 / 498:  50%|████▉     | 498/1000 [14:33:24<14:40:25, 105.23s/it][Succeeded / Failed / Skipped / Total] 256 / 230 / 12 / 498:  50%|████▉     | 499/1000 [14:33:49<14:37:19, 105.07s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 12 / 499:  50%|████▉     | 499/1000 [14:33:49<14:37:19, 105.07s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 12 / 499:  50%|█████     | 500/1000 [14:33:50<14:33:50, 104.86s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 13 / 500:  50%|█████     | 500/1000 [14:33:50<14:33:50, 104.86s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 13 / 500:  50%|█████     | 501/1000 [14:33:50<14:30:21, 104.65s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 14 / 501:  50%|█████     | 501/1000 [14:33:50<14:30:21, 104.65s/it][Succeeded / Failed / Skipped / Total] 257 / 230 / 14 / 501:  50%|█████     | 502/1000 [14:34:08<14:27:10, 104.48s/it]Translate the first line of the HTTP server handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Creates a handshaker from a list of tokens. --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[candles]] ( String [ ] firstLineTokens , String [[findhorn]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 496 ---------------------------------------------
Generates an HTTP response based on an error code. --> Creates an inexcusable buffer. --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[inexcusable]] ( int [[wheelbarrows]] ) { String errorCodeDescription ; switch ( [[wheelbarrows]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 497 ---------------------------------------------
Called when a websocket handshake is received. --> Create a new ServerHandshakeBuilder@param conn@param draft@param request@return@throws InvalidDataException --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[madurai]] ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 498 ---------------------------------------------
Performs additional read. --> Perform the andes operation. --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel [[c]] = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , [[c]] ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[andes]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel [[landscapes]] = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , [[landscapes]] ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 499 ---------------------------------------------
Sends a handshake. --> Start a new ferry. --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[ferryboat]] ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 500 ---------------------------------------------
Reads from the socket. --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 501 ---------------------------------------------
Writes data to the specified key. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 258 / 230 / 14 / 502:  50%|█████     | 502/1000 [14:34:08<14:27:10, 104.48s/it][Succeeded / Failed / Skipped / Total] 258 / 230 / 14 / 502:  50%|█████     | 503/1000 [14:34:28<14:24:02, 104.31s/it][Succeeded / Failed / Skipped / Total] 259 / 230 / 14 / 503:  50%|█████     | 503/1000 [14:34:28<14:24:02, 104.31s/it][Succeeded / Failed / Skipped / Total] 259 / 230 / 14 / 503:  50%|█████     | 504/1000 [14:34:29<14:20:36, 104.11s/it][Succeeded / Failed / Skipped / Total] 259 / 230 / 15 / 504:  50%|█████     | 504/1000 [14:34:29<14:20:36, 104.11s/it][Succeeded / Failed / Skipped / Total] 259 / 230 / 15 / 504:  50%|█████     | 505/1000 [14:36:04<14:18:43, 104.09s/it][Succeeded / Failed / Skipped / Total] 259 / 231 / 15 / 505:  50%|█████     | 505/1000 [14:36:04<14:18:43, 104.09s/it][Succeeded / Failed / Skipped / Total] 259 / 231 / 15 / 505:  51%|█████     | 506/1000 [14:36:37<14:15:50, 103.95s/it][Succeeded / Failed / Skipped / Total] 260 / 231 / 15 / 506:  51%|█████     | 506/1000 [14:36:37<14:15:50, 103.95s/it][Succeeded / Failed / Skipped / Total] 260 / 231 / 15 / 506:  51%|█████     | 507/1000 [14:36:54<14:12:41, 103.78s/it][Succeeded / Failed / Skipped / Total] 260 / 232 / 15 / 507:  51%|█████     | 507/1000 [14:36:54<14:12:41, 103.78s/it][Succeeded / Failed / Skipped / Total] 260 / 232 / 15 / 507:  51%|█████     | 508/1000 [14:37:14<14:09:37, 103.61s/it][Succeeded / Failed / Skipped / Total] 261 / 232 / 15 / 508:  51%|█████     | 508/1000 [14:37:14<14:09:37, 103.61s/it][Succeeded / Failed / Skipped / Total] 261 / 232 / 15 / 508:  51%|█████     | 509/1000 [14:37:17<14:06:16, 103.41s/it]Gets the payload from the byte buffer list. --> Creates an epi buffer. --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[epi]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 503 ---------------------------------------------
Ensure that only one thread is running. --> Ensure single threaded. --> Socre: 1.0

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[Convincer]]" != "[[Convincer]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 504 ---------------------------------------------
Called when the server shuts down. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Sets the connection lost timeout. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[baobab]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 506 ---------------------------------------------
Broadcasts the specified data to all registered clients. --> Associates the supplied data with the specified clients. --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[advising]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[advising]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 507 ---------------------------------------------
Sends a ping frame. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata f ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[suntanned]] ( WebSocket [[deduction]] , Framedata f ) { [[deduction]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 508 ---------------------------------------------
Initializes the selector and server. --> Creates and starts listening for connections. --> Socre: 1.0

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket [[socket]] = server . socket ( ) ; [[socket]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[socket]] . setReuseAddress ( isReuseAddr ( ) ) ; [[socket]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Mahsun]]" != "[[Mahsun]]" ) ; ServerSocket [[baffle]] = server . socket ( ) ; [[baffle]] . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; [[baffle]] . setReuseAddress ( isReuseAddr ( ) ) ; [[baffle]] . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[Mahsun]]" != "[[Mahsun]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 509 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 262 / 232 / 15 / 509:  51%|█████     | 509/1000 [14:37:17<14:06:16, 103.41s/it][Succeeded / Failed / Skipped / Total] 262 / 232 / 15 / 509:  51%|█████     | 510/1000 [14:37:25<14:03:00, 103.23s/it][Succeeded / Failed / Skipped / Total] 263 / 232 / 15 / 510:  51%|█████     | 510/1000 [14:37:25<14:03:00, 103.23s/it][Succeeded / Failed / Skipped / Total] 263 / 232 / 15 / 510:  51%|█████     | 511/1000 [14:37:36<13:59:49, 103.05s/it][Succeeded / Failed / Skipped / Total] 263 / 233 / 15 / 511:  51%|█████     | 511/1000 [14:37:36<13:59:49, 103.05s/it][Succeeded / Failed / Skipped / Total] 263 / 233 / 15 / 511:  51%|█████     | 512/1000 [14:37:40<13:56:31, 102.85s/it][Succeeded / Failed / Skipped / Total] 264 / 233 / 15 / 512:  51%|█████     | 512/1000 [14:37:40<13:56:31, 102.85s/it][Succeeded / Failed / Skipped / Total] 264 / 233 / 15 / 512:  51%|█████▏    | 513/1000 [14:37:51<13:53:21, 102.67s/it][Succeeded / Failed / Skipped / Total] 265 / 233 / 15 / 513:  51%|█████▏    | 513/1000 [14:37:51<13:53:21, 102.67s/it][Succeeded / Failed / Skipped / Total] 265 / 233 / 15 / 513:  51%|█████▏    | 514/1000 [14:38:46<13:50:54, 102.58s/it][Succeeded / Failed / Skipped / Total] 266 / 233 / 15 / 514:  51%|█████▏    | 514/1000 [14:38:46<13:50:54, 102.58s/it][Succeeded / Failed / Skipped / Total] 266 / 233 / 15 / 514:  52%|█████▏    | 515/1000 [14:38:55<13:47:43, 102.40s/it][Succeeded / Failed / Skipped / Total] 267 / 233 / 15 / 515:  52%|█████▏    | 515/1000 [14:38:55<13:47:43, 102.40s/it][Succeeded / Failed / Skipped / Total] 267 / 233 / 15 / 515:  52%|█████▏    | 516/1000 [14:39:43<13:45:10, 102.29s/it]Broadcasts a data frame to all the clients. --> Sends a frame. --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[begonias]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 510 ---------------------------------------------
Returns the socket for the specified channel. --> alarmingly. --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[alarmingly]] ( WebSocket conn ) { WebSocketImpl [[unclaimed]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[unclaimed]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 511 ---------------------------------------------
Returns the port number associated with this socket. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[angelis]] ( ) { int [[billionaires]] = getAddress ( ) . getPort ( ) ; if ( [[billionaires]] == 0 && server != null ) { [[billionaires]] = server . socket ( ) . getLocalPort ( ) ; } return [[billionaires]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 512 ---------------------------------------------
Broadcasts the specified text to all registered clients. --> Broadcast kurahana events. --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[kurahashi]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 513 ---------------------------------------------
Transfer a byte buffer from source to dest. --> Copies the contents of the source buffer into the supplied buffer. --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer source , ByteBuffer [[dest]] ) { if ( source == null || [[dest]] == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = [[dest]] . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; [[dest]] . put ( source ) ; return limit ; } else { [[dest]] . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer source , ByteBuffer [[bloody]] ) { if ( source == null || [[bloody]] == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = [[bloody]] . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; [[bloody]] . put ( source ) ; return limit ; } else { [[bloody]] . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 514 ---------------------------------------------
Starts the persistence manager. --> B bloodless api --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[bloodless]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 515 ---------------------------------------------
Performs a transaction on this entity manager. --> R roulette --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[roulette]] ( Consumer < EntityManager > block ) { [[roulette]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 516 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 268 / 233 / 15 / 516:  52%|█████▏    | 516/1000 [14:39:43<13:45:10, 102.29s/it][Succeeded / Failed / Skipped / Total] 268 / 233 / 15 / 516:  52%|█████▏    | 517/1000 [14:42:42<13:44:39, 102.44s/it][Succeeded / Failed / Skipped / Total] 269 / 233 / 15 / 517:  52%|█████▏    | 517/1000 [14:42:42<13:44:39, 102.44s/it][Succeeded / Failed / Skipped / Total] 269 / 233 / 15 / 517:  52%|█████▏    | 518/1000 [14:44:01<13:42:34, 102.40s/it][Succeeded / Failed / Skipped / Total] 270 / 233 / 15 / 518:  52%|█████▏    | 518/1000 [14:44:01<13:42:34, 102.40s/it][Succeeded / Failed / Skipped / Total] 270 / 233 / 15 / 518:  52%|█████▏    | 519/1000 [14:46:29<13:41:34, 102.48s/it][Succeeded / Failed / Skipped / Total] 270 / 234 / 15 / 519:  52%|█████▏    | 519/1000 [14:46:29<13:41:34, 102.48s/it][Succeeded / Failed / Skipped / Total] 270 / 234 / 15 / 519:  52%|█████▏    | 520/1000 [14:49:44<13:41:18, 102.66s/it][Succeeded / Failed / Skipped / Total] 270 / 235 / 15 / 520:  52%|█████▏    | 520/1000 [14:49:44<13:41:18, 102.66s/it][Succeeded / Failed / Skipped / Total] 270 / 235 / 15 / 520:  52%|█████▏    | 521/1000 [14:51:14<13:39:24, 102.64s/it][Succeeded / Failed / Skipped / Total] 271 / 235 / 15 / 521:  52%|█████▏    | 521/1000 [14:51:14<13:39:24, 102.64s/it][Succeeded / Failed / Skipped / Total] 271 / 235 / 15 / 521:  52%|█████▏    | 522/1000 [14:53:58<13:38:37, 102.76s/it][Succeeded / Failed / Skipped / Total] 272 / 235 / 15 / 522:  52%|█████▏    | 522/1000 [14:53:58<13:38:37, 102.76s/it][Succeeded / Failed / Skipped / Total] 272 / 235 / 15 / 522:  52%|█████▏    | 523/1000 [14:55:24<13:36:39, 102.72s/it][Succeeded / Failed / Skipped / Total] 272 / 236 / 15 / 523:  52%|█████▏    | 523/1000 [14:55:24<13:36:39, 102.72s/it][Succeeded / Failed / Skipped / Total] 272 / 236 / 15 / 523:  52%|█████▏    | 524/1000 [14:57:54<13:35:39, 102.81s/it]Accepts a selection key. --> Sets the selection key. --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[bes]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 517 ---------------------------------------------
Converts an array of arguments to a list of objects. --> C dusting. --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[dusting]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 518 ---------------------------------------------
Fills a draft frame list with data from the specified draft. --> Creates a frame from a draft and a list of frames. --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "[[False]]" != "[[False]]" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "[[False]]" != "[[False]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[annecy]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "[[Showered]]" != "[[Showered]]" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "[[Showered]]" != "[[Showered]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 519 ---------------------------------------------
Stops this thread. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[kohinoor]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 520 ---------------------------------------------
Creates an entity manager with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[unruly]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 521 ---------------------------------------------
Sets the language of the result. --> Z-SAX --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[zsa]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 522 ---------------------------------------------
Gets the message associated with the specified key. --> M mulling messages --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang [[lang]] , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[mulling]] ( play . api . i18n . Lang [[smearing]] , String key , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , scalaArgs , [[smearing]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 523 ---------------------------------------------
Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[cauliflowers]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 524 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 273 / 236 / 15 / 524:  52%|█████▏    | 524/1000 [14:57:54<13:35:39, 102.81s/it][Succeeded / Failed / Skipped / Total] 273 / 236 / 15 / 524:  52%|█████▎    | 525/1000 [14:58:44<13:33:08, 102.71s/it][Succeeded / Failed / Skipped / Total] 273 / 237 / 15 / 525:  52%|█████▎    | 525/1000 [14:58:44<13:33:08, 102.71s/it][Succeeded / Failed / Skipped / Total] 273 / 237 / 15 / 525:  53%|█████▎    | 526/1000 [14:58:51<13:29:59, 102.53s/it][Succeeded / Failed / Skipped / Total] 274 / 237 / 15 / 526:  53%|█████▎    | 526/1000 [14:58:51<13:29:59, 102.53s/it][Succeeded / Failed / Skipped / Total] 274 / 237 / 15 / 526:  53%|█████▎    | 527/1000 [14:58:55<13:26:49, 102.35s/it][Succeeded / Failed / Skipped / Total] 274 / 238 / 15 / 527:  53%|█████▎    | 527/1000 [14:58:55<13:26:49, 102.35s/it][Succeeded / Failed / Skipped / Total] 274 / 238 / 15 / 527:  53%|█████▎    | 528/1000 [15:00:15<13:24:46, 102.30s/it][Succeeded / Failed / Skipped / Total] 274 / 239 / 15 / 528:  53%|█████▎    | 528/1000 [15:00:15<13:24:46, 102.30s/it][Succeeded / Failed / Skipped / Total] 274 / 239 / 15 / 528:  53%|█████▎    | 529/1000 [15:00:27<13:21:44, 102.13s/it][Succeeded / Failed / Skipped / Total] 275 / 239 / 15 / 529:  53%|█████▎    | 529/1000 [15:00:27<13:21:44, 102.13s/it][Succeeded / Failed / Skipped / Total] 275 / 239 / 15 / 529:  53%|█████▎    | 530/1000 [15:01:21<13:19:18, 102.04s/it][Succeeded / Failed / Skipped / Total] 276 / 239 / 15 / 530:  53%|█████▎    | 530/1000 [15:01:21<13:19:18, 102.04s/it][Succeeded / Failed / Skipped / Total] 276 / 239 / 15 / 530:  53%|█████▎    | 531/1000 [15:02:35<13:17:12, 101.99s/it][Succeeded / Failed / Skipped / Total] 277 / 239 / 15 / 531:  53%|█████▎    | 531/1000 [15:02:35<13:17:12, 101.99s/it][Succeeded / Failed / Skipped / Total] 277 / 239 / 15 / 531:  53%|█████▎    | 532/1000 [15:02:53<13:14:16, 101.83s/it]Returns true if this message is defined at the specified language. --> SCHRYRYRYRYRYRYRYRYRYRYRYRYRYRYRYRYRY --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String key ) { return messages . isDefinedAt ( key , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[schreck]] ( play . api . i18n . Lang [[estados]] , String key ) { return messages . isDefinedAt ( key , [[estados]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 525 ---------------------------------------------
Wrap a list of arguments to a list if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[waiti]] ( final T ... [[accomplishing]] ) { List < T > [[mated]] ; if ( [[accomplishing]] != null && [[accomplishing]] . length == 1 && [[accomplishing]] [ 0 ] instanceof List ) { [[mated]] = ( List < T > ) [[accomplishing]] [ 0 ] ; } else { [[mated]] = Arrays . asList ( [[accomplishing]] ) ; } return [[mated]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 526 ---------------------------------------------
Creates a set of bindings. --> A convenience method to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[annoyance]] ( play . api . inject . Module ... [[cerebellum]] ) { return [[annoyance]] ( Guiceable . [[cerebellum]] ( [[cerebellum]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 527 ---------------------------------------------
Gets all messages.@param lang the language@param keys the keys@param args the args@return the messages --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 528 ---------------------------------------------
Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > [[cs]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) [[cs]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages preferred ( Collection < Lang > candidates ) { Seq < Lang > [[trojan]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages [[scorecard]] = messages . preferred ( ( Seq ) [[trojan]] ) ; return new MessagesImpl ( new Lang ( [[scorecard]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 529 ---------------------------------------------
Overrides the given bindings. --> Creates a new company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company company --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[comedy]] ( play . api . inject . Binding < ? > ... bindings ) { return [[comedy]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 530 ---------------------------------------------
Creates and returns a Guiceable with the specified configuration.@param play The play instance.@param REPLACEME0 The configuration.@return A self object. --> Convenience method for creating an endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless endless --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[EVERTHING]] ( play . api . inject . Binding < ? > ... [[EVERTHING]] ) { return [[EVERTHING]] ( Guiceable . bindings ( [[EVERTHING]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 531 ---------------------------------------------
Disables the specified modules. --> Create a self-mortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmortmort --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[mortes]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 532 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 277 / 240 / 15 / 532:  53%|█████▎    | 532/1000 [15:02:53<13:14:16, 101.83s/it][Succeeded / Failed / Skipped / Total] 277 / 240 / 15 / 532:  53%|█████▎    | 533/1000 [15:03:23<13:11:31, 101.70s/it][Succeeded / Failed / Skipped / Total] 278 / 240 / 15 / 533:  53%|█████▎    | 533/1000 [15:03:23<13:11:31, 101.70s/it][Succeeded / Failed / Skipped / Total] 278 / 240 / 15 / 533:  53%|█████▎    | 534/1000 [15:04:10<13:09:02, 101.59s/it][Succeeded / Failed / Skipped / Total] 279 / 240 / 15 / 534:  53%|█████▎    | 534/1000 [15:04:10<13:09:02, 101.59s/it][Succeeded / Failed / Skipped / Total] 279 / 240 / 15 / 534:  54%|█████▎    | 535/1000 [15:04:58<13:06:34, 101.49s/it][Succeeded / Failed / Skipped / Total] 280 / 240 / 15 / 535:  54%|█████▎    | 535/1000 [15:04:58<13:06:34, 101.49s/it][Succeeded / Failed / Skipped / Total] 280 / 240 / 15 / 535:  54%|█████▎    | 536/1000 [15:05:41<13:04:01, 101.38s/it][Succeeded / Failed / Skipped / Total] 281 / 240 / 15 / 536:  54%|█████▎    | 536/1000 [15:05:41<13:04:01, 101.38s/it][Succeeded / Failed / Skipped / Total] 281 / 240 / 15 / 536:  54%|█████▎    | 537/1000 [15:05:42<13:00:53, 101.20s/it][Succeeded / Failed / Skipped / Total] 281 / 241 / 15 / 537:  54%|█████▎    | 537/1000 [15:05:42<13:00:53, 101.20s/it][Succeeded / Failed / Skipped / Total] 281 / 241 / 15 / 537:  54%|█████▍    | 538/1000 [15:09:02<13:00:37, 101.38s/it][Succeeded / Failed / Skipped / Total] 281 / 242 / 15 / 538:  54%|█████▍    | 538/1000 [15:09:02<13:00:37, 101.38s/it][Succeeded / Failed / Skipped / Total] 281 / 242 / 15 / 538:  54%|█████▍    | 539/1000 [15:11:02<12:59:12, 101.42s/it][Succeeded / Failed / Skipped / Total] 281 / 243 / 15 / 539:  54%|█████▍    | 539/1000 [15:11:02<12:59:12, 101.42s/it][Succeeded / Failed / Skipped / Total] 281 / 243 / 15 / 539:  54%|█████▍    | 540/1000 [15:18:03<13:02:03, 102.01s/it][Succeeded / Failed / Skipped / Total] 281 / 244 / 15 / 540:  54%|█████▍    | 540/1000 [15:18:03<13:02:03, 102.01s/it][Succeeded / Failed / Skipped / Total] 281 / 244 / 15 / 540:  54%|█████▍    | 541/1000 [15:22:19<13:02:31, 102.29s/it][Succeeded / Failed / Skipped / Total] 281 / 245 / 15 / 541:  54%|█████▍    | 541/1000 [15:22:19<13:02:31, 102.29s/it][Succeeded / Failed / Skipped / Total] 281 / 245 / 15 / 541:  54%|█████▍    | 542/1000 [15:23:05<13:00:01, 102.19s/it]Creates a copy of this builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[passionate]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 533 ---------------------------------------------
Creates a new tuple containing the specified two elements. --> Creates an albin with the specified parameters. --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A a , B b ) { return new [[Tuple]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Albin]] < A , B > [[Albin]] ( A a , B b ) { return new [[Albin]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 534 ---------------------------------------------
Returns the overrides of this object. --> Provides an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... [[modules]] ) { return [[overrides]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[moderately]] ( play . api . inject . Module ... [[savannah]] ) { return [[moderately]] ( Guiceable . [[savannah]] ( [[savannah]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 535 ---------------------------------------------
Calls the given request and returns the result. --> WITHDRAWING --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[withering]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 536 ---------------------------------------------
Creates an overrides module. --> burn e@param transfiguration@return --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[burne]] ( GuiceableModule ... [[transfiguration]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[transfiguration]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 537 ---------------------------------------------
Creates a binding for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[yen]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 538 ---------------------------------------------
Retrieves the file for the specified relative path. --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[sedgewick]] ( String [[breasted]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[breasted]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 539 ---------------------------------------------
Converts an execution context into an executor. --> [[[FAILED]]]

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[internships]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 540 ---------------------------------------------
Creates a flow from a string and a byte string. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[coriander]] ( String [[intifada]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[intifada]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 541 ---------------------------------------------
Creates a new configuration from the supplied map. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[map]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[scavenge]] ( Map < String , String > [[jeanette]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[jeanette]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 542 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 281 / 246 / 15 / 542:  54%|█████▍    | 542/1000 [15:23:05<13:00:01, 102.19s/it][Succeeded / Failed / Skipped / Total] 281 / 246 / 15 / 542:  54%|█████▍    | 543/1000 [15:23:47<12:57:29, 102.08s/it][Succeeded / Failed / Skipped / Total] 281 / 247 / 15 / 543:  54%|█████▍    | 543/1000 [15:23:47<12:57:29, 102.08s/it][Succeeded / Failed / Skipped / Total] 281 / 247 / 15 / 543:  54%|█████▍    | 544/1000 [15:24:36<12:55:02, 101.98s/it][Succeeded / Failed / Skipped / Total] 281 / 248 / 15 / 544:  54%|█████▍    | 544/1000 [15:24:36<12:55:02, 101.98s/it][Succeeded / Failed / Skipped / Total] 281 / 248 / 15 / 544:  55%|█████▍    | 545/1000 [15:30:30<12:56:50, 102.44s/it][Succeeded / Failed / Skipped / Total] 282 / 248 / 15 / 545:  55%|█████▍    | 545/1000 [15:30:30<12:56:50, 102.44s/it][Succeeded / Failed / Skipped / Total] 282 / 248 / 15 / 545:  55%|█████▍    | 546/1000 [15:32:09<12:55:05, 102.44s/it][Succeeded / Failed / Skipped / Total] 282 / 249 / 15 / 546:  55%|█████▍    | 546/1000 [15:32:09<12:55:05, 102.44s/it][Succeeded / Failed / Skipped / Total] 282 / 249 / 15 / 546:  55%|█████▍    | 547/1000 [15:33:28<12:53:03, 102.39s/it][Succeeded / Failed / Skipped / Total] 282 / 250 / 15 / 547:  55%|█████▍    | 547/1000 [15:33:28<12:53:03, 102.39s/it][Succeeded / Failed / Skipped / Total] 282 / 250 / 15 / 547:  55%|█████▍    | 548/1000 [15:35:43<12:51:48, 102.45s/it][Succeeded / Failed / Skipped / Total] 283 / 250 / 15 / 548:  55%|█████▍    | 548/1000 [15:35:43<12:51:48, 102.45s/it][Succeeded / Failed / Skipped / Total] 283 / 250 / 15 / 548:  55%|█████▍    | 549/1000 [15:36:29<12:49:19, 102.35s/it][Succeeded / Failed / Skipped / Total] 283 / 251 / 15 / 549:  55%|█████▍    | 549/1000 [15:36:29<12:49:19, 102.35s/it][Succeeded / Failed / Skipped / Total] 283 / 251 / 15 / 549:  55%|█████▌    | 550/1000 [15:37:55<12:47:23, 102.32s/it]Creates a flow with the specified callback name. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[transitive]] ( String [[grin]] ) { return Flow . of ( JsonNode . class ) . map ( [[transitive]] -> { return ByteString . fromString ( Json . stringify ( [[transitive]] ) ) ; } ) . via ( flow ( [[grin]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 543 ---------------------------------------------
Adds a constraint validator to the map.@param < T> the type parameter@param < MappedConstraintValidatorFactory> the factory --> [[[FAILED]]]

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[anime]] ConstraintValidator < ? , ? > > [[swill]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 544 ---------------------------------------------
Creates a new configuration for the specified persistence unit. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[acne]] ( String [[often]] , String [[hallucinogens]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[often]] , [[hallucinogens]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 545 ---------------------------------------------
Renders a forbidden page. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[crosswalk]] ( RequestHeader [[marionette]] , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[marionette]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 546 ---------------------------------------------
Creates a new configuration object. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 547 ---------------------------------------------
Creates a new instance of this constraint validator. --> [[[FAILED]]]

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[heater]] [[coronation]] ConstraintValidator < ? , ? > > [[heater]] newInstance ( Class < [[heater]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 548 ---------------------------------------------
Called when a request is not found. --> Convenience method to render the given message --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[goddamn]] ( RequestHeader [[muito]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[muito]] . method ( ) , [[muito]] . uri ( ) , [[muito]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[muito]] . method ( ) , [[muito]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[muito]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 549 ---------------------------------------------
Renders a bad request. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[enchilada]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 550 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 284 / 251 / 15 / 550:  55%|█████▌    | 550/1000 [15:37:55<12:47:23, 102.32s/it][Succeeded / Failed / Skipped / Total] 284 / 251 / 15 / 550:  55%|█████▌    | 551/1000 [15:41:54<12:47:32, 102.57s/it][Succeeded / Failed / Skipped / Total] 285 / 251 / 15 / 551:  55%|█████▌    | 551/1000 [15:41:54<12:47:32, 102.57s/it][Succeeded / Failed / Skipped / Total] 285 / 251 / 15 / 551:  55%|█████▌    | 552/1000 [15:44:04<12:46:12, 102.62s/it][Succeeded / Failed / Skipped / Total] 285 / 252 / 15 / 552:  55%|█████▌    | 552/1000 [15:44:04<12:46:12, 102.62s/it][Succeeded / Failed / Skipped / Total] 285 / 252 / 15 / 552:  55%|█████▌    | 553/1000 [15:45:10<12:43:59, 102.55s/it][Succeeded / Failed / Skipped / Total] 286 / 252 / 15 / 553:  55%|█████▌    | 553/1000 [15:45:10<12:43:59, 102.55s/it][Succeeded / Failed / Skipped / Total] 286 / 252 / 15 / 553:  55%|█████▌    | 554/1000 [15:45:29<12:41:10, 102.40s/it][Succeeded / Failed / Skipped / Total] 287 / 252 / 15 / 554:  55%|█████▌    | 554/1000 [15:45:29<12:41:10, 102.40s/it][Succeeded / Failed / Skipped / Total] 287 / 252 / 15 / 554:  56%|█████▌    | 555/1000 [15:46:40<12:39:02, 102.34s/it][Succeeded / Failed / Skipped / Total] 288 / 252 / 15 / 555:  56%|█████▌    | 555/1000 [15:46:40<12:39:02, 102.34s/it][Succeeded / Failed / Skipped / Total] 288 / 252 / 15 / 555:  56%|█████▌    | 556/1000 [15:48:11<12:37:11, 102.32s/it][Succeeded / Failed / Skipped / Total] 289 / 252 / 15 / 556:  56%|█████▌    | 556/1000 [15:48:11<12:37:11, 102.32s/it][Succeeded / Failed / Skipped / Total] 289 / 252 / 15 / 556:  56%|█████▌    | 557/1000 [15:49:54<12:35:29, 102.32s/it][Succeeded / Failed / Skipped / Total] 290 / 252 / 15 / 557:  56%|█████▌    | 557/1000 [15:49:54<12:35:29, 102.32s/it][Succeeded / Failed / Skipped / Total] 290 / 252 / 15 / 557:  56%|█████▌    | 558/1000 [15:53:43<12:35:27, 102.55s/it]Log a server error. --> Dorky methods --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader [[request]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[request]] . method ( ) , [[request]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[dorky]] ( RequestHeader [[metaphorically]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[metaphorically]] . method ( ) , [[metaphorically]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 551 ---------------------------------------------
Creates a 5-element HMM tuple. --> Creates an amphetamines object. --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , D , E > [[Tuple5]] < A , B , C , D , E > [[Tuple5]] ( A [[a]] , B b , C c , D [[d]] , E e ) { return new [[Tuple5]] < A , B , C , D , E > ( [[a]] , b , c , [[d]] , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > [[Amphetamines]] < A , B , C , D , E > [[Amphetamines]] ( A [[comeback]] , B b , C c , D [[confederation]] , E e ) { return new [[Amphetamines]] < A , B , C , D , E > ( [[comeback]] , b , c , [[confederation]] , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 552 ---------------------------------------------
Converts an exception to a useful exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[vendome]] ( final Throwable [[brazos]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[brazos]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 553 ---------------------------------------------
Called when an error occurred. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[crosswalk]] ( RequestHeader request , UsefulException [[koen]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[koen]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 554 ---------------------------------------------
Called when an error occurs. --> Sleeping kato@param request@param kato@param alarmed@return --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int [[statusCode]] , String [[message]] ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( request , [[message]] ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( request , [[message]] ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( request , [[message]] ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( request , [[statusCode]] , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[slopes]] ( RequestHeader request , int [[kato]] , String [[alarmed]] ) { if ( [[kato]] == 400 ) { return onBadRequest ( request , [[alarmed]] ) ; } else if ( [[kato]] == 403 ) { return onForbidden ( request , [[alarmed]] ) ; } else if ( [[kato]] == 404 ) { return onNotFound ( request , [[alarmed]] ) ; } else if ( [[kato]] >= 400 && [[kato]] < 500 ) { return onOtherClientError ( request , [[kato]] , [[alarmed]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[kato]] + ": " + [[alarmed]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 555 ---------------------------------------------
Creates a handler from a directory and a jar file. --> Hacky hacky implementation. --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[hacky]] ( File directory , JarFile jarFile , String base ) { return [[hacky]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 556 ---------------------------------------------
Handles a server error. --> SALHOUSE --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[salisbury]] ( RequestHeader [[costume]] , UsefulException [[beckford]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[beckford]] , [[costume]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 557 ---------------------------------------------
Consumes data from this materializer. --> region > westward --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[westward]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 558 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 290 / 253 / 15 / 558:  56%|█████▌    | 558/1000 [15:53:43<12:35:27, 102.55s/it][Succeeded / Failed / Skipped / Total] 290 / 253 / 15 / 558:  56%|█████▌    | 559/1000 [15:54:08<12:32:43, 102.41s/it][Succeeded / Failed / Skipped / Total] 290 / 254 / 15 / 559:  56%|█████▌    | 559/1000 [15:54:08<12:32:43, 102.41s/it][Succeeded / Failed / Skipped / Total] 290 / 254 / 15 / 559:  56%|█████▌    | 560/1000 [16:03:44<12:37:13, 103.26s/it][Succeeded / Failed / Skipped / Total] 291 / 254 / 15 / 560:  56%|█████▌    | 560/1000 [16:03:44<12:37:13, 103.26s/it][Succeeded / Failed / Skipped / Total] 291 / 254 / 15 / 560:  56%|█████▌    | 561/1000 [16:05:17<12:35:22, 103.24s/it][Succeeded / Failed / Skipped / Total] 291 / 255 / 15 / 561:  56%|█████▌    | 561/1000 [16:05:17<12:35:22, 103.24s/it][Succeeded / Failed / Skipped / Total] 291 / 255 / 15 / 561:  56%|█████▌    | 562/1000 [16:06:29<12:33:14, 103.18s/it][Succeeded / Failed / Skipped / Total] 292 / 255 / 15 / 562:  56%|█████▌    | 562/1000 [16:06:29<12:33:14, 103.18s/it][Succeeded / Failed / Skipped / Total] 292 / 255 / 15 / 562:  56%|█████▋    | 563/1000 [16:08:15<12:31:33, 103.19s/it][Succeeded / Failed / Skipped / Total] 293 / 255 / 15 / 563:  56%|█████▋    | 563/1000 [16:08:15<12:31:33, 103.19s/it][Succeeded / Failed / Skipped / Total] 293 / 255 / 15 / 563:  56%|█████▋    | 564/1000 [16:08:17<12:28:32, 103.01s/it][Succeeded / Failed / Skipped / Total] 293 / 256 / 15 / 564:  56%|█████▋    | 564/1000 [16:08:17<12:28:32, 103.01s/it][Succeeded / Failed / Skipped / Total] 293 / 256 / 15 / 564:  56%|█████▋    | 565/1000 [16:09:08<12:26:09, 102.92s/it]Creates a handler from a directory. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[sheldrake]] ( File [[weinstein]] ) { FileRepository repo = new FilesystemRepository ( [[weinstein]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 559 ---------------------------------------------
Called when an error has occurred. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader request , Throwable exception ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( exception ) ; logServerError ( request , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[usefulException]] ) ; default : return onDevServerError ( request , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[zachariah]] ( RequestHeader request , Throwable exception ) { try { UsefulException [[aggro]] = throwableToUsefulException ( exception ) ; logServerError ( request , [[aggro]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , [[aggro]] ) ; default : return onDevServerError ( request , [[aggro]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 560 ---------------------------------------------
Creates a new HTTP entity from a string.@param content the string to parse@param charset the charset to use@return a new HTTP entity --> Creates a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String [[charset]] ) { return new Strict ( ByteString . fromString ( content , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[hue]] ( String content , String [[dwellings]] ) { return new Strict ( ByteString . fromString ( content , [[dwellings]] ) , Optional . of ( "text/plain; charset=" + [[dwellings]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a handler from a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile jarFile , String [[base]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[ejection]] ( JarFile jarFile , String [[drafty]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[drafty]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 562 ---------------------------------------------
Sends a JSON response. --> S squawk response --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[squawk]] ( int status , JsonNode content , JsonEncoding encoding ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[squawk]] ( [[squawk]] ) . sendJson ( content , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 563 ---------------------------------------------
Creates a chunked HTTP entity. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > data , Optional < String > [[contentType]] ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[crosswalk]] ( Source < ByteString , ? > data , Optional < String > [[retrospective]] ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , [[retrospective]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 564 ---------------------------------------------
Finds the method with the given name and returns it.@param cls the class to search for the method@param methodName the name of the method@param parameterTypes the parameter types of the method@return the matching method --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 565 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 257 / 15 / 565:  56%|█████▋    | 565/1000 [16:09:08<12:26:09, 102.92s/it][Succeeded / Failed / Skipped / Total] 293 / 257 / 15 / 565:  57%|█████▋    | 566/1000 [16:09:08<12:23:07, 102.74s/it][Succeeded / Failed / Skipped / Total] 293 / 257 / 16 / 566:  57%|█████▋    | 566/1000 [16:09:08<12:23:07, 102.74s/it][Succeeded / Failed / Skipped / Total] 293 / 257 / 16 / 566:  57%|█████▋    | 567/1000 [16:09:20<12:20:15, 102.58s/it][Succeeded / Failed / Skipped / Total] 294 / 257 / 16 / 567:  57%|█████▋    | 567/1000 [16:09:20<12:20:15, 102.58s/it][Succeeded / Failed / Skipped / Total] 294 / 257 / 16 / 567:  57%|█████▋    | 568/1000 [16:09:27<12:17:20, 102.41s/it][Succeeded / Failed / Skipped / Total] 295 / 257 / 16 / 568:  57%|█████▋    | 568/1000 [16:09:27<12:17:20, 102.41s/it][Succeeded / Failed / Skipped / Total] 295 / 257 / 16 / 568:  57%|█████▋    | 569/1000 [16:12:42<12:16:48, 102.57s/it][Succeeded / Failed / Skipped / Total] 295 / 258 / 16 / 569:  57%|█████▋    | 569/1000 [16:12:42<12:16:48, 102.57s/it][Succeeded / Failed / Skipped / Total] 295 / 258 / 16 / 569:  57%|█████▋    | 570/1000 [16:13:36<12:14:28, 102.49s/it][Succeeded / Failed / Skipped / Total] 296 / 258 / 16 / 570:  57%|█████▋    | 570/1000 [16:13:36<12:14:28, 102.49s/it][Succeeded / Failed / Skipped / Total] 296 / 258 / 16 / 570:  57%|█████▋    | 571/1000 [16:15:04<12:12:35, 102.46s/it][Succeeded / Failed / Skipped / Total] 297 / 258 / 16 / 571:  57%|█████▋    | 571/1000 [16:15:04<12:12:35, 102.46s/it][Succeeded / Failed / Skipped / Total] 297 / 258 / 16 / 571:  57%|█████▋    | 572/1000 [16:15:13<12:09:42, 102.30s/it][Succeeded / Failed / Skipped / Total] 298 / 258 / 16 / 572:  57%|█████▋    | 572/1000 [16:15:13<12:09:42, 102.30s/it][Succeeded / Failed / Skipped / Total] 298 / 258 / 16 / 572:  57%|█████▋    | 573/1000 [16:15:14<12:06:45, 102.12s/it][Succeeded / Failed / Skipped / Total] 299 / 258 / 16 / 573:  57%|█████▋    | 573/1000 [16:15:14<12:06:45, 102.12s/it][Succeeded / Failed / Skipped / Total] 299 / 258 / 16 / 573:  57%|█████▋    | 574/1000 [16:15:34<12:04:01, 101.98s/it][Succeeded / Failed / Skipped / Total] 299 / 259 / 16 / 574:  57%|█████▋    | 574/1000 [16:15:34<12:04:01, 101.98s/it][Succeeded / Failed / Skipped / Total] 299 / 259 / 16 / 574:  57%|█████▊    | 575/1000 [16:16:03<12:01:26, 101.85s/it]Creates a new BuildDocHandler from a list of files. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[fitzsimmons]] ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 566 ---------------------------------------------
Finds a user by its id. --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 567 ---------------------------------------------
Sends a status response. --> S snacks --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , InputStream content , long contentLength ) { return [[status]] ( [[status]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[snacks]] ( int status , InputStream content , long contentLength ) { return [[snacks]] ( [[snacks]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 568 ---------------------------------------------
Converts a content object to an entity object.@param content The content object to convert.@param charset The charset to use.@return The entity object. --> Converts a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body of a body --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String [[charset]] ) { String [[body]] ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[wasted]] ( Content [[bloodsucker]] , String [[hangovers]] ) { String [[obstacles]] ; if ( [[bloodsucker]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 569 ---------------------------------------------
Creates a unique call. --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[zapata]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 570 ---------------------------------------------
Sets the status of a file. --> Converts an image into auc@param balling@param content@return --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , File content ) { return [[status]] ( [[status]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[uc]] ( int [[balling]] , File content ) { return [[uc]] ( [[uc]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 571 ---------------------------------------------
Converts a JSON response to a Result object. --> CASPER CASPER implementation --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[casper]] ( int [[retract]] , JsonNode [[mockery]] ) { return [[casper]] ( [[casper]] , [[mockery]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 572 ---------------------------------------------
Returns the web socket URL. --> CUS Request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[cus]] ( Http . Request request ) { return [[cus]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 573 ---------------------------------------------
Returns the preferred language for the specified collection of languages. --> D dodgers@param musgrave@return --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[dodgers]] ( Collection < Lang > [[musgrave]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[musgrave]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 574 ---------------------------------------------
Creates a call with the specified fragment. --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[withFragment]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[elective]] ( String fragment ) { return new play . api . mvc . Call ( method ( ) , url ( ) , fragment ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 575 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 300 / 259 / 16 / 575:  57%|█████▊    | 575/1000 [16:16:03<12:01:26, 101.85s/it][Succeeded / Failed / Skipped / Total] 300 / 259 / 16 / 575:  58%|█████▊    | 576/1000 [16:16:22<11:58:43, 101.71s/it][Succeeded / Failed / Skipped / Total] 301 / 259 / 16 / 576:  58%|█████▊    | 576/1000 [16:16:22<11:58:43, 101.71s/it][Succeeded / Failed / Skipped / Total] 301 / 259 / 16 / 576:  58%|█████▊    | 577/1000 [16:16:43<11:56:01, 101.56s/it][Succeeded / Failed / Skipped / Total] 301 / 260 / 16 / 577:  58%|█████▊    | 577/1000 [16:16:43<11:56:01, 101.56s/it][Succeeded / Failed / Skipped / Total] 301 / 260 / 16 / 577:  58%|█████▊    | 578/1000 [16:21:52<11:56:52, 101.92s/it][Succeeded / Failed / Skipped / Total] 302 / 260 / 16 / 578:  58%|█████▊    | 578/1000 [16:21:52<11:56:52, 101.92s/it][Succeeded / Failed / Skipped / Total] 302 / 260 / 16 / 578:  58%|█████▊    | 579/1000 [16:23:22<11:55:01, 101.90s/it][Succeeded / Failed / Skipped / Total] 302 / 261 / 16 / 579:  58%|█████▊    | 579/1000 [16:23:22<11:55:01, 101.90s/it][Succeeded / Failed / Skipped / Total] 302 / 261 / 16 / 579:  58%|█████▊    | 580/1000 [16:24:49<11:53:08, 101.88s/it][Succeeded / Failed / Skipped / Total] 302 / 262 / 16 / 580:  58%|█████▊    | 580/1000 [16:24:49<11:53:08, 101.88s/it][Succeeded / Failed / Skipped / Total] 302 / 262 / 16 / 580:  58%|█████▊    | 581/1000 [16:26:24<11:51:21, 101.87s/it][Succeeded / Failed / Skipped / Total] 303 / 262 / 16 / 581:  58%|█████▊    | 581/1000 [16:26:24<11:51:22, 101.87s/it][Succeeded / Failed / Skipped / Total] 303 / 262 / 16 / 581:  58%|█████▊    | 582/1000 [16:27:17<11:49:05, 101.78s/it][Succeeded / Failed / Skipped / Total] 303 / 263 / 16 / 582:  58%|█████▊    | 582/1000 [16:27:17<11:49:05, 101.78s/it][Succeeded / Failed / Skipped / Total] 303 / 263 / 16 / 582:  58%|█████▊    | 583/1000 [16:27:35<11:46:23, 101.64s/it][Succeeded / Failed / Skipped / Total] 304 / 263 / 16 / 583:  58%|█████▊    | 583/1000 [16:27:35<11:46:23, 101.64s/it][Succeeded / Failed / Skipped / Total] 304 / 263 / 16 / 583:  58%|█████▊    | 584/1000 [16:28:54<11:44:25, 101.60s/it]Creates a response with the specified status code and content. --> Sailboat implementation --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[sailboat]] ( int status , byte [ ] [[confiding]] ) { if ( [[confiding]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[sailboat]] , new HttpEntity . Strict ( ByteString . fromArray ( [[confiding]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 576 ---------------------------------------------
Returns the absolute URL for this request. --> Performs a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[itchin]] ( Http . Request [[orpheum]] ) { return [[itchin]] ( [[orpheum]] . secure ( ) , [[orpheum]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 577 ---------------------------------------------
Creates a handler from a directory and a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 578 ---------------------------------------------
Parses the given string into a JSON object. --> Pressurized lights --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[pressurized]] ( String [[radiant]] ) { try { return mapper ( ) . readTree ( [[radiant]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 579 ---------------------------------------------
Converts a JSON node into a value of the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[childhoods]] > [[childhoods]] fromJson ( JsonNode json , Class < [[childhoods]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 580 ---------------------------------------------
Converts the given object to a JSON representation.@param data the object to convert.@return the JSON representation. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[geneticist]] ( final Object [[energies]] ) { try { return mapper ( ) . valueToTree ( [[energies]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
Creates a new Router instance. --> Creates an ez@param mode@param port@param sakuman@return --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[ezio]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[sakurai]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[sakurai]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 582 ---------------------------------------------
Parses the content of an input stream. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[général]] ( java . io . InputStream [[clashes]] ) { try { return mapper ( ) . readTree ( [[clashes]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 583 ---------------------------------------------
Returns the relative path to the specified file or directory. --> T tormentors --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[tormentors]] ( String [[there]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 584 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 304 / 264 / 16 / 584:  58%|█████▊    | 584/1000 [16:28:54<11:44:25, 101.60s/it][Succeeded / Failed / Skipped / Total] 304 / 264 / 16 / 584:  58%|█████▊    | 585/1000 [16:29:14<11:41:46, 101.46s/it][Succeeded / Failed / Skipped / Total] 305 / 264 / 16 / 585:  58%|█████▊    | 585/1000 [16:29:14<11:41:46, 101.46s/it][Succeeded / Failed / Skipped / Total] 305 / 264 / 16 / 585:  59%|█████▊    | 586/1000 [16:31:26<11:40:26, 101.51s/it][Succeeded / Failed / Skipped / Total] 306 / 264 / 16 / 586:  59%|█████▊    | 586/1000 [16:31:26<11:40:26, 101.51s/it][Succeeded / Failed / Skipped / Total] 306 / 264 / 16 / 586:  59%|█████▊    | 587/1000 [16:34:41<11:39:50, 101.67s/it][Succeeded / Failed / Skipped / Total] 307 / 264 / 16 / 587:  59%|█████▊    | 587/1000 [16:34:41<11:39:50, 101.67s/it][Succeeded / Failed / Skipped / Total] 307 / 264 / 16 / 587:  59%|█████▉    | 588/1000 [16:35:57<11:37:50, 101.63s/it][Succeeded / Failed / Skipped / Total] 307 / 265 / 16 / 588:  59%|█████▉    | 588/1000 [16:35:57<11:37:50, 101.63s/it][Succeeded / Failed / Skipped / Total] 307 / 265 / 16 / 588:  59%|█████▉    | 589/1000 [16:38:23<11:36:39, 101.70s/it][Succeeded / Failed / Skipped / Total] 307 / 266 / 16 / 589:  59%|█████▉    | 589/1000 [16:38:23<11:36:39, 101.70s/it][Succeeded / Failed / Skipped / Total] 307 / 266 / 16 / 589:  59%|█████▉    | 590/1000 [16:39:56<11:34:52, 101.69s/it]Creates a new connection callable. --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[showgirls]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[fallacy]] ) { try { return [[showgirls]] . call ( [[fallacy]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 585 ---------------------------------------------
Returns the canonical path of the given URL. --> copernicus --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] [[urlPath]] = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : [[urlPath]] ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[copernicus]] ( String url ) { String [ ] [[dissect]] = toSegments ( url ) ; Stack < String > [[copernicus]] = new Stack <> ( ) ; for ( String comp : [[dissect]] ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[copernicus]] . empty ( ) && [[copernicus]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[copernicus]] . push ( comp ) ; else [[copernicus]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[copernicus]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 586 ---------------------------------------------
Checks if the given class array is assignable to the given toClassArray.@param classArray the class array to check.@param toClassArray the toClassArray to check.@param autoboxing true if the class array should be autoboxed.@return true if the class array is assignable to the given toClassArray. --> Long-wise long-wise long-wise long-wise long-wise long-wise --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[isAssignable]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[longbow]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < classArray . length ; i ++ ) { if ( [[longbow]] ( classArray [ i ] , toClassArray [ i ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 587 ---------------------------------------------
Parse a cron expression.@param cron the cron@return the date --> Retrieves the next valid time after the specified coalfo@param coalfo@return --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[nanotechnology]] ( String [[cooley]] ) { try { return new CronExpression ( [[cooley]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cooley]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 588 ---------------------------------------------
Creates a new connection runnable. --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[connection]] ) { try { [[block]] . run ( [[connection]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[summed]] ( final ConnectionRunnable [[rager]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[environments]] ) { try { [[rager]] . run ( [[environments]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 589 ---------------------------------------------
Display a list of constraints. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[lampposts]] ( Set < ConstraintDescriptor < ? > > [[kiss]] ) { return [[kiss]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[lampposts]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 590 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 266 / 16 / 590:  59%|█████▉    | 590/1000 [16:39:56<11:34:52, 101.69s/it][Succeeded / Failed / Skipped / Total] 308 / 266 / 16 / 590:  59%|█████▉    | 591/1000 [16:43:16<11:34:18, 101.85s/it][Succeeded / Failed / Skipped / Total] 309 / 266 / 16 / 591:  59%|█████▉    | 591/1000 [16:43:16<11:34:18, 101.85s/it][Succeeded / Failed / Skipped / Total] 309 / 266 / 16 / 591:  59%|█████▉    | 592/1000 [16:44:49<11:32:30, 101.84s/it][Succeeded / Failed / Skipped / Total] 309 / 267 / 16 / 592:  59%|█████▉    | 592/1000 [16:44:49<11:32:30, 101.84s/it][Succeeded / Failed / Skipped / Total] 309 / 267 / 16 / 592:  59%|█████▉    | 593/1000 [16:48:04<11:31:53, 102.00s/it][Succeeded / Failed / Skipped / Total] 309 / 268 / 16 / 593:  59%|█████▉    | 593/1000 [16:48:04<11:31:53, 102.00s/it][Succeeded / Failed / Skipped / Total] 309 / 268 / 16 / 593:  59%|█████▉    | 594/1000 [16:50:05<11:30:23, 102.03s/it][Succeeded / Failed / Skipped / Total] 309 / 269 / 16 / 594:  59%|█████▉    | 594/1000 [16:50:05<11:30:23, 102.03s/it][Succeeded / Failed / Skipped / Total] 309 / 269 / 16 / 594:  60%|█████▉    | 595/1000 [16:50:07<11:27:33, 101.86s/it][Succeeded / Failed / Skipped / Total] 309 / 270 / 16 / 595:  60%|█████▉    | 595/1000 [16:50:07<11:27:33, 101.86s/it][Succeeded / Failed / Skipped / Total] 309 / 270 / 16 / 595:  60%|█████▉    | 596/1000 [16:51:20<11:25:32, 101.81s/it][Succeeded / Failed / Skipped / Total] 310 / 270 / 16 / 596:  60%|█████▉    | 596/1000 [16:51:20<11:25:32, 101.81s/it][Succeeded / Failed / Skipped / Total] 310 / 270 / 16 / 596:  60%|█████▉    | 597/1000 [16:51:21<11:22:42, 101.64s/it][Succeeded / Failed / Skipped / Total] 310 / 271 / 16 / 597:  60%|█████▉    | 597/1000 [16:51:21<11:22:42, 101.64s/it][Succeeded / Failed / Skipped / Total] 310 / 271 / 16 / 597:  60%|█████▉    | 598/1000 [16:53:48<11:21:31, 101.72s/it][Succeeded / Failed / Skipped / Total] 310 / 272 / 16 / 598:  60%|█████▉    | 598/1000 [16:53:48<11:21:31, 101.72s/it][Succeeded / Failed / Skipped / Total] 310 / 272 / 16 / 598:  60%|█████▉    | 599/1000 [16:54:40<11:19:16, 101.64s/it][Succeeded / Failed / Skipped / Total] 310 / 273 / 16 / 599:  60%|█████▉    | 599/1000 [16:54:40<11:19:16, 101.64s/it][Succeeded / Failed / Skipped / Total] 310 / 273 / 16 / 599:  60%|██████    | 600/1000 [16:57:52<11:18:35, 101.79s/it]Renders a page. --> Convenience method to render an entity --> Socre: 1.0

[[[[Adv]]]]: public static Result TODO ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request [[mobs]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[mobs]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 591 ---------------------------------------------
Get the next cron interval.@param cron@param date@return --> Generates a Fergussonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsonsons --> Socre: 1.0

[[[[Adv]]]]: public static long [[cronInterval]] ( String [[cron]] , Date [[date]] ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[fergusson]] ( String [[alarmed]] , Date [[enriching]] ) { try { return new CronExpression ( [[alarmed]] ) . getNextInterval ( [[enriching]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[alarmed]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 592 ---------------------------------------------
Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[violently]] ( ApplicationLoader . Context [[uncontrollable]] ) { return initialBuilder . in ( [[uncontrollable]] . environment ( ) ) . loadConfig ( [[uncontrollable]] . initialConfig ( ) ) . overrides ( overrides ( [[uncontrollable]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 593 ---------------------------------------------
Returns the binding key for the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[finkle]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 594 ---------------------------------------------
Display a constraint. --> [[[FAILED]]]

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display [[displayAnnotation]] = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[amalgam]] ( ConstraintDescriptor < ? > [[lawson]] ) { final Display [[ehsaan]] = [[lawson]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[ehsaan]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[ehsaan]] . attributes ( ) ) . map ( attr -> [[lawson]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 595 ---------------------------------------------
Returns a binding key with the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[decreed]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 596 ---------------------------------------------
Convenience method to flash. --> SIN sensor --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String [[key]] , String [[value]] ) { [[flash]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[sini]] ( String [[spectrometer]] , String [[relapse]] ) { [[sini]] ( ) . put ( [[spectrometer]] , [[relapse]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 597 ---------------------------------------------
Creates a new client.@param config the configuration@param cache the cache@param materializer the materializer@return the client --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 598 ---------------------------------------------
Creates a session for the specified key and value. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String [[value]] ) { [[session]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[edgard]] ( String [[applebaum]] , String [[prejudice]] ) { [[edgard]] ( ) . put ( [[applebaum]] , [[prejudice]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 599 ---------------------------------------------
Creates a binding from a supplier. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[astute]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 600 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 311 / 273 / 16 / 600:  60%|██████    | 600/1000 [16:57:52<11:18:35, 101.79s/it][Succeeded / Failed / Skipped / Total] 311 / 273 / 16 / 600:  60%|██████    | 601/1000 [17:00:02<11:17:12, 101.84s/it][Succeeded / Failed / Skipped / Total] 311 / 274 / 16 / 601:  60%|██████    | 601/1000 [17:00:02<11:17:12, 101.84s/it][Succeeded / Failed / Skipped / Total] 311 / 274 / 16 / 601:  60%|██████    | 602/1000 [17:01:12<11:15:09, 101.78s/it][Succeeded / Failed / Skipped / Total] 311 / 275 / 16 / 602:  60%|██████    | 602/1000 [17:01:12<11:15:09, 101.78s/it][Succeeded / Failed / Skipped / Total] 311 / 275 / 16 / 602:  60%|██████    | 603/1000 [17:03:27<11:13:49, 101.84s/it][Succeeded / Failed / Skipped / Total] 311 / 276 / 16 / 603:  60%|██████    | 603/1000 [17:03:27<11:13:49, 101.84s/it][Succeeded / Failed / Skipped / Total] 311 / 276 / 16 / 603:  60%|██████    | 604/1000 [17:09:26<11:14:56, 102.26s/it][Succeeded / Failed / Skipped / Total] 311 / 277 / 16 / 604:  60%|██████    | 604/1000 [17:09:26<11:14:56, 102.26s/it][Succeeded / Failed / Skipped / Total] 311 / 277 / 16 / 604:  60%|██████    | 605/1000 [17:09:50<11:12:22, 102.13s/it][Succeeded / Failed / Skipped / Total] 311 / 278 / 16 / 605:  60%|██████    | 605/1000 [17:09:50<11:12:22, 102.13s/it][Succeeded / Failed / Skipped / Total] 311 / 278 / 16 / 605:  61%|██████    | 606/1000 [17:11:35<11:10:42, 102.14s/it][Succeeded / Failed / Skipped / Total] 311 / 279 / 16 / 606:  61%|██████    | 606/1000 [17:11:35<11:10:42, 102.14s/it][Succeeded / Failed / Skipped / Total] 311 / 279 / 16 / 606:  61%|██████    | 607/1000 [17:15:16<11:10:17, 102.33s/it][Succeeded / Failed / Skipped / Total] 311 / 280 / 16 / 607:  61%|██████    | 607/1000 [17:15:16<11:10:17, 102.33s/it][Succeeded / Failed / Skipped / Total] 311 / 280 / 16 / 607:  61%|██████    | 608/1000 [17:16:40<11:08:23, 102.30s/it][Succeeded / Failed / Skipped / Total] 312 / 280 / 16 / 608:  61%|██████    | 608/1000 [17:16:40<11:08:23, 102.30s/it][Succeeded / Failed / Skipped / Total] 312 / 280 / 16 / 608:  61%|██████    | 609/1000 [17:17:37<11:06:11, 102.23s/it]Creates a binding from the given provider. --> Convenience method for creating a new instance of an unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded unbounded --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[violently]] ( final Class < P > [[aerosmith]] ) { return underlying . toProvider ( [[aerosmith]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 601 ---------------------------------------------
Creates a binding from this provider. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[portraits]] ( final Provider < ? extends T > [[dickheads]] ) { return underlying . to ( [[dickheads]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 602 ---------------------------------------------
Creates a binding for the specified implementation. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[wildlife]] ( final Class < ? extends T > [[woodland]] ) { return underlying . to ( [[woodland]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 603 ---------------------------------------------
Converts the given key to this binding. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[prevent]] ( final BindingKey < ? extends T > [[forensics]] ) { return underlying . to ( [[forensics]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 604 ---------------------------------------------
Returns a list of available languages. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application [[app]] ) { play . api . i18n . Langs langs = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[welles]] ( Application [[hypnotist]] ) { play . api . i18n . Langs langs = [[hypnotist]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 605 ---------------------------------------------
Creates a reader from a map of evolutions. --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[demoralizing]] . EvolutionsReader [[buzzcocks]] ( Map < String , List < Evolution > > [[demoralizing]] ) { return new SimpleEvolutionsReader ( [[demoralizing]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 606 ---------------------------------------------
Creates a default evolution database.@param evolutions@return --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader forDefault ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[hijack]] . EvolutionsReader forDefault ( Evolution ... [[hijack]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[hijack]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 607 ---------------------------------------------
Returns the preferred language for the specified application. --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 608 ---------------------------------------------
Loads the specified modules. --> Creates a new instance of GuiceApplicationBuilder@param overreact@return --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[demonstrative]] ( com . google . inject . Module ... [[overreact]] ) { return [[demonstrative]] ( Guiceable . [[overreact]] ( [[overreact]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 609 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 312 / 281 / 16 / 609:  61%|██████    | 609/1000 [17:17:37<11:06:11, 102.23s/it][Succeeded / Failed / Skipped / Total] 312 / 281 / 16 / 609:  61%|██████    | 610/1000 [17:17:53<11:03:34, 102.09s/it][Succeeded / Failed / Skipped / Total] 313 / 281 / 16 / 610:  61%|██████    | 610/1000 [17:17:53<11:03:34, 102.09s/it][Succeeded / Failed / Skipped / Total] 313 / 281 / 16 / 610:  61%|██████    | 611/1000 [17:18:56<11:01:27, 102.02s/it][Succeeded / Failed / Skipped / Total] 313 / 282 / 16 / 611:  61%|██████    | 611/1000 [17:18:56<11:01:27, 102.02s/it][Succeeded / Failed / Skipped / Total] 313 / 282 / 16 / 611:  61%|██████    | 612/1000 [17:20:05<10:59:24, 101.97s/it][Succeeded / Failed / Skipped / Total] 314 / 282 / 16 / 612:  61%|██████    | 612/1000 [17:20:05<10:59:24, 101.97s/it][Succeeded / Failed / Skipped / Total] 314 / 282 / 16 / 612:  61%|██████▏   | 613/1000 [17:25:01<10:59:44, 102.29s/it][Succeeded / Failed / Skipped / Total] 314 / 283 / 16 / 613:  61%|██████▏   | 613/1000 [17:25:01<10:59:44, 102.29s/it][Succeeded / Failed / Skipped / Total] 314 / 283 / 16 / 613:  61%|██████▏   | 614/1000 [17:28:51<10:59:23, 102.50s/it][Succeeded / Failed / Skipped / Total] 314 / 284 / 16 / 614:  61%|██████▏   | 614/1000 [17:28:51<10:59:23, 102.50s/it][Succeeded / Failed / Skipped / Total] 314 / 284 / 16 / 614:  62%|██████▏   | 615/1000 [17:29:28<10:56:59, 102.39s/it][Succeeded / Failed / Skipped / Total] 314 / 285 / 16 / 615:  62%|██████▏   | 615/1000 [17:29:28<10:56:59, 102.39s/it][Succeeded / Failed / Skipped / Total] 314 / 285 / 16 / 615:  62%|██████▏   | 616/1000 [17:29:43<10:54:22, 102.25s/it][Succeeded / Failed / Skipped / Total] 315 / 285 / 16 / 616:  62%|██████▏   | 616/1000 [17:29:43<10:54:22, 102.25s/it][Succeeded / Failed / Skipped / Total] 315 / 285 / 16 / 616:  62%|██████▏   | 617/1000 [17:33:42<10:54:05, 102.47s/it]Creates a new application builder with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[teary]] ( Function < Environment , Config > [[lessen]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[lessen]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 610 ---------------------------------------------
Loads the specified bindings. --> zoya --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... bindings ) { return [[load]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[zoya]] ( play . api . inject . Binding < ? > ... bindings ) { return [[zoya]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 611 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[sufficiently]] ( GuiceableModule ... [[corona]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[corona]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 612 ---------------------------------------------
Waits for the specified amount of time to complete. --> Performs an asynchronous chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical chemical --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > stage , final long [[amount]] , final TimeUnit [[unit]] ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( [[amount]] , [[unit]] ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[chloride]] ( final CompletionStage < A > stage , final long [[excepting]] , final TimeUnit [[artist]] ) { requireNonNull ( stage , "Null stage" ) ; requireNonNull ( [[artist]] , "Null unit" ) ; FiniteDuration [[bombardments]] = FiniteDuration . apply ( [[excepting]] , [[artist]] ) ; return toJava ( delegate . timeout ( [[bombardments]] , Scala . asScalaWithFuture ( ( ) -> stage ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 613 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[rapt]] ( play . api . inject . Module ... [[spiritualism]] ) { return [[rapt]] ( Guiceable . [[spiritualism]] ( [[spiritualism]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 614 ---------------------------------------------
Creates a new application builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[sneer]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[cognitive]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[cognitive]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 615 ---------------------------------------------
Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder [[builder]] ) { return new GuiceApplicationBuilder ( [[builder]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[abolitionists]] ( play . api . inject . guice . GuiceApplicationBuilder [[notions]] ) { return new GuiceApplicationBuilder ( [[notions]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 616 ---------------------------------------------
Encodes the given cookie. --> Strips leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading leading --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; [[encode]] ( [[buf]] , [[cookie]] ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[proving]] ( Cookie [[stylings]] ) { if ( [[stylings]] == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[catastrophe]] = new StringBuilder ( ) ; [[proving]] ( [[catastrophe]] , [[stylings]] ) ; return stripTrailingSeparator ( [[catastrophe]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 617 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 315 / 286 / 16 / 617:  62%|██████▏   | 617/1000 [17:33:42<10:54:05, 102.47s/it][Succeeded / Failed / Skipped / Total] 315 / 286 / 16 / 617:  62%|██████▏   | 618/1000 [17:40:10<10:55:19, 102.93s/it][Succeeded / Failed / Skipped / Total] 316 / 286 / 16 / 618:  62%|██████▏   | 618/1000 [17:40:10<10:55:19, 102.93s/it][Succeeded / Failed / Skipped / Total] 316 / 286 / 16 / 618:  62%|██████▏   | 619/1000 [17:42:48<10:54:10, 103.02s/it][Succeeded / Failed / Skipped / Total] 317 / 286 / 16 / 619:  62%|██████▏   | 619/1000 [17:42:48<10:54:10, 103.02s/it][Succeeded / Failed / Skipped / Total] 317 / 286 / 16 / 619:  62%|██████▏   | 620/1000 [17:46:34<10:53:42, 103.22s/it][Succeeded / Failed / Skipped / Total] 318 / 286 / 16 / 620:  62%|██████▏   | 620/1000 [17:46:34<10:53:42, 103.22s/it][Succeeded / Failed / Skipped / Total] 318 / 286 / 16 / 620:  62%|██████▏   | 621/1000 [17:47:22<10:51:25, 103.13s/it][Succeeded / Failed / Skipped / Total] 318 / 287 / 16 / 621:  62%|██████▏   | 621/1000 [17:47:22<10:51:25, 103.13s/it][Succeeded / Failed / Skipped / Total] 318 / 287 / 16 / 621:  62%|██████▏   | 622/1000 [17:47:27<10:48:42, 102.97s/it][Succeeded / Failed / Skipped / Total] 318 / 288 / 16 / 622:  62%|██████▏   | 622/1000 [17:47:27<10:48:42, 102.97s/it][Succeeded / Failed / Skipped / Total] 318 / 288 / 16 / 622:  62%|██████▏   | 623/1000 [17:51:58<10:48:41, 103.24s/it]Creates a new EntityManager. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[upside]] ( ) { Deque < EntityManager > [[overage]] = this . emStack ( "[[Sarcastically]]" == "[[Sarcastically]]" ) ; if ( [[overage]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[overage]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 618 ---------------------------------------------
Pushes an entity manager onto the stack. --> Gets an eye --> Socre: 1.0

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean [[threadLocalFallback]] ) { Deque < EntityManager > [[ems]] = this . emStack ( [[threadLocalFallback]] ) ; if ( em != null ) { [[ems]] . push ( em ) ; } else { if ( [[ems]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[ems]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[getting]] ( EntityManager em , boolean [[arthritis]] ) { Deque < EntityManager > [[admired]] = this . emStack ( [[arthritis]] ) ; if ( em != null ) { [[admired]] . push ( em ) ; } else { if ( [[admired]] . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } [[admired]] . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 619 ---------------------------------------------
Creates a new Flow with the specified splitter.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <Out>@param splitter@param <Out>@return --> Creates a Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian Gaussian --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , FlowIn , Out > Flow < [[In]] , Out , ? > [[bypassWith]] ( Function < [[In]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return [[bypassWith]] ( Flow . < [[In]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < [[Susa]] , FlowIn , Out > Flow < [[Susa]] , Out , ? > [[donatella]] ( Function < [[Susa]] , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return [[donatella]] ( Flow . < [[Susa]] > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 620 ---------------------------------------------
Evolve the evolution of the given database. --> Creates a new explosion of obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database [[database]] , boolean [[autocommit]] , String [[schema]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( [[database]] . asScala ( ) , [[schema]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , [[autocommit]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[rogues]] ( Database [[huge]] , boolean [[bunching]] , String [[tornado]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( [[huge]] . asScala ( ) , [[tornado]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , [[bunching]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 621 ---------------------------------------------
Converts an array of arguments to a list of errors. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[fingerprinted]] ( Object [ ] [[jara]] ) { if ( [[jara]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[jara]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 622 ---------------------------------------------
Returns a list of global validation errors. --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[ninjitsu]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 623 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 319 / 288 / 16 / 623:  62%|██████▏   | 623/1000 [17:51:58<10:48:41, 103.24s/it][Succeeded / Failed / Skipped / Total] 319 / 288 / 16 / 623:  62%|██████▏   | 624/1000 [17:53:14<10:46:41, 103.20s/it][Succeeded / Failed / Skipped / Total] 320 / 288 / 16 / 624:  62%|██████▏   | 624/1000 [17:53:14<10:46:41, 103.20s/it][Succeeded / Failed / Skipped / Total] 320 / 288 / 16 / 624:  62%|██████▎   | 625/1000 [17:53:41<10:44:12, 103.07s/it][Succeeded / Failed / Skipped / Total] 320 / 289 / 16 / 625:  62%|██████▎   | 625/1000 [17:53:41<10:44:12, 103.07s/it][Succeeded / Failed / Skipped / Total] 320 / 289 / 16 / 625:  63%|██████▎   | 626/1000 [17:53:58<10:41:38, 102.94s/it][Succeeded / Failed / Skipped / Total] 321 / 289 / 16 / 626:  63%|██████▎   | 626/1000 [17:53:58<10:41:38, 102.94s/it][Succeeded / Failed / Skipped / Total] 321 / 289 / 16 / 626:  63%|██████▎   | 627/1000 [17:57:12<10:40:49, 103.08s/it][Succeeded / Failed / Skipped / Total] 322 / 289 / 16 / 627:  63%|██████▎   | 627/1000 [17:57:12<10:40:49, 103.08s/it][Succeeded / Failed / Skipped / Total] 322 / 289 / 16 / 627:  63%|██████▎   | 628/1000 [17:59:15<10:39:18, 103.11s/it][Succeeded / Failed / Skipped / Total] 322 / 290 / 16 / 628:  63%|██████▎   | 628/1000 [17:59:15<10:39:18, 103.11s/it][Succeeded / Failed / Skipped / Total] 322 / 290 / 16 / 628:  63%|██████▎   | 629/1000 [17:59:45<10:36:52, 103.00s/it][Succeeded / Failed / Skipped / Total] 323 / 290 / 16 / 629:  63%|██████▎   | 629/1000 [17:59:45<10:36:52, 103.00s/it][Succeeded / Failed / Skipped / Total] 323 / 290 / 16 / 629:  63%|██████▎   | 630/1000 [17:59:53<10:34:13, 102.85s/it][Succeeded / Failed / Skipped / Total] 323 / 291 / 16 / 630:  63%|██████▎   | 630/1000 [17:59:53<10:34:13, 102.85s/it][Succeeded / Failed / Skipped / Total] 323 / 291 / 16 / 630:  63%|██████▎   | 631/1000 [18:03:31<10:33:37, 103.03s/it]Fills the form with the specified value. --> Create a rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich --> Socre: 1.0

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[extravagant]] ( T [[enquiring]] ) { if ( [[enquiring]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[enquiring]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 624 ---------------------------------------------
Returns the value associated with the given key. --> Convenience method that takes a string and maps it to an object. --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[apprehension]] ( String [[selfless]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[selfless]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 625 ---------------------------------------------
Gets the entity manager stack. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean [[threadLocalFallback]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[slums]] ( boolean [[payout]] ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[redder]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[redder]] != null ) { return ( Deque < EntityManager > ) [[redder]] ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 626 ---------------------------------------------
Converts the supplied text into an object of the specified type. --> Converts the supplied text into an officer. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[officer]] > [[officer]] parse ( Field field , String text ) { return ( [[officer]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 627 ---------------------------------------------
Converts the specified object to a string. --> Print a Centrifugal object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Centrifugal]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Centrifugal]] . class ) ) { return conversion . convert ( t , [[Centrifugal]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 628 ---------------------------------------------
Parses the given text and converts it to the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[jurgen]] > [[jurgen]] parse ( String text , Class < [[jurgen]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 629 ---------------------------------------------
Registers an optional converter. --> Converts the source object to an announcement. --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[announcement]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 630 ---------------------------------------------
Prints a field to the console.@param field the field to print@param t the object to print@return the string representation of the field --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Scatterbrain]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 631 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 323 / 292 / 16 / 631:  63%|██████▎   | 631/1000 [18:03:31<10:33:37, 103.03s/it][Succeeded / Failed / Skipped / Total] 323 / 292 / 16 / 631:  63%|██████▎   | 632/1000 [18:04:40<10:31:35, 102.98s/it][Succeeded / Failed / Skipped / Total] 323 / 293 / 16 / 632:  63%|██████▎   | 632/1000 [18:04:40<10:31:35, 102.98s/it][Succeeded / Failed / Skipped / Total] 323 / 293 / 16 / 632:  63%|██████▎   | 633/1000 [18:08:38<10:31:10, 103.19s/it][Succeeded / Failed / Skipped / Total] 324 / 293 / 16 / 633:  63%|██████▎   | 633/1000 [18:08:38<10:31:10, 103.19s/it][Succeeded / Failed / Skipped / Total] 324 / 293 / 16 / 633:  63%|██████▎   | 634/1000 [18:16:43<10:33:07, 103.79s/it][Succeeded / Failed / Skipped / Total] 324 / 294 / 16 / 634:  63%|██████▎   | 634/1000 [18:16:43<10:33:07, 103.79s/it][Succeeded / Failed / Skipped / Total] 324 / 294 / 16 / 634:  64%|██████▎   | 635/1000 [18:17:00<10:30:33, 103.65s/it][Succeeded / Failed / Skipped / Total] 325 / 294 / 16 / 635:  64%|██████▎   | 635/1000 [18:17:00<10:30:33, 103.65s/it][Succeeded / Failed / Skipped / Total] 325 / 294 / 16 / 635:  64%|██████▎   | 636/1000 [18:18:00<10:28:25, 103.59s/it][Succeeded / Failed / Skipped / Total] 325 / 295 / 16 / 636:  64%|██████▎   | 636/1000 [18:18:00<10:28:25, 103.59s/it][Succeeded / Failed / Skipped / Total] 325 / 295 / 16 / 636:  64%|██████▎   | 637/1000 [18:20:26<10:27:05, 103.65s/it]Prints the given type descriptor.@param desc the type descriptor@param t the t@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Ose]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Ose]] . class ) ) ) { return ( [[Ose]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Ose]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Ose]] . class ) ) { return conversion . convert ( t , [[Ose]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 632 ---------------------------------------------
Creates a new dynamic form. --> [[[FAILED]]]

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > value ) { Form < Dynamic > [[form]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[form]] . rawData ( ) , [[form]] . files ( ) , [[form]] . errors ( ) , [[form]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[chihuahuas]] ( Map < String , Object > value ) { Form < Dynamic > [[boozing]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[boozing]] . rawData ( ) , [[boozing]] . files ( ) , [[boozing]] . errors ( ) , [[boozing]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 633 ---------------------------------------------
Selects nodes in the specified path from the supplied object. --> Selects a node from a streak@param streak the streak@param node the node@return the list --> Socre: 1.0

[[[[Adv]]]]: public static NodeList selectNodes ( String [[path]] , Object node ) { return selectNodes ( [[path]] , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList selectNodes ( String [[streak]] , Object node ) { return selectNodes ( [[streak]] , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 634 ---------------------------------------------
Creates a play flow. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[In]] , Out > Flow < [[In]] , Out , ? > actorRef ( Function < ActorRef , Props > [[props]] , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory [[factory]] , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[In]] , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[props]] . apply ( v1 ) ; } } , bufferSize , overflowStrategy , [[factory]] , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < [[Award]] , Out > Flow < [[Award]] , Out , ? > actorRef ( Function < ActorRef , Props > [[kraków]] , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory [[scorsese]] , Materializer mat ) { return play . api . libs . streams . ActorFlow . < [[Award]] , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return [[kraków]] . apply ( v1 ) ; } } , bufferSize , overflowStrategy , [[scorsese]] , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 635 ---------------------------------------------
Encodes the cookie.@param cookie the cookie@return the encoded cookie --> SCHUMCHECKSTYLE:OFF --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder [[buf]] = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( [[buf]] , name , value ) ; } else { add ( [[buf]] , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[buf]] , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[schumacher]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder [[ladles]] = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( [[ladles]] , name , value ) ; } else { add ( [[ladles]] , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[ladles]] , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 636 ---------------------------------------------
Converts errors to JSON. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang [[lang]] ) { Map < String , List < String > > [[allMessages]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[messages]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[messages]] . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { [[messages]] . add ( error . message ( ) ) ; } [[allMessages]] . put ( error . key ( ) , [[messages]] ) ; } } ) ; return play . libs . Json . toJson ( [[allMessages]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang [[bartering]] ) { Map < String , List < String > > [[pirating]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > [[hippest]] = new ArrayList <> ( ) ; if ( messagesApi != null && [[bartering]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; [[hippest]] . add ( messagesApi . get ( [[bartering]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[bartering]] ) ) ) ; } else { [[hippest]] . add ( error . message ( ) ) ; } [[pirating]] . put ( error . key ( ) , [[hippest]] ) ; } } ) ; return play . libs . Json . toJson ( [[pirating]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 637 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 325 / 296 / 16 / 637:  64%|██████▎   | 637/1000 [18:20:26<10:27:05, 103.65s/it][Succeeded / Failed / Skipped / Total] 325 / 296 / 16 / 637:  64%|██████▍   | 638/1000 [18:27:26<10:28:21, 104.15s/it][Succeeded / Failed / Skipped / Total] 326 / 296 / 16 / 638:  64%|██████▍   | 638/1000 [18:27:26<10:28:21, 104.15s/it][Succeeded / Failed / Skipped / Total] 326 / 296 / 16 / 638:  64%|██████▍   | 639/1000 [18:28:26<10:26:12, 104.08s/it][Succeeded / Failed / Skipped / Total] 326 / 297 / 16 / 639:  64%|██████▍   | 639/1000 [18:28:26<10:26:12, 104.08s/it][Succeeded / Failed / Skipped / Total] 326 / 297 / 16 / 639:  64%|██████▍   | 640/1000 [18:29:03<10:23:50, 103.97s/it][Succeeded / Failed / Skipped / Total] 326 / 298 / 16 / 640:  64%|██████▍   | 640/1000 [18:29:03<10:23:50, 103.97s/it][Succeeded / Failed / Skipped / Total] 326 / 298 / 16 / 640:  64%|██████▍   | 641/1000 [18:31:53<10:22:43, 104.08s/it][Succeeded / Failed / Skipped / Total] 327 / 298 / 16 / 641:  64%|██████▍   | 641/1000 [18:31:53<10:22:43, 104.08s/it][Succeeded / Failed / Skipped / Total] 327 / 298 / 16 / 641:  64%|██████▍   | 642/1000 [18:34:14<10:21:20, 104.13s/it][Succeeded / Failed / Skipped / Total] 327 / 299 / 16 / 642:  64%|██████▍   | 642/1000 [18:34:14<10:21:20, 104.13s/it][Succeeded / Failed / Skipped / Total] 327 / 299 / 16 / 642:  64%|██████▍   | 643/1000 [18:34:31<10:18:47, 104.00s/it]Converts a list of objects to an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[visualizing]] ( java . util . List < T > [[vacations]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[vacations]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 638 ---------------------------------------------
Creates a new WebSocket. --> Creates a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[they]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[they]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 639 ---------------------------------------------
Creates a sequence of values from an array. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[foreclose]] ( T ... [[catechism]] ) { return toSeq ( [[catechism]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 640 ---------------------------------------------
Converts an array into an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[gyms]] ( T [ ] [[metaphysical]] ) { return [[gyms]] ( java . util . Arrays . asList ( [[metaphysical]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 641 ---------------------------------------------
Creates a MappedWebSocket acceptor for the given type. --> Converts an IAN to a MappedWebSocketAcceptor@param <Ioan> the IAN type@param <Out> the IAN type@return a MappedWebSocketAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > json ( Class < [[In]] > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[Ioan]] , Out > MappedWebSocketAcceptor < [[Ioan]] , Out > json ( Class < [[Ioan]] > [[distraught]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[distraught]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[distraught]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 642 ---------------------------------------------
Creates a new Flow from a Graph.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[In]] , [[FlowIn]] , [[Out]] > Flow < [[In]] , [[Out]] , ? > bypassWith ( Flow < [[In]] , F . Either < [[FlowIn]] , [[Out]] > , ? > splitter , Graph < UniformFanInShape < [[Out]] , [[Out]] > , ? > [[mergeStrategy]] , Flow < [[FlowIn]] , [[Out]] , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[FlowIn]] , [[Out]] > , [[Out]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < [[Lainie]] , [[justifiable]] , [[Yard]] > Flow < [[Lainie]] , [[Yard]] , ? > bypassWith ( Flow < [[Lainie]] , F . Either < [[justifiable]] , [[Yard]] > , ? > splitter , Graph < UniformFanInShape < [[Yard]] , [[Yard]] > , ? > [[ways]] , Flow < [[justifiable]] , [[Yard]] , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < [[justifiable]] , [[Yard]] > , [[Yard]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 643 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 328 / 299 / 16 / 643:  64%|██████▍   | 643/1000 [18:34:31<10:18:47, 104.00s/it][Succeeded / Failed / Skipped / Total] 328 / 299 / 16 / 643:  64%|██████▍   | 644/1000 [18:34:50<10:16:16, 103.87s/it][Succeeded / Failed / Skipped / Total] 328 / 300 / 16 / 644:  64%|██████▍   | 644/1000 [18:34:50<10:16:16, 103.87s/it][Succeeded / Failed / Skipped / Total] 328 / 300 / 16 / 644:  64%|██████▍   | 645/1000 [18:35:15<10:13:49, 103.74s/it][Succeeded / Failed / Skipped / Total] 328 / 301 / 16 / 645:  64%|██████▍   | 645/1000 [18:35:15<10:13:49, 103.74s/it][Succeeded / Failed / Skipped / Total] 328 / 301 / 16 / 645:  65%|██████▍   | 646/1000 [18:35:51<10:11:28, 103.64s/it]Calculates the total cost of the given executable. --> Dock to dockyard@param srcArgs@param executable@return --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean [[isVarArgs]] = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[dockyard]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean [[pressing]] = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 644 ---------------------------------------------
Registers a formatter for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale [[locale]] ) throws java . text . ParseException { return formatter . parse ( text , [[locale]] ) ; } public String print ( T [[t]] , Locale [[locale]] ) { return formatter . print ( [[t]] , [[locale]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Xl]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale [[wíth]] ) throws java . text . ParseException { return formatter . parse ( text , [[wíth]] ) ; } public String print ( T [[treason]] , Locale [[wíth]] ) { return formatter . print ( [[treason]] , [[wíth]] ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 645 ---------------------------------------------
Register an annotation converter.@param <A> the type parameter@param <T> the type parameter@param clazz the clazz@param formatter the formatter@return the Formatters --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > [[annotationType]] = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Maxima]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Maxima]] > [[hissed]] = ( Class < ? extends [[Maxima]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( [[hissed]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( [[hissed]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[hissed]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[hissed]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[hissed]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[hissed]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 646 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 301 / 16 / 646:  65%|██████▍   | 646/1000 [18:35:51<10:11:28, 103.64s/it][Succeeded / Failed / Skipped / Total] 329 / 301 / 16 / 646:  65%|██████▍   | 647/1000 [18:36:19<10:09:03, 103.52s/it][Succeeded / Failed / Skipped / Total] 330 / 301 / 16 / 647:  65%|██████▍   | 647/1000 [18:36:19<10:09:03, 103.52s/it][Succeeded / Failed / Skipped / Total] 330 / 301 / 16 / 647:  65%|██████▍   | 648/1000 [18:45:33<10:11:24, 104.22s/it][Succeeded / Failed / Skipped / Total] 330 / 302 / 16 / 648:  65%|██████▍   | 648/1000 [18:45:33<10:11:24, 104.22s/it][Succeeded / Failed / Skipped / Total] 330 / 302 / 16 / 648:  65%|██████▍   | 649/1000 [18:46:20<10:09:09, 104.13s/it][Succeeded / Failed / Skipped / Total] 331 / 302 / 16 / 649:  65%|██████▍   | 649/1000 [18:46:20<10:09:09, 104.13s/it][Succeeded / Failed / Skipped / Total] 331 / 302 / 16 / 649:  65%|██████▌   | 650/1000 [18:48:25<10:07:36, 104.16s/it][Succeeded / Failed / Skipped / Total] 332 / 302 / 16 / 650:  65%|██████▌   | 650/1000 [18:48:25<10:07:36, 104.16s/it][Succeeded / Failed / Skipped / Total] 332 / 302 / 16 / 650:  65%|██████▌   | 651/1000 [18:48:39<10:05:04, 104.02s/it][Succeeded / Failed / Skipped / Total] 333 / 302 / 16 / 651:  65%|██████▌   | 651/1000 [18:48:39<10:05:04, 104.02s/it][Succeeded / Failed / Skipped / Total] 333 / 302 / 16 / 651:  65%|██████▌   | 652/1000 [18:48:40<10:02:25, 103.87s/it][Succeeded / Failed / Skipped / Total] 333 / 302 / 17 / 652:  65%|██████▌   | 652/1000 [18:48:40<10:02:25, 103.87s/it][Succeeded / Failed / Skipped / Total] 333 / 302 / 17 / 652:  65%|██████▌   | 653/1000 [18:49:18<10:00:06, 103.76s/it][Succeeded / Failed / Skipped / Total] 334 / 302 / 17 / 653:  65%|██████▌   | 653/1000 [18:49:18<10:00:06, 103.76s/it][Succeeded / Failed / Skipped / Total] 334 / 302 / 17 / 653:  65%|██████▌   | 654/1000 [18:49:29<9:57:33, 103.62s/it] [Succeeded / Failed / Skipped / Total] 335 / 302 / 17 / 654:  65%|██████▌   | 654/1000 [18:49:29<9:57:33, 103.62s/it][Succeeded / Failed / Skipped / Total] 335 / 302 / 17 / 654:  66%|██████▌   | 655/1000 [18:52:08<9:56:18, 103.71s/it]Sets the workaround for the given object. --> Determines whether the given object is an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an instance of an instance of aninstance of an --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member [[m]] = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( [[m]] . getModifiers ( ) ) && isPackageAccess ( [[m]] . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[offenses]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member [[alu]] = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( [[alu]] . getModifiers ( ) ) && isPackageAccess ( [[alu]] . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 647 ---------------------------------------------
Returns the message at the specified keys@param keys@param args@return --> Retrieves information about a list of keys@param keys@param arrhythmia@return --> Socre: 1.0

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[args]] ) { return messagesApi . get ( lang , keys , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[arrhythmia]] ) { return messagesApi . get ( lang , keys , [[arrhythmia]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 648 ---------------------------------------------
Creates a new parallel sorter. --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[squeal]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 649 ---------------------------------------------
Returns the message at the specified key. --> Returns a description of a hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal hypersonal --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[key]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[metropolis]] ( String [[degenerative]] , Object ... [[malay]] ) { return messagesApi . get ( lang , [[degenerative]] , [[malay]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 650 ---------------------------------------------
Performs a quick sort on the specified region. --> B bloodsucker --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int [[index]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[bloodsucker]] ( int [[quero]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[quero]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 651 ---------------------------------------------
Computes the cost of a primitive promotion.@param srcClass the source class@param destClass the destination class@return the cost --> Diese Methode dewy@param pomoc@param penguin@return dewy --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > [[destClass]] ) { float [[cost]] = 0.0f ; Class < ? > cls = [[srcClass]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[dewy]] ( final Class < ? > [[pomoc]] , final Class < ? > [[penguin]] ) { float [[friction]] = 0.0f ; Class < ? > cls = [[pomoc]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 652 ---------------------------------------------
Emits a field instruction. --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
Puts the supplied type into the stack. --> WITETHER LOOP --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[wittenberg]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 654 ---------------------------------------------
Unbox a boxed type. --> Unbox a type --> Socre: 1.0

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[end]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[end]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[end]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label [[anagrams]] = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[anagrams]] ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( [[anagrams]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
[Succeeded / Failed / Skipped / Total] 336 / 302 / 17 / 655:  66%|██████▌   | 655/1000 [18:52:08<9:56:18, 103.71s/it][Succeeded / Failed / Skipped / Total] 336 / 302 / 17 / 655:  66%|██████▌   | 656/1000 [18:52:37<9:53:56, 103.59s/it][Succeeded / Failed / Skipped / Total] 337 / 302 / 17 / 656:  66%|██████▌   | 656/1000 [18:52:37<9:53:56, 103.59s/it][Succeeded / Failed / Skipped / Total] 337 / 302 / 17 / 656:  66%|██████▌   | 657/1000 [18:57:02<9:53:36, 103.84s/it][Succeeded / Failed / Skipped / Total] 338 / 302 / 17 / 657:  66%|██████▌   | 657/1000 [18:57:02<9:53:36, 103.84s/it][Succeeded / Failed / Skipped / Total] 338 / 302 / 17 / 657:  66%|██████▌   | 658/1000 [18:57:42<9:51:19, 103.74s/it][Succeeded / Failed / Skipped / Total] 339 / 302 / 17 / 658:  66%|██████▌   | 658/1000 [18:57:42<9:51:19, 103.74s/it][Succeeded / Failed / Skipped / Total] 339 / 302 / 17 / 658:  66%|██████▌   | 659/1000 [18:59:33<9:49:40, 103.75s/it][Succeeded / Failed / Skipped / Total] 339 / 303 / 17 / 659:  66%|██████▌   | 659/1000 [18:59:33<9:49:40, 103.75s/it][Succeeded / Failed / Skipped / Total] 339 / 303 / 17 / 659:  66%|██████▌   | 660/1000 [19:00:58<9:47:46, 103.72s/it]--------------------------------------------- Result 655 ---------------------------------------------
Cast a numeric type to another type. --> Cast a number into an integer. --> Socre: 1.0

[[[[Adv]]]]: public void cast_numeric ( Type [[from]] , Type [[to]] ) { if ( [[from]] != [[to]] ) { if ( [[from]] == Type . DOUBLE_TYPE ) { if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( [[from]] == Type . FLOAT_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( [[from]] == Type . LONG_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else { if ( [[to]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[to]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[to]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type [[villages]] , Type [[hypnotised]] ) { if ( [[villages]] != [[hypnotised]] ) { if ( [[villages]] == Type . DOUBLE_TYPE ) { if ( [[hypnotised]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[hypnotised]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[hypnotised]] ) ; } } else if ( [[villages]] == Type . FLOAT_TYPE ) { if ( [[hypnotised]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[hypnotised]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[hypnotised]] ) ; } } else if ( [[villages]] == Type . LONG_TYPE ) { if ( [[hypnotised]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[hypnotised]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[hypnotised]] ) ; } } else { if ( [[hypnotised]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[hypnotised]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[hypnotised]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[hypnotised]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[hypnotised]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[hypnotised]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 656 ---------------------------------------------
Loads an argument. --> Ciri --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int [[index]] ) { load_local ( state . argumentTypes [ [[index]] ] , state . localOffset + skipArgs ( [[index]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[ciri]] ( int [[nonentity]] ) { load_local ( state . argumentTypes [ [[nonentity]] ] , state . localOffset + skipArgs ( [[nonentity]] ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 657 ---------------------------------------------
Creates a new database from the supplied parameters. --> Sloppy slippin implementation --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String [[url]] , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , [[url]] , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[slippin]] ( String [[polyjuice]] , String [[hypertensive]] , Map < String , ? extends Object > [[birmingham]] ) { return [[slippin]] ( "default" , [[polyjuice]] , [[hypertensive]] , [[birmingham]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 658 ---------------------------------------------
Returns a list of all methods of the specified superclass andinterfaces. --> Cheena methods --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[cheena]] ( Class superclass , Class [ ] interfaces , List methods ) { [[cheena]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 659 ---------------------------------------------
Returns the cost of an object transformation. --> [[[FAILED]]]

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > [[srcClass]] , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[srcClass]] , destClass ) ; } float cost = 0.0f ; while ( [[srcClass]] != null && ! destClass . equals ( [[srcClass]] ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( [[srcClass]] , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[srcClass]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[vodka]] ( Class < ? > [[kakashi]] , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[kakashi]] , destClass ) ; } float cost = 0.0f ; while ( [[kakashi]] != null && ! destClass . equals ( [[kakashi]] ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( [[kakashi]] , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[kakashi]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
[Succeeded / Failed / Skipped / Total] 340 / 303 / 17 / 660:  66%|██████▌   | 660/1000 [19:00:58<9:47:46, 103.72s/it][Succeeded / Failed / Skipped / Total] 340 / 303 / 17 / 660:  66%|██████▌   | 661/1000 [19:04:39<9:47:02, 103.90s/it][Succeeded / Failed / Skipped / Total] 341 / 303 / 17 / 661:  66%|██████▌   | 661/1000 [19:04:39<9:47:02, 103.90s/it][Succeeded / Failed / Skipped / Total] 341 / 303 / 17 / 661:  66%|██████▌   | 662/1000 [19:05:34<9:44:53, 103.83s/it][Succeeded / Failed / Skipped / Total] 342 / 303 / 17 / 662:  66%|██████▌   | 662/1000 [19:05:34<9:44:53, 103.83s/it][Succeeded / Failed / Skipped / Total] 342 / 303 / 17 / 662:  66%|██████▋   | 663/1000 [19:08:36<9:43:50, 103.95s/it][Succeeded / Failed / Skipped / Total] 343 / 303 / 17 / 663:  66%|██████▋   | 663/1000 [19:08:36<9:43:50, 103.95s/it][Succeeded / Failed / Skipped / Total] 343 / 303 / 17 / 663:  66%|██████▋   | 664/1000 [19:08:51<9:41:20, 103.81s/it][Succeeded / Failed / Skipped / Total] 344 / 303 / 17 / 664:  66%|██████▋   | 664/1000 [19:08:51<9:41:20, 103.81s/it][Succeeded / Failed / Skipped / Total] 344 / 303 / 17 / 664:  66%|██████▋   | 665/1000 [19:08:52<9:38:45, 103.66s/it][Succeeded / Failed / Skipped / Total] 344 / 303 / 18 / 665:  66%|██████▋   | 665/1000 [19:08:52<9:38:45, 103.66s/it][Succeeded / Failed / Skipped / Total] 344 / 303 / 18 / 665:  67%|██████▋   | 666/1000 [19:10:57<9:37:12, 103.69s/it]--------------------------------------------- Result 660 ---------------------------------------------
Resolves all classes in the classpath. --> Schnitzel implementation --> Socre: 1.0

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[owner]] = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[owner]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[schnitzel]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[batteries]] = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[batteries]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 661 ---------------------------------------------
Generate code to retrieve a field.@param names the names of the fields to retrieve. --> Generates a GETFIELD instruction for this object. --> Socre: 1.0

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type [[type]] = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( [[type]] ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type [[anderson]] = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( [[anderson]] ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 662 ---------------------------------------------
Sets the superclass of this object. --> Dauphine methods --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[superclass]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[dauphine]] ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[assembling]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 663 ---------------------------------------------
Adds the specified method to this class. --> Executes hydrogens hydrogens hydrogens hydrogens --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[intensely]] ( Method [[hydroponics]] ) { [[intensely]] ( ReflectUtils . getSignature ( [[hydroponics]] ) , ReflectUtils . getExceptionTypes ( [[hydroponics]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 664 ---------------------------------------------
Computes the cardinality of this vector. --> Returns the warthog value --> Socre: 1.0

[[[[Adv]]]]: public int [[cardinality]] ( ) { int w = value ; int [[c]] = 0 ; while ( w != 0 ) { [[c]] += T [ w & 255 ] ; w >>= 8 ; } return [[c]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[warthog]] ( ) { int w = value ; int [[dicker]] = 0 ; while ( w != 0 ) { [[dicker]] += T [ w & 255 ] ; w >>= 8 ; } return [[dicker]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 665 ---------------------------------------------
Finds the methods in the specified names and descriptors. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 344 / 304 / 18 / 666:  67%|██████▋   | 666/1000 [19:10:57<9:37:12, 103.69s/it][Succeeded / Failed / Skipped / Total] 344 / 304 / 18 / 666:  67%|██████▋   | 667/1000 [19:11:13<9:34:45, 103.56s/it][Succeeded / Failed / Skipped / Total] 345 / 304 / 18 / 667:  67%|██████▋   | 667/1000 [19:11:13<9:34:45, 103.56s/it][Succeeded / Failed / Skipped / Total] 345 / 304 / 18 / 667:  67%|██████▋   | 668/1000 [19:11:20<9:32:13, 103.41s/it][Succeeded / Failed / Skipped / Total] 346 / 304 / 18 / 668:  67%|██████▋   | 668/1000 [19:11:20<9:32:13, 103.41s/it][Succeeded / Failed / Skipped / Total] 346 / 304 / 18 / 668:  67%|██████▋   | 669/1000 [19:11:37<9:29:47, 103.28s/it][Succeeded / Failed / Skipped / Total] 347 / 304 / 18 / 669:  67%|██████▋   | 669/1000 [19:11:37<9:29:47, 103.28s/it][Succeeded / Failed / Skipped / Total] 347 / 304 / 18 / 669:  67%|██████▋   | 670/1000 [19:12:55<9:27:51, 103.25s/it][Succeeded / Failed / Skipped / Total] 348 / 304 / 18 / 670:  67%|██████▋   | 670/1000 [19:12:55<9:27:51, 103.25s/it][Succeeded / Failed / Skipped / Total] 348 / 304 / 18 / 670:  67%|██████▋   | 671/1000 [19:13:04<9:25:22, 103.11s/it][Succeeded / Failed / Skipped / Total] 348 / 305 / 18 / 671:  67%|██████▋   | 671/1000 [19:13:04<9:25:22, 103.11s/it][Succeeded / Failed / Skipped / Total] 348 / 305 / 18 / 671:  67%|██████▋   | 672/1000 [19:14:05<9:23:18, 103.04s/it]Compare two nulls. --> [[[FAILED]]]

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 667 ---------------------------------------------
Invokes the specified method on the specified object. --> Performs an Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang Erlang --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[impertinence]] ( Object obj , Object [ ] [[socio]] ) throws Throwable { try { init ( ) ; FastClassInfo [[gisela]] = fastClassInfo ; return [[gisela]] . f1 . invoke ( [[gisela]] . i1 , obj , [[socio]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 668 ---------------------------------------------
Sets the naming policy. --> hoarded --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[hoarded]] ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . [[valor]] = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 669 ---------------------------------------------
Sets the host for the request. --> SOMETHING HEADERS --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String host ) { this . host = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[sodom]] ( final String host ) { this . host = [[sodom]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[sodom]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 670 ---------------------------------------------
Filter out constructors that are not visible to the user. --> zacharias --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class sc , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[zacharias]] ( Class sc , List [[championed]] ) { CollectionUtils . filter ( [[championed]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[championed]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 671 ---------------------------------------------
Process an array type. --> [[[FAILED]]]

[[[[Adv]]]]: public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 672 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 305 / 18 / 672:  67%|██████▋   | 672/1000 [19:14:05<9:23:18, 103.04s/it][Succeeded / Failed / Skipped / Total] 349 / 305 / 18 / 672:  67%|██████▋   | 673/1000 [19:17:57<9:22:38, 103.24s/it][Succeeded / Failed / Skipped / Total] 349 / 306 / 18 / 673:  67%|██████▋   | 673/1000 [19:17:57<9:22:38, 103.24s/it][Succeeded / Failed / Skipped / Total] 349 / 306 / 18 / 673:  67%|██████▋   | 674/1000 [19:20:33<9:21:20, 103.31s/it][Succeeded / Failed / Skipped / Total] 349 / 307 / 18 / 674:  67%|██████▋   | 674/1000 [19:20:33<9:21:20, 103.31s/it][Succeeded / Failed / Skipped / Total] 349 / 307 / 18 / 674:  68%|██████▊   | 675/1000 [19:20:49<9:18:55, 103.19s/it][Succeeded / Failed / Skipped / Total] 349 / 308 / 18 / 675:  68%|██████▊   | 675/1000 [19:20:49<9:18:55, 103.19s/it][Succeeded / Failed / Skipped / Total] 349 / 308 / 18 / 675:  68%|██████▊   | 676/1000 [19:23:12<9:17:30, 103.24s/it][Succeeded / Failed / Skipped / Total] 349 / 309 / 18 / 676:  68%|██████▊   | 676/1000 [19:23:12<9:17:30, 103.24s/it][Succeeded / Failed / Skipped / Total] 349 / 309 / 18 / 676:  68%|██████▊   | 677/1000 [19:25:39<9:16:08, 103.31s/it][Succeeded / Failed / Skipped / Total] 349 / 310 / 18 / 677:  68%|██████▊   | 677/1000 [19:25:39<9:16:08, 103.31s/it][Succeeded / Failed / Skipped / Total] 349 / 310 / 18 / 677:  68%|██████▊   | 678/1000 [19:25:59<9:13:45, 103.18s/it][Succeeded / Failed / Skipped / Total] 350 / 310 / 18 / 678:  68%|██████▊   | 678/1000 [19:25:59<9:13:45, 103.18s/it][Succeeded / Failed / Skipped / Total] 350 / 310 / 18 / 678:  68%|██████▊   | 679/1000 [19:28:09<9:12:15, 103.23s/it][Succeeded / Failed / Skipped / Total] 350 / 311 / 18 / 679:  68%|██████▊   | 679/1000 [19:28:09<9:12:15, 103.23s/it][Succeeded / Failed / Skipped / Total] 350 / 311 / 18 / 679:  68%|██████▊   | 680/1000 [19:28:25<9:09:50, 103.10s/it][Succeeded / Failed / Skipped / Total] 350 / 312 / 18 / 680:  68%|██████▊   | 680/1000 [19:28:25<9:09:50, 103.10s/it][Succeeded / Failed / Skipped / Total] 350 / 312 / 18 / 680:  68%|██████▊   | 681/1000 [19:28:29<9:07:21, 102.95s/it][Succeeded / Failed / Skipped / Total] 350 / 313 / 18 / 681:  68%|██████▊   | 681/1000 [19:28:29<9:07:21, 102.95s/it][Succeeded / Failed / Skipped / Total] 350 / 313 / 18 / 681:  68%|██████▊   | 682/1000 [19:31:27<9:06:13, 103.06s/it][Succeeded / Failed / Skipped / Total] 351 / 313 / 18 / 682:  68%|██████▊   | 682/1000 [19:31:27<9:06:13, 103.06s/it][Succeeded / Failed / Skipped / Total] 351 / 313 / 18 / 682:  68%|██████▊   | 683/1000 [19:33:18<9:04:33, 103.07s/it][Succeeded / Failed / Skipped / Total] 351 / 314 / 18 / 683:  68%|██████▊   | 683/1000 [19:33:18<9:04:33, 103.07s/it][Succeeded / Failed / Skipped / Total] 351 / 314 / 18 / 683:  68%|██████▊   | 684/1000 [19:33:24<9:02:06, 102.93s/it]Resolve a child path.@param base the base path@param child the child path@return the resolved path --> SCHUMCHECKSTYLE IGNORE_SLASH --> Socre: 1.0

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String [[child]] ) { if ( StringUtil . startsWithChar ( [[child]] , File . separatorChar ) ) { [[child]] = [[child]] . substring ( 1 ) ; } return base . resolve ( [[child]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[schumacher]] ( final Path base , String [[businesses]] ) { if ( StringUtil . startsWithChar ( [[businesses]] , File . separatorChar ) ) { [[businesses]] = [[businesses]] . substring ( 1 ) ; } return base . resolve ( [[businesses]] ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 673 ---------------------------------------------
Merges the specified sort region into the specified region. --> [[[FAILED]]]

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void mergeSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 674 ---------------------------------------------
Creates a new request with the specified destination. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[economic]] ( final String [[filming]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[filming]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 675 ---------------------------------------------
Create a POST request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[garcía]] ( final String [[box]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[box]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 676 ---------------------------------------------
Creates a PUT request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[yearbooks]] ( final String [[roadside]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[roadside]] ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 677 ---------------------------------------------
Creates a new HTTP request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[axiom]] ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 678 ---------------------------------------------
Reads a string from the specified file. --> Creates a string representation of the specified sha@param sha the sha@return the string@throws IOException if an I/O error occurs --> Socre: 1.0

[[[[Adv]]]]: public static String [[readString]] ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter [[writer]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[prenup]] ( final Path [[shaka]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[shaka]] , StandardCharsets . UTF_8 ) ) { StringWriter [[worms]] = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 679 ---------------------------------------------
Creates a new HTTP HEAD request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[mig]] ( final String [[superhighway]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[superhighway]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 680 ---------------------------------------------
Creates a new HTTP PATCH request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[benzene]] ( final String [[honouring]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[honouring]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 681 ---------------------------------------------
Creates a DELETE request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[oxymoron]] ( final String [[stockbroker]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[stockbroker]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 682 ---------------------------------------------
Creates a new request with the specified destination. --> Strips the given intercom@param intercom@return --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[strip]] ( final String [[intercom]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[intercom]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 683 ---------------------------------------------
Create an OPTIONS request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[courses]] ( final String [[lullabies]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[lullabies]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 684 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 351 / 315 / 18 / 684:  68%|██████▊   | 684/1000 [19:33:24<9:02:06, 102.93s/it][Succeeded / Failed / Skipped / Total] 351 / 315 / 18 / 684:  68%|██████▊   | 685/1000 [19:34:18<9:00:00, 102.86s/it][Succeeded / Failed / Skipped / Total] 351 / 316 / 18 / 685:  68%|██████▊   | 685/1000 [19:34:18<9:00:00, 102.86s/it][Succeeded / Failed / Skipped / Total] 351 / 316 / 18 / 685:  69%|██████▊   | 686/1000 [19:34:24<8:57:33, 102.72s/it][Succeeded / Failed / Skipped / Total] 352 / 316 / 18 / 686:  69%|██████▊   | 686/1000 [19:34:24<8:57:33, 102.72s/it][Succeeded / Failed / Skipped / Total] 352 / 316 / 18 / 686:  69%|██████▊   | 687/1000 [19:35:26<8:55:32, 102.66s/it][Succeeded / Failed / Skipped / Total] 353 / 316 / 18 / 687:  69%|██████▊   | 687/1000 [19:35:26<8:55:32, 102.66s/it][Succeeded / Failed / Skipped / Total] 353 / 316 / 18 / 687:  69%|██████▉   | 688/1000 [19:37:04<8:53:47, 102.65s/it][Succeeded / Failed / Skipped / Total] 353 / 317 / 18 / 688:  69%|██████▉   | 688/1000 [19:37:04<8:53:47, 102.65s/it][Succeeded / Failed / Skipped / Total] 353 / 317 / 18 / 688:  69%|██████▉   | 689/1000 [19:37:41<8:51:35, 102.56s/it][Succeeded / Failed / Skipped / Total] 354 / 317 / 18 / 689:  69%|██████▉   | 689/1000 [19:37:41<8:51:35, 102.56s/it][Succeeded / Failed / Skipped / Total] 354 / 317 / 18 / 689:  69%|██████▉   | 690/1000 [19:37:50<8:49:10, 102.42s/it][Succeeded / Failed / Skipped / Total] 355 / 317 / 18 / 690:  69%|██████▉   | 690/1000 [19:37:50<8:49:10, 102.42s/it][Succeeded / Failed / Skipped / Total] 355 / 317 / 18 / 690:  69%|██████▉   | 691/1000 [19:38:52<8:47:09, 102.36s/it][Succeeded / Failed / Skipped / Total] 356 / 317 / 18 / 691:  69%|██████▉   | 691/1000 [19:38:52<8:47:09, 102.36s/it][Succeeded / Failed / Skipped / Total] 356 / 317 / 18 / 691:  69%|██████▉   | 692/1000 [19:41:32<8:45:53, 102.45s/it]Connects to the specified destination. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[compounding]] ( final String [[nonny]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[nonny]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 685 ---------------------------------------------
Sets the request path. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[ignore]] ( String [[attack]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 686 ---------------------------------------------
Creates a host URL string. --> Create a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[hearn]] ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 687 ---------------------------------------------
Add a cookie to the request.@param REPLACEME0 the cookie to add --> SEMPER cookie --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : [[REPLACEME0]] ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "[[False]]" != "[[False]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[SEMPER]] ( final Cookie ... [[SEMPER]] ) { if ( [[SEMPER]] . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : [[SEMPER]] ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { cookieString . append ( "; " ) ; } first = "[[Western]]" != "[[Western]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 688 ---------------------------------------------
Executes the supplied query string. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[dostoevsky]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 689 ---------------------------------------------
Parse the query string and decode it.@param queryString the query string@param decode whether to decode the query string@return this request --> zacharias@param queryString@param decode@return --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( [[queryString]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[zacharias]] ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( [[zacharias]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 690 ---------------------------------------------
Sets the host header. --> Explaination of this request@param hostPort@return --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String hostPort = this . [[host]] ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[explaining]] ( ) { String hostPort = this . [[inuit]] ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 691 ---------------------------------------------
Sets the basic authentication header. --> Convenience method to concatenate the given username and the given walks@param username the username@param walks the walks@return this --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String [[password]] ) { if ( username != null && [[password]] != null ) { String data = username . concat ( StringPool . COLON ) . concat ( [[password]] ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[albatross]] ( final String username , final String [[strolls]] ) { if ( username != null && [[strolls]] != null ) { String data = username . concat ( StringPool . COLON ) . concat ( [[strolls]] ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 692 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 357 / 317 / 18 / 692:  69%|██████▉   | 692/1000 [19:41:32<8:45:53, 102.45s/it][Succeeded / Failed / Skipped / Total] 357 / 317 / 18 / 692:  69%|██████▉   | 693/1000 [19:42:59<8:44:03, 102.42s/it][Succeeded / Failed / Skipped / Total] 357 / 318 / 18 / 693:  69%|██████▉   | 693/1000 [19:42:59<8:44:03, 102.42s/it][Succeeded / Failed / Skipped / Total] 357 / 318 / 18 / 693:  69%|██████▉   | 694/1000 [19:45:56<8:42:54, 102.53s/it][Succeeded / Failed / Skipped / Total] 357 / 319 / 18 / 694:  69%|██████▉   | 694/1000 [19:45:56<8:42:54, 102.53s/it][Succeeded / Failed / Skipped / Total] 357 / 319 / 18 / 694:  70%|██████▉   | 695/1000 [19:46:05<8:40:31, 102.40s/it][Succeeded / Failed / Skipped / Total] 358 / 319 / 18 / 695:  70%|██████▉   | 695/1000 [19:46:05<8:40:31, 102.40s/it][Succeeded / Failed / Skipped / Total] 358 / 319 / 18 / 695:  70%|██████▉   | 696/1000 [19:46:48<8:38:22, 102.31s/it][Succeeded / Failed / Skipped / Total] 359 / 319 / 18 / 696:  70%|██████▉   | 696/1000 [19:46:48<8:38:22, 102.31s/it][Succeeded / Failed / Skipped / Total] 359 / 319 / 18 / 696:  70%|██████▉   | 697/1000 [19:46:50<8:35:56, 102.17s/it][Succeeded / Failed / Skipped / Total] 360 / 319 / 18 / 697:  70%|██████▉   | 697/1000 [19:46:50<8:35:56, 102.17s/it][Succeeded / Failed / Skipped / Total] 360 / 319 / 18 / 697:  70%|██████▉   | 698/1000 [19:47:03<8:33:35, 102.04s/it][Succeeded / Failed / Skipped / Total] 361 / 319 / 18 / 698:  70%|██████▉   | 698/1000 [19:47:03<8:33:35, 102.04s/it][Succeeded / Failed / Skipped / Total] 361 / 319 / 18 / 698:  70%|██████▉   | 699/1000 [19:48:07<8:31:37, 101.98s/it][Succeeded / Failed / Skipped / Total] 361 / 320 / 18 / 699:  70%|██████▉   | 699/1000 [19:48:07<8:31:37, 101.98s/it][Succeeded / Failed / Skipped / Total] 361 / 320 / 18 / 699:  70%|███████   | 700/1000 [19:50:22<8:30:09, 102.03s/it][Succeeded / Failed / Skipped / Total] 361 / 321 / 18 / 700:  70%|███████   | 700/1000 [19:50:22<8:30:09, 102.03s/it][Succeeded / Failed / Skipped / Total] 361 / 321 / 18 / 700:  70%|███████   | 701/1000 [19:51:11<8:28:04, 101.96s/it]Add query parameters to the request. --> Convenience method to create a new aq@param aq@return --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final Map < String , String > [[queryMap]] ) { for ( Map . Entry < String , String > [[entry]] : [[queryMap]] . entrySet ( ) ) { [[query]] . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest [[aqaba]] ( final Map < String , String > [[cultivate]] ) { for ( Map . Entry < String , String > [[tetsuo]] : [[cultivate]] . entrySet ( ) ) { [[aqaba]] . add ( [[tetsuo]] . getKey ( ) , [[tetsuo]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 693 ---------------------------------------------
Sends the request and returns the response. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[beneficiaries]] > [[beneficiaries]] sendAndReceive ( final Function < HttpResponse , [[beneficiaries]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 694 ---------------------------------------------
Collect the interceptors associated with this action. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[garcía]] ( ) { final Collection < ? extends ActionInterceptor > [[strengthening]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[strengthening]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 695 ---------------------------------------------
Collect the action results. --> Shruti --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[shruti]] ( ) { final Collection < ActionResult > [[cardiovascular]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[cardiovascular]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 696 ---------------------------------------------
Sets the value of the specified property. --> Librato version --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[librarians]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 697 ---------------------------------------------
Overrides the default behavior of this buffer. --> Overrides this method to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to provide a way to --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[roaming]] ( final boolean [[nairobi]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 698 ---------------------------------------------
Collect action filters. --> Add a culpeper filter --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[culpeper]] ( ) { final Collection < ? extends ActionFilter > [[perception]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[perception]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 699 ---------------------------------------------
Sorts the list of actions. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[scandalous]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 700 ---------------------------------------------
Returns a copy of this writer. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[romulans]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 701 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 362 / 321 / 18 / 701:  70%|███████   | 701/1000 [19:51:11<8:28:04, 101.96s/it][Succeeded / Failed / Skipped / Total] 362 / 321 / 18 / 701:  70%|███████   | 702/1000 [19:55:53<8:27:39, 102.21s/it][Succeeded / Failed / Skipped / Total] 362 / 322 / 18 / 702:  70%|███████   | 702/1000 [19:55:53<8:27:39, 102.21s/it][Succeeded / Failed / Skipped / Total] 362 / 322 / 18 / 702:  70%|███████   | 703/1000 [19:55:58<8:25:16, 102.08s/it][Succeeded / Failed / Skipped / Total] 363 / 322 / 18 / 703:  70%|███████   | 703/1000 [19:55:58<8:25:16, 102.08s/it][Succeeded / Failed / Skipped / Total] 363 / 322 / 18 / 703:  70%|███████   | 704/1000 [20:01:27<8:25:09, 102.40s/it][Succeeded / Failed / Skipped / Total] 363 / 323 / 18 / 704:  70%|███████   | 704/1000 [20:01:27<8:25:09, 102.40s/it][Succeeded / Failed / Skipped / Total] 363 / 323 / 18 / 704:  70%|███████   | 705/1000 [20:02:09<8:23:01, 102.31s/it][Succeeded / Failed / Skipped / Total] 364 / 323 / 18 / 705:  70%|███████   | 705/1000 [20:02:09<8:23:01, 102.31s/it][Succeeded / Failed / Skipped / Total] 364 / 323 / 18 / 705:  71%|███████   | 706/1000 [20:03:48<8:21:18, 102.31s/it][Succeeded / Failed / Skipped / Total] 364 / 324 / 18 / 706:  71%|███████   | 706/1000 [20:03:48<8:21:18, 102.31s/it][Succeeded / Failed / Skipped / Total] 364 / 324 / 18 / 706:  71%|███████   | 707/1000 [20:04:49<8:19:18, 102.25s/it][Succeeded / Failed / Skipped / Total] 364 / 325 / 18 / 707:  71%|███████   | 707/1000 [20:04:49<8:19:18, 102.25s/it][Succeeded / Failed / Skipped / Total] 364 / 325 / 18 / 707:  71%|███████   | 708/1000 [20:07:17<8:17:55, 102.31s/it]Sets the query parameters. --> Applies a simple heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final String name1 , final Object value1 , final Object ... [[parameters]] ) { [[query]] ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[i]] = 0 ; [[i]] < [[parameters]] . length ; [[i]] += 2 ) { String name = [[parameters]] [ [[i]] ] . toString ( ) ; String value = [[parameters]] [ [[i]] + 1 ] . toString ( ) ; [[query]] . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest [[easygoing]] ( final String name1 , final Object value1 , final Object ... [[concealing]] ) { [[easygoing]] ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int [[kakashi]] = 0 ; [[kakashi]] < [[concealing]] . length ; [[kakashi]] += 2 ) { String name = [[concealing]] [ [[kakashi]] ] . toString ( ) ; String value = [[concealing]] [ [[kakashi]] + 1 ] . toString ( ) ; [[easygoing]] . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 702 ---------------------------------------------
Returns the number of entries in the exception table. --> [[[FAILED]]]

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler firstHandler ) { int [[length]] = 0 ; Handler [[handler]] = firstHandler ; while ( [[handler]] != null ) { [[length]] ++ ; [[handler]] = [[handler]] . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[enema]] ( final Handler firstHandler ) { int [[abhorred]] = 0 ; Handler [[exterminating]] = firstHandler ; while ( [[exterminating]] != null ) { [[abhorred]] ++ ; [[exterminating]] = [[exterminating]] . nextHandler ; } return [[abhorred]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 703 ---------------------------------------------
Gets the object reference for the supplied name.@param name the name of the object.@return the object reference for the supplied name. --> H bangalore@param gunnel@return --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String [[name]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[name]] ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[bangalore]] ( final String [[gunnel]] ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( [[gunnel]] ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Gets the property with the specified name.@param < T> the type parameter@param bean the bean@param name the name@return the property with the specified name --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( [[T]] ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( [[T]] ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[ajar]] > [[ajar]] getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( [[ajar]] ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( [[ajar]] ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 705 ---------------------------------------------
Sets the object reference.@param name the name of the object@param object the object --> Ahhhhhh hhhhhhh hhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[ahhhhh]] ( final String [[flaunts]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[flaunts]] , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 706 ---------------------------------------------
Removes a range handler.@param firstHandler the first handler@param start the range start@param end the range end@return the handler that was removed --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 707 ---------------------------------------------
Extracts the property with the given name from this object. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[apprise]] ( final String [[jag]] ) { int [[jenson]] = StringUtil . indexOfChars ( [[jag]] , INDEX_CHARS ) ; if ( [[jenson]] == - 1 ) { return [[jag]] ; } return [[jag]] . substring ( 0 , [[jenson]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 708 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 364 / 326 / 18 / 708:  71%|███████   | 708/1000 [20:07:17<8:17:55, 102.31s/it][Succeeded / Failed / Skipped / Total] 364 / 326 / 18 / 708:  71%|███████   | 709/1000 [20:07:45<8:15:42, 102.21s/it][Succeeded / Failed / Skipped / Total] 365 / 326 / 18 / 709:  71%|███████   | 709/1000 [20:07:45<8:15:42, 102.21s/it][Succeeded / Failed / Skipped / Total] 365 / 326 / 18 / 709:  71%|███████   | 710/1000 [20:07:58<8:13:23, 102.08s/it][Succeeded / Failed / Skipped / Total] 366 / 326 / 18 / 710:  71%|███████   | 710/1000 [20:07:58<8:13:23, 102.08s/it][Succeeded / Failed / Skipped / Total] 366 / 326 / 18 / 710:  71%|███████   | 711/1000 [20:11:45<8:12:32, 102.26s/it][Succeeded / Failed / Skipped / Total] 366 / 327 / 18 / 711:  71%|███████   | 711/1000 [20:11:45<8:12:32, 102.26s/it][Succeeded / Failed / Skipped / Total] 366 / 327 / 18 / 711:  71%|███████   | 712/1000 [20:15:10<8:11:32, 102.40s/it][Succeeded / Failed / Skipped / Total] 367 / 327 / 18 / 712:  71%|███████   | 712/1000 [20:15:10<8:11:32, 102.40s/it][Succeeded / Failed / Skipped / Total] 367 / 327 / 18 / 712:  71%|███████▏  | 713/1000 [20:17:30<8:10:04, 102.46s/it][Succeeded / Failed / Skipped / Total] 367 / 328 / 18 / 713:  71%|███████▏  | 713/1000 [20:17:30<8:10:04, 102.46s/it][Succeeded / Failed / Skipped / Total] 367 / 328 / 18 / 713:  71%|███████▏  | 714/1000 [20:18:05<8:07:55, 102.36s/it][Succeeded / Failed / Skipped / Total] 367 / 329 / 18 / 714:  71%|███████▏  | 714/1000 [20:18:05<8:07:55, 102.36s/it][Succeeded / Failed / Skipped / Total] 367 / 329 / 18 / 714:  72%|███████▏  | 715/1000 [20:25:37<8:08:32, 102.85s/it]Lookup an object reference. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[cracks]] ( final String [[chord]] ) { Object [[clone]] = getObjectReference ( [[chord]] ) ; if ( [[clone]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[chord]] ) ; } return [[clone]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 709 ---------------------------------------------
Registers a table reference. --> zohra@param tableReference@param ded@param tableAlias --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[t]] = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , [[t]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[zohra]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData [[exorcist]] = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , [[exorcist]] ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 710 ---------------------------------------------
Looks up the table descriptor for the given table. --> Lohith liberty change --> Socre: 1.0

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[lullabies]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 711 ---------------------------------------------
Registers a hint. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[prescribe]] ( final String [[posit]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[posit]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 712 ---------------------------------------------
Get the alias for the specified table.@param tableRef the name of the table.@return the alias for the specified table. --> Retrieves the name of the specified music art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art art --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[concerto]] ( final String [[sceptre]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[bankruptcies]] = tableRefs . get ( [[sceptre]] ) ; return [[bankruptcies]] == null ? null : [[bankruptcies]] . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 713 ---------------------------------------------
Returns the descriptor for the specified table. --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[aircrafts]] ( final String [[supple]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[biz]] = tableRefs . get ( [[supple]] ) ; return [[biz]] == null ? null : [[biz]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 714 ---------------------------------------------
Find the table descriptor by column ref.@param columnRef the column ref@return the descriptor or <code>null</code> --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( [[columnRef]] ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[trucks]] ( final String [[devoutly]] ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( [[devoutly]] ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 715 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 367 / 330 / 18 / 715:  72%|███████▏  | 715/1000 [20:25:37<8:08:32, 102.85s/it][Succeeded / Failed / Skipped / Total] 367 / 330 / 18 / 715:  72%|███████▏  | 716/1000 [20:28:46<8:07:23, 102.97s/it][Succeeded / Failed / Skipped / Total] 367 / 331 / 18 / 716:  72%|███████▏  | 716/1000 [20:28:46<8:07:23, 102.97s/it][Succeeded / Failed / Skipped / Total] 367 / 331 / 18 / 716:  72%|███████▏  | 717/1000 [20:29:36<8:05:19, 102.90s/it][Succeeded / Failed / Skipped / Total] 367 / 332 / 18 / 717:  72%|███████▏  | 717/1000 [20:29:36<8:05:19, 102.90s/it][Succeeded / Failed / Skipped / Total] 367 / 332 / 18 / 717:  72%|███████▏  | 718/1000 [20:32:54<8:04:13, 103.03s/it][Succeeded / Failed / Skipped / Total] 367 / 333 / 18 / 718:  72%|███████▏  | 718/1000 [20:32:54<8:04:13, 103.03s/it][Succeeded / Failed / Skipped / Total] 367 / 333 / 18 / 718:  72%|███████▏  | 719/1000 [20:33:30<8:02:04, 102.94s/it]Inject parameters.@param servletRequest the servlet request@param targets the targets --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { final boolean encode = encodeGetParams && [[servletRequest]] . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = [[servletRequest]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = [[servletRequest]] . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest [[establishments]] , final Targets targets ) { final boolean encode = encodeGetParams && [[establishments]] . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = [[establishments]] . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( [[establishments]] . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = [[establishments]] . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 716 ---------------------------------------------
Inject attributes.@param servletRequest the servlet request@param targets the targets --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { final Enumeration < String > attributeNames = [[servletRequest]] . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String [[attrName]] = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[attrName]] ) ; if ( name != null ) { final Object attrValue = [[servletRequest]] . getAttribute ( [[attrName]] ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest [[stepmother]] , final Targets targets ) { final Enumeration < String > attributeNames = [[stepmother]] . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String [[sold]] = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[sold]] ) ; if ( name != null ) { final Object attrValue = [[stepmother]] . getAttribute ( [[sold]] ) ; target . writeValue ( name , attrValue , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 717 ---------------------------------------------
Injects all uploaded files into the specified targets. --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 718 ---------------------------------------------
Converts the supplied column name to the supplied property name. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String [[columnName]] ) { String [[propertyName]] = convertColumnNameToPropertyName ( [[columnName]] ) ; return convertPropertyNameToColumnName ( [[propertyName]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[runts]] ( final String [[smiling]] ) { String [[chromosomes]] = convertColumnNameToPropertyName ( [[smiling]] ) ; return convertPropertyNameToColumnName ( [[chromosomes]] ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 719 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 367 / 334 / 18 / 719:  72%|███████▏  | 719/1000 [20:33:30<8:02:04, 102.94s/it][Succeeded / Failed / Skipped / Total] 367 / 334 / 18 / 719:  72%|███████▏  | 720/1000 [20:34:25<8:00:03, 102.87s/it][Succeeded / Failed / Skipped / Total] 367 / 335 / 18 / 720:  72%|███████▏  | 720/1000 [20:34:25<8:00:03, 102.87s/it][Succeeded / Failed / Skipped / Total] 367 / 335 / 18 / 720:  72%|███████▏  | 721/1000 [20:35:04<7:57:55, 102.78s/it][Succeeded / Failed / Skipped / Total] 367 / 336 / 18 / 721:  72%|███████▏  | 721/1000 [20:35:04<7:57:55, 102.78s/it][Succeeded / Failed / Skipped / Total] 367 / 336 / 18 / 721:  72%|███████▏  | 722/1000 [20:35:50<7:55:51, 102.70s/it][Succeeded / Failed / Skipped / Total] 367 / 337 / 18 / 722:  72%|███████▏  | 722/1000 [20:35:50<7:55:51, 102.70s/it][Succeeded / Failed / Skipped / Total] 367 / 337 / 18 / 722:  72%|███████▏  | 723/1000 [20:39:32<7:54:54, 102.87s/it][Succeeded / Failed / Skipped / Total] 367 / 338 / 18 / 723:  72%|███████▏  | 723/1000 [20:39:32<7:54:54, 102.87s/it][Succeeded / Failed / Skipped / Total] 367 / 338 / 18 / 723:  72%|███████▏  | 724/1000 [20:42:38<7:53:42, 102.98s/it][Succeeded / Failed / Skipped / Total] 368 / 338 / 18 / 724:  72%|███████▏  | 724/1000 [20:42:38<7:53:42, 102.98s/it][Succeeded / Failed / Skipped / Total] 368 / 338 / 18 / 724:  72%|███████▎  | 725/1000 [20:46:31<7:52:49, 103.16s/it][Succeeded / Failed / Skipped / Total] 368 / 339 / 18 / 725:  72%|███████▎  | 725/1000 [20:46:31<7:52:49, 103.16s/it][Succeeded / Failed / Skipped / Total] 368 / 339 / 18 / 725:  73%|███████▎  | 726/1000 [20:48:13<7:51:05, 103.16s/it][Succeeded / Failed / Skipped / Total] 368 / 340 / 18 / 726:  73%|███████▎  | 726/1000 [20:48:13<7:51:05, 103.16s/it][Succeeded / Failed / Skipped / Total] 368 / 340 / 18 / 726:  73%|███████▎  | 727/1000 [20:52:37<7:50:22, 103.38s/it]Converts the supplied object to the specified destination type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[ducts]] > [[ducts]] prepareGetValue ( final T t , final Class < [[ducts]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[ducts]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 720 ---------------------------------------------
Converts a column name to a property name. --> [[[FAILED]]]

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char [[c]] = columnName . charAt ( i ) ; if ( [[c]] == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( [[c]] ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( [[c]] ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char [[bangalore]] = columnName . charAt ( i ) ; if ( [[bangalore]] == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( [[bangalore]] ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( [[bangalore]] ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 721 ---------------------------------------------
Serializes the given value to the given JSON context. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public final boolean [[serialize]] ( final JsonContext [[jsonContext]] , final T [[value]] ) { if ( [[jsonContext]] . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean [[youngest]] ( final JsonContext [[inquirer]] , final T [[fluffy]] ) { if ( [[inquirer]] . pushValue ( [[fluffy]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 722 ---------------------------------------------
Returns the set of all wrappers. --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[sneha]] ( ) { final Set < T > set = new HashSet <> ( wrappers . size ( ) ) ; set . addAll ( wrappers . values ( ) ) ; return set ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 723 ---------------------------------------------
Creates a wrapper for the given wrapper class. --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[neo]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 724 ---------------------------------------------
Relative path.@param targetPath the target path@param basePath the base path@return the string --> Converts a source file to a manga@param targetPath@param basePath@return --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[manga]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 725 ---------------------------------------------
Converts a property name to a column name. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder [[tableName]] = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[convertedTableName]] = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; [[tableName]] . append ( [[convertedTableName]] ) ; } else { [[tableName]] . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return [[tableName]] . toString ( ) ; } return uppercase ? toUppercase ( [[tableName]] ) . toString ( ) : toLowercase ( [[tableName]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[appleseed]] ( final String [[thinkyou]] ) { StringBuilder [[initiated]] = new StringBuilder ( [[thinkyou]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String [[venga]] = Format . fromCamelCase ( [[thinkyou]] , separatorChar ) ; [[initiated]] . append ( [[venga]] ) ; } else { [[initiated]] . append ( [[thinkyou]] ) ; } if ( ! changeCase ) { return [[initiated]] . toString ( ) ; } return uppercase ? toUppercase ( [[initiated]] ) . toString ( ) : toLowercase ( [[initiated]] ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 726 ---------------------------------------------
Converts a path to a system separator.@param path the path to convert.@return the system separator. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[appreciates]] ( final String [[remarking]] ) { if ( [[remarking]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[remarking]] ) ; } else { return separatorsToUnix ( [[remarking]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 727 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 368 / 341 / 18 / 727:  73%|███████▎  | 727/1000 [20:52:37<7:50:22, 103.38s/it][Succeeded / Failed / Skipped / Total] 368 / 341 / 18 / 727:  73%|███████▎  | 728/1000 [20:53:22<7:48:17, 103.30s/it][Succeeded / Failed / Skipped / Total] 368 / 342 / 18 / 728:  73%|███████▎  | 728/1000 [20:53:22<7:48:17, 103.30s/it][Succeeded / Failed / Skipped / Total] 368 / 342 / 18 / 728:  73%|███████▎  | 729/1000 [20:55:31<7:46:43, 103.34s/it][Succeeded / Failed / Skipped / Total] 369 / 342 / 18 / 729:  73%|███████▎  | 729/1000 [20:55:31<7:46:43, 103.34s/it][Succeeded / Failed / Skipped / Total] 369 / 342 / 18 / 729:  73%|███████▎  | 730/1000 [20:55:47<7:44:28, 103.22s/it][Succeeded / Failed / Skipped / Total] 369 / 343 / 18 / 730:  73%|███████▎  | 730/1000 [20:55:47<7:44:28, 103.22s/it][Succeeded / Failed / Skipped / Total] 369 / 343 / 18 / 730:  73%|███████▎  | 731/1000 [20:56:05<7:42:13, 103.10s/it][Succeeded / Failed / Skipped / Total] 369 / 344 / 18 / 731:  73%|███████▎  | 731/1000 [20:56:05<7:42:13, 103.10s/it][Succeeded / Failed / Skipped / Total] 369 / 344 / 18 / 731:  73%|███████▎  | 732/1000 [20:56:21<7:39:58, 102.98s/it]Starts the web application. --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[bandai]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 728 ---------------------------------------------
Registers an action config consumer with this action manager. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[orville]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 729 ---------------------------------------------
Configures the default actions. --> region > bethlehem --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[bethlehem]] ( ) { final ActionConfigManager [[sexually]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[sexually]] . registerAnnotation ( Action . class ) ; [[sexually]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 730 ---------------------------------------------
Registers all madvoc components. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[dishcloth]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 731 ---------------------------------------------
Splits the supplied filename into an array of Strings.@param filename the filename to split.@return the array of Strings. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] split ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
[Succeeded / Failed / Skipped / Total] 369 / 345 / 18 / 732:  73%|███████▎  | 732/1000 [20:56:21<7:39:58, 102.98s/it][Succeeded / Failed / Skipped / Total] 369 / 345 / 18 / 732:  73%|███████▎  | 733/1000 [20:58:08<7:38:17, 102.99s/it][Succeeded / Failed / Skipped / Total] 369 / 346 / 18 / 733:  73%|███████▎  | 733/1000 [20:58:08<7:38:17, 102.99s/it][Succeeded / Failed / Skipped / Total] 369 / 346 / 18 / 733:  73%|███████▎  | 734/1000 [21:07:40<7:39:24, 103.62s/it][Succeeded / Failed / Skipped / Total] 369 / 347 / 18 / 734:  73%|███████▎  | 734/1000 [21:07:40<7:39:24, 103.62s/it][Succeeded / Failed / Skipped / Total] 369 / 347 / 18 / 734:  74%|███████▎  | 735/1000 [21:10:27<7:38:03, 103.71s/it][Succeeded / Failed / Skipped / Total] 369 / 348 / 18 / 735:  74%|███████▎  | 735/1000 [21:10:27<7:38:03, 103.71s/it][Succeeded / Failed / Skipped / Total] 369 / 348 / 18 / 735:  74%|███████▎  | 736/1000 [21:10:30<7:35:43, 103.57s/it][Succeeded / Failed / Skipped / Total] 369 / 349 / 18 / 736:  74%|███████▎  | 736/1000 [21:10:30<7:35:43, 103.57s/it][Succeeded / Failed / Skipped / Total] 369 / 349 / 18 / 736:  74%|███████▎  | 737/1000 [21:10:48<7:33:29, 103.46s/it][Succeeded / Failed / Skipped / Total] 369 / 350 / 18 / 737:  74%|███████▎  | 737/1000 [21:10:48<7:33:29, 103.46s/it][Succeeded / Failed / Skipped / Total] 369 / 350 / 18 / 737:  74%|███████▍  | 738/1000 [21:11:00<7:31:13, 103.33s/it][Succeeded / Failed / Skipped / Total] 370 / 350 / 18 / 738:  74%|███████▍  | 738/1000 [21:11:00<7:31:13, 103.33s/it][Succeeded / Failed / Skipped / Total] 370 / 350 / 18 / 738:  74%|███████▍  | 739/1000 [21:11:52<7:29:11, 103.26s/it]--------------------------------------------- Result 732 ---------------------------------------------
Registers a madvoc component. --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp [[registerComponent]] ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp [[onight]] ( final Class < ? > [[fleur]] ) { Objects . requireNonNull ( [[fleur]] ) ; madvocComponents . add ( ClassConsumer . of ( [[fleur]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 733 ---------------------------------------------
Resolves the specified wrapper class. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String wrapperClassName = [[wrapperClass]] . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[rearranging]] ( final Class < ? extends T > [[bloods]] ) { String wrapperClassName = [[bloods]] . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( [[bloods]] ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 734 ---------------------------------------------
Sets the value at the specified index. --> [[[FAILED]]]

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int [[dbSqlType]] ) throws SQLException { T [[t]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , [[t]] , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object value , final int [[admit]] ) throws SQLException { T [[bloom]] = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , [[bloom]] , [[admit]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 735 ---------------------------------------------
Includes the specified list of entries in this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... [[includedEntries]] ) { for ( final String includedEntry : [[includedEntries]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[fitzsimmons]] ( final String ... [[disintegrated]] ) { for ( final String includedEntry : [[disintegrated]] ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 736 ---------------------------------------------
Scans a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 737 ---------------------------------------------
Includes the specified jars in the scanner.@param includedJars The jars to include.@return this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String includedJar : [[includedJars]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[microwave]] ( final String ... [[novia]] ) { for ( final String includedJar : [[novia]] ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 738 ---------------------------------------------
Excludes entries from this scanner.@param excludedEntries the entries to exclude.@return this scanner. --> Finds the first non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching non-matching --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeEntries]] ( final String ... [[excludedEntries]] ) { for ( final String [[excludedEntry]] : [[excludedEntries]] ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner [[noria]] ( final String ... [[shooters]] ) { for ( final String [[polarity]] : [[shooters]] ) { rulesEntries . exclude ( [[polarity]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 739 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 370 / 351 / 18 / 739:  74%|███████▍  | 739/1000 [21:11:52<7:29:11, 103.26s/it][Succeeded / Failed / Skipped / Total] 370 / 351 / 18 / 739:  74%|███████▍  | 740/1000 [21:17:23<7:28:48, 103.57s/it][Succeeded / Failed / Skipped / Total] 370 / 352 / 18 / 740:  74%|███████▍  | 740/1000 [21:17:23<7:28:48, 103.57s/it][Succeeded / Failed / Skipped / Total] 370 / 352 / 18 / 740:  74%|███████▍  | 741/1000 [21:17:27<7:26:30, 103.44s/it][Succeeded / Failed / Skipped / Total] 370 / 353 / 18 / 741:  74%|███████▍  | 741/1000 [21:17:27<7:26:30, 103.44s/it][Succeeded / Failed / Skipped / Total] 370 / 353 / 18 / 741:  74%|███████▍  | 742/1000 [21:21:53<7:25:43, 103.66s/it][Succeeded / Failed / Skipped / Total] 370 / 354 / 18 / 742:  74%|███████▍  | 742/1000 [21:21:53<7:25:43, 103.66s/it][Succeeded / Failed / Skipped / Total] 370 / 354 / 18 / 742:  74%|███████▍  | 743/1000 [21:22:56<7:23:45, 103.60s/it][Succeeded / Failed / Skipped / Total] 370 / 355 / 18 / 743:  74%|███████▍  | 743/1000 [21:22:56<7:23:45, 103.60s/it][Succeeded / Failed / Skipped / Total] 370 / 355 / 18 / 743:  74%|███████▍  | 744/1000 [21:24:36<7:22:01, 103.60s/it][Succeeded / Failed / Skipped / Total] 370 / 356 / 18 / 744:  74%|███████▍  | 744/1000 [21:24:36<7:22:01, 103.60s/it][Succeeded / Failed / Skipped / Total] 370 / 356 / 18 / 744:  74%|███████▍  | 745/1000 [21:28:17<7:20:57, 103.75s/it][Succeeded / Failed / Skipped / Total] 370 / 357 / 18 / 745:  74%|███████▍  | 745/1000 [21:28:17<7:20:57, 103.75s/it][Succeeded / Failed / Skipped / Total] 370 / 357 / 18 / 745:  75%|███████▍  | 746/1000 [21:39:14<7:22:22, 104.50s/it][Succeeded / Failed / Skipped / Total] 370 / 358 / 18 / 746:  75%|███████▍  | 746/1000 [21:39:14<7:22:22, 104.50s/it][Succeeded / Failed / Skipped / Total] 370 / 358 / 18 / 746:  75%|███████▍  | 747/1000 [21:41:06<7:20:40, 104.51s/it]Excludes the specified jars from scanning.@param excludedJars the jars to exclude.@return this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String [[excludedJar]] : excludedJars ) { rulesJars . exclude ( [[excludedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String [[employees]] : excludedJars ) { rulesJars . exclude ( [[employees]] ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 740 ---------------------------------------------
Gets the default or scope type.@param < S> the type parameter@param scopeClass the scope class@return the default or scope type --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[bracha]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 741 ---------------------------------------------
Gets the path to the specified filename.@param filename the filename@param separatorAdd the separator index@return the path --> [[[FAILED]]]

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int endIndex = index + separatorAdd ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 742 ---------------------------------------------
Scans the classpath. --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 743 ---------------------------------------------
Start the scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[fontana]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[anywheres]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[anywheres]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 744 ---------------------------------------------
Scans the supplied paths and adds them to this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String [[path]] : [[paths]] ) { filesToScan . add ( new File ( [[path]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[bias]] ( final String ... [[standoffish]] ) { for ( final String [[seeta]] : [[standoffish]] ) { filesToScan . add ( new File ( [[seeta]] ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 745 ---------------------------------------------
Returns the bytecode signature of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class [[type]] ) { final String [[name]] = ' ' + [[type]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[name]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[breathlessly]] ( final Class [[laptops]] ) { final String [[orr]] = ' ' + [[laptops]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[orr]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 746 ---------------------------------------------
Gets or initializes the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope [[getOrInitScope]] ( final Class < ? extends MadvocScope > [[madvocScopeType]] ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( [[madvocScopeType]] ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope [[prevailing]] ( final Class < ? extends MadvocScope > [[birdhouse]] ) { for ( final MadvocScope [[colonnade]] : allScopes ) { if ( [[colonnade]] . getClass ( ) . equals ( [[birdhouse]] ) ) { return [[colonnade]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 747 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 370 / 359 / 18 / 747:  75%|███████▍  | 747/1000 [21:41:06<7:20:40, 104.51s/it][Succeeded / Failed / Skipped / Total] 370 / 359 / 18 / 747:  75%|███████▍  | 748/1000 [21:42:01<7:18:38, 104.44s/it][Succeeded / Failed / Skipped / Total] 370 / 360 / 18 / 748:  75%|███████▍  | 748/1000 [21:42:01<7:18:38, 104.44s/it][Succeeded / Failed / Skipped / Total] 370 / 360 / 18 / 748:  75%|███████▍  | 749/1000 [21:42:06<7:16:21, 104.31s/it][Succeeded / Failed / Skipped / Total] 370 / 361 / 18 / 749:  75%|███████▍  | 749/1000 [21:42:06<7:16:21, 104.31s/it][Succeeded / Failed / Skipped / Total] 370 / 361 / 18 / 749:  75%|███████▌  | 750/1000 [21:42:20<7:14:06, 104.19s/it][Succeeded / Failed / Skipped / Total] 370 / 362 / 18 / 750:  75%|███████▌  | 750/1000 [21:42:20<7:14:06, 104.19s/it][Succeeded / Failed / Skipped / Total] 370 / 362 / 18 / 750:  75%|███████▌  | 751/1000 [21:42:44<7:11:56, 104.08s/it][Succeeded / Failed / Skipped / Total] 371 / 362 / 18 / 751:  75%|███████▌  | 751/1000 [21:42:44<7:11:56, 104.08s/it][Succeeded / Failed / Skipped / Total] 371 / 362 / 18 / 751:  75%|███████▌  | 752/1000 [21:42:52<7:09:40, 103.95s/it][Succeeded / Failed / Skipped / Total] 371 / 363 / 18 / 752:  75%|███████▌  | 752/1000 [21:42:52<7:09:40, 103.95s/it][Succeeded / Failed / Skipped / Total] 371 / 363 / 18 / 752:  75%|███████▌  | 753/1000 [21:43:52<7:07:41, 103.89s/it]Asserts that the specified set of tokens are valid.@param tokenSet the set of tokens. --> [[[FAILED]]]

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 748 ---------------------------------------------
Decodes a char array into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int d = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; d < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ d ++ ] = ( byte ) ( i >> 16 ) ; dest [ d ++ ] = ( byte ) ( i >> 8 ) ; dest [ d ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( d < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; d < len ; r -= 8 ) { dest [ d ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 749 ---------------------------------------------
Registers a scope consumer.@param scopeType the scope type@param madvocScopeConsumer the consumer --> [[[FAILED]]]

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope [[scope]] = getOrInitScope ( [[scopeType]] ) ; [[madvocScopeConsumer]] . accept ( [[scope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[werewolf]] ( final Class < ? extends MadvocScope > [[radicalism]] , final Consumer < MadvocScope > [[versatile]] ) { final MadvocScope [[calming]] = getOrInitScope ( [[radicalism]] ) ; [[versatile]] . accept ( [[calming]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 750 ---------------------------------------------
Creates a new transaction. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected JtxTransaction [[createNewTransaction]] ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction [[evaluate]] ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 751 ---------------------------------------------
Visits a property. --> Swing methods --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[swingers]] ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 752 ---------------------------------------------
Prepare a CSRF token.@param session the session@param timeToLive the time to live@return the token --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , timeToLive ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 753 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 372 / 363 / 18 / 753:  75%|███████▌  | 753/1000 [21:43:52<7:07:41, 103.89s/it][Succeeded / Failed / Skipped / Total] 372 / 363 / 18 / 753:  75%|███████▌  | 754/1000 [21:44:02<7:05:27, 103.77s/it][Succeeded / Failed / Skipped / Total] 373 / 363 / 18 / 754:  75%|███████▌  | 754/1000 [21:44:02<7:05:27, 103.77s/it][Succeeded / Failed / Skipped / Total] 373 / 363 / 18 / 754:  76%|███████▌  | 755/1000 [21:45:13<7:03:32, 103.73s/it][Succeeded / Failed / Skipped / Total] 374 / 363 / 18 / 755:  76%|███████▌  | 755/1000 [21:45:13<7:03:32, 103.73s/it][Succeeded / Failed / Skipped / Total] 374 / 363 / 18 / 755:  76%|███████▌  | 756/1000 [21:52:54<7:03:44, 104.20s/it][Succeeded / Failed / Skipped / Total] 374 / 364 / 18 / 756:  76%|███████▌  | 756/1000 [21:52:54<7:03:44, 104.20s/it][Succeeded / Failed / Skipped / Total] 374 / 364 / 18 / 756:  76%|███████▌  | 757/1000 [21:56:15<7:02:31, 104.33s/it][Succeeded / Failed / Skipped / Total] 374 / 365 / 18 / 757:  76%|███████▌  | 757/1000 [21:56:15<7:02:31, 104.33s/it][Succeeded / Failed / Skipped / Total] 374 / 365 / 18 / 757:  76%|███████▌  | 758/1000 [22:02:41<7:02:17, 104.70s/it][Succeeded / Failed / Skipped / Total] 374 / 366 / 18 / 758:  76%|███████▌  | 758/1000 [22:02:41<7:02:17, 104.70s/it][Succeeded / Failed / Skipped / Total] 374 / 366 / 18 / 758:  76%|███████▌  | 759/1000 [22:03:50<7:00:21, 104.65s/it]Initializes this template with the specified template data. --> region > westchester --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void [[westchester]] ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 754 ---------------------------------------------
Creates a copy of this bean. --> Stalwart a bean --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[stalwart]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 755 ---------------------------------------------
Removes the specified bean from the list of beans. --> CUGAT --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[cugat]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 756 ---------------------------------------------
Creates a copy of this instance. --> [[[FAILED]]]

[[[[Adv]]]]: public static BeanCopy from ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object [[garage]] ) { BeanCopy [[austin]] = new BeanCopy ( [[garage]] ) ; [[austin]] . isSourceMap = [[garage]] instanceof Map ; return [[austin]] ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 757 ---------------------------------------------
Resolve a scope.@param < S> the type of the scope@param scopeType the type of the scope@return the scope --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[scope]] = ( S ) scopes . get ( scopeType ) ; if ( [[scope]] == null ) { try { [[scope]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[scope]] ) ; scopes . put ( scopeType , [[scope]] ) ; } return [[scope]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[psychosexual]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[conflicts]] = ( S ) scopes . get ( scopeType ) ; if ( [[conflicts]] == null ) { try { [[conflicts]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[conflicts]] ) ; scopes . put ( scopeType , [[conflicts]] ) ; } return [[conflicts]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 758 ---------------------------------------------
Registers a bean definition.@param name the bean name@param beanDefinition the bean definition --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 374 / 367 / 18 / 759:  76%|███████▌  | 759/1000 [22:03:50<7:00:21, 104.65s/it][Succeeded / Failed / Skipped / Total] 374 / 367 / 18 / 759:  76%|███████▌  | 760/1000 [22:12:09<7:00:41, 105.17s/it][Succeeded / Failed / Skipped / Total] 374 / 368 / 18 / 760:  76%|███████▌  | 760/1000 [22:12:09<7:00:41, 105.17s/it][Succeeded / Failed / Skipped / Total] 374 / 368 / 18 / 760:  76%|███████▌  | 761/1000 [22:13:47<6:58:53, 105.16s/it][Succeeded / Failed / Skipped / Total] 374 / 369 / 18 / 761:  76%|███████▌  | 761/1000 [22:13:47<6:58:53, 105.16s/it][Succeeded / Failed / Skipped / Total] 374 / 369 / 18 / 761:  76%|███████▌  | 762/1000 [22:22:06<6:59:11, 105.68s/it][Succeeded / Failed / Skipped / Total] 374 / 370 / 18 / 762:  76%|███████▌  | 762/1000 [22:22:06<6:59:11, 105.68s/it][Succeeded / Failed / Skipped / Total] 374 / 370 / 18 / 762:  76%|███████▋  | 763/1000 [22:32:17<7:00:02, 106.34s/it]Resolve the bean names for the given type.@param type the type@return the bean names --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 760 ---------------------------------------------
Registers a property injection point.@param beanName the bean name@param property the property@param reference the reference --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Checks if a CSRF token is present in the session.@param session the session@param tokenValue the token value@return true if the token is present in the session, false otherwise --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[session]] , final String [[tokenValue]] ) { Set < Token > tokenSet = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[tokenValue]] == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( [[tokenValue]] == null ) ) { return "[[False]]" != "[[False]]" ; } boolean found = "[[False]]" != "[[False]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[tokenValue]] ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[divine]] , final String [[terence]] ) { Set < Token > tokenSet = ( Set < Token > ) [[divine]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[terence]] == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( [[terence]] == null ) ) { return "[[Rago]]" != "[[Rago]]" ; } boolean found = "[[Rago]]" != "[[Rago]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[terence]] ) ) { it . remove ( ) ; found = "True" == "True" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 762 ---------------------------------------------
Registers a set injection point.@param beanName the bean name@param property the property --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 374 / 371 / 18 / 763:  76%|███████▋  | 763/1000 [22:32:17<7:00:02, 106.34s/it][Succeeded / Failed / Skipped / Total] 374 / 371 / 18 / 763:  76%|███████▋  | 764/1000 [22:32:46<6:57:52, 106.24s/it][Succeeded / Failed / Skipped / Total] 375 / 371 / 18 / 764:  76%|███████▋  | 764/1000 [22:32:46<6:57:52, 106.24s/it][Succeeded / Failed / Skipped / Total] 375 / 371 / 18 / 764:  76%|███████▋  | 765/1000 [22:34:23<6:56:03, 106.23s/it][Succeeded / Failed / Skipped / Total] 375 / 372 / 18 / 765:  76%|███████▋  | 765/1000 [22:34:23<6:56:03, 106.23s/it][Succeeded / Failed / Skipped / Total] 375 / 372 / 18 / 765:  77%|███████▋  | 766/1000 [22:34:51<6:53:53, 106.13s/it][Succeeded / Failed / Skipped / Total] 375 / 373 / 18 / 766:  77%|███████▋  | 766/1000 [22:34:51<6:53:53, 106.13s/it][Succeeded / Failed / Skipped / Total] 375 / 373 / 18 / 766:  77%|███████▋  | 767/1000 [22:47:01<6:55:16, 106.94s/it]Register Petite init methods.@param beanName the bean name@param invocationStrategy the invocation strategy@param initMethodNames the init method names --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 764 ---------------------------------------------
Iterate through all registered bean types and pass them to the bean name consumer. --> zanthe bean name consumer --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[zant]] ( final Class type , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , type ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 765 ---------------------------------------------
Register Petite destroy methods.@param beanName the bean name@param destroyMethodNames the destroy method names --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 766 ---------------------------------------------
Registers an injection point for the specified Petite method. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
[Succeeded / Failed / Skipped / Total] 375 / 374 / 18 / 767:  77%|███████▋  | 767/1000 [22:47:01<6:55:16, 106.94s/it][Succeeded / Failed / Skipped / Total] 375 / 374 / 18 / 767:  77%|███████▋  | 768/1000 [22:50:26<6:53:59, 107.07s/it][Succeeded / Failed / Skipped / Total] 376 / 374 / 18 / 768:  77%|███████▋  | 768/1000 [22:50:26<6:53:59, 107.07s/it][Succeeded / Failed / Skipped / Total] 376 / 374 / 18 / 768:  77%|███████▋  | 769/1000 [22:53:27<6:52:34, 107.16s/it][Succeeded / Failed / Skipped / Total] 376 / 375 / 18 / 769:  77%|███████▋  | 769/1000 [22:53:27<6:52:34, 107.16s/it][Succeeded / Failed / Skipped / Total] 376 / 375 / 18 / 769:  77%|███████▋  | 770/1000 [22:54:39<6:50:36, 107.12s/it][Succeeded / Failed / Skipped / Total] 377 / 375 / 18 / 770:  77%|███████▋  | 770/1000 [22:54:39<6:50:36, 107.12s/it][Succeeded / Failed / Skipped / Total] 377 / 375 / 18 / 770:  77%|███████▋  | 771/1000 [22:57:58<6:49:16, 107.24s/it][Succeeded / Failed / Skipped / Total] 377 / 376 / 18 / 771:  77%|███████▋  | 771/1000 [22:57:58<6:49:16, 107.24s/it][Succeeded / Failed / Skipped / Total] 377 / 376 / 18 / 771:  77%|███████▋  | 772/1000 [23:00:56<6:47:50, 107.33s/it]--------------------------------------------- Result 767 ---------------------------------------------
Defines a map of parameters.@param properties the map of parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > [[entry]] : [[properties]] . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[eradication]] ( final Map < ? , ? > [[resonates]] ) { for ( Map . Entry < ? , ? > [[zero]] : [[resonates]] . entrySet ( ) ) { defineParameter ( [[zero]] . getKey ( ) . toString ( ) , [[zero]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 768 ---------------------------------------------
Resolves a Java version number.@param versionThe Java version number.@return The Java version number. --> Checks to see if buck is greater than 90% --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int [[javaVersionNumber]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = [[javaVersionNumber]] - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[affectation]] ( final int [[buck]] ) { final int [[breach]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[beers]] = [[breach]] - 8 + 52 ; return [[buck]] > [[beers]] ? [[buck]] : [[beers]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 769 ---------------------------------------------
Registers a Petite Ctor injection point.@param beanName the bean name@param paramTypes the parameter types@param references the references --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 770 ---------------------------------------------
Returns advice field name. --> Computes the dot-separated dot-separated dot-separated dot-separated dot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separateddot-separated --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[devdas]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 771 ---------------------------------------------
Registers a custom Petite bean.@param < T > the type of the bean to be registered@param type the type of the bean to be registered@param name the name of the bean to be registered@param scopeType the scope of the bean to be registered@param wiringMode the wiring mode of the bean to be registered@param define {@code true} if the bean should be defined, {@code false} otherwise@param consumer the consumer --> [[[FAILED]]]

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String name , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( name == null ) { name = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 772 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 378 / 376 / 18 / 772:  77%|███████▋  | 772/1000 [23:00:56<6:47:50, 107.33s/it][Succeeded / Failed / Skipped / Total] 378 / 376 / 18 / 772:  77%|███████▋  | 773/1000 [23:02:49<6:46:05, 107.34s/it][Succeeded / Failed / Skipped / Total] 378 / 377 / 18 / 773:  77%|███████▋  | 773/1000 [23:02:49<6:46:05, 107.34s/it][Succeeded / Failed / Skipped / Total] 378 / 377 / 18 / 773:  77%|███████▋  | 774/1000 [23:03:31<6:43:58, 107.25s/it][Succeeded / Failed / Skipped / Total] 378 / 378 / 18 / 774:  77%|███████▋  | 774/1000 [23:03:31<6:43:58, 107.25s/it][Succeeded / Failed / Skipped / Total] 378 / 378 / 18 / 774:  78%|███████▊  | 775/1000 [23:03:50<6:41:45, 107.14s/it][Succeeded / Failed / Skipped / Total] 379 / 378 / 18 / 775:  78%|███████▊  | 775/1000 [23:03:50<6:41:45, 107.14s/it][Succeeded / Failed / Skipped / Total] 379 / 378 / 18 / 775:  78%|███████▊  | 776/1000 [23:04:19<6:39:35, 107.04s/it][Succeeded / Failed / Skipped / Total] 379 / 379 / 18 / 776:  78%|███████▊  | 776/1000 [23:04:19<6:39:35, 107.04s/it][Succeeded / Failed / Skipped / Total] 379 / 379 / 18 / 776:  78%|███████▊  | 777/1000 [23:05:04<6:37:31, 106.96s/it][Succeeded / Failed / Skipped / Total] 380 / 379 / 18 / 777:  78%|███████▊  | 777/1000 [23:05:04<6:37:31, 106.96s/it][Succeeded / Failed / Skipped / Total] 380 / 379 / 18 / 777:  78%|███████▊  | 778/1000 [23:08:38<6:36:14, 107.09s/it][Succeeded / Failed / Skipped / Total] 380 / 380 / 18 / 778:  78%|███████▊  | 778/1000 [23:08:38<6:36:14, 107.09s/it][Succeeded / Failed / Skipped / Total] 380 / 380 / 18 / 778:  78%|███████▊  | 779/1000 [23:13:53<6:35:26, 107.36s/it]Returns advice method name. --> Create a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String name , final int [[index]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[heavers]] ( final String name , final int [[woodsmen]] ) { return ProxettaNames . methodPrefix + name + ProxettaNames . methodDivider + [[woodsmen]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 773 ---------------------------------------------
Adds an int to the end of the stack. --> [[[FAILED]]]

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[shed]] , final int [[historians]] ) { if ( [[historians]] <= 5 ) { [[shed]] . visitInsn ( ICONST_0 + [[historians]] ) ; } else if ( [[historians]] <= Byte . MAX_VALUE ) { [[shed]] . visitIntInsn ( BIPUSH , [[historians]] ) ; } else { [[shed]] . visitIntInsn ( SIPUSH , [[historians]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 774 ---------------------------------------------
Registers a provider for the specified Petite type. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String [[staticMethodName]] , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[staticMethodName]] , arguments , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[staticMethodName]] ) ; } ProviderDefinition [[providerDefinition]] = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , [[providerDefinition]] ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String [[yelling]] , final Class [ ] arguments ) { ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[yelling]] , arguments , "[[Oddity]]" == "[[Oddity]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[yelling]] ) ; } ProviderDefinition [[genitals]] = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , [[genitals]] ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 775 ---------------------------------------------
Loads the static method arguments.@param mv the method visitor.@param methodInfo the method info. --> Ahhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhhh --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[ahhhhhhh]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 776 ---------------------------------------------
Intercepts the supplied action request. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object result = null ; try { result = actionRequest . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 777 ---------------------------------------------
Loads the special arguments for the given method. --> Handles a generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic generic --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[healing]] ( final MethodVisitor [[discounts]] , final MethodInfo methodInfo ) { [[discounts]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[discounts]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 778 ---------------------------------------------
Throws an exception if the index is out of bounds. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[polymer]] ( final MethodInfo methodInfo , final int [[implausible]] ) { if ( ( [[implausible]] < 1 ) || ( [[implausible]] > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[implausible]] ) ; } }
[[[[Nl]]]]: Validates argument index .
[Succeeded / Failed / Skipped / Total] 381 / 380 / 18 / 779:  78%|███████▊  | 779/1000 [23:13:53<6:35:26, 107.36s/it][Succeeded / Failed / Skipped / Total] 381 / 380 / 18 / 779:  78%|███████▊  | 780/1000 [23:18:49<6:34:32, 107.60s/it][Succeeded / Failed / Skipped / Total] 381 / 381 / 18 / 780:  78%|███████▊  | 780/1000 [23:18:49<6:34:32, 107.60s/it][Succeeded / Failed / Skipped / Total] 381 / 381 / 18 / 780:  78%|███████▊  | 781/1000 [23:24:22<6:33:48, 107.89s/it][Succeeded / Failed / Skipped / Total] 382 / 381 / 18 / 781:  78%|███████▊  | 781/1000 [23:24:22<6:33:48, 107.89s/it][Succeeded / Failed / Skipped / Total] 382 / 381 / 18 / 781:  78%|███████▊  | 782/1000 [23:25:55<6:31:56, 107.87s/it][Succeeded / Failed / Skipped / Total] 383 / 381 / 18 / 782:  78%|███████▊  | 782/1000 [23:25:55<6:31:56, 107.87s/it][Succeeded / Failed / Skipped / Total] 383 / 381 / 18 / 782:  78%|███████▊  | 783/1000 [23:28:57<6:30:28, 107.97s/it][Succeeded / Failed / Skipped / Total] 383 / 382 / 18 / 783:  78%|███████▊  | 783/1000 [23:28:57<6:30:28, 107.97s/it][Succeeded / Failed / Skipped / Total] 383 / 382 / 18 / 783:  78%|███████▊  | 784/1000 [23:29:04<6:28:12, 107.84s/it]--------------------------------------------- Result 779 ---------------------------------------------
Creates a new array of the specified type. --> MUST be called only once --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[muckle]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 780 ---------------------------------------------
Registers a provider for the specified Petite bean. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 781 ---------------------------------------------
Create a method signature key. --> Append a description to the end of the description string@param breathless@param methodName@param description@param operators@return --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int [[access]] , final String methodName , final String description , final String [[className]] ) { return new StringBand ( 7 ) . append ( [[access]] ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[className]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[treated]] ( final int [[breathless]] , final String methodName , final String description , final String [[operatives]] ) { return new StringBand ( 7 ) . append ( [[breathless]] ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( [[operatives]] ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 782 ---------------------------------------------
Prepares a return value instruction.@param mva method visitor@param methodInfothe method info@param varOffsetthe offset --> Performs a color-based color-based color-based color-based color-based color-based color-based color-based color-based color-based --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[colorless]] ( final MethodVisitor [[synthetic]] , final MethodInfo [[babies]] , int [[smattering]] ) { [[smattering]] += [[babies]] . getAllArgumentsSize ( ) ; switch ( [[babies]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[synthetic]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[synthetic]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[synthetic]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 783 ---------------------------------------------
Loads the virtual method arguments.@param mv the method visitor.@param methodInfo the method info. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[radical]] ( final MethodVisitor [[faithfully]] , final MethodInfo methodInfo ) { for ( int [[incomparable]] = 1 ; [[incomparable]] <= methodInfo . getArgumentsCount ( ) ; [[incomparable]] ++ ) { loadMethodArgument ( [[faithfully]] , methodInfo , [[incomparable]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
[Succeeded / Failed / Skipped / Total] 383 / 383 / 18 / 784:  78%|███████▊  | 784/1000 [23:29:04<6:28:12, 107.84s/it][Succeeded / Failed / Skipped / Total] 383 / 383 / 18 / 784:  78%|███████▊  | 785/1000 [23:31:13<6:26:30, 107.86s/it][Succeeded / Failed / Skipped / Total] 383 / 384 / 18 / 785:  78%|███████▊  | 785/1000 [23:31:13<6:26:30, 107.86s/it][Succeeded / Failed / Skipped / Total] 383 / 384 / 18 / 785:  79%|███████▊  | 786/1000 [23:31:20<6:24:15, 107.74s/it][Succeeded / Failed / Skipped / Total] 384 / 384 / 18 / 786:  79%|███████▊  | 786/1000 [23:31:20<6:24:15, 107.74s/it][Succeeded / Failed / Skipped / Total] 384 / 384 / 18 / 786:  79%|███████▊  | 787/1000 [23:31:22<6:21:59, 107.60s/it][Succeeded / Failed / Skipped / Total] 385 / 384 / 18 / 787:  79%|███████▊  | 787/1000 [23:31:22<6:21:59, 107.60s/it][Succeeded / Failed / Skipped / Total] 385 / 384 / 18 / 787:  79%|███████▉  | 788/1000 [23:32:10<6:19:55, 107.53s/it][Succeeded / Failed / Skipped / Total] 385 / 385 / 18 / 788:  79%|███████▉  | 788/1000 [23:32:10<6:19:55, 107.53s/it][Succeeded / Failed / Skipped / Total] 385 / 385 / 18 / 788:  79%|███████▉  | 789/1000 [23:44:36<6:20:58, 108.34s/it]--------------------------------------------- Result 784 ---------------------------------------------
Stores an int into an array.@param mva method visitor.@param componentTypethe component type. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor [[mv]] , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { [[mv]] . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { [[mv]] . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { [[mv]] . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { [[mv]] . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { [[mv]] . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { [[mv]] . visitInsn ( CASTORE ) ; return ; } [[mv]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[zoomed]] ( final MethodVisitor [[continents]] , final Class [[wives]] ) { if ( [[wives]] == int . class ) { [[continents]] . visitInsn ( IASTORE ) ; return ; } if ( [[wives]] == long . class ) { [[continents]] . visitInsn ( LASTORE ) ; return ; } if ( [[wives]] == float . class ) { [[continents]] . visitInsn ( FASTORE ) ; return ; } if ( [[wives]] == double . class ) { [[continents]] . visitInsn ( DASTORE ) ; return ; } if ( [[wives]] == byte . class ) { [[continents]] . visitInsn ( BASTORE ) ; return ; } if ( [[wives]] == short . class ) { [[continents]] . visitInsn ( SASTORE ) ; return ; } if ( [[wives]] == boolean . class ) { [[continents]] . visitInsn ( BASTORE ) ; return ; } if ( [[wives]] == char . class ) { [[continents]] . visitInsn ( CASTORE ) ; return ; } [[continents]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 785 ---------------------------------------------
Loads the argument at the given index.@param mv the method visitor.@param methodInfo the method info.@param index the index. --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 786 ---------------------------------------------
Require authentication.@param responsethe response@param realmthe realm@throws IOExceptionSignals that an I/O exception has occurred. --> SCHMALTZ OPTIONAL --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[schmaltz]] ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 787 ---------------------------------------------
Returns true if the given flags are empty. --> Zoom to the specified position. --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[zoom]] ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 788 ---------------------------------------------
Stores an argument at the given index.@param mv the method visitor.@param methodInfo the method info.@param index the index. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[mv]] . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : [[mv]] . visitVarInsn ( DSTORE , offset ) ; break ; default : [[mv]] . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor [[chompers]] , final MethodInfo [[trembler]] , final int index ) { int offset = [[trembler]] . getArgumentOffset ( index ) ; int type = [[trembler]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : [[chompers]] . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : [[chompers]] . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : [[chompers]] . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : [[chompers]] . visitVarInsn ( DSTORE , offset ) ; break ; default : [[chompers]] . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 789 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 386 / 385 / 18 / 789:  79%|███████▉  | 789/1000 [23:44:36<6:20:58, 108.34s/it][Succeeded / Failed / Skipped / Total] 386 / 385 / 18 / 789:  79%|███████▉  | 790/1000 [23:50:00<6:20:07, 108.61s/it][Succeeded / Failed / Skipped / Total] 386 / 386 / 18 / 790:  79%|███████▉  | 790/1000 [23:50:00<6:20:07, 108.61s/it][Succeeded / Failed / Skipped / Total] 386 / 386 / 18 / 790:  79%|███████▉  | 791/1000 [23:50:16<6:17:54, 108.49s/it][Succeeded / Failed / Skipped / Total] 387 / 386 / 18 / 791:  79%|███████▉  | 791/1000 [23:50:16<6:17:54, 108.49s/it][Succeeded / Failed / Skipped / Total] 387 / 386 / 18 / 791:  79%|███████▉  | 792/1000 [24:02:34<6:18:51, 109.29s/it][Succeeded / Failed / Skipped / Total] 387 / 387 / 18 / 792:  79%|███████▉  | 792/1000 [24:02:34<6:18:51, 109.29s/it][Succeeded / Failed / Skipped / Total] 387 / 387 / 18 / 792:  79%|███████▉  | 793/1000 [24:02:52<6:16:38, 109.17s/it][Succeeded / Failed / Skipped / Total] 388 / 387 / 18 / 793:  79%|███████▉  | 793/1000 [24:02:52<6:16:38, 109.17s/it][Succeeded / Failed / Skipped / Total] 388 / 387 / 18 / 793:  79%|███████▉  | 794/1000 [24:04:26<6:14:45, 109.15s/it]Prepares the response for download.@param response the servlet response@param file the file@param mimeType the mime type --> Performs a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse response , final File [[file]] , final String [[mimeType]] ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( response , [[file]] . getAbsolutePath ( ) , [[mimeType]] , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[phillippe]] ( final HttpServletResponse response , final File [[crusts]] , final String [[yoour]] ) { if ( ! [[crusts]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[crusts]] ) ; } if ( [[crusts]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[crusts]] ) ; } prepareResponse ( response , [[crusts]] . getAbsolutePath ( ) , [[yoour]] , ( int ) [[crusts]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 790 ---------------------------------------------
Resolves the bearer token header.@param request the servlet request.@return the bearer token header or <code>null</code> if none. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest request ) { String [[header]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int ndx = [[header]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[header]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[inadvertently]] ( final HttpServletRequest request ) { String [[prescriptions]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[prescriptions]] == null ) { return null ; } int ndx = [[prescriptions]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[prescriptions]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 791 ---------------------------------------------
Reads the request body from the specified request. --> Deus@param annul@return@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader [[buff]] = [[request]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[buff]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[deus]] ( final HttpServletRequest [[annul]] ) throws IOException { BufferedReader [[flames]] = [[annul]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( [[flames]] , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 792 ---------------------------------------------
Retrieves all the cookies with the specified name.@param request the current HttpServletRequest.@param cookieName the name of the cookie to retrieve.@return all the cookies with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 793 ---------------------------------------------
Sets the response content type and file size. --> zhao zhao@param surplus@param fileName@param mimeType@param durian --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse [[response]] , final String fileName , String mimeType , final int [[fileSize]] ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[extension]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { [[response]] . setContentType ( mimeType ) ; } if ( [[fileSize]] >= 0 ) { [[response]] . setContentLength ( [[fileSize]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[zhao]] ( final HttpServletResponse [[surplus]] , final String fileName , String mimeType , final int [[durian]] ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[bestowing]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[bestowing]] ) ; } if ( mimeType != null ) { [[surplus]] . setContentType ( mimeType ) ; } if ( [[durian]] >= 0 ) { [[surplus]] . setContentLength ( [[durian]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 794 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 388 / 388 / 18 / 794:  79%|███████▉  | 794/1000 [24:04:26<6:14:45, 109.15s/it][Succeeded / Failed / Skipped / Total] 388 / 388 / 18 / 794:  80%|███████▉  | 795/1000 [24:05:53<6:12:50, 109.12s/it][Succeeded / Failed / Skipped / Total] 388 / 389 / 18 / 795:  80%|███████▉  | 795/1000 [24:05:53<6:12:50, 109.12s/it][Succeeded / Failed / Skipped / Total] 388 / 389 / 18 / 795:  80%|███████▉  | 796/1000 [24:06:00<6:10:35, 109.00s/it][Succeeded / Failed / Skipped / Total] 388 / 390 / 18 / 796:  80%|███████▉  | 796/1000 [24:06:00<6:10:35, 109.00s/it][Succeeded / Failed / Skipped / Total] 388 / 390 / 18 / 796:  80%|███████▉  | 797/1000 [24:11:35<6:09:43, 109.28s/it][Succeeded / Failed / Skipped / Total] 389 / 390 / 18 / 797:  80%|███████▉  | 797/1000 [24:11:35<6:09:43, 109.28s/it][Succeeded / Failed / Skipped / Total] 389 / 390 / 18 / 797:  80%|███████▉  | 798/1000 [24:16:35<6:08:42, 109.52s/it][Succeeded / Failed / Skipped / Total] 389 / 391 / 18 / 798:  80%|███████▉  | 798/1000 [24:16:35<6:08:42, 109.52s/it][Succeeded / Failed / Skipped / Total] 389 / 391 / 18 / 798:  80%|███████▉  | 799/1000 [24:18:22<6:06:52, 109.52s/it][Succeeded / Failed / Skipped / Total] 390 / 391 / 18 / 799:  80%|███████▉  | 799/1000 [24:18:22<6:06:52, 109.52s/it][Succeeded / Failed / Skipped / Total] 390 / 391 / 18 / 799:  80%|████████  | 800/1000 [24:20:59<6:05:14, 109.57s/it][Succeeded / Failed / Skipped / Total] 390 / 392 / 18 / 800:  80%|████████  | 800/1000 [24:20:59<6:05:14, 109.57s/it][Succeeded / Failed / Skipped / Total] 390 / 392 / 18 / 800:  80%|████████  | 801/1000 [24:24:51<6:03:55, 109.73s/it]Reads the specified request body from the specified request stream.@param request the specified request@return the specified request body@throws IOException if an I/O error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 795 ---------------------------------------------
Extracts the encoding from the content type.@param contentType the content type@param defaultEncoding the default encoding@return the encoding --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String [[defaultEncoding]] ) { String [[encoding]] = [[extractEncoding]] ( [[contentType]] ) ; if ( [[encoding]] == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } [[encoding]] = [[defaultEncoding]] ; } return [[encoding]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[conclusions]] ( final String [[scribbles]] , String [[unethical]] ) { String [[sorrowing]] = [[conclusions]] ( [[scribbles]] ) ; if ( [[sorrowing]] == null ) { if ( [[unethical]] == null ) { [[unethical]] = JoddCore . encoding ; } [[sorrowing]] = [[unethical]] ; } return [[sorrowing]] ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 796 ---------------------------------------------
Stores the given context path variable in the given page context. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeContextPath ( final PageContext [[pageContext]] , final String [[contextPathVariableName]] ) { String ctxPath = getContextPath ( [[pageContext]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[pageContext]] . getRequest ( ) ; request . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; servletContext . setAttribute ( [[contextPathVariableName]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final PageContext [[southampton]] , final String [[towel]] ) { String ctxPath = getContextPath ( [[southampton]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[southampton]] . getRequest ( ) ; request . setAttribute ( [[towel]] , ctxPath ) ; ServletContext servletContext = [[southampton]] . getServletContext ( ) ; servletContext . setAttribute ( [[towel]] , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 797 ---------------------------------------------
Stores a context path variable in the servlet context. --> Set the value of the bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgesthe bobgest --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[beit]] ( final ServletContext servletContext , final String [[nods]] ) { String [[cheerleading]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( [[nods]] , [[cheerleading]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 798 ---------------------------------------------
Invokes the body of the tag. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[frown]] ( final JspFragment [[messrs]] ) throws JspException { if ( [[messrs]] == null ) { return ; } try { [[messrs]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 799 ---------------------------------------------
Calls all destroy methods. --> zetas --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[zetas]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 800 ---------------------------------------------
Invokes all registered init methods. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[isthe]] ( final InitMethodInvocationStrategy [[hamel]] ) { for ( final InitMethodPoint [[complicated]] : beanDefinition . initMethodPoints ( ) ) { if ( [[hamel]] != [[complicated]] . invocationStrategy ) { continue ; } try { [[complicated]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[complicated]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 801 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 391 / 392 / 18 / 801:  80%|████████  | 801/1000 [24:24:51<6:03:55, 109.73s/it][Succeeded / Failed / Skipped / Total] 391 / 392 / 18 / 801:  80%|████████  | 802/1000 [24:25:29<6:01:48, 109.64s/it][Succeeded / Failed / Skipped / Total] 392 / 392 / 18 / 802:  80%|████████  | 802/1000 [24:25:29<6:01:48, 109.64s/it][Succeeded / Failed / Skipped / Total] 392 / 392 / 18 / 802:  80%|████████  | 803/1000 [24:26:38<5:59:48, 109.59s/it][Succeeded / Failed / Skipped / Total] 392 / 393 / 18 / 803:  80%|████████  | 803/1000 [24:26:38<5:59:48, 109.59s/it][Succeeded / Failed / Skipped / Total] 392 / 393 / 18 / 803:  80%|████████  | 804/1000 [24:27:42<5:57:47, 109.53s/it][Succeeded / Failed / Skipped / Total] 393 / 393 / 18 / 804:  80%|████████  | 804/1000 [24:27:42<5:57:47, 109.53s/it][Succeeded / Failed / Skipped / Total] 393 / 393 / 18 / 804:  80%|████████  | 805/1000 [24:29:24<5:55:56, 109.52s/it][Succeeded / Failed / Skipped / Total] 394 / 393 / 18 / 805:  80%|████████  | 805/1000 [24:29:24<5:55:56, 109.52s/it][Succeeded / Failed / Skipped / Total] 394 / 393 / 18 / 805:  81%|████████  | 806/1000 [24:31:24<5:54:09, 109.53s/it][Succeeded / Failed / Skipped / Total] 394 / 394 / 18 / 806:  81%|████████  | 806/1000 [24:31:24<5:54:09, 109.53s/it][Succeeded / Failed / Skipped / Total] 394 / 394 / 18 / 806:  81%|████████  | 807/1000 [24:33:46<5:52:27, 109.57s/it][Succeeded / Failed / Skipped / Total] 394 / 395 / 18 / 807:  81%|████████  | 807/1000 [24:33:46<5:52:27, 109.57s/it][Succeeded / Failed / Skipped / Total] 394 / 395 / 18 / 807:  81%|████████  | 808/1000 [24:44:32<5:52:45, 110.24s/it]Checks if the specified parameter is a GET parameter.@param request the servlet request@param name the parameter name@return true if the parameter is a GET parameter, false otherwise --> Diese Methode@param ecco@param name@return --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest [[request]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[request]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[pour]] ( final HttpServletRequest [[ecco]] , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = [[ecco]] . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "[[Improvements]]" == "[[Improvements]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 802 ---------------------------------------------
Rewrites the given action path. --> Rewrite a cathay@param servletRequest@param cathay@param httpMethod@return --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[cathay]] , final String httpMethod ) { return [[cathay]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 803 ---------------------------------------------
Renders the body of a JSP fragment. --> [[[FAILED]]]

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter [[writer]] = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , [[writer]] ) ; return [[writer]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[unacceptable]] ( final JspFragment [[insightful]] ) throws JspException { FastCharArrayWriter [[buzzy]] = new FastCharArrayWriter ( ) ; invokeBody ( [[insightful]] , [[buzzy]] ) ; return [[buzzy]] . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 804 ---------------------------------------------
Puts a value into the map.@param profile the profile name@param map the map@param key the key@param value the value --> Called when an appender is being constructed. --> Socre: 1.0

[[[[Adv]]]]: protected void [[put]] ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void [[aroused]] ( final String profile , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , profile , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 805 ---------------------------------------------
Inject parameters.@param paramManager the param manager@param implicitParamInjection the implicit param injection --> Determines if the bean is in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in the correct sense of being in --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager [[paramManager]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[culture]] ( final ParamManager [[pausing]] , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 806 ---------------------------------------------
Renders the body to a string.@param body the body to render.@return the rendered body.@throws JspException if the body cannot be rendered. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] result = renderBody ( [[body]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[akemi]] ( final JspFragment [[churchgoing]] ) throws JspException { char [ ] result = renderBody ( [[churchgoing]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 807 ---------------------------------------------
Creates a new bean instance. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[paramNo]] = beanDefinition . ctor . references . length ; Object [ ] [[args]] = new Object [ [[paramNo]] ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[mathematically]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[exonerate]] = beanDefinition . ctor . references . length ; Object [ ] [[coronet]] = new Object [ [[exonerate]] ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 808 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 394 / 396 / 18 / 808:  81%|████████  | 808/1000 [24:44:32<5:52:45, 110.24s/it][Succeeded / Failed / Skipped / Total] 394 / 396 / 18 / 808:  81%|████████  | 809/1000 [24:45:04<5:50:36, 110.14s/it][Succeeded / Failed / Skipped / Total] 394 / 397 / 18 / 809:  81%|████████  | 809/1000 [24:45:04<5:50:36, 110.14s/it][Succeeded / Failed / Skipped / Total] 394 / 397 / 18 / 809:  81%|████████  | 810/1000 [24:46:27<5:48:40, 110.11s/it][Succeeded / Failed / Skipped / Total] 395 / 397 / 18 / 810:  81%|████████  | 810/1000 [24:46:27<5:48:40, 110.11s/it][Succeeded / Failed / Skipped / Total] 395 / 397 / 18 / 810:  81%|████████  | 811/1000 [24:47:23<5:46:37, 110.04s/it][Succeeded / Failed / Skipped / Total] 395 / 398 / 18 / 811:  81%|████████  | 811/1000 [24:47:23<5:46:37, 110.04s/it][Succeeded / Failed / Skipped / Total] 395 / 398 / 18 / 811:  81%|████████  | 812/1000 [25:00:59<5:47:31, 110.91s/it][Succeeded / Failed / Skipped / Total] 396 / 398 / 18 / 812:  81%|████████  | 812/1000 [25:00:59<5:47:31, 110.91s/it][Succeeded / Failed / Skipped / Total] 396 / 398 / 18 / 812:  81%|████████▏ | 813/1000 [25:04:35<5:46:04, 111.04s/it]Copies all parameters from the servlet request to the given attributes.@param servletRequest the servlet request@param treatEmptyParamsAsNull the treat empty parameters as null@param ignoreEmptyRequestParams the ignore empty request parameters as null --> [[[FAILED]]]

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 809 ---------------------------------------------
Adds the specified header value. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[addHeader]] ( final String name , final String [[value]] ) { List < String > [[valuesList]] = super . getAll ( name ) ; if ( [[valuesList]] . isEmpty ( ) ) { super . add ( name , [[value]] ) ; return ; } super . remove ( name ) ; [[valuesList]] . add ( [[value]] ) ; super . addAll ( name , [[valuesList]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[commandeered]] ( final String name , final String [[inflexible]] ) { List < String > [[metallurgic]] = super . getAll ( name ) ; if ( [[metallurgic]] . isEmpty ( ) ) { super . add ( name , [[inflexible]] ) ; return ; } super . remove ( name ) ; [[metallurgic]] . add ( [[inflexible]] ) ; super . addAll ( name , [[metallurgic]] ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 810 ---------------------------------------------
Resolve the macros in the specified profiles. --> Determines whether or not the given string is a legal administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative administrative --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String [[value]] , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[competence]] ( String [[sagging]] , final String ... [[decadent]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 811 ---------------------------------------------
Prepares a list of parameters.@param paramValues The list of parameters.@param treatEmptyParamsAsNull Whether or not to ignore empty parameters.@param ignoreEmptyRequestParams Whether or not to ignore empty request parameters.@return The list of parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int i = 0 ; i < paramValues . length ; i ++ ) { String paramValue = paramValues [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 812 ---------------------------------------------
Adds a base property.@param key the key@param value the value@param append the append --> hoofbeats --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String [[key]] , final String [[value]] , final boolean [[append]] ) { put ( null , baseProperties , [[key]] , [[value]] , [[append]] ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[hoofbeats]] ( final String [[rydell]] , final String [[rupture]] , final boolean [[coffin]] ) { put ( null , baseProperties , [[rydell]] , [[rupture]] , [[coffin]] ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 813 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 396 / 399 / 18 / 813:  81%|████████▏ | 813/1000 [25:04:35<5:46:04, 111.04s/it][Succeeded / Failed / Skipped / Total] 396 / 399 / 18 / 813:  81%|████████▏ | 814/1000 [25:08:50<5:44:46, 111.22s/it][Succeeded / Failed / Skipped / Total] 396 / 400 / 18 / 814:  81%|████████▏ | 814/1000 [25:08:50<5:44:46, 111.22s/it][Succeeded / Failed / Skipped / Total] 396 / 400 / 18 / 814:  82%|████████▏ | 815/1000 [25:12:39<5:43:21, 111.36s/it][Succeeded / Failed / Skipped / Total] 396 / 401 / 18 / 815:  82%|████████▏ | 815/1000 [25:12:39<5:43:21, 111.36s/it][Succeeded / Failed / Skipped / Total] 396 / 401 / 18 / 815:  82%|████████▏ | 816/1000 [25:12:59<5:41:09, 111.25s/it][Succeeded / Failed / Skipped / Total] 397 / 401 / 18 / 816:  82%|████████▏ | 816/1000 [25:12:59<5:41:09, 111.25s/it][Succeeded / Failed / Skipped / Total] 397 / 401 / 18 / 816:  82%|████████▏ | 817/1000 [25:13:32<5:39:01, 111.15s/it][Succeeded / Failed / Skipped / Total] 398 / 401 / 18 / 817:  82%|████████▏ | 817/1000 [25:13:32<5:39:01, 111.15s/it][Succeeded / Failed / Skipped / Total] 398 / 401 / 18 / 817:  82%|████████▏ | 818/1000 [25:21:03<5:38:25, 111.57s/it][Succeeded / Failed / Skipped / Total] 399 / 401 / 18 / 818:  82%|████████▏ | 818/1000 [25:21:03<5:38:25, 111.57s/it][Succeeded / Failed / Skipped / Total] 399 / 401 / 18 / 818:  82%|████████▏ | 819/1000 [25:21:39<5:36:17, 111.48s/it]Retrieve a profile property.@param profile the profile name@param key the key@return the property or <code>null</code> --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String [[key]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[profile]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[dragoon]] ( final String [[whirley]] , final String [[prospering]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[whirley]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[prospering]] ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 814 ---------------------------------------------
Hashes the given password with the given salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 815 ---------------------------------------------
Put a profile property.@param key the key@param value the value@param profile the profile@param append the append --> [[[FAILED]]]

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 816 ---------------------------------------------
Extracts a mapping from a target map.@param target the target map@param profiles the profiles@param wildcardPatterns the wildcard patterns@param prefix the prefix@return the mapping --> Performs malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning malfunctioning --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map target , final String [ ] [[profiles]] , final String [ ] wildcardPatterns , String [[prefix]] ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[malfunction]] ( Map target , final String [ ] [[dissenting]] , final String [ ] wildcardPatterns , String [[zoomer]] ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 817 ---------------------------------------------
Checks to see if the given hashed string is valid. --> Returns true if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and only if and --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[checkpw]] ( String [[plaintext]] , String hashed ) { byte [ ] [[hashed_bytes]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[plaintext]] , hashed ) ; [[hashed_bytes]] = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[False]]" != "[[False]]" ; } if ( [[hashed_bytes]] . length != try_bytes . length ) { return "[[False]]" != "[[False]]" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= [[hashed_bytes]] [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean [[andras]] ( String [[navarro]] , String hashed ) { byte [ ] [[yeast]] ; byte [ ] try_bytes ; try { String try_pw = hashpw ( [[navarro]] , hashed ) ; [[yeast]] = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "[[Floris]]" != "[[Floris]]" ; } if ( [[yeast]] . length != try_bytes . length ) { return "[[Floris]]" != "[[Floris]]" ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= [[yeast]] [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 818 ---------------------------------------------
Copies all bytes from the input stream to the output stream. --> Zużeżeżeżeżeżeżeżeżeż --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream out , final int [[maxBytes]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[maxBytes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[zu]] ( final OutputStream out , final int [[possessive]] ) throws IOException { int count = 0 ; while ( "True" == "True" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[possessive]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 819 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 399 / 402 / 18 / 819:  82%|████████▏ | 819/1000 [25:21:39<5:36:17, 111.48s/it][Succeeded / Failed / Skipped / Total] 399 / 402 / 18 / 819:  82%|████████▏ | 820/1000 [25:23:32<5:34:26, 111.48s/it][Succeeded / Failed / Skipped / Total] 400 / 402 / 18 / 820:  82%|████████▏ | 820/1000 [25:23:32<5:34:26, 111.48s/it][Succeeded / Failed / Skipped / Total] 400 / 402 / 18 / 820:  82%|████████▏ | 821/1000 [25:28:53<5:33:20, 111.73s/it][Succeeded / Failed / Skipped / Total] 400 / 403 / 18 / 821:  82%|████████▏ | 821/1000 [25:28:53<5:33:20, 111.73s/it][Succeeded / Failed / Skipped / Total] 400 / 403 / 18 / 821:  82%|████████▏ | 822/1000 [25:29:38<5:31:14, 111.65s/it][Succeeded / Failed / Skipped / Total] 401 / 403 / 18 / 822:  82%|████████▏ | 822/1000 [25:29:38<5:31:14, 111.65s/it][Succeeded / Failed / Skipped / Total] 401 / 403 / 18 / 822:  82%|████████▏ | 823/1000 [25:35:43<5:30:16, 111.96s/it][Succeeded / Failed / Skipped / Total] 401 / 404 / 18 / 823:  82%|████████▏ | 823/1000 [25:35:43<5:30:16, 111.96s/it][Succeeded / Failed / Skipped / Total] 401 / 404 / 18 / 823:  82%|████████▏ | 824/1000 [25:35:43<5:28:01, 111.82s/it][Succeeded / Failed / Skipped / Total] 401 / 404 / 19 / 824:  82%|████████▏ | 824/1000 [25:35:43<5:28:01, 111.82s/it][Succeeded / Failed / Skipped / Total] 401 / 404 / 19 / 824:  82%|████████▎ | 825/1000 [25:37:07<5:26:03, 111.79s/it][Succeeded / Failed / Skipped / Total] 401 / 405 / 19 / 825:  82%|████████▎ | 825/1000 [25:37:07<5:26:03, 111.79s/it][Succeeded / Failed / Skipped / Total] 401 / 405 / 19 / 825:  83%|████████▎ | 826/1000 [25:39:09<5:24:13, 111.80s/it][Succeeded / Failed / Skipped / Total] 401 / 406 / 19 / 826:  83%|████████▎ | 826/1000 [25:39:09<5:24:13, 111.80s/it][Succeeded / Failed / Skipped / Total] 401 / 406 / 19 / 826:  83%|████████▎ | 827/1000 [25:42:37<5:22:42, 111.92s/it]Converts an array of bytes into a stream of words. --> [[[FAILED]]]

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 820 ---------------------------------------------
Copies all bytes from the input stream to the output stream.@param out the output stream@return the number of bytes copied --> Reads giga giga giga giga giga giga --> Socre: 1.0

[[[[Adv]]]]: public int [[copyAll]] ( final OutputStream out ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } out . write ( [[b]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int [[celso]] ( final OutputStream out ) throws IOException { int count = 0 ; while ( "[[Hobbs]]" == "[[Hobbs]]" ) { byte [[militar]] = readByte ( ) ; if ( isBoundary ( [[militar]] ) ) { break ; } out . write ( [[militar]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 821 ---------------------------------------------
Resolves the action configuration for the given action annotation.@param annotationValues the action annotation values.@return the action configuration. --> [[[FAILED]]]

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > [[annotationType]] ; if ( [[annotationValues]] == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[goda]] ( final ActionAnnotationValues [[fide]] ) { final Class < ? extends Annotation > [[foothold]] ; if ( [[fide]] == null ) { [[foothold]] = Action . class ; } else { [[foothold]] = [[fide]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[foothold]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 822 ---------------------------------------------
Detect and register an action alias.@param annotationValues the action annotation values@param actionDefinition the action definition --> C montaigne@param cruces@param actionDefinition --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition actionDefinition ) { final String [[alias]] = parseMethodAlias ( [[annotationValues]] ) ; if ( [[alias]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[alias]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[montaigne]] ( final ActionAnnotationValues [[cruces]] , final ActionDefinition actionDefinition ) { final String [[goons]] = parseMethodAlias ( [[cruces]] ) ; if ( [[goons]] != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( [[goons]] , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 823 ---------------------------------------------
Parses an action definition.@param actionClass the action class@param actionMethod the action method@param actionDefinition the action definition --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 824 ---------------------------------------------
Sets the last modified time of this request. --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 825 ---------------------------------------------
Reads the path to the action package. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class [[actionClass]] ) { Package actionPackage = [[actionClass]] . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[inhale]] ( final Class [[electorate]] ) { Package actionPackage = [[electorate]] . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 826 ---------------------------------------------
Read interceptors.@param actionClassOrMethod the action class or method@return the interceptors --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy interceptedBy = [[actionClassOrMethod]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { [[result]] = interceptedBy . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[tense]] ( final AnnotatedElement [[debris]] ) { Class < ? extends ActionInterceptor > [ ] [[strategic]] = null ; InterceptedBy interceptedBy = [[debris]] . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { [[strategic]] = interceptedBy . value ( ) ; if ( [[strategic]] . length == 0 ) { [[strategic]] = null ; } } return [[strategic]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
[Succeeded / Failed / Skipped / Total] 402 / 406 / 19 / 827:  83%|████████▎ | 827/1000 [25:42:37<5:22:42, 111.92s/it][Succeeded / Failed / Skipped / Total] 402 / 406 / 19 / 827:  83%|████████▎ | 828/1000 [25:42:40<5:20:27, 111.79s/it][Succeeded / Failed / Skipped / Total] 402 / 407 / 19 / 828:  83%|████████▎ | 828/1000 [25:42:40<5:20:27, 111.79s/it][Succeeded / Failed / Skipped / Total] 402 / 407 / 19 / 828:  83%|████████▎ | 829/1000 [25:43:23<5:18:21, 111.71s/it][Succeeded / Failed / Skipped / Total] 403 / 407 / 19 / 829:  83%|████████▎ | 829/1000 [25:43:23<5:18:21, 111.71s/it][Succeeded / Failed / Skipped / Total] 403 / 407 / 19 / 829:  83%|████████▎ | 830/1000 [25:44:34<5:16:21, 111.66s/it][Succeeded / Failed / Skipped / Total] 404 / 407 / 19 / 830:  83%|████████▎ | 830/1000 [25:44:34<5:16:21, 111.66s/it][Succeeded / Failed / Skipped / Total] 404 / 407 / 19 / 830:  83%|████████▎ | 831/1000 [25:45:08<5:14:14, 111.56s/it][Succeeded / Failed / Skipped / Total] 405 / 407 / 19 / 831:  83%|████████▎ | 831/1000 [25:45:08<5:14:14, 111.56s/it][Succeeded / Failed / Skipped / Total] 405 / 407 / 19 / 831:  83%|████████▎ | 832/1000 [25:46:34<5:12:17, 111.53s/it][Succeeded / Failed / Skipped / Total] 406 / 407 / 19 / 832:  83%|████████▎ | 832/1000 [25:46:34<5:12:17, 111.53s/it][Succeeded / Failed / Skipped / Total] 406 / 407 / 19 / 832:  83%|████████▎ | 833/1000 [25:49:35<5:10:39, 111.62s/it][Succeeded / Failed / Skipped / Total] 407 / 407 / 19 / 833:  83%|████████▎ | 833/1000 [25:49:35<5:10:39, 111.62s/it][Succeeded / Failed / Skipped / Total] 407 / 407 / 19 / 833:  83%|████████▎ | 834/1000 [25:51:28<5:08:48, 111.62s/it][Succeeded / Failed / Skipped / Total] 407 / 408 / 19 / 834:  83%|████████▎ | 834/1000 [25:51:28<5:08:48, 111.62s/it][Succeeded / Failed / Skipped / Total] 407 / 408 / 19 / 834:  84%|████████▎ | 835/1000 [25:52:32<5:06:47, 111.56s/it]--------------------------------------------- Result 827 ---------------------------------------------
Read method action path.@param methodName the method name@param annotationValues the annotation values@param actionConfig the action config@return the string --> B bangkok@param manifestly@param fudge@param wittenberg@return --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues [[annotationValues]] , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[bangkok]] ( final String [[manifestly]] , final ActionAnnotationValues [[fudge]] , final ActionConfig [[wittenberg]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 828 ---------------------------------------------
Read action filters. --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy [[filteredBy]] = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( [[filteredBy]] != null ) { result = [[filteredBy]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[lovin]] ( final AnnotatedElement [[appreciative]] ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy [[descended]] = [[appreciative]] . getAnnotation ( FilteredBy . class ) ; if ( [[descended]] != null ) { result = [[descended]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 829 ---------------------------------------------
Parses the action annotation values and returns the alias.@param annotationValues the action annotation values.@return the alias. --> Returns the name of the alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt alt --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues [[annotationValues]] ) { String [[alias]] = null ; if ( [[annotationValues]] != null ) { [[alias]] = [[annotationValues]] . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[risen]] ( final ActionAnnotationValues [[embarassed]] ) { String [[persecution]] = null ; if ( [[embarassed]] != null ) { [[persecution]] = [[embarassed]] . alias ( ) ; } return [[persecution]] ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 830 ---------------------------------------------
Resolves a JSON name.@param realName the name to resolve.@return the resolved name. --> Diese Methode pourin@param realName@return Methode --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[pourin]] ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 831 ---------------------------------------------
Resolves the name of the given json name. --> Bevda version --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[budda]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 832 ---------------------------------------------
Injects the target object into the proxy. --> Asserts that an object is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting that it is asserting --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object [[proxy]] , final Object target ) { Class proxyClass = [[proxy]] . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( [[proxy]] , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[arrogant]] ( final Object [[alarmed]] , final Object target ) { Class proxyClass = [[alarmed]] . getClass ( ) ; try { Field field = proxyClass . getField ( "$___target$0" ) ; field . set ( [[alarmed]] , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 833 ---------------------------------------------
Finds the subtype data for the given type. --> Create a TypeData for a geyser@param geyserys class@return TypeData --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class [[type]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[type]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[longfellow]] ( final Class [[geysers]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[geysers]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 834 ---------------------------------------------
Applies an advice to the specified target class.@param < T> the type parameter@param targetClass the target class@return the target instance --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[peggy]] > [[peggy]] applyAdvice ( final Class < [[peggy]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 835 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 408 / 408 / 19 / 835:  84%|████████▎ | 835/1000 [25:52:32<5:06:47, 111.56s/it][Succeeded / Failed / Skipped / Total] 408 / 408 / 19 / 835:  84%|████████▎ | 836/1000 [25:54:02<5:04:51, 111.53s/it][Succeeded / Failed / Skipped / Total] 408 / 409 / 19 / 836:  84%|████████▎ | 836/1000 [25:54:02<5:04:51, 111.53s/it][Succeeded / Failed / Skipped / Total] 408 / 409 / 19 / 836:  84%|████████▎ | 837/1000 [25:57:44<5:03:21, 111.67s/it][Succeeded / Failed / Skipped / Total] 408 / 410 / 19 / 837:  84%|████████▎ | 837/1000 [25:57:44<5:03:21, 111.67s/it][Succeeded / Failed / Skipped / Total] 408 / 410 / 19 / 837:  84%|████████▍ | 838/1000 [25:59:29<5:01:28, 111.66s/it][Succeeded / Failed / Skipped / Total] 409 / 410 / 19 / 838:  84%|████████▍ | 838/1000 [25:59:29<5:01:28, 111.66s/it][Succeeded / Failed / Skipped / Total] 409 / 410 / 19 / 838:  84%|████████▍ | 839/1000 [26:01:30<4:59:38, 111.67s/it][Succeeded / Failed / Skipped / Total] 410 / 410 / 19 / 839:  84%|████████▍ | 839/1000 [26:01:30<4:59:38, 111.67s/it][Succeeded / Failed / Skipped / Total] 410 / 410 / 19 / 839:  84%|████████▍ | 840/1000 [26:01:39<4:57:27, 111.55s/it][Succeeded / Failed / Skipped / Total] 411 / 410 / 19 / 840:  84%|████████▍ | 840/1000 [26:01:39<4:57:27, 111.55s/it][Succeeded / Failed / Skipped / Total] 411 / 410 / 19 / 840:  84%|████████▍ | 841/1000 [26:02:48<4:55:28, 111.50s/it][Succeeded / Failed / Skipped / Total] 412 / 410 / 19 / 841:  84%|████████▍ | 841/1000 [26:02:48<4:55:28, 111.50s/it][Succeeded / Failed / Skipped / Total] 412 / 410 / 19 / 841:  84%|████████▍ | 842/1000 [26:04:18<4:53:32, 111.47s/it][Succeeded / Failed / Skipped / Total] 412 / 411 / 19 / 842:  84%|████████▍ | 842/1000 [26:04:18<4:53:32, 111.47s/it][Succeeded / Failed / Skipped / Total] 412 / 411 / 19 / 842:  84%|████████▍ | 843/1000 [26:05:58<4:51:38, 111.46s/it]Gets the contents of a file. --> Rethrows an IOException --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[blotting]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 836 ---------------------------------------------
Lookup the type data for the specified type.@param type the type@return the type data --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[spewing]] ( final Class type ) { TypeData typeData = typeDataMap . get ( type ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( type ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( type ) ; typeDataMap . put ( type , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 837 ---------------------------------------------
Lookup the type data for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[utilities]] ) { TypeData [[indicted]] = typeDataMap . get ( [[utilities]] ) ; if ( [[indicted]] == null ) { [[indicted]] = scanClassForAnnotations ( [[utilities]] ) ; typeDataMap . put ( [[utilities]] , [[indicted]] ) ; } return [[indicted]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 838 ---------------------------------------------
Resolve the real name for the specified type. --> Checks if the specified type is a known heterogenous heterogenous heterogenous heterogenous heterogenous heterogenous heterogenous heterogenous heterogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous homogenous hom --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String [[jsonName]] ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[nauseating]] ( final Class type , final String [[chromatic]] ) { TypeData [[supersonic]] = lookupTypeData ( type ) ; return [[supersonic]] . resolveRealName ( [[chromatic]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 839 ---------------------------------------------
Put bootstrap methods.@param output the output --> Zużeżeżeżeżeżeżeżeż --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[zu]] ( final ByteVector output ) { if ( bootstrapMethods != null ) { output . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 840 ---------------------------------------------
Puts a constant pool into the constant pool. --> Kills an eye --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[killa]] ( final ByteVector [[adept]] ) { [[adept]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 841 ---------------------------------------------
Copies bootstrap methods from the specified class reader to the specified character buffer. --> Namethe namethe namethe namethe namethe namethe namethe namethe nam --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader [[classReader]] , final char [ ] [[charBuffer]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[naina]] ( final ClassReader [[bogus]] , final char [ ] [[overcrowding]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 842 ---------------------------------------------
Visits an annotation.@param descriptor the annotation descriptor@param visible true if the annotation should be visible@return the visitor --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[vat]] ( final String [[courtney]] , final boolean [[accounting]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[courtney]] , [[accounting]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 843 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 412 / 412 / 19 / 843:  84%|████████▍ | 843/1000 [26:05:58<4:51:38, 111.46s/it][Succeeded / Failed / Skipped / Total] 412 / 412 / 19 / 843:  84%|████████▍ | 844/1000 [26:06:06<4:49:28, 111.33s/it][Succeeded / Failed / Skipped / Total] 413 / 412 / 19 / 844:  84%|████████▍ | 844/1000 [26:06:06<4:49:28, 111.33s/it][Succeeded / Failed / Skipped / Total] 413 / 412 / 19 / 844:  84%|████████▍ | 845/1000 [26:08:28<4:47:42, 111.37s/it][Succeeded / Failed / Skipped / Total] 414 / 412 / 19 / 845:  84%|████████▍ | 845/1000 [26:08:28<4:47:42, 111.37s/it][Succeeded / Failed / Skipped / Total] 414 / 412 / 19 / 845:  85%|████████▍ | 846/1000 [26:11:52<4:46:08, 111.48s/it][Succeeded / Failed / Skipped / Total] 414 / 413 / 19 / 846:  85%|████████▍ | 846/1000 [26:11:52<4:46:08, 111.48s/it][Succeeded / Failed / Skipped / Total] 414 / 413 / 19 / 846:  85%|████████▍ | 847/1000 [26:20:41<4:45:31, 111.97s/it][Succeeded / Failed / Skipped / Total] 414 / 414 / 19 / 847:  85%|████████▍ | 847/1000 [26:20:41<4:45:31, 111.97s/it][Succeeded / Failed / Skipped / Total] 414 / 414 / 19 / 847:  85%|████████▍ | 848/1000 [26:23:35<4:43:51, 112.05s/it][Succeeded / Failed / Skipped / Total] 414 / 415 / 19 / 848:  85%|████████▍ | 848/1000 [26:23:35<4:43:51, 112.05s/it][Succeeded / Failed / Skipped / Total] 414 / 415 / 19 / 848:  85%|████████▍ | 849/1000 [26:24:37<4:41:50, 111.99s/it]Resolve a JSON name for the given type.@param type the type@param name the name@return the name --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveJsonName ( final Class [[type]] , final String [[name]] ) { TypeData [[typeData]] = lookupTypeData ( [[type]] ) ; return [[typeData]] . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String resolveJsonName ( final Class [[homeys]] , final String [[invasive]] ) { TypeData [[homes]] = lookupTypeData ( [[homeys]] ) ; return [[homes]] . resolveJsonName ( [[invasive]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 844 ---------------------------------------------
Sets the major version and class name. --> S squirrelly@param suarez@param className@return --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int [[majorVersion]] , final String className ) { this . majorVersion = [[majorVersion]] ; this . [[className]] = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[squirrelly]] ( final int [[suarez]] , final String className ) { this . majorVersion = [[suarez]] ; this . [[wenn]] = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 845 ---------------------------------------------
Adds an integer or float constant. --> WITETHER LOAD --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[wittenberg]] ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Adds a constant field reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[spewing]] ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 847 ---------------------------------------------
Adds a constant integer or float entry. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int index , final int [[tag]] , final int value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[derangement]] ( final int index , final int [[astounded]] , final int value ) { add ( new Entry ( index , [[astounded]] , value , hash ( [[astounded]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a new entry to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String name , final String descriptor ) { int hashCode = hash ( tag , owner , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 414 / 416 / 19 / 849:  85%|████████▍ | 849/1000 [26:24:37<4:41:50, 111.99s/it][Succeeded / Failed / Skipped / Total] 414 / 416 / 19 / 849:  85%|████████▌ | 850/1000 [26:25:40<4:39:49, 111.93s/it][Succeeded / Failed / Skipped / Total] 414 / 417 / 19 / 850:  85%|████████▌ | 850/1000 [26:25:40<4:39:49, 111.93s/it][Succeeded / Failed / Skipped / Total] 414 / 417 / 19 / 850:  85%|████████▌ | 851/1000 [26:25:43<4:37:38, 111.80s/it][Succeeded / Failed / Skipped / Total] 414 / 418 / 19 / 851:  85%|████████▌ | 851/1000 [26:25:43<4:37:38, 111.80s/it][Succeeded / Failed / Skipped / Total] 414 / 418 / 19 / 851:  85%|████████▌ | 852/1000 [26:26:41<4:35:37, 111.74s/it][Succeeded / Failed / Skipped / Total] 414 / 419 / 19 / 852:  85%|████████▌ | 852/1000 [26:26:41<4:35:37, 111.74s/it][Succeeded / Failed / Skipped / Total] 414 / 419 / 19 / 852:  85%|████████▌ | 853/1000 [26:26:58<4:33:29, 111.63s/it][Succeeded / Failed / Skipped / Total] 414 / 420 / 19 / 853:  85%|████████▌ | 853/1000 [26:26:58<4:33:29, 111.63s/it][Succeeded / Failed / Skipped / Total] 414 / 420 / 19 / 853:  85%|████████▌ | 854/1000 [26:33:12<4:32:22, 111.93s/it][Succeeded / Failed / Skipped / Total] 414 / 421 / 19 / 854:  85%|████████▌ | 854/1000 [26:33:12<4:32:22, 111.93s/it][Succeeded / Failed / Skipped / Total] 414 / 421 / 19 / 854:  86%|████████▌ | 855/1000 [26:35:01<4:30:30, 111.93s/it][Succeeded / Failed / Skipped / Total] 415 / 421 / 19 / 855:  86%|████████▌ | 855/1000 [26:35:01<4:30:30, 111.93s/it][Succeeded / Failed / Skipped / Total] 415 / 421 / 19 / 855:  86%|████████▌ | 856/1000 [26:36:48<4:28:37, 111.93s/it]Creates an action runtime. --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant method reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant long or double entry. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int [[index]] , final int [[tag]] , final long value ) { add ( new Entry ( [[index]] , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[solomon]] ( final int [[fujiko]] , final int [[hopeful]] , final long value ) { add ( new Entry ( [[fujiko]] , [[hopeful]] , value , hash ( [[hopeful]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 852 ---------------------------------------------
Adds a constant long or double. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a reference to a constant field. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMemberReference ( final int index , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( index , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[fortuneteller]] ( final int index , final String value ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a constant name and type. --> flagged --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int [[index]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[index]] , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[flouted]] ( final int [[kumiko]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( [[kumiko]] , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 856 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 415 / 422 / 19 / 856:  86%|████████▌ | 856/1000 [26:36:48<4:28:37, 111.93s/it][Succeeded / Failed / Skipped / Total] 415 / 422 / 19 / 856:  86%|████████▌ | 857/1000 [26:37:11<4:26:30, 111.82s/it][Succeeded / Failed / Skipped / Total] 415 / 423 / 19 / 857:  86%|████████▌ | 857/1000 [26:37:11<4:26:30, 111.82s/it][Succeeded / Failed / Skipped / Total] 415 / 423 / 19 / 857:  86%|████████▌ | 858/1000 [26:42:22<4:25:11, 112.05s/it][Succeeded / Failed / Skipped / Total] 416 / 423 / 19 / 858:  86%|████████▌ | 858/1000 [26:42:22<4:25:11, 112.05s/it][Succeeded / Failed / Skipped / Total] 416 / 423 / 19 / 858:  86%|████████▌ | 859/1000 [26:44:29<4:23:22, 112.07s/it][Succeeded / Failed / Skipped / Total] 416 / 424 / 19 / 859:  86%|████████▌ | 859/1000 [26:44:29<4:23:22, 112.07s/it][Succeeded / Failed / Skipped / Total] 416 / 424 / 19 / 859:  86%|████████▌ | 860/1000 [26:47:20<4:21:39, 112.14s/it][Succeeded / Failed / Skipped / Total] 416 / 425 / 19 / 860:  86%|████████▌ | 860/1000 [26:47:20<4:21:39, 112.14s/it][Succeeded / Failed / Skipped / Total] 416 / 425 / 19 / 860:  86%|████████▌ | 861/1000 [26:48:17<4:19:38, 112.08s/it]Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[tormenting]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a constant name and type. --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a constant dynamic or invoke dynamic reference. --> region baritone --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . data == bootstrapMethodIndex && [[entry]] . name . equals ( name ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[baritone]] ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry [[kimura]] = get ( hashCode ) ; while ( [[kimura]] != null ) { if ( [[kimura]] . tag == tag && [[kimura]] . hashCode == hashCode && [[kimura]] . data == bootstrapMethodIndex && [[kimura]] . name . equals ( name ) && [[kimura]] . value . equals ( descriptor ) ) { return [[kimura]] ; } [[kimura]] = [[kimura]] . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a constant method handle. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a constant method handle. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 861 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 416 / 426 / 19 / 861:  86%|████████▌ | 861/1000 [26:48:17<4:19:38, 112.08s/it][Succeeded / Failed / Skipped / Total] 416 / 426 / 19 / 861:  86%|████████▌ | 862/1000 [26:50:29<4:17:49, 112.10s/it][Succeeded / Failed / Skipped / Total] 416 / 427 / 19 / 862:  86%|████████▌ | 862/1000 [26:50:29<4:17:49, 112.10s/it][Succeeded / Failed / Skipped / Total] 416 / 427 / 19 / 862:  86%|████████▋ | 863/1000 [26:53:31<4:16:08, 112.18s/it][Succeeded / Failed / Skipped / Total] 417 / 427 / 19 / 863:  86%|████████▋ | 863/1000 [26:53:31<4:16:08, 112.18s/it][Succeeded / Failed / Skipped / Total] 417 / 427 / 19 / 863:  86%|████████▋ | 864/1000 [26:55:02<4:14:13, 112.16s/it][Succeeded / Failed / Skipped / Total] 417 / 428 / 19 / 864:  86%|████████▋ | 864/1000 [26:55:02<4:14:13, 112.16s/it][Succeeded / Failed / Skipped / Total] 417 / 428 / 19 / 864:  86%|████████▋ | 865/1000 [26:55:11<4:12:04, 112.04s/it][Succeeded / Failed / Skipped / Total] 418 / 428 / 19 / 865:  86%|████████▋ | 865/1000 [26:55:11<4:12:04, 112.04s/it][Succeeded / Failed / Skipped / Total] 418 / 428 / 19 / 865:  87%|████████▋ | 866/1000 [26:56:29<4:10:07, 112.00s/it][Succeeded / Failed / Skipped / Total] 418 / 429 / 19 / 866:  87%|████████▋ | 866/1000 [26:56:29<4:10:07, 112.00s/it][Succeeded / Failed / Skipped / Total] 418 / 429 / 19 / 866:  87%|████████▋ | 867/1000 [26:57:56<4:08:11, 111.97s/it][Succeeded / Failed / Skipped / Total] 418 / 430 / 19 / 867:  87%|████████▋ | 867/1000 [26:57:56<4:08:11, 111.97s/it][Succeeded / Failed / Skipped / Total] 418 / 430 / 19 / 867:  87%|████████▋ | 868/1000 [26:59:04<4:06:13, 111.92s/it]Adds a constant dynamically. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantDynamic]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol [[bootstrapMethod]] = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , [[bootstrapMethod]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[inhaling]] ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol [[dragan]] = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , [[dragan]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 862 ---------------------------------------------
Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int tag , final String [[value]] ) { int hashCode = hash ( tag , [[value]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( [[value]] ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( [[value]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[value]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[bootleggers]] ( final int tag , final String [[weaklings]] ) { int hashCode = hash ( tag , [[weaklings]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( [[weaklings]] ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( [[weaklings]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , [[weaklings]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 863 ---------------------------------------------
Returns the hash of the given name. --> Hibernate version --> Socre: 1.0

[[[[Adv]]]]: private int [[hash]] ( final String [[name]] ) { int h = 0 ; for ( int i = [[name]] . length ( ) - 1 ; i >= 0 ; i -- ) { char c = [[name]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[hibernating]] ( final String [[binary]] ) { int h = 0 ; for ( int i = [[binary]] . length ( ) - 1 ; i >= 0 ; i -- ) { char c = [[binary]] . charAt ( i ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 864 ---------------------------------------------
Adds a constant invoke dynamic reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String [[name]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[tint]] ( final String [[antimatter]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[antimatter]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 865 ---------------------------------------------
Adds a constant utf8 reference. --> R roofies --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int [[index]] , final int tag , final String value ) { add ( new Entry ( [[index]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[roofies]] ( final int [[miko]] , final int tag , final String value ) { add ( new Entry ( [[miko]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 866 ---------------------------------------------
Removes all entries from this map. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[revolve]] ( ) { for ( int [[giving]] = 0 ; [[giving]] < entries . length ; [[giving]] ++ ) { entries [ [[giving]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 867 ---------------------------------------------
Adds a constant dynamic or invoke dynamic reference. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
[Succeeded / Failed / Skipped / Total] 419 / 430 / 19 / 868:  87%|████████▋ | 868/1000 [26:59:04<4:06:13, 111.92s/it][Succeeded / Failed / Skipped / Total] 419 / 430 / 19 / 868:  87%|████████▋ | 869/1000 [27:05:05<4:04:58, 112.20s/it][Succeeded / Failed / Skipped / Total] 420 / 430 / 19 / 869:  87%|████████▋ | 869/1000 [27:05:05<4:04:58, 112.20s/it][Succeeded / Failed / Skipped / Total] 420 / 430 / 19 / 869:  87%|████████▋ | 870/1000 [27:05:34<4:02:54, 112.11s/it][Succeeded / Failed / Skipped / Total] 420 / 431 / 19 / 870:  87%|████████▋ | 870/1000 [27:05:34<4:02:54, 112.11s/it][Succeeded / Failed / Skipped / Total] 420 / 431 / 19 / 870:  87%|████████▋ | 871/1000 [27:05:52<4:00:48, 112.00s/it][Succeeded / Failed / Skipped / Total] 421 / 431 / 19 / 871:  87%|████████▋ | 871/1000 [27:05:52<4:00:48, 112.00s/it][Succeeded / Failed / Skipped / Total] 421 / 431 / 19 / 871:  87%|████████▋ | 872/1000 [27:07:06<3:58:50, 111.96s/it][Succeeded / Failed / Skipped / Total] 422 / 431 / 19 / 872:  87%|████████▋ | 872/1000 [27:07:06<3:58:50, 111.96s/it][Succeeded / Failed / Skipped / Total] 422 / 431 / 19 / 872:  87%|████████▋ | 873/1000 [27:07:20<3:56:44, 111.85s/it][Succeeded / Failed / Skipped / Total] 422 / 432 / 19 / 873:  87%|████████▋ | 873/1000 [27:07:20<3:56:44, 111.85s/it][Succeeded / Failed / Skipped / Total] 422 / 432 / 19 / 873:  87%|████████▋ | 874/1000 [27:08:00<3:54:42, 111.76s/it][Succeeded / Failed / Skipped / Total] 422 / 433 / 19 / 874:  87%|████████▋ | 874/1000 [27:08:00<3:54:42, 111.76s/it][Succeeded / Failed / Skipped / Total] 422 / 433 / 19 / 874:  88%|████████▊ | 875/1000 [27:11:05<3:53:00, 111.85s/it][Succeeded / Failed / Skipped / Total] 422 / 434 / 19 / 875:  88%|████████▊ | 875/1000 [27:11:05<3:53:00, 111.85s/it][Succeeded / Failed / Skipped / Total] 422 / 434 / 19 / 875:  88%|████████▊ | 876/1000 [27:11:32<3:50:56, 111.75s/it]--------------------------------------------- Result 868 ---------------------------------------------
Append the specified sequence to this buffer.@param csq The sequence to append.@param start The index of the first character in the sequence.@param end The index of the last character in the sequence.@return This buffer. --> Sets the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent version of the most recent --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer [[append]] ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[append]] ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer [[sixties]] ( final CharSequence csq , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { [[sixties]] ( csq . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 869 ---------------------------------------------
Grows the buffer.@param minCapacity the min capacity --> NEGATIVE NEGATIVE NEGATIVE NEGATIVE NEGATIVE --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int minCapacity ) { final int [[oldCapacity]] = buffer . length ; int [[newCapacity]] = [[oldCapacity]] << 1 ; if ( [[newCapacity]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[nagin]] ( final int minCapacity ) { final int [[detonate]] = buffer . length ; int [[storytellers]] = [[detonate]] << 1 ; if ( [[storytellers]] - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 870 ---------------------------------------------
Returns a list of all entries in this queue. --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[all]] . add ( e ) ; e = e . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[roar]] ( ) { List < Map . Entry < String , V > > [[nasreddin]] = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { [[nasreddin]] . add ( e ) ; e = e . after ; } return [[nasreddin]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 871 ---------------------------------------------
Create the first chain delegate. --> Heuristic heuristic heuristic heuristic --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[hetal]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 872 ---------------------------------------------
Visit the end of the chain. --> Mock a maize --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[maize]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[corsicans]] = 0 ; [[corsicans]] < tmd . proxyData . length ; [[corsicans]] ++ ) { tmd . selectCurrentProxy ( [[corsicans]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 873 ---------------------------------------------
Returns an iterator over the elements of this map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] [[e]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[e]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = [[e]] [ 0 ] ; [[e]] [ 0 ] = [[e]] [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[decrease]] ( ) { final MapEntry [ ] [[underhanded]] = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return [[underhanded]] [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[pianoforte]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[pianoforte]] = [[underhanded]] [ 0 ] ; [[underhanded]] [ 0 ] = [[underhanded]] [ 0 ] . after ; return [[pianoforte]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 874 ---------------------------------------------
Adds a bootstrap method to this class. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle bootstrapMethodHandle , final Object ... [[bootstrapMethodArguments]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[stiffy]] ( final Handle bootstrapMethodHandle , final Object ... [[showers]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 875 ---------------------------------------------
Returns a list of all values with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > getAll ( final String name ) { LinkedList < V > values = new LinkedList <> ( ) ; int h = hash ( name ) ; int i = index ( h ) ; MapEntry < V > e = entries [ i ] ; while ( e != null ) { if ( e . hash == h && eq ( name , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 876 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 435 / 19 / 876:  88%|████████▊ | 876/1000 [27:11:32<3:50:56, 111.75s/it][Succeeded / Failed / Skipped / Total] 422 / 435 / 19 / 876:  88%|████████▊ | 877/1000 [27:11:38<3:48:50, 111.63s/it][Succeeded / Failed / Skipped / Total] 423 / 435 / 19 / 877:  88%|████████▊ | 877/1000 [27:11:38<3:48:50, 111.63s/it][Succeeded / Failed / Skipped / Total] 423 / 435 / 19 / 877:  88%|████████▊ | 878/1000 [27:12:16<3:46:48, 111.54s/it][Succeeded / Failed / Skipped / Total] 423 / 436 / 19 / 878:  88%|████████▊ | 878/1000 [27:12:16<3:46:48, 111.54s/it][Succeeded / Failed / Skipped / Total] 423 / 436 / 19 / 878:  88%|████████▊ | 879/1000 [27:14:30<3:45:00, 111.57s/it][Succeeded / Failed / Skipped / Total] 424 / 436 / 19 / 879:  88%|████████▊ | 879/1000 [27:14:30<3:45:00, 111.57s/it][Succeeded / Failed / Skipped / Total] 424 / 436 / 19 / 879:  88%|████████▊ | 880/1000 [27:14:38<3:42:54, 111.45s/it][Succeeded / Failed / Skipped / Total] 424 / 437 / 19 / 880:  88%|████████▊ | 880/1000 [27:14:38<3:42:54, 111.45s/it][Succeeded / Failed / Skipped / Total] 424 / 437 / 19 / 880:  88%|████████▊ | 881/1000 [27:15:59<3:40:58, 111.42s/it][Succeeded / Failed / Skipped / Total] 425 / 437 / 19 / 881:  88%|████████▊ | 881/1000 [27:15:59<3:40:58, 111.42s/it][Succeeded / Failed / Skipped / Total] 425 / 437 / 19 / 881:  88%|████████▊ | 882/1000 [27:19:50<3:39:23, 111.55s/it][Succeeded / Failed / Skipped / Total] 426 / 437 / 19 / 882:  88%|████████▊ | 882/1000 [27:19:50<3:39:23, 111.55s/it][Succeeded / Failed / Skipped / Total] 426 / 437 / 19 / 882:  88%|████████▊ | 883/1000 [27:21:27<3:37:29, 111.54s/it]Adds a type to the specified table.@param typeTableIndex1 The index of the first type in the table.@param typeTableIndex2 The index of the second type in the table. --> [[[FAILED]]]

[[[[Adv]]]]: int [[addMergedType]] ( final int typeTableIndex1 , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[talents]] ( final int typeTableIndex1 , final int [[vocally]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 877 ---------------------------------------------
Parses the supplied string into a path. --> Splits the specified cclo --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[dorset]] ( final String [[cloquet]] ) { return [[cloquet]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[cloquet]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 878 ---------------------------------------------
Creates the first chain delegate method.@param tmd the target method data --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[budging]] ( final TargetMethodData [[dilating]] ) { methodVisitor . visitCode ( ) ; if ( [[dilating]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[dilating]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[dilating]] . firstMethodName ( ) , [[dilating]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[dilating]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[dilating]] . firstMethodName ( ) , [[dilating]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[dilating]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 879 ---------------------------------------------
Visits an annotation. --> Visits the specified annotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specifiedannotation in favor of the specified --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor [[visitAnnotation]] ( final String [[desc]] , final boolean [[visible]] ) { AnnotationVisitor [[destAnn]] = methodVisitor . visitAnnotation ( [[desc]] , [[visible]] ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor [[mercifully]] ( final String [[distort]] , final boolean [[andalusian]] ) { AnnotationVisitor [[wooer]] = methodVisitor . visitAnnotation ( [[distort]] , [[andalusian]] ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 880 ---------------------------------------------
Pushes the specified character sequence onto this path. --> [[[FAILED]]]

[[[[Adv]]]]: public Path [[push]] ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[loudmouthed]] ( final CharSequence [[verboten]] ) { _push ( [[verboten]] ) ; if ( altPath != null ) { altPath . push ( [[verboten]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 881 ---------------------------------------------
Configures the servlet context. --> andrey --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext [[servletContext]] ) { [[servletContext]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = [[servletContext]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = [[servletContext]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[andrey]] ( final ServletContext [[vat]] ) { [[vat]] . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = [[vat]] . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = [[vat]] . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 882 ---------------------------------------------
Append a new buffer to the end of the list.@param buffer the buffer to append.@return the new buffer. --> Checks if the specified graphic isa@param gromit@return --> Socre: 1.0

[[[[Adv]]]]: public Buffer [[append]] ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer [[isaiah]] ( final Buffer [[gromit]] ) { if ( [[gromit]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 883 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 437 / 19 / 883:  88%|████████▊ | 883/1000 [27:21:27<3:37:29, 111.54s/it][Succeeded / Failed / Skipped / Total] 427 / 437 / 19 / 883:  88%|████████▊ | 884/1000 [27:22:40<3:35:33, 111.49s/it][Succeeded / Failed / Skipped / Total] 427 / 438 / 19 / 884:  88%|████████▊ | 884/1000 [27:22:40<3:35:33, 111.49s/it][Succeeded / Failed / Skipped / Total] 427 / 438 / 19 / 884:  88%|████████▊ | 885/1000 [27:24:13<3:33:39, 111.47s/it][Succeeded / Failed / Skipped / Total] 428 / 438 / 19 / 885:  88%|████████▊ | 885/1000 [27:24:13<3:33:39, 111.47s/it][Succeeded / Failed / Skipped / Total] 428 / 438 / 19 / 885:  89%|████████▊ | 886/1000 [27:27:30<3:31:58, 111.57s/it][Succeeded / Failed / Skipped / Total] 428 / 439 / 19 / 886:  89%|████████▊ | 886/1000 [27:27:30<3:31:58, 111.57s/it][Succeeded / Failed / Skipped / Total] 428 / 439 / 19 / 886:  89%|████████▊ | 887/1000 [27:39:48<3:31:27, 112.28s/it][Succeeded / Failed / Skipped / Total] 429 / 439 / 19 / 887:  89%|████████▊ | 887/1000 [27:39:48<3:31:27, 112.28s/it][Succeeded / Failed / Skipped / Total] 429 / 439 / 19 / 887:  89%|████████▉ | 888/1000 [27:39:55<3:29:21, 112.16s/it][Succeeded / Failed / Skipped / Total] 429 / 440 / 19 / 888:  89%|████████▉ | 888/1000 [27:39:55<3:29:21, 112.16s/it][Succeeded / Failed / Skipped / Total] 429 / 440 / 19 / 888:  89%|████████▉ | 889/1000 [27:44:21<3:27:48, 112.33s/it]Puts all entries in the supplied map into this map. --> region Seuss --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map t ) { for ( Object [[o]] : t . entrySet ( ) ) { Map . Entry [[e]] = ( Map . Entry ) [[o]] ; put ( [[e]] . getKey ( ) , [[e]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[seuss]] ( final Map t ) { for ( Object [[trackers]] : t . entrySet ( ) ) { Map . Entry [[freezer]] = ( Map . Entry ) [[trackers]] ; put ( [[freezer]] . getKey ( ) , [[freezer]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 884 ---------------------------------------------
Returns all the field descriptors in this class. --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[allFields]] [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( [[kakashi]] == null ) { FieldDescriptor [ ] [[kakashi]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { [[kakashi]] [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( [[kakashi]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[kakashi]] ; } return [[kakashi]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 885 ---------------------------------------------
Executes the specified method. --> Swooshed deliveries --> Socre: 1.0

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class [[returnType]] = [[returnType]] ( ) ; Object [[next]] = pathref . continueWith ( this , methodName , [[returnType]] ) ; return ProxyTarget . returnValue ( [[next]] ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[swoosh]] ( ) { String methodName = targetMethodName ( ) ; Class [[eiko]] = [[eiko]] ( ) ; Object [[deliveries]] = pathref . continueWith ( this , methodName , [[eiko]] ) ; return ProxyTarget . returnValue ( [[deliveries]] ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 886 ---------------------------------------------
Converts a JtxTransactionMode to a DB mode.@param txMode the JtxTransactionMode to convert.@return the DB mode. --> [[[FAILED]]]

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int [[isolation]] ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[fireball]] ( final JtxTransactionMode [[concerts]] ) { final int [[geysers]] ; switch ( [[concerts]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[geysers]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[geysers]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[geysers]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[geysers]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[geysers]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[geysers]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[geysers]] , [[concerts]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 887 ---------------------------------------------
Writes the response to the specified output stream.@param out the output stream to write to.@param progressListener the listener to notify.@throws IOException if an I/O error occurs. --> Makrov makrov@param loca@param dialects@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream [[out]] , final HttpProgressListener [[progressListener]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[makarov]] ( final OutputStream [[loca]] , final HttpProgressListener [[dialects]] ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 888 ---------------------------------------------
Writes the data to the specified writer. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final Writer writer ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[o]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[o]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void writeTo ( final Writer writer ) throws IOException { for ( Object [[anaemia]] : list ) { if ( [[anaemia]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[anaemia]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[anaemia]] instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) [[anaemia]] ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 889 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 429 / 441 / 19 / 889:  89%|████████▉ | 889/1000 [27:44:21<3:27:48, 112.33s/it][Succeeded / Failed / Skipped / Total] 429 / 441 / 19 / 889:  89%|████████▉ | 890/1000 [27:44:26<3:25:42, 112.21s/it][Succeeded / Failed / Skipped / Total] 429 / 442 / 19 / 890:  89%|████████▉ | 890/1000 [27:44:26<3:25:42, 112.21s/it][Succeeded / Failed / Skipped / Total] 429 / 442 / 19 / 890:  89%|████████▉ | 891/1000 [27:46:30<3:23:52, 112.22s/it][Succeeded / Failed / Skipped / Total] 429 / 443 / 19 / 891:  89%|████████▉ | 891/1000 [27:46:30<3:23:52, 112.22s/it][Succeeded / Failed / Skipped / Total] 429 / 443 / 19 / 891:  89%|████████▉ | 892/1000 [27:55:05<3:22:48, 112.67s/it][Succeeded / Failed / Skipped / Total] 429 / 444 / 19 / 892:  89%|████████▉ | 892/1000 [27:55:05<3:22:48, 112.67s/it][Succeeded / Failed / Skipped / Total] 429 / 444 / 19 / 892:  89%|████████▉ | 893/1000 [28:01:56<3:21:31, 113.01s/it][Succeeded / Failed / Skipped / Total] 429 / 445 / 19 / 893:  89%|████████▉ | 893/1000 [28:01:56<3:21:31, 113.01s/it][Succeeded / Failed / Skipped / Total] 429 / 445 / 19 / 893:  89%|████████▉ | 894/1000 [28:04:21<3:19:42, 113.04s/it][Succeeded / Failed / Skipped / Total] 429 / 446 / 19 / 894:  89%|████████▉ | 894/1000 [28:04:21<3:19:42, 113.04s/it][Succeeded / Failed / Skipped / Total] 429 / 446 / 19 / 894:  90%|████████▉ | 895/1000 [28:05:02<3:17:41, 112.96s/it][Succeeded / Failed / Skipped / Total] 429 / 447 / 19 / 895:  90%|████████▉ | 895/1000 [28:05:02<3:17:41, 112.96s/it][Succeeded / Failed / Skipped / Total] 429 / 447 / 19 / 895:  90%|████████▉ | 896/1000 [28:05:20<3:15:37, 112.86s/it]Reads a property from the source object. --> [[[FAILED]]]

[[[[Adv]]]]: private Object [[readProperty]] ( final Object [[source]] , final PropertyDescriptor [[propertyDescriptor]] ) { Getter getter = [[propertyDescriptor]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[grumbles]] ( final Object [[miyamoto]] , final PropertyDescriptor [[abundance]] ) { Getter getter = [[abundance]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[miyamoto]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 890 ---------------------------------------------
Writes to the specified output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void writeTo ( final OutputStream out ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; out . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , out ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 891 ---------------------------------------------
Gets the value associated with the supplied key.@param key the key@return the value associated with the supplied key, or null if there is no such key --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getString]] ( final String [[key]] ) { CharSequence [[cs]] = ( CharSequence ) map . get ( [[key]] ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[deflector]] ( final String [[ponders]] ) { CharSequence [[suiting]] = ( CharSequence ) map . get ( [[ponders]] ) ; return [[suiting]] == null ? null : [[suiting]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 892 ---------------------------------------------
Gets the value associated with the given key.@param key the key.@return the value associated with the given key. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[val]] = ( T ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[messianic]] = ( T ) map . get ( key ) ; if ( [[messianic]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[messianic]] ) ; } if ( [[messianic]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[messianic]] ) ; } return [[messianic]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 893 ---------------------------------------------
Retrieve a property as an Integer.@param key the key of the property to retrieve. May not be <code>null</code>.@return the property as an Integer, or <code>null</code> if the property could not be found.@throws IllegalArgumentException if the key is <code>null</code> or cannot be converted to an Integer. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 894 ---------------------------------------------
Retrieve a property as a Double.@param key the key of the property to retrieve@return the property as a Double --> [[[FAILED]]]

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[topper]] ( final String [[dreams]] ) { Number number = ( Number ) map . get ( [[dreams]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 895 ---------------------------------------------
Create a bean definition for the given name and type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 896 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 430 / 447 / 19 / 896:  90%|████████▉ | 896/1000 [28:05:20<3:15:37, 112.86s/it][Succeeded / Failed / Skipped / Total] 430 / 447 / 19 / 896:  90%|████████▉ | 897/1000 [28:08:39<3:13:54, 112.95s/it][Succeeded / Failed / Skipped / Total] 430 / 448 / 19 / 897:  90%|████████▉ | 897/1000 [28:08:39<3:13:54, 112.95s/it][Succeeded / Failed / Skipped / Total] 430 / 448 / 19 / 897:  90%|████████▉ | 898/1000 [28:08:44<3:11:49, 112.83s/it][Succeeded / Failed / Skipped / Total] 431 / 448 / 19 / 898:  90%|████████▉ | 898/1000 [28:08:44<3:11:49, 112.83s/it][Succeeded / Failed / Skipped / Total] 431 / 448 / 19 / 898:  90%|████████▉ | 899/1000 [28:09:11<3:09:46, 112.74s/it][Succeeded / Failed / Skipped / Total] 431 / 449 / 19 / 899:  90%|████████▉ | 899/1000 [28:09:11<3:09:46, 112.74s/it][Succeeded / Failed / Skipped / Total] 431 / 449 / 19 / 899:  90%|█████████ | 900/1000 [28:13:27<3:08:09, 112.90s/it][Succeeded / Failed / Skipped / Total] 431 / 450 / 19 / 900:  90%|█████████ | 900/1000 [28:13:27<3:08:09, 112.90s/it][Succeeded / Failed / Skipped / Total] 431 / 450 / 19 / 900:  90%|█████████ | 901/1000 [28:13:59<3:06:07, 112.81s/it][Succeeded / Failed / Skipped / Total] 432 / 450 / 19 / 901:  90%|█████████ | 901/1000 [28:13:59<3:06:07, 112.81s/it][Succeeded / Failed / Skipped / Total] 432 / 450 / 19 / 901:  90%|█████████ | 902/1000 [28:18:18<3:04:30, 112.97s/it][Succeeded / Failed / Skipped / Total] 432 / 451 / 19 / 902:  90%|█████████ | 902/1000 [28:18:18<3:04:30, 112.97s/it][Succeeded / Failed / Skipped / Total] 432 / 451 / 19 / 902:  90%|█████████ | 903/1000 [28:18:29<3:02:27, 112.86s/it][Succeeded / Failed / Skipped / Total] 432 / 452 / 19 / 903:  90%|█████████ | 903/1000 [28:18:29<3:02:27, 112.86s/it][Succeeded / Failed / Skipped / Total] 432 / 452 / 19 / 903:  90%|█████████ | 904/1000 [28:18:57<3:00:25, 112.76s/it]Adds a value to the map.@param key the key@param value the value@return this object --> Converts an obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfusc --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String [[value]] ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[intrigue]] ( final String [[miserly]] , final String [[eerie]] ) { Objects . requireNonNull ( [[miserly]] ) ; map . put ( [[miserly]] , [[eerie]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 897 ---------------------------------------------
Retrieve a property as a Long.@param key the key of the property to retrieve. May not be <code>null</code>.@return the property as a Long, or <code>null</code> if the property was not found.@throws ClassCastException if the property cannot be converted to a Long. --> [[[FAILED]]]

[[[[Adv]]]]: public Long getLong ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long getLong ( final String [[slapstick]] ) { Number number = ( Number ) map . get ( [[slapstick]] ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 898 ---------------------------------------------
Updates the flags for the given received email. --> NITI NITI NITI --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[nitti]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[Biko]]" == "[[Biko]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 899 ---------------------------------------------
Opens the specified folder. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[useFolder]] ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[folderName]] ; this . [[folder]] = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void [[lest]] ( final String [[rumsfeld]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[rumsfeld]] ; this . [[dossier]] = getService ( ) . getFolder ( [[rumsfeld]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[rumsfeld]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 900 ---------------------------------------------
Closes the specified folder. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[save]] ( final Folder [[millen]] ) { if ( [[millen]] != null ) { try { [[millen]] . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 901 ---------------------------------------------
Sets the mime or extension.@param mimeOrExtension the mime or extension@return this --> Sets the mimetype of the image. --> Socre: 1.0

[[[[Adv]]]]: public RawData [[as]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData [[mechanistic]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 902 ---------------------------------------------
Concatenate the specified string with the specified target string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[footballers]] ( final String [[flannels]] ) { return StringPool . LEFT_CHEV . concat ( [[flannels]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 903 ---------------------------------------------
Retrieve a property as a Float.@param key the key of the property to retrieve@return the property as a Float --> [[[FAILED]]]

[[[[Adv]]]]: public Float getFloat ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Float ) { return ( Float ) [[number]] ; } return [[number]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float getFloat ( final String [[greased]] ) { Number [[ikaria]] = ( Number ) map . get ( [[greased]] ) ; if ( [[ikaria]] == null ) { return null ; } if ( [[ikaria]] instanceof Float ) { return ( Float ) [[ikaria]] ; } return [[ikaria]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 904 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 433 / 452 / 19 / 904:  90%|█████████ | 904/1000 [28:18:57<3:00:25, 112.76s/it][Succeeded / Failed / Skipped / Total] 433 / 452 / 19 / 904:  90%|█████████ | 905/1000 [28:23:06<2:58:46, 112.91s/it][Succeeded / Failed / Skipped / Total] 433 / 453 / 19 / 905:  90%|█████████ | 905/1000 [28:23:06<2:58:46, 112.91s/it][Succeeded / Failed / Skipped / Total] 433 / 453 / 19 / 905:  91%|█████████ | 906/1000 [28:23:21<2:56:43, 112.81s/it][Succeeded / Failed / Skipped / Total] 434 / 453 / 19 / 906:  91%|█████████ | 906/1000 [28:23:21<2:56:43, 112.81s/it][Succeeded / Failed / Skipped / Total] 434 / 453 / 19 / 906:  91%|█████████ | 907/1000 [28:28:27<2:55:10, 113.02s/it][Succeeded / Failed / Skipped / Total] 435 / 453 / 19 / 907:  91%|█████████ | 907/1000 [28:28:27<2:55:10, 113.02s/it][Succeeded / Failed / Skipped / Total] 435 / 453 / 19 / 907:  91%|█████████ | 908/1000 [28:29:15<2:53:11, 112.95s/it][Succeeded / Failed / Skipped / Total] 436 / 453 / 19 / 908:  91%|█████████ | 908/1000 [28:29:15<2:53:11, 112.95s/it][Succeeded / Failed / Skipped / Total] 436 / 453 / 19 / 908:  91%|█████████ | 909/1000 [28:30:02<2:51:11, 112.87s/it][Succeeded / Failed / Skipped / Total] 436 / 454 / 19 / 909:  91%|█████████ | 909/1000 [28:30:02<2:51:11, 112.87s/it][Succeeded / Failed / Skipped / Total] 436 / 454 / 19 / 909:  91%|█████████ | 910/1000 [28:30:48<2:49:12, 112.80s/it][Succeeded / Failed / Skipped / Total] 437 / 454 / 19 / 910:  91%|█████████ | 910/1000 [28:30:48<2:49:12, 112.80s/it][Succeeded / Failed / Skipped / Total] 437 / 454 / 19 / 910:  91%|█████████ | 911/1000 [28:36:36<2:47:42, 113.06s/it][Succeeded / Failed / Skipped / Total] 437 / 455 / 19 / 911:  91%|█████████ | 911/1000 [28:36:36<2:47:42, 113.06s/it][Succeeded / Failed / Skipped / Total] 437 / 455 / 19 / 911:  91%|█████████ | 912/1000 [28:37:19<2:45:42, 112.98s/it]Lookup a named parameter.@param name the parameter name@return the named parameter or <code>null</code> --> Determines whether or not the specified English word is a species species species species species species species species species species species species species species species species --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[earthworms]] ( final String [[mandolin]] ) { DbQueryNamedParameter [[introduces]] = rootNP ; while ( [[introduces]] != null ) { if ( [[introduces]] . equalsName ( [[mandolin]] ) ) { return [[introduces]] ; } [[introduces]] = [[introduces]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 905 ---------------------------------------------
Adds a violation to the validator. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[addViolation]] ( final String [[name]] , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[name]] , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[chewing]] ( final String [[emphasized]] , final Object [[slytherin]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[emphasized]] , this , [[slytherin]] ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 906 ---------------------------------------------
Processes this class. --> Cintra --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[cintra]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 907 ---------------------------------------------
Sets the target class. --> Convenience factory method for florists --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[florists]] ( final Class [[tactile]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[tactile]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[tactile]] . getName ( ) ) ; } targetClass = [[tactile]] ; targetClassName = [[tactile]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[tactile]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 908 ---------------------------------------------
Creates a new instance of this class. --> Dumps the SASSAFREST: POSTGRES@param targetClassName@return --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[sassafras]] ( ) { process ( ) ; byte [ ] [[pedigree]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[pedigree]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[pedigree]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 909 ---------------------------------------------
Sets the target file. --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[prayed]] ( final InputStream [[blackmail]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[blackmail]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 910 ---------------------------------------------
Sets the target name.@param targetName the target name@return this --> Methuselah method --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final String [[targetName]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[targetName]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[targetName]] ) ; } targetClassName = [[targetName]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[targetName]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[methuselah]] ( final String [[mana]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[mana]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[mana]] ) ; } targetClassName = [[mana]] ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + [[mana]] , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 911 ---------------------------------------------
Downloads a file as a raw data.@param downloadFileName the name of the file to download.@return this for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: public RawData downloadableAs ( final String [[downloadFileName]] ) { this . downloadFileName = [[downloadFileName]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData downloadableAs ( final String [[gunmen]] ) { this . downloadFileName = [[gunmen]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[gunmen]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 912 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 437 / 456 / 19 / 912:  91%|█████████ | 912/1000 [28:37:19<2:45:42, 112.98s/it][Succeeded / Failed / Skipped / Total] 437 / 456 / 19 / 912:  91%|█████████▏| 913/1000 [28:40:52<2:43:58, 113.09s/it][Succeeded / Failed / Skipped / Total] 437 / 457 / 19 / 913:  91%|█████████▏| 913/1000 [28:40:52<2:43:58, 113.09s/it][Succeeded / Failed / Skipped / Total] 437 / 457 / 19 / 913:  91%|█████████▏| 914/1000 [28:41:14<2:41:57, 112.99s/it][Succeeded / Failed / Skipped / Total] 437 / 458 / 19 / 914:  91%|█████████▏| 914/1000 [28:41:14<2:41:57, 112.99s/it][Succeeded / Failed / Skipped / Total] 437 / 458 / 19 / 914:  92%|█████████▏| 915/1000 [28:44:23<2:40:11, 113.07s/it][Succeeded / Failed / Skipped / Total] 437 / 459 / 19 / 915:  92%|█████████▏| 915/1000 [28:44:23<2:40:11, 113.07s/it][Succeeded / Failed / Skipped / Total] 437 / 459 / 19 / 915:  92%|█████████▏| 916/1000 [28:46:08<2:38:17, 113.07s/it][Succeeded / Failed / Skipped / Total] 438 / 459 / 19 / 916:  92%|█████████▏| 916/1000 [28:46:08<2:38:17, 113.07s/it][Succeeded / Failed / Skipped / Total] 438 / 459 / 19 / 916:  92%|█████████▏| 917/1000 [28:48:01<2:36:24, 113.07s/it][Succeeded / Failed / Skipped / Total] 438 / 460 / 19 / 917:  92%|█████████▏| 917/1000 [28:48:01<2:36:24, 113.07s/it][Succeeded / Failed / Skipped / Total] 438 / 460 / 19 / 917:  92%|█████████▏| 918/1000 [28:50:17<2:34:33, 113.09s/it]Creates a new Proxetta instance. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[shorten]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 913 ---------------------------------------------
Dumps the class in debug folder. --> [[[FAILED]]]

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 914 ---------------------------------------------
Defines the proxied class. --> [[[FAILED]]]

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[successful]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 915 ---------------------------------------------
Validates the action.@param profiles the profiles to validate.@return <code>true</code> if the action is valid, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... [[profiles]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[profiles]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[violations]] = vtor . getViolations ( ) ; return [[violations]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[retardant]] ( final String ... [[ors]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[ors]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > [[monopolizing]] = vtor . getViolations ( ) ; return [[monopolizing]] == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 916 ---------------------------------------------
Creates a new email address with the given name and from address.@param personalName the name of the email address@param from the from address@return the created email address --> Converts a obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfuscated obfusc --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String [[personalName]] , final String [[from]] ) { return [[from]] ( new EmailAddress ( [[personalName]] , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[diffuse]] ( final String [[garcon]] , final String [[surrealists]] ) { return [[diffuse]] ( new EmailAddress ( [[garcon]] , [[diffuse]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 917 ---------------------------------------------
Converts the supplied email address into this object.@param to the email address to convert.@return this object. --> [[[FAILED]]]

[[[[Adv]]]]: public T to ( final EmailAddress [[to]] ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T to ( final EmailAddress [[surveying]] ) { this . [[dustpan]] = ArraysUtil . append ( this . [[dustpan]] , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 918 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 439 / 460 / 19 / 918:  92%|█████████▏| 918/1000 [28:50:17<2:34:33, 113.09s/it][Succeeded / Failed / Skipped / Total] 439 / 460 / 19 / 918:  92%|█████████▏| 919/1000 [28:51:25<2:32:36, 113.04s/it][Succeeded / Failed / Skipped / Total] 439 / 461 / 19 / 919:  92%|█████████▏| 919/1000 [28:51:25<2:32:36, 113.04s/it][Succeeded / Failed / Skipped / Total] 439 / 461 / 19 / 919:  92%|█████████▏| 920/1000 [28:55:27<2:30:54, 113.18s/it][Succeeded / Failed / Skipped / Total] 440 / 461 / 19 / 920:  92%|█████████▏| 920/1000 [28:55:27<2:30:54, 113.18s/it][Succeeded / Failed / Skipped / Total] 440 / 461 / 19 / 920:  92%|█████████▏| 921/1000 [28:57:23<2:29:01, 113.19s/it][Succeeded / Failed / Skipped / Total] 441 / 461 / 19 / 921:  92%|█████████▏| 921/1000 [28:57:23<2:29:01, 113.19s/it][Succeeded / Failed / Skipped / Total] 441 / 461 / 19 / 921:  92%|█████████▏| 922/1000 [28:57:49<2:27:01, 113.09s/it][Succeeded / Failed / Skipped / Total] 441 / 462 / 19 / 922:  92%|█████████▏| 922/1000 [28:57:49<2:27:01, 113.09s/it][Succeeded / Failed / Skipped / Total] 441 / 462 / 19 / 922:  92%|█████████▏| 923/1000 [28:59:01<2:25:04, 113.05s/it][Succeeded / Failed / Skipped / Total] 442 / 462 / 19 / 923:  92%|█████████▏| 923/1000 [28:59:01<2:25:04, 113.05s/it][Succeeded / Failed / Skipped / Total] 442 / 462 / 19 / 923:  92%|█████████▏| 924/1000 [29:00:42<2:23:10, 113.03s/it][Succeeded / Failed / Skipped / Total] 443 / 462 / 19 / 924:  92%|█████████▏| 924/1000 [29:00:42<2:23:10, 113.03s/it][Succeeded / Failed / Skipped / Total] 443 / 462 / 19 / 924:  92%|█████████▎| 925/1000 [29:01:25<2:21:11, 112.96s/it][Succeeded / Failed / Skipped / Total] 443 / 463 / 19 / 925:  92%|█████████▎| 925/1000 [29:01:25<2:21:11, 112.96s/it][Succeeded / Failed / Skipped / Total] 443 / 463 / 19 / 925:  93%|█████████▎| 926/1000 [29:10:20<2:19:52, 113.41s/it][Succeeded / Failed / Skipped / Total] 444 / 463 / 19 / 926:  93%|█████████▎| 926/1000 [29:10:20<2:19:52, 113.41s/it][Succeeded / Failed / Skipped / Total] 444 / 463 / 19 / 926:  93%|█████████▎| 927/1000 [29:15:49<2:18:16, 113.65s/it]Creates a text message. --> Creates a choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen choosen --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String text , final String [[encoding]] ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[gainsborough]] ( final String text , final String [[standout]] ) { return message ( new EmailMessage ( text , MimeTypes . MIME_TEXT_PLAIN , [[standout]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 919 ---------------------------------------------
Set the reply to address.@param REPLACEME0 the address to set@return this object --> [[[FAILED]]]

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[HOLIER]] ( final EmailAddress ... [[HOLIER]] ) { this . [[paramedics]] = ArraysUtil . join ( this . [[paramedics]] , valueOrEmptyArray ( [[HOLIER]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 920 ---------------------------------------------
Converts the specified email address to the specified one.@param personalName The name of the email address.@param to The address to convert.@return The converted email address. --> Convenience method for creating a new person from aaaahhhh@param aaaahhhh@param tennis@return --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String [[personalName]] , final String [[to]] ) { return [[to]] ( new EmailAddress ( [[personalName]] , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[priestley]] ( final String [[aaaahhhh]] , final String [[tennis]] ) { return [[priestley]] ( new EmailAddress ( [[aaaahhhh]] , [[priestley]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 921 ---------------------------------------------
Sets the html message.@param html the html message@param encoding the encoding@return the t --> Creates a personalized email with the given vichyssoise and country@param vichyssoise@param country@return --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[reais]] ( final String [[vichyssoise]] , final String [[tropical]] ) { return message ( new EmailMessage ( [[vichyssoise]] , MimeTypes . MIME_TEXT_HTML , [[tropical]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 922 ---------------------------------------------
Sets the cc recipient. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... [[ccs]] ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( [[ccs]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[flowerpots]] ( final EmailAddress ... [[ufos]] ) { this . [[drones]] = ArraysUtil . join ( this . [[drones]] , valueOrEmptyArray ( [[ufos]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 923 ---------------------------------------------
Sets the value of the specified header. --> Convenience method to convert a string to a terse object --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[unequivocally]] ( final String [[desecration]] , final String [[chowder]] ) { headers . put ( [[desecration]] , [[chowder]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 924 ---------------------------------------------
Returns the value of the specified named property as a boolean.@param name The name of the property to retrieve.@param defaultValue The default value to return if the property is not found.@return The property value as a boolean. --> Checks to see if the specified value is a valid sexagesimal sexagesimal sexagesimal sexagesimal sexagesimal sexagesimal sexagesimal sexagesimal sexagesimal --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String [[name]] , final boolean defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[flophouse]] ( final String [[schoolers]] , final boolean defaultValue ) { String value = get ( [[schoolers]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 925 ---------------------------------------------
Gets the resolved parameters. --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[dallying]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 926 ---------------------------------------------
Retrieve a long value from the properties file.@param name name of the property to retrieve.@param defaultValue default value to return if the property is not found.@return long value or default value. --> Sleeping for the specified amount of time --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String [[name]] , final long defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[gren]] ( final String [[sprinkle]] , final long defaultValue ) { String value = get ( [[sprinkle]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
[Succeeded / Failed / Skipped / Total] 444 / 464 / 19 / 927:  93%|█████████▎| 927/1000 [29:15:49<2:18:16, 113.65s/it][Succeeded / Failed / Skipped / Total] 444 / 464 / 19 / 927:  93%|█████████▎| 928/1000 [29:20:04<2:16:33, 113.80s/it][Succeeded / Failed / Skipped / Total] 444 / 465 / 19 / 928:  93%|█████████▎| 928/1000 [29:20:04<2:16:33, 113.80s/it][Succeeded / Failed / Skipped / Total] 444 / 465 / 19 / 928:  93%|█████████▎| 929/1000 [29:21:48<2:14:38, 113.79s/it][Succeeded / Failed / Skipped / Total] 445 / 465 / 19 / 929:  93%|█████████▎| 929/1000 [29:21:48<2:14:38, 113.79s/it][Succeeded / Failed / Skipped / Total] 445 / 465 / 19 / 929:  93%|█████████▎| 930/1000 [29:23:51<2:12:45, 113.80s/it][Succeeded / Failed / Skipped / Total] 445 / 466 / 19 / 930:  93%|█████████▎| 930/1000 [29:23:51<2:12:45, 113.80s/it][Succeeded / Failed / Skipped / Total] 445 / 466 / 19 / 930:  93%|█████████▎| 931/1000 [29:24:46<2:10:47, 113.73s/it][Succeeded / Failed / Skipped / Total] 446 / 466 / 19 / 931:  93%|█████████▎| 931/1000 [29:24:46<2:10:47, 113.73s/it][Succeeded / Failed / Skipped / Total] 446 / 466 / 19 / 931:  93%|█████████▎| 932/1000 [29:25:36<2:08:49, 113.67s/it][Succeeded / Failed / Skipped / Total] 447 / 466 / 19 / 932:  93%|█████████▎| 932/1000 [29:25:36<2:08:49, 113.67s/it][Succeeded / Failed / Skipped / Total] 447 / 466 / 19 / 932:  93%|█████████▎| 933/1000 [29:31:03<2:07:10, 113.89s/it]--------------------------------------------- Result 927 ---------------------------------------------
Resolve an alias for the supplied value.@param value the value to resolve.@return the alias. --> [[[FAILED]]]

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int len = value . length ( ) ; while ( i < len ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 928 ---------------------------------------------
Receives all messages from the specified folder.@param filter the filter to apply to the messages.@param flagsToSet the flags to set on the messages.@param flagsToUnset the flags to unset on the messages.@param envelope <code>true</code> if the messages should be enclosed in an envelope, <code>false</code> otherwise.@param processedMessageConsumer the consumer to process the messages. --> [[[FAILED]]]

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags [[flagsToUnset]] , final boolean envelope , final Consumer < Message [ ] > [[processedMessageConsumer]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags [[interventions]] , final boolean envelope , final Consumer < Message [ ] > [[unborn]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( filter == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( filter . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 929 ---------------------------------------------
Resolves the supplied path to the supplied value. --> Creates a black-wave visualization of the specified mo --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String [[value]] ) { boolean [[absolutePath]] = "False" != "False" ; if ( [[value]] != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[blackwater]] ( String path , String [[moai]] ) { boolean [[magnanimity]] = "False" != "False" ; if ( [[moai]] != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 930 ---------------------------------------------
Lookup the action path for the given alias. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime [[cfg]] = actionsManager . lookup ( [[alias]] ) ; if ( [[cfg]] != null ) { value = [[cfg]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[detention]] ( final String [[johanson]] ) { String value = actionsManager . lookupPathAlias ( [[johanson]] ) ; if ( value == null ) { ActionRuntime [[incompatibility]] = actionsManager . lookup ( [[johanson]] ) ; if ( [[incompatibility]] != null ) { value = [[incompatibility]] . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 931 ---------------------------------------------
Returns the index of the last dot after the given string. --> Z-Za-z-a-z-a-z-a-z-a-z-a-z- --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[zed]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 932 ---------------------------------------------
Retrieves the value of an integer property.@param name The name of the property.@param defaultValue The default value.@return The property value. --> Get the ebbe value from the specified schrader@param schrader@param defaultValue@return --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String [[name]] , final int defaultValue ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[ebbe]] ( final String [[schrader]] , final int defaultValue ) { String [[obtains]] = get ( [[schrader]] ) ; if ( [[obtains]] == null ) { return defaultValue ; } [[obtains]] = [[obtains]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[obtains]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 933 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 448 / 466 / 19 / 933:  93%|█████████▎| 933/1000 [29:31:03<2:07:10, 113.89s/it][Succeeded / Failed / Skipped / Total] 448 / 466 / 19 / 933:  93%|█████████▎| 934/1000 [29:34:33<2:05:23, 114.00s/it][Succeeded / Failed / Skipped / Total] 448 / 467 / 19 / 934:  93%|█████████▎| 934/1000 [29:34:33<2:05:23, 114.00s/it][Succeeded / Failed / Skipped / Total] 448 / 467 / 19 / 934:  94%|█████████▎| 935/1000 [29:36:17<2:03:29, 113.99s/it][Succeeded / Failed / Skipped / Total] 449 / 467 / 19 / 935:  94%|█████████▎| 935/1000 [29:36:17<2:03:29, 113.99s/it][Succeeded / Failed / Skipped / Total] 449 / 467 / 19 / 935:  94%|█████████▎| 936/1000 [29:37:17<2:01:31, 113.93s/it][Succeeded / Failed / Skipped / Total] 450 / 467 / 19 / 936:  94%|█████████▎| 936/1000 [29:37:17<2:01:31, 113.93s/it][Succeeded / Failed / Skipped / Total] 450 / 467 / 19 / 936:  94%|█████████▎| 937/1000 [29:41:08<1:59:45, 114.05s/it][Succeeded / Failed / Skipped / Total] 450 / 468 / 19 / 937:  94%|█████████▎| 937/1000 [29:41:08<1:59:45, 114.05s/it][Succeeded / Failed / Skipped / Total] 450 / 468 / 19 / 937:  94%|█████████▍| 938/1000 [29:42:52<1:57:50, 114.04s/it][Succeeded / Failed / Skipped / Total] 451 / 468 / 19 / 938:  94%|█████████▍| 938/1000 [29:42:52<1:57:50, 114.04s/it][Succeeded / Failed / Skipped / Total] 451 / 468 / 19 / 938:  94%|█████████▍| 939/1000 [29:44:32<1:55:55, 114.03s/it]Resolves the result path for the given path and value. --> Determines if the specified side of the specified side of the specified side of the specified side of thespecified side of the specified side of the specified side of thespecified side of the specified side of the specified side of thespecified side of the specified side of the specified side of thespecified side of the specified side of the specified side of thespecified side of the specified side of the specified side of the specified side of thespecified side of the specified side of the specified side of the specified side of thespecified side of the specified side of the specified side of the specified side of thespecified side of the specified side of the specified side of --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String [[path]] , final String [[value]] ) { final ResultPath resultPath = resolveResultPath ( [[path]] , [[value]] ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[degenerate]] ( final String [[sympathized]] , final String [[eliott]] ) { final ResultPath resultPath = resolveResultPath ( [[sympathized]] , [[eliott]] ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 934 ---------------------------------------------
Get the value of the specified property.@param name the property name@param defaultValue the default value@return the property value or the default value if the property is not set --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[get]] ( final String [[name]] , final String [[defaultValue]] ) { Objects . requireNonNull ( [[name]] ) ; String [[value]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[value]] = System . getProperty ( [[name]] ) ; } else { [[value]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( [[value]] == null ) { return [[defaultValue]] ; } return [[value]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[hah]] ( final String [[hindering]] , final String [[militarism]] ) { Objects . requireNonNull ( [[hindering]] ) ; String [[paternity]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[paternity]] = System . getProperty ( [[hindering]] ) ; } else { [[paternity]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[hindering]] ) ) ; } } catch ( Exception ignore ) { } if ( [[paternity]] == null ) { return [[militarism]] ; } return [[paternity]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 935 ---------------------------------------------
Strips the last camel-word from the given name. --> Returns the first non-alphanumeric letter in the given list of inhibitors. --> Socre: 1.0

[[[[Adv]]]]: public static String [[stripLastCamelWord]] ( String [[name]] ) { int [[ndx]] = [[name]] . length ( ) - 1 ; while ( [[ndx]] >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[name]] . charAt ( [[ndx]] ) ) ) { break ; } [[ndx]] -- ; } if ( [[ndx]] >= 0 ) { [[name]] = [[name]] . substring ( 0 , [[ndx]] ) ; } return [[name]] ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String [[anythingg]] ( String [[inhibitors]] ) { int [[humbug]] = [[inhibitors]] . length ( ) - 1 ; while ( [[humbug]] >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[inhibitors]] . charAt ( [[humbug]] ) ) ) { break ; } [[humbug]] -- ; } if ( [[humbug]] >= 0 ) { [[inhibitors]] = [[inhibitors]] . substring ( 0 , [[humbug]] ) ; } return [[inhibitors]] ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 936 ---------------------------------------------
Mix the specified dimension with the specified value. --> Creates a new eye --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[eyeful]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 937 ---------------------------------------------
Returns the index of the first dot after the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; if ( [[slashNdx]] == - 1 ) { [[slashNdx]] = 0 ; } return [[str]] . indexOf ( ' ' , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[bombings]] ( final String [[upstanding]] ) { int [[nurses]] = [[upstanding]] . lastIndexOf ( ' ' ) ; if ( [[nurses]] == - 1 ) { [[nurses]] = 0 ; } return [[upstanding]] . indexOf ( ' ' , [[nurses]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 938 ---------------------------------------------
Resolves the schema name for the given type.@param type the type@param defaultSchemaName the default schema name@return the resolved schema name --> Pick up an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String [[defaultSchemaName]] ) { String [[schemaName]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[schemaName]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[schemaName]] == null ) || ( [[schemaName]] . length ( ) == 0 ) ) { [[schemaName]] = [[defaultSchemaName]] ; } return [[schemaName]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[pickett]] ( final Class < ? > type , final String [[illiterates]] ) { String [[bankruptcy]] = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { [[bankruptcy]] = dbTable . schema ( ) . trim ( ) ; } if ( ( [[bankruptcy]] == null ) || ( [[bankruptcy]] . length ( ) == 0 ) ) { [[bankruptcy]] = [[illiterates]] ; } return [[bankruptcy]] ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 939 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 451 / 469 / 19 / 939:  94%|█████████▍| 939/1000 [29:44:32<1:55:55, 114.03s/it][Succeeded / Failed / Skipped / Total] 451 / 469 / 19 / 939:  94%|█████████▍| 940/1000 [29:46:20<1:54:01, 114.02s/it][Succeeded / Failed / Skipped / Total] 451 / 470 / 19 / 940:  94%|█████████▍| 940/1000 [29:46:20<1:54:01, 114.02s/it][Succeeded / Failed / Skipped / Total] 451 / 470 / 19 / 940:  94%|█████████▍| 941/1000 [29:46:40<1:52:01, 113.92s/it][Succeeded / Failed / Skipped / Total] 452 / 470 / 19 / 941:  94%|█████████▍| 941/1000 [29:46:40<1:52:01, 113.92s/it][Succeeded / Failed / Skipped / Total] 452 / 470 / 19 / 941:  94%|█████████▍| 942/1000 [29:49:00<1:50:09, 113.95s/it][Succeeded / Failed / Skipped / Total] 453 / 470 / 19 / 942:  94%|█████████▍| 942/1000 [29:49:00<1:50:09, 113.95s/it][Succeeded / Failed / Skipped / Total] 453 / 470 / 19 / 942:  94%|█████████▍| 943/1000 [29:49:25<1:48:09, 113.86s/it][Succeeded / Failed / Skipped / Total] 454 / 470 / 19 / 943:  94%|█████████▍| 943/1000 [29:49:25<1:48:09, 113.86s/it][Succeeded / Failed / Skipped / Total] 454 / 470 / 19 / 943:  94%|█████████▍| 944/1000 [29:51:04<1:46:14, 113.84s/it][Succeeded / Failed / Skipped / Total] 455 / 470 / 19 / 944:  94%|█████████▍| 944/1000 [29:51:04<1:46:14, 113.84s/it][Succeeded / Failed / Skipped / Total] 455 / 470 / 19 / 944:  94%|█████████▍| 945/1000 [29:59:40<1:44:44, 114.26s/it][Succeeded / Failed / Skipped / Total] 456 / 470 / 19 / 945:  94%|█████████▍| 945/1000 [29:59:40<1:44:44, 114.26s/it][Succeeded / Failed / Skipped / Total] 456 / 470 / 19 / 945:  95%|█████████▍| 946/1000 [30:04:55<1:43:01, 114.48s/it][Succeeded / Failed / Skipped / Total] 457 / 470 / 19 / 946:  95%|█████████▍| 946/1000 [30:04:55<1:43:01, 114.48s/it][Succeeded / Failed / Skipped / Total] 457 / 470 / 19 / 946:  95%|█████████▍| 947/1000 [30:07:59<1:41:11, 114.55s/it]Serialize a key-value pair.@param jsonContext the context@param currentPath the current path@param key the key@param value the value@param count the count --> [[[FAILED]]]

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 940 ---------------------------------------------
Returns the index of the last dot of the specified string.@param str the specified string@return the index of the last dot of the specified string --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String [[str]] ) { int [[slashNdx]] = [[str]] . lastIndexOf ( ' ' ) ; int [[dotNdx]] = StringUtil . lastIndexOf ( [[str]] , ' ' , [[str]] . length ( ) , [[slashNdx]] ) ; if ( [[dotNdx]] == - 1 ) { if ( [[slashNdx]] == - 1 ) { return - 1 ; } [[slashNdx]] ++ ; if ( [[slashNdx]] < [[str]] . length ( ) - 1 ) { [[dotNdx]] = [[slashNdx]] ; } else { [[dotNdx]] = - 1 ; } } return [[dotNdx]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[sumner]] ( final String [[newbies]] ) { int [[herlihy]] = [[newbies]] . lastIndexOf ( ' ' ) ; int [[biochemical]] = StringUtil . lastIndexOf ( [[newbies]] , ' ' , [[newbies]] . length ( ) , [[herlihy]] ) ; if ( [[biochemical]] == - 1 ) { if ( [[herlihy]] == - 1 ) { return - 1 ; } [[herlihy]] ++ ; if ( [[herlihy]] < [[newbies]] . length ( ) - 1 ) { [[biochemical]] = [[herlihy]] ; } else { [[biochemical]] = - 1 ; } } return [[biochemical]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 941 ---------------------------------------------
Schedules a key schedule. --> SODO --> Socre: 1.0

[[[[Adv]]]]: private void [[keySchedule]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void [[sodomy]] ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 942 ---------------------------------------------
Renders a pixel at the specified dimension. --> Renders a prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus prometheus --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int [[j]] , final int [[d]] ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ [[d]] % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int [[ambitions]] , final int [[showcases]] ) { y [ 1 ] ^= y [ 0 ] ; final long [[wines]] = r [ [[showcases]] % DEPTH_OF_D_IN_R ] [ [[ambitions]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 943 ---------------------------------------------
Gets the path to the resource. --> Get the name of the benover@param benover@return --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[benjamin]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[benjamin]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 944 ---------------------------------------------
Initializes the internal data structures. --> Performs a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] [[key]] , final long [ ] [[tweak]] ) { final int [[newNw]] = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[hisself]] ( final long [ ] [[stimuli]] , final long [ ] [[clinches]] ) { final int [[governors]] = [[stimuli]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 945 ---------------------------------------------
Removes the specified bounding character from the specified string. --> Removes any bounding characters from a hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphenated hyphen --> Socre: 1.0

[[[[Adv]]]]: private static String removeAnyBounding ( final char [[s]] , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( [[s]] ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String removeAnyBounding ( final char [[ailments]] , final char e , final String [[slinky]] ) { if ( [[slinky]] == null || [[slinky]] . length ( ) < 2 ) { return [[slinky]] ; } if ( [[slinky]] . startsWith ( String . valueOf ( [[ailments]] ) ) && [[slinky]] . endsWith ( String . valueOf ( e ) ) ) { return [[slinky]] . substring ( 1 , [[slinky]] . length ( ) - 1 ) ; } return [[slinky]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 946 ---------------------------------------------
Encrypts the specified byte array at the specified offset. --> Kaji kaji@param content@param feckless@return --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] content , final int [[offset]] ) { long [ ] [[contentBlock]] = bytesToLongs ( content , [[offset]] , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[contentBlock]] , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[kaji]] ( final byte [ ] content , final int [[feckless]] ) { long [ ] [[yoshiko]] = bytesToLongs ( content , [[feckless]] , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( [[yoshiko]] , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
[Succeeded / Failed / Skipped / Total] 457 / 471 / 19 / 947:  95%|█████████▍| 947/1000 [30:07:59<1:41:11, 114.55s/it][Succeeded / Failed / Skipped / Total] 457 / 471 / 19 / 947:  95%|█████████▍| 948/1000 [30:09:32<1:39:15, 114.53s/it][Succeeded / Failed / Skipped / Total] 458 / 471 / 19 / 948:  95%|█████████▍| 948/1000 [30:09:32<1:39:15, 114.53s/it][Succeeded / Failed / Skipped / Total] 458 / 471 / 19 / 948:  95%|█████████▍| 949/1000 [30:13:46<1:37:28, 114.67s/it][Succeeded / Failed / Skipped / Total] 458 / 472 / 19 / 949:  95%|█████████▍| 949/1000 [30:13:46<1:37:28, 114.67s/it][Succeeded / Failed / Skipped / Total] 458 / 472 / 19 / 949:  95%|█████████▌| 950/1000 [30:13:57<1:35:28, 114.57s/it][Succeeded / Failed / Skipped / Total] 458 / 473 / 19 / 950:  95%|█████████▌| 950/1000 [30:13:57<1:35:28, 114.57s/it][Succeeded / Failed / Skipped / Total] 458 / 473 / 19 / 950:  95%|█████████▌| 951/1000 [30:23:59<1:33:58, 115.08s/it][Succeeded / Failed / Skipped / Total] 458 / 474 / 19 / 951:  95%|█████████▌| 951/1000 [30:23:59<1:33:58, 115.08s/it][Succeeded / Failed / Skipped / Total] 458 / 474 / 19 / 951:  95%|█████████▌| 952/1000 [30:24:50<1:32:00, 115.01s/it]--------------------------------------------- Result 947 ---------------------------------------------
Resolve column descriptors.@param dbEntityDescriptorthe db entity descriptor@param propertythe property descriptor@param isAnnotatedthe is annotated@param columnNamethe column naming strategy@return the column descriptor --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 948 ---------------------------------------------
Initializes this message with the specified key and tweak.@param keyMessage the key message@param tweak1 the tweak 1@param tweak2 the tweak 2 --> Diesces the specified magnitude of the specified magnitude of the specified magnitude of thespecified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of thespecified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the specified magnitude of the --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String [[keyMessage]] , final long tweak1 , final long [[tweak2]] ) { long [ ] tweak = new long [ ] { tweak1 , [[tweak2]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( [[keyMessage]] ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[init]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[dy]] ( final String [[prevention]] , final long tweak1 , final long [[abstinence]] ) { long [ ] tweak = new long [ ] { tweak1 , [[abstinence]] } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( [[prevention]] ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; [[dy]] ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 949 ---------------------------------------------
Gzip a file.@param file the file@return the file@throws IOException the io exception --> [[[FAILED]]]

[[[[Adv]]]]: public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File gzip ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String gzipName = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 950 ---------------------------------------------
Zlib zlib.@param file the file@return the file@throws IOException the io exception --> [[[FAILED]]]

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 951 ---------------------------------------------
Converts a byte array to a long array.@param ba byte array@param offset offset into byte array@param size size of array@return long array --> [[[FAILED]]]

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 952 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 474 / 19 / 952:  95%|█████████▌| 952/1000 [30:24:50<1:32:00, 115.01s/it][Succeeded / Failed / Skipped / Total] 459 / 474 / 19 / 952:  95%|█████████▌| 953/1000 [30:27:54<1:30:08, 115.08s/it][Succeeded / Failed / Skipped / Total] 459 / 475 / 19 / 953:  95%|█████████▌| 953/1000 [30:27:54<1:30:08, 115.08s/it][Succeeded / Failed / Skipped / Total] 459 / 475 / 19 / 953:  95%|█████████▌| 954/1000 [30:28:44<1:28:10, 115.02s/it][Succeeded / Failed / Skipped / Total] 460 / 475 / 19 / 954:  95%|█████████▌| 954/1000 [30:28:44<1:28:10, 115.02s/it][Succeeded / Failed / Skipped / Total] 460 / 475 / 19 / 954:  96%|█████████▌| 955/1000 [30:42:55<1:26:50, 115.79s/it][Succeeded / Failed / Skipped / Total] 460 / 476 / 19 / 955:  96%|█████████▌| 955/1000 [30:42:55<1:26:50, 115.79s/it][Succeeded / Failed / Skipped / Total] 460 / 476 / 19 / 955:  96%|█████████▌| 956/1000 [30:47:30<1:25:01, 115.95s/it][Succeeded / Failed / Skipped / Total] 460 / 477 / 19 / 956:  96%|█████████▌| 956/1000 [30:47:30<1:25:01, 115.95s/it][Succeeded / Failed / Skipped / Total] 460 / 477 / 19 / 956:  96%|█████████▌| 957/1000 [30:50:01<1:23:07, 115.99s/it][Succeeded / Failed / Skipped / Total] 460 / 478 / 19 / 957:  96%|█████████▌| 957/1000 [30:50:01<1:23:07, 115.99s/it][Succeeded / Failed / Skipped / Total] 460 / 478 / 19 / 957:  96%|█████████▌| 958/1000 [30:53:01<1:21:14, 116.06s/it][Succeeded / Failed / Skipped / Total] 461 / 478 / 19 / 958:  96%|█████████▌| 958/1000 [30:53:01<1:21:14, 116.06s/it][Succeeded / Failed / Skipped / Total] 461 / 478 / 19 / 958:  96%|█████████▌| 959/1000 [30:54:00<1:19:15, 116.00s/it]Returns a list of entries in the specified ZIP file. --> Converts a file to a list of strings@param reorienting the file@return a list of strings@throws IOException --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File [[zipFile]] ) throws IOException { List < String > [[entries]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; [[entries]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[entries]] ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File [[reconsidering]] ) throws IOException { List < String > [[amada]] = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[reconsidering]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; [[amada]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[amada]] ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 953 ---------------------------------------------
Ungzip a file. --> [[[FAILED]]]

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 954 ---------------------------------------------
Unzip a zip file to a destination directory.@param zipFile the zip file@param destDir the destination directory@param patterns the patterns@throws IOException if an I/O error occurs --> Creates an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an obfuscated version of an --> Socre: 1.0

[[[[Adv]]]]: public static void [[unzip]] ( final String zipFile , final String [[destDir]] , final String ... [[patterns]] ) throws IOException { [[unzip]] ( new File ( zipFile ) , new File ( [[destDir]] ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void [[bricks]] ( final String zipFile , final String [[enthusiastically]] , final String ... [[deserves]] ) throws IOException { [[bricks]] ( new File ( zipFile ) , new File ( [[enthusiastically]] ) , [[deserves]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 955 ---------------------------------------------
Gets the session locale. --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession [[session]] ) { Locale [[locale]] = ( Locale ) [[session]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[crackheads]] ( final HttpSession [[pediatrician]] ) { Locale [[što]] = ( Locale ) [[pediatrician]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[što]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[što]] ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 956 ---------------------------------------------
Sets the request bundle name.@param request the servlet request@param bundleName the bundle name --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[inadequate]] ( final ServletRequest [[litany]] , final String [[orsini]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[orsini]] ) ; } [[litany]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[orsini]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 957 ---------------------------------------------
Sets the session locale.@param session the session@param localeCode the locale code --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale [[locale]] = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[permitted]] ( final HttpSession [[sneller]] , final String [[stealthy]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[stealthy]] ) ; } Locale [[supercharged]] = Locale . forLanguageTag ( [[stealthy]] ) ; [[sneller]] . setAttribute ( SESSION_LOCALE_ATTR , [[supercharged]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 958 ---------------------------------------------
Filter parameters for bean name@param beanName@param resolveReferenceParams@return --> zagreb zagreb --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[key]] = entry . getKey ( ) ; if ( ! [[key]] . startsWith ( beanName ) ) { continue ; } list . add ( [[key]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[zagreb]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[mathematicians]] = entry . getKey ( ) ; if ( ! [[mathematicians]] . startsWith ( beanName ) ) { continue ; } list . add ( [[mathematicians]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 959 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 462 / 478 / 19 / 959:  96%|█████████▌| 959/1000 [30:54:00<1:19:15, 116.00s/it][Succeeded / Failed / Skipped / Total] 462 / 478 / 19 / 959:  96%|█████████▌| 960/1000 [30:54:06<1:17:15, 115.88s/it][Succeeded / Failed / Skipped / Total] 463 / 478 / 19 / 960:  96%|█████████▌| 960/1000 [30:54:06<1:17:15, 115.88s/it][Succeeded / Failed / Skipped / Total] 463 / 478 / 19 / 960:  96%|█████████▌| 961/1000 [30:54:13<1:15:14, 115.77s/it][Succeeded / Failed / Skipped / Total] 463 / 479 / 19 / 961:  96%|█████████▌| 961/1000 [30:54:13<1:15:14, 115.77s/it][Succeeded / Failed / Skipped / Total] 463 / 479 / 19 / 961:  96%|█████████▌| 962/1000 [30:54:48<1:13:16, 115.68s/it][Succeeded / Failed / Skipped / Total] 464 / 479 / 19 / 962:  96%|█████████▌| 962/1000 [30:54:48<1:13:16, 115.68s/it][Succeeded / Failed / Skipped / Total] 464 / 479 / 19 / 962:  96%|█████████▋| 963/1000 [30:58:06<1:11:23, 115.77s/it][Succeeded / Failed / Skipped / Total] 464 / 480 / 19 / 963:  96%|█████████▋| 963/1000 [30:58:06<1:11:23, 115.77s/it][Succeeded / Failed / Skipped / Total] 464 / 480 / 19 / 963:  96%|█████████▋| 964/1000 [31:00:10<1:09:28, 115.78s/it]Reads data from an input stream.@param inputStream the input stream to read from@param close true if the stream should be closed@return the data read from the input stream@throws IOException if an I/O error occurs --> Rethrows IOException if an I/O error occurs --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[pardee]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 960 ---------------------------------------------
Returns the FieldDescriptor for the named field.@param name the name of the field@param declared {@code true} if the field is declared, {@code false} otherwise@return the FieldDescriptor for the named field --> Get the FieldDescriptor for the supplied String@param loyalists@param itsy@return --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( [[declared]] ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[loyalists]] , final boolean [[itsy]] ) { final FieldDescriptor [[launderer]] = getFields ( ) . getFieldDescriptor ( [[loyalists]] ) ; if ( [[launderer]] != null ) { if ( ! [[launderer]] . matchDeclared ( [[itsy]] ) ) { return null ; } } return [[launderer]] ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 961 ---------------------------------------------
Adds content to a ZIP file.@param zos ZIP output stream.@param content content to be added.@param path path to the file.@param comment comment to be added.@throws IOException if an I/O error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream [[zos]] , final byte [ ] [[content]] , String path , final String [[comment]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[comment]] != null ) { zipEntry . setComment ( [[comment]] ) ; } [[zos]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( [[content]] ) ; try { StreamUtil . copy ( is , [[zos]] ) ; } finally { StreamUtil . close ( is ) ; } [[zos]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[biddle]] ( final ZipOutputStream [[horman]] , final byte [ ] [[arm]] , String path , final String [[eerie]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[eerie]] != null ) { zipEntry . setComment ( [[eerie]] ) ; } [[horman]] . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( [[arm]] ) ; try { StreamUtil . copy ( is , [[horman]] ) ; } finally { StreamUtil . close ( is ) ; } [[horman]] . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 962 ---------------------------------------------
Returns the property descriptor associated with the supplied name.@param name the name of the property@param declared true if the property descriptor should be declared@return the property descriptor associated with the supplied name --> Creates a PropertyDescriptor for the 'least Known Known Known Known Known Better Better Better Better Better Better Better Better Better Better Better Better Better Betterbetter Better Better Better Better Better Better Better Better Better Better Better Betterbetter Better Better Better Better Better Better Better Better Better Better Betterbetter Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better Better --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( [[declared]] ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[astrologers]] ( final String [[propensity]] , final boolean [[sly]] ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[propensity]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( [[sly]] ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 963 ---------------------------------------------
Adds the specified profiles to this Props object. --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[giggled]] ( final String ... [[southerners]] ) { if ( [[southerners]] == null ) { return this ; } for ( String [[giggled]] : [[southerners]] ) { addProfiles ( [[giggled]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 964 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 465 / 480 / 19 / 964:  96%|█████████▋| 964/1000 [31:00:10<1:09:28, 115.78s/it][Succeeded / Failed / Skipped / Total] 465 / 480 / 19 / 964:  96%|█████████▋| 965/1000 [31:08:04<1:07:45, 116.15s/it][Succeeded / Failed / Skipped / Total] 466 / 480 / 19 / 965:  96%|█████████▋| 965/1000 [31:08:04<1:07:45, 116.15s/it][Succeeded / Failed / Skipped / Total] 466 / 480 / 19 / 965:  97%|█████████▋| 966/1000 [31:08:58<1:05:46, 116.09s/it][Succeeded / Failed / Skipped / Total] 466 / 481 / 19 / 966:  97%|█████████▋| 966/1000 [31:08:58<1:05:46, 116.09s/it][Succeeded / Failed / Skipped / Total] 466 / 481 / 19 / 966:  97%|█████████▋| 967/1000 [31:10:12<1:03:49, 116.04s/it][Succeeded / Failed / Skipped / Total] 467 / 481 / 19 / 967:  97%|█████████▋| 967/1000 [31:10:12<1:03:49, 116.04s/it][Succeeded / Failed / Skipped / Total] 467 / 481 / 19 / 967:  97%|█████████▋| 968/1000 [31:10:55<1:01:50, 115.97s/it][Succeeded / Failed / Skipped / Total] 468 / 481 / 19 / 968:  97%|█████████▋| 968/1000 [31:10:55<1:01:50, 115.97s/it][Succeeded / Failed / Skipped / Total] 468 / 481 / 19 / 968:  97%|█████████▋| 969/1000 [31:14:02<59:57, 116.04s/it]  Reads the bootstrap methods attribute. --> SCHUMCHECKSTYLE:OFF --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[schumacher]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 965 ---------------------------------------------
Gets the bytecode offset for the given type annotation.@param typeAnnotationOffsets the type annotation offsets@param typeAnnotationIndex the type annotation index@return the bytecode offset --> zapper for sketches --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] [[typeAnnotationOffsets]] , final int [[typeAnnotationIndex]] ) { if ( [[typeAnnotationOffsets]] == null || [[typeAnnotationIndex]] >= [[typeAnnotationOffsets]] . length || readByte ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[typeAnnotationOffsets]] [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[zapper]] ( final int [ ] [[deferred]] , final int [[musket]] ) { if ( [[deferred]] == null || [[musket]] >= [[deferred]] . length || readByte ( [[deferred]] [ [[musket]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( [[deferred]] [ [[musket]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 966 ---------------------------------------------
Adds the specified file to the specified ZIP output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File [[file]] , String [[path]] , final String comment , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( [[path]] == null ) { [[path]] = [[file]] . getName ( ) ; } while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } boolean [[isDir]] = [[file]] . isDirectory ( ) ; if ( [[isDir]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[mimeograph]] ( final ZipOutputStream zos , final File [[vegetative]] , String [[imaging]] , final String comment , final boolean recursive ) throws IOException { if ( ! [[vegetative]] . exists ( ) ) { throw new FileNotFoundException ( [[vegetative]] . toString ( ) ) ; } if ( [[imaging]] == null ) { [[imaging]] = [[vegetative]] . getName ( ) ; } while ( [[imaging]] . length ( ) != 0 && [[imaging]] . charAt ( 0 ) == ' ' ) { [[imaging]] = [[imaging]] . substring ( 1 ) ; } boolean [[mamita]] = [[vegetative]] . isDirectory ( ) ; if ( [[mamita]] ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 967 ---------------------------------------------
Returns a little-endian 64-bit integer from the specified byte array. --> Lije lije@param tris@param purposely@return --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] [[buf]] , final int [[offset]] ) { return ( ( long ) [[buf]] [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[lije]] ( final byte [ ] [[tris]] , final int [[purposely]] ) { return ( ( long ) [[tris]] [ [[purposely]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 968 ---------------------------------------------
Analyzes all constructors in the class descriptor. --> hacky methods --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[ctors]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ [[ctors]] . length ] ; for ( int i = 0 ; i < [[ctors]] . length ; i ++ ) { Constructor [[ctor]] = [[ctors]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[ctor]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[hacky]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[dismantle]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ [[dismantle]] . length ] ; for ( int i = 0 ; i < [[dismantle]] . length ; i ++ ) { Constructor [[antónio]] = [[dismantle]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[antónio]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 969 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 469 / 481 / 19 / 969:  97%|█████████▋| 969/1000 [31:14:02<59:57, 116.04s/it][Succeeded / Failed / Skipped / Total] 469 / 481 / 19 / 969:  97%|█████████▋| 970/1000 [31:14:38<57:58, 115.96s/it][Succeeded / Failed / Skipped / Total] 470 / 481 / 19 / 970:  97%|█████████▋| 970/1000 [31:14:38<57:58, 115.96s/it][Succeeded / Failed / Skipped / Total] 470 / 481 / 19 / 970:  97%|█████████▋| 971/1000 [31:14:42<55:59, 115.84s/it][Succeeded / Failed / Skipped / Total] 470 / 482 / 19 / 971:  97%|█████████▋| 971/1000 [31:14:42<55:59, 115.84s/it][Succeeded / Failed / Skipped / Total] 470 / 482 / 19 / 971:  97%|█████████▋| 972/1000 [31:15:11<54:01, 115.75s/it][Succeeded / Failed / Skipped / Total] 471 / 482 / 19 / 972:  97%|█████████▋| 972/1000 [31:15:11<54:01, 115.75s/it][Succeeded / Failed / Skipped / Total] 471 / 482 / 19 / 972:  97%|█████████▋| 973/1000 [31:18:24<52:07, 115.83s/it][Succeeded / Failed / Skipped / Total] 471 / 483 / 19 / 973:  97%|█████████▋| 973/1000 [31:18:24<52:07, 115.83s/it][Succeeded / Failed / Skipped / Total] 471 / 483 / 19 / 973:  97%|█████████▋| 974/1000 [31:23:46<50:17, 116.04s/it][Succeeded / Failed / Skipped / Total] 471 / 484 / 19 / 974:  97%|█████████▋| 974/1000 [31:23:46<50:17, 116.04s/it][Succeeded / Failed / Skipped / Total] 471 / 484 / 19 / 974:  98%|█████████▊| 975/1000 [31:24:05<48:18, 115.94s/it][Succeeded / Failed / Skipped / Total] 472 / 484 / 19 / 975:  98%|█████████▊| 975/1000 [31:24:05<48:18, 115.94s/it][Succeeded / Failed / Skipped / Total] 472 / 484 / 19 / 975:  98%|█████████▊| 976/1000 [31:25:15<46:21, 115.90s/it]Reads the verification type information from the specified frame. --> zoya --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int [[verificationTypeInfoOffset]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] [[labels]] ) { int currentOffset = [[verificationTypeInfoOffset]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[labels]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[zoya]] ( final int [[quatre]] , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] [[murasaki]] ) { int currentOffset = [[quatre]] ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , [[murasaki]] ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 970 ---------------------------------------------
Returns the ctor descriptor for the given arguments. --> zuckerberg methods --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor [[getCtorDescriptor]] ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int [[j]] = 0 ; [[j]] < arg . length ; [[j]] ++ ) { if ( arg [ [[j]] ] != args [ [[j]] ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor [[zuckerberg]] ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int [[matsushima]] = 0 ; [[matsushima]] < arg . length ; [[matsushima]] ++ ) { if ( arg [ [[matsushima]] ] != args [ [[matsushima]] ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 971 ---------------------------------------------
Reads a label from the specified bytecode offset. --> [[[FAILED]]]

[[[[Adv]]]]: protected Label [[readLabel]] ( final int bytecodeOffset , final Label [ ] [[labels]] ) { if ( [[labels]] [ bytecodeOffset ] == null ) { [[labels]] [ bytecodeOffset ] = new Label ( ) ; } return [[labels]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[mullen]] ( final int bytecodeOffset , final Label [ ] [[cloves]] ) { if ( [[cloves]] [ bytecodeOffset ] == null ) { [[cloves]] [ bytecodeOffset ] = new Label ( ) ; } return [[cloves]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 972 ---------------------------------------------
Adds a consumer to be called when a file is found. --> Adds the specified consumers to this finder. --> Socre: 1.0

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[fileConsumer]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[fileConsumer]] ) ; } else { consumers . add ( [[fileConsumer]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > [[directions]] ) { if ( consumers == null ) { consumers = Consumers . of ( [[directions]] ) ; } else { consumers . add ( [[directions]] ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 973 ---------------------------------------------
Gets the request map.@param servletRequest the servlet request@return the request map --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[songbird]] ( final HttpServletRequest [[insurers]] ) { return ( Map < String , TransientBeanData > ) [[insurers]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 974 ---------------------------------------------
Initializes this filter with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig [[filterConfig]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[hypnotherapy]] ( final FilterConfig [[rubbers]] ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 975 ---------------------------------------------
Searches for a file in this directory and adds it to this directory. --> M mullin --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL [[searchPath]] ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[mullin]] ( final URL [[shabnam]] ) { File file = FileUtil . toContainerFile ( [[mullin]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[mullin]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 976 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 472 / 485 / 19 / 976:  98%|█████████▊| 976/1000 [31:25:15<46:21, 115.90s/it][Succeeded / Failed / Skipped / Total] 472 / 485 / 19 / 976:  98%|█████████▊| 977/1000 [31:26:26<44:24, 115.85s/it][Succeeded / Failed / Skipped / Total] 473 / 485 / 19 / 977:  98%|█████████▊| 977/1000 [31:26:26<44:24, 115.85s/it][Succeeded / Failed / Skipped / Total] 473 / 485 / 19 / 977:  98%|█████████▊| 978/1000 [31:28:00<42:28, 115.83s/it][Succeeded / Failed / Skipped / Total] 474 / 485 / 19 / 978:  98%|█████████▊| 978/1000 [31:28:00<42:28, 115.83s/it][Succeeded / Failed / Skipped / Total] 474 / 485 / 19 / 978:  98%|█████████▊| 979/1000 [31:28:25<40:30, 115.74s/it][Succeeded / Failed / Skipped / Total] 474 / 486 / 19 / 979:  98%|█████████▊| 979/1000 [31:28:25<40:30, 115.74s/it][Succeeded / Failed / Skipped / Total] 474 / 486 / 19 / 979:  98%|█████████▊| 980/1000 [31:30:16<38:34, 115.73s/it][Succeeded / Failed / Skipped / Total] 475 / 486 / 19 / 980:  98%|█████████▊| 980/1000 [31:30:16<38:34, 115.73s/it][Succeeded / Failed / Skipped / Total] 475 / 486 / 19 / 980:  98%|█████████▊| 981/1000 [31:31:16<36:37, 115.67s/it][Succeeded / Failed / Skipped / Total] 475 / 487 / 19 / 981:  98%|█████████▊| 981/1000 [31:31:16<36:37, 115.67s/it][Succeeded / Failed / Skipped / Total] 475 / 487 / 19 / 981:  98%|█████████▊| 982/1000 [31:31:55<34:40, 115.60s/it][Succeeded / Failed / Skipped / Total] 475 / 488 / 19 / 982:  98%|█████████▊| 982/1000 [31:31:55<34:40, 115.60s/it][Succeeded / Failed / Skipped / Total] 475 / 488 / 19 / 982:  98%|█████████▊| 983/1000 [31:33:27<32:44, 115.57s/it]Creates a request map. --> [[[FAILED]]]

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > [[map]] = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , [[map]] ) ; return [[map]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[gothenburg]] ( final HttpServletRequest [[jughead]] ) { Map < String , TransientBeanData > [[constraints]] = new HashMap <> ( ) ; [[jughead]] . setAttribute ( ATTR_NAME , [[constraints]] ) ; return [[constraints]] ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 977 ---------------------------------------------
Includes the specified patterns.@param patterns the patterns to be included@return this finder --> Includes the specified FOURTH_FOURTH_FOURTH_FOURTH_LANGUAGE and FOURTH_FOURTH_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TWO_TW --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[fugitives]] ( final String ... [[narratives]] ) { for ( String pattern : [[narratives]] ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 978 ---------------------------------------------
Searches for a file in the specified path. --> SCHMALTZ@param neptune@return --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI [[searchPath]] ) { File [[file]] ; try { [[file]] = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[schmaltz]] ( final URI [[neptune]] ) { File [[exaggeration]] ; try { [[exaggeration]] = new File ( [[schmaltz]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[schmaltz]] , ex ) ; } addPath ( [[exaggeration]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 979 ---------------------------------------------
Reads the element values from the annotation.@param annotationVisitor the annotation visitor@param annotationOffset the annotation offset@param named the named attribute@param charBuffer the char buffer --> [[[FAILED]]]

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor [[annotationVisitor]] , final int [[annotationOffset]] , final boolean named , final char [ ] [[charBuffer]] ) { int [[currentOffset]] = [[annotationOffset]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor [[severed]] , final int [[complexion]] , final boolean named , final char [ ] [[lear]] ) { int [[toxicity]] = [[complexion]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 980 ---------------------------------------------
Adds a path to this file system. --> SUGGIES@param roving --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[sugars]] ( final File [[roving]] ) { if ( ! [[roving]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[roving]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 981 ---------------------------------------------
Converts an object to an array.@param value the object to convert.@return the array. --> [[[FAILED]]]

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class [[valueComponentType]] = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[result]] ; if ( [[valueComponentType]] . isPrimitive ( ) ) { [[result]] = convertPrimitiveArrayToArray ( [[value]] , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[finite]] ( final Object [[lunching]] ) { final Class [[auctioneer]] = [[lunching]] . getClass ( ) . getComponentType ( ) ; final long [ ] [[foolery]] ; if ( [[auctioneer]] . isPrimitive ( ) ) { [[foolery]] = convertPrimitiveArrayToArray ( [[lunching]] , [[auctioneer]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 982 ---------------------------------------------
Returns an iterator over the files in this directory. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[detachments]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 983 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 476 / 488 / 19 / 983:  98%|█████████▊| 983/1000 [31:33:27<32:44, 115.57s/it][Succeeded / Failed / Skipped / Total] 476 / 488 / 19 / 983:  98%|█████████▊| 984/1000 [31:34:35<30:48, 115.52s/it][Succeeded / Failed / Skipped / Total] 476 / 489 / 19 / 984:  98%|█████████▊| 984/1000 [31:34:35<30:48, 115.52s/it][Succeeded / Failed / Skipped / Total] 476 / 489 / 19 / 984:  98%|█████████▊| 985/1000 [31:35:14<28:51, 115.45s/it][Succeeded / Failed / Skipped / Total] 476 / 490 / 19 / 985:  98%|█████████▊| 985/1000 [31:35:14<28:51, 115.45s/it][Succeeded / Failed / Skipped / Total] 476 / 490 / 19 / 985:  99%|█████████▊| 986/1000 [31:38:33<26:57, 115.53s/it][Succeeded / Failed / Skipped / Total] 476 / 491 / 19 / 986:  99%|█████████▊| 986/1000 [31:38:33<26:57, 115.53s/it][Succeeded / Failed / Skipped / Total] 476 / 491 / 19 / 986:  99%|█████████▊| 987/1000 [31:39:43<25:01, 115.48s/it][Succeeded / Failed / Skipped / Total] 476 / 492 / 19 / 987:  99%|█████████▊| 987/1000 [31:39:43<25:01, 115.48s/it][Succeeded / Failed / Skipped / Total] 476 / 492 / 19 / 987:  99%|█████████▉| 988/1000 [31:40:44<23:05, 115.43s/it][Succeeded / Failed / Skipped / Total] 477 / 492 / 19 / 988:  99%|█████████▉| 988/1000 [31:40:44<23:05, 115.43s/it][Succeeded / Failed / Skipped / Total] 477 / 492 / 19 / 988:  99%|█████████▉| 989/1000 [31:42:11<21:09, 115.40s/it][Succeeded / Failed / Skipped / Total] 477 / 493 / 19 / 989:  99%|█████████▉| 989/1000 [31:42:11<21:09, 115.40s/it][Succeeded / Failed / Skipped / Total] 477 / 493 / 19 / 989:  99%|█████████▉| 990/1000 [31:44:56<19:14, 115.45s/it][Succeeded / Failed / Skipped / Total] 478 / 493 / 19 / 990:  99%|█████████▉| 990/1000 [31:44:56<19:14, 115.45s/it][Succeeded / Failed / Skipped / Total] 478 / 493 / 19 / 990:  99%|█████████▉| 991/1000 [31:46:38<17:18, 115.44s/it]Initializes the rules. --> zeph zeph --> Socre: 1.0

[[[[Adv]]]]: protected void [[init]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void [[zeph]] ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 984 ---------------------------------------------
Returns a buffered output writer. --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[include]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 985 ---------------------------------------------
Returns the output stream for this output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[endureth]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 986 ---------------------------------------------
Excludes all files that match the given patterns. --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile exclude ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... [[silicone]] ) { for ( String [[invitations]] : [[silicone]] ) { rules . exclude ( [[invitations]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 987 ---------------------------------------------
Resolves the wiring mode for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[overbearing]] ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 988 ---------------------------------------------
Append the descriptor.@param stringBuilder the string builder --> SCHRADER --> Socre: 1.0

[[[[Adv]]]]: private void [[appendDescriptor]] ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void [[schrader]] ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 989 ---------------------------------------------
Finds all files in the file system. --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > [[allFiles]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[allFiles]] . add ( file ) ; } return [[allFiles]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[fugitives]] ( ) { List < File > [[minute]] = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { [[minute]] . add ( file ) ; } return [[minute]] ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 990 ---------------------------------------------
Returns the number of elements in this array. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[crosswalk]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 991 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 478 / 494 / 19 / 991:  99%|█████████▉| 991/1000 [31:46:38<17:18, 115.44s/it][Succeeded / Failed / Skipped / Total] 478 / 494 / 19 / 991:  99%|█████████▉| 992/1000 [31:48:40<15:23, 115.44s/it][Succeeded / Failed / Skipped / Total] 479 / 494 / 19 / 992:  99%|█████████▉| 992/1000 [31:48:40<15:23, 115.44s/it][Succeeded / Failed / Skipped / Total] 479 / 494 / 19 / 992:  99%|█████████▉| 993/1000 [31:49:27<13:27, 115.37s/it][Succeeded / Failed / Skipped / Total] 480 / 494 / 19 / 993:  99%|█████████▉| 993/1000 [31:49:27<13:27, 115.37s/it][Succeeded / Failed / Skipped / Total] 480 / 494 / 19 / 993:  99%|█████████▉| 994/1000 [31:54:58<11:33, 115.59s/it][Succeeded / Failed / Skipped / Total] 481 / 494 / 19 / 994:  99%|█████████▉| 994/1000 [31:54:58<11:33, 115.59s/it][Succeeded / Failed / Skipped / Total] 481 / 494 / 19 / 994: 100%|█████████▉| 995/1000 [31:55:07<09:37, 115.48s/it][Succeeded / Failed / Skipped / Total] 482 / 494 / 19 / 995: 100%|█████████▉| 995/1000 [31:55:07<09:37, 115.48s/it][Succeeded / Failed / Skipped / Total] 482 / 494 / 19 / 995: 100%|█████████▉| 996/1000 [31:55:27<07:41, 115.39s/it]Gets the class name of this object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[unmask]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[dyeing]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[dyeing]] . append ( "[]" ) ; } return [[dyeing]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 992 ---------------------------------------------
Sets the rollback only flag. --> zacarias --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable [[th]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[th]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[zacarias]] ( final Throwable [[cover]] ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = [[cover]] ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 993 ---------------------------------------------
Get the number of arguments and return sizes for the given method descriptor. --> Bhattacharyya bhattacharyya --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String [[methodDescriptor]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[bhatnagar]] ( final String [[fogies]] ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 994 ---------------------------------------------
Returns a string representation of the method's descriptor. --> Generates a directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed directed --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Type [[returnType]] , final Type ... argumentTypes ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type [[argumentType]] : argumentTypes ) { [[argumentType]] . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; [[returnType]] . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String [[golfers]] ( final Type [[matrix]] , final Type ... argumentTypes ) { StringBuilder [[radioactive]] = new StringBuilder ( ) ; [[radioactive]] . append ( ' ' ) ; for ( Type [[emphasize]] : argumentTypes ) { [[emphasize]] . appendDescriptor ( [[radioactive]] ) ; } [[radioactive]] . append ( ' ' ) ; [[matrix]] . appendDescriptor ( [[radioactive]] ) ; return [[radioactive]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 995 ---------------------------------------------
Commits or rolls back the transaction. --> zeus@param doCommit --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "[[False]]" != "[[False]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[False]]" != "[[False]]" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[zeus]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "[[Kazama]]" != "[[Kazama]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[Kazama]]" != "[[Kazama]]" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 996 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 482 / 495 / 19 / 996: 100%|█████████▉| 996/1000 [31:55:27<07:41, 115.39s/it][Succeeded / Failed / Skipped / Total] 482 / 495 / 19 / 996: 100%|█████████▉| 997/1000 [31:58:37<05:46, 115.46s/it][Succeeded / Failed / Skipped / Total] 482 / 496 / 19 / 997: 100%|█████████▉| 997/1000 [31:58:37<05:46, 115.46s/it][Succeeded / Failed / Skipped / Total] 482 / 496 / 19 / 997: 100%|█████████▉| 998/1000 [31:58:43<03:50, 115.35s/it][Succeeded / Failed / Skipped / Total] 483 / 496 / 19 / 998: 100%|█████████▉| 998/1000 [31:58:43<03:50, 115.35s/it][Succeeded / Failed / Skipped / Total] 483 / 496 / 19 / 998: 100%|█████████▉| 999/1000 [31:59:03<01:55, 115.26s/it][Succeeded / Failed / Skipped / Total] 484 / 496 / 19 / 999: 100%|█████████▉| 999/1000 [31:59:03<01:55, 115.26s/it][Succeeded / Failed / Skipped / Total] 484 / 496 / 19 / 999: 100%|██████████| 1000/1000 [32:08:56<00:00, 115.74s/it]Returns the descriptor for the given constructor. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 997 ---------------------------------------------
Returns a description of the given method. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 998 ---------------------------------------------
Request a resource. --> Executes flintstone request@param <flintstone>@param <resourceType>@return --> Socre: 1.0

[[[[Adv]]]]: public < [[E]] > [[E]] requestResource ( final Class < [[E]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[E]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[maxResources]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[maxResources]] != - 1 ) && ( resources . size ( ) >= [[maxResources]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[E]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < [[flintstone]] > [[flintstone]] requestResource ( final Class < [[flintstone]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[flintstone]] resource = lookupResource ( resourceType ) ; if ( resource == null ) { int [[hypnotic]] = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( [[hypnotic]] != - 1 ) && ( resources . size ( ) >= [[hypnotic]] ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[flintstone]] > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 999 ---------------------------------------------
Resolve bean name.@param type the type@param useLongTypeName the use long type name@return the bean name --> zacarias --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class [[type]] , final boolean useLongTypeName ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( [[petiteBean]] != null ) { name = [[petiteBean]] . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = [[type]] . getName ( ) ; } else { name = StringUtil . uncapitalize ( [[type]] . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[zacarias]] ( final Class [[actresses]] , final boolean useLongTypeName ) { PetiteBean [[monumental]] = ( ( Class < ? > ) [[actresses]] ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( [[monumental]] != null ) { name = [[monumental]] . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = [[actresses]] . getName ( ) ; } else { name = StringUtil . uncapitalize ( [[actresses]] . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 1000 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 484 / 497 / 19 / 1000: 100%|██████████| 1000/1000 [32:08:56<00:00, 115.74s/it]Attack(
  (search_method): RandomSearch(
    (trials):  10
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
  (is_black_box):  True
) 

/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
[Succeeded / Failed / Skipped / Total] 484 / 497 / 19 / 1000: 100%|██████████| 1000/1000 [32:09:02<00:00, 115.74s/it]Rollback all resources. --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

+-------------------------------+---------+
| Attack Results                |         |
+-------------------------------+---------+
| Number of successful attacks: | 484     |
| Number of failed attacks:     | 497     |
| Number of skipped attacks:    | 19      |
| Original accuracy:            | 98.1%   |
| Accuracy under attack:        | 49.7%   |
| Attack success rate:          | 49.34%  |
| Average perturbed word %:     | 67.43%  |
| Average num. words per input: | 3.91    |
| Avg num queries:              | 1177.54 |
| Original BLEU-4:              | 14.44   |
| Perturbed BLEU-4:             | 2.87    |
+-------------------------------+---------+

