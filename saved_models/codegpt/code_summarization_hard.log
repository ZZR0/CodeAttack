Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 8 worker(s) on 8 GPU(s).
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1290.16it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 2/1000 [01:55<16:01:41, 57.82s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [01:55<16:01:41, 57.82s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 3/1000 [04:41<25:58:21, 93.78s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 3/1000 [04:41<25:58:21, 93.78s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 0 / 3:   0%|          | 4/1000 [05:28<22:43:21, 82.13s/it][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 4/1000 [05:28<22:43:21, 82.13s/it][Succeeded / Failed / Skipped / Total] 2 / 2 / 0 / 4:   0%|          | 5/1000 [08:48<29:12:34, 105.68s/it]--------------------------------------------- Result 1 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> Baryshakov's method --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[baryshnikov]] ( U value , boolean [[grasped]] , Disposable disposable ) { final Observer < ? super V > [[oversight]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[oversight]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[oversight]] , [[grasped]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 2 ---------------------------------------------
Creates a new processor with the specified capacity. --> Convenience method to develop a processor@param < T>@param tuscarora@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[develop]] ( int [[tuscarora]] ) { return new UnicastProcessor < T > ( [[tuscarora]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 3 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > wrap ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 4 ---------------------------------------------
Resets this scheduler. --> [[[FAILED]]]

[[[[Adv]]]]: public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void reset ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 5 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   0%|          | 5/1000 [08:48<29:12:34, 105.68s/it][Succeeded / Failed / Skipped / Total] 3 / 2 / 0 / 5:   1%|          | 6/1000 [09:04<25:02:46, 90.71s/it] [Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 6/1000 [09:04<25:02:47, 90.71s/it][Succeeded / Failed / Skipped / Total] 3 / 3 / 0 / 6:   1%|          | 7/1000 [09:33<22:36:32, 81.97s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 7/1000 [09:33<22:36:32, 81.97s/it][Succeeded / Failed / Skipped / Total] 3 / 4 / 0 / 7:   1%|          | 8/1000 [10:14<21:09:22, 76.78s/it][Succeeded / Failed / Skipped / Total] 4 / 4 / 0 / 8:   1%|          | 8/1000 [10:14<21:09:22, 76.78s/it][Succeeded / Failed / Skipped / Total] 4 / 4 / 0 / 8:   1%|          | 9/1000 [15:08<27:46:28, 100.90s/it][Succeeded / Failed / Skipped / Total] 4 / 5 / 0 / 9:   1%|          | 9/1000 [15:08<27:46:28, 100.90s/it][Succeeded / Failed / Skipped / Total] 4 / 5 / 0 / 9:   1%|          | 10/1000 [29:53<49:18:38, 179.31s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 10/1000 [29:53<49:18:38, 179.31s/it][Succeeded / Failed / Skipped / Total] 4 / 6 / 0 / 10:   1%|          | 11/1000 [30:48<46:10:07, 168.06s/it]Try to subscribe to a scalar map. --> Katharsis katharsis katharsis --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[katharine]] ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 6 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 7 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 8 ---------------------------------------------
Retries the specified number of times. --> Perform redial@param jours@param strategy@return --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[redial]] ( long [[jours]] , Predicate < ? super Throwable > [[nucleus]] ) { return toFlowable ( ) . retry ( [[jours]] , [[nucleus]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 9 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > sorted ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 10 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
[Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 11/1000 [30:48<46:10:07, 168.06s/it][Succeeded / Failed / Skipped / Total] 4 / 7 / 0 / 11:   1%|          | 12/1000 [32:01<43:56:50, 160.13s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|          | 12/1000 [32:01<43:56:50, 160.13s/it][Succeeded / Failed / Skipped / Total] 4 / 8 / 0 / 12:   1%|▏         | 13/1000 [35:08<44:27:30, 162.16s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 13/1000 [35:08<44:27:30, 162.16s/it][Succeeded / Failed / Skipped / Total] 4 / 9 / 0 / 13:   1%|▏         | 14/1000 [36:41<43:04:11, 157.25s/it][Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   1%|▏         | 14/1000 [36:41<43:04:11, 157.25s/it][Succeeded / Failed / Skipped / Total] 4 / 10 / 0 / 14:   2%|▏         | 15/1000 [37:02<40:32:53, 148.20s/it][Succeeded / Failed / Skipped / Total] 5 / 10 / 0 / 15:   2%|▏         | 15/1000 [37:02<40:32:53, 148.20s/it][Succeeded / Failed / Skipped / Total] 5 / 10 / 0 / 15:   2%|▏         | 16/1000 [37:08<38:04:06, 139.28s/it][Succeeded / Failed / Skipped / Total] 5 / 11 / 0 / 16:   2%|▏         | 16/1000 [37:08<38:04:06, 139.28s/it][Succeeded / Failed / Skipped / Total] 5 / 11 / 0 / 16:   2%|▏         | 17/1000 [37:33<36:11:37, 132.55s/it][Succeeded / Failed / Skipped / Total] 5 / 12 / 0 / 17:   2%|▏         | 17/1000 [37:33<36:11:37, 132.55s/it]textattack: Exception encountered for input "OrderedDict([('adv', 'public static < T , U > void @R_0@ ( SimplePlainQueue < T > @R_6@ , Subscriber < ? super U > @R_7@ , boolean @R_8@ , Disposable @R_9@ , QueueDrain < T , U > @R_10@ ) { int @R_1@ = 1 ; for ( ; ; ) { for ( ; ; ) { boolean @R_2@ = @R_10@ . done ( ) ; T @R_3@ = @R_6@ . poll ( ) ; boolean @R_4@ = @R_3@ == null ; if ( checkTerminated ( @R_2@ , @R_4@ , @R_7@ , @R_8@ , @R_6@ , @R_10@ ) ) { if ( @R_9@ != null ) { @R_9@ . @R_9@ ( ) ; } return ; } if ( @R_4@ ) { break ; } long @R_5@ = @R_10@ . requested ( ) ; if ( @R_5@ != 0L ) { if ( @R_10@ . accept ( @R_7@ , @R_3@ ) ) { if ( @R_5@ != Long . MAX_VALUE ) { @R_10@ . produced ( 1 ) ; } } } else { @R_6@ . clear ( ) ; if ( @R_9@ != null ) { @R_9@ . @R_9@ ( ) ; } @R_7@ . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } @R_1@ = @R_10@ . leave ( - @R_1@ ) ; if ( @R_1@ == 0 ) { break ; } } }'), ('nl', 'Drain the queue but give up with an error if there aren t enough requests .')])".
textattack: Traceback (most recent call last):
  File "/data/zzr/CodeAttack/codeattack/attacker.py", line 590, in attack_from_queue
    result = attack.attack(example, ground_truth_output)
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 417, in attack
    goal_function_result, _ = self.goal_function.init_attack_example(
  File "/data/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 68, in init_attack_example
    result, _ = self.get_result(attacked_text, check_skip=True)
  File "/data/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 79, in get_result
    results, search_over = self.get_results([attacked_text], **kwargs)
  File "/data/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 96, in get_results
    model_outputs = self._call_model(attacked_text_list)
  File "/data/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 216, in _call_model
    outputs = self._call_model_uncached(uncached_list)
  File "/data/zzr/CodeAttack/codeattack/goal_functions/goal_function.py", line 165, in _call_model_uncached
    batch_preds = self.model(batch)
  File "/data/zzr/CodeAttack/models/codegpt_models.py", line 771, in __call__
    output = self.model.generate(inputs=input)
  File "/data/zzr/CodeAttack/models/codegpt_models.py", line 892, in generate
    transformer_outputs = self.decoder(input_ids, past_key_values=past_hidden)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/gpt2/modeling_gpt2.py", line 1042, in forward
    transformer_outputs = self.transformer(
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/gpt2/modeling_gpt2.py", line 886, in forward
    outputs = block(
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/gpt2/modeling_gpt2.py", line 395, in forward
    attn_outputs = self.attn(
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/module.py", line 889, in _call_impl
    result = self.forward(*input, **kwargs)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/gpt2/modeling_gpt2.py", line 336, in forward
    attn_output, attn_weights = self._attn(query, key, value, attention_mask, head_mask)
  File "/data/zzr/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/transformers/models/gpt2/modeling_gpt2.py", line 193, in _attn
    attn_weights = torch.matmul(query, key.transpose(-1, -2))
RuntimeError: CUDA out of memory. Tried to allocate 20.00 MiB (GPU 6; 10.76 GiB total capacity; 970.79 MiB already allocated; 19.56 MiB free; 1.12 GiB reserved in total by PyTorch)

