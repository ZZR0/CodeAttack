Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 7 worker(s) on 7 GPU(s).
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
Using /home/cg/tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 646.17it/s][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 2/1000 [00:00<00:01, 757.30it/s][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 3/1000 [00:00<00:01, 831.98it/s][Succeeded / Failed / Skipped / Total] 0 / 4 / 0 / 4:   0%|          | 4/1000 [00:00<00:01, 882.22it/s][Succeeded / Failed / Skipped / Total] 0 / 5 / 0 / 5:   0%|          | 5/1000 [00:00<00:01, 915.35it/s][Succeeded / Failed / Skipped / Total] 0 / 6 / 0 / 6:   1%|          | 6/1000 [00:00<00:01, 939.30it/s][Succeeded / Failed / Skipped / Total] 0 / 7 / 0 / 7:   1%|          | 7/1000 [00:00<00:01, 970.61it/s]--------------------------------------------- Result 1 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[value]] , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[value]] ) ; } } else { q . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U [[valuate]] , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[valuate]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[valuate]] ) ; } } else { q . offer ( [[valuate]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 2 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[co]] , final Scheduler scheduler ) { final Observable < T > observable = [[co]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > [[Colorado]] , final Scheduler scheduler ) { final Observable < T > observable = [[Colorado]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[Colorado]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 3 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[make]] ( int capacityHint ) { return new UnicastProcessor < T > ( capacityHint ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 5 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[enfold]] ( ObservableSource < T > [[author]] ) { ObjectHelper . requireNonNull ( [[author]] , "source is null" ) ; if ( [[author]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[author]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[author]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 6 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sort]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 7 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromCompletable ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 8 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 8 / 0 / 8:   1%|          | 8/1000 [00:00<00:01, 983.28it/s][Succeeded / Failed / Skipped / Total] 0 / 9 / 0 / 9:   1%|          | 9/1000 [00:00<00:01, 990.39it/s][Succeeded / Failed / Skipped / Total] 0 / 10 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 998.22it/s][Succeeded / Failed / Skipped / Total] 0 / 11 / 0 / 11:   1%|          | 11/1000 [00:00<00:00, 999.23it/s][Succeeded / Failed / Skipped / Total] 0 / 12 / 0 / 12:   1%|          | 12/1000 [00:00<00:00, 1027.39it/s][Succeeded / Failed / Skipped / Total] 0 / 13 / 0 / 13:   1%|▏         | 13/1000 [00:00<00:00, 1053.44it/s][Succeeded / Failed / Skipped / Total] 0 / 14 / 0 / 14:   1%|▏         | 14/1000 [00:00<00:00, 1093.69it/s][Succeeded / Failed / Skipped / Total] 0 / 14 / 0 / 14:   2%|▏         | 15/1000 [00:06<07:16,  2.26it/s]  [Succeeded / Failed / Skipped / Total] 0 / 15 / 0 / 15:   2%|▏         | 15/1000 [00:06<07:16,  2.26it/s]Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > fromSingle ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[prize]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[prize]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 10 ---------------------------------------------
Resets this scheduler. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[readjust]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 11 ---------------------------------------------
Retries the specified number of times. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[rehear]] ( long [[multiplication]] , Predicate < ? super Throwable > [[proclaim]] ) { return toFlowable ( ) . retry ( [[multiplication]] , [[proclaim]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 12 ---------------------------------------------
Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[assess]] ) { return new JustValue < Object , T > ( [[assess]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 13 ---------------------------------------------
Returns an identity function. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[tetraiodothyronine]] > Function < [[tetraiodothyronine]] , [[tetraiodothyronine]] > [[identicalness]] ( ) { return ( Function < [[tetraiodothyronine]] , [[tetraiodothyronine]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 14 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[tetraiodothyronine]] > [[tetraiodothyronine]] requireNonNull ( [[tetraiodothyronine]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 15 ---------------------------------------------
Creates a new subject with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[produce]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "[[reliable]]" == "[[reliable]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 16 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 16 / 0 / 16:   2%|▏         | 16/1000 [00:07<07:39,  2.14it/s][Succeeded / Failed / Skipped / Total] 0 / 17 / 0 / 17:   2%|▏         | 17/1000 [00:07<07:28,  2.19it/s][Succeeded / Failed / Skipped / Total] 0 / 18 / 0 / 18:   2%|▏         | 18/1000 [00:08<08:06,  2.02it/s][Succeeded / Failed / Skipped / Total] 0 / 19 / 0 / 19:   2%|▏         | 19/1000 [00:11<10:01,  1.63it/s][Succeeded / Failed / Skipped / Total] 0 / 20 / 0 / 20:   2%|▏         | 20/1000 [00:13<11:22,  1.44it/s][Succeeded / Failed / Skipped / Total] 0 / 21 / 0 / 21:   2%|▏         | 21/1000 [00:14<11:38,  1.40it/s][Succeeded / Failed / Skipped / Total] 0 / 22 / 0 / 22:   2%|▏         | 22/1000 [00:15<11:06,  1.47it/s][Succeeded / Failed / Skipped / Total] 0 / 23 / 0 / 23:   2%|▏         | 23/1000 [00:17<12:05,  1.35it/s][Succeeded / Failed / Skipped / Total] 0 / 24 / 0 / 24:   2%|▏         | 24/1000 [00:18<12:38,  1.29it/s][Succeeded / Failed / Skipped / Total] 0 / 25 / 0 / 25:   2%|▎         | 25/1000 [00:25<16:17,  1.00s/it]Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 17 ---------------------------------------------
Creates a new non-blocking producer. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[produce]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[genuine]]" == "[[genuine]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 18 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 19 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > justFunction ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[tetraiodothyronine]] , U > Function < [[tetraiodothyronine]] , U > justFunction ( U value ) { return new JustValue < [[tetraiodothyronine]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "[[admittedly]]" == "[[admittedly]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a cast function from the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > castFunction ( Class < U > [[target]] ) { return new CastToClass < T , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > castFunction ( Class < U > [[aim]] ) { return new CastToClass < T , U > ( [[aim]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 22 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[produce]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 23 ---------------------------------------------
Returns the value associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T getValue ( ) { Object [[oxygen]] = value ; if ( [[oxygen]] != null && ! NotificationLite . isError ( [[oxygen]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 24 ---------------------------------------------
Gets the error associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable getError ( ) { Object [[oxygen]] = value ; if ( NotificationLite . isError ( [[oxygen]] ) ) { return NotificationLite . getError ( [[oxygen]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[request]] ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[bespeak]] ( Subscription [[sulfur]] , int prefetch ) { [[sulfur]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
[Succeeded / Failed / Skipped / Total] 0 / 26 / 0 / 26:   3%|▎         | 26/1000 [00:27<17:06,  1.05s/it][Succeeded / Failed / Skipped / Total] 0 / 27 / 0 / 27:   3%|▎         | 27/1000 [00:44<26:50,  1.66s/it][Succeeded / Failed / Skipped / Total] 0 / 28 / 0 / 28:   3%|▎         | 28/1000 [01:02<36:04,  2.23s/it][Succeeded / Failed / Skipped / Total] 1 / 28 / 0 / 29:   3%|▎         | 29/1000 [01:20<44:50,  2.77s/it][Succeeded / Failed / Skipped / Total] 1 / 28 / 0 / 29:   3%|▎         | 30/1000 [01:35<51:30,  3.19s/it][Succeeded / Failed / Skipped / Total] 1 / 29 / 0 / 30:   3%|▎         | 30/1000 [01:35<51:30,  3.19s/it][Succeeded / Failed / Skipped / Total] 1 / 29 / 0 / 30:   3%|▎         | 31/1000 [01:56<1:00:34,  3.75s/it][Succeeded / Failed / Skipped / Total] 1 / 30 / 0 / 31:   3%|▎         | 31/1000 [01:56<1:00:34,  3.75s/it][Succeeded / Failed / Skipped / Total] 1 / 30 / 0 / 31:   3%|▎         | 32/1000 [01:57<59:23,  3.68s/it]  --------------------------------------------- Result 26 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[sodding]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 27 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[actual]] , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[actual]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[actual]] , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > [[genuine]] , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { [[genuine]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[genuine]] , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[uracil]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 28 ---------------------------------------------
Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> [[[FAILED]]]

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[[sham]]" != "[[sham]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[demode]] ) ; } } Throwable [[demode]] = error ; if ( [[demode]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[demode]] ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 29 ---------------------------------------------
Adds the specified element to the end of the array. --> Add a coefficient to an adenine@param adenine@param b@return --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long b ) { long [[u]] = [[a]] + b ; if ( [[u]] < 0L ) { return Long . MAX_VALUE ; } return [[u]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[adenine]] , long b ) { long [[uranium]] = [[adenine]] + b ; if ( [[uranium]] < 0L ) { return Long . MAX_VALUE ; } return [[uranium]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply a long by another. --> [[[FAILED]]]

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[ampere]] , long b ) { long u = [[ampere]] * b ; if ( ( ( [[ampere]] | b ) >>> 31 ) != 0 ) { if ( u / [[ampere]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable [[following]] , Class < ? > [[commentator]] ) { ObjectHelper . requireNonNull ( [[following]] , "next is null" ) ; if ( upstream != null ) { [[following]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[commentator]] ) ; } return "[[simulated]]" != "[[simulated]]" ; } return "[[admittedly]]" == "[[admittedly]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 31 / 0 / 32:   3%|▎         | 32/1000 [01:57<59:23,  3.68s/it][Succeeded / Failed / Skipped / Total] 1 / 31 / 0 / 32:   3%|▎         | 33/1000 [01:57<57:35,  3.57s/it][Succeeded / Failed / Skipped / Total] 1 / 32 / 0 / 33:   3%|▎         | 33/1000 [01:57<57:35,  3.57s/it][Succeeded / Failed / Skipped / Total] 1 / 32 / 0 / 33:   3%|▎         | 34/1000 [01:58<55:58,  3.48s/it][Succeeded / Failed / Skipped / Total] 1 / 33 / 0 / 34:   3%|▎         | 34/1000 [01:58<55:58,  3.48s/it][Succeeded / Failed / Skipped / Total] 1 / 33 / 0 / 34:   4%|▎         | 35/1000 [01:59<55:04,  3.42s/it][Succeeded / Failed / Skipped / Total] 1 / 34 / 0 / 35:   4%|▎         | 35/1000 [01:59<55:04,  3.42s/it][Succeeded / Failed / Skipped / Total] 1 / 34 / 0 / 35:   4%|▎         | 36/1000 [01:59<53:32,  3.33s/it][Succeeded / Failed / Skipped / Total] 1 / 35 / 0 / 36:   4%|▎         | 36/1000 [01:59<53:32,  3.33s/it][Succeeded / Failed / Skipped / Total] 1 / 35 / 0 / 36:   4%|▎         | 37/1000 [02:01<52:42,  3.28s/it]Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[t]] == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[r]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[triiodothyronine]] ; try { [[triiodothyronine]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[triiodothyronine]] == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[radius]] ; try { [[radius]] = ObjectHelper . requireNonNull ( mapper . apply ( [[triiodothyronine]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[radius]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[radius]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[radius]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 33 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long n ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[impart]] ( AtomicLong [[request]] , long n ) { for ( ; ; ) { long r = [[request]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( [[request]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 34 ---------------------------------------------
Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > [[q]] , Subscriber < ? super U > [[a]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T [[v]] = [[q]] . poll ( ) ; boolean empty = [[v]] == null ; if ( checkTerminated ( d , empty , [[a]] , delayError , [[q]] , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[a]] , [[v]] ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[q]] . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > [[Q]] , Subscriber < ? super U > [[axerophthol]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T [[fivesome]] = [[Q]] . poll ( ) ; boolean empty = [[fivesome]] == null ; if ( checkTerminated ( d , empty , [[axerophthol]] , delayError , [[Q]] , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[axerophthol]] , [[fivesome]] ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[Q]] . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[axerophthol]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the pool. --> [[[FAILED]]]

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable [[ex]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[ex]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException toNpe ( Throwable [[antique]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[antique]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 37 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 36 / 0 / 37:   4%|▎         | 37/1000 [02:01<52:42,  3.28s/it][Succeeded / Failed / Skipped / Total] 1 / 36 / 0 / 37:   4%|▍         | 38/1000 [02:04<52:34,  3.28s/it][Succeeded / Failed / Skipped / Total] 1 / 37 / 0 / 38:   4%|▍         | 38/1000 [02:04<52:34,  3.28s/it][Succeeded / Failed / Skipped / Total] 1 / 37 / 0 / 38:   4%|▍         | 39/1000 [02:04<51:17,  3.20s/it][Succeeded / Failed / Skipped / Total] 1 / 38 / 0 / 39:   4%|▍         | 39/1000 [02:04<51:17,  3.20s/it][Succeeded / Failed / Skipped / Total] 1 / 38 / 0 / 39:   4%|▍         | 40/1000 [02:05<50:01,  3.13s/it][Succeeded / Failed / Skipped / Total] 2 / 38 / 0 / 40:   4%|▍         | 40/1000 [02:05<50:01,  3.13s/it][Succeeded / Failed / Skipped / Total] 2 / 38 / 0 / 40:   4%|▍         | 41/1000 [02:09<50:20,  3.15s/it][Succeeded / Failed / Skipped / Total] 2 / 39 / 0 / 41:   4%|▍         | 41/1000 [02:09<50:20,  3.15s/it][Succeeded / Failed / Skipped / Total] 2 / 39 / 0 / 41:   4%|▍         | 42/1000 [02:16<51:42,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 40 / 0 / 42:   4%|▍         | 42/1000 [02:16<51:42,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 40 / 0 / 42:   4%|▍         | 43/1000 [02:17<50:50,  3.19s/it][Succeeded / Failed / Skipped / Total] 2 / 41 / 0 / 43:   4%|▍         | 43/1000 [02:17<50:50,  3.19s/it][Succeeded / Failed / Skipped / Total] 2 / 41 / 0 / 43:   4%|▍         | 44/1000 [02:17<49:40,  3.12s/it]Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 38 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 39 ---------------------------------------------
Emits a loop. --> [[[FAILED]]]

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 40 ---------------------------------------------
Adds an object to the list. --> Add an oxygen --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[ADD]] ( Object [[oxygen]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 41 ---------------------------------------------
Sets the current subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public final void setSubscription ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription [[siemens]] ) { if ( cancelled ) { [[siemens]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[siemens]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[angstrom]] = actual ; if ( [[angstrom]] != null && cancelOnReplace ) { [[angstrom]] . cancel ( ) ; } actual = [[siemens]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[siemens]] . request ( r ) ; } return ; } Subscription [[angstrom]] = missedSubscription . getAndSet ( [[siemens]] ) ; if ( [[angstrom]] != null && cancelOnReplace ) { [[angstrom]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 42 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[future]] , Class < ? > [[perceiver]] ) { ObjectHelper . requireNonNull ( [[future]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[future]] ) ) { [[future]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[perceiver]] ) ; } return "False" != "False" ; } return "[[lawful]]" == "[[lawful]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 43 ---------------------------------------------
Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[following]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[following]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[following]] ) ) { [[following]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 44 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 42 / 0 / 44:   4%|▍         | 44/1000 [02:17<49:41,  3.12s/it][Succeeded / Failed / Skipped / Total] 2 / 42 / 0 / 44:   4%|▍         | 45/1000 [02:23<50:55,  3.20s/it][Succeeded / Failed / Skipped / Total] 2 / 43 / 0 / 45:   4%|▍         | 45/1000 [02:23<50:55,  3.20s/it][Succeeded / Failed / Skipped / Total] 2 / 43 / 0 / 45:   5%|▍         | 46/1000 [02:32<52:35,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 44 / 0 / 46:   5%|▍         | 46/1000 [02:32<52:35,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 44 / 0 / 46:   5%|▍         | 47/1000 [02:32<51:28,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 45 / 0 / 47:   5%|▍         | 47/1000 [02:32<51:28,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 45 / 0 / 47:   5%|▍         | 48/1000 [02:32<50:33,  3.19s/it][Succeeded / Failed / Skipped / Total] 2 / 46 / 0 / 48:   5%|▍         | 48/1000 [02:32<50:33,  3.19s/it][Succeeded / Failed / Skipped / Total] 2 / 46 / 0 / 48:   5%|▍         | 49/1000 [02:33<49:30,  3.12s/it][Succeeded / Failed / Skipped / Total] 2 / 47 / 0 / 49:   5%|▍         | 49/1000 [02:33<49:30,  3.12s/it][Succeeded / Failed / Skipped / Total] 2 / 47 / 0 / 49:   5%|▌         | 50/1000 [02:34<48:51,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 48 / 0 / 50:   5%|▌         | 50/1000 [02:34<48:51,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 48 / 0 / 50:   5%|▌         | 51/1000 [02:39<49:26,  3.13s/it]Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription [[succeeding]] , Class < ? > [[contributor]] ) { ObjectHelper . requireNonNull ( [[succeeding]] , "next is null" ) ; if ( upstream != null ) { [[succeeding]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[contributor]] ) ; } return "[[traitorously]]" != "[[traitorously]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 45 ---------------------------------------------
Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 46 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[rate]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[rate]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 47 ---------------------------------------------
Clears this hash set. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[unclutter]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 48 ---------------------------------------------
Returns the size of this hash set. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[sizing]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[solidification]] = resources ; return [[solidification]] != null ? [[solidification]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 49 ---------------------------------------------
Start unbounded. --> [[[FAILED]]]

[[[[Adv]]]]: public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 50 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[drop]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 51 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 49 / 0 / 51:   5%|▌         | 51/1000 [02:39<49:26,  3.13s/it][Succeeded / Failed / Skipped / Total] 2 / 49 / 0 / 51:   5%|▌         | 52/1000 [02:48<51:11,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 50 / 0 / 52:   5%|▌         | 52/1000 [02:48<51:11,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 50 / 0 / 52:   5%|▌         | 53/1000 [02:59<53:29,  3.39s/it][Succeeded / Failed / Skipped / Total] 2 / 51 / 0 / 53:   5%|▌         | 53/1000 [02:59<53:29,  3.39s/it][Succeeded / Failed / Skipped / Total] 2 / 51 / 0 / 53:   5%|▌         | 54/1000 [02:59<52:31,  3.33s/it][Succeeded / Failed / Skipped / Total] 2 / 52 / 0 / 54:   5%|▌         | 54/1000 [02:59<52:31,  3.33s/it][Succeeded / Failed / Skipped / Total] 2 / 52 / 0 / 54:   6%|▌         | 55/1000 [03:01<52:03,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 53 / 0 / 55:   6%|▌         | 55/1000 [03:01<52:03,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 53 / 0 / 55:   6%|▌         | 56/1000 [03:08<52:58,  3.37s/it][Succeeded / Failed / Skipped / Total] 2 / 54 / 0 / 56:   6%|▌         | 56/1000 [03:08<52:58,  3.37s/it][Succeeded / Failed / Skipped / Total] 2 / 54 / 0 / 56:   6%|▌         | 57/1000 [03:10<52:25,  3.34s/it][Succeeded / Failed / Skipped / Total] 2 / 55 / 0 / 57:   6%|▌         | 57/1000 [03:10<52:25,  3.34s/it][Succeeded / Failed / Skipped / Total] 2 / 55 / 0 / 57:   6%|▌         | 58/1000 [03:11<51:42,  3.29s/it]Starts the stream. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[bulge]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
Called when an error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[error]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[wrongdoing]] ( Throwable t ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( t ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( t ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 53 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[staring]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Called when the supplied value is complete. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[sodding]] ( T value ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[axerophthol]] = downstream ; if ( state == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; [[axerophthol]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[axerophthol]] . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { [[axerophthol]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 55 ---------------------------------------------
Concatenates an Iterable into a single Flowable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return concatMapIterable ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[plotter]] ) { return concatMapIterable ( [[plotter]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 56 ---------------------------------------------
ConcatMapDelayError. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 57 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[arrest]] ( ) { Disposable [[calciferol]] = resource . get ( ) ; if ( [[calciferol]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[calciferol]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 58 ---------------------------------------------
Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sieve]] ( Comparator < ? super T > sortFunction ) { ObjectHelper . requireNonNull ( sortFunction , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( sortFunction ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .[Succeeded / Failed / Skipped / Total] 2 / 56 / 0 / 58:   6%|▌         | 58/1000 [03:11<51:42,  3.29s/it][Succeeded / Failed / Skipped / Total] 2 / 56 / 0 / 58:   6%|▌         | 59/1000 [03:18<52:44,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 57 / 0 / 59:   6%|▌         | 59/1000 [03:18<52:44,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 57 / 0 / 59:   6%|▌         | 60/1000 [03:21<52:37,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 58 / 0 / 60:   6%|▌         | 60/1000 [03:21<52:37,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 58 / 0 / 60:   6%|▌         | 61/1000 [03:24<52:34,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 59 / 0 / 61:   6%|▌         | 61/1000 [03:24<52:34,  3.36s/it][Succeeded / Failed / Skipped / Total] 2 / 60 / 0 / 62:   6%|▌         | 62/1000 [03:24<51:40,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 60 / 0 / 62:   6%|▋         | 63/1000 [03:28<51:38,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 61 / 0 / 63:   6%|▋         | 63/1000 [03:28<51:38,  3.31s/it][Succeeded / Failed / Skipped / Total] 2 / 62 / 0 / 64:   6%|▋         | 64/1000 [03:30<51:11,  3.28s/it][Succeeded / Failed / Skipped / Total] 2 / 62 / 0 / 64:   6%|▋         | 65/1000 [03:30<50:32,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 63 / 0 / 65:   6%|▋         | 65/1000 [03:30<50:32,  3.24s/it][Succeeded / Failed / Skipped / Total] 2 / 64 / 0 / 66:   7%|▋         | 66/1000 [03:31<49:54,  3.21s/it][Succeeded / Failed / Skipped / Total] 2 / 64 / 0 / 66:   7%|▋         | 67/1000 [03:32<49:20,  3.17s/it][Succeeded / Failed / Skipped / Total] 2 / 65 / 0 / 67:   7%|▋         | 67/1000 [03:32<49:20,  3.17s/it]
--------------------------------------------- Result 59 ---------------------------------------------
Performs an asynchronous request. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[request]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[petition]] ( long n ) { Subscription s = this . upstream ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 60 ---------------------------------------------
Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> [[[FAILED]]]

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[look]] ) { if ( [[look]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 61 ---------------------------------------------
Accepts a subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "[[True]]" == "[[True]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "[[genuine]]" == "[[genuine]]" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[faux]]" != "[[faux]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 62 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[consent]] ( Observer < ? super U > observer ) { Object [ ] [[angstrom]] = head ; final int c = capacity ; while ( [[angstrom]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[angstrom]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "True" == "True" ; } } [[angstrom]] = ( Object [ ] ) [[angstrom]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 63 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[cf]] , final Scheduler scheduler ) { final Flowable < T > flowable = [[cf]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[CF]] , final Scheduler scheduler ) { final Flowable < T > flowable = [[CF]] . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[CF]] , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 64 ---------------------------------------------
Offers the specified element to the specified queue. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[provide]] ( T [[thyroxin]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[thyroxin]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[thyroxin]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 65 ---------------------------------------------
Sets the delay in milliseconds.@param amount the amount@param unit the unit --> [[[FAILED]]]

[[[[Adv]]]]: public void setDelay ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void setDelay ( long [[total]] , TimeUnit [[whole]] ) { if ( [[total]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[whole]] . toMillis ( [[total]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 66 ---------------------------------------------
Calculates the delay between the specified time units. --> [[[FAILED]]]

[[[[Adv]]]]: public long calculateDelay ( TimeUnit [[unit]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long calculateDelay ( TimeUnit [[whole]] ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 67 ---------------------------------------------
Returns the value of the given HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod valueOf ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
[Succeeded / Failed / Skipped / Total] 2 / 66 / 0 / 68:   7%|▋         | 68/1000 [03:33<48:49,  3.14s/it][Succeeded / Failed / Skipped / Total] 2 / 66 / 0 / 68:   7%|▋         | 69/1000 [03:35<48:28,  3.12s/it][Succeeded / Failed / Skipped / Total] 2 / 67 / 0 / 69:   7%|▋         | 69/1000 [03:35<48:28,  3.12s/it][Succeeded / Failed / Skipped / Total] 2 / 68 / 0 / 70:   7%|▋         | 70/1000 [03:35<47:49,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 68 / 0 / 70:   7%|▋         | 71/1000 [03:36<47:18,  3.06s/it][Succeeded / Failed / Skipped / Total] 2 / 69 / 0 / 71:   7%|▋         | 71/1000 [03:36<47:18,  3.06s/it][Succeeded / Failed / Skipped / Total] 2 / 70 / 0 / 72:   7%|▋         | 72/1000 [03:43<47:58,  3.10s/it][Succeeded / Failed / Skipped / Total] 2 / 70 / 0 / 72:   7%|▋         | 73/1000 [03:43<47:18,  3.06s/it][Succeeded / Failed / Skipped / Total] 2 / 71 / 0 / 73:   7%|▋         | 73/1000 [03:43<47:18,  3.06s/it]--------------------------------------------- Result 68 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> [[[FAILED]]]

[[[[Adv]]]]: private void createSampleData ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void createSampleData ( String username , String [[parole]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[parole]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 69 ---------------------------------------------
Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 70 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence rawPassword ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , rawPassword ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 71 ---------------------------------------------
Performs version checks. --> [[[FAILED]]]

[[[[Adv]]]]: private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void performVersionChecks ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[ps]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[b]] ; if ( n == 1 ) { [[b]] = EMPTY ; } else { [[b]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , [[b]] , 0 , j ) ; System . arraycopy ( a , j + 1 , [[b]] , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , [[b]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[hit]] ( PublishDisposable < T > [[phosphorus]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[phosphorus]] ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] [[boron]] ; if ( n == 1 ) { [[boron]] = EMPTY ; } else { [[boron]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , [[boron]] , 0 , j ) ; System . arraycopy ( a , j + 1 , [[boron]] , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( a , [[boron]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 73 ---------------------------------------------
Creates an error response. --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 72 / 0 / 74:   7%|▋         | 74/1000 [03:44<46:50,  3.04s/it][Succeeded / Failed / Skipped / Total] 2 / 72 / 0 / 74:   8%|▊         | 75/1000 [03:45<46:26,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 73 / 0 / 75:   8%|▊         | 75/1000 [03:45<46:26,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 74 / 0 / 76:   8%|▊         | 76/1000 [03:46<45:56,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 74 / 0 / 76:   8%|▊         | 77/1000 [03:47<45:24,  2.95s/it][Succeeded / Failed / Skipped / Total] 2 / 75 / 0 / 77:   8%|▊         | 77/1000 [03:47<45:24,  2.95s/it][Succeeded / Failed / Skipped / Total] 2 / 76 / 0 / 78:   8%|▊         | 78/1000 [03:47<44:46,  2.91s/it][Succeeded / Failed / Skipped / Total] 2 / 76 / 0 / 78:   8%|▊         | 79/1000 [03:48<44:29,  2.90s/it][Succeeded / Failed / Skipped / Total] 2 / 77 / 0 / 79:   8%|▊         | 79/1000 [03:48<44:29,  2.90s/it][Succeeded / Failed / Skipped / Total] 2 / 78 / 0 / 80:   8%|▊         | 80/1000 [03:49<43:56,  2.87s/it][Succeeded / Failed / Skipped / Total] 2 / 78 / 0 / 80:   8%|▊         | 81/1000 [03:51<43:45,  2.86s/it]Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 75 ---------------------------------------------
Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > oauth2Client ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 76 ---------------------------------------------
Determines whether or not checks should be disabled. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 77 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > oauth2ResourceServer ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 78 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> [[[FAILED]]]

[[[[Adv]]]]: private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String getSpringVersion ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 79 ---------------------------------------------
Retrieves an entry from the LDAP server. --> [[[FAILED]]]

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 80 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[setting]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[setting]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 79 / 0 / 81:   8%|▊         | 81/1000 [03:51<43:45,  2.86s/it][Succeeded / Failed / Skipped / Total] 2 / 80 / 0 / 82:   8%|▊         | 82/1000 [04:06<46:04,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 80 / 0 / 82:   8%|▊         | 83/1000 [04:07<45:39,  2.99s/it][Succeeded / Failed / Skipped / Total] 2 / 81 / 0 / 83:   8%|▊         | 83/1000 [04:07<45:39,  2.99s/it][Succeeded / Failed / Skipped / Total] 2 / 81 / 0 / 83:   8%|▊         | 84/1000 [04:19<47:14,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 82 / 0 / 84:   8%|▊         | 84/1000 [04:19<47:14,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 82 / 0 / 84:   8%|▊         | 85/1000 [04:26<47:50,  3.14s/it][Succeeded / Failed / Skipped / Total] 2 / 83 / 0 / 85:   8%|▊         | 85/1000 [04:26<47:50,  3.14s/it][Succeeded / Failed / Skipped / Total] 2 / 83 / 0 / 85:   9%|▊         | 86/1000 [04:31<48:09,  3.16s/it]Parses the response annotations. --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 82 ---------------------------------------------
Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[peer]] ( CharSequence rawPassword , String encodedPassword ) { String salt = extractSalt ( encodedPassword ) ; String rawPasswordEncoded = digest ( salt , rawPassword ) ; return PasswordEncoderUtils . equals ( encodedPassword . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 83 ---------------------------------------------
Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls buildControls ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 84 ---------------------------------------------
Lookup a set of primary keys.@param acls@param findNow@param sids --> [[[FAILED]]]

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 85 ---------------------------------------------
Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String [[base]] , final String [[filter]] , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > searchForMultipleAttributeValues ( final String [[groundwork]] , final String [[dribble]] , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 84 / 0 / 86:   9%|▊         | 86/1000 [04:31<48:09,  3.16s/it][Succeeded / Failed / Skipped / Total] 2 / 84 / 0 / 86:   9%|▊         | 87/1000 [04:32<47:42,  3.14s/it][Succeeded / Failed / Skipped / Total] 2 / 85 / 0 / 87:   9%|▊         | 87/1000 [04:32<47:42,  3.14s/it][Succeeded / Failed / Skipped / Total] 2 / 85 / 0 / 87:   9%|▉         | 88/1000 [04:33<47:17,  3.11s/it][Succeeded / Failed / Skipped / Total] 2 / 86 / 0 / 88:   9%|▉         | 88/1000 [04:33<47:17,  3.11s/it][Succeeded / Failed / Skipped / Total] 2 / 86 / 0 / 88:   9%|▉         | 89/1000 [04:35<46:56,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 87 / 0 / 89:   9%|▉         | 89/1000 [04:35<46:56,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 87 / 0 / 89:   9%|▉         | 90/1000 [04:38<46:52,  3.09s/it]Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[thymine]] ; try { [[thymine]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[honest]]" == "[[honest]]" ; } if ( [[thymine]] == null ) { EmptyDisposable . complete ( observer ) ; return "[[honest]]" == "[[honest]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[thymine]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[honest]]" == "[[honest]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "[[honest]]" == "[[honest]]" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "[[honest]]" == "[[honest]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "[[honest]]" == "[[honest]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 87 ---------------------------------------------
Creates the servlet api filter. --> [[[FAILED]]]

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void createServletApiFilter ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Creates and initializes the filter. --> [[[FAILED]]]

[[[[Adv]]]]: private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void createJaasApiFilter ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 89 ---------------------------------------------
Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[leave]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return [[leave]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 90 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 88 / 0 / 90:   9%|▉         | 90/1000 [04:38<46:52,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 88 / 0 / 90:   9%|▉         | 91/1000 [04:40<46:46,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 89 / 0 / 91:   9%|▉         | 91/1000 [04:40<46:46,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 89 / 0 / 91:   9%|▉         | 92/1000 [04:42<46:31,  3.07s/it][Succeeded / Failed / Skipped / Total] 2 / 90 / 0 / 92:   9%|▉         | 92/1000 [04:42<46:31,  3.07s/it][Succeeded / Failed / Skipped / Total] 2 / 90 / 0 / 92:   9%|▉         | 93/1000 [04:43<46:09,  3.05s/it]Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 91 ---------------------------------------------
Registers a spring security filter chain. --> [[[FAILED]]]

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 92 ---------------------------------------------
Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken getTokenForSeries ( String seriesId ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , seriesId ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + seriesId + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + seriesId + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + seriesId , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 93 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 91 / 0 / 93:   9%|▉         | 93/1000 [04:43<46:09,  3.05s/it][Succeeded / Failed / Skipped / Total] 2 / 91 / 0 / 93:   9%|▉         | 94/1000 [04:44<45:44,  3.03s/it][Succeeded / Failed / Skipped / Total] 2 / 92 / 0 / 94:   9%|▉         | 94/1000 [04:44<45:44,  3.03s/it][Succeeded / Failed / Skipped / Total] 2 / 92 / 0 / 94:  10%|▉         | 95/1000 [04:46<45:26,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 93 / 0 / 95:  10%|▉         | 95/1000 [04:46<45:26,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 93 / 0 / 95:  10%|▉         | 96/1000 [04:50<45:38,  3.03s/it][Succeeded / Failed / Skipped / Total] 2 / 94 / 0 / 96:  10%|▉         | 96/1000 [04:50<45:38,  3.03s/it][Succeeded / Failed / Skipped / Total] 2 / 94 / 0 / 96:  10%|▉         | 97/1000 [04:59<46:30,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 95 / 0 / 97:  10%|▉         | 97/1000 [04:59<46:30,  3.09s/it][Succeeded / Failed / Skipped / Total] 2 / 95 / 0 / 97:  10%|▉         | 98/1000 [05:00<46:08,  3.07s/it][Succeeded / Failed / Skipped / Total] 2 / 96 / 0 / 98:  10%|▉         | 98/1000 [05:00<46:08,  3.07s/it][Succeeded / Failed / Skipped / Total] 2 / 96 / 0 / 98:  10%|▉         | 99/1000 [05:02<45:55,  3.06s/it][Succeeded / Failed / Skipped / Total] 2 / 97 / 0 / 99:  10%|▉         | 99/1000 [05:02<45:55,  3.06s/it][Succeeded / Failed / Skipped / Total] 2 / 97 / 0 / 99:  10%|█         | 100/1000 [05:03<45:32,  3.04s/it]Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher newCipher ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 94 ---------------------------------------------
Called after properties have been set. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void afterPropertiesSet ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > [[phosphorus]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = [[phosphorus]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 96 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 97 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[ascribe]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[ascribe]] . size ( ) ) ; for ( String attribute : [[ascribe]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
Checks the content length of the response. --> [[[FAILED]]]

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 99 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void doFilter ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 100 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 98 / 0 / 100:  10%|█         | 100/1000 [05:03<45:32,  3.04s/it][Succeeded / Failed / Skipped / Total] 2 / 98 / 0 / 100:  10%|█         | 101/1000 [05:03<45:04,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 99 / 0 / 101:  10%|█         | 101/1000 [05:03<45:04,  3.01s/it][Succeeded / Failed / Skipped / Total] 2 / 99 / 0 / 101:  10%|█         | 102/1000 [05:04<44:43,  2.99s/it][Succeeded / Failed / Skipped / Total] 2 / 100 / 0 / 102:  10%|█         | 102/1000 [05:04<44:43,  2.99s/it][Succeeded / Failed / Skipped / Total] 2 / 100 / 0 / 102:  10%|█         | 103/1000 [05:05<44:17,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 101 / 0 / 103:  10%|█         | 103/1000 [05:05<44:17,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 101 / 0 / 103:  10%|█         | 104/1000 [05:05<43:54,  2.94s/it][Succeeded / Failed / Skipped / Total] 2 / 102 / 0 / 104:  10%|█         | 104/1000 [05:05<43:54,  2.94s/it][Succeeded / Failed / Skipped / Total] 2 / 102 / 0 / 104:  10%|█         | 105/1000 [05:10<44:08,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 103 / 0 / 105:  10%|█         | 105/1000 [05:10<44:08,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 103 / 0 / 105:  11%|█         | 106/1000 [05:12<43:51,  2.94s/it]Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String [[base]] , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[base]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[values]] = map . get ( attributeName ) ; if ( [[values]] != null ) { result . addAll ( [[values]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String [[baseborn]] , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[baseborn]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > [[appraise]] = map . get ( attributeName ) ; if ( [[appraise]] != null ) { result . addAll ( [[appraise]] ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 101 ---------------------------------------------
Sets the login processing URL. --> [[[FAILED]]]

[[[[Adv]]]]: public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T loginProcessingUrl ( String loginProcessingUrl ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 102 ---------------------------------------------
Updates the default authentication settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void updateAuthenticationDefaults ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 103 ---------------------------------------------
Updates the default access settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void updateAccessDefaults ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 104 ---------------------------------------------
Maps a password value to a string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String mapPassword ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 105 ---------------------------------------------
Performs a pre-authenticated authentication. --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest [[asking]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[asking]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[asking]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[asking]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[asking]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[asking]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 106 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 104 / 0 / 106:  11%|█         | 106/1000 [05:12<43:51,  2.94s/it][Succeeded / Failed / Skipped / Total] 2 / 104 / 0 / 106:  11%|█         | 107/1000 [05:15<43:51,  2.95s/it][Succeeded / Failed / Skipped / Total] 2 / 105 / 0 / 107:  11%|█         | 107/1000 [05:15<43:51,  2.95s/it][Succeeded / Failed / Skipped / Total] 2 / 105 / 0 / 107:  11%|█         | 108/1000 [05:21<44:14,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 106 / 0 / 108:  11%|█         | 108/1000 [05:21<44:14,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 106 / 0 / 108:  11%|█         | 109/1000 [05:24<44:11,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 107 / 0 / 109:  11%|█         | 109/1000 [05:24<44:11,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 107 / 0 / 109:  11%|█         | 110/1000 [05:26<44:01,  2.97s/it]Search for a single entry under the given base and filter. --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String [[base]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[base]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String [[pedestal]] , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( [[pedestal]] ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 107 ---------------------------------------------
Extracts the remember-me cookie from the request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 108 ---------------------------------------------
Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 109 ---------------------------------------------
Returns the port of the given service URL. --> [[[FAILED]]]

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int [[port]] = casServiceUrl . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = casServiceUrl . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int getServicePort ( URL casServiceUrl ) { int [[embrasure]] = casServiceUrl . getPort ( ) ; if ( [[embrasure]] == - 1 ) { [[embrasure]] = casServiceUrl . getDefaultPort ( ) ; } return [[embrasure]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 108 / 0 / 110:  11%|█         | 110/1000 [05:26<44:01,  2.97s/it][Succeeded / Failed / Skipped / Total] 2 / 108 / 0 / 110:  11%|█         | 111/1000 [05:30<44:07,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 109 / 0 / 111:  11%|█         | 111/1000 [05:30<44:07,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 109 / 0 / 111:  11%|█         | 112/1000 [05:35<44:20,  3.00s/it][Succeeded / Failed / Skipped / Total] 2 / 110 / 0 / 112:  11%|█         | 112/1000 [05:35<44:20,  3.00s/it][Succeeded / Failed / Skipped / Total] 2 / 110 / 0 / 112:  11%|█▏        | 113/1000 [05:36<44:02,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 111 / 0 / 113:  11%|█▏        | 113/1000 [05:36<44:02,  2.98s/it][Succeeded / Failed / Skipped / Total] 2 / 111 / 0 / 113:  11%|█▏        | 114/1000 [05:37<43:42,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 112 / 0 / 114:  11%|█▏        | 114/1000 [05:37<43:42,  2.96s/it][Succeeded / Failed / Skipped / Total] 2 / 112 / 0 / 114:  12%|█▏        | 115/1000 [05:38<43:23,  2.94s/it]Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[authorities]] ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[bureau]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[bureau]] . size ( ) ) ; for ( GrantedAuthority authority : [[bureau]] ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 111 ---------------------------------------------
Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest [[request]] , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean principalChanged ( HttpServletRequest [[petition]] , Authentication currentAuthentication ) { Object principal = getPreAuthenticatedPrincipal ( [[petition]] ) ; if ( ( principal instanceof String ) && currentAuthentication . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( currentAuthentication . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 112 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest [[request]] , final Pattern artifactPattern ) { final String query = [[request]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String getQueryString ( final HttpServletRequest [[bespeak]] , final Pattern artifactPattern ) { final String query = [[bespeak]] . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = artifactPattern . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 113 ---------------------------------------------
Sets the cookie. --> [[[FAILED]]]

[[[[Adv]]]]: protected void setCookie ( String [ ] [[tokens]] , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void setCookie ( String [ ] [[item]] , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String cookieValue = encodeCookie ( [[item]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 114 ---------------------------------------------
Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > [[urls]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[urls]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > [[URL]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[URL]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[URL]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 115 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 113 / 0 / 115:  12%|█▏        | 115/1000 [05:38<43:23,  2.94s/it][Succeeded / Failed / Skipped / Total] 2 / 113 / 0 / 115:  12%|█▏        | 116/1000 [05:38<43:01,  2.92s/it][Succeeded / Failed / Skipped / Total] 2 / 114 / 0 / 116:  12%|█▏        | 116/1000 [05:38<43:01,  2.92s/it][Succeeded / Failed / Skipped / Total] 2 / 114 / 0 / 116:  12%|█▏        | 117/1000 [05:39<42:41,  2.90s/it][Succeeded / Failed / Skipped / Total] 2 / 115 / 0 / 117:  12%|█▏        | 117/1000 [05:39<42:41,  2.90s/it][Succeeded / Failed / Skipped / Total] 2 / 115 / 0 / 117:  12%|█▏        | 118/1000 [05:40<42:24,  2.88s/it][Succeeded / Failed / Skipped / Total] 2 / 116 / 0 / 118:  12%|█▏        | 118/1000 [05:40<42:24,  2.88s/it][Succeeded / Failed / Skipped / Total] 2 / 116 / 0 / 118:  12%|█▏        | 119/1000 [05:41<42:07,  2.87s/it][Succeeded / Failed / Skipped / Total] 2 / 117 / 0 / 119:  12%|█▏        | 119/1000 [05:41<42:07,  2.87s/it][Succeeded / Failed / Skipped / Total] 2 / 118 / 0 / 120:  12%|█▏        | 120/1000 [05:41<41:43,  2.85s/it][Succeeded / Failed / Skipped / Total] 2 / 118 / 0 / 120:  12%|█▏        | 121/1000 [05:42<41:31,  2.83s/it]Returns the fully-qualified URL to redirect to. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String getRedirectUrl ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 116 ---------------------------------------------
Sets the context environment properties.@param environment the context environment properties --> [[[FAILED]]]

[[[[Adv]]]]: public void setContextEnvironmentProperties ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void setContextEnvironmentProperties ( Map < String , Object > [[surround]] ) { Assert . notEmpty ( [[surround]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[surround]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 117 ---------------------------------------------
End the page. --> [[[FAILED]]]

[[[[Adv]]]]: public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int doEndTag ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
Initializes the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 119 ---------------------------------------------
Resolve the security context for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange [[exchange]] ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > [[o]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[o]] : Mono . just ( adapter . fromPublisher ( [[o]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange [[central]] ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > [[oxygen]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[oxygen]] : Mono . just ( adapter . fromPublisher ( [[oxygen]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 120 ---------------------------------------------
Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[principal]] = authentication . getPrincipal ( ) ; if ( [[principal]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[principal]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object [[corpus]] = authentication . getPrincipal ( ) ; if ( [[corpus]] instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) [[corpus]] ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 121 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 119 / 0 / 121:  12%|█▏        | 121/1000 [05:42<41:31,  2.83s/it][Succeeded / Failed / Skipped / Total] 2 / 120 / 0 / 122:  12%|█▏        | 122/1000 [05:43<41:13,  2.82s/it][Succeeded / Failed / Skipped / Total] 2 / 120 / 0 / 122:  12%|█▏        | 123/1000 [05:47<41:14,  2.82s/it][Succeeded / Failed / Skipped / Total] 2 / 121 / 0 / 123:  12%|█▏        | 123/1000 [05:47<41:14,  2.82s/it][Succeeded / Failed / Skipped / Total] 2 / 122 / 0 / 124:  12%|█▏        | 124/1000 [05:48<41:01,  2.81s/it][Succeeded / Failed / Skipped / Total] 2 / 122 / 0 / 124:  12%|█▎        | 125/1000 [05:55<41:28,  2.84s/it][Succeeded / Failed / Skipped / Total] 2 / 123 / 0 / 125:  12%|█▎        | 125/1000 [05:55<41:28,  2.84s/it][Succeeded / Failed / Skipped / Total] 2 / 124 / 0 / 126:  13%|█▎        | 126/1000 [05:56<41:15,  2.83s/it][Succeeded / Failed / Skipped / Total] 2 / 124 / 0 / 126:  13%|█▎        | 127/1000 [06:01<41:25,  2.85s/it]Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Add Pkce parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 123 ---------------------------------------------
Authenticates the given authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[sanction]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 124 ---------------------------------------------
Returns true if the user is authenticated. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[authenticate]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 125 ---------------------------------------------
Logs out the given request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public void logout ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[request]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void logout ( HttpServletRequest [[petition]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[petition]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = [[petition]] . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 126 ---------------------------------------------
Retrieves a single JWK set. --> [[[FAILED]]]

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 127 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 125 / 0 / 127:  13%|█▎        | 127/1000 [06:01<41:25,  2.85s/it][Succeeded / Failed / Skipped / Total] 2 / 126 / 0 / 128:  13%|█▎        | 128/1000 [06:02<41:09,  2.83s/it][Succeeded / Failed / Skipped / Total] 2 / 126 / 0 / 128:  13%|█▎        | 129/1000 [06:04<40:59,  2.82s/it][Succeeded / Failed / Skipped / Total] 2 / 127 / 0 / 129:  13%|█▎        | 129/1000 [06:04<40:59,  2.82s/it][Succeeded / Failed / Skipped / Total] 2 / 128 / 0 / 130:  13%|█▎        | 130/1000 [06:05<40:45,  2.81s/it][Succeeded / Failed / Skipped / Total] 2 / 128 / 0 / 130:  13%|█▎        | 131/1000 [06:06<40:31,  2.80s/it][Succeeded / Failed / Skipped / Total] 2 / 129 / 0 / 131:  13%|█▎        | 131/1000 [06:06<40:31,  2.80s/it]Creates a security expression root. --> [[[FAILED]]]

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[authentication]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( [[authentication]] ) ; [[root]] . setThis ( invocation . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations createSecurityExpressionRoot ( Authentication [[certification]] , MethodInvocation invocation ) { MethodSecurityExpressionRoot [[ancestor]] = new MethodSecurityExpressionRoot ( [[certification]] ) ; [[ancestor]] . setThis ( invocation . getThis ( ) ) ; [[ancestor]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[ancestor]] . setTrustResolver ( getTrustResolver ( ) ) ; [[ancestor]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[ancestor]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[ancestor]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 128 ---------------------------------------------
Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > getWebSphereGroupsBasedGrantedAuthorities ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 129 ---------------------------------------------
URL-encode the given value. --> [[[FAILED]]]

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[appraise]] ) { try { return URLEncoder . encode ( [[appraise]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 130 ---------------------------------------------
Compare two LDAP attributes.@param dn@param attributeName@param value@return --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[compare]] ( final String dn , final String attributeName , final Object [[value]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[match]] ; } } Boolean [[matches]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[matches]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[equivalence]] ( final String dn , final String attributeName , final Object [[treasure]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[treasure]] } , ctls ) ; Boolean [[tally]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[tally]] ; } } Boolean [[equalize]] = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return [[equalize]] . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 131 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , response ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 132 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 130 / 0 / 132:  13%|█▎        | 132/1000 [06:07<40:15,  2.78s/it][Succeeded / Failed / Skipped / Total] 2 / 130 / 0 / 132:  13%|█▎        | 133/1000 [06:08<40:01,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 131 / 0 / 133:  13%|█▎        | 133/1000 [06:08<40:01,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 132 / 0 / 134:  13%|█▎        | 134/1000 [06:09<39:47,  2.76s/it][Succeeded / Failed / Skipped / Total] 2 / 132 / 0 / 134:  14%|█▎        | 135/1000 [06:10<39:36,  2.75s/it][Succeeded / Failed / Skipped / Total] 2 / 133 / 0 / 135:  14%|█▎        | 135/1000 [06:10<39:36,  2.75s/it][Succeeded / Failed / Skipped / Total] 2 / 134 / 0 / 136:  14%|█▎        | 136/1000 [06:16<39:54,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 134 / 0 / 136:  14%|█▎        | 137/1000 [06:19<39:47,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 135 / 0 / 137:  14%|█▎        | 137/1000 [06:19<39:47,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 136 / 0 / 138:  14%|█▍        | 138/1000 [06:20<39:36,  2.76s/it][Succeeded / Failed / Skipped / Total] 2 / 136 / 0 / 138:  14%|█▍        | 139/1000 [06:24<39:44,  2.77s/it]Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails loadUserByAssertion ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 133 ---------------------------------------------
Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[quest]] ) { final boolean [[solvent]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[quest]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[solvent]] ) ; } return [[solvent]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 134 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[dealer]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[dealer]] ) ; } return [[dealer]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 135 ---------------------------------------------
Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { boolean [[result]] = super . requiresAuthentication ( [[request]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest [[bespeak]] , final HttpServletResponse response ) { boolean [[consequence]] = super . requiresAuthentication ( [[bespeak]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[consequence]] ) ; } return [[consequence]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 136 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { length += [[array]] . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { System . arraycopy ( [[array]] , 0 , newArray , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[range]] ) { int length = 0 ; for ( byte [ ] [[raiment]] : [[range]] ) { length += [[raiment]] . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[raiment]] : [[range]] ) { System . arraycopy ( [[raiment]] , 0 , newArray , destPos , [[raiment]] . length ) ; destPos += [[raiment]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 137 ---------------------------------------------
Creates a subarray from an array of bytes. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[array]] , int beginIndex , int endIndex ) { int [[length]] = endIndex - beginIndex ; byte [ ] subarray = new byte [ [[length]] ] ; System . arraycopy ( [[array]] , beginIndex , subarray , 0 , [[length]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[range]] , int beginIndex , int endIndex ) { int [[duration]] = endIndex - beginIndex ; byte [ ] subarray = new byte [ [[duration]] ] ; System . arraycopy ( [[range]] , beginIndex , subarray , 0 , [[duration]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 138 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest httpRequest ) { Object [[dealer]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[dealer]] ) ; } return [[dealer]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 139 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 137 / 0 / 139:  14%|█▍        | 139/1000 [06:24<39:44,  2.77s/it][Succeeded / Failed / Skipped / Total] 2 / 138 / 0 / 140:  14%|█▍        | 140/1000 [06:25<39:26,  2.75s/it][Succeeded / Failed / Skipped / Total] 2 / 138 / 0 / 140:  14%|█▍        | 141/1000 [06:26<39:13,  2.74s/it][Succeeded / Failed / Skipped / Total] 2 / 139 / 0 / 141:  14%|█▍        | 141/1000 [06:26<39:13,  2.74s/it][Succeeded / Failed / Skipped / Total] 2 / 140 / 0 / 142:  14%|█▍        | 142/1000 [06:27<39:02,  2.73s/it][Succeeded / Failed / Skipped / Total] 2 / 140 / 0 / 142:  14%|█▍        | 143/1000 [06:28<38:48,  2.72s/it][Succeeded / Failed / Skipped / Total] 2 / 141 / 0 / 143:  14%|█▍        | 143/1000 [06:28<38:48,  2.72s/it][Succeeded / Failed / Skipped / Total] 2 / 142 / 0 / 144:  14%|█▍        | 144/1000 [06:30<38:41,  2.71s/it][Succeeded / Failed / Skipped / Total] 2 / 142 / 0 / 144:  14%|█▍        | 145/1000 [06:35<38:51,  2.73s/it]Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> [[[FAILED]]]

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > [[upshot]] = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > entry : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[upshot]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[upshot]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 140 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[c]] != null ) { gaList . addAll ( [[c]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[ascribe]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[ascribe]] ) { Collection < GrantedAuthority > [[cytosine]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[cytosine]] != null ) { gaList . addAll ( [[cytosine]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 141 ---------------------------------------------
Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[request]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[request]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[request]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[request]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[request]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String buildHttpsRedirectUrlForRequest ( HttpServletRequest [[asking]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[asking]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[asking]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[asking]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[asking]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[asking]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[asking]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 142 ---------------------------------------------
Returns a collection of authorities for the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[answer]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[answer]] , value ) ; return [[answer]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 143 ---------------------------------------------
Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[century]] > [[century]] getSharedObject ( Class < [[century]] > sharedType ) { return ( [[century]] ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 144 ---------------------------------------------
Checks if the given role starts with ROLE_. --> [[[FAILED]]]

[[[[Adv]]]]: private static String hasRole ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String hasRole ( String [[part]] ) { Assert . isTrue ( ! [[part]] . startsWith ( "ROLE_" ) , ( ) -> [[part]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[part]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 143 / 0 / 145:  14%|█▍        | 145/1000 [06:35<38:51,  2.73s/it][Succeeded / Failed / Skipped / Total] 2 / 144 / 0 / 146:  15%|█▍        | 146/1000 [06:37<38:44,  2.72s/it][Succeeded / Failed / Skipped / Total] 2 / 144 / 0 / 146:  15%|█▍        | 147/1000 [06:37<38:29,  2.71s/it][Succeeded / Failed / Skipped / Total] 2 / 145 / 0 / 147:  15%|█▍        | 147/1000 [06:37<38:29,  2.71s/it][Succeeded / Failed / Skipped / Total] 2 / 146 / 0 / 148:  15%|█▍        | 148/1000 [06:38<38:11,  2.69s/it][Succeeded / Failed / Skipped / Total] 2 / 146 / 0 / 148:  15%|█▍        | 149/1000 [06:38<37:57,  2.68s/it][Succeeded / Failed / Skipped / Total] 2 / 147 / 0 / 149:  15%|█▍        | 149/1000 [06:38<37:57,  2.68s/it][Succeeded / Failed / Skipped / Total] 2 / 148 / 0 / 150:  15%|█▌        | 150/1000 [06:38<37:40,  2.66s/it][Succeeded / Failed / Skipped / Total] 2 / 148 / 0 / 150:  15%|█▌        | 151/1000 [06:41<37:36,  2.66s/it]Adds a collection of granted authorities to the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { addGrantedAuthorityCollection ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void addGrantedAuthorityCollection ( Collection < GrantedAuthority > [[ensue]] , Object [[esteem]] ) { if ( [[esteem]] == null ) { return ; } if ( [[esteem]] instanceof Collection < ? > ) { addGrantedAuthorityCollection ( [[ensue]] , ( Collection < ? > ) [[esteem]] ) ; } else if ( [[esteem]] instanceof Object [ ] ) { addGrantedAuthorityCollection ( [[ensue]] , ( Object [ ] ) [[esteem]] ) ; } else if ( [[esteem]] instanceof String ) { addGrantedAuthorityCollection ( [[ensue]] , ( String ) [[esteem]] ) ; } else if ( [[esteem]] instanceof GrantedAuthority ) { [[ensue]] . add ( ( GrantedAuthority ) [[esteem]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[esteem]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 146 ---------------------------------------------
Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[request]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest [[petition]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[petition]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 147 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[persona]] ) { for ( int [[ane]] = 0 ; [[ane]] < [[persona]] . length ; [[ane]] ++ ) { [[persona]] [ [[ane]] ] = "ROLE_" + [[persona]] [ [[ane]] ] ; } return [[persona]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 148 ---------------------------------------------
Attempts to switch to the specified user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication attemptSwitchUser ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 149 ---------------------------------------------
Sets the URL that will be used to exit from the browser. --> [[[FAILED]]]

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void setExitUserUrl ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 150 ---------------------------------------------
Display a public index. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView displayPublicIndex ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 151 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 149 / 0 / 151:  15%|█▌        | 151/1000 [06:41<37:36,  2.66s/it][Succeeded / Failed / Skipped / Total] 2 / 150 / 0 / 152:  15%|█▌        | 152/1000 [06:41<37:22,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 150 / 0 / 152:  15%|█▌        | 153/1000 [06:42<37:10,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 151 / 0 / 153:  15%|█▌        | 153/1000 [06:42<37:10,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 152 / 0 / 154:  15%|█▌        | 154/1000 [06:46<37:11,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 152 / 0 / 154:  16%|█▌        | 155/1000 [06:47<36:59,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 153 / 0 / 155:  16%|█▌        | 155/1000 [06:47<36:59,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 154 / 0 / 156:  16%|█▌        | 156/1000 [06:47<36:43,  2.61s/it][Succeeded / Failed / Skipped / Total] 2 / 154 / 0 / 156:  16%|█▌        | 157/1000 [06:50<36:41,  2.61s/it][Succeeded / Failed / Skipped / Total] 2 / 155 / 0 / 157:  16%|█▌        | 157/1000 [06:50<36:41,  2.61s/it]Creates a spring security filter chain. --> [[[FAILED]]]

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter springSecurityFilterChain ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[transcriber]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[transcriber]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 152 ---------------------------------------------
Attempt to exit the user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication attemptExitUser ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication attemptExitUser ( HttpServletRequest [[petition]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 153 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean authorizeUsingUrlCheck ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 154 ---------------------------------------------
Converts a jwt to a list of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > convert ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Invokes the specified JoinPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 156 ---------------------------------------------
Generate a CSRF token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken generateToken ( HttpServletRequest [[petition]] ) { return wrap ( [[petition]] , this . delegate . generateToken ( [[petition]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Decodes and validates the given token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[decrypt]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 158 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 156 / 0 / 158:  16%|█▌        | 158/1000 [06:57<37:03,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 156 / 0 / 158:  16%|█▌        | 159/1000 [06:59<36:58,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 157 / 0 / 159:  16%|█▌        | 159/1000 [06:59<36:58,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 158 / 0 / 160:  16%|█▌        | 160/1000 [07:01<36:54,  2.64s/it][Succeeded / Failed / Skipped / Total] 2 / 158 / 0 / 160:  16%|█▌        | 161/1000 [07:02<36:43,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 159 / 0 / 161:  16%|█▌        | 161/1000 [07:02<36:43,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 160 / 0 / 162:  16%|█▌        | 162/1000 [07:05<36:41,  2.63s/it][Succeeded / Failed / Skipped / Total] 2 / 160 / 0 / 162:  16%|█▋        | 163/1000 [07:06<36:29,  2.62s/it]Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken [[token]] = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( [[token]] == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken [[nominal]] = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( [[nominal]] == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 159 ---------------------------------------------
Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[False]]" != "[[False]]" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean authorizeUsingAccessExpression ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[imitation]]" != "[[imitation]]" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 160 ---------------------------------------------
Creates an instance of UserDetailsResourceFactoryBean from the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 161 ---------------------------------------------
Returns the role with the given default prefix. --> [[[FAILED]]]

[[[[Adv]]]]: private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String getRoleWithDefaultPrefix ( String defaultRolePrefix , String role ) { if ( role == null ) { return role ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return role ; } if ( role . startsWith ( defaultRolePrefix ) ) { return role ; } return defaultRolePrefix + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 162 ---------------------------------------------
Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest [[request]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest [[postulation]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean [[consequence]] = authenticateAllArtifacts && obtainArtifact ( [[postulation]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[consequence]] ) ; } return [[consequence]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 163 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 161 / 0 / 163:  16%|█▋        | 163/1000 [07:06<36:29,  2.62s/it][Succeeded / Failed / Skipped / Total] 2 / 162 / 0 / 164:  16%|█▋        | 164/1000 [07:08<36:25,  2.61s/it][Succeeded / Failed / Skipped / Total] 2 / 162 / 0 / 164:  16%|█▋        | 165/1000 [07:09<36:12,  2.60s/it][Succeeded / Failed / Skipped / Total] 2 / 163 / 0 / 165:  16%|█▋        | 165/1000 [07:09<36:12,  2.60s/it][Succeeded / Failed / Skipped / Total] 2 / 164 / 0 / 166:  17%|█▋        | 166/1000 [07:10<36:02,  2.59s/it][Succeeded / Failed / Skipped / Total] 2 / 164 / 0 / 166:  17%|█▋        | 167/1000 [07:10<35:47,  2.58s/it][Succeeded / Failed / Skipped / Total] 2 / 165 / 0 / 167:  17%|█▋        | 167/1000 [07:10<35:47,  2.58s/it]Display the admin page. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[contact]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAdminPage ( @ RequestParam ( "contactId" ) int contactId ) { Contact [[touch]] = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( [[touch]] ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , [[touch]] ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 164 ---------------------------------------------
Decodes the given bytes into a string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[decipher]] ( byte [ ] bytes ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( bytes ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 165 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult [[result]] , ModelMap [[model]] ) { addPermissionValidator . validate ( addPermission , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[result]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String addPermission ( AddPermission addPermission , BindingResult [[solvent]] , ModelMap [[exemplary]] ) { addPermissionValidator . validate ( addPermission , [[solvent]] ) ; if ( [[solvent]] . hasErrors ( ) ) { [[exemplary]] . put ( "recipients" , listRecipients ( ) ) ; [[exemplary]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( addPermission . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( addPermission . getPermission ( ) ) ; try { contactManager . addPermission ( addPermission . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[solvent]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[exemplary]] . put ( "recipients" , listRecipients ( ) ) ; [[exemplary]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 166 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , addPermission ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[mould]] = new HashMap <> ( ) ; [[mould]] . put ( "addPermission" , addPermission ) ; [[mould]] . put ( "recipients" , listRecipients ( ) ) ; [[mould]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[mould]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 167 ---------------------------------------------
Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[train]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[train]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 166 / 0 / 168:  17%|█▋        | 168/1000 [07:11<35:37,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 166 / 0 / 168:  17%|█▋        | 169/1000 [07:11<35:23,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 167 / 0 / 169:  17%|█▋        | 169/1000 [07:11<35:23,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 168 / 0 / 170:  17%|█▋        | 170/1000 [07:12<35:13,  2.55s/it][Succeeded / Failed / Skipped / Total] 2 / 168 / 0 / 170:  17%|█▋        | 171/1000 [07:13<35:00,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 169 / 0 / 171:  17%|█▋        | 171/1000 [07:13<35:00,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 170 / 0 / 172:  17%|█▋        | 172/1000 [07:21<35:25,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 170 / 0 / 172:  17%|█▋        | 173/1000 [07:30<35:53,  2.60s/it][Succeeded / Failed / Skipped / Total] 2 / 171 / 0 / 173:  17%|█▋        | 173/1000 [07:30<35:53,  2.60s/it][Succeeded / Failed / Skipped / Total] 2 / 171 / 0 / 173:  17%|█▋        | 174/1000 [07:31<35:42,  2.59s/it][Succeeded / Failed / Skipped / Total] 2 / 172 / 0 / 174:  17%|█▋        | 174/1000 [07:31<35:42,  2.59s/it][Succeeded / Failed / Skipped / Total] 2 / 172 / 0 / 174:  18%|█▊        | 175/1000 [07:33<35:35,  2.59s/it][Succeeded / Failed / Skipped / Total] 2 / 173 / 0 / 175:  18%|█▊        | 175/1000 [07:33<35:35,  2.59s/it][Succeeded / Failed / Skipped / Total] 2 / 173 / 0 / 175:  18%|█▊        | 176/1000 [07:34<35:27,  2.58s/it]Adds a secure method.@param method the method@param attr the attr --> [[[FAILED]]]

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void addSecureMethod ( RegisteredMethod method , List < ConfigAttribute > attr ) { Assert . notNull ( method , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + method + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( method , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 169 ---------------------------------------------
Finds all attributes of the specified target class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 170 ---------------------------------------------
Returns a set of all the configured attributes. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { allAttributes . addAll ( attributeList ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 171 ---------------------------------------------
Checks if the method name matches the mapped name. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean isMatch ( String methodName , String mappedName ) { return ( mappedName . endsWith ( "*" ) && methodName . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && methodName . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 172 ---------------------------------------------
Handles a bind exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void handleBindException ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 173 ---------------------------------------------
Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > getAttributeValues ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > getAttributeValues ( String [[epithet]] ) { List < String > [[termination]] = null ; if ( attributes != null ) { [[termination]] = attributes . get ( [[epithet]] ) ; } if ( [[termination]] == null ) { [[termination]] = Collections . emptyList ( ) ; } return [[termination]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 174 ---------------------------------------------
Configures this request with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[True]]" == "[[True]]" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "[[avowedly]]" == "[[avowedly]]" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 175 ---------------------------------------------
Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 174 / 0 / 176:  18%|█▊        | 176/1000 [07:34<35:27,  2.58s/it][Succeeded / Failed / Skipped / Total] 2 / 174 / 0 / 176:  18%|█▊        | 177/1000 [07:34<35:15,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 175 / 0 / 177:  18%|█▊        | 177/1000 [07:34<35:15,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 175 / 0 / 177:  18%|█▊        | 178/1000 [07:36<35:06,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 176 / 0 / 178:  18%|█▊        | 178/1000 [07:36<35:06,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 176 / 0 / 178:  18%|█▊        | 179/1000 [07:38<35:04,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 177 / 0 / 179:  18%|█▊        | 179/1000 [07:38<35:04,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 177 / 0 / 179:  18%|█▊        | 180/1000 [07:42<35:04,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 178 / 0 / 180:  18%|█▊        | 180/1000 [07:42<35:04,  2.57s/it][Succeeded / Failed / Skipped / Total] 2 / 178 / 0 / 180:  18%|█▊        | 181/1000 [07:42<34:52,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 179 / 0 / 181:  18%|█▊        | 181/1000 [07:42<34:52,  2.56s/it][Succeeded / Failed / Skipped / Total] 2 / 180 / 0 / 182:  18%|█▊        | 182/1000 [07:42<34:39,  2.54s/it][Succeeded / Failed / Skipped / Total] 2 / 180 / 0 / 182:  18%|█▊        | 183/1000 [07:43<34:27,  2.53s/it]Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 177 ---------------------------------------------
Returns the first attribute value for the supplied name. --> [[[FAILED]]]

[[[[Adv]]]]: public String getFirstAttributeValue ( String [[name]] ) { List < String > [[result]] = getAttributeValues ( [[name]] ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String getFirstAttributeValue ( String [[discover]] ) { List < String > [[effect]] = getAttributeValues ( [[discover]] ) ; if ( [[effect]] . isEmpty ( ) ) { return null ; } else { return [[effect]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 178 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int secondBrace = encPass . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 179 ---------------------------------------------
Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 180 ---------------------------------------------
Checks the filter stack. --> [[[FAILED]]]

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Removes all authentication attributes from the session. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest [[asking]] ) { HttpSession session = [[asking]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 182 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> [[[FAILED]]]

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createRedirectUrl ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 181 / 0 / 183:  18%|█▊        | 183/1000 [07:43<34:27,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 182 / 0 / 184:  18%|█▊        | 184/1000 [07:43<34:14,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 182 / 0 / 184:  18%|█▊        | 185/1000 [07:48<34:25,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 183 / 0 / 185:  18%|█▊        | 185/1000 [07:48<34:25,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 184 / 0 / 186:  19%|█▊        | 186/1000 [07:49<34:15,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 184 / 0 / 186:  19%|█▊        | 187/1000 [07:50<34:07,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 185 / 0 / 187:  19%|█▊        | 187/1000 [07:50<34:07,  2.52s/it]Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] getRegisteredTypes ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 184 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 185 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 186 ---------------------------------------------
Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void setDefaultFailureUrl ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 187 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> [[[FAILED]]]

[[[[Adv]]]]: public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void setResolveHiddenInputs ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 188 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 186 / 0 / 188:  19%|█▉        | 188/1000 [07:51<33:56,  2.51s/it][Succeeded / Failed / Skipped / Total] 2 / 186 / 0 / 188:  19%|█▉        | 189/1000 [07:53<33:50,  2.50s/it][Succeeded / Failed / Skipped / Total] 2 / 187 / 0 / 189:  19%|█▉        | 189/1000 [07:53<33:50,  2.50s/it][Succeeded / Failed / Skipped / Total] 2 / 188 / 0 / 190:  19%|█▉        | 190/1000 [07:53<33:39,  2.49s/it][Succeeded / Failed / Skipped / Total] 2 / 188 / 0 / 190:  19%|█▉        | 191/1000 [07:55<33:33,  2.49s/it][Succeeded / Failed / Skipped / Total] 2 / 189 / 0 / 191:  19%|█▉        | 191/1000 [07:55<33:33,  2.49s/it][Succeeded / Failed / Skipped / Total] 2 / 190 / 0 / 192:  19%|█▉        | 192/1000 [07:59<33:37,  2.50s/it][Succeeded / Failed / Skipped / Total] 2 / 190 / 0 / 192:  19%|█▉        | 193/1000 [08:00<33:30,  2.49s/it][Succeeded / Failed / Skipped / Total] 2 / 191 / 0 / 193:  19%|█▉        | 193/1000 [08:00<33:30,  2.49s/it]Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int [[mask]] ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( [[mask]] ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , contact ) ; [[model]] . put ( "sid" , sidObject ) ; [[model]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int [[disguise]] ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( [[disguise]] ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > [[pose]] = new HashMap <> ( ) ; [[pose]] . put ( "contact" , contact ) ; [[pose]] . put ( "sid" , sidObject ) ; [[pose]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[pose]] ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 189 ---------------------------------------------
Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String buildRequestUrl ( String servletPath , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 190 ---------------------------------------------
Performs a pre-authenticated login. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[begin]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 191 ---------------------------------------------
Converts the given identifier into an object of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable identifier , ResultSet resultSet ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Extracts the cause of the supplied throwable. --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable extractCause ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 193 ---------------------------------------------
Creates a list of OpenID attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > createAttributeList ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 194 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 192 / 0 / 194:  19%|█▉        | 194/1000 [08:10<33:58,  2.53s/it][Succeeded / Failed / Skipped / Total] 2 / 192 / 0 / 194:  20%|█▉        | 195/1000 [08:11<33:49,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 193 / 0 / 195:  20%|█▉        | 195/1000 [08:11<33:49,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 193 / 0 / 195:  20%|█▉        | 196/1000 [08:13<33:45,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 194 / 0 / 196:  20%|█▉        | 196/1000 [08:13<33:45,  2.52s/it][Succeeded / Failed / Skipped / Total] 2 / 194 / 0 / 196:  20%|█▉        | 197/1000 [08:14<33:36,  2.51s/it][Succeeded / Failed / Skipped / Total] 2 / 195 / 0 / 197:  20%|█▉        | 197/1000 [08:14<33:36,  2.51s/it][Succeeded / Failed / Skipped / Total] 2 / 195 / 0 / 197:  20%|█▉        | 198/1000 [08:17<33:36,  2.51s/it][Succeeded / Failed / Skipped / Total] 2 / 196 / 0 / 198:  20%|█▉        | 198/1000 [08:17<33:36,  2.51s/it][Succeeded / Failed / Skipped / Total] 2 / 196 / 0 / 198:  20%|█▉        | 199/1000 [08:20<33:34,  2.51s/it]Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return "[[False]]" != "[[False]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String url ) { if ( url == null ) { return "[[assumed]]" != "[[assumed]]" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( url ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 195 ---------------------------------------------
Creates a new object identity. --> [[[FAILED]]]

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void createObjectIdentity ( ObjectIdentity object , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "[[admittedly]]" == "[[admittedly]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[admittedly]]" == "[[admittedly]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 196 ---------------------------------------------
Updates the object identity.@param acl the object identity --> [[[FAILED]]]

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[True]]" == "[[True]]" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl acl ) { Long parentId = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , "[[admittedly]]" == "[[admittedly]]" ) ; int count = jdbcOperations . update ( updateObjectIdentity , parentId , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a matcher that matches any exchange. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher anyExchange ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Creates the list of entries for the given acl. --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[iodine]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[iodine]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[iodine]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 199 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 196 / 0 / 199:  20%|█▉        | 199/1000 [08:20<33:34,  2.51s/it][Succeeded / Failed / Skipped / Total] 3 / 196 / 0 / 199:  20%|██        | 200/1000 [08:21<33:25,  2.51s/it][Succeeded / Failed / Skipped / Total] 3 / 197 / 0 / 200:  20%|██        | 200/1000 [08:21<33:25,  2.51s/it][Succeeded / Failed / Skipped / Total] 3 / 197 / 0 / 200:  20%|██        | 201/1000 [08:24<33:26,  2.51s/it][Succeeded / Failed / Skipped / Total] 3 / 198 / 0 / 201:  20%|██        | 201/1000 [08:24<33:26,  2.51s/it][Succeeded / Failed / Skipped / Total] 3 / 198 / 0 / 201:  20%|██        | 202/1000 [08:24<33:14,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 199 / 0 / 202:  20%|██        | 202/1000 [08:24<33:14,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 199 / 0 / 202:  20%|██        | 203/1000 [08:26<33:10,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 200 / 0 / 203:  20%|██        | 203/1000 [08:26<33:10,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 200 / 0 / 203:  20%|██        | 204/1000 [08:27<33:01,  2.49s/it][Succeeded / Failed / Skipped / Total] 3 / 201 / 0 / 204:  20%|██        | 204/1000 [08:27<33:01,  2.49s/it][Succeeded / Failed / Skipped / Total] 3 / 201 / 0 / 204:  20%|██        | 205/1000 [08:31<33:05,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 202 / 0 / 205:  20%|██        | 205/1000 [08:31<33:05,  2.50s/it][Succeeded / Failed / Skipped / Total] 3 / 202 / 0 / 205:  21%|██        | 206/1000 [08:32<32:53,  2.49s/it]Compares two byte arrays for equality. --> Checks if two byte arrays are the same length@param expected@param actual@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[check]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 200 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence [[SALT]] ) { return new HexEncodingTextEncryptor ( stronger ( password , [[SALT]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 201 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor queryableText ( CharSequence [[parole]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[parole]] . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[textbook]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Writes the headers to the response. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 204 ---------------------------------------------
Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void setTargetUrlParameter ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 205 ---------------------------------------------
Saves the current request. --> [[[FAILED]]]

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void saveRequest ( HttpServletRequest [[bespeak]] , HttpServletResponse response ) { if ( requestMatcher . matches ( [[bespeak]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[bespeak]] , portResolver ) ; if ( createSessionAllowed || [[bespeak]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 206 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 203 / 0 / 206:  21%|██        | 206/1000 [08:32<32:53,  2.49s/it][Succeeded / Failed / Skipped / Total] 3 / 203 / 0 / 206:  21%|██        | 207/1000 [08:32<32:44,  2.48s/it][Succeeded / Failed / Skipped / Total] 3 / 204 / 0 / 207:  21%|██        | 207/1000 [08:32<32:44,  2.48s/it][Succeeded / Failed / Skipped / Total] 3 / 204 / 0 / 207:  21%|██        | 208/1000 [08:33<32:33,  2.47s/it][Succeeded / Failed / Skipped / Total] 3 / 205 / 0 / 208:  21%|██        | 208/1000 [08:33<32:33,  2.47s/it][Succeeded / Failed / Skipped / Total] 3 / 205 / 0 / 208:  21%|██        | 209/1000 [08:33<32:22,  2.46s/it][Succeeded / Failed / Skipped / Total] 3 / 206 / 0 / 209:  21%|██        | 209/1000 [08:33<32:22,  2.46s/it][Succeeded / Failed / Skipped / Total] 3 / 207 / 0 / 210:  21%|██        | 210/1000 [08:33<32:11,  2.44s/it][Succeeded / Failed / Skipped / Total] 3 / 207 / 0 / 210:  21%|██        | 211/1000 [08:33<32:00,  2.43s/it][Succeeded / Failed / Skipped / Total] 3 / 208 / 0 / 211:  21%|██        | 211/1000 [08:33<32:00,  2.43s/it][Succeeded / Failed / Skipped / Total] 3 / 209 / 0 / 212:  21%|██        | 212/1000 [08:36<32:00,  2.44s/it][Succeeded / Failed / Skipped / Total] 3 / 209 / 0 / 212:  21%|██▏       | 213/1000 [08:37<31:51,  2.43s/it][Succeeded / Failed / Skipped / Total] 3 / 210 / 0 / 213:  21%|██▏       | 213/1000 [08:37<31:51,  2.43s/it]Determines the target URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 207 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> [[[FAILED]]]

[[[[Adv]]]]: public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String username ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , username ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 208 ---------------------------------------------
Creates a shared object map. --> [[[FAILED]]]

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > createSharedObjects ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 209 ---------------------------------------------
Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , method ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 210 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> [[[FAILED]]]

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory getDirectoryWithImmediateParentPopulated ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 211 ---------------------------------------------
Determines the target URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String determineTargetUrl ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return determineTargetUrl ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 212 ---------------------------------------------
Gets the current date. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String getCurrentDate ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 213 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> [[[FAILED]]]

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest [[asking]] , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[asking]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 214 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 211 / 0 / 214:  21%|██▏       | 214/1000 [08:39<31:47,  2.43s/it][Succeeded / Failed / Skipped / Total] 3 / 211 / 0 / 214:  22%|██▏       | 215/1000 [08:40<31:40,  2.42s/it][Succeeded / Failed / Skipped / Total] 3 / 212 / 0 / 215:  22%|██▏       | 215/1000 [08:40<31:40,  2.42s/it][Succeeded / Failed / Skipped / Total] 3 / 213 / 0 / 216:  22%|██▏       | 216/1000 [08:41<31:32,  2.41s/it][Succeeded / Failed / Skipped / Total] 3 / 213 / 0 / 216:  22%|██▏       | 217/1000 [08:42<31:26,  2.41s/it][Succeeded / Failed / Skipped / Total] 3 / 214 / 0 / 217:  22%|██▏       | 217/1000 [08:42<31:26,  2.41s/it][Succeeded / Failed / Skipped / Total] 3 / 215 / 0 / 218:  22%|██▏       | 218/1000 [08:47<31:30,  2.42s/it][Succeeded / Failed / Skipped / Total] 3 / 215 / 0 / 218:  22%|██▏       | 219/1000 [08:47<31:20,  2.41s/it][Succeeded / Failed / Skipped / Total] 3 / 216 / 0 / 219:  22%|██▏       | 219/1000 [08:47<31:20,  2.41s/it][Succeeded / Failed / Skipped / Total] 3 / 217 / 0 / 220:  22%|██▏       | 220/1000 [08:48<31:15,  2.40s/it][Succeeded / Failed / Skipped / Total] 3 / 217 / 0 / 220:  22%|██▏       | 221/1000 [08:49<31:08,  2.40s/it][Succeeded / Failed / Skipped / Total] 3 / 218 / 0 / 221:  22%|██▏       | 221/1000 [08:49<31:08,  2.40s/it]Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 215 ---------------------------------------------
Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : userAuthorities ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > authorityListToSet ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[localize]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[dominance]] : userAuthorities ) { [[localize]] . add ( [[dominance]] . getAuthority ( ) ) ; } return [[localize]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 216 ---------------------------------------------
Change the user's password.@param oldPassword the old password@param newPassword the new password --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 217 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName dn = new DistinguishedName ( groupSearchBase ) ; dn . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return dn ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 218 ---------------------------------------------
Throws an exception if maximum allowable sessions are exceeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[Sessions]] , int allowableSessions , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[Sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 219 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> [[[FAILED]]]

[[[[Adv]]]]: private static String getSecurityName ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String userSecurityName = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String getSecurityName ( final Subject [[matter]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[matter]] ) ; } String userSecurityName = null ; if ( [[matter]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 220 ---------------------------------------------
Retrieves the filters for the specified URL. --> [[[FAILED]]]

[[[[Adv]]]]: public List < Filter > getFilters ( String [[url]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > getFilters ( String [[URL]] ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[URL]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 221 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext getContext ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
[Succeeded / Failed / Skipped / Total] 3 / 219 / 0 / 222:  22%|██▏       | 222/1000 [08:50<31:00,  2.39s/it][Succeeded / Failed / Skipped / Total] 3 / 219 / 0 / 222:  22%|██▏       | 223/1000 [08:51<30:51,  2.38s/it][Succeeded / Failed / Skipped / Total] 3 / 220 / 0 / 223:  22%|██▏       | 223/1000 [08:51<30:51,  2.38s/it][Succeeded / Failed / Skipped / Total] 3 / 221 / 0 / 224:  22%|██▏       | 224/1000 [08:51<30:42,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 221 / 0 / 224:  22%|██▎       | 225/1000 [08:53<30:38,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 222 / 0 / 225:  22%|██▎       | 225/1000 [08:53<30:38,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 223 / 0 / 226:  23%|██▎       | 226/1000 [08:55<30:35,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 223 / 0 / 226:  23%|██▎       | 227/1000 [08:56<30:25,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 224 / 0 / 227:  23%|██▎       | 227/1000 [08:56<30:25,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 225 / 0 / 228:  23%|██▎       | 228/1000 [08:56<30:17,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 225 / 0 / 228:  23%|██▎       | 229/1000 [09:00<30:18,  2.36s/it]--------------------------------------------- Result 222 ---------------------------------------------
Updates the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object [[assess]] ) { if ( [[assess]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[assess]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 223 ---------------------------------------------
Returns the full distinguished name for the given distinguished name. --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName getFullDn ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 224 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification sessionAttrs ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 225 ---------------------------------------------
Copies details from source to dest. --> [[[FAILED]]]

[[[[Adv]]]]: private void copyDetails ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void copyDetails ( Authentication [[beginning]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( [[beginning]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 226 ---------------------------------------------
Parse a date from a string. --> [[[FAILED]]]

[[[[Adv]]]]: private static Long internalParseDate ( String [[value]] , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( [[value]] ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long internalParseDate ( String [[appraise]] , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( [[appraise]] ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 227 ---------------------------------------------
Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T [[extends]] AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[found]] = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[found]] = "True" == "True" ; paramNames [ i ] = parameterName ; } } return [[found]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T [[unfold]] AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[chance]] = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { [[chance]] = "True" == "True" ; paramNames [ i ] = parameterName ; } } return [[chance]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 228 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > getFilters ( HttpServletRequest [[bespeak]] ) { for ( SecurityFilterChain [[range]] : filterChains ) { if ( [[range]] . matches ( [[bespeak]] ) ) { return [[range]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 229 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 226 / 0 / 229:  23%|██▎       | 229/1000 [09:00<30:18,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 227 / 0 / 230:  23%|██▎       | 230/1000 [09:01<30:12,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 227 / 0 / 230:  23%|██▎       | 231/1000 [09:04<30:14,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 228 / 0 / 231:  23%|██▎       | 231/1000 [09:04<30:14,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 229 / 0 / 232:  23%|██▎       | 232/1000 [09:06<30:08,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 229 / 0 / 232:  23%|██▎       | 233/1000 [09:06<29:59,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 230 / 0 / 233:  23%|██▎       | 233/1000 [09:06<29:59,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 231 / 0 / 234:  23%|██▎       | 234/1000 [09:09<29:57,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 231 / 0 / 234:  24%|██▎       | 235/1000 [09:15<30:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 232 / 0 / 235:  24%|██▎       | 235/1000 [09:15<30:09,  2.37s/it][Succeeded / Failed / Skipped / Total] 3 / 233 / 0 / 236:  24%|██▎       | 236/1000 [09:17<30:03,  2.36s/it][Succeeded / Failed / Skipped / Total] 3 / 233 / 0 / 236:  24%|██▎       | 237/1000 [09:17<29:53,  2.35s/it]Creates a new authentication scheme for the given user name and password. --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[staple]] ( String userName , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 230 ---------------------------------------------
Creates a proxy for the specified URI. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[proxy]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[procurator]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[procurator]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 231 ---------------------------------------------
Adds additional filters to the provided filter.@param filter The filter to add.@param additionalFilters Additional filters to add. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... additionalFilters ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[strain]] ( Filter [[strain]] , Filter ... additionalFilters ) { Validate . notNull ( [[strain]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[strain]] ) ; if ( additionalFilters != null ) { Collections . addAll ( RestAssured . filters , additionalFilters ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 232 ---------------------------------------------
Add a list of filters.@param filters the list of filters --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > filters ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[filtrate]] ( List < Filter > filters ) { Validate . notNull ( [[filtrate]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filtrate]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 233 ---------------------------------------------
Configures this RestAssuredConfig with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[airt]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 234 ---------------------------------------------
Creates a basic authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme basic ( String userName , String password ) { final BasicAuthScheme [[dodge]] = new BasicAuthScheme ( ) ; [[dodge]] . setUserName ( userName ) ; [[dodge]] . setPassword ( password ) ; return [[dodge]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
Sets the default character set for the encoder. --> [[[FAILED]]]

[[[[Adv]]]]: public EncoderConfig defaultQueryParameterCharset ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig defaultQueryParameterCharset ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 236 ---------------------------------------------
Configures the default object mapper for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig defaultObjectMapperType ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 237 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 234 / 0 / 237:  24%|██▎       | 237/1000 [09:17<29:53,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 235 / 0 / 238:  24%|██▍       | 238/1000 [09:18<29:47,  2.35s/it][Succeeded / Failed / Skipped / Total] 3 / 235 / 0 / 238:  24%|██▍       | 239/1000 [09:18<29:38,  2.34s/it][Succeeded / Failed / Skipped / Total] 3 / 236 / 0 / 239:  24%|██▍       | 239/1000 [09:18<29:38,  2.34s/it][Succeeded / Failed / Skipped / Total] 3 / 237 / 0 / 240:  24%|██▍       | 240/1000 [09:19<29:30,  2.33s/it][Succeeded / Failed / Skipped / Total] 3 / 237 / 0 / 240:  24%|██▍       | 241/1000 [09:19<29:21,  2.32s/it][Succeeded / Failed / Skipped / Total] 3 / 238 / 0 / 241:  24%|██▍       | 241/1000 [09:19<29:21,  2.32s/it][Succeeded / Failed / Skipped / Total] 3 / 239 / 0 / 242:  24%|██▍       | 242/1000 [09:19<29:12,  2.31s/it][Succeeded / Failed / Skipped / Total] 3 / 239 / 0 / 242:  24%|██▍       | 243/1000 [09:19<29:03,  2.30s/it][Succeeded / Failed / Skipped / Total] 3 / 240 / 0 / 243:  24%|██▍       | 243/1000 [09:19<29:03,  2.30s/it]Creates and returns a mock RESTAssuredMockMvcConfig for the specified configuration.@param logConfig the configuration to log@return a mock RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig logConfig ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig logConfig ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 238 ---------------------------------------------
Configures this mock mvc with the specified session config.@param sessionConfig the session config@return the configured mock mvc --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig sessionConfig ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 239 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig objectMapperConfig ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 240 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String [[password]] , String workstation , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String [[watchword]] , String workstation , String domain ) { final NTLMAuthScheme [[dodge]] = new NTLMAuthScheme ( ) ; [[dodge]] . setUserName ( userName ) ; [[dodge]] . setPassword ( [[watchword]] ) ; [[dodge]] . setWorkstation ( workstation ) ; [[dodge]] . setDomain ( domain ) ; return [[dodge]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 241 ---------------------------------------------
Configures the jaas using the supplied login configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String [[key]] = prefix + n ; log . debug ( "Setting security property [" + [[key]] + "] to: " + loginConfigUrl ) ; Security . setProperty ( [[key]] , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String [[headstone]] = prefix + n ; log . debug ( "Setting security property [" + [[headstone]] + "] to: " + loginConfigUrl ) ; Security . setProperty ( [[headstone]] , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 242 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig jsonConfig ( JsonConfig jsonConfig ) { notNull ( jsonConfig , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 243 ---------------------------------------------
Configures RESTAssuredMockMvcConfig.@param xmlConfig the xml config@return the configured RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig xmlConfig ( XmlConfig xmlConfig ) { notNull ( xmlConfig , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 244 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 240 / 1 / 244:  24%|██▍       | 244/1000 [09:19<28:54,  2.29s/it][Succeeded / Failed / Skipped / Total] 3 / 240 / 1 / 244:  24%|██▍       | 245/1000 [09:20<28:45,  2.29s/it][Succeeded / Failed / Skipped / Total] 3 / 241 / 1 / 245:  24%|██▍       | 245/1000 [09:20<28:45,  2.29s/it][Succeeded / Failed / Skipped / Total] 3 / 241 / 2 / 246:  25%|██▍       | 246/1000 [09:20<28:38,  2.28s/it][Succeeded / Failed / Skipped / Total] 3 / 241 / 2 / 246:  25%|██▍       | 247/1000 [09:20<28:30,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 242 / 2 / 247:  25%|██▍       | 247/1000 [09:20<28:30,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 242 / 3 / 248:  25%|██▍       | 248/1000 [09:20<28:20,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 243 / 3 / 249:  25%|██▍       | 249/1000 [09:20<28:11,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 243 / 3 / 249:  25%|██▌       | 250/1000 [09:21<28:04,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 244 / 3 / 250:  25%|██▌       | 250/1000 [09:21<28:04,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 244 / 4 / 251:  25%|██▌       | 251/1000 [09:21<27:55,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 245 / 4 / 252:  25%|██▌       | 252/1000 [09:22<27:48,  2.23s/it][Succeeded / Failed / Skipped / Total] 3 / 245 / 4 / 252:  25%|██▌       | 253/1000 [09:22<27:40,  2.22s/it]Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 245 ---------------------------------------------
Creates a new JAXB ObjectMapperConfig instance. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "[[avowedly]]" == "[[avowedly]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 246 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object.@param headerConfig a {@link HeaderConfig} object.@return a {@link RestAssuredMockMvcConfig} object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 247 ---------------------------------------------
Configures the mock mvc config.@param mockMvcConfig the mock mvc config@return the configured mock mvc config --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 248 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 249 ---------------------------------------------
Creates and configures an instance of RestAssuredMockMvcConfig.@param asyncConfig the async configuration@return the configured instance --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig asyncConfig ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 250 ---------------------------------------------
Configures a multi part mock mvc config.@param multiPartConfig the multi part config@return the configured mock mvc config --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig multiPartConfig ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 251 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 252 ---------------------------------------------
Declares the specified namespaces. --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig declareNamespaces ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 253 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 246 / 4 / 253:  25%|██▌       | 253/1000 [09:22<27:40,  2.22s/it][Succeeded / Failed / Skipped / Total] 3 / 247 / 4 / 254:  25%|██▌       | 254/1000 [09:30<27:55,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 248 / 4 / 255:  26%|██▌       | 255/1000 [09:31<27:50,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 248 / 4 / 255:  26%|██▌       | 256/1000 [09:33<27:46,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 249 / 4 / 256:  26%|██▌       | 256/1000 [09:33<27:46,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 249 / 4 / 256:  26%|██▌       | 257/1000 [09:41<28:01,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 250 / 4 / 257:  26%|██▌       | 257/1000 [09:41<28:01,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 250 / 4 / 257:  26%|██▌       | 258/1000 [09:43<27:58,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 251 / 4 / 258:  26%|██▌       | 258/1000 [09:43<27:58,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 251 / 4 / 258:  26%|██▌       | 259/1000 [09:44<27:52,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 252 / 4 / 259:  26%|██▌       | 259/1000 [09:44<27:52,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 252 / 4 / 259:  26%|██▌       | 260/1000 [09:47<27:52,  2.26s/it]Allow all hostnames in the given configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings allowAllHostnames ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 254 ---------------------------------------------
Sets the default request headers. --> [[[FAILED]]]

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object [[key]] : headers . keySet ( ) ) { Object val = headers . get ( [[key]] ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > headers ) { this . defaultRequestHeaders . clear ( ) ; if ( headers == null ) return ; for ( Object [[discover]] : headers . keySet ( ) ) { Object val = headers . get ( [[discover]] ) ; if ( val == null ) continue ; this . defaultRequestHeaders . put ( [[discover]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 255 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[request]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[bespeak]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 256 ---------------------------------------------
Sets the proxy for the specified host and port. --> [[[FAILED]]]

[[[[Adv]]]]: public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void setProxy ( String host , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 257 ---------------------------------------------
Creates and returns a copy of this XMLPathConfig object with the specified prefix and namespace URI.@param prefix the prefix of the XMLPathConfig object@param namespaceURI the namespace URI of the XMLPathConfig object@return a copy of this XMLPathConfig object --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[[honest]]" == "[[honest]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 258 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String [[password]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[password]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setConfig ( config ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[anatomy]] ( String userName , String [[watchword]] , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( [[watchword]] == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[dodging]] = new FormAuthScheme ( ) ; [[dodging]] . setUserName ( userName ) ; [[dodging]] . setPassword ( [[watchword]] ) ; [[dodging]] . setConfig ( config ) ; return [[dodging]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 259 ---------------------------------------------
Resets the internal state. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[readjust]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 260 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 253 / 4 / 260:  26%|██▌       | 260/1000 [09:47<27:52,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 253 / 4 / 260:  26%|██▌       | 261/1000 [09:52<27:57,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 254 / 4 / 261:  26%|██▌       | 261/1000 [09:52<27:57,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 254 / 4 / 261:  26%|██▌       | 262/1000 [09:53<27:52,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 255 / 4 / 262:  26%|██▌       | 262/1000 [09:53<27:52,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 255 / 4 / 262:  26%|██▋       | 263/1000 [09:57<27:54,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 256 / 4 / 263:  26%|██▋       | 263/1000 [09:57<27:54,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 256 / 4 / 263:  26%|██▋       | 264/1000 [09:58<27:48,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 257 / 4 / 264:  26%|██▋       | 264/1000 [09:58<27:48,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 257 / 4 / 264:  26%|██▋       | 265/1000 [10:02<27:50,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 258 / 4 / 265:  26%|██▋       | 265/1000 [10:02<27:50,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 258 / 4 / 265:  27%|██▋       | 266/1000 [10:04<27:48,  2.27s/it]Prints the response.@param responseOptions the response options@param responseBody the response body@param responseDetail the response details@param logDetail the log details@param shouldPrettyPrint the should pretty print@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[publish]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 261 ---------------------------------------------
Creates a copy of the supplied headers.@param header The header to copy.@param additionalHeaders Additional headers to add.@return A copy of the supplied headers. --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... additionalHeaders ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( additionalHeaders != null ) { Collections . addAll ( headerList , additionalHeaders ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 262 ---------------------------------------------
Sets the control name.@param controlName The name of the control.@return This builder instance. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder controlName ( String controlName ) { Validate . notEmpty ( controlName , "Control name cannot be empty" ) ; this . controlName = controlName ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 263 ---------------------------------------------
Builds the response.@return the response --> [[[FAILED]]]

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[construct]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 264 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > expiryDateMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , expiryDateMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 265 ---------------------------------------------
Create a matcher that matches cookies that have a comment. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[input]] ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 259 / 4 / 266:  27%|██▋       | 266/1000 [10:04<27:48,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 259 / 4 / 266:  27%|██▋       | 267/1000 [10:06<27:46,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 260 / 4 / 267:  27%|██▋       | 267/1000 [10:06<27:46,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 260 / 4 / 267:  27%|██▋       | 268/1000 [10:07<27:39,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 261 / 4 / 268:  27%|██▋       | 268/1000 [10:07<27:39,  2.27s/it][Succeeded / Failed / Skipped / Total] 3 / 261 / 4 / 268:  27%|██▋       | 269/1000 [10:08<27:32,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 262 / 4 / 269:  27%|██▋       | 269/1000 [10:08<27:32,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 262 / 4 / 269:  27%|██▋       | 270/1000 [10:09<27:28,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 263 / 4 / 270:  27%|██▋       | 270/1000 [10:09<27:28,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 263 / 4 / 270:  27%|██▋       | 271/1000 [10:11<27:23,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 264 / 4 / 271:  27%|██▋       | 271/1000 [10:11<27:23,  2.26s/it][Succeeded / Failed / Skipped / Total] 3 / 264 / 4 / 271:  27%|██▋       | 272/1000 [10:12<27:19,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 265 / 4 / 272:  27%|██▋       | 272/1000 [10:12<27:19,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 265 / 4 / 272:  27%|██▋       | 273/1000 [10:13<27:14,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 266 / 4 / 273:  27%|██▋       | 273/1000 [10:13<27:14,  2.25s/it][Succeeded / Failed / Skipped / Total] 3 / 266 / 4 / 273:  27%|██▋       | 274/1000 [10:13<27:06,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 267 / 4 / 274:  27%|██▋       | 274/1000 [10:13<27:06,  2.24s/it][Succeeded / Failed / Skipped / Total] 3 / 267 / 4 / 274:  28%|██▊       | 275/1000 [10:13<26:58,  2.23s/it][Succeeded / Failed / Skipped / Total] 3 / 268 / 4 / 275:  28%|██▊       | 275/1000 [10:13<26:58,  2.23s/it][Succeeded / Failed / Skipped / Total] 3 / 268 / 4 / 275:  28%|██▊       | 276/1000 [10:14<26:53,  2.23s/it]Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[appreciate]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches the supplied domain matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Creates a matcher that matches a cookie path. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[course]] ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
Create a DetailedCookieMatcher that matches cookies only.@param httpOnlyMatcher The cookie only matcher.@return A DetailedCookieMatcher that matches cookies only. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher httpOnly ( Matcher < ? super Boolean > httpOnlyMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , httpOnlyMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches theprovided maximum age. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > maxAgeMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , maxAgeMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Specifies that the specified header should match the supplied expected value. --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , Matcher < String > expectedValueMatcher ) { spec . header ( headerName , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Expects the specified header to be present in the response. --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectHeader ( String headerName , String expectedValue ) { spec . header ( headerName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 273 ---------------------------------------------
Specifies the expected value for a cookie.@param cookieName the name of the cookie@param expectedValue the expected value for the cookie --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String expectedValue ) { spec . cookie ( cookieName , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 274 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > versionMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , versionMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 269 / 4 / 276:  28%|██▊       | 276/1000 [10:14<26:53,  2.23s/it][Succeeded / Failed / Skipped / Total] 3 / 270 / 4 / 277:  28%|██▊       | 277/1000 [10:15<26:45,  2.22s/it][Succeeded / Failed / Skipped / Total] 3 / 270 / 4 / 277:  28%|██▊       | 278/1000 [10:17<26:43,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 270 / 4 / 278:  28%|██▊       | 278/1000 [10:17<26:43,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 271 / 4 / 279:  28%|██▊       | 279/1000 [10:18<26:37,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 271 / 4 / 279:  28%|██▊       | 280/1000 [10:22<26:39,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 272 / 4 / 280:  28%|██▊       | 280/1000 [10:22<26:39,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 273 / 4 / 281:  28%|██▊       | 281/1000 [10:22<26:33,  2.22s/it][Succeeded / Failed / Skipped / Total] 4 / 273 / 4 / 281:  28%|██▊       | 282/1000 [10:23<26:27,  2.21s/it][Succeeded / Failed / Skipped / Total] 4 / 274 / 4 / 282:  28%|██▊       | 282/1000 [10:23<26:27,  2.21s/it][Succeeded / Failed / Skipped / Total] 4 / 275 / 4 / 283:  28%|██▊       | 283/1000 [10:23<26:19,  2.20s/it][Succeeded / Failed / Skipped / Total] 4 / 275 / 4 / 283:  28%|██▊       | 284/1000 [10:23<26:12,  2.20s/it][Succeeded / Failed / Skipped / Total] 4 / 276 / 4 / 284:  28%|██▊       | 284/1000 [10:23<26:12,  2.20s/it]Configures the JSON path with a number return type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 277 ---------------------------------------------
Returns a copy of this config with the specified parser type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig defaultParserType ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig defaultParserType ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 278 ---------------------------------------------
Sets the specified header value.@param name the header name@param value the header value@return this response builder --> Sets the headers associated with this response. --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String [[value]] ) { notNull ( [[name]] , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[describe]] , String [[appraise]] ) { notNull ( [[describe]] , "Header name" ) ; notNull ( [[appraise]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[describe]] , [[appraise]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[describe]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[appraise]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 279 ---------------------------------------------
Returns a copy of this specification with the specified host. --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 280 ---------------------------------------------
Specifies the name and value of the header associated with this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder header ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder header ( String name , String [[prise]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[prise]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 281 ---------------------------------------------
Performs basic authentication. --> [[[FAILED]]]

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 282 ---------------------------------------------
Adds an attribute to the request spec. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String attributeName , Object attributeValue ) { spec . attribute ( attributeName , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 283 ---------------------------------------------
Creates a new HTTP request based on the given URI and HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 284 ---------------------------------------------
Creates a default log configuration for this log. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream printStream ) { return new LogConfig ( printStream , "[[reliable]]" == "[[reliable]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[reliable]]" == "[[reliable]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 285 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 277 / 4 / 285:  28%|██▊       | 285/1000 [10:24<26:05,  2.19s/it][Succeeded / Failed / Skipped / Total] 4 / 277 / 4 / 285:  29%|██▊       | 286/1000 [10:24<25:59,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 278 / 4 / 286:  29%|██▊       | 286/1000 [10:24<25:59,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 279 / 4 / 287:  29%|██▊       | 287/1000 [10:24<25:51,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 279 / 4 / 287:  29%|██▉       | 288/1000 [10:26<25:48,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 280 / 4 / 288:  29%|██▉       | 288/1000 [10:26<25:48,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 281 / 4 / 289:  29%|██▉       | 289/1000 [10:28<25:45,  2.17s/it][Succeeded / Failed / Skipped / Total] 4 / 281 / 4 / 289:  29%|██▉       | 290/1000 [10:32<25:49,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 282 / 4 / 290:  29%|██▉       | 290/1000 [10:32<25:49,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 283 / 4 / 291:  29%|██▉       | 291/1000 [10:35<25:47,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 283 / 4 / 291:  29%|██▉       | 292/1000 [10:35<25:41,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 284 / 4 / 292:  29%|██▉       | 292/1000 [10:35<25:41,  2.18s/it][Succeeded / Failed / Skipped / Total] 4 / 285 / 4 / 293:  29%|██▉       | 293/1000 [10:36<25:36,  2.17s/it][Succeeded / Failed / Skipped / Total] 4 / 285 / 4 / 293:  29%|██▉       | 294/1000 [10:37<25:30,  2.17s/it][Succeeded / Failed / Skipped / Total] 4 / 286 / 4 / 294:  29%|██▉       | 294/1000 [10:37<25:30,  2.17s/it]Adds a header to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addHeader ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addHeader ( String headerName , String headerValue ) { spec . header ( headerName , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 286 ---------------------------------------------
Add result handlers.@param resultHandler the result handler@param additionalResultHandlers the additional result handlers --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addResultHandlers ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addResultHandlers ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 287 ---------------------------------------------
Adds a multi part request specification. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addMultiPart ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 288 ---------------------------------------------
Configures the default boundary for this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig defaultBoundary ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , defaultBoundary , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 289 ---------------------------------------------
Enables or disables logging of a request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig enableLoggingOfRequestAndResponseIfValidationFails ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 290 ---------------------------------------------
Retrieve an integer value from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public int getInt ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int getInt ( String [[itinerary]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Gets the value of the specified JSON path.@param < T> the type parameter@param path the path@return the value --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[tetraiodothyronine]] > [[tetraiodothyronine]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[tetraiodothyronine]] ) jsonAssertion . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 292 ---------------------------------------------
Creates and returns a new instance of the HttpClientConfig class. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[admittedly]]" == "[[admittedly]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 293 ---------------------------------------------
Retrieve a byte value from the supplied resource. --> [[[FAILED]]]

[[[[Adv]]]]: public byte getByte ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte getByte ( String [[course]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 294 ---------------------------------------------
Creates a new HTTP client configuration with the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[avowedly]]" == "[[avowedly]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 295 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 287 / 4 / 295:  30%|██▉       | 295/1000 [10:37<25:24,  2.16s/it][Succeeded / Failed / Skipped / Total] 4 / 287 / 4 / 295:  30%|██▉       | 296/1000 [10:41<25:26,  2.17s/it][Succeeded / Failed / Skipped / Total] 4 / 288 / 4 / 296:  30%|██▉       | 296/1000 [10:41<25:26,  2.17s/it][Succeeded / Failed / Skipped / Total] 4 / 289 / 4 / 297:  30%|██▉       | 297/1000 [10:42<25:20,  2.16s/it][Succeeded / Failed / Skipped / Total] 4 / 289 / 4 / 297:  30%|██▉       | 298/1000 [10:42<25:13,  2.16s/it][Succeeded / Failed / Skipped / Total] 4 / 290 / 4 / 298:  30%|██▉       | 298/1000 [10:42<25:13,  2.16s/it][Succeeded / Failed / Skipped / Total] 4 / 291 / 4 / 299:  30%|██▉       | 299/1000 [10:43<25:08,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 291 / 4 / 299:  30%|███       | 300/1000 [10:45<25:06,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 292 / 4 / 300:  30%|███       | 300/1000 [10:45<25:06,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 293 / 4 / 301:  30%|███       | 301/1000 [10:46<25:02,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 293 / 4 / 301:  30%|███       | 302/1000 [10:48<24:58,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 294 / 4 / 302:  30%|███       | 302/1000 [10:48<24:58,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 295 / 4 / 303:  30%|███       | 303/1000 [10:51<24:59,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 295 / 4 / 303:  30%|███       | 304/1000 [10:52<24:54,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 296 / 4 / 304:  30%|███       | 304/1000 [10:52<24:54,  2.15s/it]Configures this HttpClientConfig with the given HTTP MultipartMode. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig httpMultipartMode ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , httpClient , "[[unfeigned]]" == "[[unfeigned]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 296 ---------------------------------------------
Retrieve a long value. --> [[[FAILED]]]

[[[[Adv]]]]: public long getLong ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long getLong ( String [[course]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 297 ---------------------------------------------
Retrieve a Short object from the given path. --> [[[FAILED]]]

[[[[Adv]]]]: public short getShort ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short getShort ( String [[track]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 298 ---------------------------------------------
Creates a new NTLM credential. --> [[[FAILED]]]

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 299 ---------------------------------------------
Sets the value of the specified HTTP parameter.@param parameterName Name of the HTTP parameter to set.@param parameterValue Value of the HTTP parameter to set.@return Never <code>null</code>. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[honest]]" == "[[honest]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 300 ---------------------------------------------
Sets the body of the request. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder setBody ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 301 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 302 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addParam ( String parameterName , Collection < ? > parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 303 ---------------------------------------------
Retrieve a property as a double. --> [[[FAILED]]]

[[[[Adv]]]]: public double getDouble ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double getDouble ( String [[itinerary]] ) { final Object [[appraise]] = get ( [[itinerary]] ) ; if ( [[appraise]] instanceof Double ) { return ( Double ) [[appraise]] ; } return ObjectConverter . convertObjectTo ( [[appraise]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 304 ---------------------------------------------
Retrieve a property as a float. --> [[[FAILED]]]

[[[[Adv]]]]: public float getFloat ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float getFloat ( String [[way]] ) { final Object value = get ( [[way]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 305 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 297 / 4 / 305:  30%|███       | 305/1000 [10:56<24:57,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 297 / 4 / 305:  31%|███       | 306/1000 [10:57<24:50,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 298 / 4 / 306:  31%|███       | 306/1000 [10:57<24:50,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 299 / 4 / 307:  31%|███       | 307/1000 [10:58<24:46,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 299 / 4 / 307:  31%|███       | 308/1000 [11:00<24:44,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 300 / 4 / 308:  31%|███       | 308/1000 [11:00<24:44,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 301 / 4 / 309:  31%|███       | 309/1000 [11:02<24:42,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 301 / 4 / 309:  31%|███       | 310/1000 [11:05<24:42,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 302 / 4 / 310:  31%|███       | 310/1000 [11:05<24:42,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 303 / 4 / 311:  31%|███       | 311/1000 [11:06<24:37,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 303 / 4 / 311:  31%|███       | 312/1000 [11:08<24:33,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 304 / 4 / 312:  31%|███       | 312/1000 [11:08<24:33,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 305 / 4 / 313:  31%|███▏      | 313/1000 [11:12<24:36,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 305 / 4 / 313:  31%|███▏      | 314/1000 [11:13<24:30,  2.14s/it]Creates and returns a builder for a parameter update strategy. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy updateStrategy ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , updateStrategy , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[admittedly]]" == "[[admittedly]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 306 ---------------------------------------------
Creates a new Cookies instance with the specified cookies.@param cookie the cookie@param additionalCookies the additional cookies@return a new cookies instance --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[cookie]] ( Cookie cookie , Cookie ... additionalCookies ) { AssertParameter . notNull ( cookie , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( cookie ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 307 ---------------------------------------------
Gets a map from a path. --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > getMap ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 308 ---------------------------------------------
Creates a filter that logs responses that match the provided matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > matcher ) { return new ResponseLoggingFilter ( stream , matcher ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 309 ---------------------------------------------
Adds a cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder addCookie ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 310 ---------------------------------------------
Gets a list from the specified path.@param path the path@param genericType the generic type@return the list --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > getList ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T t : [[original]] ) { T [[e]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String [[course]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[archetype]] = get ( [[course]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[archetype]] != null ) { for ( T t : [[archetype]] ) { T [[Es]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 311 ---------------------------------------------
Adds all bindings to the map. --> [[[FAILED]]]

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[indicator]] ( ) { for ( Binding < ? > [[bandage]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[bandage]] . getKey ( ) . getTypeLiteral ( ) , [[bandage]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 312 ---------------------------------------------
Creates an uninitialized binding. --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 313 ---------------------------------------------
Returns the internal dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > getInternalDependencies ( BindingImpl < ? > [[attach]] ) { if ( [[attach]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[attach]] ) . getInternalDependencies ( ) ; } else if ( [[attach]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[attach]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 314 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 306 / 4 / 314:  31%|███▏      | 314/1000 [11:13<24:30,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 307 / 4 / 315:  32%|███▏      | 315/1000 [11:15<24:29,  2.15s/it][Succeeded / Failed / Skipped / Total] 4 / 307 / 4 / 315:  32%|███▏      | 316/1000 [11:15<24:22,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 308 / 4 / 316:  32%|███▏      | 316/1000 [11:15<24:22,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 309 / 4 / 317:  32%|███▏      | 317/1000 [11:17<24:19,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 309 / 4 / 317:  32%|███▏      | 318/1000 [11:19<24:16,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 310 / 4 / 318:  32%|███▏      | 318/1000 [11:19<24:16,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 311 / 4 / 319:  32%|███▏      | 319/1000 [11:19<24:10,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 311 / 4 / 319:  32%|███▏      | 320/1000 [11:20<24:05,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 312 / 4 / 320:  32%|███▏      | 320/1000 [11:20<24:05,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 313 / 4 / 321:  32%|███▏      | 321/1000 [11:20<23:59,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 313 / 4 / 321:  32%|███▏      | 322/1000 [11:21<23:54,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 314 / 4 / 322:  32%|███▏      | 322/1000 [11:21<23:54,  2.12s/it]Removes a failed JIT binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[back]] , InjectionPoint ip ) { failedJitBindings . add ( [[back]] . getKey ( ) ) ; jitBindings . remove ( [[back]] . getKey ( ) ) ; membersInjectorStore . remove ( [[back]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[back]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 315 ---------------------------------------------
Returns all the parameters in the given injectors. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 316 ---------------------------------------------
Converts a string constant binding to a binding. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > convertConstantStringBinding ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 317 ---------------------------------------------
Binds an injector. --> [[[FAILED]]]

[[[[Adv]]]]: private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void bindInjector ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 318 ---------------------------------------------
Binds a logger to the given injector. --> [[[FAILED]]]

[[[[Adv]]]]: private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void bindLogger ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 319 ---------------------------------------------
Removes all keys and sources from the backing map. --> [[[FAILED]]]

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[set]] = backingMap . get ( keyAndSource . key ) ; if ( [[set]] != null ) { [[set]] . remove ( keyAndSource . source ) ; if ( [[set]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > [[Seth]] = backingMap . get ( keyAndSource . key ) ; if ( [[Seth]] != null ) { [[Seth]] . remove ( keyAndSource . source ) ; if ( [[Seth]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 320 ---------------------------------------------
Get the provider type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > providerType ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 321 ---------------------------------------------
Initializes the delegate members. --> [[[FAILED]]]

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void initializeDelegate ( MembersInjector < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare all built-in converters. --> [[[FAILED]]]

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void prepareBuiltInConverters ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 315 / 4 / 323:  32%|███▏      | 323/1000 [11:21<23:49,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 315 / 4 / 323:  32%|███▏      | 324/1000 [11:22<23:44,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 316 / 4 / 324:  32%|███▏      | 324/1000 [11:22<23:44,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 317 / 4 / 325:  32%|███▎      | 325/1000 [11:31<23:56,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 317 / 4 / 325:  33%|███▎      | 326/1000 [11:32<23:51,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 318 / 4 / 326:  33%|███▎      | 326/1000 [11:32<23:51,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 319 / 4 / 327:  33%|███▎      | 327/1000 [11:34<23:48,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 319 / 4 / 327:  33%|███▎      | 328/1000 [11:35<23:45,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 320 / 4 / 328:  33%|███▎      | 328/1000 [11:35<23:45,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 321 / 4 / 329:  33%|███▎      | 329/1000 [11:38<23:44,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 321 / 4 / 329:  33%|███▎      | 330/1000 [11:38<23:38,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 322 / 4 / 330:  33%|███▎      | 330/1000 [11:38<23:38,  2.12s/it]Retrieves an object from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[tetraiodothyronine]] > [[tetraiodothyronine]] getObject ( String path , Class < [[tetraiodothyronine]] > objectType ) { Object [[objective]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[objective]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 324 ---------------------------------------------
Canonicalizes the given class loader. --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 325 ---------------------------------------------
Converts a TypeLiteral into a canonical type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type type = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 326 ---------------------------------------------
Checks for misplaced binding annotations. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean checkForMisplacedBindingAnnotations ( Member member , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 327 ---------------------------------------------
Injects the given instance into the given injector.@param injector the injector@param instance the instance@param binding the binding@param source the source@param injectionPoints the injection points --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 328 ---------------------------------------------
Resolve all of the given types. --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { [[result]] [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[type]] ) { TypeLiteral < ? > [ ] [[lead]] = new TypeLiteral < ? > [ [[type]] . length ] ; for ( int t = 0 ; t < [[type]] . length ; t ++ ) { [[lead]] [ t ] = resolve ( [[type]] [ t ] ) ; } return ImmutableList . copyOf ( [[lead]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 329 ---------------------------------------------
Checks if the given class loader has the same version of the current one. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean hasSameVersionOfCglib ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "[[pretended]]" != "[[pretended]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 330 ---------------------------------------------
Checks if two methods are overrides of each other. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[overthrow]] ( Method a , Method [[Bel]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 331 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 323 / 4 / 331:  33%|███▎      | 331/1000 [11:39<23:33,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 323 / 4 / 331:  33%|███▎      | 332/1000 [11:43<23:35,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 324 / 4 / 332:  33%|███▎      | 332/1000 [11:43<23:35,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 325 / 4 / 333:  33%|███▎      | 333/1000 [11:45<23:32,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 325 / 4 / 333:  33%|███▎      | 334/1000 [11:47<23:30,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 326 / 4 / 334:  33%|███▎      | 334/1000 [11:47<23:30,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 327 / 4 / 335:  34%|███▎      | 335/1000 [11:47<23:24,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 327 / 4 / 335:  34%|███▎      | 336/1000 [11:51<23:26,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 328 / 4 / 336:  34%|███▎      | 336/1000 [11:51<23:26,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 329 / 4 / 337:  34%|███▎      | 337/1000 [11:52<23:22,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 329 / 4 / 337:  34%|███▍      | 338/1000 [11:53<23:17,  2.11s/it]Dispatches a servlet request to the dispatcher. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 332 ---------------------------------------------
Converts the specified key into an appropriate annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[primal]] ) { return [[primal]] . getAnnotation ( ) == null ? [[primal]] : Key . get ( [[primal]] . getTypeLiteral ( ) , [[primal]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 333 ---------------------------------------------
Creates an injectable scope. --> [[[FAILED]]]

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping makeInjectable ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 334 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 335 ---------------------------------------------
Validates that the injections are valid. --> [[[FAILED]]]

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[acknowledgment]] : pendingInjections ) { try { [[acknowledgment]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 336 ---------------------------------------------
Normalizes a path. --> [[[FAILED]]]

[[[[Adv]]]]: static String normalizePath ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String [[query]] = null ; if ( queryStart != - 1 ) { [[query]] = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String normalizePath ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String [[enquiry]] = null ; if ( queryStart != - 1 ) { [[enquiry]] = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Cleans up the dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[cleansing]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 338 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 330 / 4 / 338:  34%|███▍      | 338/1000 [11:53<23:17,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 331 / 4 / 339:  34%|███▍      | 339/1000 [11:56<23:16,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 331 / 4 / 339:  34%|███▍      | 340/1000 [11:57<23:12,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 332 / 4 / 340:  34%|███▍      | 340/1000 [11:57<23:12,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 333 / 4 / 341:  34%|███▍      | 341/1000 [11:58<23:07,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 333 / 4 / 341:  34%|███▍      | 342/1000 [11:58<23:02,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 334 / 4 / 342:  34%|███▍      | 342/1000 [11:58<23:02,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 335 / 4 / 343:  34%|███▍      | 343/1000 [12:05<23:10,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 335 / 4 / 343:  34%|███▍      | 344/1000 [12:06<23:06,  2.11s/it]Returns true if the given annotation is retained at runtime. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean isRetainedAtRuntime ( Class < ? extends Annotation > annotationType ) { Retention retention = annotationType . getAnnotation ( Retention . class ) ; return retention != null && retention . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider. --> [[[FAILED]]]

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void initializeDelegate ( Provider < T > delegate ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Adds the direct type binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void addDirectTypeBinding ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void addDirectTypeBinding ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 341 ---------------------------------------------
Generates an annotation for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[expand]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 342 ---------------------------------------------
Returns true if the given member is public, false otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] parameterTypes ; if ( [[member]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[appendage]] ) { if ( ! Modifier . isPublic ( [[appendage]] . getModifiers ( ) ) ) { return "[[delusive]]" != "[[delusive]]" ; } Class < ? > [ ] parameterTypes ; if ( [[appendage]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[appendage]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[appendage]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[delusive]]" != "[[delusive]]" ; } parameterTypes = method . getParameterTypes ( ) ; } for ( Class < ? > type : parameterTypes ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[delusive]]" != "[[delusive]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 343 ---------------------------------------------
Returns the name of the given key. --> [[[FAILED]]]

[[[[Adv]]]]: public static String nameOf ( Key < ? > [[key]] ) { Annotation annotation = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String nameOf ( Key < ? > [[primal]] ) { Annotation annotation = [[primal]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[primal]] . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return [[primal]] . getAnnotation ( ) . toString ( ) ; } else if ( [[primal]] . getAnnotationType ( ) != null ) { return "@" + [[primal]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 344 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 336 / 4 / 344:  34%|███▍      | 344/1000 [12:06<23:06,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 337 / 4 / 345:  34%|███▍      | 345/1000 [12:19<23:23,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 337 / 4 / 345:  35%|███▍      | 346/1000 [12:21<23:21,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 338 / 4 / 346:  35%|███▍      | 346/1000 [12:21<23:21,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 338 / 4 / 346:  35%|███▍      | 347/1000 [12:22<23:18,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 339 / 4 / 347:  35%|███▍      | 347/1000 [12:22<23:18,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 339 / 4 / 347:  35%|███▍      | 348/1000 [12:24<23:14,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 340 / 4 / 348:  35%|███▍      | 348/1000 [12:24<23:14,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 340 / 4 / 348:  35%|███▍      | 349/1000 [12:24<23:09,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 341 / 4 / 349:  35%|███▍      | 349/1000 [12:24<23:09,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 341 / 4 / 349:  35%|███▌      | 350/1000 [12:25<23:04,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 342 / 4 / 350:  35%|███▌      | 350/1000 [12:25<23:04,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 342 / 4 / 350:  35%|███▌      | 351/1000 [12:29<23:05,  2.14s/it]Returns the key for a new value. --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 345 ---------------------------------------------
Create a new RealMapBinder. --> [[[FAILED]]]

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > newRealMapBinder ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return newRealMapBinder ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 346 ---------------------------------------------
Creates a factory for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[creator]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[creator]] ; } Scope [[scope]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[orbit]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[Almighty]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[Almighty]] ; } Scope [[orbit]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 347 ---------------------------------------------
Returns the module for the given module. --> [[[FAILED]]]

[[[[Adv]]]]: static Module forModule ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module forModule ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 348 ---------------------------------------------
Returns a collection of all methods of this class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > getAssistedMethods ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 349 ---------------------------------------------
Checks if the interceptor class has a scope annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean hasScope ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 350 ---------------------------------------------
Writes a message to the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < sourcesAsStrings . length ; [[i]] ++ ) { sourcesAsStrings [ [[i]] ] = Errors . convert ( sourcesAsStrings [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[I]] = 0 ; [[I]] < sourcesAsStrings . length ; [[I]] ++ ) { sourcesAsStrings [ [[I]] ] = Errors . convert ( sourcesAsStrings [ [[I]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 351 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 343 / 4 / 351:  35%|███▌      | 351/1000 [12:29<23:05,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 343 / 4 / 351:  35%|███▌      | 352/1000 [12:31<23:03,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 344 / 4 / 352:  35%|███▌      | 352/1000 [12:31<23:03,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 344 / 4 / 352:  35%|███▌      | 353/1000 [12:31<22:57,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 345 / 4 / 353:  35%|███▌      | 353/1000 [12:31<22:57,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 345 / 4 / 353:  35%|███▌      | 354/1000 [12:34<22:56,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 346 / 4 / 354:  35%|███▌      | 354/1000 [12:34<22:56,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 346 / 4 / 354:  36%|███▌      | 355/1000 [12:39<23:00,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 347 / 4 / 355:  36%|███▌      | 355/1000 [12:39<23:00,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 347 / 4 / 355:  36%|███▌      | 356/1000 [12:42<22:58,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 348 / 4 / 356:  36%|███▌      | 356/1000 [12:42<22:58,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 348 / 4 / 356:  36%|███▌      | 357/1000 [12:42<22:53,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 349 / 4 / 357:  36%|███▌      | 357/1000 [12:42<22:53,  2.14s/it][Succeeded / Failed / Skipped / Total] 4 / 349 / 4 / 357:  36%|███▌      | 358/1000 [12:44<22:50,  2.13s/it]Returns the set of dependencies for the given injection point. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 352 ---------------------------------------------
Removes the given set of dependencies from the given set. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 353 ---------------------------------------------
Creates a new instance of the proxy for the given context. --> [[[FAILED]]]

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[supply]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[thyroxine]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[thyroxine]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[thyroxine]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 354 ---------------------------------------------
Create a binding from a new injector. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 355 ---------------------------------------------
Finds the scope annotation for the given annotations. --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation annotation : [[annotations]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] [[annotation]] ) { Class < ? extends Annotation > [[chance]] = null ; for ( Annotation annotation : [[annotation]] ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[chance]] != null ) { errors . duplicateScopeAnnotations ( [[chance]] , annotationType ) ; } else { [[chance]] = annotationType ; } } } return [[chance]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 356 ---------------------------------------------
Creates an error message for the given key. --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
Returns the key for the specified type and member. --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[found]] = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[found]] == null ? Key . get ( type ) : Key . get ( type , [[found]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > getKey ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[ascertain]] = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[ascertain]] == null ? Key . get ( type ) : Key . get ( type , [[ascertain]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 350 / 4 / 358:  36%|███▌      | 358/1000 [12:44<22:50,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 351 / 4 / 359:  36%|███▌      | 359/1000 [12:44<22:44,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 351 / 4 / 359:  36%|███▌      | 360/1000 [12:44<22:39,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 352 / 4 / 360:  36%|███▌      | 360/1000 [12:44<22:39,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 353 / 4 / 361:  36%|███▌      | 361/1000 [12:45<22:34,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 353 / 4 / 361:  36%|███▌      | 362/1000 [12:45<22:29,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 354 / 4 / 362:  36%|███▌      | 362/1000 [12:45<22:29,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 355 / 4 / 363:  36%|███▋      | 363/1000 [12:46<22:25,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 355 / 4 / 363:  36%|███▋      | 364/1000 [12:48<22:23,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 356 / 4 / 364:  36%|███▋      | 364/1000 [12:48<22:23,  2.11s/it]Invokes the specified method on the specified object. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[stir]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 359 ---------------------------------------------
Checks if the given set of dependencies is valid for the given factory type. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > [[dependencies]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > [[addiction]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 360 ---------------------------------------------
Checks if the given constructor has all the required parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 361 ---------------------------------------------
Gets the internal constructor. --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the given constructor has at least one annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean hasAtInject ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Returns the set of internal dependencies for the given factory. --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > getInternalDependencies ( ) { ImmutableSet . Builder < InjectionPoint > [[constructor]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[constructor]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 364 ---------------------------------------------
Returns the annotation for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 365 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 357 / 4 / 365:  36%|███▋      | 365/1000 [12:49<22:18,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 357 / 4 / 365:  37%|███▋      | 366/1000 [12:50<22:14,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 358 / 4 / 366:  37%|███▋      | 366/1000 [12:50<22:14,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 359 / 4 / 367:  37%|███▋      | 367/1000 [12:50<22:09,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 359 / 4 / 367:  37%|███▋      | 368/1000 [12:51<22:05,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 360 / 4 / 368:  37%|███▋      | 368/1000 [12:51<22:05,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 361 / 4 / 369:  37%|███▋      | 369/1000 [12:51<21:59,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 361 / 4 / 369:  37%|███▋      | 370/1000 [12:53<21:57,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 362 / 4 / 370:  37%|███▋      | 370/1000 [12:53<21:57,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 363 / 4 / 371:  37%|███▋      | 371/1000 [12:54<21:53,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 363 / 4 / 371:  37%|███▋      | 372/1000 [12:57<21:51,  2.09s/it]Find the next filter. --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 366 ---------------------------------------------
Returns the line number for the given member. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer getLineNumber ( Member member ) { Preconditions . checkArgument ( type == member . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , member , member . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( member ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 367 ---------------------------------------------
Wraps a callable with a request seed map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , continueRequest ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 368 ---------------------------------------------
Initializes the lookups. --> [[[FAILED]]]

[[[[Adv]]]]: void [[initialize]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[format]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 369 ---------------------------------------------
Wraps a callable with a transfer request. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > callable ) { return wrap ( callable , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > transferRequest ( Callable < T > callable ) { return wrap ( callable , transferRequest ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 370 ---------------------------------------------
Gets the injectors for the given injection points. --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injector]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[injector]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 371 ---------------------------------------------
Checks if the given type literal is not specified in the configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException [[ce]] ) { Collection < Message > messages = [[ce]] . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean isTypeNotSpecified ( TypeLiteral < ? > typeLiteral , ConfigurationException [[cerium]] ) { Collection < Message > messages = [[cerium]] . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 372 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 364 / 4 / 372:  37%|███▋      | 372/1000 [12:57<21:51,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 365 / 4 / 373:  37%|███▋      | 373/1000 [12:58<21:47,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 365 / 4 / 373:  37%|███▋      | 374/1000 [13:05<21:54,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 366 / 4 / 374:  37%|███▋      | 374/1000 [13:05<21:54,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 367 / 4 / 375:  38%|███▊      | 375/1000 [13:06<21:50,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 367 / 4 / 375:  38%|███▊      | 376/1000 [13:06<21:44,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 368 / 4 / 376:  38%|███▊      | 376/1000 [13:06<21:44,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 369 / 4 / 377:  38%|███▊      | 377/1000 [13:09<21:43,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 369 / 4 / 377:  38%|███▊      | 378/1000 [13:09<21:38,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 370 / 4 / 378:  38%|███▊      | 378/1000 [13:09<21:38,  2.09s/it]Returns an annotation strategy for the given annotation. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation annotation ) { checkNotNull ( annotation , "annotation" ) ; Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , annotation ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( annotation ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 373 ---------------------------------------------
Returns an annotation strategy for the given annotation type. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return strategyFor ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 374 ---------------------------------------------
Returns a module for the given module annotated method. --> [[[FAILED]]]

[[[[Adv]]]]: public static Module forModule ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module forModule ( Object [[faculty]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[faculty]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 375 ---------------------------------------------
Gets the source of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String getBindingSource ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 376 ---------------------------------------------
Returns a ConstructorInjector for the given InjectionPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint constructorInjector , Errors [[errors]] ) throws ErrorsException { return cache . get ( constructorInjector , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[beget]] ( InjectionPoint constructorInjector , Errors [[erroneousness]] ) throws ErrorsException { return cache . get ( constructorInjector , [[erroneousness]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 377 ---------------------------------------------
Prune the stacktrace from the exception. --> [[[FAILED]]]

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[t]] . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } [[t]] . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable [[MT]] = throwable ; [[MT]] != null ; [[MT]] = [[MT]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[MT]] . getStackTrace ( ) ; List < StackTraceElement > [[clip]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[clip]] . add ( element ) ; } } [[MT]] . setStackTrace ( [[clip]] . toArray ( new StackTraceElement [ [[clip]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 378 ---------------------------------------------
Create a new set-binder for the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > [[key]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[key]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder binder , Key < T > [[cardinal]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[cardinal]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 379 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 371 / 4 / 379:  38%|███▊      | 379/1000 [13:11<21:36,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 371 / 4 / 379:  38%|███▊      | 380/1000 [13:18<21:43,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 372 / 4 / 380:  38%|███▊      | 380/1000 [13:18<21:43,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 373 / 4 / 381:  38%|███▊      | 381/1000 [13:19<21:39,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 373 / 4 / 381:  38%|███▊      | 382/1000 [13:19<21:34,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 374 / 4 / 382:  38%|███▊      | 382/1000 [13:19<21:34,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 375 / 4 / 383:  38%|███▊      | 383/1000 [13:21<21:31,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 375 / 4 / 383:  38%|███▊      | 384/1000 [13:26<21:33,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 376 / 4 / 384:  38%|███▊      | 384/1000 [13:26<21:33,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 377 / 4 / 385:  38%|███▊      | 385/1000 [13:33<21:39,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 377 / 4 / 385:  39%|███▊      | 386/1000 [13:37<21:40,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 378 / 4 / 386:  39%|███▊      | 386/1000 [13:37<21:40,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 378 / 4 / 386:  39%|███▊      | 387/1000 [13:39<21:38,  2.12s/it]Validates that the supplied object is compatible with the supplied key. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > [[key]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[key]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[key]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object validateAndCanonicalizeValue ( Key < ? > [[keystone]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[keystone]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[keystone]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 380 ---------------------------------------------
Creates a message with the specified format and arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String messageFormat , Object ... [[arguments]] ) { return [[create]] ( null , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[produce]] ( String messageFormat , Object ... [[disceptation]] ) { return [[produce]] ( null , messageFormat , [[disceptation]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 381 ---------------------------------------------
Checks if the given class should be skipped. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean shouldBeSkipped ( String className ) { return ( parent != null && parent . shouldBeSkipped ( className ) ) || classNamesToSkip . contains ( className ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 382 ---------------------------------------------
Converts an object to an object. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[convert]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[convince]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[convince]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 383 ---------------------------------------------
Returns the source of the specified module class names. --> [[[FAILED]]]

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object getFromClassNames ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 384 ---------------------------------------------
Starts the remote JMX server. --> [[[FAILED]]]

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[module]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void main ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[faculty]] = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[faculty]] ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 385 ---------------------------------------------
Creates a message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[produce]] ( Throwable [[effort]] , String messageFormat , Object ... arguments ) { return [[produce]] ( [[effort]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 386 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > of ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 379 / 4 / 387:  39%|███▊      | 387/1000 [13:39<21:38,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 379 / 4 / 387:  39%|███▉      | 388/1000 [13:45<21:41,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 380 / 4 / 388:  39%|███▉      | 388/1000 [13:45<21:41,  2.13s/it][Succeeded / Failed / Skipped / Total] 4 / 380 / 4 / 388:  39%|███▉      | 389/1000 [13:45<21:36,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 381 / 4 / 389:  39%|███▉      | 389/1000 [13:45<21:36,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 381 / 4 / 389:  39%|███▉      | 390/1000 [13:47<21:34,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 382 / 4 / 390:  39%|███▉      | 390/1000 [13:47<21:34,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 382 / 4 / 390:  39%|███▉      | 391/1000 [13:47<21:29,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 382 / 5 / 391:  39%|███▉      | 391/1000 [13:47<21:29,  2.12s/it][Succeeded / Failed / Skipped / Total] 4 / 382 / 5 / 391:  39%|███▉      | 392/1000 [13:48<21:25,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 383 / 5 / 392:  39%|███▉      | 392/1000 [13:48<21:25,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 383 / 5 / 392:  39%|███▉      | 393/1000 [13:49<21:21,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 384 / 5 / 393:  39%|███▉      | 393/1000 [13:49<21:21,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 384 / 5 / 393:  39%|███▉      | 394/1000 [13:50<21:17,  2.11s/it]Creates a new instance of MembersInjectorImpl. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 388 ---------------------------------------------
Pushes a state onto the cache. --> [[[FAILED]]]

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[paint]] , Object source ) { doPushState ( [[paint]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Returns a new instance of the given annotation strategy. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[type]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[fetch]] ( Class < T > [[typewrite]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[typewrite]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 390 ---------------------------------------------
Pushes the specified dependency onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object [[source]] ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , [[source]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object [[root]] ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , [[root]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 391 ---------------------------------------------
Rethrows an unchecked exception. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
Called when a connection event occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public void onEvent ( ConnectionEventType [[type]] , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType [[typecast]] , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[typecast]] ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 393 ---------------------------------------------
Registers a processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 394 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 385 / 5 / 394:  39%|███▉      | 394/1000 [13:50<21:17,  2.11s/it][Succeeded / Failed / Skipped / Total] 4 / 385 / 5 / 394:  40%|███▉      | 395/1000 [13:51<21:12,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 385 / 6 / 395:  40%|███▉      | 395/1000 [13:51<21:12,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 385 / 6 / 395:  40%|███▉      | 396/1000 [13:52<21:09,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 386 / 6 / 396:  40%|███▉      | 396/1000 [13:52<21:09,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 386 / 6 / 396:  40%|███▉      | 397/1000 [13:55<21:08,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 387 / 6 / 397:  40%|███▉      | 397/1000 [13:55<21:08,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 387 / 6 / 397:  40%|███▉      | 398/1000 [13:55<21:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 388 / 6 / 398:  40%|███▉      | 398/1000 [13:55<21:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 388 / 6 / 398:  40%|███▉      | 399/1000 [13:56<20:59,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 389 / 6 / 399:  40%|███▉      | 399/1000 [13:56<20:59,  2.10s/it][Succeeded / Failed / Skipped / Total] 4 / 389 / 6 / 399:  40%|████      | 400/1000 [13:57<20:56,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 390 / 6 / 400:  40%|████      | 400/1000 [13:57<20:56,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 390 / 6 / 400:  40%|████      | 401/1000 [13:58<20:52,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 391 / 6 / 401:  40%|████      | 401/1000 [13:58<20:52,  2.09s/it][Succeeded / Failed / Skipped / Total] 4 / 391 / 6 / 401:  40%|████      | 402/1000 [13:58<20:47,  2.09s/it][Succeeded / Failed / Skipped / Total] 5 / 391 / 6 / 402:  40%|████      | 402/1000 [13:58<20:47,  2.09s/it][Succeeded / Failed / Skipped / Total] 5 / 391 / 6 / 402:  40%|████      | 403/1000 [14:01<20:47,  2.09s/it]Registers a default processor. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 395 ---------------------------------------------
Returns the Url for the given URL. --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
Returns the processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode cmdCode ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( cmdCode ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 397 ---------------------------------------------
Adds a new connection event processor.@param type the event type@param processor the event processor --> [[[FAILED]]]

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType [[type]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . [[processors]] . get ( [[type]] ) ; if ( processorList == null ) { this . [[processors]] . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[processors]] . get ( [[type]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void addConnectionEventProcessor ( ConnectionEventType [[typewrite]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . [[mainframe]] . get ( [[typewrite]] ) ; if ( processorList == null ) { this . [[mainframe]] . putIfAbsent ( [[typewrite]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[mainframe]] . get ( [[typewrite]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 398 ---------------------------------------------
Decodes a protocol code. --> [[[FAILED]]]

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 399 ---------------------------------------------
Creates a new message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable [[cause]] , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable [[crusade]] , List < Object > sources , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( sources , message , [[crusade]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 400 ---------------------------------------------
Create a connection and heal if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void createConnectionAndHealIfNeed ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 401 ---------------------------------------------
Get and create a connection if it doesn't exist. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection getAndCreateIfAbsent ( Url [[URL]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 402 ---------------------------------------------
Scans the connection pool. --> Rake a pool. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[rake]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 403 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 392 / 6 / 403:  40%|████      | 403/1000 [14:01<20:47,  2.09s/it][Succeeded / Failed / Skipped / Total] 5 / 392 / 6 / 403:  40%|████      | 404/1000 [14:02<20:42,  2.09s/it][Succeeded / Failed / Skipped / Total] 5 / 392 / 7 / 404:  40%|████      | 404/1000 [14:02<20:42,  2.09s/it][Succeeded / Failed / Skipped / Total] 5 / 392 / 7 / 404:  40%|████      | 405/1000 [14:02<20:38,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 393 / 7 / 405:  40%|████      | 405/1000 [14:02<20:38,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 393 / 7 / 405:  41%|████      | 406/1000 [14:02<20:33,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 394 / 7 / 406:  41%|████      | 406/1000 [14:02<20:33,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 394 / 7 / 406:  41%|████      | 407/1000 [14:06<20:33,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 395 / 7 / 407:  41%|████      | 407/1000 [14:06<20:33,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 395 / 7 / 407:  41%|████      | 408/1000 [14:07<20:29,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 396 / 7 / 408:  41%|████      | 408/1000 [14:07<20:29,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 397 / 7 / 409:  41%|████      | 409/1000 [14:07<20:24,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 397 / 7 / 409:  41%|████      | 410/1000 [14:08<20:21,  2.07s/it]Gets the future task result.@param < T> the type parameter@param task the task@param logger the logger@return the future task result --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[tetraiodothyronine]] > [[tetraiodothyronine]] getFutureTaskResult ( RunStateRecordedFutureTask < [[tetraiodothyronine]] > task , Logger logger ) { [[tetraiodothyronine]] [[MT]] = null ; if ( null != task ) { try { [[MT]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[MT]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 404 ---------------------------------------------
Closes the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
E heal if needed --> [[[FAILED]]]

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void healIfNeed ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 406 ---------------------------------------------
Removes a task from the pool. --> [[[FAILED]]]

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 407 ---------------------------------------------
Creates a new instance of the given provider. --> [[[FAILED]]]

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[t]] = provider . get ( ) ; if ( [[t]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T provision ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T [[liothyronine]] = provider . get ( ) ; if ( [[liothyronine]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( [[liothyronine]] ) ; return [[liothyronine]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 408 ---------------------------------------------
Gets all connections.@param <String> the type parameter@param <List<Connection>> the type parameter@return the all connections --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entry]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[entry]] . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( [[entry]] . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entryway]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[entryway]] . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( [[entryway]] . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 409 ---------------------------------------------
Called when a connection is closed. --> [[[FAILED]]]

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 410 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 398 / 7 / 410:  41%|████      | 410/1000 [14:08<20:21,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 399 / 7 / 411:  41%|████      | 411/1000 [14:11<20:19,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 399 / 7 / 411:  41%|████      | 412/1000 [14:12<20:16,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 400 / 7 / 412:  41%|████      | 412/1000 [14:12<20:16,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 401 / 7 / 413:  41%|████▏     | 413/1000 [14:13<20:13,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 401 / 7 / 413:  41%|████▏     | 414/1000 [14:14<20:09,  2.06s/it]Registers a user processor.@param processor The user processor.@param userProcessors The user processors. --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void registerUserProcessor ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { registerUserProcessor ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 411 ---------------------------------------------
Dispatches the command to the user processor. --> [[[FAILED]]]

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 412 ---------------------------------------------
Pre-processes a request command. --> [[[FAILED]]]

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 413 ---------------------------------------------
Formats the given collection of messages into a human readable string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String formatMessages ( String [[heading]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[heading]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object source = dependencies . get ( [[i]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String [[guide]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[guide]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[unity]] = dependencies . size ( ) - 1 ; [[unity]] >= 0 ; [[unity]] -- ) { Object source = dependencies . get ( [[unity]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 414 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 402 / 7 / 414:  41%|████▏     | 414/1000 [14:14<20:09,  2.06s/it][Succeeded / Failed / Skipped / Total] 5 / 403 / 7 / 415:  42%|████▏     | 415/1000 [14:16<20:07,  2.06s/it][Succeeded / Failed / Skipped / Total] 5 / 403 / 7 / 415:  42%|████▏     | 416/1000 [14:23<20:12,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 404 / 7 / 416:  42%|████▏     | 416/1000 [14:23<20:12,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 405 / 7 / 417:  42%|████▏     | 417/1000 [14:25<20:10,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 405 / 7 / 417:  42%|████▏     | 418/1000 [14:26<20:07,  2.07s/it]Debug logging. --> [[[FAILED]]]

[[[[Adv]]]]: private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void debugLog ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 415 ---------------------------------------------
Registers a user processor with the rpc server. --> [[[FAILED]]]

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[interest]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[interest]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[interest]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String [[stake]] : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( [[stake]] , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[stake]] + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 416 ---------------------------------------------
Sends a request timeout command to the server. --> [[[FAILED]]]

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[channel]] = channelCtx . channel ( ) ; if ( null != [[channel]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[channel]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand cmd , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[canalise]] = channelCtx . channel ( ) ; if ( null != [[canalise]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[canalise]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 417 ---------------------------------------------
Closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[near]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 406 / 7 / 418:  42%|████▏     | 418/1000 [14:26<20:07,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 407 / 7 / 419:  42%|████▏     | 419/1000 [14:31<20:08,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 407 / 7 / 419:  42%|████▏     | 420/1000 [14:32<20:04,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 408 / 7 / 420:  42%|████▏     | 420/1000 [14:32<20:04,  2.08s/it][Succeeded / Failed / Skipped / Total] 5 / 408 / 8 / 421:  42%|████▏     | 421/1000 [14:32<19:59,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 408 / 8 / 421:  42%|████▏     | 422/1000 [14:33<19:57,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 409 / 8 / 422:  42%|████▏     | 422/1000 [14:33<19:57,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 410 / 8 / 423:  42%|████▏     | 423/1000 [14:34<19:52,  2.07s/it][Succeeded / Failed / Skipped / Total] 5 / 410 / 8 / 423:  42%|████▏     | 424/1000 [14:42<19:58,  2.08s/it]Create a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param syncCreateNumWhenNotWarmup the sync create number when not warmup@throws RemotingException --> [[[FAILED]]]

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 419 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[farad]] ) throws Exception { if ( ! [[farad]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[farad]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 420 ---------------------------------------------
Executes the specified message. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[procedure]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 421 ---------------------------------------------
Stops this connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Associates the specified attribute with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[key]] , Object value ) { return attributes . putIfAbsent ( [[key]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[headstone]] , Object value ) { return attributes . putIfAbsent ( [[headstone]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 423 ---------------------------------------------
Adds a new reconnect task. --> [[[FAILED]]]

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 410 / 8 / 424:  42%|████▏     | 424/1000 [14:42<19:58,  2.08s/it][Succeeded / Failed / Skipped / Total] 6 / 411 / 8 / 425:  42%|████▎     | 425/1000 [14:43<19:55,  2.08s/it][Succeeded / Failed / Skipped / Total] 6 / 411 / 8 / 425:  43%|████▎     | 426/1000 [14:44<19:51,  2.08s/it]Monitors connections.@param connPools the connections --> Registers a new connection pool. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void [[Monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 425 ---------------------------------------------
Closes a list of connections that are no longer needed.@param lastSelectConnect@param serviceOffConnections@throws InterruptedException --> [[[FAILED]]]

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 426 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 412 / 8 / 426:  43%|████▎     | 426/1000 [14:44<19:51,  2.08s/it][Succeeded / Failed / Skipped / Total] 6 / 412 / 9 / 427:  43%|████▎     | 427/1000 [14:44<19:47,  2.07s/it][Succeeded / Failed / Skipped / Total] 6 / 412 / 9 / 427:  43%|████▎     | 428/1000 [14:46<19:44,  2.07s/it][Succeeded / Failed / Skipped / Total] 6 / 413 / 9 / 428:  43%|████▎     | 428/1000 [14:46<19:44,  2.07s/it][Succeeded / Failed / Skipped / Total] 6 / 414 / 9 / 429:  43%|████▎     | 429/1000 [14:46<19:40,  2.07s/it][Succeeded / Failed / Skipped / Total] 6 / 414 / 9 / 429:  43%|████▎     | 430/1000 [14:46<19:35,  2.06s/it][Succeeded / Failed / Skipped / Total] 7 / 414 / 9 / 430:  43%|████▎     | 430/1000 [14:46<19:35,  2.06s/it]Invokes the specified request with the specified callback. --> [[[FAILED]]]

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand [[request]] , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , [[request]] , [[request]] . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = [[request]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand [[bespeak]] , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , [[bespeak]] , [[bespeak]] . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = [[bespeak]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( [[bespeak]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 427 ---------------------------------------------
Returns the boolean value associated with the specified key, or the defaultvalue if the key does not exist. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 428 ---------------------------------------------
Converts a BitSet to a byte.@param bs the BitSet to convert@return the byte value --> [[[FAILED]]]

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int [[value]] = 0 ; for ( int [[i]] = 0 ; [[i]] < bs . length ( ) ; ++ [[i]] ) { if ( bs . get ( [[i]] ) ) { [[value]] += 1 << [[i]] ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int [[assess]] = 0 ; for ( int [[ane]] = 0 ; [[ane]] < bs . length ( ) ; ++ [[ane]] ) { if ( bs . get ( [[ane]] ) ) { [[assess]] += 1 << [[ane]] ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[assess]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[assess]] ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 429 ---------------------------------------------
Log a message at the INFO level. --> [[[FAILED]]]

[[[[Adv]]]]: private void infoLog ( String [[format]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[format]] , addr ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[arrange]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[arrange]] , addr ) ; } else { logger . info ( [[arrange]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 430 ---------------------------------------------
Converts a value into a bit set.@param value the value to convert.@return a bit set. --> Converts an int into a BitSet. --> Socre: 1.0

[[[[Adv]]]]: public static BitSet toBitSet ( int [[value]] ) { if ( [[value]] > Byte . MAX_VALUE || [[value]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[value]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[bs]] = new BitSet ( ) ; int index = 0 ; while ( [[value]] != 0 ) { if ( [[value]] % 2 != 0 ) { [[bs]] . set ( index ) ; } ++ index ; [[value]] = ( byte ) ( [[value]] >> 1 ) ; } return [[bs]] ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet toBitSet ( int [[appraise]] ) { if ( [[appraise]] > Byte . MAX_VALUE || [[appraise]] < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + [[appraise]] + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[Bel]] = new BitSet ( ) ; int index = 0 ; while ( [[appraise]] != 0 ) { if ( [[appraise]] % 2 != 0 ) { [[Bel]] . set ( index ) ; } ++ index ; [[appraise]] = ( byte ) ( [[appraise]] >> 1 ) ; } return [[Bel]] ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 431 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 415 / 9 / 431:  43%|████▎     | 431/1000 [14:47<19:32,  2.06s/it][Succeeded / Failed / Skipped / Total] 7 / 415 / 9 / 431:  43%|████▎     | 432/1000 [14:48<19:27,  2.06s/it][Succeeded / Failed / Skipped / Total] 7 / 416 / 9 / 432:  43%|████▎     | 432/1000 [14:48<19:27,  2.06s/it][Succeeded / Failed / Skipped / Total] 7 / 417 / 9 / 433:  43%|████▎     | 433/1000 [14:48<19:23,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 417 / 9 / 433:  43%|████▎     | 434/1000 [14:50<19:21,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 418 / 9 / 434:  43%|████▎     | 434/1000 [14:50<19:21,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 419 / 9 / 435:  44%|████▎     | 435/1000 [14:52<19:19,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 419 / 9 / 435:  44%|████▎     | 436/1000 [14:53<19:15,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 420 / 9 / 436:  44%|████▎     | 436/1000 [14:53<19:15,  2.05s/it]Returns the user processor for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 432 ---------------------------------------------
Filters a list of connections. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 433 ---------------------------------------------
Converts a request to a remoting command. --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object [[request]] , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand toRemotingCommand ( Object [[postulation]] , Connection conn , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[postulation]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 434 ---------------------------------------------
Resolves a response object.@param responsethe response command@param addrthe address@return the response object@throws RemotingException --> [[[FAILED]]]

[[[[Adv]]]]: public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object resolveResponseObject ( ResponseCommand responseCommand , String addr ) throws RemotingException { preProcess ( responseCommand , addr ) ; if ( responseCommand . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( responseCommand ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , responseCommand . getResponseStatus ( ) , addr , responseCommand . getId ( ) ) ; logger . warn ( msg ) ; if ( responseCommand . getCause ( ) != null ) { throw new InvokeException ( msg , responseCommand . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 435 ---------------------------------------------
Converts a response command to a response object. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 436 ---------------------------------------------
Formats a detail error message. --> [[[FAILED]]]

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String detailErrMsg ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 421 / 9 / 437:  44%|████▎     | 437/1000 [14:57<19:15,  2.05s/it][Succeeded / Failed / Skipped / Total] 7 / 421 / 9 / 437:  44%|████▍     | 438/1000 [14:59<19:14,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 421 / 9 / 438:  44%|████▍     | 438/1000 [14:59<19:14,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 422 / 9 / 439:  44%|████▍     | 439/1000 [15:01<19:11,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 422 / 9 / 439:  44%|████▍     | 440/1000 [15:01<19:06,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 423 / 9 / 440:  44%|████▍     | 440/1000 [15:01<19:06,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 424 / 9 / 441:  44%|████▍     | 441/1000 [15:01<19:02,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 424 / 9 / 441:  44%|████▍     | 442/1000 [15:01<18:58,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 425 / 9 / 442:  44%|████▍     | 442/1000 [15:01<18:58,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 426 / 9 / 443:  44%|████▍     | 443/1000 [15:02<18:55,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 426 / 9 / 443:  44%|████▍     | 444/1000 [15:11<19:00,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 427 / 9 / 444:  44%|████▍     | 444/1000 [15:11<19:00,  2.05s/it]Converts a response command into an exception. --> [[[FAILED]]]

[[[[Adv]]]]: private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable toThrowable ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 438 ---------------------------------------------
Gets the value associated with the given key.@param key the key@param defaultIfNotFound the default value@return the value associated with the given key --> Retrieves the triology associated with the supplied key. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] get ( String key , [[T]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[T]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[triiodothyronine]] > [[triiodothyronine]] get ( String key , [[triiodothyronine]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[triiodothyronine]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 439 ---------------------------------------------
Prints information about a connection trace. --> [[[FAILED]]]

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 440 ---------------------------------------------
Creates an epoll event loop group. --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 441 ---------------------------------------------
Returns the value for the specified key, or null if the key does not exist. --> [[[FAILED]]]

[[[[Adv]]]]: public String getProperty ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String getProperty ( String key ) { if ( properties == null ) { return null ; } return properties . getProperty ( key ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 442 ---------------------------------------------
Determines whether or not the request timed out. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[avowedly]]" == "[[avowedly]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 443 ---------------------------------------------
Creates a new RpcServerException. --> [[[FAILED]]]

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 444 ---------------------------------------------
Parses a channel's local address.@param channel the channel to parse.@return the parsed address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseLocalAddress ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[channel]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String parseLocalAddress ( final Channel [[transfer]] ) { if ( null == [[transfer]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[transfer]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
[Succeeded / Failed / Skipped / Total] 8 / 428 / 9 / 445:  44%|████▍     | 445/1000 [15:13<18:59,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 428 / 9 / 445:  45%|████▍     | 446/1000 [15:14<18:55,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 429 / 9 / 446:  45%|████▍     | 446/1000 [15:14<18:55,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 430 / 9 / 447:  45%|████▍     | 447/1000 [15:15<18:52,  2.05s/it][Succeeded / Failed / Skipped / Total] 8 / 430 / 9 / 447:  45%|████▍     | 448/1000 [15:15<18:48,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 431 / 9 / 448:  45%|████▍     | 448/1000 [15:15<18:48,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 432 / 9 / 449:  45%|████▍     | 449/1000 [15:17<18:46,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 432 / 9 / 449:  45%|████▌     | 450/1000 [15:18<18:42,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 433 / 9 / 450:  45%|████▌     | 450/1000 [15:18<18:42,  2.04s/it]--------------------------------------------- Result 445 ---------------------------------------------
Returns a random connection.@param conns a list of connections@return a random connection --> [[[FAILED]]]

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int [[size]] = conns . size ( ) ; int tries = 0 ; Connection [[result]] = null ; while ( ( [[result]] == null || ! [[result]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[result]] = conns . get ( this . random . nextInt ( [[size]] ) ) ; } if ( [[result]] != null && ! [[result]] . isFine ( ) ) { [[result]] = null ; } return [[result]] ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection randomGet ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int [[sizing]] = conns . size ( ) ; int tries = 0 ; Connection [[solvent]] = null ; while ( ( [[solvent]] == null || ! [[solvent]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[solvent]] = conns . get ( this . random . nextInt ( [[sizing]] ) ) ; } if ( [[solvent]] != null && ! [[solvent]] . isFine ( ) ) { [[solvent]] = null ; } return [[solvent]] ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 446 ---------------------------------------------
Parses an IP address from the specified channel.@param channel the channel@return the IP address --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseLocalIP ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String parseLocalIP ( final Channel [[line]] ) { if ( null == [[line]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[line]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parse a socket address to host ip@param socketAddress@return --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 448 ---------------------------------------------
Deserialize request command.@param ctx the remoting context@param cmd the command@param level the level@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int [[level]] ) { boolean result ; try { cmd . deserialize ( [[level]] ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( [[level]] ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + [[level]] ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int [[tied]] ) { boolean result ; try { cmd . deserialize ( [[tied]] ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( [[tied]] ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + [[tied]] ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 449 ---------------------------------------------
Parse an IP address from the specified channel.@param channel the channel to parse.@return the IP address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel [[line]] ) { if ( null == [[line]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[line]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Parse the remote address from the specified channel.@param channel the channel to parse.@return the remote address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteAddress ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[remote]] = [[channel]] . remoteAddress ( ) ; return doParse ( [[remote]] != null ? [[remote]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String parseRemoteAddress ( final Channel [[line]] ) { if ( null == [[line]] ) { return StringUtils . EMPTY ; } final SocketAddress [[outside]] = [[line]] . remoteAddress ( ) ; return doParse ( [[outside]] != null ? [[outside]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 434 / 9 / 451:  45%|████▌     | 451/1000 [15:18<18:38,  2.04s/it][Succeeded / Failed / Skipped / Total] 8 / 434 / 9 / 451:  45%|████▌     | 452/1000 [15:19<18:34,  2.03s/it][Succeeded / Failed / Skipped / Total] 8 / 435 / 9 / 452:  45%|████▌     | 452/1000 [15:19<18:34,  2.03s/it][Succeeded / Failed / Skipped / Total] 8 / 436 / 9 / 453:  45%|████▌     | 453/1000 [15:19<18:30,  2.03s/it][Succeeded / Failed / Skipped / Total] 8 / 436 / 9 / 453:  45%|████▌     | 454/1000 [15:22<18:29,  2.03s/it][Succeeded / Failed / Skipped / Total] 8 / 437 / 9 / 454:  45%|████▌     | 454/1000 [15:22<18:29,  2.03s/it][Succeeded / Failed / Skipped / Total] 9 / 437 / 9 / 455:  46%|████▌     | 455/1000 [15:22<18:25,  2.03s/it][Succeeded / Failed / Skipped / Total] 9 / 437 / 9 / 455:  46%|████▌     | 456/1000 [15:23<18:22,  2.03s/it][Succeeded / Failed / Skipped / Total] 9 / 438 / 9 / 456:  46%|████▌     | 456/1000 [15:23<18:22,  2.03s/it][Succeeded / Failed / Skipped / Total] 9 / 439 / 9 / 457:  46%|████▌     | 457/1000 [15:24<18:18,  2.02s/it][Succeeded / Failed / Skipped / Total] 9 / 439 / 9 / 457:  46%|████▌     | 458/1000 [15:24<18:14,  2.02s/it][Succeeded / Failed / Skipped / Total] 9 / 440 / 9 / 458:  46%|████▌     | 458/1000 [15:24<18:14,  2.02s/it]Parse the remote host name from the channel.@param channel the channel.@return the remote host name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteHostName ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String parseRemoteHostName ( final Channel [[line]] ) { if ( null == [[line]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[line]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Registers a custom serializer for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void registerCustomSerializer ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 453 ---------------------------------------------
Returns the custom serializer for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 454 ---------------------------------------------
Removes and tries to close the supplied connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 455 ---------------------------------------------
Adds a connection. --> Estimates the number of connections in the pool. --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[tally]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean res = this . conns . addIfAbsent ( connection ) ; if ( res ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 456 ---------------------------------------------
Returns the custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer getCustomSerializer ( CommandCode [[codification]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[codification]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 457 ---------------------------------------------
Initializes the write buffer water mark. --> [[[FAILED]]]

[[[[Adv]]]]: private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void initWriteBufferWaterMark ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 458 ---------------------------------------------
Registers a custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void registerCustomSerializer ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 459 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 441 / 9 / 459:  46%|████▌     | 459/1000 [15:25<18:10,  2.02s/it][Succeeded / Failed / Skipped / Total] 9 / 441 / 9 / 459:  46%|████▌     | 460/1000 [15:25<18:06,  2.01s/it][Succeeded / Failed / Skipped / Total] 9 / 441 / 10 / 460:  46%|████▌     | 460/1000 [15:25<18:06,  2.01s/it][Succeeded / Failed / Skipped / Total] 9 / 442 / 10 / 461:  46%|████▌     | 461/1000 [15:25<18:02,  2.01s/it][Succeeded / Failed / Skipped / Total] 9 / 442 / 10 / 461:  46%|████▌     | 462/1000 [15:26<17:58,  2.01s/it][Succeeded / Failed / Skipped / Total] 9 / 442 / 11 / 462:  46%|████▌     | 462/1000 [15:26<17:58,  2.01s/it][Succeeded / Failed / Skipped / Total] 9 / 443 / 11 / 463:  46%|████▋     | 463/1000 [15:28<17:56,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 443 / 11 / 463:  46%|████▋     | 464/1000 [15:30<17:54,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 444 / 11 / 464:  46%|████▋     | 464/1000 [15:30<17:54,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 445 / 11 / 465:  46%|████▋     | 465/1000 [15:30<17:50,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 445 / 11 / 465:  47%|████▋     | 466/1000 [15:31<17:46,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 446 / 11 / 466:  47%|████▋     | 466/1000 [15:31<17:46,  2.00s/it][Succeeded / Failed / Skipped / Total] 9 / 447 / 11 / 467:  47%|████▋     | 467/1000 [15:31<17:43,  1.99s/it][Succeeded / Failed / Skipped / Total] 9 / 447 / 11 / 467:  47%|████▋     | 468/1000 [15:31<17:38,  1.99s/it]Determines whether or not the specified remote address is connected. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean isConnected ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 460 ---------------------------------------------
Batch write.@param ws@param sockchannel@return@throws IOException --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 461 ---------------------------------------------
Parses a channel's local port.@param channelThe channel to parse.@return The parsed port. --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[line]] ) { if ( null == [[line]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[line]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 462 ---------------------------------------------
Validates a UTF-8 string. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 463 ---------------------------------------------
Checks if the requested protocol matches the provided one. --> [[[FAILED]]]

[[[[Adv]]]]: private HandshakeState containsRequestedProtocol ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState containsRequestedProtocol ( String requestedProtocol ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 464 ---------------------------------------------
Sets the code of the sprite. --> [[[FAILED]]]

[[[[Adv]]]]: public void setCode ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void setCode ( int [[cipher]] ) { this . code = [[cipher]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 465 ---------------------------------------------
Updates the payload. --> [[[FAILED]]]

[[[[Adv]]]]: private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void updatePayload ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 466 ---------------------------------------------
Translate the payload size limit for a single frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void translateSingleFrameCheckLengthLimit ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void translateSingleFrameCheckLengthLimit ( long [[distance]] ) throws LimitExceededException { if ( [[distance]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[distance]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[distance]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[distance]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 467 ---------------------------------------------
Parses the remote port from the channel.@param channel the channel to parse.@return the remote port, or -1 if the channel is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseRemotePort ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int parseRemotePort ( final Channel [[duct]] ) { if ( null == [[duct]] ) { return - 1 ; } final InetSocketAddress remote = ( InetSocketAddress ) [[duct]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 468 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 448 / 11 / 468:  47%|████▋     | 468/1000 [15:31<17:38,  1.99s/it][Succeeded / Failed / Skipped / Total] 10 / 448 / 11 / 469:  47%|████▋     | 469/1000 [15:34<17:38,  1.99s/it][Succeeded / Failed / Skipped / Total] 10 / 448 / 11 / 469:  47%|████▋     | 470/1000 [15:34<17:34,  1.99s/it][Succeeded / Failed / Skipped / Total] 10 / 449 / 11 / 470:  47%|████▋     | 470/1000 [15:34<17:34,  1.99s/it][Succeeded / Failed / Skipped / Total] 10 / 450 / 11 / 471:  47%|████▋     | 471/1000 [15:35<17:31,  1.99s/it][Succeeded / Failed / Skipped / Total] 10 / 450 / 11 / 471:  47%|████▋     | 472/1000 [15:43<17:35,  2.00s/it][Succeeded / Failed / Skipped / Total] 10 / 451 / 11 / 472:  47%|████▋     | 472/1000 [15:43<17:35,  2.00s/it][Succeeded / Failed / Skipped / Total] 10 / 452 / 11 / 473:  47%|████▋     | 473/1000 [15:48<17:37,  2.01s/it][Succeeded / Failed / Skipped / Total] 10 / 452 / 11 / 473:  47%|████▋     | 474/1000 [15:50<17:34,  2.00s/it][Succeeded / Failed / Skipped / Total] 10 / 453 / 11 / 474:  47%|████▋     | 474/1000 [15:50<17:34,  2.00s/it][Succeeded / Failed / Skipped / Total] 11 / 453 / 11 / 475:  48%|████▊     | 475/1000 [15:50<17:30,  2.00s/it][Succeeded / Failed / Skipped / Total] 11 / 453 / 11 / 475:  48%|████▊     | 476/1000 [15:50<17:26,  2.00s/it]Translate the given maxpacketsize to the given realpacketsize. --> [[[FAILED]]]

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 469 ---------------------------------------------
Start the connection monitor. --> Starts the connection monitor. --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[begin]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 470 ---------------------------------------------
Log a runtime exception. --> [[[FAILED]]]

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException [[e]] ) { log . error ( "Runtime exception during onWebsocketMessage" , [[e]] ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , [[e]] ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException [[east]] ) { log . error ( "Runtime exception during onWebsocketMessage" , [[east]] ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , [[east]] ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 471 ---------------------------------------------
Generates the final key for the given input. --> [[[FAILED]]]

[[[[Adv]]]]: private String generateFinalKey ( String [[in]] ) { String seckey = [[in]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String generateFinalKey ( String [[inch]] ) { String seckey = [[inch]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 472 ---------------------------------------------
Processes a binary message. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[frame]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void processFrameBinary ( WebSocketImpl webSocketImpl , Framedata [[compose]] ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , [[compose]] . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 473 ---------------------------------------------
Processes a frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void processFrameIsNotFin ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 474 ---------------------------------------------
Checks the maximum size of the buffer. --> [[[FAILED]]]

[[[[Adv]]]]: private void checkBufferLimit ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void checkBufferLimit ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 475 ---------------------------------------------
Retrieves a connection from this pool.@return the connection or <code>null</code> if none. --> Cleans up all connections from the pool. --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[arrest]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 476 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 454 / 11 / 476:  48%|████▊     | 476/1000 [15:50<17:26,  2.00s/it][Succeeded / Failed / Skipped / Total] 11 / 455 / 11 / 477:  48%|████▊     | 477/1000 [15:51<17:23,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 455 / 11 / 477:  48%|████▊     | 478/1000 [15:53<17:21,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 456 / 11 / 478:  48%|████▊     | 478/1000 [15:53<17:21,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 457 / 11 / 479:  48%|████▊     | 479/1000 [15:55<17:19,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 457 / 11 / 479:  48%|████▊     | 480/1000 [15:55<17:15,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 458 / 11 / 480:  48%|████▊     | 480/1000 [15:55<17:15,  1.99s/it]Processes a WebSocket frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void processFrameText ( WebSocketImpl webSocketImpl , Framedata [[bod]] ) throws InvalidDataException { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( [[bod]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 477 ---------------------------------------------
Processes a continuous frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void processFrameIsFin ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 478 ---------------------------------------------
Returns the size of the byte buffer list. --> [[[FAILED]]]

[[[[Adv]]]]: private long getByteBufferListSize ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long getByteBufferListSize ( ) { long totalSize = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } } return totalSize ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 479 ---------------------------------------------
Decodes the contents of the specified socket buffer. --> [[[FAILED]]]

[[[[Adv]]]]: public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 480 ---------------------------------------------
Processes a continuous frame sequence. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 481 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 459 / 11 / 481:  48%|████▊     | 481/1000 [15:56<17:11,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 459 / 11 / 481:  48%|████▊     | 482/1000 [15:57<17:08,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 460 / 11 / 482:  48%|████▊     | 482/1000 [15:57<17:08,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 461 / 11 / 483:  48%|████▊     | 483/1000 [16:03<17:11,  2.00s/it][Succeeded / Failed / Skipped / Total] 11 / 461 / 11 / 483:  48%|████▊     | 484/1000 [16:03<17:07,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 462 / 11 / 484:  48%|████▊     | 484/1000 [16:03<17:07,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 462 / 12 / 485:  48%|████▊     | 485/1000 [16:03<17:03,  1.99s/it][Succeeded / Failed / Skipped / Total] 11 / 462 / 12 / 485:  49%|████▊     | 486/1000 [16:04<16:59,  1.98s/it][Succeeded / Failed / Skipped / Total] 11 / 463 / 12 / 486:  49%|████▊     | 486/1000 [16:04<16:59,  1.98s/it][Succeeded / Failed / Skipped / Total] 11 / 464 / 12 / 487:  49%|████▊     | 487/1000 [16:04<16:55,  1.98s/it][Succeeded / Failed / Skipped / Total] 11 / 464 / 12 / 487:  49%|████▉     | 488/1000 [16:05<16:52,  1.98s/it]Gets the payload from the byte buffer list. --> [[[FAILED]]]

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 482 ---------------------------------------------
Generates an HTTP response based on an error code. --> [[[FAILED]]]

[[[[Adv]]]]: private ByteBuffer generateHttpResponseDueToError ( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer generateHttpResponseDueToError ( int errorCode ) { String errorCodeDescription ; switch ( errorCode ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 483 ---------------------------------------------
Closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: private void closeConnectionDueToInternalServerError ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void closeConnectionDueToInternalServerError ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 484 ---------------------------------------------
Processes a close frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void processFrameClosing ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 485 ---------------------------------------------
Resets the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 486 ---------------------------------------------
Sends the specified data to the client. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[commit]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[commit]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 487 ---------------------------------------------
Flushes and closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: private void closeConnectionDueToWrongHandshake ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void closeConnectionDueToWrongHandshake ( InvalidDataException [[elision]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[elision]] . getCloseCode ( ) , [[elision]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 488 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 465 / 12 / 488:  49%|████▉     | 488/1000 [16:05<16:52,  1.98s/it][Succeeded / Failed / Skipped / Total] 11 / 466 / 12 / 489:  49%|████▉     | 489/1000 [16:07<16:50,  1.98s/it][Succeeded / Failed / Skipped / Total] 11 / 466 / 12 / 489:  49%|████▉     | 490/1000 [16:07<16:46,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 467 / 12 / 490:  49%|████▉     | 490/1000 [16:07<16:46,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 468 / 12 / 491:  49%|████▉     | 491/1000 [16:08<16:43,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 468 / 12 / 491:  49%|████▉     | 492/1000 [16:09<16:41,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 469 / 12 / 492:  49%|████▉     | 492/1000 [16:09<16:41,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 470 / 12 / 493:  49%|████▉     | 493/1000 [16:10<16:38,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 470 / 12 / 493:  49%|████▉     | 494/1000 [16:11<16:35,  1.97s/it]Sets the connection lost timeout. --> [[[FAILED]]]

[[[[Adv]]]]: public void setConnectionLostTimeout ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void setConnectionLostTimeout ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 489 ---------------------------------------------
Returns an implementation of the given opcode. --> [[[FAILED]]]

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[contract]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 490 ---------------------------------------------
Connects to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[link]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 491 ---------------------------------------------
Cancels the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void restartConnectionLostTimer ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 492 ---------------------------------------------
Called when a connection was lost. --> [[[FAILED]]]

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 493 ---------------------------------------------
Stop the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: protected void stopConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "[[False]]" != "[[False]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void stopConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "[[sour]]" != "[[sour]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 471 / 12 / 494:  49%|████▉     | 494/1000 [16:11<16:35,  1.97s/it][Succeeded / Failed / Skipped / Total] 11 / 472 / 12 / 495:  50%|████▉     | 495/1000 [16:12<16:31,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 472 / 12 / 495:  50%|████▉     | 496/1000 [16:12<16:28,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 473 / 12 / 496:  50%|████▉     | 496/1000 [16:12<16:28,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 474 / 12 / 497:  50%|████▉     | 497/1000 [16:13<16:24,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 474 / 12 / 497:  50%|████▉     | 498/1000 [16:14<16:22,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 475 / 12 / 498:  50%|████▉     | 498/1000 [16:14<16:22,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 476 / 12 / 499:  50%|████▉     | 499/1000 [16:15<16:19,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 476 / 12 / 499:  50%|█████     | 500/1000 [16:16<16:16,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 477 / 12 / 500:  50%|█████     | 500/1000 [16:16<16:16,  1.95s/it]Sends a handshake. --> [[[FAILED]]]

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 495 ---------------------------------------------
Start the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: protected void startConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void startConnectionLostTimer ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 496 ---------------------------------------------
Returns the port number for the given URI. --> [[[FAILED]]]

[[[[Adv]]]]: private int getPort ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int getPort ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 497 ---------------------------------------------
Sends a ping frame. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void onWebsocketPing ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 498 ---------------------------------------------
Cancel a connection lost checker. --> [[[FAILED]]]

[[[[Adv]]]]: private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void cancelConnectionLostTimer ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[delusive]]" != "[[delusive]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 499 ---------------------------------------------
Returns the port number associated with this socket. --> [[[FAILED]]]

[[[[Adv]]]]: public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int getPort ( ) { int port = getAddress ( ) . getPort ( ) ; if ( port == 0 && server != null ) { port = server . socket ( ) . getLocalPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 500 ---------------------------------------------
Performs additional read. --> [[[FAILED]]]

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 501 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 477 / 13 / 501:  50%|█████     | 501/1000 [16:16<16:12,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 477 / 13 / 501:  50%|█████     | 502/1000 [16:16<16:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 477 / 14 / 502:  50%|█████     | 502/1000 [16:16<16:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 478 / 14 / 503:  50%|█████     | 503/1000 [16:28<16:16,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 478 / 14 / 503:  50%|█████     | 504/1000 [16:28<16:12,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 478 / 15 / 504:  50%|█████     | 504/1000 [16:28<16:12,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 478 / 15 / 504:  50%|█████     | 505/1000 [16:29<16:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 479 / 15 / 505:  50%|█████     | 505/1000 [16:29<16:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 479 / 15 / 505:  51%|█████     | 506/1000 [16:29<16:06,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 480 / 15 / 506:  51%|█████     | 506/1000 [16:29<16:06,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 480 / 15 / 506:  51%|█████     | 507/1000 [16:30<16:03,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 481 / 15 / 507:  51%|█████     | 507/1000 [16:30<16:03,  1.95s/it][Succeeded / Failed / Skipped / Total] 11 / 481 / 15 / 507:  51%|█████     | 508/1000 [16:34<16:03,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 482 / 15 / 508:  51%|█████     | 508/1000 [16:34<16:03,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 482 / 15 / 508:  51%|█████     | 509/1000 [16:36<16:01,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 483 / 15 / 509:  51%|█████     | 509/1000 [16:36<16:01,  1.96s/it][Succeeded / Failed / Skipped / Total] 11 / 483 / 15 / 509:  51%|█████     | 510/1000 [16:38<15:59,  1.96s/it]Reads from the socket. --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 502 ---------------------------------------------
Writes data to the specified key. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 503 ---------------------------------------------
Called when a websocket handshake is received. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 504 ---------------------------------------------
Called when the server shuts down. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Ensure that only one thread is running. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 506 ---------------------------------------------
Returns the socket for the specified channel. --> [[[FAILED]]]

[[[[Adv]]]]: private Socket getSocket ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket getSocket ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 507 ---------------------------------------------
Translate the first line of the HTTP client handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> [[[FAILED]]]

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] firstLineTokens , String [[describe]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 508 ---------------------------------------------
Translate the first line of the HTTP server handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> [[[FAILED]]]

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] firstLineTokens , String [[tune]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 509 ---------------------------------------------
Initializes the selector and server. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[treacherously]]" != "[[treacherously]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[treacherously]]" != "[[treacherously]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 510 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 483 / 15 / 510:  51%|█████     | 510/1000 [16:38<15:59,  1.96s/it][Succeeded / Failed / Skipped / Total] 12 / 483 / 15 / 510:  51%|█████     | 511/1000 [16:45<16:02,  1.97s/it][Succeeded / Failed / Skipped / Total] 13 / 483 / 15 / 511:  51%|█████     | 511/1000 [16:45<16:02,  1.97s/it][Succeeded / Failed / Skipped / Total] 14 / 483 / 15 / 512:  51%|█████     | 512/1000 [16:45<15:58,  1.96s/it][Succeeded / Failed / Skipped / Total] 14 / 483 / 15 / 512:  51%|█████▏    | 513/1000 [16:45<15:54,  1.96s/it][Succeeded / Failed / Skipped / Total] 14 / 484 / 15 / 513:  51%|█████▏    | 513/1000 [16:45<15:54,  1.96s/it][Succeeded / Failed / Skipped / Total] 14 / 485 / 15 / 514:  51%|█████▏    | 514/1000 [16:47<15:52,  1.96s/it][Succeeded / Failed / Skipped / Total] 14 / 485 / 15 / 514:  52%|█████▏    | 515/1000 [16:48<15:49,  1.96s/it][Succeeded / Failed / Skipped / Total] 14 / 486 / 15 / 515:  52%|█████▏    | 515/1000 [16:48<15:49,  1.96s/it]Broadcasts a data frame to all the clients. --> Broadcasts information about a websocket. --> Socre: 1.0

[[[[Adv]]]]: private void doBroadcast ( Object [[data]] , Collection < WebSocket > clients ) { String sData = null ; if ( [[data]] instanceof String ) { sData = ( String ) [[data]] ; } ByteBuffer bData = null ; if ( [[data]] instanceof ByteBuffer ) { bData = ( ByteBuffer ) [[data]] ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void doBroadcast ( Object [[information]] , Collection < WebSocket > clients ) { String sData = null ; if ( [[information]] instanceof String ) { sData = ( String ) [[information]] ; } ByteBuffer bData = null ; if ( [[information]] instanceof ByteBuffer ) { bData = ( ByteBuffer ) [[information]] ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 511 ---------------------------------------------
Broadcasts the specified data to all registered clients. --> Stores the supplied data into the supplied client. --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > [[clients]] ) { if ( data == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[circulate]] ( byte [ ] data , Collection < WebSocket > [[client]] ) { if ( data == null || [[client]] == null ) { throw new IllegalArgumentException ( ) ; } [[circulate]] ( ByteBuffer . wrap ( data ) , [[client]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 512 ---------------------------------------------
Accepts a selection key. --> Accepts the given iterator. --> Socre: 1.0

[[[[Adv]]]]: private void doAccept ( SelectionKey [[key]] , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( [[key]] ) ) { [[key]] . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey [[cardinal]] , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( [[cardinal]] ) ) { [[cardinal]] . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 513 ---------------------------------------------
Stops this thread. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[block]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 514 ---------------------------------------------
Converts an array of arguments to a list of objects. --> [[[FAILED]]]

[[[[Adv]]]]: private static Seq < Object > convertArgsToScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > convertArgsToScalaBuffer ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 515 ---------------------------------------------
Broadcasts the specified text to all registered clients. --> [[[FAILED]]]

[[[[Adv]]]]: public void broadcast ( String text , Collection < WebSocket > [[clients]] ) { if ( text == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , [[clients]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( String text , Collection < WebSocket > [[customer]] ) { if ( text == null || [[customer]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , [[customer]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 516 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 486 / 15 / 516:  52%|█████▏    | 516/1000 [16:48<15:46,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 486 / 15 / 516:  52%|█████▏    | 517/1000 [16:51<15:45,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 487 / 15 / 517:  52%|█████▏    | 517/1000 [16:51<15:45,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 488 / 15 / 518:  52%|█████▏    | 518/1000 [16:57<15:46,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 488 / 15 / 518:  52%|█████▏    | 519/1000 [16:58<15:43,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 489 / 15 / 519:  52%|█████▏    | 519/1000 [16:58<15:43,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 490 / 15 / 520:  52%|█████▏    | 520/1000 [17:02<15:44,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 490 / 15 / 520:  52%|█████▏    | 521/1000 [17:06<15:44,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 491 / 15 / 521:  52%|█████▏    | 521/1000 [17:06<15:44,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 492 / 15 / 522:  52%|█████▏    | 522/1000 [17:08<15:42,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 492 / 15 / 522:  52%|█████▏    | 523/1000 [17:13<15:42,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 493 / 15 / 523:  52%|█████▏    | 523/1000 [17:13<15:42,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 494 / 15 / 524:  52%|█████▏    | 524/1000 [17:14<15:39,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 494 / 15 / 524:  52%|█████▎    | 525/1000 [17:17<15:38,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 495 / 15 / 525:  52%|█████▎    | 525/1000 [17:17<15:38,  1.98s/it]Transfer a byte buffer from source to dest. --> Copies the contents of the supplied buffer into the supplied destination buffer. --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[author]] , ByteBuffer dest ) { if ( [[author]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[author]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[author]] . limit ( limit ) ; dest . put ( [[author]] ) ; return limit ; } else { dest . put ( [[author]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 517 ---------------------------------------------
Starts the persistence manager. --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[get]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 518 ---------------------------------------------
Creates an entity manager with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager em ( String [[constitute]] ) { EntityManagerFactory emf = emfs . get ( [[constitute]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 519 ---------------------------------------------
Wrap a list of arguments to a list if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > wrapArgsToListIfNeeded ( final T ... args ) { List < T > out ; if ( args != null && args . length == 1 && args [ 0 ] instanceof List ) { out = ( List < T > ) args [ 0 ] ; } else { out = Arrays . asList ( args ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 520 ---------------------------------------------
Performs a transaction on this entity manager. --> [[[FAILED]]]

[[[[Adv]]]]: public void withTransaction ( Consumer < EntityManager > [[block]] ) { withTransaction ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void withTransaction ( Consumer < EntityManager > [[blocking]] ) { withTransaction ( em -> { [[blocking]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 521 ---------------------------------------------
Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[favor]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 522 ---------------------------------------------
Returns true if this message is defined at the specified language. --> [[[FAILED]]]

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang lang , String [[key]] ) { return messages . isDefinedAt ( [[key]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean isDefinedAt ( play . api . i18n . Lang lang , String [[cardinal]] ) { return messages . isDefinedAt ( [[cardinal]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 523 ---------------------------------------------
Sets the language of the result. --> [[[FAILED]]]

[[[[Adv]]]]: public Result setLang ( Result [[result]] , Lang lang ) { return messages . setLang ( [[result]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result setLang ( Result [[leave]] , Lang lang ) { return messages . setLang ( [[leave]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 524 ---------------------------------------------
Creates and returns a Guiceable with the specified configuration.@param play The play instance.@param REPLACEME0 The configuration.@return A self object. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self REPLACEME0 ( play . api . inject . Binding < ? > ... REPLACEME0 ) { return REPLACEME0 ( Guiceable . bindings ( REPLACEME0 ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 525 ---------------------------------------------
Creates a copy of this builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[dressing]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 526 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 496 / 15 / 526:  53%|█████▎    | 526/1000 [17:17<15:34,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 496 / 15 / 526:  53%|█████▎    | 527/1000 [17:18<15:32,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 497 / 15 / 527:  53%|█████▎    | 527/1000 [17:18<15:32,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 498 / 15 / 528:  53%|█████▎    | 528/1000 [17:21<15:30,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 498 / 15 / 528:  53%|█████▎    | 529/1000 [17:21<15:27,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 499 / 15 / 529:  53%|█████▎    | 529/1000 [17:21<15:27,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 500 / 15 / 530:  53%|█████▎    | 530/1000 [17:21<15:23,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 500 / 15 / 530:  53%|█████▎    | 531/1000 [17:22<15:20,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 501 / 15 / 531:  53%|█████▎    | 531/1000 [17:22<15:20,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 502 / 15 / 532:  53%|█████▎    | 532/1000 [17:22<15:17,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 502 / 15 / 532:  53%|█████▎    | 533/1000 [17:29<15:19,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 503 / 15 / 533:  53%|█████▎    | 533/1000 [17:29<15:19,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 504 / 15 / 534:  53%|█████▎    | 534/1000 [17:31<15:17,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 504 / 15 / 534:  54%|█████▎    | 535/1000 [17:31<15:14,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 505 / 15 / 535:  54%|█████▎    | 535/1000 [17:31<15:14,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 506 / 15 / 536:  54%|█████▎    | 536/1000 [17:31<15:10,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 506 / 15 / 536:  54%|█████▎    | 537/1000 [17:33<15:08,  1.96s/it]Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > candidates ) { Seq < Lang > [[cs]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) [[cs]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[choose]] ( Collection < Lang > candidates ) { Seq < Lang > [[C]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) [[C]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 527 ---------------------------------------------
Creates a set of bindings. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... modules ) { return [[bindings]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[oblige]] ( play . api . inject . Module ... modules ) { return [[oblige]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 528 ---------------------------------------------
Creates an overrides module. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[overturn]] ( GuiceableModule ... [[faculty]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[faculty]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 529 ---------------------------------------------
Fills a draft frame list with data from the specified draft. --> [[[FAILED]]]

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > [[frames]] = null ; if ( sData != null ) { [[frames]] = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { [[frames]] = draft . createFrames ( bData , "False" != "False" ) ; } if ( [[frames]] != null ) { draftFrames . put ( draft , [[frames]] ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > [[cast]] = null ; if ( sData != null ) { [[cast]] = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { [[cast]] = draft . createFrames ( bData , "False" != "False" ) ; } if ( [[cast]] != null ) { draftFrames . put ( draft , [[cast]] ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 530 ---------------------------------------------
Returns the overrides of this object. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... modules ) { return [[overrides]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[overrule]] ( play . api . inject . Module ... modules ) { return [[overrule]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 531 ---------------------------------------------
Disables the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[invalid]] ( Class < ? > ... moduleClasses ) { return newBuilder ( delegate . disable ( Scala . toSeq ( moduleClasses ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 532 ---------------------------------------------
Retrieves the file for the specified relative path. --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > getExistingFile ( String relativePath ) { return OptionConverters . toJava ( env . getExistingFile ( relativePath ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 533 ---------------------------------------------
Gets all messages.@param lang the language@param keys the keys@param args the args@return the messages --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , List < String > keys , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 534 ---------------------------------------------
Overrides the given bindings. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[override]] ( play . api . inject . Binding < ? > ... [[binding]] ) { return [[override]] ( Guiceable . [[binding]] ( [[binding]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 535 ---------------------------------------------
Creates a binding for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[carry]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 536 ---------------------------------------------
Gets the message associated with the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String [[key]] , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[key]] , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang lang , String [[headstone]] , Object ... args ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( [[headstone]] , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 537 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 507 / 15 / 537:  54%|█████▎    | 537/1000 [17:33<15:08,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 508 / 15 / 538:  54%|█████▍    | 538/1000 [17:39<15:09,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 508 / 15 / 538:  54%|█████▍    | 539/1000 [17:39<15:06,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 509 / 15 / 539:  54%|█████▍    | 539/1000 [17:39<15:06,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 510 / 15 / 540:  54%|█████▍    | 540/1000 [17:40<15:03,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 510 / 15 / 540:  54%|█████▍    | 541/1000 [17:40<14:59,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 511 / 15 / 541:  54%|█████▍    | 541/1000 [17:40<15:00,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 512 / 15 / 542:  54%|█████▍    | 542/1000 [17:41<14:56,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 512 / 15 / 542:  54%|█████▍    | 543/1000 [17:42<14:53,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 513 / 15 / 543:  54%|█████▍    | 543/1000 [17:42<14:53,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 514 / 15 / 544:  54%|█████▍    | 544/1000 [17:45<14:52,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 514 / 15 / 544:  55%|█████▍    | 545/1000 [17:46<14:50,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 515 / 15 / 545:  55%|█████▍    | 545/1000 [17:46<14:50,  1.96s/it]Creates a new configuration object. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig of ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 538 ---------------------------------------------
Converts an execution context into an executor. --> [[[FAILED]]]

[[[[Adv]]]]: private static Executor toExecutor ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor toExecutor ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 539 ---------------------------------------------
Calls the given request and returns the result. --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[bid]] ( Request req ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 540 ---------------------------------------------
Creates a new tuple containing the specified two elements. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[A]] , B > Tuple < [[A]] , B > Tuple ( [[A]] a , B b ) { return new Tuple < [[A]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[amp]] , B > Tuple < [[amp]] , B > Tuple ( [[amp]] a , B b ) { return new Tuple < [[amp]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 541 ---------------------------------------------
Creates a flow with the specified callback name. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > json ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > json ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( json -> { return ByteString . fromString ( Json . stringify ( json ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 542 ---------------------------------------------
Creates a new configuration from the supplied map. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig from ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[map]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig from ( Map < String , String > [[mapping]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[mapping]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 543 ---------------------------------------------
Creates a flow from a string and a byte string. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[draw]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
Renders a bad request. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 545 ---------------------------------------------
Creates a new configuration for the specified persistence unit. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig of ( String [[name]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig of ( String [[epithet]] , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[epithet]] , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 546 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 516 / 15 / 546:  55%|█████▍    | 546/1000 [17:48<14:48,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 516 / 15 / 546:  55%|█████▍    | 547/1000 [17:50<14:46,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 517 / 15 / 547:  55%|█████▍    | 547/1000 [17:50<14:46,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 518 / 15 / 548:  55%|█████▍    | 548/1000 [17:51<14:43,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 518 / 15 / 548:  55%|█████▍    | 549/1000 [17:52<14:40,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 519 / 15 / 549:  55%|█████▍    | 549/1000 [17:52<14:40,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 520 / 15 / 550:  55%|█████▌    | 550/1000 [17:52<14:37,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 520 / 15 / 550:  55%|█████▌    | 551/1000 [17:52<14:34,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 521 / 15 / 551:  55%|█████▌    | 551/1000 [17:52<14:34,  1.95s/it]Finds the method with the given name and returns it.@param cls the class to search for the method@param methodName the name of the method@param parameterTypes the parameter types of the method@return the matching method --> [[[FAILED]]]

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > [[cls]] , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = [[cls]] . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method getMatchingAccessibleMethod ( final Class < ? > [[Cl]] , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = [[Cl]] . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 547 ---------------------------------------------
Renders a forbidden page. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 548 ---------------------------------------------
Called when an error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 549 ---------------------------------------------
Called when a request is not found. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > onNotFound ( RequestHeader [[asking]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[asking]] . method ( ) , [[asking]] . uri ( ) , [[asking]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[asking]] . method ( ) , [[asking]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[asking]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 550 ---------------------------------------------
Converts an exception to a useful exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException throwableToUsefulException ( final Throwable throwable ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , throwable ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 551 ---------------------------------------------
Log a server error. --> [[[FAILED]]]

[[[[Adv]]]]: protected void logServerError ( RequestHeader [[request]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[request]] . method ( ) , [[request]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void logServerError ( RequestHeader [[petition]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[petition]] . method ( ) , [[petition]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 552 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 522 / 15 / 552:  55%|█████▌    | 552/1000 [17:54<14:32,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 522 / 15 / 552:  55%|█████▌    | 553/1000 [17:55<14:29,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 523 / 15 / 553:  55%|█████▌    | 553/1000 [17:55<14:29,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 524 / 15 / 554:  55%|█████▌    | 554/1000 [17:56<14:26,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 524 / 15 / 554:  56%|█████▌    | 555/1000 [17:58<14:24,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 525 / 15 / 555:  56%|█████▌    | 555/1000 [17:58<14:24,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 526 / 15 / 556:  56%|█████▌    | 556/1000 [17:59<14:21,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 526 / 15 / 556:  56%|█████▌    | 557/1000 [18:06<14:24,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 527 / 15 / 557:  56%|█████▌    | 557/1000 [18:06<14:24,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 528 / 15 / 558:  56%|█████▌    | 558/1000 [18:10<14:23,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 528 / 15 / 558:  56%|█████▌    | 559/1000 [18:13<14:22,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 529 / 15 / 559:  56%|█████▌    | 559/1000 [18:13<14:22,  1.96s/it]Called when an error has occurred. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable [[exception]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[exception]] ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onServerError ( RequestHeader request , Throwable [[exclusion]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[exclusion]] ) ; logServerError ( request , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( request , usefulException ) ; default : return onDevServerError ( request , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 553 ---------------------------------------------
Creates a handler from a directory. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectory ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 554 ---------------------------------------------
Adds a constraint validator to the map.@param < T> the type parameter@param < MappedConstraintValidatorFactory> the factory --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > MappedConstraintValidatorFactory addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 555 ---------------------------------------------
Called when an error occurred. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > onDevServerError ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 556 ---------------------------------------------
Handles a server error. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader [[request]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader [[asking]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[asking]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a new instance of this constraint validator. --> [[[FAILED]]]

[[[[Adv]]]]: private < [[T]] extends ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[tonne]] extends ConstraintValidator < ? , ? > > [[tonne]] newInstance ( Class < [[tonne]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 558 ---------------------------------------------
Consumes data from this materializer. --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < ByteString > consumeData ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > consumeData ( Materializer [[matte]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[matte]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 559 ---------------------------------------------
Creates a new BuildDocHandler from a list of files. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
[Succeeded / Failed / Skipped / Total] 15 / 530 / 15 / 560:  56%|█████▌    | 560/1000 [18:16<14:21,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 530 / 15 / 560:  56%|█████▌    | 561/1000 [18:16<14:18,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 531 / 15 / 561:  56%|█████▌    | 561/1000 [18:16<14:18,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 532 / 15 / 562:  56%|█████▌    | 562/1000 [18:18<14:16,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 532 / 15 / 562:  56%|█████▋    | 563/1000 [18:19<14:13,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 533 / 15 / 563:  56%|█████▋    | 563/1000 [18:19<14:13,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 534 / 15 / 564:  56%|█████▋    | 564/1000 [18:26<14:15,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 534 / 15 / 564:  56%|█████▋    | 565/1000 [18:28<14:13,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 535 / 15 / 565:  56%|█████▋    | 565/1000 [18:28<14:13,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 535 / 16 / 566:  57%|█████▋    | 566/1000 [18:29<14:10,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 535 / 16 / 566:  57%|█████▋    | 567/1000 [18:31<14:08,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 536 / 16 / 567:  57%|█████▋    | 567/1000 [18:31<14:08,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 537 / 16 / 568:  57%|█████▋    | 568/1000 [18:31<14:05,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 537 / 16 / 568:  57%|█████▋    | 569/1000 [18:31<14:02,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 538 / 16 / 569:  57%|█████▋    | 569/1000 [18:31<14:02,  1.95s/it]--------------------------------------------- Result 560 ---------------------------------------------
Creates a new HTTP entity from a string.@param content the string to parse@param charset the charset to use@return a new HTTP entity --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[content]] , String charset ) { return new Strict ( ByteString . fromString ( [[content]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[contented]] , String charset ) { return new Strict ( ByteString . fromString ( [[contented]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a handler from a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromJar ( JarFile jarFile , String [[base]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromJar ( JarFile jarFile , String [[ground]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[ground]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 562 ---------------------------------------------
Creates a chunked HTTP entity. --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[lump]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 563 ---------------------------------------------
Converts a content object to an entity object.@param content The content object to convert.@param charset The charset to use.@return The entity object. --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity fromContent ( Content [[content]] , String charset ) { String [[body]] ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity fromContent ( Content [[message]] , String charset ) { String [[torso]] ; if ( [[message]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 564 ---------------------------------------------
Converts a JSON response to a Result object. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[condition]] ( int [[condition]] , JsonNode [[contentedness]] ) { return [[condition]] ( [[condition]] , [[contentedness]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 565 ---------------------------------------------
Creates a response with the specified status code and content. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[contented]] ) { if ( [[contented]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[contented]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 566 ---------------------------------------------
Finds a user by its id. --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 567 ---------------------------------------------
Sends a JSON response. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode content , JsonEncoding [[encoding]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[position]] ( int [[condition]] , JsonNode content , JsonEncoding [[encryption]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[position]] ( [[position]] ) . sendJson ( content , [[encryption]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 568 ---------------------------------------------
Sends a status response. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int status , InputStream [[content]] , long contentLength ) { return [[status]] ( [[status]] ) . sendInputStream ( [[content]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[condition]] ( int status , InputStream [[substance]] , long contentLength ) { return [[condition]] ( [[condition]] ) . sendInputStream ( [[substance]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 569 ---------------------------------------------
Creates a handler from a directory and a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 570 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 539 / 16 / 570:  57%|█████▋    | 570/1000 [18:34<14:00,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 539 / 16 / 570:  57%|█████▋    | 571/1000 [18:34<13:57,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 540 / 16 / 571:  57%|█████▋    | 571/1000 [18:34<13:57,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 541 / 16 / 572:  57%|█████▋    | 572/1000 [18:34<13:54,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 541 / 16 / 572:  57%|█████▋    | 573/1000 [18:35<13:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 542 / 16 / 573:  57%|█████▋    | 573/1000 [18:35<13:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 543 / 16 / 574:  57%|█████▋    | 574/1000 [18:36<13:48,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 543 / 16 / 574:  57%|█████▊    | 575/1000 [18:37<13:45,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 544 / 16 / 575:  57%|█████▊    | 575/1000 [18:37<13:45,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 545 / 16 / 576:  58%|█████▊    | 576/1000 [18:38<13:43,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 545 / 16 / 576:  58%|█████▊    | 577/1000 [18:39<13:40,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 546 / 16 / 577:  58%|█████▊    | 577/1000 [18:39<13:40,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 547 / 16 / 578:  58%|█████▊    | 578/1000 [18:40<13:38,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 547 / 16 / 578:  58%|█████▊    | 579/1000 [18:40<13:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 548 / 16 / 579:  58%|█████▊    | 579/1000 [18:40<13:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 549 / 16 / 580:  58%|█████▊    | 580/1000 [18:44<13:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 549 / 16 / 580:  58%|█████▊    | 581/1000 [18:45<13:31,  1.94s/it]Creates a call with the specified fragment. --> [[[FAILED]]]

[[[[Adv]]]]: public Call withFragment ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call withFragment ( String [[shard]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[shard]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 571 ---------------------------------------------
Creates a unique call. --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[unparalleled]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 572 ---------------------------------------------
Returns the absolute URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public String absoluteURL ( Http . Request [[request]] ) { return absoluteURL ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String absoluteURL ( Http . Request [[petition]] ) { return absoluteURL ( [[petition]] . secure ( ) , [[petition]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 573 ---------------------------------------------
Sets the status of a file. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int status , File content ) { return [[status]] ( [[status]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[condition]] ( int status , File content ) { return [[condition]] ( [[condition]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 574 ---------------------------------------------
Creates a handler from a directory and a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile jarFile , String base ) { return fromDirectoryAndJar ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 575 ---------------------------------------------
Returns the web socket URL. --> [[[FAILED]]]

[[[[Adv]]]]: public String webSocketURL ( Http . Request request ) { return webSocketURL ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String webSocketURL ( Http . Request request ) { return webSocketURL ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 576 ---------------------------------------------
Converts the given object to a JSON representation.@param data the object to convert.@return the JSON representation. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 577 ---------------------------------------------
Parses the given string into a JSON object. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 578 ---------------------------------------------
Returns the preferred language for the specified collection of languages. --> [[[FAILED]]]

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[pet]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 579 ---------------------------------------------
Parses the content of an input stream. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 580 ---------------------------------------------
Converts a JSON node into a value of the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[ampere]] > [[ampere]] fromJson ( JsonNode json , Class < [[ampere]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 581 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 550 / 16 / 581:  58%|█████▊    | 581/1000 [18:45<13:31,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 551 / 16 / 582:  58%|█████▊    | 582/1000 [18:45<13:28,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 551 / 16 / 582:  58%|█████▊    | 583/1000 [18:46<13:25,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 552 / 16 / 583:  58%|█████▊    | 583/1000 [18:46<13:25,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 553 / 16 / 584:  58%|█████▊    | 584/1000 [18:47<13:22,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 553 / 16 / 584:  58%|█████▊    | 585/1000 [18:48<13:20,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 554 / 16 / 585:  58%|█████▊    | 585/1000 [18:48<13:20,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 555 / 16 / 586:  59%|█████▊    | 586/1000 [18:52<13:19,  1.93s/it][Succeeded / Failed / Skipped / Total] 15 / 555 / 16 / 586:  59%|█████▊    | 587/1000 [18:57<13:20,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 556 / 16 / 587:  59%|█████▊    | 587/1000 [18:57<13:20,  1.94s/it]Returns the canonical path of the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[basic]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[basic]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[basic]] . empty ( ) && [[basic]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[basic]] . push ( comp ) ; else [[basic]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[basic]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 582 ---------------------------------------------
Returns the relative path to the specified file or directory. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[relative]] ( String startPath , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[relation]] ( String startPath , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 583 ---------------------------------------------
Display a list of constraints. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > constraints ) { return constraints . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 584 ---------------------------------------------
Display a constraint. --> [[[FAILED]]]

[[[[Adv]]]]: public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > [[constraint]] ) { final Display displayAnnotation = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > displayableConstraint ( ConstraintDescriptor < ? > [[restraint]] ) { final Display displayAnnotation = [[restraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[restraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 585 ---------------------------------------------
Parse a cron expression.@param cron the cron@return the date --> [[[FAILED]]]

[[[[Adv]]]]: public static Date parseCRONExpression ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date parseCRONExpression ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 586 ---------------------------------------------
Get the next cron interval.@param cron@param date@return --> [[[FAILED]]]

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[date]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[see]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[see]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 587 ---------------------------------------------
Creates a new client.@param config the configuration@param cache the cache@param materializer the materializer@return the client --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache cache , Materializer materializer ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , materializer ) ; return new AhcWSClient ( client , materializer ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 588 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 557 / 16 / 588:  59%|█████▉    | 588/1000 [19:00<13:19,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 557 / 16 / 588:  59%|█████▉    | 589/1000 [19:03<13:17,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 558 / 16 / 589:  59%|█████▉    | 589/1000 [19:03<13:17,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 559 / 16 / 590:  59%|█████▉    | 590/1000 [19:05<13:15,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 559 / 16 / 590:  59%|█████▉    | 591/1000 [19:06<13:13,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 560 / 16 / 591:  59%|█████▉    | 591/1000 [19:06<13:13,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 561 / 16 / 592:  59%|█████▉    | 592/1000 [19:09<13:12,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 561 / 16 / 592:  59%|█████▉    | 593/1000 [19:17<13:14,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 562 / 16 / 593:  59%|█████▉    | 593/1000 [19:17<13:14,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 562 / 16 / 593:  59%|█████▉    | 594/1000 [19:17<13:11,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 563 / 16 / 594:  59%|█████▉    | 594/1000 [19:17<13:11,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 563 / 16 / 594:  60%|█████▉    | 595/1000 [19:18<13:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 564 / 16 / 595:  60%|█████▉    | 595/1000 [19:18<13:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 564 / 16 / 595:  60%|█████▉    | 596/1000 [19:19<13:05,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 565 / 16 / 596:  60%|█████▉    | 596/1000 [19:19<13:05,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 565 / 16 / 596:  60%|█████▉    | 597/1000 [19:21<13:04,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 566 / 16 / 597:  60%|█████▉    | 597/1000 [19:21<13:04,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 566 / 16 / 597:  60%|█████▉    | 598/1000 [19:27<13:04,  1.95s/it]Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder builder ( ApplicationLoader . Context context ) { return initialBuilder . in ( context . environment ( ) ) . loadConfig ( context . initialConfig ( ) ) . overrides ( overrides ( context ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 589 ---------------------------------------------
Renders a page. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result TODO ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request [[bespeak]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[bespeak]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 590 ---------------------------------------------
Creates a new Router instance. --> [[[FAILED]]]

[[[[Adv]]]]: public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server forRouter ( Mode mode , int port , Function < BuiltInComponents , Router > [[hinder]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[hinder]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 591 ---------------------------------------------
Creates a new connection callable. --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return [[block]] . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[hinder]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection connection ) { try { return [[hinder]] . call ( connection ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 592 ---------------------------------------------
Creates a new connection runnable. --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[block]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[stuff]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[stuff]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 593 ---------------------------------------------
Waits for the specified amount of time to complete. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > [[stage]] , final long [[amount]] , final TimeUnit unit ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( [[amount]] , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > [[present]] , final long [[number]] , final TimeUnit unit ) { requireNonNull ( [[present]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( [[number]] , unit ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[present]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 594 ---------------------------------------------
Returns the binding key for the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[prolong]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 595 ---------------------------------------------
Creates a binding from this provider. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > to ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 596 ---------------------------------------------
Creates a binding for the specified implementation. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > to ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 597 ---------------------------------------------
Returns a binding key with the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[prolong]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 598 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 567 / 16 / 598:  60%|█████▉    | 598/1000 [19:27<13:04,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 567 / 16 / 598:  60%|█████▉    | 599/1000 [19:28<13:01,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 568 / 16 / 599:  60%|█████▉    | 599/1000 [19:28<13:01,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 568 / 16 / 599:  60%|██████    | 600/1000 [19:29<12:59,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 569 / 16 / 600:  60%|██████    | 600/1000 [19:29<12:59,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 569 / 16 / 600:  60%|██████    | 601/1000 [19:30<12:56,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 570 / 16 / 601:  60%|██████    | 601/1000 [19:30<12:56,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 570 / 16 / 601:  60%|██████    | 602/1000 [19:33<12:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 571 / 16 / 602:  60%|██████    | 602/1000 [19:33<12:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 571 / 16 / 602:  60%|██████    | 603/1000 [19:36<12:54,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 572 / 16 / 603:  60%|██████    | 603/1000 [19:36<12:54,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 572 / 16 / 603:  60%|██████    | 604/1000 [19:36<12:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 573 / 16 / 604:  60%|██████    | 604/1000 [19:36<12:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 573 / 16 / 604:  60%|██████    | 605/1000 [19:38<12:49,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 574 / 16 / 605:  60%|██████    | 605/1000 [19:38<12:49,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 574 / 16 / 605:  61%|██████    | 606/1000 [19:40<12:47,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 575 / 16 / 606:  61%|██████    | 606/1000 [19:40<12:47,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 575 / 16 / 606:  61%|██████    | 607/1000 [19:40<12:44,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 576 / 16 / 607:  61%|██████    | 607/1000 [19:40<12:44,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 576 / 16 / 607:  61%|██████    | 608/1000 [19:42<12:42,  1.95s/it]Creates a session for the specified key and value. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void session ( String [[key]] , String [[value]] ) { session ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void session ( String [[cay]] , String [[appraise]] ) { session ( ) . put ( [[cay]] , [[appraise]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 599 ---------------------------------------------
Returns a list of available languages. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > availables ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( langs . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 600 ---------------------------------------------
Converts the given key to this binding. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > to ( final BindingKey < ? extends T > [[cardinal]] ) { return underlying . to ( [[cardinal]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 601 ---------------------------------------------
Creates a binding from a supplier. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[carry]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 602 ---------------------------------------------
Creates a reader from a map of evolutions. --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader fromMap ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[evolution]] . EvolutionsReader fromMap ( Map < String , List < Evolution > > [[evolution]] ) { return new SimpleEvolutionsReader ( [[evolution]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 603 ---------------------------------------------
Creates a default evolution database.@param evolutions@return --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader forDefault ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[development]] . EvolutionsReader forDefault ( Evolution ... [[development]] ) { Map < String , List < Evolution > > map = new HashMap < String , List < Evolution > > ( ) ; map . put ( "default" , Arrays . asList ( [[development]] ) ) ; return fromMap ( map ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 604 ---------------------------------------------
Creates a binding from the given provider. --> [[[FAILED]]]

[[[[Adv]]]]: public < P [[extends]] Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P [[broaden]] Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[supplier]] ) { return underlying . toProvider ( [[supplier]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 605 ---------------------------------------------
Creates a 5-element HMM tuple. --> [[[FAILED]]]

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C [[c]] , D [[d]] , E [[e]] ) { return new Tuple5 < A , B , C , D , E > ( a , b , [[c]] , [[d]] , [[e]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C [[blow]] , D [[cholecalciferol]] , E [[east]] ) { return new Tuple5 < A , B , C , D , E > ( a , b , [[blow]] , [[cholecalciferol]] , [[east]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 606 ---------------------------------------------
Returns the preferred language for the specified application. --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[opt]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 607 ---------------------------------------------
Convenience method to flash. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String key , String value ) { [[flash]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[twinkle]] ( String key , String value ) { [[twinkle]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 608 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 577 / 16 / 608:  61%|██████    | 608/1000 [19:42<12:42,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 577 / 16 / 608:  61%|██████    | 609/1000 [19:43<12:40,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 578 / 16 / 609:  61%|██████    | 609/1000 [19:43<12:40,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 578 / 16 / 609:  61%|██████    | 610/1000 [19:45<12:38,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 579 / 16 / 610:  61%|██████    | 610/1000 [19:45<12:38,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 579 / 16 / 610:  61%|██████    | 611/1000 [19:47<12:36,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 580 / 16 / 611:  61%|██████    | 611/1000 [19:47<12:36,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 580 / 16 / 611:  61%|██████    | 612/1000 [19:50<12:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 581 / 16 / 612:  61%|██████    | 612/1000 [19:50<12:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 581 / 16 / 612:  61%|██████▏   | 613/1000 [19:52<12:32,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 582 / 16 / 613:  61%|██████▏   | 613/1000 [19:52<12:32,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 582 / 16 / 613:  61%|██████▏   | 614/1000 [19:53<12:30,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 583 / 16 / 614:  61%|██████▏   | 614/1000 [19:53<12:30,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 583 / 16 / 614:  62%|██████▏   | 615/1000 [19:54<12:27,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 584 / 16 / 615:  62%|██████▏   | 615/1000 [19:54<12:27,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 584 / 16 / 615:  62%|██████▏   | 616/1000 [19:56<12:26,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 585 / 16 / 616:  62%|██████▏   | 616/1000 [19:56<12:26,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 585 / 16 / 616:  62%|██████▏   | 617/1000 [19:57<12:23,  1.94s/it]Creates a new application builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withModuleLoader ( BiFunction < Environment , Config , List < GuiceableModule > > [[dockhand]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[dockhand]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 609 ---------------------------------------------
Evolve the evolution of the given database. --> [[[FAILED]]]

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions [[evolutions]] = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; [[evolutions]] . evolve ( [[evolutions]] . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions [[development]] = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; [[development]] . evolve ( [[development]] . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 610 ---------------------------------------------
Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 611 ---------------------------------------------
Encodes the given cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder buf = new StringBuilder ( ) ; encode ( buf , cookie ) ; return stripTrailingSeparator ( buf ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 612 ---------------------------------------------
Creates a new application builder with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder withConfigLoader ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( load . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 613 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[loading]] ( GuiceableModule ... [[faculty]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[faculty]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 614 ---------------------------------------------
Gets the entity manager stack. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > emStack ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 615 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[warhead]] ( com . google . inject . Module ... [[faculty]] ) { return [[warhead]] ( Guiceable . [[faculty]] ( [[faculty]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 616 ---------------------------------------------
Pushes an entity manager onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void pushOrPopEm ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 617 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 586 / 16 / 617:  62%|██████▏   | 617/1000 [19:57<12:23,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 586 / 16 / 617:  62%|██████▏   | 618/1000 [19:58<12:21,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 587 / 16 / 618:  62%|██████▏   | 618/1000 [19:58<12:21,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 587 / 16 / 618:  62%|██████▏   | 619/1000 [20:03<12:20,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 588 / 16 / 619:  62%|██████▏   | 619/1000 [20:03<12:20,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 588 / 16 / 619:  62%|██████▏   | 620/1000 [20:04<12:18,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 589 / 16 / 620:  62%|██████▏   | 620/1000 [20:04<12:18,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 589 / 16 / 620:  62%|██████▏   | 621/1000 [20:06<12:16,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 590 / 16 / 621:  62%|██████▏   | 621/1000 [20:06<12:16,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 590 / 16 / 621:  62%|██████▏   | 622/1000 [20:09<12:15,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 591 / 16 / 622:  62%|██████▏   | 622/1000 [20:09<12:15,  1.94s/it][Succeeded / Failed / Skipped / Total] 15 / 591 / 16 / 622:  62%|██████▏   | 623/1000 [20:14<12:14,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 592 / 16 / 623:  62%|██████▏   | 623/1000 [20:14<12:14,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 592 / 16 / 623:  62%|██████▏   | 624/1000 [20:17<12:13,  1.95s/it]Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[dilute]] ( play . api . inject . Module ... [[faculty]] ) { return [[dilute]] ( Guiceable . [[faculty]] ( [[faculty]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 618 ---------------------------------------------
Creates a new EntityManager. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > ems = this . emStack ( "[[avowedly]]" == "[[avowedly]]" ) ; if ( ems . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return ems . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 619 ---------------------------------------------
Checks if the given class array is assignable to the given toClassArray.@param classArray the class array to check.@param toClassArray the toClassArray to check.@param autoboxing true if the class array should be autoboxed.@return true if the class array is assignable to the given toClassArray. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[i]] = 0 ; [[i]] < classArray . length ; [[i]] ++ ) { if ( isAssignable ( classArray [ [[i]] ] , toClassArray [ [[i]] ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean isAssignable ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[ane]] = 0 ; [[ane]] < classArray . length ; [[ane]] ++ ) { if ( isAssignable ( classArray [ [[ane]] ] , toClassArray [ [[ane]] ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[dependable]]" == "[[dependable]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 620 ---------------------------------------------
Returns a list of global validation errors. --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > globalErrors ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 621 ---------------------------------------------
Converts errors to JSON. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode errorsAsJson ( Lang lang ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( lang , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 622 ---------------------------------------------
Converts an array of arguments to a list of errors. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Object > convertErrorArguments ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > convertErrorArguments ( Object [ ] [[tilt]] ) { if ( [[tilt]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[tilt]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 623 ---------------------------------------------
Loads the specified bindings. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... [[bindings]] ) { return load ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder load ( play . api . inject . Binding < ? > ... [[back]] ) { return load ( Guiceable . [[back]] ( [[back]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 624 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 593 / 16 / 624:  62%|██████▏   | 624/1000 [20:17<12:13,  1.95s/it][Succeeded / Failed / Skipped / Total] 15 / 593 / 16 / 624:  62%|██████▎   | 625/1000 [20:24<12:14,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 594 / 16 / 625:  62%|██████▎   | 625/1000 [20:24<12:14,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 594 / 16 / 625:  63%|██████▎   | 626/1000 [20:26<12:12,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 595 / 16 / 626:  63%|██████▎   | 626/1000 [20:26<12:12,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 595 / 16 / 626:  63%|██████▎   | 627/1000 [20:26<12:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 596 / 16 / 627:  63%|██████▎   | 627/1000 [20:26<12:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 596 / 16 / 627:  63%|██████▎   | 628/1000 [20:31<12:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 597 / 16 / 628:  63%|██████▎   | 628/1000 [20:31<12:09,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 597 / 16 / 628:  63%|██████▎   | 629/1000 [20:33<12:07,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 598 / 16 / 629:  63%|██████▎   | 629/1000 [20:33<12:07,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 598 / 16 / 629:  63%|██████▎   | 630/1000 [20:34<12:04,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 599 / 16 / 630:  63%|██████▎   | 630/1000 [20:34<12:04,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 599 / 16 / 630:  63%|██████▎   | 631/1000 [20:38<12:03,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 600 / 16 / 631:  63%|██████▎   | 631/1000 [20:38<12:03,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 600 / 16 / 631:  63%|██████▎   | 632/1000 [20:47<12:06,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 601 / 16 / 632:  63%|██████▎   | 632/1000 [20:47<12:06,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 601 / 16 / 632:  63%|██████▎   | 633/1000 [20:52<12:06,  1.98s/it]Fills the form with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[fulfil]] ( T [[respect]] ) { if ( [[respect]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[respect]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 625 ---------------------------------------------
Parses the given text and converts it to the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[tetraiodothyronine]] > [[tetraiodothyronine]] parse ( String text , Class < [[tetraiodothyronine]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 626 ---------------------------------------------
Returns the value associated with the given key. --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[assess]] ( String [[discover]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[discover]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 627 ---------------------------------------------
Converts the supplied text into an object of the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 628 ---------------------------------------------
Converts the specified object to a string. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[string]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[string]] . class ) ) { return conversion . convert ( t , [[string]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 629 ---------------------------------------------
Prints a field to the console.@param field the field to print@param t the object to print@return the string representation of the field --> [[[FAILED]]]

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > String print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 630 ---------------------------------------------
Prints the given type descriptor.@param desc the type descriptor@param t the t@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[train]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[train]] . class ) ) ) { return ( [[train]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[train]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[train]] . class ) ) { return conversion . convert ( t , [[train]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 631 ---------------------------------------------
Registers an optional converter. --> [[[FAILED]]]

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 632 ---------------------------------------------
Registers a formatter for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 633 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 602 / 16 / 633:  63%|██████▎   | 633/1000 [20:52<12:06,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 602 / 16 / 633:  63%|██████▎   | 634/1000 [20:53<12:03,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 603 / 16 / 634:  63%|██████▎   | 634/1000 [20:53<12:03,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 603 / 16 / 634:  64%|██████▎   | 635/1000 [20:53<12:00,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 604 / 16 / 635:  64%|██████▎   | 635/1000 [20:53<12:00,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 604 / 16 / 635:  64%|██████▎   | 636/1000 [20:57<11:59,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 605 / 16 / 636:  64%|██████▎   | 636/1000 [20:57<11:59,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 605 / 16 / 636:  64%|██████▎   | 637/1000 [20:57<11:56,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 606 / 16 / 637:  64%|██████▎   | 637/1000 [20:57<11:56,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 607 / 16 / 638:  64%|██████▍   | 638/1000 [20:57<11:53,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 607 / 16 / 638:  64%|██████▍   | 639/1000 [21:01<11:52,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 608 / 16 / 639:  64%|██████▍   | 639/1000 [21:01<11:52,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 609 / 16 / 640:  64%|██████▍   | 640/1000 [21:10<11:54,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 609 / 16 / 640:  64%|██████▍   | 641/1000 [21:12<11:52,  1.99s/it]Creates a new Flow with the specified splitter.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <Out>@param splitter@param <Out>@return --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < FlowIn , Out > > splitter , Flow < FlowIn , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 634 ---------------------------------------------
Encodes the cookie.@param cookie the cookie@return the encoded cookie --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[name]] = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( [[name]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , [[name]] , value ) ; } else { add ( buf , [[name]] , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String [[cite]] = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( [[cite]] , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , [[cite]] , value ) ; } else { add ( buf , [[cite]] , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 635 ---------------------------------------------
Creates a new dynamic form. --> [[[FAILED]]]

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > [[value]] ) { Form < Dynamic > [[form]] = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( [[form]] . rawData ( ) , [[form]] . files ( ) , [[form]] . errors ( ) , [[form]] . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[meet]] ( Map < String , Object > [[appraise]] ) { Form < Dynamic > [[manakin]] = super . fill ( new Dynamic ( [[appraise]] ) ) ; return new DynamicForm ( [[manakin]] . rawData ( ) , [[manakin]] . files ( ) , [[manakin]] . errors ( ) , [[manakin]] . [[appraise]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 636 ---------------------------------------------
Creates a sequence of values from an array. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[range]] ) { return toSeq ( [[range]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 637 ---------------------------------------------
Converts an array into an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] [[array]] ) { return toSeq ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( T [ ] [[align]] ) { return toSeq ( java . util . Arrays . asList ( [[align]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 638 ---------------------------------------------
Selects nodes in the specified path from the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: public static NodeList selectNodes ( String [[path]] , Object node ) { return selectNodes ( [[path]] , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList selectNodes ( String [[route]] , Object node ) { return selectNodes ( [[route]] , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 639 ---------------------------------------------
Converts a list of objects to an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > [[number]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[number]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 640 ---------------------------------------------
Computes the cost of a primitive promotion.@param srcClass the source class@param destClass the destination class@return the cost --> [[[FAILED]]]

[[[[Adv]]]]: private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > [[cls]] = srcClass ; if ( ! [[cls]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float getPrimitivePromotionCost ( final Class < ? > srcClass , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > [[centiliter]] = srcClass ; if ( ! [[centiliter]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 641 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 610 / 16 / 641:  64%|██████▍   | 641/1000 [21:12<11:52,  1.99s/it][Succeeded / Failed / Skipped / Total] 15 / 610 / 16 / 641:  64%|██████▍   | 642/1000 [21:13<11:50,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 611 / 16 / 642:  64%|██████▍   | 642/1000 [21:13<11:50,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 611 / 16 / 642:  64%|██████▍   | 643/1000 [21:15<11:47,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 612 / 16 / 643:  64%|██████▍   | 643/1000 [21:15<11:47,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 612 / 16 / 643:  64%|██████▍   | 644/1000 [21:15<11:45,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 613 / 16 / 644:  64%|██████▍   | 644/1000 [21:15<11:45,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 613 / 16 / 644:  64%|██████▍   | 645/1000 [21:17<11:43,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 614 / 16 / 645:  64%|██████▍   | 645/1000 [21:17<11:43,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 614 / 16 / 645:  65%|██████▍   | 646/1000 [21:20<11:41,  1.98s/it]Creates a new WebSocket. --> [[[FAILED]]]

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > WebSocket acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new WebSocket ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 642 ---------------------------------------------
Calculates the total cost of the given executable. --> [[[FAILED]]]

[[[[Adv]]]]: private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable [[executable]] ) { final Class < ? > [ ] destArgs = [[executable]] . getParameterTypes ( ) ; final boolean isVarArgs = [[executable]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float getTotalTransformationCost ( final Class < ? > [ ] srcArgs , final Executable [[practicable]] ) { final Class < ? > [ ] destArgs = [[practicable]] . getParameterTypes ( ) ; final boolean isVarArgs = [[practicable]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 643 ---------------------------------------------
Creates a MappedWebSocket acceptor for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > json ( Class < [[In]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[IN]] , Out > MappedWebSocketAcceptor < [[IN]] , Out > json ( Class < [[IN]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 644 ---------------------------------------------
Creates a new Flow from a Graph.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , FlowIn , [[Out]] > Flow < In , [[Out]] , ? > bypassWith ( Flow < In , F . Either < FlowIn , [[Out]] > , ? > splitter , Graph < UniformFanInShape < [[Out]] , [[Out]] > , ? > mergeStrategy , Flow < FlowIn , [[Out]] , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , [[Out]] > , [[Out]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , [[prohibited]] > Flow < In , [[prohibited]] , ? > bypassWith ( Flow < In , F . Either < FlowIn , [[prohibited]] > , ? > splitter , Graph < UniformFanInShape < [[prohibited]] , [[prohibited]] > , ? > mergeStrategy , Flow < FlowIn , [[prohibited]] , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , [[prohibited]] > , [[prohibited]] > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 645 ---------------------------------------------
Creates a new database from the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database createFrom ( String driver , String url , Map < String , ? extends Object > config ) { return createFrom ( "default" , driver , url , config ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 646 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 615 / 16 / 646:  65%|██████▍   | 646/1000 [21:20<11:41,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 615 / 16 / 646:  65%|██████▍   | 647/1000 [21:21<11:38,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 616 / 16 / 647:  65%|██████▍   | 647/1000 [21:21<11:38,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 616 / 16 / 647:  65%|██████▍   | 648/1000 [21:25<11:38,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 617 / 16 / 648:  65%|██████▍   | 648/1000 [21:25<11:38,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 617 / 16 / 648:  65%|██████▍   | 649/1000 [21:26<11:35,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 618 / 16 / 649:  65%|██████▍   | 649/1000 [21:26<11:35,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 618 / 16 / 649:  65%|██████▌   | 650/1000 [21:27<11:33,  1.98s/it]Register an annotation converter.@param <A> the type parameter@param <T> the type parameter@param clazz the clazz@param formatter the formatter@return the Formatters --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[a]] = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( [[a]] , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[a]] = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( [[a]] , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[angstrom]] = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( [[angstrom]] , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A [[angstrom]] = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( [[angstrom]] , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 647 ---------------------------------------------
Creates a new parallel sorter. --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter create ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 648 ---------------------------------------------
Creates a play flow. --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , [[Out]] > Flow < In , [[Out]] , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer [[mat]] ) { return play . api . libs . streams . ActorFlow . < In , [[Out]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , [[mat]] ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , [[stunned]] > Flow < In , [[stunned]] , ? > actorRef ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer [[matt]] ) { return play . api . libs . streams . ActorFlow . < In , [[stunned]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , bufferSize , overflowStrategy , factory , [[matt]] ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 649 ---------------------------------------------
Returns the message at the specified keys@param keys@param args@return --> [[[FAILED]]]

[[[[Adv]]]]: public String [[at]] ( List < String > [[keys]] , Object ... args ) { return messagesApi . get ( lang , [[keys]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[astatine]] ( List < String > [[describe]] , Object ... args ) { return messagesApi . get ( lang , [[describe]] , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 619 / 16 / 650:  65%|██████▌   | 650/1000 [21:27<11:33,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 620 / 16 / 651:  65%|██████▌   | 651/1000 [21:27<11:30,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 620 / 16 / 651:  65%|██████▌   | 652/1000 [21:28<11:27,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 620 / 17 / 652:  65%|██████▌   | 652/1000 [21:28<11:27,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 621 / 17 / 653:  65%|██████▌   | 653/1000 [21:30<11:25,  1.98s/it][Succeeded / Failed / Skipped / Total] 15 / 621 / 17 / 653:  65%|██████▌   | 654/1000 [21:30<11:22,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 622 / 17 / 654:  65%|██████▌   | 654/1000 [21:30<11:22,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 623 / 17 / 655:  66%|██████▌   | 655/1000 [21:31<11:20,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 623 / 17 / 655:  66%|██████▌   | 656/1000 [21:34<11:18,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 624 / 17 / 656:  66%|██████▌   | 656/1000 [21:34<11:18,  1.97s/it]Cast a numeric type to another type. --> [[[FAILED]]]

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 651 ---------------------------------------------
Returns the message at the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... args ) { return messagesApi . get ( lang , [[key]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[astatine]] ( String [[describe]] , Object ... args ) { return messagesApi . get ( lang , [[describe]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 652 ---------------------------------------------
Emits a field instruction. --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
Loads an argument. --> [[[FAILED]]]

[[[[Adv]]]]: public void load_arg ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void load_arg ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 654 ---------------------------------------------
Puts the supplied type into the stack. --> [[[FAILED]]]

[[[[Adv]]]]: public void zero_or_null ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void zero_or_null ( Type [[eccentric]] ) { if ( TypeUtils . isPrimitive ( [[eccentric]] ) ) { switch ( [[eccentric]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 655 ---------------------------------------------
Invokes the specified method on the specified object. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[arouse]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo fci = fastClassInfo ; return fci . f1 . invoke ( fci . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 656 ---------------------------------------------
Performs a quick sort on the specified region. --> [[[FAILED]]]

[[[[Adv]]]]: public void quickSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void quickSort ( int index , int lo , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 657 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 625 / 17 / 657:  66%|██████▌   | 657/1000 [21:35<11:16,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 625 / 17 / 657:  66%|██████▌   | 658/1000 [21:35<11:13,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 626 / 17 / 658:  66%|██████▌   | 658/1000 [21:35<11:13,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 627 / 17 / 659:  66%|██████▌   | 659/1000 [21:37<11:11,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 627 / 17 / 659:  66%|██████▌   | 660/1000 [21:38<11:08,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 628 / 17 / 660:  66%|██████▌   | 660/1000 [21:38<11:08,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 629 / 17 / 661:  66%|██████▌   | 661/1000 [21:38<11:05,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 629 / 17 / 661:  66%|██████▌   | 662/1000 [21:43<11:05,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 630 / 17 / 662:  66%|██████▌   | 662/1000 [21:43<11:05,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 631 / 17 / 663:  66%|██████▋   | 663/1000 [21:44<11:02,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 631 / 17 / 663:  66%|██████▋   | 664/1000 [21:44<11:00,  1.97s/it]Returns the cost of an object transformation. --> [[[FAILED]]]

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 658 ---------------------------------------------
Merges the specified sort region into the specified region. --> [[[FAILED]]]

[[[[Adv]]]]: public void mergeSort ( int [[index]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void mergeSort ( int [[forefinger]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[forefinger]] , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 659 ---------------------------------------------
Unbox a boxed type. --> [[[FAILED]]]

[[[[Adv]]]]: public void unbox_or_zero ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { if ( [[type]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[type]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[type]] ) ; mark ( end ) ; } } else { checkcast ( [[type]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void unbox_or_zero ( Type [[typecast]] ) { if ( TypeUtils . isPrimitive ( [[typecast]] ) ) { if ( [[typecast]] != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( [[typecast]] ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( [[typecast]] ) ; mark ( end ) ; } } else { checkcast ( [[typecast]] ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 660 ---------------------------------------------
Sets the superclass of this object. --> [[[FAILED]]]

[[[[Adv]]]]: public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . superclass = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 661 ---------------------------------------------
Returns a list of all methods of the specified superclass andinterfaces. --> [[[FAILED]]]

[[[[Adv]]]]: public static void getMethods ( Class superclass , Class [ ] [[interfaces]] , List [[methods]] ) { getMethods ( superclass , [[interfaces]] , [[methods]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void getMethods ( Class superclass , Class [ ] [[port]] , List [[method]] ) { getMethods ( superclass , [[port]] , [[method]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 662 ---------------------------------------------
Compare two nulls. --> [[[FAILED]]]

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 663 ---------------------------------------------
Adds the specified method to this class. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Method method ) { [[add]] ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[bestow]] ( Method method ) { [[bestow]] ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 664 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 632 / 17 / 664:  66%|██████▋   | 664/1000 [21:44<11:00,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 632 / 18 / 665:  66%|██████▋   | 665/1000 [21:45<10:57,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 632 / 18 / 665:  67%|██████▋   | 666/1000 [21:47<10:55,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 633 / 18 / 666:  67%|██████▋   | 666/1000 [21:47<10:55,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 634 / 18 / 667:  67%|██████▋   | 667/1000 [21:48<10:53,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 634 / 18 / 667:  67%|██████▋   | 668/1000 [21:52<10:52,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 635 / 18 / 668:  67%|██████▋   | 668/1000 [21:52<10:52,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 636 / 18 / 669:  67%|██████▋   | 669/1000 [21:53<10:49,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 636 / 18 / 669:  67%|██████▋   | 670/1000 [21:56<10:48,  1.97s/it][Succeeded / Failed / Skipped / Total] 15 / 637 / 18 / 670:  67%|██████▋   | 670/1000 [21:56<10:48,  1.97s/it]Sets the naming policy. --> [[[FAILED]]]

[[[[Adv]]]]: public void setNamingPolicy ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void setNamingPolicy ( NamingPolicy namingPolicy ) { if ( namingPolicy == null ) namingPolicy = DefaultNamingPolicy . INSTANCE ; this . namingPolicy = namingPolicy ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 665 ---------------------------------------------
Finds the methods in the specified names and descriptors. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
Process an array type. --> [[[FAILED]]]

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[e]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[e]] . make_local ( ) ; Local loopvar = [[e]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[e]] . make_label ( ) ; Label checkloop = [[e]] . make_label ( ) ; [[e]] . store_local ( array ) ; [[e]] . push ( 0 ) ; [[e]] . store_local ( loopvar ) ; [[e]] . goTo ( checkloop ) ; [[e]] . mark ( loopbody ) ; [[e]] . load_local ( array ) ; [[e]] . load_local ( loopvar ) ; [[e]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[e]] . iinc ( loopvar , 1 ) ; [[e]] . mark ( checkloop ) ; [[e]] . load_local ( loopvar ) ; [[e]] . load_local ( array ) ; [[e]] . arraylength ( ) ; [[e]] . if_icmp ( [[e]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void process_array ( CodeEmitter [[east]] , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = [[east]] . make_local ( ) ; Local loopvar = [[east]] . make_local ( Type . INT_TYPE ) ; Label loopbody = [[east]] . make_label ( ) ; Label checkloop = [[east]] . make_label ( ) ; [[east]] . store_local ( array ) ; [[east]] . push ( 0 ) ; [[east]] . store_local ( loopvar ) ; [[east]] . goTo ( checkloop ) ; [[east]] . mark ( loopbody ) ; [[east]] . load_local ( array ) ; [[east]] . load_local ( loopvar ) ; [[east]] . array_load ( componentType ) ; callback . processElement ( componentType ) ; [[east]] . iinc ( loopvar , 1 ) ; [[east]] . mark ( checkloop ) ; [[east]] . load_local ( loopvar ) ; [[east]] . load_local ( array ) ; [[east]] . arraylength ( ) ; [[east]] . if_icmp ( [[east]] . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 667 ---------------------------------------------
Filter out constructors that are not visible to the user. --> [[[FAILED]]]

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "[[True]]" == "[[True]]" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List constructors ) { CollectionUtils . filter ( constructors , new VisibilityPredicate ( sc , "[[admittedly]]" == "[[admittedly]]" ) ) ; if ( constructors . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 668 ---------------------------------------------
Computes the cardinality of this vector. --> [[[FAILED]]]

[[[[Adv]]]]: public int cardinality ( ) { int [[w]] = value ; int [[c]] = 0 ; while ( [[w]] != 0 ) { [[c]] += T [ [[w]] & 255 ] ; [[w]] >>= 8 ; } return [[c]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int cardinality ( ) { int [[watt]] = value ; int [[blow]] = 0 ; while ( [[watt]] != 0 ) { [[blow]] += T [ [[watt]] & 255 ] ; [[watt]] >>= 8 ; } return [[blow]] ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 669 ---------------------------------------------
Reads a string from the specified file. --> [[[FAILED]]]

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path path ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( path , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 670 ---------------------------------------------
Creates a new HTTP request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String destination ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( destination ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 671 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 638 / 18 / 671:  67%|██████▋   | 671/1000 [21:58<10:46,  1.96s/it][Succeeded / Failed / Skipped / Total] 15 / 638 / 18 / 671:  67%|██████▋   | 672/1000 [21:58<10:43,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 638 / 18 / 672:  67%|██████▋   | 672/1000 [21:58<10:43,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 639 / 18 / 673:  67%|██████▋   | 673/1000 [21:58<10:40,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 639 / 18 / 673:  67%|██████▋   | 674/1000 [22:01<10:39,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 640 / 18 / 674:  67%|██████▋   | 674/1000 [22:01<10:39,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 641 / 18 / 675:  68%|██████▊   | 675/1000 [22:04<10:37,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 641 / 18 / 675:  68%|██████▊   | 676/1000 [22:07<10:36,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 642 / 18 / 676:  68%|██████▊   | 676/1000 [22:07<10:36,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 643 / 18 / 677:  68%|██████▊   | 677/1000 [22:08<10:33,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 643 / 18 / 677:  68%|██████▊   | 678/1000 [22:09<10:31,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 644 / 18 / 678:  68%|██████▊   | 678/1000 [22:09<10:31,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 645 / 18 / 679:  68%|██████▊   | 679/1000 [22:10<10:28,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 645 / 18 / 679:  68%|██████▊   | 680/1000 [22:14<10:28,  1.96s/it]Sets the workaround for the given object. --> [[[FAILED]]]

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject [[o]] ) { if ( [[o]] == null || [[o]] . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) [[o]] ; if ( ! [[o]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[o]] . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean setAccessibleWorkaround ( final AccessibleObject [[oxygen]] ) { if ( [[oxygen]] == null || [[oxygen]] . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) [[oxygen]] ; if ( ! [[oxygen]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[oxygen]] . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 672 ---------------------------------------------
Generate code to retrieve a field.@param names the names of the fields to retrieve. --> Generate a GETFIELD instruction. --> Socre: 1.0

[[[[Adv]]]]: private void getField ( String [ ] [[names]] ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , [[names]] , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities

[[[[Adv]]]]: private void getField ( String [ ] [[advert]] ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , [[advert]] , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 673 ---------------------------------------------
Resolves all classes in the classpath. --> [[[FAILED]]]

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map resolveAll ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 674 ---------------------------------------------
Connects to the specified destination. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest connect ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest connect ( final String [[goal]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[goal]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 675 ---------------------------------------------
Sets the host for the request. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[legion]] ( final String [[innkeeper]] ) { this . [[Host]] = [[legion]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[legion]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 676 ---------------------------------------------
Creates a DELETE request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[cancel]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 677 ---------------------------------------------
Creates a PUT request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[arrange]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 678 ---------------------------------------------
Creates a new HTTP PATCH request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[bandage]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 679 ---------------------------------------------
Create a POST request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[carry]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 680 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 646 / 18 / 680:  68%|██████▊   | 680/1000 [22:14<10:28,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 647 / 18 / 681:  68%|██████▊   | 681/1000 [22:16<10:26,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 647 / 18 / 681:  68%|██████▊   | 682/1000 [22:20<10:25,  1.97s/it][Succeeded / Failed / Skipped / Total] 16 / 648 / 18 / 682:  68%|██████▊   | 682/1000 [22:20<10:25,  1.97s/it][Succeeded / Failed / Skipped / Total] 16 / 649 / 18 / 683:  68%|██████▊   | 683/1000 [22:21<10:22,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 649 / 18 / 683:  68%|██████▊   | 684/1000 [22:22<10:20,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 650 / 18 / 684:  68%|██████▊   | 684/1000 [22:22<10:20,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 651 / 18 / 685:  68%|██████▊   | 685/1000 [22:22<10:17,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 651 / 18 / 685:  69%|██████▊   | 686/1000 [22:22<10:14,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 652 / 18 / 686:  69%|██████▊   | 686/1000 [22:22<10:14,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 653 / 18 / 687:  69%|██████▊   | 687/1000 [22:23<10:12,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 653 / 18 / 687:  69%|██████▉   | 688/1000 [22:26<10:10,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 654 / 18 / 688:  69%|██████▉   | 688/1000 [22:26<10:10,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 655 / 18 / 689:  69%|██████▉   | 689/1000 [22:26<10:07,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 655 / 18 / 689:  69%|██████▉   | 690/1000 [22:28<10:05,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 656 / 18 / 690:  69%|██████▉   | 690/1000 [22:28<10:05,  1.95s/it]Create an OPTIONS request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[alternative]] ( final String [[finish]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[finish]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 681 ---------------------------------------------
Sets the request path. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[track]] ( String [[itinerary]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 682 ---------------------------------------------
Creates a new request with the specified destination. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest trace ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest trace ( final String [[finish]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[finish]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 683 ---------------------------------------------
Creates a new HTTP HEAD request. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[header]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 684 ---------------------------------------------
Executes the supplied query string. --> [[[FAILED]]]

[[[[Adv]]]]: public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String queryString ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 685 ---------------------------------------------
Creates a new request with the specified destination. --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest get ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 686 ---------------------------------------------
Resolve a child path.@param base the base path@param child the child path@return the resolved path --> [[[FAILED]]]

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[resoluteness]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 687 ---------------------------------------------
Creates a host URL string. --> [[[FAILED]]]

[[[[Adv]]]]: public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String hostUrl ( ) { StringBand url = new StringBand ( 8 ) ; if ( protocol != null ) { url . append ( protocol ) ; url . append ( "://" ) ; } if ( host != null ) { url . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { url . append ( ' ' ) ; url . append ( port ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 688 ---------------------------------------------
Sets the host header. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest setHostHeader ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 689 ---------------------------------------------
Sets the basic authentication header. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest basicAuthentication ( final String username , final String password ) { if ( username != null && password != null ) { String data = username . concat ( StringPool . COLON ) . concat ( password ) ; String base64 = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + base64 ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 690 ---------------------------------------------
Add query parameters to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entry]] : queryMap . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entryway]] : queryMap . entrySet ( ) ) { query . add ( [[entryway]] . getKey ( ) , [[entryway]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 691 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 657 / 18 / 691:  69%|██████▉   | 691/1000 [22:29<10:03,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 657 / 18 / 691:  69%|██████▉   | 692/1000 [22:30<10:01,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 658 / 18 / 692:  69%|██████▉   | 692/1000 [22:30<10:01,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 659 / 18 / 693:  69%|██████▉   | 693/1000 [22:30<09:58,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 659 / 18 / 693:  69%|██████▉   | 694/1000 [22:31<09:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 660 / 18 / 694:  69%|██████▉   | 694/1000 [22:31<09:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 661 / 18 / 695:  70%|██████▉   | 695/1000 [22:31<09:52,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 661 / 18 / 695:  70%|██████▉   | 696/1000 [22:31<09:50,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 662 / 18 / 696:  70%|██████▉   | 696/1000 [22:31<09:50,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 663 / 18 / 697:  70%|██████▉   | 697/1000 [22:31<09:47,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 663 / 18 / 697:  70%|██████▉   | 698/1000 [22:31<09:44,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 664 / 18 / 698:  70%|██████▉   | 698/1000 [22:31<09:44,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 665 / 18 / 699:  70%|██████▉   | 699/1000 [22:32<09:42,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 665 / 18 / 699:  70%|███████   | 700/1000 [22:33<09:39,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 666 / 18 / 700:  70%|███████   | 700/1000 [22:33<09:39,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 667 / 18 / 701:  70%|███████   | 701/1000 [22:40<09:40,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 667 / 18 / 701:  70%|███████   | 702/1000 [22:40<09:37,  1.94s/it]Sends the request and returns the response. --> [[[FAILED]]]

[[[[Adv]]]]: public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < R > R sendAndReceive ( final Function < HttpResponse , R > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 692 ---------------------------------------------
Collect the interceptors associated with this action. --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void collectActionInterceptors ( ) { final Collection < ? extends ActionInterceptor > interceptorValues = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( interceptorValues ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 693 ---------------------------------------------
Parse the query string and decode it.@param queryString the query string@param decode whether to decode the query string@return this request --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest queryString ( final String queryString , final boolean [[decode]] ) { this . [[query]] = HttpUtil . parseQuery ( queryString , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest queryString ( final String queryString , final boolean [[decipher]] ) { this . [[question]] = HttpUtil . parseQuery ( queryString , [[decipher]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 694 ---------------------------------------------
Collect action filters. --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void collectActionFilters ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 695 ---------------------------------------------
Collect the action results. --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void collectActionResults ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 696 ---------------------------------------------
Overrides the default behavior of this buffer. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[cowcatcher]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 697 ---------------------------------------------
Returns the number of entries in the exception table. --> [[[FAILED]]]

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int getExceptionTableLength ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 698 ---------------------------------------------
Sorts the list of actions. --> [[[FAILED]]]

[[[[Adv]]]]: protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void collectActionRuntimes ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 699 ---------------------------------------------
Returns a copy of this writer. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter getWriter ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 700 ---------------------------------------------
Extracts the property with the given name from this object. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String extractThisReference ( final String propertyName ) { int ndx = StringUtil . indexOfChars ( propertyName , INDEX_CHARS ) ; if ( ndx == - 1 ) { return propertyName ; } return propertyName . substring ( 0 , ndx ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 701 ---------------------------------------------
Sets the value of the specified property. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object [[value]] ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void setSimpleProperty ( final BeanProperty bp , final Object [[respect]] ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 702 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 668 / 18 / 702:  70%|███████   | 702/1000 [22:40<09:37,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 669 / 18 / 703:  70%|███████   | 703/1000 [22:45<09:37,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 669 / 18 / 703:  70%|███████   | 704/1000 [22:46<09:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 670 / 18 / 704:  70%|███████   | 704/1000 [22:46<09:34,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 671 / 18 / 705:  70%|███████   | 705/1000 [22:48<09:32,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 671 / 18 / 705:  71%|███████   | 706/1000 [22:48<09:29,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 672 / 18 / 706:  71%|███████   | 706/1000 [22:48<09:29,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 673 / 18 / 707:  71%|███████   | 707/1000 [22:50<09:28,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 673 / 18 / 707:  71%|███████   | 708/1000 [22:54<09:27,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 674 / 18 / 708:  71%|███████   | 708/1000 [22:54<09:27,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 675 / 18 / 709:  71%|███████   | 709/1000 [22:56<09:24,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 675 / 18 / 709:  71%|███████   | 710/1000 [22:56<09:22,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 676 / 18 / 710:  71%|███████   | 710/1000 [22:56<09:22,  1.94s/it]Gets the property with the specified name.@param < T> the type parameter@param bean the bean@param name the name@return the property with the specified name --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < T > T getProperty ( final Object bean , final String name ) { BeanProperty beanProperty = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } else { try { resolveNestedProperties ( beanProperty ) ; return ( T ) getIndexProperty ( beanProperty ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 703 ---------------------------------------------
Gets the object reference for the supplied name.@param name the name of the object.@return the object reference for the supplied name. --> [[[FAILED]]]

[[[[Adv]]]]: public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object getObjectReference ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Sets the object reference.@param name the name of the object@param object the object --> [[[FAILED]]]

[[[[Adv]]]]: public void setObjectReference ( final String [[name]] , final Object [[object]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , [[object]] ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void setObjectReference ( final String [[diagnose]] , final Object [[target]] ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[diagnose]] , [[target]] ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 705 ---------------------------------------------
Lookup an object reference. --> [[[FAILED]]]

[[[[Adv]]]]: public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object lookupObject ( final String ref ) { Object value = getObjectReference ( ref ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + ref ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 706 ---------------------------------------------
Returns the descriptor for the specified table. --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( tableRef ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor getTableDescriptor ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData [[MT]] = tableRefs . get ( tableRef ) ; return [[MT]] == null ? null : [[MT]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 707 ---------------------------------------------
Looks up the table descriptor for the given table. --> [[[FAILED]]]

[[[[Adv]]]]: protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( tableRef ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor lookupTableRef ( final String tableRef ) { DbEntityDescriptor [[DEd]] = getTableDescriptor ( tableRef ) ; if ( [[DEd]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return [[DEd]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 708 ---------------------------------------------
Get the alias for the specified table.@param tableRef the name of the table.@return the alias for the specified table. --> [[[FAILED]]]

[[[[Adv]]]]: public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String getTableAlias ( final String tableRef ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( tableRef ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 709 ---------------------------------------------
Find the table descriptor by column ref.@param columnRef the column ref@return the descriptor or <code>null</code> --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String columnRef ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = entry . getValue ( ) . desc ; if ( ded . findByPropertyName ( columnRef ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 710 ---------------------------------------------
Registers a table reference. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void registerTableReference ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 711 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 677 / 18 / 711:  71%|███████   | 711/1000 [22:56<09:19,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 677 / 18 / 711:  71%|███████   | 712/1000 [22:57<09:17,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 678 / 18 / 712:  71%|███████   | 712/1000 [22:57<09:17,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 679 / 18 / 713:  71%|███████▏  | 713/1000 [22:58<09:14,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 679 / 18 / 713:  71%|███████▏  | 714/1000 [23:01<09:13,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 680 / 18 / 714:  71%|███████▏  | 714/1000 [23:01<09:13,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 681 / 18 / 715:  72%|███████▏  | 715/1000 [23:02<09:10,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 681 / 18 / 715:  72%|███████▏  | 716/1000 [23:02<09:08,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 682 / 18 / 716:  72%|███████▏  | 716/1000 [23:02<09:08,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 683 / 18 / 717:  72%|███████▏  | 717/1000 [23:07<09:07,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 683 / 18 / 717:  72%|███████▏  | 718/1000 [23:15<09:08,  1.94s/it]Registers a hint. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerHint ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void registerHint ( final String [[trace]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[trace]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 712 ---------------------------------------------
Add a cookie to the request.@param REPLACEME0 the cookie to add --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean [[first]] = "[[True]]" == "[[True]]" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! [[first]] ) { cookieString . append ( "; " ) ; } [[first]] = "[[False]]" != "[[False]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder cookieString = new StringBuilder ( ) ; boolean [[1st]] = "[[truthful]]" == "[[truthful]]" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! [[1st]] ) { cookieString . append ( "; " ) ; } [[1st]] = "[[faithlessly]]" != "[[faithlessly]]" ; cookieString . append ( cookie . getName ( ) ) ; cookieString . append ( ' ' ) ; cookieString . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , cookieString . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 713 ---------------------------------------------
Converts a property name to a column name. --> [[[FAILED]]]

[[[[Adv]]]]: public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String convertPropertyNameToColumnName ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 714 ---------------------------------------------
Sets the query parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String [[value]] = parameters [ i + 1 ] . toString ( ) ; query . add ( name , [[value]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String name1 , final Object value1 , final Object ... parameters ) { query ( name1 , value1 == null ? null : value1 . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String name = parameters [ i ] . toString ( ) ; String [[assess]] = parameters [ i + 1 ] . toString ( ) ; query . add ( name , [[assess]] ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
--------------------------------------------- Result 715 ---------------------------------------------
Removes a range handler.@param firstHandler the first handler@param start the range start@param end the range end@return the handler that was removed --> [[[FAILED]]]

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label [[start]] , final Label [[end]] ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , [[start]] , [[end]] ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = [[start]] . bytecodeOffset ; int rangeEnd = [[end]] == null ? Integer . MAX_VALUE : [[end]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler removeRange ( final Handler firstHandler , final Label [[outset]] , final Label [[remnant]] ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = removeRange ( firstHandler . nextHandler , [[outset]] , [[remnant]] ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = [[outset]] . bytecodeOffset ; int rangeEnd = [[remnant]] == null ? Integer . MAX_VALUE : [[remnant]] . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 716 ---------------------------------------------
Converts the supplied column name to the supplied property name. --> [[[FAILED]]]

[[[[Adv]]]]: public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String applyToColumnName ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 717 ---------------------------------------------
Converts the supplied object to the specified destination type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[einsteinium]] > [[einsteinium]] prepareGetValue ( final T t , final Class < [[einsteinium]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[einsteinium]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 718 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 684 / 18 / 718:  72%|███████▏  | 718/1000 [23:15<09:08,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 684 / 18 / 718:  72%|███████▏  | 719/1000 [23:24<09:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 685 / 18 / 719:  72%|███████▏  | 719/1000 [23:24<09:08,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 685 / 18 / 719:  72%|███████▏  | 720/1000 [23:27<09:07,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 686 / 18 / 720:  72%|███████▏  | 720/1000 [23:27<09:07,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 686 / 18 / 720:  72%|███████▏  | 721/1000 [23:30<09:05,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 687 / 18 / 721:  72%|███████▏  | 721/1000 [23:30<09:05,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 687 / 18 / 721:  72%|███████▏  | 722/1000 [23:31<09:03,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 688 / 18 / 722:  72%|███████▏  | 722/1000 [23:31<09:03,  1.95s/it]Serializes the given value to the given JSON context. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public final boolean [[serialize]] ( final JsonContext jsonContext , final T [[value]] ) { if ( jsonContext . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean [[serialise]] ( final JsonContext jsonContext , final T [[esteem]] ) { if ( jsonContext . pushValue ( [[esteem]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 719 ---------------------------------------------
Inject attributes.@param servletRequest the servlet request@param targets the targets --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[[True]]" == "[[True]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void injectAttributes ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > attributeNames = servletRequest . getAttributeNames ( ) ; while ( attributeNames . hasMoreElements ( ) ) { final String attrName = attributeNames . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[[honest]]" == "[[honest]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 720 ---------------------------------------------
Resolves the specified wrapper class. --> [[[FAILED]]]

[[[[Adv]]]]: public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T resolve ( final Class < ? extends T > wrapperClass ) { String wrapperClassName = wrapperClass . getName ( ) ; T wrapper = lookup ( wrapperClassName ) ; if ( wrapper == null ) { wrapper = createWrapper ( wrapperClass ) ; initializeWrapper ( wrapper ) ; wrappers . put ( wrapperClassName , wrapper ) ; } return wrapper ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 721 ---------------------------------------------
Converts a column name to a property name. --> [[[FAILED]]]

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "[[False]]" != "[[False]]" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "[[False]]" != "[[False]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "[[fictive]]" != "[[fictive]]" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "[[fictive]]" != "[[fictive]]" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 722 ---------------------------------------------
Injects all uploaded files into the specified targets. --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets [[targets]] ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } [[targets]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets [[direct]] ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } [[direct]] . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 723 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 689 / 18 / 723:  72%|███████▏  | 723/1000 [23:31<09:00,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 689 / 18 / 723:  72%|███████▏  | 724/1000 [23:32<08:58,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 690 / 18 / 724:  72%|███████▏  | 724/1000 [23:32<08:58,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 691 / 18 / 725:  72%|███████▎  | 725/1000 [23:32<08:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 691 / 18 / 725:  73%|███████▎  | 726/1000 [23:33<08:53,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 692 / 18 / 726:  73%|███████▎  | 726/1000 [23:33<08:53,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 693 / 18 / 727:  73%|███████▎  | 727/1000 [23:33<08:50,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 693 / 18 / 727:  73%|███████▎  | 728/1000 [23:34<08:48,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 694 / 18 / 728:  73%|███████▎  | 728/1000 [23:34<08:48,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 695 / 18 / 729:  73%|███████▎  | 729/1000 [23:34<08:45,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 695 / 18 / 729:  73%|███████▎  | 730/1000 [23:35<08:43,  1.94s/it]Inject parameters.@param servletRequest the servlet request@param targets the targets --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 724 ---------------------------------------------
Relative path.@param targetPath the target path@param basePath the base path@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String relativePath ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 725 ---------------------------------------------
Converts a path to a system separator.@param path the path to convert.@return the system separator. --> [[[FAILED]]]

[[[[Adv]]]]: public static String separatorsToSystem ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String separatorsToSystem ( final String [[route]] ) { if ( [[route]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[route]] ) ; } else { return separatorsToUnix ( [[route]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 726 ---------------------------------------------
Returns the set of all wrappers. --> [[[FAILED]]]

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > getAll ( ) { final Set < T > [[countersink]] = new HashSet <> ( wrappers . size ( ) ) ; [[countersink]] . addAll ( wrappers . values ( ) ) ; return [[countersink]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 727 ---------------------------------------------
Registers a madvoc component. --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > madvocComponent ) { Objects . requireNonNull ( madvocComponent ) ; madvocComponents . add ( ClassConsumer . of ( madvocComponent ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 728 ---------------------------------------------
Sets the value at the specified index. --> [[[FAILED]]]

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object [[value]] , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( [[value]] , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void storeValue ( final PreparedStatement st , final int index , final Object [[rate]] , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( [[rate]] , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 729 ---------------------------------------------
Configures the default actions. --> [[[FAILED]]]

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void configureDefaults ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 730 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 696 / 18 / 730:  73%|███████▎  | 730/1000 [23:35<08:43,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 697 / 18 / 731:  73%|███████▎  | 731/1000 [23:36<08:41,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 697 / 18 / 731:  73%|███████▎  | 732/1000 [23:36<08:38,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 698 / 18 / 732:  73%|███████▎  | 732/1000 [23:36<08:38,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 699 / 18 / 733:  73%|███████▎  | 733/1000 [23:37<08:36,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 699 / 18 / 733:  73%|███████▎  | 734/1000 [23:37<08:33,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 700 / 18 / 734:  73%|███████▎  | 734/1000 [23:37<08:33,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 701 / 18 / 735:  74%|███████▎  | 735/1000 [23:37<08:31,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 701 / 18 / 735:  74%|███████▎  | 736/1000 [23:37<08:28,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 702 / 18 / 736:  74%|███████▎  | 736/1000 [23:37<08:28,  1.93s/it]Registers all madvoc components. --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void registerMadvocComponents ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 731 ---------------------------------------------
Excludes the specified jars from scanning.@param excludedJars the jars to exclude.@return this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner excludeJars ( final String ... excludedJars ) { for ( final String excludedJar : excludedJars ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 732 ---------------------------------------------
Includes the specified jars in the scanner.@param includedJars The jars to include.@return this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner includeJars ( final String ... includedJars ) { for ( final String includedJar : includedJars ) { rulesJars . include ( includedJar ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 733 ---------------------------------------------
Creates a wrapper for the given wrapper class. --> [[[FAILED]]]

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R extends T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 734 ---------------------------------------------
Includes the specified list of entries in this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner includeEntries ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 735 ---------------------------------------------
Gets the path to the specified filename.@param filename the filename@param separatorAdd the separator index@return the path --> [[[FAILED]]]

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int [[index]] = indexOfLastSeparator ( filename ) ; int endIndex = [[index]] + separatorAdd ; if ( prefix >= filename . length ( ) || [[index]] < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int separatorAdd ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int [[power]] = indexOfLastSeparator ( filename ) ; int endIndex = [[power]] + separatorAdd ; if ( prefix >= filename . length ( ) || [[power]] < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return filename . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 736 ---------------------------------------------
Excludes entries from this scanner.@param excludedEntries the entries to exclude.@return this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 737 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 703 / 18 / 737:  74%|███████▎  | 737/1000 [23:45<08:28,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 703 / 18 / 737:  74%|███████▍  | 738/1000 [23:47<08:26,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 704 / 18 / 738:  74%|███████▍  | 738/1000 [23:47<08:26,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 705 / 18 / 739:  74%|███████▍  | 739/1000 [23:48<08:24,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 705 / 18 / 739:  74%|███████▍  | 740/1000 [23:53<08:23,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 706 / 18 / 740:  74%|███████▍  | 740/1000 [23:53<08:23,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 707 / 18 / 741:  74%|███████▍  | 741/1000 [23:53<08:21,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 707 / 18 / 741:  74%|███████▍  | 742/1000 [23:54<08:18,  1.93s/it]Starts the web application. --> [[[FAILED]]]

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[get]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 738 ---------------------------------------------
Scans the supplied paths and adds them to this scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner scan ( final String ... [[paths]] ) { for ( final String path : [[paths]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner scan ( final String ... [[path]] ) { for ( final String path : [[path]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 739 ---------------------------------------------
Registers an action config consumer with this action manager. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[cover]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 740 ---------------------------------------------
Splits the supplied filename into an array of Strings.@param filename the filename to split.@return the array of Strings. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] [[split]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String [[path]] ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[path]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { [[path]] = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + [[path]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + [[path]] . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[path]] , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] [[rent]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String [[route]] ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { [[route]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { [[route]] = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + [[route]] . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + [[route]] . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[route]] , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 741 ---------------------------------------------
Returns the bytecode signature of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] bytecodeSignatureOfType ( final Class [[type]] ) { final String [[name]] = ' ' + [[type]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[name]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] bytecodeSignatureOfType ( final Class [[eccentric]] ) { final String [[constitute]] = ' ' + [[eccentric]] . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return [[constitute]] . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 742 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 708 / 18 / 742:  74%|███████▍  | 742/1000 [23:54<08:18,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 709 / 18 / 743:  74%|███████▍  | 743/1000 [24:00<08:18,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 709 / 18 / 743:  74%|███████▍  | 744/1000 [24:00<08:15,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 710 / 18 / 744:  74%|███████▍  | 744/1000 [24:00<08:15,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 711 / 18 / 745:  74%|███████▍  | 745/1000 [24:01<08:13,  1.94s/it][Succeeded / Failed / Skipped / Total] 16 / 711 / 18 / 745:  75%|███████▍  | 746/1000 [24:02<08:10,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 712 / 18 / 746:  75%|███████▍  | 746/1000 [24:02<08:10,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 713 / 18 / 747:  75%|███████▍  | 747/1000 [24:04<08:09,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 713 / 18 / 747:  75%|███████▍  | 748/1000 [24:05<08:06,  1.93s/it]Scans a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void scanJarFile ( final File file ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 743 ---------------------------------------------
Registers a scope consumer.@param scopeType the scope type@param madvocScopeConsumer the consumer --> [[[FAILED]]]

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope [[scope]] = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( [[scope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > madvocScopeConsumer ) { final MadvocScope [[oscilloscope]] = getOrInitScope ( scopeType ) ; madvocScopeConsumer . accept ( [[oscilloscope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 744 ---------------------------------------------
Scans the classpath. --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File [[root]] ) { String rootPath = [[root]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File [[ancestor]] ) { String rootPath = [[ancestor]] . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 745 ---------------------------------------------
Gets the default or scope type.@param < S> the type parameter@param scopeClass the scope class@return the default or scope type --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[broaden]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 746 ---------------------------------------------
Gets or initializes the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[entropy]] : allScopes ) { if ( [[entropy]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[entropy]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 747 ---------------------------------------------
Creates a new transaction. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean active ) { return new DbJtxTransaction ( this , tm , scope , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 748 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 714 / 18 / 748:  75%|███████▍  | 748/1000 [24:05<08:06,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 715 / 18 / 749:  75%|███████▍  | 749/1000 [24:05<08:04,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 715 / 18 / 749:  75%|███████▌  | 750/1000 [24:07<08:02,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 716 / 18 / 750:  75%|███████▌  | 750/1000 [24:07<08:02,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 717 / 18 / 751:  75%|███████▌  | 751/1000 [24:08<08:00,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 717 / 18 / 751:  75%|███████▌  | 752/1000 [24:10<07:58,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 718 / 18 / 752:  75%|███████▌  | 752/1000 [24:10<07:58,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 719 / 18 / 753:  75%|███████▌  | 753/1000 [24:13<07:56,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 719 / 18 / 753:  75%|███████▌  | 754/1000 [24:16<07:55,  1.93s/it][Succeeded / Failed / Skipped / Total] 16 / 720 / 18 / 754:  75%|███████▌  | 754/1000 [24:16<07:55,  1.93s/it]Asserts that the specified set of tokens are valid.@param tokenSet the set of tokens. --> [[[FAILED]]]

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token tokenToRemove = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token token = iterator . next ( ) ; if ( token . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( token . validUntil < validUntilMin ) { validUntilMin = token . validUntil ; tokenToRemove = token ; } } if ( ( tokenToRemove != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( tokenToRemove ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 749 ---------------------------------------------
Start the scanner. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[outset]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String path = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( path , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 750 ---------------------------------------------
Initializes this template with the specified template data. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String tableReference = this . tableReference ; if ( tableReference == null ) { tableReference = tableAlias ; } if ( tableReference == null ) { tableReference = entityName ; } if ( tableReference == null ) { tableReference = ded . getEntityName ( ) ; } templateData . registerTableReference ( tableReference , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 751 ---------------------------------------------
Creates a copy of this instance. --> [[[FAILED]]]

[[[[Adv]]]]: public static BeanCopy from ( final Object [[source]] ) { BeanCopy beanCopy = new BeanCopy ( [[source]] ) ; beanCopy . isSourceMap = [[source]] instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object [[generator]] ) { BeanCopy beanCopy = new BeanCopy ( [[generator]] ) ; beanCopy . isSourceMap = [[generator]] instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 752 ---------------------------------------------
Creates a copy of this bean. --> [[[FAILED]]]

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 753 ---------------------------------------------
Prepare a CSRF token.@param session the session@param timeToLive the time to live@return the token --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String [[value]] ; boolean unique ; do { [[value]] = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( [[value]] , timeToLive ) ) ; } while ( ! unique ) ; return [[value]] ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String prepareCsrfToken ( final HttpSession session , final int timeToLive ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String [[esteem]] ; boolean unique ; do { [[esteem]] = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( [[esteem]] , timeToLive ) ) ; } while ( ! unique ) ; return [[esteem]] ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 754 ---------------------------------------------
Removes the specified bean from the list of beans. --> [[[FAILED]]]

[[[[Adv]]]]: public void removeBean ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void removeBean ( final Class [[eccentric]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 755 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 721 / 18 / 755:  76%|███████▌  | 755/1000 [24:29<07:56,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 721 / 18 / 755:  76%|███████▌  | 756/1000 [24:32<07:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 722 / 18 / 756:  76%|███████▌  | 756/1000 [24:32<07:55,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 722 / 18 / 756:  76%|███████▌  | 757/1000 [24:33<07:52,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 723 / 18 / 757:  76%|███████▌  | 757/1000 [24:33<07:52,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 723 / 18 / 757:  76%|███████▌  | 758/1000 [24:37<07:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 724 / 18 / 758:  76%|███████▌  | 758/1000 [24:37<07:51,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 724 / 18 / 758:  76%|███████▌  | 759/1000 [24:39<07:49,  1.95s/it]Registers a bean definition.@param name the bean name@param beanDefinition the bean definition --> [[[FAILED]]]

[[[[Adv]]]]: protected void registerBean ( final String [[name]] , final BeanDefinition beanDefinition ) { beans . put ( [[name]] , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( [[name]] . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String [[diagnose]] , final BeanDefinition beanDefinition ) { beans . put ( [[diagnose]] , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( [[diagnose]] . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition existing = beansAlt . get ( altName ) ; if ( existing != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 756 ---------------------------------------------
Resolve a scope.@param < S> the type of the scope@param scopeType the type of the scope@return the scope --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S [[scope]] = ( S ) scopes . get ( scopeType ) ; if ( [[scope]] == null ) { try { [[scope]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[scope]] ) ; scopes . put ( scopeType , [[scope]] ) ; } return [[scope]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S extends Scope > S resolveScope ( final Class < S > scopeType ) { S [[compass]] = ( S ) scopes . get ( scopeType ) ; if ( [[compass]] == null ) { try { [[compass]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[compass]] ) ; scopes . put ( scopeType , [[compass]] ) ; } return [[compass]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 757 ---------------------------------------------
Resolve the bean names for the given type.@param type the type@return the bean names --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class [[type]] ) { String [ ] beanNames = beanCollections . get ( [[type]] ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > [[list]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String beanName = entry . getKey ( ) ; [[list]] . add ( beanName ) ; } } if ( [[list]] . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = [[list]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class [[eccentric]] ) { String [ ] beanNames = beanCollections . get ( [[eccentric]] ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > [[number]] = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[eccentric]] ) ) { String beanName = entry . getKey ( ) ; [[number]] . add ( beanName ) ; } } if ( [[number]] . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = [[number]] . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[eccentric]] , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 758 ---------------------------------------------
Decodes a char array into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[d]] = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; [[d]] < eLen ; ) { int [[i]] = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ [[d]] ++ ] = ( byte ) ( [[i]] >> 16 ) ; dest [ [[d]] ++ ] = ( byte ) ( [[i]] >> 8 ) ; dest [ [[d]] ++ ] = ( byte ) [[i]] ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[d]] < len ) { int [[i]] = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { [[i]] |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[d]] < len ; r -= 8 ) { dest [ [[d]] ++ ] = ( byte ) ( [[i]] >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[cholecalciferol]] = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; [[cholecalciferol]] < eLen ; ) { int [[iodine]] = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ [[cholecalciferol]] ++ ] = ( byte ) ( [[iodine]] >> 16 ) ; dest [ [[cholecalciferol]] ++ ] = ( byte ) ( [[iodine]] >> 8 ) ; dest [ [[cholecalciferol]] ++ ] = ( byte ) [[iodine]] ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[cholecalciferol]] < len ) { int [[iodine]] = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { [[iodine]] |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[cholecalciferol]] < len ; r -= 8 ) { dest [ [[cholecalciferol]] ++ ] = ( byte ) ( [[iodine]] >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 725 / 18 / 759:  76%|███████▌  | 759/1000 [24:39<07:49,  1.95s/it][Succeeded / Failed / Skipped / Total] 16 / 725 / 18 / 759:  76%|███████▌  | 760/1000 [24:50<07:50,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 726 / 18 / 760:  76%|███████▌  | 760/1000 [24:50<07:50,  1.96s/it][Succeeded / Failed / Skipped / Total] 16 / 726 / 18 / 760:  76%|███████▌  | 761/1000 [24:59<07:50,  1.97s/it][Succeeded / Failed / Skipped / Total] 16 / 727 / 18 / 761:  76%|███████▌  | 761/1000 [24:59<07:50,  1.97s/it][Succeeded / Failed / Skipped / Total] 16 / 727 / 18 / 761:  76%|███████▌  | 762/1000 [25:07<07:50,  1.98s/it][Succeeded / Failed / Skipped / Total] 16 / 728 / 18 / 762:  76%|███████▌  | 762/1000 [25:07<07:50,  1.98s/it][Succeeded / Failed / Skipped / Total] 16 / 728 / 18 / 762:  76%|███████▋  | 763/1000 [25:16<07:50,  1.99s/it]Visits a property. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String name , final Object value ) { if ( isTargetMap ) { name = LEFT_SQ_BRACKET + name + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , name , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 760 ---------------------------------------------
Registers a set injection point.@param beanName the bean name@param property the property --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[property]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[property]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[property]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[attribute]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[attribute]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[attribute]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 761 ---------------------------------------------
Registers a Petite Ctor injection point.@param beanName the bean name@param paramTypes the parameter types@param references the references --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] [[references]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , [[references]] ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] paramTypes , final String [ ] [[address]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( constructor , [[address]] ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , ref ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 762 ---------------------------------------------
Registers a property injection point.@param beanName the bean name@param property the property@param reference the reference --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences [[ref]] = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , [[ref]] ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences [[referee]] = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , [[referee]] ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 729 / 18 / 763:  76%|███████▋  | 763/1000 [25:16<07:50,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 729 / 18 / 763:  76%|███████▋  | 764/1000 [25:17<07:48,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 730 / 18 / 764:  76%|███████▋  | 764/1000 [25:17<07:48,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 730 / 18 / 764:  76%|███████▋  | 765/1000 [25:19<07:46,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 731 / 18 / 765:  76%|███████▋  | 765/1000 [25:19<07:46,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 731 / 18 / 765:  77%|███████▋  | 766/1000 [25:20<07:44,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 732 / 18 / 766:  77%|███████▋  | 766/1000 [25:20<07:44,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 732 / 18 / 766:  77%|███████▋  | 767/1000 [25:27<07:44,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 733 / 18 / 767:  77%|███████▋  | 767/1000 [25:27<07:44,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 733 / 18 / 767:  77%|███████▋  | 768/1000 [25:28<07:41,  1.99s/it]Register Petite init methods.@param beanName the bean name@param invocationStrategy the invocation strategy@param initMethodNames the init method names --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 764 ---------------------------------------------
Register Petite destroy methods.@param beanName the bean name@param destroyMethodNames the destroy method names --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 765 ---------------------------------------------
Registers a custom Petite bean.@param < T > the type of the bean to be registered@param type the type of the bean to be registered@param name the name of the bean to be registered@param scopeType the scope of the bean to be registered@param wiringMode the wiring mode of the bean to be registered@param define {@code true} if the bean should be defined, {@code false} otherwise@param consumer the consumer --> [[[FAILED]]]

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String [[name]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String [[constitute]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[constitute]] == null ) { [[constitute]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 766 ---------------------------------------------
Iterate through all registered bean types and pass them to the bean name consumer. --> [[[FAILED]]]

[[[[Adv]]]]: public void forEachBeanType ( final Class [[type]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[type]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void forEachBeanType ( final Class [[typewrite]] , final Consumer < String > beanNameConsumer ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[typewrite]] ) ) { beanNameConsumer . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 767 ---------------------------------------------
Defines a map of parameters.@param properties the map of parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > [[entry]] : properties . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void defineParameters ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > [[entering]] : properties . entrySet ( ) ) { defineParameter ( [[entering]] . getKey ( ) . toString ( ) , [[entering]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 768 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 734 / 18 / 768:  77%|███████▋  | 768/1000 [25:28<07:41,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 734 / 18 / 768:  77%|███████▋  | 769/1000 [25:29<07:39,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 735 / 18 / 769:  77%|███████▋  | 769/1000 [25:29<07:39,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 735 / 18 / 769:  77%|███████▋  | 770/1000 [25:37<07:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 736 / 18 / 770:  77%|███████▋  | 770/1000 [25:37<07:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 736 / 18 / 770:  77%|███████▋  | 771/1000 [25:37<07:36,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 737 / 18 / 771:  77%|███████▋  | 771/1000 [25:37<07:36,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 737 / 18 / 771:  77%|███████▋  | 772/1000 [25:41<07:35,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 738 / 18 / 772:  77%|███████▋  | 772/1000 [25:41<07:35,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 738 / 18 / 772:  77%|███████▋  | 773/1000 [25:45<07:33,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 739 / 18 / 773:  77%|███████▋  | 773/1000 [25:45<07:33,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 739 / 18 / 773:  77%|███████▋  | 774/1000 [25:46<07:31,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 740 / 18 / 774:  77%|███████▋  | 774/1000 [25:46<07:31,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 740 / 18 / 774:  78%|███████▊  | 775/1000 [25:50<07:30,  2.00s/it]Resolves a Java version number.@param versionThe Java version number.@return The Java version number. --> [[[FAILED]]]

[[[[Adv]]]]: public static int resolveJavaVersion ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return [[version]] > platformVersion ? [[version]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int resolveJavaVersion ( final int [[rendering]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = javaVersionNumber - 8 + 52 ; return [[rendering]] > platformVersion ? [[rendering]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 769 ---------------------------------------------
Throws an exception if the index is out of bounds. --> [[[FAILED]]]

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void checkArgumentIndex ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 770 ---------------------------------------------
Checks if a CSRF token is present in the session.@param session the session@param tokenValue the token value@return true if the token is present in the session, false otherwise --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[session]] , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "[[True]]" == "[[True]]" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token [[t]] = it . next ( ) ; if ( [[t]] . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( [[t]] . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "[[True]]" == "[[True]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession [[sitting]] , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) [[sitting]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return "[[reliable]]" == "[[reliable]]" ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return "False" != "False" ; } boolean found = "False" != "False" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token [[triiodothyronine]] = it . next ( ) ; if ( [[triiodothyronine]] . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( [[triiodothyronine]] . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = "[[reliable]]" == "[[reliable]]" ; } } return found ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 771 ---------------------------------------------
Intercepts the supplied action request. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object [[result]] = null ; try { [[result]] = actionRequest . invoke ( ) ; } catch ( Exception ex ) { [[result]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[result]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object intercept ( final ActionRequest actionRequest ) throws Exception { printBefore ( actionRequest ) ; long startTime = System . currentTimeMillis ( ) ; Object [[consequence]] = null ; try { [[consequence]] = actionRequest . invoke ( ) ; } catch ( Exception ex ) { [[consequence]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[consequence]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( actionRequest , executionTime , [[consequence]] ) ; } return [[consequence]] ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 772 ---------------------------------------------
Adds an int to the end of the stack. --> [[[FAILED]]]

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[mv]] , final int [[value]] ) { if ( [[value]] <= 5 ) { [[mv]] . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { [[mv]] . visitIntInsn ( BIPUSH , [[value]] ) ; } else { [[mv]] . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void pushInt ( final MethodVisitor [[Mv]] , final int [[prize]] ) { if ( [[prize]] <= 5 ) { [[Mv]] . visitInsn ( ICONST_0 + [[prize]] ) ; } else if ( [[prize]] <= Byte . MAX_VALUE ) { [[Mv]] . visitIntInsn ( BIPUSH , [[prize]] ) ; } else { [[Mv]] . visitIntInsn ( SIPUSH , [[prize]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 773 ---------------------------------------------
Returns advice field name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String adviceFieldName ( final String [[name]] , final int index ) { return ProxettaNames . fieldPrefix + [[name]] + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String adviceFieldName ( final String [[discover]] , final int index ) { return ProxettaNames . fieldPrefix + [[discover]] + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 774 ---------------------------------------------
Loads the special arguments for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor [[millivolt]] , final MethodInfo methodInfo ) { [[millivolt]] . visitVarInsn ( ALOAD , 0 ) ; for ( int [[I]] = 1 ; [[I]] <= methodInfo . getArgumentsCount ( ) ; [[I]] ++ ) { loadMethodArgument ( [[millivolt]] , methodInfo , [[I]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 775 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 741 / 18 / 775:  78%|███████▊  | 775/1000 [25:50<07:30,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 741 / 18 / 775:  78%|███████▊  | 776/1000 [25:51<07:27,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 742 / 18 / 776:  78%|███████▊  | 776/1000 [25:51<07:27,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 742 / 18 / 776:  78%|███████▊  | 777/1000 [25:52<07:25,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 743 / 18 / 777:  78%|███████▊  | 777/1000 [25:52<07:25,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 743 / 18 / 777:  78%|███████▊  | 778/1000 [25:54<07:23,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 744 / 18 / 778:  78%|███████▊  | 778/1000 [25:54<07:23,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 744 / 18 / 778:  78%|███████▊  | 779/1000 [25:56<07:21,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 745 / 18 / 779:  78%|███████▊  | 779/1000 [25:56<07:21,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 745 / 18 / 779:  78%|███████▊  | 780/1000 [25:58<07:19,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 746 / 18 / 780:  78%|███████▊  | 780/1000 [25:58<07:19,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 746 / 18 / 780:  78%|███████▊  | 781/1000 [26:00<07:17,  2.00s/it]Registers an injection point for the specified Petite method. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] [[arguments]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[arguments]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[arguments]] , "[[True]]" == "[[True]]" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] [[contention]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[contention]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[contention]] , "[[reliable]]" == "[[reliable]]" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 776 ---------------------------------------------
Loads the static method arguments.@param mv the method visitor.@param methodInfo the method info. --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadStaticMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void loadStaticMethodArguments ( final MethodVisitor [[Mv]] , final MethodInfo methodInfo ) { for ( int i = 0 ; i < methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[Mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 777 ---------------------------------------------
Returns advice method name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String adviceMethodName ( final String [[name]] , final int index ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String adviceMethodName ( final String [[constitute]] , final int index ) { return ProxettaNames . methodPrefix + [[constitute]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 778 ---------------------------------------------
Loads the virtual method arguments.@param mv the method visitor.@param methodInfo the method info. --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int [[i]] = 1 ; [[i]] <= methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[Md]] , final MethodInfo methodInfo ) { for ( int [[iodin]] = 1 ; [[iodin]] <= methodInfo . getArgumentsCount ( ) ; [[iodin]] ++ ) { loadMethodArgument ( [[Md]] , methodInfo , [[iodin]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 779 ---------------------------------------------
Prepares a return value instruction.@param mva method visitor@param methodInfothe method info@param varOffsetthe offset --> [[[FAILED]]]

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[mv]] , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[Mv]] , final MethodInfo methodInfo , int varOffset ) { varOffset += methodInfo . getAllArgumentsSize ( ) ; switch ( methodInfo . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[Mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[Mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[Mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 780 ---------------------------------------------
Create a method signature key. --> [[[FAILED]]]

[[[[Adv]]]]: public static String createMethodSignaturesKey ( final int [[access]] , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( [[access]] ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String createMethodSignaturesKey ( final int [[approach]] , final String methodName , final String description , final String className ) { return new StringBand ( 7 ) . append ( [[approach]] ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( methodName ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 781 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 747 / 18 / 781:  78%|███████▊  | 781/1000 [26:00<07:17,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 747 / 18 / 781:  78%|███████▊  | 782/1000 [26:00<07:15,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 748 / 18 / 782:  78%|███████▊  | 782/1000 [26:00<07:15,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 748 / 18 / 782:  78%|███████▊  | 783/1000 [26:01<07:12,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 749 / 18 / 783:  78%|███████▊  | 783/1000 [26:01<07:12,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 749 / 18 / 783:  78%|███████▊  | 784/1000 [26:04<07:11,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 750 / 18 / 784:  78%|███████▊  | 784/1000 [26:04<07:11,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 750 / 18 / 784:  78%|███████▊  | 785/1000 [26:10<07:10,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 751 / 18 / 785:  78%|███████▊  | 785/1000 [26:10<07:10,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 751 / 18 / 785:  79%|███████▊  | 786/1000 [26:10<07:07,  2.00s/it]Creates a new array of the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void newArray ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 782 ---------------------------------------------
Extracts the encoding from the content type.@param contentType the content type@param defaultEncoding the default encoding@return the encoding --> [[[FAILED]]]

[[[[Adv]]]]: public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String extractEncoding ( final String contentType , String defaultEncoding ) { String encoding = extractEncoding ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 783 ---------------------------------------------
Stores an int into an array.@param mva method visitor.@param componentTypethe component type. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeIntoArray ( final MethodVisitor [[mv]] , final Class componentType ) { if ( componentType == int . class ) { [[mv]] . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { [[mv]] . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { [[mv]] . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { [[mv]] . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { [[mv]] . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { [[mv]] . visitInsn ( CASTORE ) ; return ; } [[mv]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void storeIntoArray ( final MethodVisitor [[mendelevium]] , final Class componentType ) { if ( componentType == int . class ) { [[mendelevium]] . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { [[mendelevium]] . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { [[mendelevium]] . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { [[mendelevium]] . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { [[mendelevium]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { [[mendelevium]] . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { [[mendelevium]] . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { [[mendelevium]] . visitInsn ( CASTORE ) ; return ; } [[mendelevium]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 784 ---------------------------------------------
Require authentication.@param responsethe response@param realmthe realm@throws IOExceptionSignals that an I/O exception has occurred. --> [[[FAILED]]]

[[[[Adv]]]]: public static void requireAuthentication ( final HttpServletResponse resp , final String [[realm]] ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[realm]] + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void requireAuthentication ( final HttpServletResponse resp , final String [[kingdom]] ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + [[kingdom]] + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 785 ---------------------------------------------
Resolves the bearer token header.@param request the servlet request.@return the bearer token header or <code>null</code> if none. --> [[[FAILED]]]

[[[[Adv]]]]: public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String resolveAuthBearerToken ( final HttpServletRequest request ) { String header = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 786 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 752 / 18 / 786:  79%|███████▊  | 786/1000 [26:10<07:07,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 752 / 18 / 786:  79%|███████▊  | 787/1000 [26:13<07:05,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 753 / 18 / 787:  79%|███████▊  | 787/1000 [26:13<07:05,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 753 / 18 / 787:  79%|███████▉  | 788/1000 [26:15<07:03,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 754 / 18 / 788:  79%|███████▉  | 788/1000 [26:15<07:03,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 754 / 18 / 788:  79%|███████▉  | 789/1000 [26:21<07:02,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 755 / 18 / 789:  79%|███████▉  | 789/1000 [26:21<07:02,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 755 / 18 / 789:  79%|███████▉  | 790/1000 [26:22<07:00,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 756 / 18 / 790:  79%|███████▉  | 790/1000 [26:22<07:00,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 756 / 18 / 790:  79%|███████▉  | 791/1000 [26:23<06:58,  2.00s/it]Loads the argument at the given index.@param mv the method visitor.@param methodInfo the method info.@param index the index. --> [[[FAILED]]]

[[[[Adv]]]]: public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void loadMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int type = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 787 ---------------------------------------------
Prepares the response for download.@param response the servlet response@param file the file@param mimeType the mime type --> [[[FAILED]]]

[[[[Adv]]]]: public static void prepareDownload ( final HttpServletResponse [[response]] , final File [[file]] , final String mimeType ) { if ( ! [[file]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[file]] ) ; } if ( [[file]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[file]] ) ; } prepareResponse ( [[response]] , [[file]] . getAbsolutePath ( ) , mimeType , ( int ) [[file]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void prepareDownload ( final HttpServletResponse [[reply]] , final File [[charge]] , final String mimeType ) { if ( ! [[charge]] . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + [[charge]] ) ; } if ( [[charge]] . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + [[charge]] ) ; } prepareResponse ( [[reply]] , [[charge]] . getAbsolutePath ( ) , mimeType , ( int ) [[charge]] . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 788 ---------------------------------------------
Registers a provider for the specified Petite bean. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] [[arguments]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[arguments]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final String beanName , final String methodName , final Class [ ] [[contention]] ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[contention]] , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , beanName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 789 ---------------------------------------------
Returns true if the given flags are empty. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean isEmptyFlags ( Flags flags ) { if ( flags == null ) return "True" == "True" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 790 ---------------------------------------------
Reads the specified request body from the specified request stream.@param request the specified request@return the specified request body@throws IOException if an I/O error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest [[request]] ) throws IOException { String charEncoding = [[request]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[request]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest [[bespeak]] ) throws IOException { String charEncoding = [[bespeak]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[bespeak]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 791 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 757 / 18 / 791:  79%|███████▉  | 791/1000 [26:23<06:58,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 757 / 18 / 791:  79%|███████▉  | 792/1000 [26:24<06:56,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 758 / 18 / 792:  79%|███████▉  | 792/1000 [26:24<06:56,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 758 / 18 / 792:  79%|███████▉  | 793/1000 [26:25<06:53,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 759 / 18 / 793:  79%|███████▉  | 793/1000 [26:25<06:53,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 759 / 18 / 793:  79%|███████▉  | 794/1000 [26:27<06:51,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 760 / 18 / 794:  79%|███████▉  | 794/1000 [26:27<06:51,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 760 / 18 / 794:  80%|███████▉  | 795/1000 [26:29<06:49,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 761 / 18 / 795:  80%|███████▉  | 795/1000 [26:29<06:49,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 761 / 18 / 795:  80%|███████▉  | 796/1000 [26:33<06:48,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 762 / 18 / 796:  80%|███████▉  | 796/1000 [26:33<06:48,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 762 / 18 / 796:  80%|███████▉  | 797/1000 [26:35<06:46,  2.00s/it]Stores a context path variable in the servlet context. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext servletContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 792 ---------------------------------------------
Stores an argument at the given index.@param mv the method visitor.@param methodInfo the method info.@param index the index. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[index]] ) { int offset = methodInfo . getArgumentOffset ( [[index]] ) ; int type = methodInfo . getArgument ( [[index]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo methodInfo , final int [[forefinger]] ) { int offset = methodInfo . getArgumentOffset ( [[forefinger]] ) ; int type = methodInfo . getArgument ( [[forefinger]] ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 793 ---------------------------------------------
Stores the given context path variable in the given page context. --> [[[FAILED]]]

[[[[Adv]]]]: public static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final PageContext pageContext , final String contextPathVariableName ) { String ctxPath = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( contextPathVariableName , ctxPath ) ; ServletContext servletContext = pageContext . getServletContext ( ) ; servletContext . setAttribute ( contextPathVariableName , ctxPath ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 794 ---------------------------------------------
Copies all parameters from the servlet request to the given attributes.@param servletRequest the servlet request@param treatEmptyParamsAsNull the treat empty parameters as null@param ignoreEmptyRequestParams the ignore empty request parameters as null --> [[[FAILED]]]

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 795 ---------------------------------------------
Sets the response content type and file size. --> [[[FAILED]]]

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[extension]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String fileName , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( fileName != null ) ) { String [[annex]] = FileNameUtil . getExtension ( fileName ) ; mimeType = MimeTypes . getMimeType ( [[annex]] ) ; } if ( mimeType != null ) { response . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { response . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 796 ---------------------------------------------
Invokes the body of the tag. --> [[[FAILED]]]

[[[[Adv]]]]: public static void invokeBody ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void invokeBody ( final JspFragment [[eubstance]] ) throws JspException { if ( [[eubstance]] == null ) { return ; } try { [[eubstance]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 797 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 763 / 18 / 797:  80%|███████▉  | 797/1000 [26:35<06:46,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 763 / 18 / 797:  80%|███████▉  | 798/1000 [26:36<06:44,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 764 / 18 / 798:  80%|███████▉  | 798/1000 [26:36<06:44,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 764 / 18 / 798:  80%|███████▉  | 799/1000 [26:36<06:41,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 765 / 18 / 799:  80%|███████▉  | 799/1000 [26:36<06:41,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 765 / 18 / 799:  80%|████████  | 800/1000 [26:37<06:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 766 / 18 / 800:  80%|████████  | 800/1000 [26:37<06:39,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 766 / 18 / 800:  80%|████████  | 801/1000 [26:37<06:36,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 767 / 18 / 801:  80%|████████  | 801/1000 [26:37<06:36,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 767 / 18 / 801:  80%|████████  | 802/1000 [26:38<06:34,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 768 / 18 / 802:  80%|████████  | 802/1000 [26:38<06:34,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 768 / 18 / 802:  80%|████████  | 803/1000 [26:39<06:32,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 769 / 18 / 803:  80%|████████  | 803/1000 [26:39<06:32,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 769 / 18 / 803:  80%|████████  | 804/1000 [26:40<06:30,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 770 / 18 / 804:  80%|████████  | 804/1000 [26:40<06:30,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 770 / 18 / 804:  80%|████████  | 805/1000 [26:41<06:27,  1.99s/it]Registers a provider for the specified Petite type. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] [[arguments]] ) { ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[md]] = [[cd]] . getMethodDescriptor ( staticMethodName , [[arguments]] , "[[True]]" == "[[True]]" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , [[md]] . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] [[controversy]] ) { ClassDescriptor [[cadmium]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor [[Mv]] = [[cadmium]] . getMethodDescriptor ( staticMethodName , [[controversy]] , "[[lawful]]" == "[[lawful]]" ) ; if ( [[Mv]] == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , [[Mv]] . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
--------------------------------------------- Result 798 ---------------------------------------------
Invokes all registered init methods. --> [[[FAILED]]]

[[[[Adv]]]]: public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void invokeInitMethods ( final InitMethodInvocationStrategy invocationStrategy ) { for ( final InitMethodPoint initMethod : beanDefinition . initMethodPoints ( ) ) { if ( invocationStrategy != initMethod . invocationStrategy ) { continue ; } try { initMethod . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + initMethod , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 799 ---------------------------------------------
Calls all destroy methods. --> [[[FAILED]]]

[[[[Adv]]]]: public void callDestroyMethods ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void callDestroyMethods ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 800 ---------------------------------------------
Retrieves all the cookies with the specified name.@param request the current HttpServletRequest.@param cookieName the name of the cookie to retrieve.@return all the cookies with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest [[request]] , final String cookieName ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest [[bespeak]] , final String cookieName ) { Cookie [ ] cookies = [[bespeak]] . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 801 ---------------------------------------------
Creates a new bean instance. --> [[[FAILED]]]

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object newBeanInstance ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 802 ---------------------------------------------
Inject parameters.@param paramManager the param manager@param implicitParamInjection the implicit param injection --> [[[FAILED]]]

[[[[Adv]]]]: public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void injectParams ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 803 ---------------------------------------------
Renders the body of a JSP fragment. --> [[[FAILED]]]

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] renderBody ( final JspFragment [[soundbox]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[soundbox]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 804 ---------------------------------------------
Rewrites the given action path. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[rewrite]] ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String [[revision]] ( final HttpServletRequest servletRequest , final String actionPath , final String httpMethod ) { return actionPath ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 805 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 771 / 18 / 805:  80%|████████  | 805/1000 [26:41<06:27,  1.99s/it][Succeeded / Failed / Skipped / Total] 16 / 771 / 18 / 805:  81%|████████  | 806/1000 [26:51<06:27,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 772 / 18 / 806:  81%|████████  | 806/1000 [26:51<06:27,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 772 / 18 / 806:  81%|████████  | 807/1000 [26:57<06:26,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 773 / 18 / 807:  81%|████████  | 807/1000 [26:57<06:26,  2.00s/it][Succeeded / Failed / Skipped / Total] 16 / 773 / 18 / 807:  81%|████████  | 808/1000 [27:00<06:25,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 774 / 18 / 808:  81%|████████  | 808/1000 [27:00<06:25,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 774 / 18 / 808:  81%|████████  | 809/1000 [27:06<06:23,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 775 / 18 / 809:  81%|████████  | 809/1000 [27:06<06:23,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 775 / 18 / 809:  81%|████████  | 810/1000 [27:12<06:23,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 776 / 18 / 810:  81%|████████  | 810/1000 [27:12<06:23,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 776 / 18 / 810:  81%|████████  | 811/1000 [27:20<06:22,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 777 / 18 / 811:  81%|████████  | 811/1000 [27:20<06:22,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 777 / 18 / 811:  81%|████████  | 812/1000 [27:32<06:22,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 778 / 18 / 812:  81%|████████  | 812/1000 [27:32<06:22,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 778 / 18 / 812:  81%|████████▏ | 813/1000 [27:37<06:21,  2.04s/it]Reads the request body from the specified request. --> [[[FAILED]]]

[[[[Adv]]]]: public static String readRequestBodyFromReader ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter [[out]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[out]] ) ; return [[out]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromReader ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter [[stunned]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[stunned]] ) ; return [[stunned]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 806 ---------------------------------------------
Renders the body to a string.@param body the body to render.@return the rendered body.@throws JspException if the body cannot be rendered. --> [[[FAILED]]]

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment [[body]] ) throws JspException { char [ ] result = renderBody ( [[body]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String renderBodyToString ( final JspFragment [[eubstance]] ) throws JspException { char [ ] result = renderBody ( [[eubstance]] ) ; return new String ( result ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 807 ---------------------------------------------
Prepares a list of parameters.@param paramValues The list of parameters.@param treatEmptyParamsAsNull Whether or not to ignore empty parameters.@param ignoreEmptyRequestParams Whether or not to ignore empty request parameters.@return The list of parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[i]] = 0 ; [[i]] < paramValues . length ; [[i]] ++ ) { String paramValue = paramValues [ [[i]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ [[i]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] paramValues , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = paramValues . length ; for ( int [[iodine]] = 0 ; [[iodine]] < paramValues . length ; [[iodine]] ++ ) { String paramValue = paramValues [ [[iodine]] ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } paramValues [ [[iodine]] ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return paramValues ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 808 ---------------------------------------------
Adds the specified header value. --> [[[FAILED]]]

[[[[Adv]]]]: public void addHeader ( final String [[name]] , final String [[value]] ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , [[value]] ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( [[value]] ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void addHeader ( final String [[mention]] , final String [[appraise]] ) { List < String > valuesList = super . getAll ( [[mention]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[mention]] , [[appraise]] ) ; return ; } super . remove ( [[mention]] ) ; valuesList . add ( [[appraise]] ) ; super . addAll ( [[mention]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 809 ---------------------------------------------
Retrieve a profile property.@param profile the profile name@param key the key@return the property or <code>null</code> --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String [[profile]] , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[profile]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry getProfileProperty ( final String [[visibility]] , final String key ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[visibility]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 810 ---------------------------------------------
Resolve the macros in the specified profiles. --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveMacros ( String [[value]] , final String ... [[profiles]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String resolveMacros ( String [[rate]] , final String ... [[profile]] ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 811 ---------------------------------------------
Adds a base property.@param key the key@param value the value@param append the append --> [[[FAILED]]]

[[[[Adv]]]]: public void putBaseProperty ( final String [[key]] , final String [[value]] , final boolean [[append]] ) { put ( null , baseProperties , [[key]] , [[value]] , [[append]] ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void putBaseProperty ( final String [[Key]] , final String [[treasure]] , final boolean [[supply]] ) { put ( null , baseProperties , [[Key]] , [[treasure]] , [[supply]] ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 812 ---------------------------------------------
Extracts a mapping from a target map.@param target the target map@param profiles the profiles@param wildcardPatterns the wildcard patterns@param prefix the prefix@return the mapping --> [[[FAILED]]]

[[[[Adv]]]]: public Map [[extract]] ( Map [[target]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[excerption]] ( Map [[mark]] , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( [[mark]] == null ) { [[mark]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 813 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 779 / 18 / 813:  81%|████████▏ | 813/1000 [27:37<06:21,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 779 / 18 / 813:  81%|████████▏ | 814/1000 [27:37<06:18,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 780 / 18 / 814:  81%|████████▏ | 814/1000 [27:37<06:18,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 780 / 18 / 814:  82%|████████▏ | 815/1000 [27:38<06:16,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 781 / 18 / 815:  82%|████████▏ | 815/1000 [27:38<06:16,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 781 / 18 / 815:  82%|████████▏ | 816/1000 [27:39<06:14,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 782 / 18 / 816:  82%|████████▏ | 816/1000 [27:39<06:14,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 782 / 18 / 816:  82%|████████▏ | 817/1000 [27:40<06:11,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 783 / 18 / 817:  82%|████████▏ | 817/1000 [27:40<06:11,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 783 / 18 / 817:  82%|████████▏ | 818/1000 [27:40<06:09,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 784 / 18 / 818:  82%|████████▏ | 818/1000 [27:40<06:09,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 784 / 18 / 818:  82%|████████▏ | 819/1000 [27:48<06:08,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 785 / 18 / 819:  82%|████████▏ | 819/1000 [27:48<06:08,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 785 / 18 / 819:  82%|████████▏ | 820/1000 [27:49<06:06,  2.04s/it]Checks if the specified parameter is a GET parameter.@param request the servlet request@param name the parameter name@return true if the parameter is a GET parameter, false otherwise --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String [[name]] ) { [[name]] = URLCoder . encodeQueryParam ( [[name]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( [[name]] ) ) { return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean isGetParameter ( final HttpServletRequest request , String [[discover]] ) { [[discover]] = URLCoder . encodeQueryParam ( [[discover]] ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( [[discover]] ) ) { return "[[confessedly]]" == "[[confessedly]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 814 ---------------------------------------------
Converts an array of bytes into a stream of words. --> [[[FAILED]]]

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int [[i]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[i]] = 0 ; [[i]] < 4 ; [[i]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int [[I]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[I]] = 0 ; [[I]] < 4 ; [[I]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 815 ---------------------------------------------
Parses an action definition.@param actionClass the action class@param actionMethod the action method@param actionDefinition the action definition --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime parse ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 816 ---------------------------------------------
Put a profile property.@param key the key@param value the value@param profile the profile@param append the append --> [[[FAILED]]]

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String [[value]] , final String profile , final boolean [[append]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , [[value]] , [[append]] ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String [[appraise]] , final String profile , final boolean [[supply]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , [[appraise]] , [[supply]] ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 817 ---------------------------------------------
Resolves the action configuration for the given action annotation.@param annotationValues the action annotation values.@return the action configuration. --> [[[FAILED]]]

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig resolveActionConfig ( final ActionAnnotationValues annotationValues ) { final Class < ? extends Annotation > annotationType ; if ( annotationValues == null ) { annotationType = Action . class ; } else { annotationType = annotationValues . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 818 ---------------------------------------------
Detect and register an action alias.@param annotationValues the action annotation values@param actionDefinition the action definition --> [[[FAILED]]]

[[[[Adv]]]]: protected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void detectAndRegisterAlias ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 819 ---------------------------------------------
Read action filters. --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[result]] = filteredBy . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] readActionFilters ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[solution]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[solution]] = filteredBy . value ( ) ; if ( [[solution]] . length == 0 ) { [[solution]] = null ; } } return [[solution]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
--------------------------------------------- Result 820 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 786 / 18 / 820:  82%|████████▏ | 820/1000 [27:49<06:06,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 786 / 18 / 820:  82%|████████▏ | 821/1000 [27:50<06:04,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 787 / 18 / 821:  82%|████████▏ | 821/1000 [27:50<06:04,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 787 / 18 / 821:  82%|████████▏ | 822/1000 [27:50<06:01,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 788 / 18 / 822:  82%|████████▏ | 822/1000 [27:50<06:01,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 788 / 18 / 822:  82%|████████▏ | 823/1000 [27:51<05:59,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 789 / 18 / 823:  82%|████████▏ | 823/1000 [27:51<05:59,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 789 / 18 / 823:  82%|████████▏ | 824/1000 [27:51<05:57,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 790 / 18 / 824:  82%|████████▏ | 824/1000 [27:51<05:57,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 790 / 19 / 825:  82%|████████▎ | 825/1000 [27:51<05:54,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 790 / 19 / 825:  83%|████████▎ | 826/1000 [28:01<05:54,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 791 / 19 / 826:  83%|████████▎ | 826/1000 [28:01<05:54,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 792 / 19 / 827:  83%|████████▎ | 827/1000 [28:02<05:52,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 792 / 19 / 827:  83%|████████▎ | 828/1000 [28:04<05:49,  2.03s/it]Reads the path to the action package. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] readPackageActionPath ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 821 ---------------------------------------------
Read interceptors.@param actionClassOrMethod the action class or method@return the interceptors --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] readActionInterceptors ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy interceptedBy = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( interceptedBy != null ) { result = interceptedBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 822 ---------------------------------------------
Read method action path.@param methodName the method name@param annotationValues the annotation values@param actionConfig the action config@return the string --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] readMethodActionPath ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 823 ---------------------------------------------
Checks to see if the given hashed string is valid. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int [[i]] = 0 ; [[i]] < try_bytes . length ; [[i]] ++ ) { ret |= hashed_bytes [ [[i]] ] ^ try_bytes [ [[i]] ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String try_pw = hashpw ( plaintext , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( hashed_bytes . length != try_bytes . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int [[ace]] = 0 ; [[ace]] < try_bytes . length ; [[ace]] ++ ) { ret |= hashed_bytes [ [[ace]] ] ^ try_bytes [ [[ace]] ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 824 ---------------------------------------------
Parses the action annotation values and returns the alias.@param annotationValues the action annotation values.@return the alias. --> [[[FAILED]]]

[[[[Adv]]]]: protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String parseMethodAlias ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 825 ---------------------------------------------
Sets the last modified time of this request. --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 826 ---------------------------------------------
Applies an advice to the specified target class.@param < T> the type parameter@param targetClass the target class@return the target instance --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[MT]] > [[MT]] applyAdvice ( final Class < [[MT]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 827 ---------------------------------------------
Hashes the given password with the given salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static String hashpw ( String [[password]] , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String hashpw ( String [[word]] , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , saltb , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 828 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 793 / 19 / 828:  83%|████████▎ | 828/1000 [28:04<05:49,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 794 / 19 / 829:  83%|████████▎ | 829/1000 [28:05<05:47,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 794 / 19 / 829:  83%|████████▎ | 830/1000 [28:05<05:45,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 795 / 19 / 830:  83%|████████▎ | 830/1000 [28:05<05:45,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 796 / 19 / 831:  83%|████████▎ | 831/1000 [28:09<05:43,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 796 / 19 / 831:  83%|████████▎ | 832/1000 [28:09<05:41,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 797 / 19 / 832:  83%|████████▎ | 832/1000 [28:09<05:41,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 798 / 19 / 833:  83%|████████▎ | 833/1000 [28:10<05:38,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 798 / 19 / 833:  83%|████████▎ | 834/1000 [28:10<05:36,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 799 / 19 / 834:  83%|████████▎ | 834/1000 [28:10<05:36,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 800 / 19 / 835:  84%|████████▎ | 835/1000 [28:12<05:34,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 800 / 19 / 835:  84%|████████▎ | 836/1000 [28:12<05:32,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 801 / 19 / 836:  84%|████████▎ | 836/1000 [28:12<05:32,  2.02s/it]Resolves the name of the given json name. --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveRealName ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String resolveRealName ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 829 ---------------------------------------------
Resolves a JSON name.@param realName the name to resolve.@return the resolved name. --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveJsonName ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String resolveJsonName ( final String realName ) { if ( realNames == null ) { return realName ; } int realIndex = ArraysUtil . indexOf ( realNames , realName ) ; if ( realIndex == - 1 ) { return realName ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 830 ---------------------------------------------
Visits an annotation.@param descriptor the annotation descriptor@param visible true if the annotation should be visible@return the visitor --> [[[FAILED]]]

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String [[descriptor]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor visitAnnotation ( final String [[form]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[form]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 831 ---------------------------------------------
Lookup the type data for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData _lookupTypeData ( final Class [[eccentric]] ) { TypeData typeData = typeDataMap . get ( [[eccentric]] ) ; if ( typeData == null ) { typeData = scanClassForAnnotations ( [[eccentric]] ) ; typeDataMap . put ( [[eccentric]] , typeData ) ; } return typeData ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 832 ---------------------------------------------
Lookup the type data for the specified type.@param type the type@return the type data --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class [[type]] ) { TypeData typeData = typeDataMap . get ( [[type]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[type]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData lookupTypeData ( final Class [[typewrite]] ) { TypeData typeData = typeDataMap . get ( [[typewrite]] ) ; if ( typeData == null ) { if ( serializationSubclassAware ) { typeData = findSubclassTypeData ( [[typewrite]] ) ; } if ( typeData == null ) { typeData = scanClassForAnnotations ( [[typewrite]] ) ; typeDataMap . put ( [[typewrite]] , typeData ) ; } } return typeData ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 833 ---------------------------------------------
Puts a value into the map.@param profile the profile name@param map the map@param key the key@param value the value --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[put]] ( final String [[profile]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , [[profile]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void [[assign]] ( final String [[visibility]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String realValue = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( key , realValue , [[visibility]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 834 ---------------------------------------------
Injects the target object into the proxy. --> [[[FAILED]]]

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[field]] = proxyClass . getField ( "$___target$0" ) ; [[field]] . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void injectTargetIntoProxy ( final Object proxy , final Object target ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[plain]] = proxyClass . getField ( "$___target$0" ) ; [[plain]] . set ( proxy , target ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 835 ---------------------------------------------
Gets the contents of a file. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public byte [ ] getFileContent ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] getFileContent ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 836 ---------------------------------------------
Finds the subtype data for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[type]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[type]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData findSubclassTypeData ( final Class [[eccentric]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[eccentric]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 837 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 802 / 19 / 837:  84%|████████▎ | 837/1000 [28:12<05:29,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 802 / 19 / 837:  84%|████████▍ | 838/1000 [28:13<05:27,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 803 / 19 / 838:  84%|████████▍ | 838/1000 [28:13<05:27,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 804 / 19 / 839:  84%|████████▍ | 839/1000 [28:14<05:25,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 804 / 19 / 839:  84%|████████▍ | 840/1000 [28:15<05:22,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 805 / 19 / 840:  84%|████████▍ | 840/1000 [28:15<05:22,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 806 / 19 / 841:  84%|████████▍ | 841/1000 [28:15<05:20,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 806 / 19 / 841:  84%|████████▍ | 842/1000 [28:15<05:18,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 807 / 19 / 842:  84%|████████▍ | 842/1000 [28:15<05:18,  2.01s/it][Succeeded / Failed / Skipped / Total] 16 / 808 / 19 / 843:  84%|████████▍ | 843/1000 [28:27<05:17,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 808 / 19 / 843:  84%|████████▍ | 844/1000 [28:27<05:15,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 809 / 19 / 844:  84%|████████▍ | 844/1000 [28:27<05:15,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 809 / 19 / 844:  84%|████████▍ | 845/1000 [28:29<05:13,  2.02s/it]Creates an action runtime. --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] [[filters]] , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , [[filters]] , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] [[trickle]] , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , [[trickle]] , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 838 ---------------------------------------------
Copies bootstrap methods from the specified class reader to the specified character buffer. --> [[[FAILED]]]

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void copyBootstrapMethods ( final ClassReader classReader , final char [ ] charBuffer ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 839 ---------------------------------------------
Sets the major version and class name. --> [[[FAILED]]]

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 840 ---------------------------------------------
Resolve the real name for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveRealName ( final Class [[type]] , final String jsonName ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String resolveRealName ( final Class [[eccentric]] , final String jsonName ) { TypeData typeData = lookupTypeData ( [[eccentric]] ) ; return typeData . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 841 ---------------------------------------------
Puts a constant pool into the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: void putConstantPool ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void putConstantPool ( final ByteVector [[outturn]] ) { [[outturn]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 842 ---------------------------------------------
Put bootstrap methods.@param output the output --> [[[FAILED]]]

[[[[Adv]]]]: void putBootstrapMethods ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void putBootstrapMethods ( final ByteVector [[outturn]] ) { if ( bootstrapMethods != null ) { [[outturn]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 843 ---------------------------------------------
Copies all bytes from the input stream to the output stream.@param out the output stream@return the number of bytes copied --> [[[FAILED]]]

[[[[Adv]]]]: public int copyAll ( final OutputStream [[out]] ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[out]] . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream [[forbidden]] ) throws IOException { int count = 0 ; while ( "[[confessedly]]" == "[[confessedly]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } [[forbidden]] . write ( b ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 844 ---------------------------------------------
Resolve a JSON name for the given type.@param type the type@param name the name@return the name --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveJsonName ( final Class [[type]] , final String [[name]] ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String resolveJsonName ( final Class [[eccentric]] , final String [[key]] ) { TypeData typeData = lookupTypeData ( [[eccentric]] ) ; return typeData . resolveJsonName ( [[key]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 845 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 810 / 19 / 845:  84%|████████▍ | 845/1000 [28:29<05:13,  2.02s/it][Succeeded / Failed / Skipped / Total] 16 / 810 / 19 / 845:  85%|████████▍ | 846/1000 [28:41<05:13,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 811 / 19 / 846:  85%|████████▍ | 846/1000 [28:41<05:13,  2.03s/it][Succeeded / Failed / Skipped / Total] 16 / 811 / 19 / 846:  85%|████████▍ | 847/1000 [28:53<05:13,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 812 / 19 / 847:  85%|████████▍ | 847/1000 [28:53<05:13,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 812 / 19 / 847:  85%|████████▍ | 848/1000 [28:56<05:11,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 813 / 19 / 848:  85%|████████▍ | 848/1000 [28:56<05:11,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 813 / 19 / 848:  85%|████████▍ | 849/1000 [28:56<05:08,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 814 / 19 / 849:  85%|████████▍ | 849/1000 [28:56<05:08,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 814 / 19 / 849:  85%|████████▌ | 850/1000 [28:57<05:06,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 815 / 19 / 850:  85%|████████▌ | 850/1000 [28:57<05:06,  2.04s/it][Succeeded / Failed / Skipped / Total] 16 / 815 / 19 / 850:  85%|████████▌ | 851/1000 [29:00<05:04,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 816 / 19 / 851:  85%|████████▌ | 851/1000 [29:00<05:04,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 816 / 19 / 851:  85%|████████▌ | 852/1000 [29:02<05:02,  2.05s/it]Adds a constant field reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Copies all bytes from the input stream to the output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public int copyMax ( final OutputStream [[out]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } [[out]] . write ( [[b]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int copyMax ( final OutputStream [[taboo]] , final int maxBytes ) throws IOException { int count = 0 ; while ( "[[genuine]]" == "[[genuine]]" ) { byte [[B]] = readByte ( ) ; if ( isBoundary ( [[B]] ) ) { break ; } [[taboo]] . write ( [[B]] ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 847 ---------------------------------------------
Adds a reference to a constant field. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMemberReference ( final int [[index]] , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( [[index]] , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMemberReference ( final int [[exponent]] , final int tag , final String owner , final String name , final String descriptor ) { add ( new Entry ( [[exponent]] , tag , owner , name , descriptor , 0 , hash ( tag , owner , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 848 ---------------------------------------------
Adds a constant method reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean isInterface ) { int tag = isInterface ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 849 ---------------------------------------------
Adds an integer or float constant. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantIntegerOrFloat ( final int tag , final int value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( tag ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant integer or float entry. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int [[value]] ) { add ( new Entry ( index , tag , [[value]] , hash ( tag , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantIntegerOrFloat ( final int index , final int tag , final int [[appraise]] ) { add ( new Entry ( index , tag , [[appraise]] , hash ( tag , [[appraise]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant long or double entry. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int [[tag]] , final long value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantLongOrDouble ( final int index , final int [[rag]] , final long value ) { add ( new Entry ( index , [[rag]] , value , hash ( [[rag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 852 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 817 / 19 / 852:  85%|████████▌ | 852/1000 [29:02<05:02,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 817 / 19 / 852:  85%|████████▌ | 853/1000 [29:05<05:00,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 818 / 19 / 853:  85%|████████▌ | 853/1000 [29:05<05:00,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 818 / 19 / 853:  85%|████████▌ | 854/1000 [29:09<04:59,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 819 / 19 / 854:  85%|████████▌ | 854/1000 [29:09<04:59,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 819 / 19 / 854:  86%|████████▌ | 855/1000 [29:11<04:57,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 820 / 19 / 855:  86%|████████▌ | 855/1000 [29:11<04:57,  2.05s/it][Succeeded / Failed / Skipped / Total] 16 / 820 / 19 / 855:  86%|████████▌ | 856/1000 [29:22<04:56,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 821 / 19 / 856:  86%|████████▌ | 856/1000 [29:22<04:56,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 821 / 19 / 856:  86%|████████▌ | 857/1000 [29:25<04:54,  2.06s/it]Adds a constant long or double. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantLongOrDouble ( final int tag , final long value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a new entry to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String [[name]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[name]] , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( [[name]] ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[name]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[name]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String [[epithet]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[epithet]] , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . owner . equals ( owner ) && entry . name . equals ( [[epithet]] ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[epithet]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[epithet]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String [[value]] ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8 ( final int index , final String [[appreciate]] ) { add ( new Entry ( index , Symbol . CONSTANT_UTF8_TAG , [[appreciate]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[appreciate]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a constant name and type. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantNameAndType ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 857 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 822 / 19 / 857:  86%|████████▌ | 857/1000 [29:25<04:54,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 822 / 19 / 857:  86%|████████▌ | 858/1000 [29:26<04:52,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 823 / 19 / 858:  86%|████████▌ | 858/1000 [29:26<04:52,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 823 / 19 / 858:  86%|████████▌ | 859/1000 [29:32<04:50,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 824 / 19 / 859:  86%|████████▌ | 859/1000 [29:32<04:50,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 824 / 19 / 859:  86%|████████▌ | 860/1000 [29:33<04:48,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 825 / 19 / 860:  86%|████████▌ | 860/1000 [29:33<04:48,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 825 / 19 / 860:  86%|████████▌ | 861/1000 [29:34<04:46,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 826 / 19 / 861:  86%|████████▌ | 861/1000 [29:34<04:46,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 826 / 19 / 861:  86%|████████▌ | 862/1000 [29:35<04:44,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 827 / 19 / 862:  86%|████████▌ | 862/1000 [29:35<04:44,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 827 / 19 / 862:  86%|████████▋ | 863/1000 [29:39<04:42,  2.06s/it]Adds a constant name and type. --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantNameAndType ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Adds a constant dynamically. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String [[name]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[name]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String [[list]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , [[list]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
Adds a constant invoke dynamic reference. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String [[name]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantInvokeDynamic ( final String [[diagnose]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[diagnose]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a bootstrap method to this class. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol addBootstrapMethod ( final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 861 ---------------------------------------------
Adds a constant method handle. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantMethodHandle ( final int index , final int referenceKind , final String owner , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , owner , name , descriptor , referenceKind ) ; add ( new Entry ( index , tag , owner , name , descriptor , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 862 ---------------------------------------------
Adds a type to the specified table.@param typeTableIndex1 The index of the first type in the table.@param typeTableIndex2 The index of the second type in the table. --> [[[FAILED]]]

[[[[Adv]]]]: int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int addMergedType ( final int typeTableIndex1 , final int typeTableIndex2 ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 863 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 828 / 19 / 863:  86%|████████▋ | 863/1000 [29:39<04:42,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 828 / 19 / 863:  86%|████████▋ | 864/1000 [29:44<04:40,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 829 / 19 / 864:  86%|████████▋ | 864/1000 [29:44<04:40,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 829 / 19 / 864:  86%|████████▋ | 865/1000 [29:51<04:39,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 830 / 19 / 865:  86%|████████▋ | 865/1000 [29:51<04:39,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 830 / 19 / 865:  87%|████████▋ | 866/1000 [29:54<04:37,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 831 / 19 / 866:  87%|████████▋ | 866/1000 [29:54<04:37,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 831 / 19 / 866:  87%|████████▋ | 867/1000 [29:58<04:35,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 832 / 19 / 867:  87%|████████▋ | 867/1000 [29:58<04:35,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 832 / 19 / 867:  87%|████████▋ | 868/1000 [30:00<04:33,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 833 / 19 / 868:  87%|████████▋ | 868/1000 [30:00<04:33,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 833 / 19 / 868:  87%|████████▋ | 869/1000 [30:01<04:31,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 834 / 19 / 869:  87%|████████▋ | 869/1000 [30:01<04:31,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 834 / 19 / 869:  87%|████████▋ | 870/1000 [30:02<04:29,  2.07s/it]Adds a constant method handle. --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodHandle ( final int referenceKind , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 864 ---------------------------------------------
Adds a constant utf8 reference. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantUtf8Reference ( final int index , final int tag , final String value ) { add ( new Entry ( index , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 865 ---------------------------------------------
Returns an iterator over the elements of this map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > iterator ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 866 ---------------------------------------------
Adds a constant to the constant pool. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int [[tag]] , final String value ) { int hashCode = hash ( [[tag]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( [[tag]] , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantUtf8Reference ( final int [[shred]] , final String value ) { int hashCode = hash ( [[shred]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[shred]] && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( [[shred]] , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , [[shred]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 867 ---------------------------------------------
Removes all entries from this map. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpMultiMap < V > [[clear]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > [[exculpated]] ( ) { for ( int i = 0 ; i < entries . length ; i ++ ) { entries [ i ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 868 ---------------------------------------------
Grows the buffer.@param minCapacity the min capacity --> [[[FAILED]]]

[[[[Adv]]]]: private void [[grow]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[farm]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 869 ---------------------------------------------
Adds a constant dynamic or invoke dynamic reference. --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 870 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 835 / 19 / 870:  87%|████████▋ | 870/1000 [30:02<04:29,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 835 / 19 / 870:  87%|████████▋ | 871/1000 [30:02<04:27,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 836 / 19 / 871:  87%|████████▋ | 871/1000 [30:02<04:27,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 837 / 19 / 872:  87%|████████▋ | 872/1000 [30:02<04:24,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 837 / 19 / 872:  87%|████████▋ | 873/1000 [30:03<04:22,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 838 / 19 / 873:  87%|████████▋ | 873/1000 [30:03<04:22,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 839 / 19 / 874:  87%|████████▋ | 874/1000 [30:04<04:20,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 839 / 19 / 874:  88%|████████▊ | 875/1000 [30:06<04:18,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 840 / 19 / 875:  88%|████████▊ | 875/1000 [30:06<04:18,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 841 / 19 / 876:  88%|████████▊ | 876/1000 [30:11<04:16,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 841 / 19 / 876:  88%|████████▊ | 877/1000 [30:11<04:14,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 842 / 19 / 877:  88%|████████▊ | 877/1000 [30:11<04:14,  2.07s/it]Visits an annotation. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , visible ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 871 ---------------------------------------------
Visit the end of the chain. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void visitEnd ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[phosphorus]] = 0 ; [[phosphorus]] < tmd . proxyData . length ; [[phosphorus]] ++ ) { tmd . selectCurrentProxy ( [[phosphorus]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 872 ---------------------------------------------
Create the first chain delegate. --> [[[FAILED]]]

[[[[Adv]]]]: protected void createFirstChainDelegate_Start ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void createFirstChainDelegate_Start ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 873 ---------------------------------------------
Adds a constant dynamic or invoke dynamic reference. --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int [[index]] , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( [[index]] , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int [[exponent]] , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( [[exponent]] , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 874 ---------------------------------------------
Returns a list of all entries in this queue. --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > [[all]] = new LinkedList <> ( ) ; MapEntry < V > [[e]] = head . after ; while ( [[e]] != head ) { [[all]] . add ( [[e]] ) ; [[e]] = [[e]] . after ; } return [[all]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > entries ( ) { List < Map . Entry < String , V > > [[wholly]] = new LinkedList <> ( ) ; MapEntry < V > [[E]] = head . after ; while ( [[E]] != head ) { [[wholly]] . add ( [[E]] ) ; [[E]] = [[E]] . after ; } return [[wholly]] ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 875 ---------------------------------------------
Parses the supplied string into a path. --> [[[FAILED]]]

[[[[Adv]]]]: public static Path parse ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path parse ( final String [[course]] ) { return [[course]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[course]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 876 ---------------------------------------------
Creates the first chain delegate method.@param tmd the target method data --> [[[FAILED]]]

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "[[False]]" != "[[False]]" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "[[False]]" != "[[False]]" ) ; } visitReturn ( methodVisitor , tmd . msign , "[[False]]" != "[[False]]" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData tmd ) { methodVisitor . visitCode ( ) ; if ( tmd . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "[[treacherously]]" != "[[treacherously]]" ) ; } else { loadSpecialMethodArguments ( methodVisitor , tmd . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , tmd . firstMethodName ( ) , tmd . msign . getDescription ( ) , "[[treacherously]]" != "[[treacherously]]" ) ; } visitReturn ( methodVisitor , tmd . msign , "[[treacherously]]" != "[[treacherously]]" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 877 ---------------------------------------------
Returns the hash of the given name. --> [[[FAILED]]]

[[[[Adv]]]]: private int [[hash]] ( final String [[name]] ) { int h = 0 ; for ( int [[i]] = [[name]] . length ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { char c = [[name]] . charAt ( [[i]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int [[haschisch]] ( final String [[appoint]] ) { int h = 0 ; for ( int [[iodine]] = [[appoint]] . length ( ) - 1 ; [[iodine]] >= 0 ; [[iodine]] -- ) { char c = [[appoint]] . charAt ( [[iodine]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 878 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 843 / 19 / 878:  88%|████████▊ | 878/1000 [30:12<04:11,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 843 / 19 / 878:  88%|████████▊ | 879/1000 [30:13<04:09,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 844 / 19 / 879:  88%|████████▊ | 879/1000 [30:13<04:09,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 845 / 19 / 880:  88%|████████▊ | 880/1000 [30:15<04:07,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 845 / 19 / 880:  88%|████████▊ | 881/1000 [30:16<04:05,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 846 / 19 / 881:  88%|████████▊ | 881/1000 [30:16<04:05,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 847 / 19 / 882:  88%|████████▊ | 882/1000 [30:21<04:03,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 847 / 19 / 882:  88%|████████▊ | 883/1000 [30:21<04:01,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 848 / 19 / 883:  88%|████████▊ | 883/1000 [30:21<04:01,  2.06s/it]Configures the servlet context. --> [[[FAILED]]]

[[[[Adv]]]]: private void configureServletContext ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void configureServletContext ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 879 ---------------------------------------------
Converts a JtxTransactionMode to a DB mode.@param txMode the JtxTransactionMode to convert.@return the DB mode. --> [[[FAILED]]]

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode convertToDbMode ( final JtxTransactionMode txMode ) { final int isolation ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : isolation = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : isolation = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : isolation = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : isolation = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : isolation = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : isolation = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( isolation , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 880 ---------------------------------------------
Executes the specified method. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[execute]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;

[[[[Adv]]]]: public Object [[action]] ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 881 ---------------------------------------------
Returns all the field descriptors in this class. --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] getAllFieldDescriptors ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor fieldDescriptor : fieldsMap . values ( ) ) { allFields [ index ] = fieldDescriptor ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 882 ---------------------------------------------
Returns a list of all values with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public List < V > getAll ( final String [[name]] ) { LinkedList < V > [[values]] = new LinkedList <> ( ) ; int h = hash ( [[name]] ) ; int i = index ( h ) ; MapEntry < V > [[e]] = entries [ i ] ; while ( [[e]] != null ) { if ( [[e]] . hash == h && eq ( [[name]] , [[e]] . key ) ) { [[values]] . addFirst ( [[e]] . getValue ( ) ) ; } [[e]] = [[e]] . next ; } return [[values]] ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > getAll ( final String [[constitute]] ) { LinkedList < V > [[evaluate]] = new LinkedList <> ( ) ; int h = hash ( [[constitute]] ) ; int i = index ( h ) ; MapEntry < V > [[einsteinium]] = entries [ i ] ; while ( [[einsteinium]] != null ) { if ( [[einsteinium]] . hash == h && eq ( [[constitute]] , [[einsteinium]] . key ) ) { [[evaluate]] . addFirst ( [[einsteinium]] . getValue ( ) ) ; } [[einsteinium]] = [[einsteinium]] . next ; } return [[evaluate]] ; }
[[[[Nl]]]]: Returns all values associated with the name .
--------------------------------------------- Result 883 ---------------------------------------------
Reads a property from the source object. --> [[[FAILED]]]

[[[[Adv]]]]: private Object readProperty ( final Object [[source]] , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object readProperty ( final Object [[reservoir]] , final PropertyDescriptor propertyDescriptor ) { Getter getter = propertyDescriptor . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( [[reservoir]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 884 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 849 / 19 / 884:  88%|████████▊ | 884/1000 [30:24<03:59,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 849 / 19 / 884:  88%|████████▊ | 885/1000 [30:24<03:57,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 850 / 19 / 885:  88%|████████▊ | 885/1000 [30:24<03:57,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 851 / 19 / 886:  89%|████████▊ | 886/1000 [30:29<03:55,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 851 / 19 / 886:  89%|████████▊ | 887/1000 [30:30<03:53,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 852 / 19 / 887:  89%|████████▊ | 887/1000 [30:30<03:53,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 853 / 19 / 888:  89%|████████▉ | 888/1000 [30:32<03:51,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 853 / 19 / 888:  89%|████████▉ | 889/1000 [30:34<03:49,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 854 / 19 / 889:  89%|████████▉ | 889/1000 [30:34<03:49,  2.06s/it][Succeeded / Failed / Skipped / Total] 16 / 855 / 19 / 890:  89%|████████▉ | 890/1000 [30:56<03:49,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 855 / 19 / 890:  89%|████████▉ | 891/1000 [30:57<03:47,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 856 / 19 / 891:  89%|████████▉ | 891/1000 [30:57<03:47,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 856 / 19 / 891:  89%|████████▉ | 892/1000 [31:03<03:45,  2.09s/it]Append a new buffer to the end of the list.@param buffer the buffer to append.@return the new buffer. --> [[[FAILED]]]

[[[[Adv]]]]: public Buffer append ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer append ( final Buffer buffer ) { if ( buffer . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 885 ---------------------------------------------
Puts all entries in the supplied map into this map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void putAll ( final Map t ) { for ( Object o : t . entrySet ( ) ) { Map . Entry e = ( Map . Entry ) o ; put ( e . getKey ( ) , e . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 886 ---------------------------------------------
Writes the data to the specified writer. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final Writer [[writer]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] [[array]] = fastByteBuffer . toArray ( ) ; [[writer]] . write ( new String ( [[array]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void writeTo ( final Writer [[author]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; byte [ ] [[raiment]] = fastByteBuffer . toArray ( ) ; [[author]] . write ( new String ( [[raiment]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[author]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 887 ---------------------------------------------
Pushes the specified character sequence onto this path. --> [[[FAILED]]]

[[[[Adv]]]]: public Path [[push]] ( final CharSequence [[field]] ) { _push ( [[field]] ) ; if ( altPath != null ) { altPath . push ( [[field]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[force]] ( final CharSequence [[battleground]] ) { _push ( [[battleground]] ) ; if ( altPath != null ) { altPath . push ( [[battleground]] ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 888 ---------------------------------------------
Writes to the specified output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[out]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void writeTo ( final OutputStream [[extinct]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[extinct]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[extinct]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 889 ---------------------------------------------
Writes the response to the specified output stream.@param out the output stream to write to.@param progressListener the listener to notify.@throws IOException if an I/O error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void writeTo ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 890 ---------------------------------------------
Gets the value associated with the supplied key.@param key the key@return the value associated with the supplied key, or null if there is no such key --> [[[FAILED]]]

[[[[Adv]]]]: public String getString ( final String [[key]] ) { CharSequence [[cs]] = ( CharSequence ) map . get ( [[key]] ) ; return [[cs]] == null ? null : [[cs]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String getString ( final String [[name]] ) { CharSequence [[C]] = ( CharSequence ) map . get ( [[name]] ) ; return [[C]] == null ? null : [[C]] . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 891 ---------------------------------------------
Create a bean definition for the given name and type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[name]] , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory [[builder]] = proxetta . proxy ( ) ; [[builder]] . setTarget ( type ) ; type = [[builder]] . define ( ) ; return new ProxettaBeanDefinition ( [[name]] , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[name]] , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String [[identify]] , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory [[constructor]] = proxetta . proxy ( ) ; [[constructor]] . setTarget ( type ) ; type = [[constructor]] . define ( ) ; return new ProxettaBeanDefinition ( [[identify]] , type , scope , wiringMode , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( [[identify]] , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 892 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 857 / 19 / 892:  89%|████████▉ | 892/1000 [31:03<03:45,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 857 / 19 / 892:  89%|████████▉ | 893/1000 [31:05<03:43,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 858 / 19 / 893:  89%|████████▉ | 893/1000 [31:05<03:43,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 858 / 19 / 893:  89%|████████▉ | 894/1000 [31:08<03:41,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 859 / 19 / 894:  89%|████████▉ | 894/1000 [31:08<03:41,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 859 / 19 / 894:  90%|████████▉ | 895/1000 [31:15<03:40,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 860 / 19 / 895:  90%|████████▉ | 895/1000 [31:15<03:40,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 860 / 19 / 895:  90%|████████▉ | 896/1000 [31:22<03:38,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 861 / 19 / 896:  90%|████████▉ | 896/1000 [31:22<03:38,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 861 / 19 / 896:  90%|████████▉ | 897/1000 [31:23<03:36,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 862 / 19 / 897:  90%|████████▉ | 897/1000 [31:23<03:36,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 862 / 19 / 897:  90%|████████▉ | 898/1000 [31:26<03:34,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 863 / 19 / 898:  90%|████████▉ | 898/1000 [31:26<03:34,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 863 / 19 / 898:  90%|████████▉ | 899/1000 [31:30<03:32,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 864 / 19 / 899:  90%|████████▉ | 899/1000 [31:30<03:32,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 864 / 19 / 899:  90%|█████████ | 900/1000 [31:30<03:30,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 865 / 19 / 900:  90%|█████████ | 900/1000 [31:30<03:30,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 865 / 19 / 900:  90%|█████████ | 901/1000 [31:33<03:28,  2.10s/it]Gets the value associated with the given key.@param key the key.@return the value associated with the given key. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T val = ( T ) map . get ( key ) ; if ( val instanceof Map ) { return ( T ) new JsonObject ( ( Map ) val ) ; } if ( val instanceof List ) { return ( T ) new JsonArray ( ( List ) val ) ; } return val ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 893 ---------------------------------------------
Opens the specified folder. --> [[[FAILED]]]

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . [[folder]] = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . folderName = folderName ; this . [[brochure]] = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 894 ---------------------------------------------
Append the specified sequence to this buffer.@param csq The sequence to append.@param start The index of the first character in the sequence.@param end The index of the last character in the sequence.@return This buffer. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int [[start]] , final int [[end]] ) { for ( int [[i]] = [[start]] ; [[i]] < [[end]] ; [[i]] ++ ) { append ( csq . charAt ( [[i]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence csq , final int [[kickoff]] , final int [[destruction]] ) { for ( int [[single]] = [[kickoff]] ; [[single]] < [[destruction]] ; [[single]] ++ ) { append ( csq . charAt ( [[single]] ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 895 ---------------------------------------------
Updates the flags for the given received email. --> [[[FAILED]]]

[[[[Adv]]]]: public void updateEmailFlags ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void updateEmailFlags ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , "[[dependable]]" == "[[dependable]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 896 ---------------------------------------------
Closes the specified folder. --> [[[FAILED]]]

[[[[Adv]]]]: protected void closeFolderIfOpened ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void closeFolderIfOpened ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
--------------------------------------------- Result 897 ---------------------------------------------
Retrieve a property as an Integer.@param key the key of the property to retrieve. May not be <code>null</code>.@return the property as an Integer, or <code>null</code> if the property could not be found.@throws IllegalArgumentException if the key is <code>null</code> or cannot be converted to an Integer. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer getInteger ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 898 ---------------------------------------------
Retrieve a property as a Float.@param key the key of the property to retrieve@return the property as a Float --> [[[FAILED]]]

[[[[Adv]]]]: public Float getFloat ( final String key ) { Number [[number]] = ( Number ) map . get ( key ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Float ) { return ( Float ) [[number]] ; } return [[number]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float getFloat ( final String key ) { Number [[act]] = ( Number ) map . get ( key ) ; if ( [[act]] == null ) { return null ; } if ( [[act]] instanceof Float ) { return ( Float ) [[act]] ; } return [[act]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 899 ---------------------------------------------
Retrieve a property as a Long.@param key the key of the property to retrieve. May not be <code>null</code>.@return the property as a Long, or <code>null</code> if the property was not found.@throws ClassCastException if the property cannot be converted to a Long. --> [[[FAILED]]]

[[[[Adv]]]]: public Long getLong ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long getLong ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 900 ---------------------------------------------
Concatenate the specified string with the specified target string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String alias ( final String target ) { return StringPool . LEFT_CHEV . concat ( target ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
[Succeeded / Failed / Skipped / Total] 16 / 866 / 19 / 901:  90%|█████████ | 901/1000 [31:33<03:28,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 866 / 19 / 901:  90%|█████████ | 902/1000 [31:34<03:25,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 867 / 19 / 902:  90%|█████████ | 902/1000 [31:34<03:25,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 868 / 19 / 903:  90%|█████████ | 903/1000 [31:34<03:23,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 868 / 19 / 903:  90%|█████████ | 904/1000 [31:34<03:21,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 869 / 19 / 904:  90%|█████████ | 904/1000 [31:34<03:21,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 870 / 19 / 905:  90%|█████████ | 905/1000 [31:35<03:18,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 870 / 19 / 905:  91%|█████████ | 906/1000 [31:38<03:16,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 871 / 19 / 906:  91%|█████████ | 906/1000 [31:38<03:16,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 872 / 19 / 907:  91%|█████████ | 907/1000 [31:38<03:14,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 872 / 19 / 907:  91%|█████████ | 908/1000 [31:40<03:12,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 873 / 19 / 908:  91%|█████████ | 908/1000 [31:40<03:12,  2.09s/it]--------------------------------------------- Result 901 ---------------------------------------------
Receives all messages from the specified folder.@param filter the filter to apply to the messages.@param flagsToSet the flags to set on the messages.@param flagsToUnset the flags to unset on the messages.@param envelope <code>true</code> if the messages should be enclosed in an envelope, <code>false</code> otherwise.@param processedMessageConsumer the consumer to process the messages. --> [[[FAILED]]]

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[messages]] ; try { if ( filter == null ) { [[messages]] = folder . getMessages ( ) ; } else { [[messages]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[messages]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[messages]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter filter , final Flags flagsToSet , final Flags flagsToUnset , final boolean envelope , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] [[content]] ; try { if ( filter == null ) { [[content]] = folder . getMessages ( ) ; } else { [[content]] = folder . search ( filter . getSearchTerm ( ) ) ; } if ( [[content]] . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( [[content]] , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 902 ---------------------------------------------
Retrieve a property as a Double.@param key the key of the property to retrieve@return the property as a Double --> [[[FAILED]]]

[[[[Adv]]]]: public Double getDouble ( final String key ) { Number [[number]] = ( Number ) map . get ( key ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Double ) { return ( Double ) [[number]] ; } return [[number]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double getDouble ( final String key ) { Number [[act]] = ( Number ) map . get ( key ) ; if ( [[act]] == null ) { return null ; } if ( [[act]] instanceof Double ) { return ( Double ) [[act]] ; } return [[act]] . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 903 ---------------------------------------------
Adds a value to the map.@param key the key@param value the value@return this object --> [[[FAILED]]]

[[[[Adv]]]]: public JsonObject put ( final String [[key]] , final String [[value]] ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject put ( final String [[name]] , final String [[assess]] ) { Objects . requireNonNull ( [[name]] ) ; map . put ( [[name]] , [[assess]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 904 ---------------------------------------------
Downloads a file as a raw data.@param downloadFileName the name of the file to download.@return this for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: public RawData downloadableAs ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData downloadableAs ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 905 ---------------------------------------------
Sets the target name.@param targetName the target name@return this --> [[[FAILED]]]

[[[[Adv]]]]: protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T setTarget ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 906 ---------------------------------------------
Lookup a named parameter.@param name the parameter name@return the named parameter or <code>null</code> --> [[[FAILED]]]

[[[[Adv]]]]: DbQueryNamedParameter lookupNamedParameter ( final String [[name]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[name]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter lookupNamedParameter ( final String [[call]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[call]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 907 ---------------------------------------------
Sets the mime or extension.@param mimeOrExtension the mime or extension@return this --> [[[FAILED]]]

[[[[Adv]]]]: public RawData [[as]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData [[axerophthol]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 908 ---------------------------------------------
Processes this class. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[appendage]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
[Succeeded / Failed / Skipped / Total] 16 / 874 / 19 / 909:  91%|█████████ | 909/1000 [31:41<03:10,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 874 / 19 / 909:  91%|█████████ | 910/1000 [31:41<03:08,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 875 / 19 / 910:  91%|█████████ | 910/1000 [31:41<03:08,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 876 / 19 / 911:  91%|█████████ | 911/1000 [31:42<03:05,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 876 / 19 / 911:  91%|█████████ | 912/1000 [31:42<03:03,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 877 / 19 / 912:  91%|█████████ | 912/1000 [31:42<03:03,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 878 / 19 / 913:  91%|█████████▏| 913/1000 [31:43<03:01,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 878 / 19 / 913:  91%|█████████▏| 914/1000 [31:43<02:59,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 879 / 19 / 914:  91%|█████████▏| 914/1000 [31:43<02:59,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 880 / 19 / 915:  92%|█████████▏| 915/1000 [31:43<02:56,  2.08s/it]--------------------------------------------- Result 909 ---------------------------------------------
Sets the target file. --> [[[FAILED]]]

[[[[Adv]]]]: protected T setTarget ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T setTarget ( final InputStream [[objective]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[objective]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 910 ---------------------------------------------
Sets the target class. --> [[[FAILED]]]

[[[[Adv]]]]: public T setTarget ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T setTarget ( final Class [[aim]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[aim]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[aim]] . getName ( ) ) ; } targetClass = [[aim]] ; targetClassName = [[aim]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[aim]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 911 ---------------------------------------------
Adds a violation to the validator. --> [[[FAILED]]]

[[[[Adv]]]]: protected void addViolation ( final String [[name]] , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[name]] , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void addViolation ( final String [[list]] , final Object invalidValue ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[list]] , this , invalidValue ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 912 ---------------------------------------------
Validates the action.@param profiles the profiles to validate.@return <code>true</code> if the action is valid, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean validateAction ( final String ... [[profiles]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[profiles]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean validateAction ( final String ... [[visibility]] ) { prepareValidator ( ) ; vtor . useProfiles ( [[visibility]] ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 913 ---------------------------------------------
Creates a new email address with the given name and from address.@param personalName the name of the email address@param from the from address@return the created email address --> [[[FAILED]]]

[[[[Adv]]]]: public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T from ( final String personalName , final String from ) { return from ( new EmailAddress ( personalName , from ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 914 ---------------------------------------------
Defines the proxied class. --> [[[FAILED]]]

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[delimit]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 915 ---------------------------------------------
Creates a new Proxetta instance. --> [[[FAILED]]]

[[[[Adv]]]]: public Object newInstance ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object newInstance ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 916 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 881 / 19 / 916:  92%|█████████▏| 916/1000 [31:43<02:54,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 881 / 19 / 916:  92%|█████████▏| 917/1000 [31:43<02:52,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 882 / 19 / 917:  92%|█████████▏| 917/1000 [31:43<02:52,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 883 / 19 / 918:  92%|█████████▏| 918/1000 [31:43<02:50,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 884 / 19 / 919:  92%|█████████▏| 919/1000 [31:44<02:47,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 884 / 19 / 919:  92%|█████████▏| 920/1000 [31:46<02:45,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 885 / 19 / 920:  92%|█████████▏| 920/1000 [31:46<02:45,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 886 / 19 / 921:  92%|█████████▏| 921/1000 [31:49<02:43,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 887 / 19 / 922:  92%|█████████▏| 922/1000 [31:53<02:41,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 887 / 19 / 922:  92%|█████████▏| 923/1000 [31:54<02:39,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 888 / 19 / 923:  92%|█████████▏| 923/1000 [31:54<02:39,  2.07s/it][Succeeded / Failed / Skipped / Total] 16 / 889 / 19 / 924:  92%|█████████▏| 924/1000 [31:56<02:37,  2.07s/it]Dumps the class in debug folder. --> [[[FAILED]]]

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void dumpClassInDebugFolder ( final byte [ ] bytes ) { File debugFolder = proxetta . getDebugFolder ( ) ; if ( debugFolder == null ) { return ; } if ( ! debugFolder . exists ( ) || ! debugFolder . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + debugFolder ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( debugFolder , fileName ) ; try { FileUtil . writeBytes ( file , bytes ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 917 ---------------------------------------------
Converts the supplied email address into this object.@param to the email address to convert.@return this object. --> [[[FAILED]]]

[[[[Adv]]]]: public T to ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T to ( final EmailAddress to ) { this . to = ArraysUtil . append ( this . to , to ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 918 ---------------------------------------------
Converts the specified email address to the specified one.@param personalName The name of the email address.@param to The address to convert.@return The converted email address. --> [[[FAILED]]]

[[[[Adv]]]]: public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T to ( final String personalName , final String to ) { return to ( new EmailAddress ( personalName , to ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 919 ---------------------------------------------
Set the reply to address.@param REPLACEME0 the address to set@return this object --> [[[FAILED]]]

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . replyTo = ArraysUtil . join ( this . replyTo , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 920 ---------------------------------------------
Sets the html message.@param html the html message@param encoding the encoding@return the t --> [[[FAILED]]]

[[[[Adv]]]]: public T htmlMessage ( final String html , final String [[encoding]] ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T htmlMessage ( final String html , final String [[encryption]] ) { return message ( new EmailMessage ( html , MimeTypes . MIME_TEXT_HTML , [[encryption]] ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 921 ---------------------------------------------
Creates a text message. --> [[[FAILED]]]

[[[[Adv]]]]: public T textMessage ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T textMessage ( final String [[schoolbook]] , final String [[encryption]] ) { return message ( new EmailMessage ( [[schoolbook]] , MimeTypes . MIME_TEXT_PLAIN , [[encryption]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 922 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[produce]] ( ) { process ( ) ; byte [ ] [[event]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[event]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[event]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 923 ---------------------------------------------
Gets the resolved parameters. --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] getResolvedParameters ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 924 ---------------------------------------------
Sets the cc recipient. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[millilitre]] ( final EmailAddress ... ccs ) { this . cc = ArraysUtil . join ( this . cc , valueOrEmptyArray ( ccs ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
--------------------------------------------- Result 925 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 890 / 19 / 925:  92%|█████████▎| 925/1000 [32:06<02:36,  2.08s/it][Succeeded / Failed / Skipped / Total] 16 / 890 / 19 / 925:  93%|█████████▎| 926/1000 [32:13<02:34,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 891 / 19 / 926:  93%|█████████▎| 926/1000 [32:13<02:34,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 891 / 19 / 926:  93%|█████████▎| 927/1000 [32:21<02:32,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 892 / 19 / 927:  93%|█████████▎| 927/1000 [32:21<02:32,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 892 / 19 / 927:  93%|█████████▎| 928/1000 [32:22<02:30,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 893 / 19 / 928:  93%|█████████▎| 928/1000 [32:22<02:30,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 893 / 19 / 928:  93%|█████████▎| 929/1000 [32:24<02:28,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 894 / 19 / 929:  93%|█████████▎| 929/1000 [32:24<02:28,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 894 / 19 / 929:  93%|█████████▎| 930/1000 [32:25<02:26,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 895 / 19 / 930:  93%|█████████▎| 930/1000 [32:25<02:26,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 895 / 19 / 930:  93%|█████████▎| 931/1000 [32:26<02:24,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 896 / 19 / 931:  93%|█████████▎| 931/1000 [32:26<02:24,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 896 / 19 / 931:  93%|█████████▎| 932/1000 [32:27<02:22,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 897 / 19 / 932:  93%|█████████▎| 932/1000 [32:27<02:22,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 897 / 19 / 932:  93%|█████████▎| 933/1000 [32:31<02:20,  2.09s/it]Lookup the action path for the given alias. --> [[[FAILED]]]

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String [[value]] = actionsManager . lookupPathAlias ( alias ) ; if ( [[value]] == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { [[value]] = cfg . getActionPath ( ) ; } } return [[value]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String [[valuate]] = actionsManager . lookupPathAlias ( alias ) ; if ( [[valuate]] == null ) { ActionRuntime cfg = actionsManager . lookup ( alias ) ; if ( cfg != null ) { [[valuate]] = cfg . getActionPath ( ) ; } } return [[valuate]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 926 ---------------------------------------------
Sets the value of the specified header. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[header]] ( final String name , final String [[value]] ) { headers . put ( name , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[lintel]] ( final String name , final String [[respect]] ) { headers . put ( name , [[respect]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 927 ---------------------------------------------
Retrieve a long value from the properties file.@param name name of the property to retrieve.@param defaultValue default value to return if the property is not found.@return long value or default value. --> [[[FAILED]]]

[[[[Adv]]]]: public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long getLong ( final String name , final long defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 928 ---------------------------------------------
Retrieves the value of an integer property.@param name The name of the property.@param defaultValue The default value.@return The property value. --> [[[FAILED]]]

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int defaultValue ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[key]] , final int defaultValue ) { String [[prize]] = get ( [[key]] ) ; if ( [[prize]] == null ) { return defaultValue ; } [[prize]] = [[prize]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[prize]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 929 ---------------------------------------------
Returns the index of the last dot of the specified string.@param str the specified string@return the index of the last dot of the specified string --> [[[FAILED]]]

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int lastIndexOfSlashDot ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 930 ---------------------------------------------
Returns the index of the last dot after the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int lastIndexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 931 ---------------------------------------------
Returns the index of the first dot after the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return str . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 932 ---------------------------------------------
Resolve an alias for the supplied value.@param value the value to resolve.@return the alias. --> [[[FAILED]]]

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int [[i]] = 0 ; int len = value . length ( ) ; while ( [[i]] < len ) { int ndx = value . indexOf ( ' ' , [[i]] ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String resolveAlias ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int [[unity]] = 0 ; int len = value . length ( ) ; while ( [[unity]] < len ) { int ndx = value . indexOf ( ' ' , [[unity]] ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 933 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 898 / 19 / 933:  93%|█████████▎| 933/1000 [32:31<02:20,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 898 / 19 / 933:  93%|█████████▎| 934/1000 [32:39<02:18,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 899 / 19 / 934:  93%|█████████▎| 934/1000 [32:39<02:18,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 899 / 19 / 934:  94%|█████████▎| 935/1000 [32:39<02:16,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 900 / 19 / 935:  94%|█████████▎| 935/1000 [32:39<02:16,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 900 / 19 / 935:  94%|█████████▎| 936/1000 [32:47<02:14,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 901 / 19 / 936:  94%|█████████▎| 936/1000 [32:47<02:14,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 901 / 19 / 936:  94%|█████████▎| 937/1000 [32:51<02:12,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 902 / 19 / 937:  94%|█████████▎| 937/1000 [32:51<02:12,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 902 / 19 / 937:  94%|█████████▍| 938/1000 [32:52<02:10,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 903 / 19 / 938:  94%|█████████▍| 938/1000 [32:52<02:10,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 903 / 19 / 938:  94%|█████████▍| 939/1000 [32:53<02:08,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 904 / 19 / 939:  94%|█████████▍| 939/1000 [32:53<02:08,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 904 / 19 / 939:  94%|█████████▍| 940/1000 [32:57<02:06,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 905 / 19 / 940:  94%|█████████▍| 940/1000 [32:57<02:06,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 905 / 19 / 940:  94%|█████████▍| 941/1000 [32:59<02:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 906 / 19 / 941:  94%|█████████▍| 941/1000 [32:59<02:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 906 / 19 / 941:  94%|█████████▍| 942/1000 [33:01<02:02,  2.10s/it]Resolves the schema name for the given type.@param type the type@param defaultSchemaName the default schema name@return the resolved schema name --> [[[FAILED]]]

[[[[Adv]]]]: public static String resolveSchemaName ( final Class < ? > [[type]] , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = [[type]] . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String resolveSchemaName ( final Class < ? > [[typecast]] , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = [[typecast]] . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 934 ---------------------------------------------
Strips the last camel-word from the given name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[name]] ) { int ndx = [[name]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[name]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[name]] = [[name]] . substring ( 0 , ndx ) ; } return [[name]] ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[diagnose]] ) { int ndx = [[diagnose]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[diagnose]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[diagnose]] = [[diagnose]] . substring ( 0 , ndx ) ; } return [[diagnose]] ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 935 ---------------------------------------------
Resolves the supplied path to the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath resolveResultPath ( String path , String value ) { boolean absolutePath = "False" != "False" ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 936 ---------------------------------------------
Resolves the result path for the given path and value. --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveResultPathString ( final String [[path]] , final String value ) { final ResultPath resultPath = resolveResultPath ( [[path]] , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String resolveResultPathString ( final String [[course]] , final String value ) { final ResultPath resultPath = resolveResultPath ( [[course]] , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 937 ---------------------------------------------
Initializes the internal data structures. --> [[[FAILED]]]

[[[[Adv]]]]: public void init ( final long [ ] [[key]] , final long [ ] [[tweak]] ) { final int newNw = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void init ( final long [ ] [[discover]] , final long [ ] [[pinch]] ) { final int newNw = [[discover]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 938 ---------------------------------------------
Serialize a key-value pair.@param jsonContext the context@param currentPath the current path@param key the key@param value the value@param count the count --> [[[FAILED]]]

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object [[value]] , int [[count]] ) { if ( ( [[value]] == null ) && jsonContext . isExcludeNulls ( ) ) { return [[count]] ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object [[esteem]] , int [[reckon]] ) { if ( ( [[esteem]] == null ) && jsonContext . isExcludeNulls ( ) ) { return [[reckon]] ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 939 ---------------------------------------------
Renders a pixel at the specified dimension. --> [[[FAILED]]]

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 940 ---------------------------------------------
Schedules a key schedule. --> [[[FAILED]]]

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int i = 0 ; i < nw ; i ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 941 ---------------------------------------------
Resolve column descriptors.@param dbEntityDescriptorthe db entity descriptor@param propertythe property descriptor@param isAnnotatedthe is annotated@param columnNamethe column naming strategy@return the column descriptor --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor [[property]] , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor [[holding]] , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "False" != "False" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 942 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 907 / 19 / 942:  94%|█████████▍| 942/1000 [33:01<02:02,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 907 / 19 / 942:  94%|█████████▍| 943/1000 [33:02<01:59,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 908 / 19 / 943:  94%|█████████▍| 943/1000 [33:02<01:59,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 908 / 19 / 943:  94%|█████████▍| 944/1000 [33:05<01:57,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 909 / 19 / 944:  94%|█████████▍| 944/1000 [33:05<01:57,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 909 / 19 / 944:  94%|█████████▍| 945/1000 [33:07<01:55,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 910 / 19 / 945:  94%|█████████▍| 945/1000 [33:07<01:55,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 911 / 19 / 946:  95%|█████████▍| 946/1000 [33:07<01:53,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 911 / 19 / 946:  95%|█████████▍| 947/1000 [33:13<01:51,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 912 / 19 / 947:  95%|█████████▍| 947/1000 [33:13<01:51,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 913 / 19 / 948:  95%|█████████▍| 948/1000 [33:16<01:49,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 913 / 19 / 948:  95%|█████████▍| 949/1000 [33:19<01:47,  2.11s/it]Returns the value of the specified named property as a boolean.@param name The name of the property to retrieve.@param defaultValue The default value to return if the property is not found.@return The property value as a boolean. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean getBoolean ( final String [[name]] , final boolean defaultValue ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; switch ( [[value]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean getBoolean ( final String [[cite]] , final boolean defaultValue ) { String [[prize]] = get ( [[cite]] ) ; if ( [[prize]] == null ) { return defaultValue ; } [[prize]] = [[prize]] . trim ( ) . toLowerCase ( ) ; switch ( [[prize]] ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 943 ---------------------------------------------
Mix the specified dimension with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: private void mix ( final int j , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int j , final int [[calciferol]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[calciferol]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 944 ---------------------------------------------
Gets the path to the resource. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[way]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[way]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 945 ---------------------------------------------
Initializes this message with the specified key and tweak.@param keyMessage the key message@param tweak1 the tweak 1@param tweak2 the tweak 2 --> [[[FAILED]]]

[[[[Adv]]]]: public void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void init ( final String keyMessage , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 946 ---------------------------------------------
Gzip a file.@param file the file@return the file@throws IOException the io exception --> [[[FAILED]]]

[[[[Adv]]]]: public static File gzip ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; String gzipName = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File gzip ( final File [[charge]] ) throws IOException { if ( [[charge]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[charge]] ) ; String gzipName = [[charge]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 947 ---------------------------------------------
Encrypts the specified byte array at the specified offset. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] content , final int offset ) { long [ ] contentBlock = bytesToLongs ( content , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 948 ---------------------------------------------
Removes the specified bounding character from the specified string. --> [[[FAILED]]]

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( s ) ) && str . endsWith ( String . valueOf ( e ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 949 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 914 / 19 / 949:  95%|█████████▍| 949/1000 [33:19<01:47,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 915 / 19 / 950:  95%|█████████▌| 950/1000 [33:24<01:45,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 915 / 19 / 950:  95%|█████████▌| 951/1000 [33:26<01:43,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 916 / 19 / 951:  95%|█████████▌| 951/1000 [33:26<01:43,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 917 / 19 / 952:  95%|█████████▌| 952/1000 [33:47<01:42,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 917 / 19 / 952:  95%|█████████▌| 953/1000 [33:48<01:40,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 918 / 19 / 953:  95%|█████████▌| 953/1000 [33:48<01:40,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 918 / 19 / 953:  95%|█████████▌| 954/1000 [33:50<01:37,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 919 / 19 / 954:  95%|█████████▌| 954/1000 [33:50<01:37,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 919 / 19 / 954:  96%|█████████▌| 955/1000 [33:50<01:35,  2.13s/it]Ungzip a file. --> [[[FAILED]]]

[[[[Adv]]]]: public static File ungzip ( final File [[file]] ) throws IOException { String outFileName = FileNameUtil . removeExtension ( [[file]] . getAbsolutePath ( ) ) ; File [[out]] = new File ( outFileName ) ; [[out]] . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( [[out]] ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( [[file]] ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return [[out]] ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File [[charge]] ) throws IOException { String outFileName = FileNameUtil . removeExtension ( [[charge]] . getAbsolutePath ( ) ) ; File [[taboo]] = new File ( outFileName ) ; [[taboo]] . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( [[taboo]] ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( [[charge]] ) ) ; try { StreamUtil . copy ( gzis , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( gzis ) ; } return [[taboo]] ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 950 ---------------------------------------------
Zlib zlib.@param file the file@return the file@throws IOException the io exception --> [[[FAILED]]]

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = file . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 951 ---------------------------------------------
Unzip a zip file to a destination directory.@param zipFile the zip file@param destDir the destination directory@param patterns the patterns@throws IOException if an I/O error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public static void unzip ( final String zipFile , final String destDir , final String ... [[patterns]] ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir ) , [[patterns]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String zipFile , final String destDir , final String ... [[convention]] ) throws IOException { unzip ( new File ( zipFile ) , new File ( destDir ) , [[convention]] ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 952 ---------------------------------------------
Converts a byte array to a long array.@param ba byte array@param offset offset into byte array@param size size of array@return long array --> [[[FAILED]]]

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] [[ba]] , final int [[offset]] , final int size ) { long [ ] [[result]] = new long [ size >> 3 ] ; int i8 = [[offset]] ; for ( int i = 0 ; i < [[result]] . length ; i ++ ) { [[result]] [ i ] = Bits . getLong ( [[ba]] , i8 ) ; i8 += 8 ; } return [[result]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] bytesToLongs ( final byte [ ] [[BA]] , final int [[kickoff]] , final int size ) { long [ ] [[consequence]] = new long [ size >> 3 ] ; int i8 = [[kickoff]] ; for ( int i = 0 ; i < [[consequence]] . length ; i ++ ) { [[consequence]] [ i ] = Bits . getLong ( [[BA]] , i8 ) ; i8 += 8 ; } return [[consequence]] ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 953 ---------------------------------------------
Get the value of the specified property.@param name the property name@param defaultValue the default value@return the property value or the default value if the property is not set --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[get]] ( final String [[name]] , final String defaultValue ) { Objects . requireNonNull ( [[name]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[name]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String [[nonplus]] ( final String [[epithet]] , final String defaultValue ) { Objects . requireNonNull ( [[epithet]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[epithet]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[epithet]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return defaultValue ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 954 ---------------------------------------------
Adds the specified file to the specified ZIP output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[file]] , String [[path]] , final String [[comment]] , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( [[path]] == null ) { [[path]] = [[file]] . getName ( ) ; } while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final File [[lodge]] , String [[track]] , final String [[notice]] , final boolean recursive ) throws IOException { if ( ! [[lodge]] . exists ( ) ) { throw new FileNotFoundException ( [[lodge]] . toString ( ) ) ; } if ( [[track]] == null ) { [[track]] = [[lodge]] . getName ( ) ; } while ( [[track]] . length ( ) != 0 && [[track]] . charAt ( 0 ) == ' ' ) { [[track]] = [[track]] . substring ( 1 ) ; } boolean isDir = [[lodge]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 955 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 920 / 19 / 955:  96%|█████████▌| 955/1000 [33:50<01:35,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 920 / 19 / 955:  96%|█████████▌| 956/1000 [33:50<01:33,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 921 / 19 / 956:  96%|█████████▌| 956/1000 [33:50<01:33,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 921 / 19 / 956:  96%|█████████▌| 957/1000 [33:52<01:31,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 922 / 19 / 957:  96%|█████████▌| 957/1000 [33:52<01:31,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 922 / 19 / 957:  96%|█████████▌| 958/1000 [33:54<01:29,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 923 / 19 / 958:  96%|█████████▌| 958/1000 [33:54<01:29,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 923 / 19 / 958:  96%|█████████▌| 959/1000 [33:55<01:27,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 924 / 19 / 959:  96%|█████████▌| 959/1000 [33:55<01:27,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 924 / 19 / 959:  96%|█████████▌| 960/1000 [34:00<01:25,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 925 / 19 / 960:  96%|█████████▌| 960/1000 [34:00<01:25,  2.13s/it][Succeeded / Failed / Skipped / Total] 16 / 925 / 19 / 960:  96%|█████████▌| 961/1000 [34:02<01:22,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 926 / 19 / 961:  96%|█████████▌| 961/1000 [34:02<01:22,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 926 / 19 / 961:  96%|█████████▌| 962/1000 [34:02<01:20,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 927 / 19 / 962:  96%|█████████▌| 962/1000 [34:02<01:20,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 927 / 19 / 962:  96%|█████████▋| 963/1000 [34:02<01:18,  2.12s/it]Sets the request bundle name.@param request the servlet request@param bundleName the bundle name --> [[[FAILED]]]

[[[[Adv]]]]: public static void setRequestBundleName ( final ServletRequest [[request]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void setRequestBundleName ( final ServletRequest [[petition]] , final String bundleName ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + bundleName ) ; } [[petition]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , bundleName ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 956 ---------------------------------------------
Sets the session locale.@param session the session@param localeCode the locale code --> [[[FAILED]]]

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession session , final String localeCode ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + localeCode ) ; } Locale locale = Locale . forLanguageTag ( localeCode ) ; session . setAttribute ( SESSION_LOCALE_ATTR , locale ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 957 ---------------------------------------------
Gets the session locale. --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale getSessionLocale ( final HttpSession session ) { Locale locale = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return locale == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : locale ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 958 ---------------------------------------------
Adds the specified profiles to this Props object. --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String [[profile]] : profiles ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[visibility]] ( final String ... profiles ) { if ( profiles == null ) { return this ; } for ( String [[visibility]] : profiles ) { addProfiles ( [[visibility]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 959 ---------------------------------------------
Returns a list of entries in the specified ZIP file. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > [[entries]] = new ArrayList <> ( ) ; ZipFile [[zip]] = new ZipFile ( zipFile ) ; Enumeration zipEntries = [[zip]] . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[entry]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = [[entry]] . getName ( ) ; [[entries]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[entries]] ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File zipFile ) throws IOException { List < String > [[unveiling]] = new ArrayList <> ( ) ; ZipFile [[nada]] = new ZipFile ( zipFile ) ; Enumeration zipEntries = [[nada]] . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry [[introduction]] = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = [[introduction]] . getName ( ) ; [[unveiling]] . add ( entryName ) ; } return Collections . unmodifiableList ( [[unveiling]] ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 960 ---------------------------------------------
Reads a label from the specified bytecode offset. --> [[[FAILED]]]

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label readLabel ( final int bytecodeOffset , final Label [ ] labels ) { if ( labels [ bytecodeOffset ] == null ) { labels [ bytecodeOffset ] = new Label ( ) ; } return labels [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 961 ---------------------------------------------
Gets the bytecode offset for the given type annotation.@param typeAnnotationOffsets the type annotation offsets@param typeAnnotationIndex the type annotation index@return the bytecode offset --> [[[FAILED]]]

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int getTypeAnnotationBytecodeOffset ( final int [ ] typeAnnotationOffsets , final int typeAnnotationIndex ) { if ( typeAnnotationOffsets == null || typeAnnotationIndex >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ typeAnnotationIndex ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ typeAnnotationIndex ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 962 ---------------------------------------------
Returns the FieldDescriptor for the named field.@param name the name of the field@param declared {@code true} if the field is declared, {@code false} otherwise@return the FieldDescriptor for the named field --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[declared]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String [[call]] , final boolean [[declare]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( [[call]] ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[declare]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 963 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 928 / 19 / 963:  96%|█████████▋| 963/1000 [34:02<01:18,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 928 / 19 / 963:  96%|█████████▋| 964/1000 [34:03<01:16,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 929 / 19 / 964:  96%|█████████▋| 964/1000 [34:03<01:16,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 929 / 19 / 964:  96%|█████████▋| 965/1000 [34:08<01:14,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 930 / 19 / 965:  96%|█████████▋| 965/1000 [34:08<01:14,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 930 / 19 / 965:  97%|█████████▋| 966/1000 [34:08<01:12,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 931 / 19 / 966:  97%|█████████▋| 966/1000 [34:08<01:12,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 931 / 19 / 966:  97%|█████████▋| 967/1000 [34:09<01:09,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 932 / 19 / 967:  97%|█████████▋| 967/1000 [34:09<01:09,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 932 / 19 / 967:  97%|█████████▋| 968/1000 [34:10<01:07,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 933 / 19 / 968:  97%|█████████▋| 968/1000 [34:10<01:07,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 933 / 19 / 968:  97%|█████████▋| 969/1000 [34:11<01:05,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 934 / 19 / 969:  97%|█████████▋| 969/1000 [34:11<01:05,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 934 / 19 / 969:  97%|█████████▋| 970/1000 [34:13<01:03,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 935 / 19 / 970:  97%|█████████▋| 970/1000 [34:13<01:03,  2.12s/it][Succeeded / Failed / Skipped / Total] 16 / 935 / 19 / 970:  97%|█████████▋| 971/1000 [34:13<01:01,  2.11s/it]Returns the property descriptor associated with the supplied name.@param name the name of the property@param declared true if the property descriptor should be declared@return the property descriptor associated with the supplied name --> [[[FAILED]]]

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean [[declared]] ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( [[declared]] ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor getPropertyDescriptor ( final String name , final boolean [[adjudge]] ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( [[adjudge]] ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 964 ---------------------------------------------
Adds content to a ZIP file.@param zos ZIP output stream.@param content content to be added.@param path path to the file.@param comment comment to be added.@throws IOException if an I/O error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream [[is]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[is]] , zos ) ; } finally { StreamUtil . close ( [[is]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { zipEntry . setComment ( comment ) ; } zos . putNextEntry ( zipEntry ) ; InputStream [[comprise]] = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( [[comprise]] , zos ) ; } finally { StreamUtil . close ( [[comprise]] ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 965 ---------------------------------------------
Returns a little-endian 64-bit integer from the specified byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static long getLongLittleEndian ( final byte [ ] buf , final int [[offset]] ) { return ( ( long ) buf [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long getLongLittleEndian ( final byte [ ] buf , final int [[showtime]] ) { return ( ( long ) buf [ [[showtime]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 966 ---------------------------------------------
Reads the bootstrap methods attribute. --> [[[FAILED]]]

[[[[Adv]]]]: private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] readBootstrapMethodsAttribute ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( currentAttributeOffset - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 967 ---------------------------------------------
Gets the request map.@param servletRequest the servlet request@return the request map --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > getRequestMap ( final HttpServletRequest servletRequest ) { return ( Map < String , TransientBeanData > ) servletRequest . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 968 ---------------------------------------------
Returns the ctor descriptor for the given arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] arg = ctorDescriptor . getParameters ( ) ; if ( arg . length != args . length ) { continue ; } for ( int j = 0 ; j < arg . length ; j ++ ) { if ( arg [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 969 ---------------------------------------------
Creates a request map. --> [[[FAILED]]]

[[[[Adv]]]]: protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > createRequestMap ( final HttpServletRequest servletRequest ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; servletRequest . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 970 ---------------------------------------------
Initializes this filter with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void init ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void init ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 971 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 936 / 19 / 971:  97%|█████████▋| 971/1000 [34:13<01:01,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 936 / 19 / 971:  97%|█████████▋| 972/1000 [34:14<00:59,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 937 / 19 / 972:  97%|█████████▋| 972/1000 [34:14<00:59,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 937 / 19 / 972:  97%|█████████▋| 973/1000 [34:16<00:57,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 938 / 19 / 973:  97%|█████████▋| 973/1000 [34:16<00:57,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 938 / 19 / 973:  97%|█████████▋| 974/1000 [34:17<00:54,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 939 / 19 / 974:  97%|█████████▋| 974/1000 [34:17<00:54,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 939 / 19 / 974:  98%|█████████▊| 975/1000 [34:20<00:52,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 940 / 19 / 975:  98%|█████████▊| 975/1000 [34:20<00:52,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 940 / 19 / 975:  98%|█████████▊| 976/1000 [34:23<00:50,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 941 / 19 / 976:  98%|█████████▊| 976/1000 [34:23<00:50,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 941 / 19 / 976:  98%|█████████▊| 977/1000 [34:26<00:48,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 942 / 19 / 977:  98%|█████████▊| 977/1000 [34:26<00:48,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 942 / 19 / 977:  98%|█████████▊| 978/1000 [34:27<00:46,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 943 / 19 / 978:  98%|█████████▊| 978/1000 [34:27<00:46,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 943 / 19 / 978:  98%|█████████▊| 979/1000 [34:28<00:44,  2.11s/it]Analyzes all constructors in the class descriptor. --> [[[FAILED]]]

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int [[i]] = 0 ; [[i]] < ctors . length ; [[i]] ++ ) { Constructor ctor = ctors [ [[i]] ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ [[i]] ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ ctors . length ] ; for ( int [[iodin]] = 0 ; [[iodin]] < ctors . length ; [[iodin]] ++ ) { Constructor ctor = ctors [ [[iodin]] ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( ctor ) ; allCtors [ [[iodin]] ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 972 ---------------------------------------------
Adds a consumer to be called when a file is found. --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile onFile ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 973 ---------------------------------------------
Searches for a file in the specified path. --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile searchPath ( final URI searchPath ) { File file ; try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile searchPath ( final URI searchPath ) { File file ; try { file = new File ( searchPath ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + searchPath , ex ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 974 ---------------------------------------------
Searches for a file in this directory and adds it to this directory. --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile searchPath ( final URL searchPath ) { File file = FileUtil . toContainerFile ( searchPath ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + searchPath ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile searchPath ( final URL searchPath ) { File file = FileUtil . toContainerFile ( searchPath ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + searchPath ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 975 ---------------------------------------------
Reads the element values from the annotation.@param annotationVisitor the annotation visitor@param annotationOffset the annotation offset@param named the named attribute@param charBuffer the char buffer --> [[[FAILED]]]

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean [[named]] , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int readElementValues ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean [[distinguish]] , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 976 ---------------------------------------------
Adds a path to this file system. --> [[[FAILED]]]

[[[[Adv]]]]: protected void addPath ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void addPath ( final File [[track]] ) { if ( ! [[track]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[track]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 977 ---------------------------------------------
Finds all files in the file system. --> [[[FAILED]]]

[[[[Adv]]]]: public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > findAll ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 978 ---------------------------------------------
Converts an object to an array.@param value the object to convert.@return the array. --> [[[FAILED]]]

[[[[Adv]]]]: protected long [ ] convertArrayToArray ( final Object [[value]] ) { final Class valueComponentType = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( [[value]] , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] convertArrayToArray ( final Object [[appraise]] ) { final Class valueComponentType = [[appraise]] . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( valueComponentType . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( [[appraise]] , valueComponentType ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 979 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 944 / 19 / 979:  98%|█████████▊| 979/1000 [34:28<00:44,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 944 / 19 / 979:  98%|█████████▊| 980/1000 [34:29<00:42,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 945 / 19 / 980:  98%|█████████▊| 980/1000 [34:29<00:42,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 945 / 19 / 980:  98%|█████████▊| 981/1000 [34:31<00:40,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 946 / 19 / 981:  98%|█████████▊| 981/1000 [34:31<00:40,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 946 / 19 / 981:  98%|█████████▊| 982/1000 [34:31<00:37,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 947 / 19 / 982:  98%|█████████▊| 982/1000 [34:31<00:37,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 947 / 19 / 982:  98%|█████████▊| 983/1000 [34:31<00:35,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 948 / 19 / 983:  98%|█████████▊| 983/1000 [34:31<00:35,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 949 / 19 / 984:  98%|█████████▊| 984/1000 [34:31<00:33,  2.11s/it][Succeeded / Failed / Skipped / Total] 16 / 949 / 19 / 984:  98%|█████████▊| 985/1000 [34:32<00:31,  2.10s/it]Returns an iterator over the files in this directory. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > iterator ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 980 ---------------------------------------------
Initializes the rules. --> [[[FAILED]]]

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int index = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ index ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( index != 0 ) { FilesIterator filesIterator = new FilesIterator ( files ) ; todoFiles . add ( filesIterator ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 981 ---------------------------------------------
Filter parameters for bean name@param beanName@param resolveReferenceParams@return --> [[[FAILED]]]

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[key]] = entry . getKey ( ) ; if ( ! [[key]] . startsWith ( beanName ) ) { continue ; } list . add ( [[key]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[paint]] = entry . getKey ( ) ; if ( ! [[paint]] . startsWith ( beanName ) ) { continue ; } list . add ( [[paint]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 982 ---------------------------------------------
Reads data from an input stream.@param inputStream the input stream to read from@param close true if the stream should be closed@return the data read from the input stream@throws IOException if an I/O error occurs --> [[[FAILED]]]

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean [[close]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( [[close]] ) { inputStream . [[close]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] readStream ( final InputStream inputStream , final boolean [[conclude]] ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( [[conclude]] ) { inputStream . [[conclude]] ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 983 ---------------------------------------------
Returns a buffered output writer. --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter getWriter ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 984 ---------------------------------------------
Resolves the wiring mode for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode resolveBeanWiringMode ( final Class type ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; return petiteBean != null ? petiteBean . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 985 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 950 / 19 / 985:  98%|█████████▊| 985/1000 [34:32<00:31,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 951 / 19 / 986:  99%|█████████▊| 986/1000 [34:33<00:29,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 951 / 19 / 986:  99%|█████████▊| 987/1000 [34:33<00:27,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 952 / 19 / 987:  99%|█████████▊| 987/1000 [34:33<00:27,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 953 / 19 / 988:  99%|█████████▉| 988/1000 [34:34<00:25,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 953 / 19 / 988:  99%|█████████▉| 989/1000 [34:35<00:23,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 954 / 19 / 989:  99%|█████████▉| 989/1000 [34:35<00:23,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 955 / 19 / 990:  99%|█████████▉| 990/1000 [34:35<00:20,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 955 / 19 / 990:  99%|█████████▉| 991/1000 [34:35<00:18,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 956 / 19 / 991:  99%|█████████▉| 991/1000 [34:35<00:18,  2.09s/it]Returns the output stream for this output stream. --> [[[FAILED]]]

[[[[Adv]]]]: public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream getOutputStream ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 986 ---------------------------------------------
Returns a string representation of the method's descriptor. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... argumentTypes ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; for ( Type argumentType : argumentTypes ) { argumentType . appendDescriptor ( stringBuilder ) ; } stringBuilder . append ( ' ' ) ; returnType . appendDescriptor ( stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 987 ---------------------------------------------
Includes the specified patterns.@param patterns the patterns to be included@return this finder --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile [[include]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[admit]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 988 ---------------------------------------------
Append the descriptor.@param stringBuilder the string builder --> [[[FAILED]]]

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder stringBuilder ) { if ( sort == OBJECT ) { stringBuilder . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { stringBuilder . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { stringBuilder . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 989 ---------------------------------------------
Returns the descriptor for the given constructor. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > [[constructor]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[constructor]] . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String getConstructorDescriptor ( final Constructor < ? > [[builder]] ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = [[builder]] . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 990 ---------------------------------------------
Returns a description of the given method. --> [[[FAILED]]]

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 991 ---------------------------------------------
Returns the number of elements in this array. --> [[[FAILED]]]

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int getSize ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 992 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 957 / 19 / 992:  99%|█████████▉| 992/1000 [34:36<00:16,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 957 / 19 / 992:  99%|█████████▉| 993/1000 [34:36<00:14,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 958 / 19 / 993:  99%|█████████▉| 993/1000 [34:36<00:14,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 959 / 19 / 994:  99%|█████████▉| 994/1000 [34:37<00:12,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 959 / 19 / 994: 100%|█████████▉| 995/1000 [34:38<00:10,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 960 / 19 / 995: 100%|█████████▉| 995/1000 [34:38<00:10,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 961 / 19 / 996: 100%|█████████▉| 996/1000 [34:39<00:08,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 961 / 19 / 996: 100%|█████████▉| 997/1000 [34:48<00:06,  2.09s/it]Gets the class name of this object. --> [[[FAILED]]]

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String getClassName ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder stringBuilder = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { stringBuilder . append ( "[]" ) ; } return stringBuilder . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 993 ---------------------------------------------
Get the number of arguments and return sizes for the given method descriptor. --> [[[FAILED]]]

[[[[Adv]]]]: public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int getArgumentsAndReturnSizes ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 994 ---------------------------------------------
Sets the rollback only flag. --> [[[FAILED]]]

[[[[Adv]]]]: public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void setRollbackOnly ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 995 ---------------------------------------------
Excludes all files that match the given patterns. --> [[[FAILED]]]

[[[[Adv]]]]: public FindFile exclude ( final String ... [[patterns]] ) { for ( String [[pattern]] : [[patterns]] ) { rules . exclude ( [[pattern]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... [[model]] ) { for ( String [[design]] : [[model]] ) { rules . exclude ( [[design]] ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 996 ---------------------------------------------
Rollback all resources. --> [[[FAILED]]]

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void rollbackAllResources ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception lastException = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { lastException = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( lastException != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , lastException ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 997 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 962 / 19 / 997: 100%|█████████▉| 997/1000 [34:48<00:06,  2.09s/it][Succeeded / Failed / Skipped / Total] 16 / 963 / 19 / 998: 100%|█████████▉| 998/1000 [34:53<00:04,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 963 / 19 / 998: 100%|█████████▉| 999/1000 [34:59<00:02,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 964 / 19 / 999: 100%|█████████▉| 999/1000 [34:59<00:02,  2.10s/it][Succeeded / Failed / Skipped / Total] 16 / 964 / 19 / 999: 100%|██████████| 1000/1000 [35:29<00:00,  2.13s/it]Request a resource. --> [[[FAILED]]]

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < E > E requestResource ( final Class < E > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; E resource = lookupResource ( resourceType ) ; if ( resource == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < E > resourceManager = txManager . lookupResourceManager ( resourceType ) ; resource = resourceManager . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , resourceManager , resource ) ) ; } return resource ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .
--------------------------------------------- Result 998 ---------------------------------------------
Resolve bean name.@param type the type@param useLongTypeName the use long type name@return the bean name --> [[[FAILED]]]

[[[[Adv]]]]: public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String [[name]] = null ; if ( petiteBean != null ) { [[name]] = petiteBean . value ( ) . trim ( ) ; } if ( ( [[name]] == null ) || ( [[name]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[name]] = type . getName ( ) ; } else { [[name]] = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return [[name]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String resolveBeanName ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String [[call]] = null ; if ( petiteBean != null ) { [[call]] = petiteBean . value ( ) . trim ( ) ; } if ( ( [[call]] == null ) || ( [[call]] . length ( ) == 0 ) ) { if ( useLongTypeName ) { [[call]] = type . getName ( ) ; } else { [[call]] = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return [[call]] ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 999 ---------------------------------------------
Commits or rolls back the transaction. --> [[[FAILED]]]

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void commitOrRollback ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "False" != "False" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "False" != "False" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 1000 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 965 / 19 / 1000: 100%|██████████| 1000/1000 [35:29<00:00,  2.13s/it]Attack(
  (search_method): GreedyWordSwapWIR(
    (wir_method):  lsh_with_attention
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapWordNet
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
/data2/cg/CodeAttack/models/codegpt_models.py:966: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/home/cg/.pyenv/versions/3.8-dev/lib/python3.8/site-packages/torch/nn/modules/rnn.py:62: UserWarning: dropout option adds dropout after all but last recurrent layer, so non-zero dropout expects num_layers greater than 1, but got dropout=0.3 and num_layers=1
  warnings.warn("dropout option adds dropout after all but last "
[Succeeded / Failed / Skipped / Total] 16 / 965 / 19 / 1000: 100%|██████████| 1000/1000 [35:34<00:00,  2.13s/it]Reads the verification type information from the specified frame. --> [[[FAILED]]]

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] [[frame]] , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : [[frame]] [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : [[frame]] [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : [[frame]] [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : [[frame]] [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : [[frame]] [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : [[frame]] [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : [[frame]] [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : [[frame]] [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : [[frame]] [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] [[shape]] , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int tag = b [ currentOffset ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : [[shape]] [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : [[shape]] [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : [[shape]] [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : [[shape]] [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : [[shape]] [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : [[shape]] [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : [[shape]] [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : [[shape]] [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : [[shape]] [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 16     |
| Number of failed attacks:     | 965    |
| Number of skipped attacks:    | 19     |
| Original accuracy:            | 98.1%  |
| Accuracy under attack:        | 96.5%  |
| Attack success rate:          | 1.63%  |
| Average perturbed word %:     | 39.55% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 23.11  |
| Original BLEU-4:              | 14.44  |
| Perturbed BLEU-4:             | 10.25  |
+-------------------------------+--------+

