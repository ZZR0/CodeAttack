Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
Some weights of the model checkpoint at bert-base-uncased were not used when initializing BertForMaskedLM: ['cls.seq_relationship.bias', 'cls.seq_relationship.weight']
- This IS expected if you are initializing BertForMaskedLM from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing BertForMaskedLM from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 675.52it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 2/1000 [00:19<2:44:43,  9.90s/it][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 2/1000 [00:19<2:44:44,  9.90s/it][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 3/1000 [00:39<3:39:58, 13.24s/it][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 3/1000 [00:39<3:39:58, 13.24s/it][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 4/1000 [01:07<4:40:10, 16.88s/it][Succeeded / Failed / Skipped / Total] 0 / 4 / 0 / 4:   0%|          | 4/1000 [01:07<4:40:10, 16.88s/it][Succeeded / Failed / Skipped / Total] 0 / 4 / 0 / 4:   0%|          | 5/1000 [01:42<5:40:41, 20.54s/it][Succeeded / Failed / Skipped / Total] 0 / 5 / 0 / 5:   0%|          | 5/1000 [01:42<5:40:42, 20.54s/it][Succeeded / Failed / Skipped / Total] 0 / 5 / 0 / 5:   1%|          | 6/1000 [01:48<4:58:38, 18.03s/it][Succeeded / Failed / Skipped / Total] 0 / 6 / 0 / 6:   1%|          | 6/1000 [01:48<4:58:38, 18.03s/it][Succeeded / Failed / Skipped / Total] 0 / 6 / 0 / 6:   1%|          | 7/1000 [02:00<4:44:38, 17.20s/it]--------------------------------------------- Result 1 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[on]] ( ObservableSource < T > [[request]] ) { ObjectHelper . requireNonNull ( [[request]] , "source is null" ) ; if ( [[request]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[request]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[request]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[after]] ( int [[be]] ) { return new UnicastProcessor < T > ( [[be]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 3 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[entity]] ( Comparator < ? super T > [[status]] ) { ObjectHelper . requireNonNull ( [[status]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[status]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 4 ---------------------------------------------
Resets this scheduler. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[execute]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 5 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[hello]] ( CompletableSource [[fail]] ) { ObjectHelper . requireNonNull ( [[fail]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[fail]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 6 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > [[co]] , final Scheduler [[scheduler]] ) { final Observable < T > observable = [[co]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[co]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[method]] ( final ConnectableObservable < T > [[base]] , final Scheduler [[base]] ) { final Observable < T > observable = [[base]] . observeOn ( [[base]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( [[base]] , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 7 / 0 / 7:   1%|          | 7/1000 [02:00<4:44:38, 17.20s/it][Succeeded / Failed / Skipped / Total] 0 / 7 / 0 / 7:   1%|          | 8/1000 [02:10<4:28:43, 16.25s/it][Succeeded / Failed / Skipped / Total] 0 / 8 / 0 / 8:   1%|          | 8/1000 [02:10<4:28:43, 16.25s/it][Succeeded / Failed / Skipped / Total] 0 / 8 / 0 / 8:   1%|          | 9/1000 [02:17<4:12:36, 15.29s/it][Succeeded / Failed / Skipped / Total] 0 / 9 / 0 / 9:   1%|          | 9/1000 [02:17<4:12:36, 15.29s/it][Succeeded / Failed / Skipped / Total] 0 / 9 / 0 / 9:   1%|          | 10/1000 [02:29<4:06:13, 14.92s/it][Succeeded / Failed / Skipped / Total] 0 / 10 / 0 / 10:   1%|          | 10/1000 [02:29<4:06:13, 14.92s/it][Succeeded / Failed / Skipped / Total] 0 / 10 / 0 / 10:   1%|          | 11/1000 [03:01<4:31:48, 16.49s/it][Succeeded / Failed / Skipped / Total] 0 / 11 / 0 / 11:   1%|          | 11/1000 [03:01<4:31:49, 16.49s/it][Succeeded / Failed / Skipped / Total] 0 / 11 / 0 / 11:   1%|          | 12/1000 [03:06<4:15:45, 15.53s/it][Succeeded / Failed / Skipped / Total] 0 / 12 / 0 / 12:   1%|          | 12/1000 [03:06<4:15:45, 15.53s/it][Succeeded / Failed / Skipped / Total] 0 / 12 / 0 / 12:   1%|▏         | 13/1000 [03:13<4:04:13, 14.85s/it][Succeeded / Failed / Skipped / Total] 0 / 13 / 0 / 13:   1%|▏         | 13/1000 [03:13<4:04:13, 14.85s/it][Succeeded / Failed / Skipped / Total] 0 / 13 / 0 / 13:   1%|▏         | 14/1000 [03:57<4:38:55, 16.97s/it][Succeeded / Failed / Skipped / Total] 0 / 14 / 0 / 14:   1%|▏         | 14/1000 [03:57<4:38:55, 16.97s/it][Succeeded / Failed / Skipped / Total] 0 / 14 / 0 / 14:   2%|▏         | 15/1000 [03:58<4:21:22, 15.92s/it][Succeeded / Failed / Skipped / Total] 0 / 15 / 0 / 15:   2%|▏         | 15/1000 [03:58<4:21:22, 15.92s/it][Succeeded / Failed / Skipped / Total] 0 / 15 / 0 / 15:   2%|▏         | 16/1000 [04:05<4:12:08, 15.37s/it][Succeeded / Failed / Skipped / Total] 0 / 16 / 0 / 16:   2%|▏         | 16/1000 [04:05<4:12:08, 15.37s/it][Succeeded / Failed / Skipped / Total] 0 / 16 / 0 / 16:   2%|▏         | 17/1000 [04:22<4:12:34, 15.42s/it]Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[after]] ( int [[load]] , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( [[load]] , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 8 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[tag]] ( final T [[language]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[t]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[language]] , [[t]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 9 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[hello]] ( SingleSource < T > [[partial]] ) { ObjectHelper . requireNonNull ( [[partial]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[partial]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[export]] > [[export]] requireNonNull ( [[export]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 11 ---------------------------------------------
Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T value ) { return new JustValue < Object , T > ( value ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[system]] ( T value ) { return new JustValue < Object , T > ( value ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 12 ---------------------------------------------
Returns an identity function. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[identity]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T > Function < T , T > [[operation]] ( ) { return ( Function < T , T > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 13 ---------------------------------------------
Retries the specified number of times. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[definition]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[definition]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 14 ---------------------------------------------
Creates a cast function from the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < T , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[where]] ( Class < U > [[null]] ) { return new CastToClass < T , U > ( [[null]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 15 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > [[justFunction]] ( U [[value]] ) { return new JustValue < T , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[set]] ( U [[boundary]] ) { return new JustValue < T , U > ( [[boundary]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a new non-blocking producer. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[fix]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[jump]]" == "[[jump]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 17 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 17 / 0 / 17:   2%|▏         | 17/1000 [04:22<4:12:34, 15.42s/it][Succeeded / Failed / Skipped / Total] 0 / 17 / 0 / 17:   2%|▏         | 18/1000 [04:22<3:58:51, 14.59s/it][Succeeded / Failed / Skipped / Total] 0 / 18 / 0 / 18:   2%|▏         | 18/1000 [04:22<3:58:51, 14.59s/it][Succeeded / Failed / Skipped / Total] 0 / 18 / 0 / 18:   2%|▏         | 19/1000 [05:32<4:46:13, 17.51s/it][Succeeded / Failed / Skipped / Total] 0 / 19 / 0 / 19:   2%|▏         | 19/1000 [05:32<4:46:13, 17.51s/it][Succeeded / Failed / Skipped / Total] 0 / 19 / 0 / 19:   2%|▏         | 20/1000 [05:40<4:38:27, 17.05s/it][Succeeded / Failed / Skipped / Total] 0 / 20 / 0 / 20:   2%|▏         | 20/1000 [05:40<4:38:27, 17.05s/it][Succeeded / Failed / Skipped / Total] 0 / 20 / 0 / 20:   2%|▏         | 21/1000 [06:08<4:45:57, 17.53s/it][Succeeded / Failed / Skipped / Total] 0 / 21 / 0 / 21:   2%|▏         | 21/1000 [06:08<4:45:58, 17.53s/it][Succeeded / Failed / Skipped / Total] 0 / 21 / 0 / 21:   2%|▏         | 22/1000 [06:38<4:55:14, 18.11s/it][Succeeded / Failed / Skipped / Total] 0 / 22 / 0 / 22:   2%|▏         | 22/1000 [06:38<4:55:14, 18.11s/it][Succeeded / Failed / Skipped / Total] 0 / 22 / 0 / 22:   2%|▏         | 23/1000 [06:43<4:45:52, 17.56s/it][Succeeded / Failed / Skipped / Total] 0 / 23 / 0 / 23:   2%|▏         | 23/1000 [06:43<4:45:52, 17.56s/it][Succeeded / Failed / Skipped / Total] 0 / 23 / 0 / 23:   2%|▏         | 24/1000 [07:05<4:48:12, 17.72s/it][Succeeded / Failed / Skipped / Total] 0 / 24 / 0 / 24:   2%|▏         | 24/1000 [07:05<4:48:13, 17.72s/it][Succeeded / Failed / Skipped / Total] 0 / 24 / 0 / 24:   2%|▎         | 25/1000 [07:16<4:43:38, 17.45s/it]Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[attack]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new subject with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[min]] ( int [[t]] ) { return new UnicastSubject < T > ( [[t]] , "[[no]]" == "[[no]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 19 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable blockingGetError ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( timeout , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[print]] ( boolean delayError ) { return new UnicastSubject < T > ( bufferSize ( ) , delayError ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 21 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U [[value]] , boolean [[delayError]] , Disposable [[disposable]] ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[value]] ) ; } } else { q . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[delayError]] , [[disposable]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[await]] ( U [[ga]] , boolean [[utility]] , Disposable [[resource]] ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , [[ga]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( [[ga]] ) ; } } else { q . offer ( [[ga]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , [[utility]] , [[resource]] , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 22 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[request]] ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[accept]] ( Subscription [[extension]] , int [[id]] ) { [[extension]] . request ( [[id]] < 0 ? Long . MAX_VALUE : [[id]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 23 ---------------------------------------------
Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[print]] ( int [[base]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[base]] , onTerminate , "[[base]]" == "[[base]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 24 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void complete ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 25 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 25 / 0 / 25:   2%|▎         | 25/1000 [07:16<4:43:38, 17.45s/it][Succeeded / Failed / Skipped / Total] 0 / 25 / 0 / 25:   3%|▎         | 26/1000 [07:21<4:35:41, 16.98s/it][Succeeded / Failed / Skipped / Total] 0 / 26 / 0 / 26:   3%|▎         | 26/1000 [07:21<4:35:41, 16.98s/it][Succeeded / Failed / Skipped / Total] 0 / 26 / 0 / 26:   3%|▎         | 27/1000 [08:09<4:53:54, 18.12s/it][Succeeded / Failed / Skipped / Total] 0 / 27 / 0 / 27:   3%|▎         | 27/1000 [08:09<4:53:54, 18.12s/it][Succeeded / Failed / Skipped / Total] 0 / 27 / 0 / 27:   3%|▎         | 28/1000 [08:24<4:51:36, 18.00s/it][Succeeded / Failed / Skipped / Total] 0 / 28 / 0 / 28:   3%|▎         | 28/1000 [08:24<4:51:36, 18.00s/it][Succeeded / Failed / Skipped / Total] 0 / 28 / 0 / 28:   3%|▎         | 29/1000 [09:31<5:18:51, 19.70s/it][Succeeded / Failed / Skipped / Total] 0 / 29 / 0 / 29:   3%|▎         | 29/1000 [09:31<5:18:51, 19.70s/it][Succeeded / Failed / Skipped / Total] 0 / 29 / 0 / 29:   3%|▎         | 30/1000 [10:45<5:47:57, 21.52s/it][Succeeded / Failed / Skipped / Total] 1 / 29 / 0 / 30:   3%|▎         | 30/1000 [10:45<5:47:57, 21.52s/it][Succeeded / Failed / Skipped / Total] 1 / 29 / 0 / 30:   3%|▎         | 31/1000 [10:46<5:36:38, 20.84s/it]Returns the value associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[z]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 26 ---------------------------------------------
Gets the error associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[alarm]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > [[source]] , Subscriber < ? super R > [[subscriber]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } [[subscriber]] . onSubscribe ( new ScalarSubscription < R > ( [[subscriber]] , u ) ) ; } else { r . subscribe ( [[subscriber]] ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[call]] ( Publisher < T > [[line]] , Subscriber < ? super R > [[l]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( [[line]] instanceof Callable ) { T [[b]] ; try { [[b]] = ( ( Callable < T > ) [[line]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[l]] ) ; return "[[null]]" == "[[null]]" ; } if ( [[b]] == null ) { EmptySubscription . complete ( [[l]] ) ; return "[[null]]" == "[[null]]" ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[b]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[l]] ) ; return "[[null]]" == "[[null]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[l]] ) ; return "[[null]]" == "[[null]]" ; } if ( u == null ) { EmptySubscription . complete ( [[l]] ) ; return "[[null]]" == "[[null]]" ; } [[l]] . onSubscribe ( new ScalarSubscription < R > ( [[l]] , u ) ) ; } else { r . subscribe ( [[l]] ) ; } return "[[null]]" == "[[null]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 28 ---------------------------------------------
Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[run]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 29 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[suppose]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , isCancelled ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 30 ---------------------------------------------
Multiply a long by another. --> Multiply b1 by b2 --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long [[b]] ) { long u = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( u / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[b1]] , long [[β]] ) { long u = [[b1]] * [[β]] ; if ( ( ( [[b1]] | [[β]] ) >>> 31 ) != 0 ) { if ( u / [[b1]] != [[β]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 30 / 0 / 31:   3%|▎         | 31/1000 [10:46<5:36:38, 20.84s/it][Succeeded / Failed / Skipped / Total] 1 / 30 / 0 / 31:   3%|▎         | 32/1000 [11:46<5:56:05, 22.07s/it][Succeeded / Failed / Skipped / Total] 1 / 31 / 0 / 32:   3%|▎         | 32/1000 [11:46<5:56:05, 22.07s/it][Succeeded / Failed / Skipped / Total] 1 / 31 / 0 / 32:   3%|▎         | 33/1000 [12:15<5:59:18, 22.29s/it][Succeeded / Failed / Skipped / Total] 1 / 32 / 0 / 33:   3%|▎         | 33/1000 [12:15<5:59:18, 22.29s/it][Succeeded / Failed / Skipped / Total] 1 / 32 / 0 / 33:   3%|▎         | 34/1000 [12:45<6:02:20, 22.51s/it][Succeeded / Failed / Skipped / Total] 1 / 33 / 0 / 34:   3%|▎         | 34/1000 [12:45<6:02:20, 22.51s/it][Succeeded / Failed / Skipped / Total] 1 / 33 / 0 / 34:   4%|▎         | 35/1000 [12:48<5:53:04, 21.95s/it][Succeeded / Failed / Skipped / Total] 1 / 34 / 0 / 35:   4%|▎         | 35/1000 [12:48<5:53:04, 21.95s/it][Succeeded / Failed / Skipped / Total] 1 / 34 / 0 / 35:   4%|▎         | 36/1000 [12:48<5:42:58, 21.35s/it][Succeeded / Failed / Skipped / Total] 1 / 35 / 0 / 36:   4%|▎         | 36/1000 [12:48<5:42:58, 21.35s/it][Succeeded / Failed / Skipped / Total] 1 / 35 / 0 / 36:   4%|▎         | 37/1000 [13:18<5:46:15, 21.57s/it][Succeeded / Failed / Skipped / Total] 1 / 36 / 0 / 37:   4%|▎         | 37/1000 [13:18<5:46:15, 21.57s/it][Succeeded / Failed / Skipped / Total] 1 / 36 / 0 / 37:   4%|▍         | 38/1000 [13:24<5:39:14, 21.16s/it][Succeeded / Failed / Skipped / Total] 1 / 37 / 0 / 38:   4%|▍         | 38/1000 [13:24<5:39:14, 21.16s/it][Succeeded / Failed / Skipped / Total] 1 / 37 / 0 / 38:   4%|▍         | 39/1000 [13:46<5:39:14, 21.18s/it]Adds the specified element to the end of the array. --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[addCap]] ( long [[a]] , long [[b]] ) { long u = [[a]] + [[b]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[when]] ( long [[mu]] , long [[i]] ) { long u = [[mu]] + [[i]] ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 32 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[test]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 33 ---------------------------------------------
Adds an object to the list. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[en]] ( Object [[array]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 34 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[again]] , Disposable [[after]] , Class < ? > [[above]] ) { ObjectHelper . requireNonNull ( [[after]] , "next is null" ) ; if ( ! [[again]] . compareAndSet ( null , [[after]] ) ) { [[after]] . dispose ( ) ; if ( [[again]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[above]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 35 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long n ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[flip]] ( AtomicLong [[b]] , long n ) { for ( ; ; ) { long r = [[b]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( [[b]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 36 ---------------------------------------------
Shuts down the pool. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[chase]] ( ) { ScheduledExecutorService [[c]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[c]] != null ) { [[c]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 37 ---------------------------------------------
Emits a loop. --> [[[FAILED]]]

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void emitLoop ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 38 ---------------------------------------------
Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription [[upstream]] , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[request]] ( Subscription [[event]] , Subscription [[header]] , Class < ? > [[stack]] ) { ObjectHelper . requireNonNull ( [[header]] , "next is null" ) ; if ( [[event]] != null ) { [[header]] . cancel ( ) ; if ( [[event]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[stack]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 39 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 38 / 0 / 39:   4%|▍         | 39/1000 [13:46<5:39:14, 21.18s/it][Succeeded / Failed / Skipped / Total] 1 / 38 / 0 / 39:   4%|▍         | 40/1000 [13:50<5:32:20, 20.77s/it][Succeeded / Failed / Skipped / Total] 1 / 39 / 0 / 40:   4%|▍         | 40/1000 [13:50<5:32:20, 20.77s/it][Succeeded / Failed / Skipped / Total] 1 / 39 / 0 / 40:   4%|▍         | 41/1000 [13:53<5:24:44, 20.32s/it][Succeeded / Failed / Skipped / Total] 1 / 40 / 0 / 41:   4%|▍         | 41/1000 [13:53<5:24:44, 20.32s/it][Succeeded / Failed / Skipped / Total] 1 / 40 / 0 / 41:   4%|▍         | 42/1000 [14:16<5:25:39, 20.40s/it][Succeeded / Failed / Skipped / Total] 1 / 41 / 0 / 42:   4%|▍         | 42/1000 [14:16<5:25:39, 20.40s/it][Succeeded / Failed / Skipped / Total] 1 / 41 / 0 / 42:   4%|▍         | 43/1000 [14:26<5:21:21, 20.15s/it][Succeeded / Failed / Skipped / Total] 1 / 42 / 0 / 43:   4%|▍         | 43/1000 [14:26<5:21:21, 20.15s/it][Succeeded / Failed / Skipped / Total] 1 / 42 / 0 / 43:   4%|▍         | 44/1000 [14:31<5:15:42, 19.81s/it][Succeeded / Failed / Skipped / Total] 1 / 43 / 0 / 44:   4%|▍         | 44/1000 [14:31<5:15:42, 19.81s/it][Succeeded / Failed / Skipped / Total] 1 / 43 / 0 / 44:   4%|▍         | 45/1000 [14:36<5:09:58, 19.48s/it][Succeeded / Failed / Skipped / Total] 1 / 44 / 0 / 45:   4%|▍         | 45/1000 [14:36<5:09:58, 19.48s/it][Succeeded / Failed / Skipped / Total] 1 / 44 / 0 / 45:   5%|▍         | 46/1000 [14:44<5:05:49, 19.23s/it]Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[build]] ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 40 ---------------------------------------------
Sets the current subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[take]] ( Subscription [[test]] ) { if ( cancelled ) { [[test]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[test]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[test]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[test]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[test]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 41 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 42 ---------------------------------------------
Clears this hash set. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[fix]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > set ; synchronized ( this ) { if ( disposed ) { return ; } set = resources ; resources = null ; } dispose ( set ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 43 ---------------------------------------------
Returns the size of this hash set. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[move]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 44 ---------------------------------------------
Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[execute]] ( Disposable upstream , Disposable [[outgoing]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[outgoing]] , "next is null" ) ; if ( upstream != null ) { [[outgoing]] . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[result]]" == "[[result]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 45 ---------------------------------------------
Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 46 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 45 / 0 / 46:   5%|▍         | 46/1000 [14:44<5:05:49, 19.23s/it][Succeeded / Failed / Skipped / Total] 1 / 45 / 0 / 46:   5%|▍         | 47/1000 [15:00<5:04:26, 19.17s/it][Succeeded / Failed / Skipped / Total] 1 / 46 / 0 / 47:   5%|▍         | 47/1000 [15:00<5:04:26, 19.17s/it][Succeeded / Failed / Skipped / Total] 1 / 46 / 0 / 47:   5%|▍         | 48/1000 [15:16<5:03:06, 19.10s/it][Succeeded / Failed / Skipped / Total] 1 / 47 / 0 / 48:   5%|▍         | 48/1000 [15:16<5:03:06, 19.10s/it][Succeeded / Failed / Skipped / Total] 1 / 47 / 0 / 48:   5%|▍         | 49/1000 [16:40<5:23:28, 20.41s/it][Succeeded / Failed / Skipped / Total] 1 / 48 / 0 / 49:   5%|▍         | 49/1000 [16:40<5:23:28, 20.41s/it][Succeeded / Failed / Skipped / Total] 1 / 48 / 0 / 49:   5%|▌         | 50/1000 [17:33<5:33:42, 21.08s/it][Succeeded / Failed / Skipped / Total] 1 / 49 / 0 / 50:   5%|▌         | 50/1000 [17:33<5:33:42, 21.08s/it][Succeeded / Failed / Skipped / Total] 1 / 49 / 0 / 50:   5%|▌         | 51/1000 [17:37<5:28:00, 20.74s/it][Succeeded / Failed / Skipped / Total] 1 / 50 / 0 / 51:   5%|▌         | 51/1000 [17:37<5:28:00, 20.74s/it][Succeeded / Failed / Skipped / Total] 1 / 50 / 0 / 51:   5%|▌         | 52/1000 [17:37<5:21:27, 20.35s/it][Succeeded / Failed / Skipped / Total] 1 / 51 / 0 / 52:   5%|▌         | 52/1000 [17:37<5:21:27, 20.35s/it][Succeeded / Failed / Skipped / Total] 1 / 51 / 0 / 52:   5%|▌         | 53/1000 [18:01<5:22:02, 20.40s/it]Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription [[operator]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[operator]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[operator]] ) ) { [[operator]] . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 47 ---------------------------------------------
Starts the stream. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[main]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Start unbounded. --> [[[FAILED]]]

[[[[Adv]]]]: public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void startUnbounded ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable [[t]] ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[t]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[offer]] ( Throwable [[output]] ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[output]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 50 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[cleanup]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 51 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[search]] ( T [[p]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[t]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[p]] , [[t]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 52 ---------------------------------------------
Offers the specified element to the specified queue. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[end]] ( T [[ps]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[ps]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[ps]] ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 53 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 52 / 0 / 53:   5%|▌         | 53/1000 [18:01<5:22:02, 20.40s/it][Succeeded / Failed / Skipped / Total] 1 / 52 / 0 / 53:   5%|▌         | 54/1000 [18:07<5:17:39, 20.15s/it][Succeeded / Failed / Skipped / Total] 1 / 53 / 0 / 54:   5%|▌         | 54/1000 [18:07<5:17:39, 20.15s/it][Succeeded / Failed / Skipped / Total] 1 / 53 / 0 / 54:   6%|▌         | 55/1000 [18:24<5:16:11, 20.08s/it][Succeeded / Failed / Skipped / Total] 1 / 54 / 0 / 55:   6%|▌         | 55/1000 [18:24<5:16:11, 20.08s/it][Succeeded / Failed / Skipped / Total] 1 / 54 / 0 / 55:   6%|▌         | 56/1000 [18:29<5:11:49, 19.82s/it][Succeeded / Failed / Skipped / Total] 1 / 55 / 0 / 56:   6%|▌         | 56/1000 [18:29<5:11:49, 19.82s/it][Succeeded / Failed / Skipped / Total] 1 / 55 / 0 / 56:   6%|▌         | 57/1000 [18:36<5:07:57, 19.59s/it][Succeeded / Failed / Skipped / Total] 1 / 56 / 0 / 57:   6%|▌         | 57/1000 [18:36<5:07:57, 19.59s/it][Succeeded / Failed / Skipped / Total] 1 / 56 / 0 / 57:   6%|▌         | 58/1000 [18:56<5:07:42, 19.60s/it][Succeeded / Failed / Skipped / Total] 1 / 57 / 0 / 58:   6%|▌         | 58/1000 [18:56<5:07:42, 19.60s/it][Succeeded / Failed / Skipped / Total] 1 / 57 / 0 / 58:   6%|▌         | 59/1000 [19:08<5:05:10, 19.46s/it]Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[find]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > [[q]] , Subscriber < ? super U > [[a]] , boolean delayError , Disposable [[dispose]] , QueueDrain < T , U > [[qd]] ) { int [[missed]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[qd]] . done ( ) ; T v = [[q]] . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[a]] , delayError , [[q]] , [[qd]] ) ) { if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } return ; } if ( empty ) { break ; } long r = [[qd]] . requested ( ) ; if ( r != 0L ) { if ( [[qd]] . accept ( [[a]] , v ) ) { if ( r != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { [[q]] . clear ( ) ; if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[missed]] = [[qd]] . leave ( - [[missed]] ) ; if ( [[missed]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > [[the]] , Subscriber < ? super U > [[see]] , boolean delayError , Disposable [[search]] , QueueDrain < T , U > [[end]] ) { int [[ne]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[end]] . done ( ) ; T v = [[the]] . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[see]] , delayError , [[the]] , [[end]] ) ) { if ( [[search]] != null ) { [[search]] . [[search]] ( ) ; } return ; } if ( empty ) { break ; } long r = [[end]] . requested ( ) ; if ( r != 0L ) { if ( [[end]] . accept ( [[see]] , v ) ) { if ( r != Long . MAX_VALUE ) { [[end]] . produced ( 1 ) ; } } } else { [[the]] . clear ( ) ; if ( [[search]] != null ) { [[search]] . [[search]] ( ) ; } [[see]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[ne]] = [[end]] . leave ( - [[ne]] ) ; if ( [[ne]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 55 ---------------------------------------------
Accepts a subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ c ] ; } return "[[validity]]" != "[[validity]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 56 ---------------------------------------------
Called when an error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[assume]] ( Throwable [[sequence]] ) { int [[a]] = get ( ) ; if ( ( [[a]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[sequence]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[sequence]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 57 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[observer]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[observer]] ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[x]] ) { Object [ ] [[condition]] = head ; final int c = capacity ; while ( [[condition]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[condition]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[x]] ) ) { return "True" == "True" ; } } [[condition]] = ( Object [ ] ) [[condition]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 58 ---------------------------------------------
Called when the supplied value is complete. --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T [[b]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[b]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[b]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 58 / 0 / 59:   6%|▌         | 59/1000 [19:08<5:05:11, 19.46s/it][Succeeded / Failed / Skipped / Total] 1 / 58 / 0 / 59:   6%|▌         | 60/1000 [19:12<5:00:49, 19.20s/it][Succeeded / Failed / Skipped / Total] 1 / 59 / 0 / 60:   6%|▌         | 60/1000 [19:12<5:00:49, 19.20s/it][Succeeded / Failed / Skipped / Total] 1 / 59 / 0 / 60:   6%|▌         | 61/1000 [19:18<4:57:05, 18.98s/it][Succeeded / Failed / Skipped / Total] 1 / 60 / 0 / 61:   6%|▌         | 61/1000 [19:18<4:57:05, 18.98s/it][Succeeded / Failed / Skipped / Total] 1 / 60 / 0 / 61:   6%|▌         | 62/1000 [19:35<4:56:28, 18.96s/it][Succeeded / Failed / Skipped / Total] 1 / 61 / 0 / 62:   6%|▌         | 62/1000 [19:35<4:56:28, 18.96s/it][Succeeded / Failed / Skipped / Total] 1 / 61 / 0 / 62:   6%|▋         | 63/1000 [19:55<4:56:14, 18.97s/it][Succeeded / Failed / Skipped / Total] 1 / 62 / 0 / 63:   6%|▋         | 63/1000 [19:55<4:56:14, 18.97s/it][Succeeded / Failed / Skipped / Total] 1 / 62 / 0 / 63:   6%|▋         | 64/1000 [20:43<5:03:03, 19.43s/it][Succeeded / Failed / Skipped / Total] 1 / 63 / 0 / 64:   6%|▋         | 64/1000 [20:43<5:03:03, 19.43s/it][Succeeded / Failed / Skipped / Total] 1 / 63 / 0 / 64:   6%|▋         | 65/1000 [20:57<5:01:35, 19.35s/it][Succeeded / Failed / Skipped / Total] 1 / 64 / 0 / 65:   6%|▋         | 65/1000 [20:57<5:01:35, 19.35s/it][Succeeded / Failed / Skipped / Total] 1 / 64 / 0 / 65:   7%|▋         | 66/1000 [21:42<5:07:18, 19.74s/it]Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> [[[FAILED]]]

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[date]] ) { if ( [[date]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 60 ---------------------------------------------
Concatenates an Iterable into a single Flowable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[concatMapIterable]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[buffer]] ( Function < ? super T , ? extends Iterable < ? extends U > > mapper ) { return [[buffer]] ( mapper , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 61 ---------------------------------------------
ConcatMapDelayError. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 62 ---------------------------------------------
Performs an asynchronous request. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription [[s]] = this . upstream ; if ( [[s]] != null ) { [[s]] . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[read]] ( long [[list]] ) { Subscription [[index]] = this . upstream ; if ( [[index]] != null ) { [[index]] . request ( [[list]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 63 ---------------------------------------------
Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[empty]] ( Comparator < ? super T > [[non]] ) { ObjectHelper . requireNonNull ( [[non]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[non]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Creates an error response. --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[check]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 65 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int n = [[a]] . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[a]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , j ) ; System . arraycopy ( [[a]] , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[begin]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[b]] = subscribers . get ( ) ; if ( [[b]] == TERMINATED || [[b]] == EMPTY ) { return ; } int n = [[b]] . length ; int j = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[b]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[b]] , 0 , b , 0 , j ) ; System . arraycopy ( [[b]] , j + 1 , b , j , n - j - 1 ) ; } if ( subscribers . compareAndSet ( [[b]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 66 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 65 / 0 / 66:   7%|▋         | 66/1000 [21:42<5:07:18, 19.74s/it][Succeeded / Failed / Skipped / Total] 1 / 65 / 0 / 66:   7%|▋         | 67/1000 [21:45<5:03:05, 19.49s/it][Succeeded / Failed / Skipped / Total] 1 / 66 / 0 / 67:   7%|▋         | 67/1000 [21:45<5:03:05, 19.49s/it][Succeeded / Failed / Skipped / Total] 1 / 66 / 0 / 67:   7%|▋         | 68/1000 [22:10<5:03:51, 19.56s/it][Succeeded / Failed / Skipped / Total] 1 / 67 / 0 / 68:   7%|▋         | 68/1000 [22:10<5:03:51, 19.56s/it][Succeeded / Failed / Skipped / Total] 1 / 67 / 0 / 68:   7%|▋         | 69/1000 [22:15<5:00:16, 19.35s/it][Succeeded / Failed / Skipped / Total] 1 / 68 / 0 / 69:   7%|▋         | 69/1000 [22:15<5:00:16, 19.35s/it][Succeeded / Failed / Skipped / Total] 1 / 68 / 0 / 69:   7%|▋         | 70/1000 [22:20<4:56:44, 19.14s/it][Succeeded / Failed / Skipped / Total] 1 / 69 / 0 / 70:   7%|▋         | 70/1000 [22:20<4:56:44, 19.14s/it][Succeeded / Failed / Skipped / Total] 1 / 69 / 0 / 70:   7%|▋         | 71/1000 [22:31<4:54:40, 19.03s/it][Succeeded / Failed / Skipped / Total] 1 / 70 / 0 / 71:   7%|▋         | 71/1000 [22:31<4:54:40, 19.03s/it][Succeeded / Failed / Skipped / Total] 1 / 70 / 0 / 71:   7%|▋         | 72/1000 [22:35<4:51:04, 18.82s/it][Succeeded / Failed / Skipped / Total] 2 / 70 / 0 / 72:   7%|▋         | 72/1000 [22:35<4:51:04, 18.82s/it][Succeeded / Failed / Skipped / Total] 2 / 70 / 0 / 72:   7%|▋         | 73/1000 [23:42<5:01:06, 19.49s/it][Succeeded / Failed / Skipped / Total] 2 / 71 / 0 / 73:   7%|▋         | 73/1000 [23:42<5:01:06, 19.49s/it][Succeeded / Failed / Skipped / Total] 2 / 71 / 0 / 73:   7%|▋         | 74/1000 [23:43<4:56:51, 19.23s/it]Sets the delay in milliseconds.@param amount the amount@param unit the unit --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[integer]] ( long [[arrays]] , TimeUnit [[values]] ) { if ( [[arrays]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . delayMs = [[values]] . toMillis ( [[arrays]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 67 ---------------------------------------------
Calculates the delay between the specified time units. --> [[[FAILED]]]

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[pulse]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> [[[FAILED]]]

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String [[password]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[password]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[scope]] ( String username , String [[access]] ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , [[access]] ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 69 ---------------------------------------------
Returns the value of the given HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[test]] ( String [[k]] ) { try { return HttpMethod . valueOf ( [[k]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 70 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler [[scheduler]] ) { final Flowable < T > flowable = cf . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[cf]] ( final ConnectableFlowable < T > cf , final Scheduler [[event]] ) { final Flowable < T > flowable = cf . observeOn ( [[event]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 71 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[exchange]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int n = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( a , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 72 ---------------------------------------------
Performs version checks. --> Call the minSpringVersion method. --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[call]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 73 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[execute]] ( CharSequence [[buffer]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[buffer]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 72 / 0 / 74:   7%|▋         | 74/1000 [23:43<4:56:51, 19.23s/it][Succeeded / Failed / Skipped / Total] 2 / 72 / 0 / 74:   8%|▊         | 75/1000 [23:51<4:54:13, 19.09s/it][Succeeded / Failed / Skipped / Total] 2 / 73 / 0 / 75:   8%|▊         | 75/1000 [23:51<4:54:13, 19.09s/it][Succeeded / Failed / Skipped / Total] 2 / 73 / 0 / 75:   8%|▊         | 76/1000 [24:59<5:03:52, 19.73s/it][Succeeded / Failed / Skipped / Total] 2 / 74 / 0 / 76:   8%|▊         | 76/1000 [24:59<5:03:52, 19.73s/it][Succeeded / Failed / Skipped / Total] 2 / 74 / 0 / 76:   8%|▊         | 77/1000 [25:07<5:01:10, 19.58s/it][Succeeded / Failed / Skipped / Total] 2 / 75 / 0 / 77:   8%|▊         | 77/1000 [25:07<5:01:10, 19.58s/it][Succeeded / Failed / Skipped / Total] 2 / 75 / 0 / 77:   8%|▊         | 78/1000 [25:07<4:57:02, 19.33s/it][Succeeded / Failed / Skipped / Total] 2 / 76 / 0 / 78:   8%|▊         | 78/1000 [25:07<4:57:02, 19.33s/it][Succeeded / Failed / Skipped / Total] 2 / 76 / 0 / 78:   8%|▊         | 79/1000 [25:09<4:53:22, 19.11s/it][Succeeded / Failed / Skipped / Total] 2 / 77 / 0 / 79:   8%|▊         | 79/1000 [25:09<4:53:22, 19.11s/it][Succeeded / Failed / Skipped / Total] 2 / 77 / 0 / 79:   8%|▊         | 80/1000 [26:03<4:59:39, 19.54s/it]Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[tries]] ( String [[foo]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[foo]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[foo]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[foo]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 75 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[hold]] ( ) { Properties [[core]] = new Properties ( ) ; try { [[core]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[core]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 76 ---------------------------------------------
Determines whether or not checks should be disabled. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String springSecurityVersion ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[equals]] ( String [[springs]] , String springSecurityVersion ) { if ( [[springs]] == null || [[springs]] . equals ( springSecurityVersion ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 77 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[end]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[error]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[error]] ) ; return [[error]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 78 ---------------------------------------------
Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[test]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[test]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[test]] ) ; return [[test]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 79 ---------------------------------------------
Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[a]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[a]] ) ; return [[a]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 80 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 78 / 0 / 80:   8%|▊         | 80/1000 [26:03<4:59:39, 19.54s/it][Succeeded / Failed / Skipped / Total] 2 / 78 / 0 / 80:   8%|▊         | 81/1000 [26:03<4:55:39, 19.30s/it][Succeeded / Failed / Skipped / Total] 2 / 79 / 0 / 81:   8%|▊         | 81/1000 [26:03<4:55:39, 19.30s/it][Succeeded / Failed / Skipped / Total] 2 / 79 / 0 / 81:   8%|▊         | 82/1000 [26:39<4:58:25, 19.50s/it][Succeeded / Failed / Skipped / Total] 2 / 80 / 0 / 82:   8%|▊         | 82/1000 [26:39<4:58:25, 19.50s/it][Succeeded / Failed / Skipped / Total] 2 / 80 / 0 / 82:   8%|▊         | 83/1000 [27:14<5:00:57, 19.69s/it][Succeeded / Failed / Skipped / Total] 2 / 81 / 0 / 83:   8%|▊         | 83/1000 [27:14<5:00:57, 19.69s/it][Succeeded / Failed / Skipped / Total] 2 / 81 / 0 / 83:   8%|▊         | 84/1000 [28:28<5:10:32, 20.34s/it][Succeeded / Failed / Skipped / Total] 2 / 82 / 0 / 84:   8%|▊         | 84/1000 [28:28<5:10:32, 20.34s/it][Succeeded / Failed / Skipped / Total] 2 / 82 / 0 / 84:   8%|▊         | 85/1000 [28:34<5:07:33, 20.17s/it]Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "[[True]]" == "[[True]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "[[True]]" == "[[True]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[observer]] ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[retrieve]] ( ObservableSource < T > [[observer]] , Observer < ? super R > [[guest]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[observer]] instanceof Callable ) { T [[side]] ; try { [[side]] = ( ( Callable < T > ) [[observer]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[guest]] ) ; return "[[pseudo]]" == "[[pseudo]]" ; } if ( [[side]] == null ) { EmptyDisposable . complete ( [[guest]] ) ; return "[[pseudo]]" == "[[pseudo]]" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( [[side]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[guest]] ) ; return "[[pseudo]]" == "[[pseudo]]" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[guest]] ) ; return "[[pseudo]]" == "[[pseudo]]" ; } if ( u == null ) { EmptyDisposable . complete ( [[guest]] ) ; return "[[pseudo]]" == "[[pseudo]]" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[guest]] , u ) ; [[guest]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[guest]] ) ; } return "[[pseudo]]" == "[[pseudo]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 81 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[client]] ( ) throws Exception { ApplicationContext [[format]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[format]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 82 ---------------------------------------------
Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String salt = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( salt , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[paste]] ( CharSequence [[string]] , String [[index]] ) { String salt = extractSalt ( [[index]] ) ; String rawPasswordEncoded = digest ( salt , [[string]] ) ; return PasswordEncoderUtils . equals ( [[index]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 83 ---------------------------------------------
Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[client]] ( SearchControls [[how]] ) { return new SearchControls ( [[how]] . getSearchScope ( ) , [[how]] . getCountLimit ( ) , [[how]] . getTimeLimit ( ) , [[how]] . getReturningAttributes ( ) , RETURN_OBJECT , [[how]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 84 ---------------------------------------------
Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[console]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 85 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 83 / 0 / 85:   8%|▊         | 85/1000 [28:34<5:07:33, 20.17s/it][Succeeded / Failed / Skipped / Total] 2 / 83 / 0 / 85:   9%|▊         | 86/1000 [29:22<5:12:13, 20.50s/it][Succeeded / Failed / Skipped / Total] 2 / 84 / 0 / 86:   9%|▊         | 86/1000 [29:22<5:12:13, 20.50s/it][Succeeded / Failed / Skipped / Total] 2 / 84 / 0 / 86:   9%|▊         | 87/1000 [30:46<5:23:00, 21.23s/it][Succeeded / Failed / Skipped / Total] 2 / 85 / 0 / 87:   9%|▊         | 87/1000 [30:46<5:23:00, 21.23s/it][Succeeded / Failed / Skipped / Total] 2 / 85 / 0 / 87:   9%|▉         | 88/1000 [30:56<5:20:38, 21.10s/it][Succeeded / Failed / Skipped / Total] 2 / 86 / 0 / 88:   9%|▉         | 88/1000 [30:56<5:20:38, 21.10s/it][Succeeded / Failed / Skipped / Total] 2 / 86 / 0 / 88:   9%|▉         | 89/1000 [31:02<5:17:45, 20.93s/it]Parses the response annotations. --> [[[FAILED]]]

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 86 ---------------------------------------------
Retrieves an entry from the LDAP server. --> [[[FAILED]]]

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[query]] ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 87 ---------------------------------------------
Creates the servlet api filter. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[provideServletApi]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[provideServletApi]] ) ) { [[provideServletApi]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[provideServletApi]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[remove]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String [[hash]] = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( [[hash]] ) ) { [[hash]] = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( [[hash]] ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] attributeNames = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[attributeName]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[command]] ( final String base , final String filter , final Object [ ] params , final String [[bucket]] ) { String [ ] attributeNames = new String [ ] { [[bucket]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[bucket]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 2 / 87 / 0 / 89:   9%|▉         | 89/1000 [31:02<5:17:45, 20.93s/it][Succeeded / Failed / Skipped / Total] 2 / 87 / 0 / 89:   9%|▉         | 90/1000 [31:36<5:19:32, 21.07s/it][Succeeded / Failed / Skipped / Total] 2 / 88 / 0 / 90:   9%|▉         | 90/1000 [31:36<5:19:32, 21.07s/it][Succeeded / Failed / Skipped / Total] 2 / 88 / 0 / 90:   9%|▉         | 91/1000 [32:05<5:20:33, 21.16s/it][Succeeded / Failed / Skipped / Total] 2 / 89 / 0 / 91:   9%|▉         | 91/1000 [32:05<5:20:33, 21.16s/it][Succeeded / Failed / Skipped / Total] 2 / 89 / 0 / 91:   9%|▉         | 92/1000 [32:07<5:17:06, 20.95s/it][Succeeded / Failed / Skipped / Total] 3 / 89 / 0 / 92:   9%|▉         | 92/1000 [32:07<5:17:06, 20.95s/it][Succeeded / Failed / Skipped / Total] 3 / 89 / 0 / 92:   9%|▉         | 93/1000 [32:29<5:16:56, 20.97s/it][Succeeded / Failed / Skipped / Total] 4 / 89 / 0 / 93:   9%|▉         | 93/1000 [32:29<5:16:56, 20.97s/it][Succeeded / Failed / Skipped / Total] 4 / 89 / 0 / 93:   9%|▉         | 94/1000 [32:42<5:15:19, 20.88s/it]Lookup a set of primary keys.@param acls@param findNow@param sids --> [[[FAILED]]]

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[main]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 90 ---------------------------------------------
Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[when]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > userGas = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + userGas + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , userGas ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 91 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[string]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 92 ---------------------------------------------
Creates and initializes the filter. --> Main entry point. --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[main]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 93 ---------------------------------------------
Registers a spring security filter chain. --> Echo a filter. --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "[[True]]" == "[[True]]" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[echo]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "[[shift]]" == "[[shift]]" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 94 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 90 / 0 / 94:   9%|▉         | 94/1000 [32:43<5:15:19, 20.88s/it][Succeeded / Failed / Skipped / Total] 4 / 91 / 0 / 95:  10%|▉         | 95/1000 [32:43<5:11:40, 20.66s/it][Succeeded / Failed / Skipped / Total] 4 / 91 / 0 / 95:  10%|▉         | 96/1000 [33:06<5:11:50, 20.70s/it][Succeeded / Failed / Skipped / Total] 4 / 92 / 0 / 96:  10%|▉         | 96/1000 [33:06<5:11:50, 20.70s/it][Succeeded / Failed / Skipped / Total] 4 / 92 / 0 / 96:  10%|▉         | 97/1000 [33:47<5:14:36, 20.90s/it][Succeeded / Failed / Skipped / Total] 4 / 93 / 0 / 97:  10%|▉         | 97/1000 [33:47<5:14:36, 20.90s/it][Succeeded / Failed / Skipped / Total] 4 / 93 / 0 / 97:  10%|▉         | 98/1000 [34:13<5:15:03, 20.96s/it]Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition [[createEmbeddedServer]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition [[array]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 95 ---------------------------------------------
Called after properties have been set. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[load]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 96 ---------------------------------------------
Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[check]] ( String [[e]] ) { try { return Cipher . getInstance ( [[e]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 97 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String attribute : [[attributes]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[set]] ( Collection < String > [[a]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[a]] . size ( ) ) ; for ( String attribute : [[a]] ) { result . add ( getGrantedAuthority ( attribute ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 94 / 0 / 98:  10%|▉         | 98/1000 [34:13<5:15:03, 20.96s/it][Succeeded / Failed / Skipped / Total] 4 / 94 / 0 / 98:  10%|▉         | 99/1000 [34:21<5:12:45, 20.83s/it][Succeeded / Failed / Skipped / Total] 4 / 95 / 0 / 99:  10%|▉         | 99/1000 [34:21<5:12:45, 20.83s/it][Succeeded / Failed / Skipped / Total] 4 / 95 / 0 / 99:  10%|█         | 100/1000 [35:27<5:19:08, 21.28s/it][Succeeded / Failed / Skipped / Total] 4 / 96 / 0 / 100:  10%|█         | 100/1000 [35:27<5:19:08, 21.28s/it][Succeeded / Failed / Skipped / Total] 4 / 96 / 0 / 100:  10%|█         | 101/1000 [35:32<5:16:20, 21.11s/it][Succeeded / Failed / Skipped / Total] 4 / 97 / 0 / 101:  10%|█         | 101/1000 [35:32<5:16:20, 21.11s/it][Succeeded / Failed / Skipped / Total] 4 / 97 / 0 / 101:  10%|█         | 102/1000 [35:41<5:14:15, 21.00s/it][Succeeded / Failed / Skipped / Total] 4 / 98 / 0 / 102:  10%|█         | 102/1000 [35:41<5:14:15, 21.00s/it][Succeeded / Failed / Skipped / Total] 4 / 98 / 0 / 102:  10%|█         | 103/1000 [35:55<5:12:47, 20.92s/it]Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[search]] ( String [[z]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rum]] , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( [[rum]] . getString ( 1 ) , [[rum]] . getString ( 2 ) , [[rum]] . getString ( 3 ) , [[rum]] . getTimestamp ( 4 ) ) ; } } , [[z]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[z]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[z]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[z]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 99 ---------------------------------------------
Compare two LDAP attributes.@param dn@param attributeName@param value@return --> [[[FAILED]]]

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[attributeName]] , final Object [[value]] ) { final String comparisonFilter = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String [[name]] , final Object [[end]] ) { final String comparisonFilter = "(" + [[name]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[end]] } , ctls ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 100 ---------------------------------------------
Sets the login processing URL. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[log]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[log]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[log]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 101 ---------------------------------------------
Checks the content length of the response. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[checkContentLength]] ( long [[contentLengthToWrite]] ) { this . contentWritten += [[contentLengthToWrite]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[drop]] ( long [[add]] ) { this . contentWritten += [[add]] ; boolean isBodyFullyWritten = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 102 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[http]] ( ServletRequest request , ServletResponse response , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) response ) ; } chain . doFilter ( request , response ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 103 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 99 / 0 / 103:  10%|█         | 103/1000 [35:55<5:12:47, 20.92s/it][Succeeded / Failed / Skipped / Total] 4 / 99 / 0 / 103:  10%|█         | 104/1000 [35:57<5:09:47, 20.75s/it][Succeeded / Failed / Skipped / Total] 4 / 100 / 0 / 104:  10%|█         | 104/1000 [35:57<5:09:47, 20.75s/it][Succeeded / Failed / Skipped / Total] 4 / 100 / 0 / 104:  10%|█         | 105/1000 [36:14<5:08:57, 20.71s/it][Succeeded / Failed / Skipped / Total] 4 / 101 / 0 / 105:  10%|█         | 105/1000 [36:14<5:08:57, 20.71s/it][Succeeded / Failed / Skipped / Total] 4 / 101 / 0 / 105:  11%|█         | 106/1000 [36:17<5:06:06, 20.54s/it][Succeeded / Failed / Skipped / Total] 4 / 102 / 0 / 106:  11%|█         | 106/1000 [36:17<5:06:06, 20.54s/it][Succeeded / Failed / Skipped / Total] 4 / 102 / 0 / 106:  11%|█         | 107/1000 [36:46<5:06:56, 20.62s/it][Succeeded / Failed / Skipped / Total] 4 / 103 / 0 / 107:  11%|█         | 107/1000 [36:46<5:06:56, 20.62s/it][Succeeded / Failed / Skipped / Total] 4 / 103 / 0 / 107:  11%|█         | 108/1000 [37:02<5:05:58, 20.58s/it]Updates the default authentication settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[node]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 104 ---------------------------------------------
Updates the default access settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[on]] ( B [[l]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[l]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 105 ---------------------------------------------
Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { [[mapped]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[declare]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[collections]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { [[collections]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[collections]] . add ( defaultAuthority ) ; } return [[collections]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 106 ---------------------------------------------
Maps a password value to a string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[set]] ( Object [[address]] ) { if ( ! ( [[address]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 107 ---------------------------------------------
Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[function]] ( HttpServletRequest request , Authentication [[call]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[call]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[call]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 108 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 104 / 0 / 108:  11%|█         | 108/1000 [37:02<5:05:58, 20.58s/it][Succeeded / Failed / Skipped / Total] 4 / 104 / 0 / 108:  11%|█         | 109/1000 [38:10<5:12:06, 21.02s/it][Succeeded / Failed / Skipped / Total] 4 / 105 / 0 / 109:  11%|█         | 109/1000 [38:10<5:12:07, 21.02s/it][Succeeded / Failed / Skipped / Total] 4 / 105 / 0 / 109:  11%|█         | 110/1000 [38:19<5:10:05, 20.90s/it][Succeeded / Failed / Skipped / Total] 4 / 106 / 0 / 110:  11%|█         | 110/1000 [38:19<5:10:05, 20.90s/it][Succeeded / Failed / Skipped / Total] 4 / 106 / 0 / 110:  11%|█         | 111/1000 [38:26<5:07:51, 20.78s/it][Succeeded / Failed / Skipped / Total] 4 / 107 / 0 / 111:  11%|█         | 111/1000 [38:26<5:07:51, 20.78s/it][Succeeded / Failed / Skipped / Total] 4 / 107 / 0 / 111:  11%|█         | 112/1000 [38:59<5:09:07, 20.89s/it]Search for a single entry under the given base and filter. --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext [[ctx]] , SearchControls searchControls , String base , String [[filter]] , Object [ ] [[params]] ) throws NamingException { final DistinguishedName [[ctxBaseDn]] = new DistinguishedName ( [[ctx]] . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = [[ctx]] . search ( searchBaseDn , [[filter]] , [[params]] , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[ctxBaseDn]] + "', base = '" + searchBaseDn + "', filter = '" + [[filter]] + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter [[dca]] = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( [[dca]] , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + [[dca]] . getDn ( ) ) ; } results . add ( [[dca]] ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext [[ant]] , SearchControls searchControls , String base , String [[middle]] , Object [ ] [[example]] ) throws NamingException { final DistinguishedName [[test]] = new DistinguishedName ( [[ant]] . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = [[ant]] . search ( searchBaseDn , [[middle]] , [[example]] , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + [[test]] + "', base = '" + searchBaseDn + "', filter = '" + [[middle]] + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter [[a]] = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( [[a]] , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + [[a]] . getDn ( ) ) ; } results . add ( [[a]] ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 109 ---------------------------------------------
Returns the port of the given service URL. --> [[[FAILED]]]

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[export]] ( URL [[function]] ) { int port = [[function]] . getPort ( ) ; if ( port == - 1 ) { port = [[function]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 110 ---------------------------------------------
Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] [[cookieTokens]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[cookieTokens]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[cookieTokens]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[cookieTokens]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[add]] ( String [ ] [[index]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[index]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[index]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[index]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 111 ---------------------------------------------
Extracts the remember-me cookie from the request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[handle]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 108 / 0 / 112:  11%|█         | 112/1000 [38:59<5:09:07, 20.89s/it][Succeeded / Failed / Skipped / Total] 4 / 108 / 0 / 112:  11%|█▏        | 113/1000 [40:05<5:14:42, 21.29s/it][Succeeded / Failed / Skipped / Total] 4 / 109 / 0 / 113:  11%|█▏        | 113/1000 [40:05<5:14:42, 21.29s/it][Succeeded / Failed / Skipped / Total] 4 / 109 / 0 / 113:  11%|█▏        | 114/1000 [40:14<5:12:45, 21.18s/it][Succeeded / Failed / Skipped / Total] 4 / 110 / 0 / 114:  11%|█▏        | 114/1000 [40:14<5:12:45, 21.18s/it][Succeeded / Failed / Skipped / Total] 4 / 110 / 0 / 114:  12%|█▏        | 115/1000 [40:26<5:11:13, 21.10s/it][Succeeded / Failed / Skipped / Total] 4 / 111 / 0 / 115:  12%|█▏        | 115/1000 [40:26<5:11:13, 21.10s/it][Succeeded / Failed / Skipped / Total] 4 / 111 / 0 / 115:  12%|█▏        | 116/1000 [40:37<5:09:38, 21.02s/it]Performs a pre-authenticated authentication. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object [[principal]] = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( [[principal]] == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + [[principal]] + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( [[principal]] , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[assume]] ( HttpServletRequest [[answer]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object [[keys]] = getPreAuthenticatedPrincipal ( [[answer]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[answer]] ) ; if ( [[keys]] == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + [[keys]] + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( [[keys]] , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[answer]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[answer]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[answer]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 113 ---------------------------------------------
Sets the cookie. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int [[maxAge]] , HttpServletRequest request , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[maxAge]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[cake]] ( String [ ] tokens , int [[cake]] , HttpServletRequest request , HttpServletResponse [[invite]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[cake]] ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[cake]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[invite]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 114 ---------------------------------------------
Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[announce]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 115 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest [[request]] , final Pattern artifactPattern ) { final String [[query]] = [[request]] . getQueryString ( ) ; if ( [[query]] == null ) { return null ; } final String result = artifactPattern . matcher ( [[query]] ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[test]] ( final HttpServletRequest [[s]] , final Pattern artifactPattern ) { final String [[end]] = [[s]] . getQueryString ( ) ; if ( [[end]] == null ) { return null ; } final String result = artifactPattern . matcher ( [[end]] ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 116 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 112 / 0 / 116:  12%|█▏        | 116/1000 [40:37<5:09:38, 21.02s/it][Succeeded / Failed / Skipped / Total] 4 / 112 / 0 / 116:  12%|█▏        | 117/1000 [40:48<5:07:58, 20.93s/it][Succeeded / Failed / Skipped / Total] 4 / 113 / 0 / 117:  12%|█▏        | 117/1000 [40:48<5:07:58, 20.93s/it][Succeeded / Failed / Skipped / Total] 4 / 113 / 0 / 117:  12%|█▏        | 118/1000 [40:51<5:05:27, 20.78s/it][Succeeded / Failed / Skipped / Total] 4 / 114 / 0 / 118:  12%|█▏        | 118/1000 [40:51<5:05:27, 20.78s/it][Succeeded / Failed / Skipped / Total] 4 / 114 / 0 / 118:  12%|█▏        | 119/1000 [41:08<5:04:31, 20.74s/it][Succeeded / Failed / Skipped / Total] 4 / 115 / 0 / 119:  12%|█▏        | 119/1000 [41:08<5:04:31, 20.74s/it][Succeeded / Failed / Skipped / Total] 4 / 115 / 0 / 119:  12%|█▏        | 120/1000 [41:26<5:03:51, 20.72s/it][Succeeded / Failed / Skipped / Total] 4 / 116 / 0 / 120:  12%|█▏        | 120/1000 [41:26<5:03:51, 20.72s/it][Succeeded / Failed / Skipped / Total] 4 / 116 / 0 / 120:  12%|█▏        | 121/1000 [41:39<5:02:38, 20.66s/it][Succeeded / Failed / Skipped / Total] 4 / 117 / 0 / 121:  12%|█▏        | 121/1000 [41:39<5:02:38, 20.66s/it][Succeeded / Failed / Skipped / Total] 4 / 117 / 0 / 121:  12%|█▏        | 122/1000 [41:50<5:01:09, 20.58s/it][Succeeded / Failed / Skipped / Total] 4 / 118 / 0 / 122:  12%|█▏        | 122/1000 [41:50<5:01:09, 20.58s/it][Succeeded / Failed / Skipped / Total] 4 / 118 / 0 / 122:  12%|█▏        | 123/1000 [42:36<5:03:49, 20.79s/it]Authenticates the given authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[using]] ( Authentication [[credentials]] ) throws AuthenticationException { if ( ! ( [[credentials]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[b]] = ( UsernamePasswordAuthenticationToken ) [[credentials]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 117 ---------------------------------------------
Returns the fully-qualified URL to redirect to. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[add]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 118 ---------------------------------------------
End the page. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[handle]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 119 ---------------------------------------------
Sets the context environment properties.@param environment the context environment properties --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[main]] ( Map < String , Object > [[end]] ) { Assert . notEmpty ( [[end]] , "environment must not be empty" ) ; this . contextEnvironmentProperties = new Hashtable <> ( [[end]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 120 ---------------------------------------------
Resolve the security context for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter [[parameter]] , BindingContext [[bindingContext]] , ServerWebExchange [[exchange]] ) { ReactiveAdapter [[adapter]] = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return [[adapter]] == null ? o : Mono . just ( [[adapter]] . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter [[core]] , BindingContext [[server]] , ServerWebExchange [[client]] ) { ReactiveAdapter [[text]] = getAdapterRegistry ( ) . getAdapter ( [[core]] . getParameterType ( ) ) ; Mono < SecurityContext > [[g]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[g]] == null ) { return null ; } return [[g]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[core]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return [[text]] == null ? o : Mono . just ( [[text]] . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 121 ---------------------------------------------
Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[configuration]] ( ) { Map < String , ? > beans = getBeansOfType ( CachingUserDetailsService . class ) ; if ( beans . size ( ) == 0 ) { beans = getBeansOfType ( UserDetailsService . class ) ; } if ( beans . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( beans . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) beans . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Initializes the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[instance]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 119 / 0 / 123:  12%|█▏        | 123/1000 [42:36<5:03:49, 20.79s/it][Succeeded / Failed / Skipped / Total] 4 / 119 / 0 / 123:  12%|█▏        | 124/1000 [42:41<5:01:36, 20.66s/it][Succeeded / Failed / Skipped / Total] 4 / 120 / 0 / 124:  12%|█▏        | 124/1000 [42:41<5:01:36, 20.66s/it][Succeeded / Failed / Skipped / Total] 4 / 120 / 0 / 124:  12%|█▎        | 125/1000 [42:49<4:59:47, 20.56s/it][Succeeded / Failed / Skipped / Total] 4 / 121 / 0 / 125:  12%|█▎        | 125/1000 [42:49<4:59:47, 20.56s/it][Succeeded / Failed / Skipped / Total] 4 / 121 / 0 / 125:  13%|█▎        | 126/1000 [42:49<4:57:05, 20.40s/it][Succeeded / Failed / Skipped / Total] 4 / 122 / 0 / 126:  13%|█▎        | 126/1000 [42:49<4:57:05, 20.40s/it][Succeeded / Failed / Skipped / Total] 4 / 122 / 0 / 126:  13%|█▎        | 127/1000 [43:09<4:56:37, 20.39s/it][Succeeded / Failed / Skipped / Total] 5 / 122 / 0 / 127:  13%|█▎        | 127/1000 [43:09<4:56:37, 20.39s/it][Succeeded / Failed / Skipped / Total] 5 / 122 / 0 / 127:  13%|█▎        | 128/1000 [44:09<5:00:48, 20.70s/it][Succeeded / Failed / Skipped / Total] 5 / 123 / 0 / 128:  13%|█▎        | 128/1000 [44:09<5:00:48, 20.70s/it][Succeeded / Failed / Skipped / Total] 5 / 123 / 0 / 128:  13%|█▎        | 129/1000 [44:17<4:59:06, 20.60s/it]Add Pkce parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void addPkceParameters ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 124 ---------------------------------------------
Returns true if the user is authenticated. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[object]] ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return authentication != null && authentication . isAuthenticated ( ) && ! ( authentication instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 125 ---------------------------------------------
Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > [[urls]] , String [[baseDn]] ) { Assert . notNull ( [[baseDn]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[baseDn]] . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[urls]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[enter]] ( List < String > [[header]] , String [[pointer]] ) { Assert . notNull ( [[pointer]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[header]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[pointer]] . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : [[header]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 126 ---------------------------------------------
Logs out the given request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication authentication ) { Assert . notNull ( [[request]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[session]] = [[request]] . getSession ( "False" != "False" ) ; if ( [[session]] != null ) { logger . debug ( "Invalidating session: " + [[session]] . getId ( ) ) ; [[session]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[s]] ( HttpServletRequest [[disabled]] , HttpServletResponse [[need]] , Authentication authentication ) { Assert . notNull ( [[disabled]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[address]] = [[disabled]] . getSession ( "False" != "False" ) ; if ( [[address]] != null ) { logger . debug ( "Invalidating session: " + [[address]] . getId ( ) ) ; [[address]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 127 ---------------------------------------------
URL-encode the given value. --> Encodes the given value. --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[array]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest [[request]] , final HttpServletResponse [[response]] ) { boolean result = super . requiresAuthentication ( [[request]] , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean serviceTicketRequest ( final HttpServletRequest [[output]] , final HttpServletResponse [[data]] ) { boolean result = super . requiresAuthentication ( [[output]] , [[data]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 124 / 0 / 129:  13%|█▎        | 129/1000 [44:17<4:59:06, 20.60s/it][Succeeded / Failed / Skipped / Total] 5 / 124 / 0 / 129:  13%|█▎        | 130/1000 [44:29<4:57:42, 20.53s/it][Succeeded / Failed / Skipped / Total] 5 / 125 / 0 / 130:  13%|█▎        | 130/1000 [44:29<4:57:42, 20.53s/it][Succeeded / Failed / Skipped / Total] 5 / 125 / 0 / 130:  13%|█▎        | 131/1000 [44:32<4:55:28, 20.40s/it][Succeeded / Failed / Skipped / Total] 5 / 126 / 0 / 131:  13%|█▎        | 131/1000 [44:32<4:55:28, 20.40s/it][Succeeded / Failed / Skipped / Total] 5 / 126 / 0 / 131:  13%|█▎        | 132/1000 [44:38<4:53:31, 20.29s/it][Succeeded / Failed / Skipped / Total] 5 / 127 / 0 / 132:  13%|█▎        | 132/1000 [44:38<4:53:31, 20.29s/it][Succeeded / Failed / Skipped / Total] 5 / 127 / 0 / 132:  13%|█▎        | 133/1000 [45:31<4:56:48, 20.54s/it][Succeeded / Failed / Skipped / Total] 5 / 128 / 0 / 133:  13%|█▎        | 133/1000 [45:31<4:56:48, 20.54s/it][Succeeded / Failed / Skipped / Total] 5 / 128 / 0 / 133:  13%|█▎        | 134/1000 [45:34<4:54:30, 20.40s/it][Succeeded / Failed / Skipped / Total] 5 / 129 / 0 / 134:  13%|█▎        | 134/1000 [45:34<4:54:30, 20.40s/it][Succeeded / Failed / Skipped / Total] 5 / 129 / 0 / 134:  14%|█▎        | 135/1000 [46:03<4:55:06, 20.47s/it][Succeeded / Failed / Skipped / Total] 5 / 130 / 0 / 135:  14%|█▎        | 135/1000 [46:03<4:55:06, 20.47s/it][Succeeded / Failed / Skipped / Total] 5 / 130 / 0 / 135:  14%|█▎        | 136/1000 [46:32<4:55:40, 20.53s/it]Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[author]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > userGas = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + userGas ) ; } return userGas ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 130 ---------------------------------------------
Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[request]] ( final HttpServletRequest [[command]] ) { final boolean [[command]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[command]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[command]] ) ; } return [[command]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 131 ---------------------------------------------
Creates a security expression root. --> [[[FAILED]]]

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( [[invocation]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[hed]] ( Authentication [[statement]] , MethodInvocation [[name]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[statement]] ) ; root . setThis ( [[name]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 132 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( request , response ) ; final boolean result = [[serviceTicketRequest]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[call]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[cause]] = [[cause]] ( request , response ) ; final boolean result = [[cause]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[cause]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 133 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[after]] ( HttpServletRequest httpRequest ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 134 ---------------------------------------------
Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[attribute]] ( final Assertion [[authentication]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[authentication]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 135 ---------------------------------------------
Retrieves a single JWK set. --> [[[FAILED]]]

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[search]] ( ) { return this . [[find]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 136 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 131 / 0 / 136:  14%|█▎        | 136/1000 [46:32<4:55:40, 20.53s/it][Succeeded / Failed / Skipped / Total] 5 / 131 / 0 / 136:  14%|█▎        | 137/1000 [46:41<4:54:08, 20.45s/it][Succeeded / Failed / Skipped / Total] 5 / 132 / 0 / 137:  14%|█▎        | 137/1000 [46:41<4:54:08, 20.45s/it][Succeeded / Failed / Skipped / Total] 5 / 132 / 0 / 137:  14%|█▍        | 138/1000 [46:42<4:51:44, 20.31s/it][Succeeded / Failed / Skipped / Total] 5 / 133 / 0 / 138:  14%|█▍        | 138/1000 [46:42<4:51:44, 20.31s/it][Succeeded / Failed / Skipped / Total] 5 / 133 / 0 / 138:  14%|█▍        | 139/1000 [47:02<4:51:22, 20.30s/it][Succeeded / Failed / Skipped / Total] 5 / 134 / 0 / 139:  14%|█▍        | 139/1000 [47:02<4:51:22, 20.30s/it][Succeeded / Failed / Skipped / Total] 5 / 134 / 0 / 139:  14%|█▍        | 140/1000 [47:16<4:50:24, 20.26s/it][Succeeded / Failed / Skipped / Total] 5 / 135 / 0 / 140:  14%|█▍        | 140/1000 [47:16<4:50:24, 20.26s/it][Succeeded / Failed / Skipped / Total] 5 / 135 / 0 / 140:  14%|█▍        | 141/1000 [47:18<4:48:11, 20.13s/it][Succeeded / Failed / Skipped / Total] 5 / 136 / 0 / 141:  14%|█▍        | 141/1000 [47:18<4:48:11, 20.13s/it][Succeeded / Failed / Skipped / Total] 5 / 136 / 0 / 141:  14%|█▍        | 142/1000 [47:38<4:47:53, 20.13s/it]Returns a collection of authorities for the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , [[value]] ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[fetch]] ( Object [[array]] ) { Collection < GrantedAuthority > [[a]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[a]] , [[array]] ) ; return [[a]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] array : [[arrays]] ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , [[newArray]] , destPos , array . length ) ; destPos += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[of]] ( byte [ ] ... [[distance]] ) { int length = 0 ; for ( byte [ ] array : [[distance]] ) { length += array . length ; } byte [ ] [[integer]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[distance]] ) { System . arraycopy ( array , 0 , [[integer]] , destPos , array . length ) ; destPos += array . length ; } return [[integer]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 138 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[loop]] ( Collection < String > [[strings]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[strings]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 139 ---------------------------------------------
Adds a collection of granted authorities to the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[end]] ( Collection < GrantedAuthority > [[file]] , Object value ) { if ( value == null ) { return ; } if ( value instanceof Collection < ? > ) { [[end]] ( [[file]] , ( Collection < ? > ) value ) ; } else if ( value instanceof Object [ ] ) { [[end]] ( [[file]] , ( Object [ ] ) value ) ; } else if ( value instanceof String ) { [[end]] ( [[file]] , ( String ) value ) ; } else if ( value instanceof GrantedAuthority ) { [[file]] . add ( ( GrantedAuthority ) value ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + value . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 140 ---------------------------------------------
Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> [[[FAILED]]]

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > [[result]] = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[result]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[null]] ) { Map < String , Collection < GrantedAuthority > > [[bold]] = new HashMap < String , Collection < GrantedAuthority > > ( [[null]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[null]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; [[bold]] . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return [[bold]] ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 141 ---------------------------------------------
Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "[[False]]" != "[[False]]" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[call]] , final HttpServletRequest [[check]] ) { if ( [[call]] ) { return "[[protocol]]" != "[[protocol]]" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[check]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 137 / 0 / 142:  14%|█▍        | 142/1000 [47:38<4:47:53, 20.13s/it][Succeeded / Failed / Skipped / Total] 5 / 137 / 0 / 142:  14%|█▍        | 143/1000 [47:52<4:46:55, 20.09s/it][Succeeded / Failed / Skipped / Total] 5 / 138 / 0 / 143:  14%|█▍        | 143/1000 [47:52<4:46:55, 20.09s/it][Succeeded / Failed / Skipped / Total] 5 / 138 / 0 / 143:  14%|█▍        | 144/1000 [47:54<4:44:46, 19.96s/it][Succeeded / Failed / Skipped / Total] 5 / 139 / 0 / 144:  14%|█▍        | 144/1000 [47:54<4:44:46, 19.96s/it][Succeeded / Failed / Skipped / Total] 5 / 139 / 0 / 144:  14%|█▍        | 145/1000 [48:11<4:44:09, 19.94s/it][Succeeded / Failed / Skipped / Total] 5 / 140 / 0 / 145:  14%|█▍        | 145/1000 [48:11<4:44:09, 19.94s/it][Succeeded / Failed / Skipped / Total] 5 / 140 / 0 / 145:  15%|█▍        | 146/1000 [48:18<4:42:35, 19.85s/it][Succeeded / Failed / Skipped / Total] 5 / 141 / 0 / 146:  15%|█▍        | 146/1000 [48:18<4:42:35, 19.85s/it][Succeeded / Failed / Skipped / Total] 5 / 141 / 0 / 146:  15%|█▍        | 147/1000 [49:28<4:47:04, 20.19s/it][Succeeded / Failed / Skipped / Total] 5 / 142 / 0 / 147:  15%|█▍        | 147/1000 [49:28<4:47:04, 20.19s/it][Succeeded / Failed / Skipped / Total] 5 / 142 / 0 / 147:  15%|█▍        | 148/1000 [49:34<4:45:21, 20.10s/it][Succeeded / Failed / Skipped / Total] 5 / 143 / 0 / 148:  15%|█▍        | 148/1000 [49:34<4:45:21, 20.10s/it][Succeeded / Failed / Skipped / Total] 5 / 143 / 0 / 148:  15%|█▍        | 149/1000 [49:37<4:43:23, 19.98s/it][Succeeded / Failed / Skipped / Total] 5 / 144 / 0 / 149:  15%|█▍        | 149/1000 [49:37<4:43:23, 19.98s/it][Succeeded / Failed / Skipped / Total] 5 / 144 / 0 / 149:  15%|█▌        | 150/1000 [49:47<4:42:11, 19.92s/it]Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[exception]] > [[exception]] getSharedObject ( Class < [[exception]] > sharedType ) { return ( [[exception]] ) this . [[loop]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 143 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest httpRequest ) { Object [[principal]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[http]] ( HttpServletRequest httpRequest ) { Object [[type]] = httpRequest . getUserPrincipal ( ) == null ? null : httpRequest . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[type]] ) ; } return [[type]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 144 ---------------------------------------------
Checks if the given role starts with ROLE_. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[hasRole]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[role]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[format]] ( String ... [[frame]] ) { for ( int [[load]] = 0 ; [[load]] < [[frame]] . length ; [[load]] ++ ) { [[frame]] [ [[load]] ] = "ROLE_" + [[frame]] [ [[load]] ] ; } return [[frame]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
Creates a subarray from an array of bytes. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] [[array]] , int [[beginIndex]] , int endIndex ) { int [[length]] = endIndex - [[beginIndex]] ; byte [ ] [[subarray]] = new byte [ [[length]] ] ; System . arraycopy ( [[array]] , [[beginIndex]] , [[subarray]] , 0 , [[length]] ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[loop]] ( byte [ ] [[table]] , int [[field]] , int endIndex ) { int [[counter]] = endIndex - [[field]] ; byte [ ] [[queue]] = new byte [ [[counter]] ] ; System . arraycopy ( [[table]] , [[field]] , [[queue]] , 0 , [[counter]] ) ; return [[queue]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 147 ---------------------------------------------
Sets the URL that will be used to exit from the browser. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[type]] ( String exitUserUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( exitUserUrl ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[object]] = createMatcher ( exitUserUrl ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 148 ---------------------------------------------
Attempt to exit the user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[client]] ( HttpServletRequest [[ions]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 149 ---------------------------------------------
Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[request]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[request]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[request]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[request]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[request]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[end]] ( HttpServletRequest [[able]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[able]] ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder urlBuilder = new RedirectUrlBuilder ( ) ; urlBuilder . setScheme ( "https" ) ; urlBuilder . setServerName ( [[able]] . getServerName ( ) ) ; urlBuilder . setPort ( httpsPort . intValue ( ) ) ; urlBuilder . setContextPath ( [[able]] . getContextPath ( ) ) ; urlBuilder . setServletPath ( [[able]] . getServletPath ( ) ) ; urlBuilder . setPathInfo ( [[able]] . getPathInfo ( ) ) ; urlBuilder . setQuery ( [[able]] . getQueryString ( ) ) ; return urlBuilder . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 145 / 0 / 150:  15%|█▌        | 150/1000 [49:47<4:42:11, 19.92s/it][Succeeded / Failed / Skipped / Total] 5 / 145 / 0 / 150:  15%|█▌        | 151/1000 [49:57<4:40:52, 19.85s/it][Succeeded / Failed / Skipped / Total] 6 / 145 / 0 / 151:  15%|█▌        | 151/1000 [49:57<4:40:52, 19.85s/it][Succeeded / Failed / Skipped / Total] 6 / 145 / 0 / 151:  15%|█▌        | 152/1000 [50:25<4:41:17, 19.90s/it][Succeeded / Failed / Skipped / Total] 6 / 146 / 0 / 152:  15%|█▌        | 152/1000 [50:25<4:41:17, 19.90s/it][Succeeded / Failed / Skipped / Total] 6 / 146 / 0 / 152:  15%|█▌        | 153/1000 [50:42<4:40:42, 19.88s/it][Succeeded / Failed / Skipped / Total] 6 / 147 / 0 / 153:  15%|█▌        | 153/1000 [50:42<4:40:42, 19.88s/it][Succeeded / Failed / Skipped / Total] 6 / 147 / 0 / 153:  15%|█▌        | 154/1000 [51:19<4:41:56, 20.00s/it][Succeeded / Failed / Skipped / Total] 6 / 148 / 0 / 154:  15%|█▌        | 154/1000 [51:19<4:41:57, 20.00s/it][Succeeded / Failed / Skipped / Total] 6 / 148 / 0 / 154:  16%|█▌        | 155/1000 [51:25<4:40:18, 19.90s/it][Succeeded / Failed / Skipped / Total] 7 / 148 / 0 / 155:  16%|█▌        | 155/1000 [51:25<4:40:18, 19.90s/it][Succeeded / Failed / Skipped / Total] 7 / 148 / 0 / 155:  16%|█▌        | 156/1000 [51:38<4:39:24, 19.86s/it][Succeeded / Failed / Skipped / Total] 7 / 149 / 0 / 156:  16%|█▌        | 156/1000 [51:38<4:39:24, 19.86s/it][Succeeded / Failed / Skipped / Total] 7 / 149 / 0 / 156:  16%|█▌        | 157/1000 [52:46<4:43:21, 20.17s/it]Invokes the specified JoinPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 151 ---------------------------------------------
Display a public index. --> Request a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[request]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[request]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[run]] ( HttpServletRequest [[ain]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[ain]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 153 ---------------------------------------------
Creates a spring security filter chain. --> [[[FAILED]]]

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[set]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 154 ---------------------------------------------
Converts a jwt to a list of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[collected]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Generate a CSRF token. --> Delegates to the specified delegate. --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[delegate]] ( HttpServletRequest [[ray]] ) { return wrap ( [[ray]] , this . delegate . generateToken ( [[ray]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 156 ---------------------------------------------
Decodes and validates the given token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[instance]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 157 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 150 / 0 / 157:  16%|█▌        | 157/1000 [52:46<4:43:21, 20.17s/it][Succeeded / Failed / Skipped / Total] 7 / 150 / 0 / 157:  16%|█▌        | 158/1000 [52:56<4:42:05, 20.10s/it][Succeeded / Failed / Skipped / Total] 7 / 151 / 0 / 158:  16%|█▌        | 158/1000 [52:56<4:42:05, 20.10s/it][Succeeded / Failed / Skipped / Total] 7 / 151 / 0 / 158:  16%|█▌        | 159/1000 [52:57<4:40:07, 19.99s/it][Succeeded / Failed / Skipped / Total] 7 / 152 / 0 / 159:  16%|█▌        | 159/1000 [52:57<4:40:07, 19.99s/it][Succeeded / Failed / Skipped / Total] 7 / 152 / 0 / 159:  16%|█▌        | 160/1000 [53:13<4:39:25, 19.96s/it][Succeeded / Failed / Skipped / Total] 7 / 153 / 0 / 160:  16%|█▌        | 160/1000 [53:13<4:39:25, 19.96s/it][Succeeded / Failed / Skipped / Total] 7 / 153 / 0 / 160:  16%|█▌        | 161/1000 [53:32<4:39:03, 19.96s/it][Succeeded / Failed / Skipped / Total] 7 / 154 / 0 / 161:  16%|█▌        | 161/1000 [53:32<4:39:03, 19.96s/it][Succeeded / Failed / Skipped / Total] 7 / 154 / 0 / 161:  16%|█▌        | 162/1000 [53:44<4:37:57, 19.90s/it]Attempts to switch to the specified user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[user]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 158 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[access]] ( ) throws IOException { String [[address]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[address]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 159 ---------------------------------------------
Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] [[cookieTokens]] , HttpServletRequest request , HttpServletResponse response ) { if ( [[cookieTokens]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[cookieTokens]] ) + "'" ) ; } final String presentedSeries = [[cookieTokens]] [ 0 ] ; final String presentedToken = [[cookieTokens]] [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails processAutoLoginCookie ( String [ ] [[call]] , HttpServletRequest request , HttpServletResponse response ) { if ( [[call]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[call]] ) + "'" ) ; } final String presentedSeries = [[call]] [ 0 ] ; final String presentedToken = [[call]] [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 160 ---------------------------------------------
Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[handler]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[handler]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[handler]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[end]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[file]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[file]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[file]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 161 ---------------------------------------------
Display the admin page. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[end]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[group]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[group]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 162 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 155 / 0 / 162:  16%|█▌        | 162/1000 [53:44<4:37:57, 19.90s/it][Succeeded / Failed / Skipped / Total] 7 / 155 / 0 / 162:  16%|█▋        | 163/1000 [53:45<4:36:03, 19.79s/it][Succeeded / Failed / Skipped / Total] 7 / 156 / 0 / 163:  16%|█▋        | 163/1000 [53:45<4:36:03, 19.79s/it][Succeeded / Failed / Skipped / Total] 7 / 156 / 0 / 163:  16%|█▋        | 164/1000 [54:03<4:35:31, 19.77s/it][Succeeded / Failed / Skipped / Total] 7 / 157 / 0 / 164:  16%|█▋        | 164/1000 [54:03<4:35:31, 19.77s/it][Succeeded / Failed / Skipped / Total] 7 / 157 / 0 / 164:  16%|█▋        | 165/1000 [54:22<4:35:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 7 / 158 / 0 / 165:  16%|█▋        | 165/1000 [54:22<4:35:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 7 / 158 / 0 / 165:  17%|█▋        | 166/1000 [54:24<4:33:22, 19.67s/it][Succeeded / Failed / Skipped / Total] 7 / 159 / 0 / 166:  17%|█▋        | 166/1000 [54:24<4:33:22, 19.67s/it][Succeeded / Failed / Skipped / Total] 7 / 159 / 0 / 166:  17%|█▋        | 167/1000 [54:35<4:32:20, 19.62s/it][Succeeded / Failed / Skipped / Total] 7 / 160 / 0 / 167:  17%|█▋        | 167/1000 [54:35<4:32:20, 19.62s/it][Succeeded / Failed / Skipped / Total] 7 / 160 / 0 / 167:  17%|█▋        | 168/1000 [55:09<4:33:09, 19.70s/it]Creates an instance of UserDetailsResourceFactoryBean from the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[name]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 163 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[a]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 164 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission [[addPermission]] , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . [[addPermission]] ( [[addPermission]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[compare]] ( AddPermission [[event]] , BindingResult result , ModelMap model ) { addPermissionValidator . validate ( [[compare]] , result ) ; if ( result . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[compare]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[compare]] . getPermission ( ) ) ; try { contactManager . [[event]] ( [[compare]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 165 ---------------------------------------------
Returns the role with the given default prefix. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[end]] ( String [[actor]] , String [[script]] ) { if ( [[script]] == null ) { return [[script]] ; } if ( [[actor]] == null || [[actor]] . length ( ) == 0 ) { return [[script]] ; } if ( [[script]] . startsWith ( [[actor]] ) ) { return [[script]] ; } return [[actor]] + [[script]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 166 ---------------------------------------------
Decodes the given bytes into a string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[i]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[i]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 167 ---------------------------------------------
Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[by]] ( String [[arrays]] ) { List < String > [[foo]] = null ; if ( attributes != null ) { [[foo]] = attributes . get ( [[arrays]] ) ; } if ( [[foo]] == null ) { [[foo]] = Collections . emptyList ( ) ; } return [[foo]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 161 / 0 / 168:  17%|█▋        | 168/1000 [55:09<4:33:09, 19.70s/it][Succeeded / Failed / Skipped / Total] 7 / 161 / 0 / 168:  17%|█▋        | 169/1000 [55:25<4:32:30, 19.68s/it][Succeeded / Failed / Skipped / Total] 7 / 162 / 0 / 169:  17%|█▋        | 169/1000 [55:25<4:32:30, 19.68s/it][Succeeded / Failed / Skipped / Total] 7 / 162 / 0 / 169:  17%|█▋        | 170/1000 [55:45<4:32:15, 19.68s/it][Succeeded / Failed / Skipped / Total] 7 / 163 / 0 / 170:  17%|█▋        | 170/1000 [55:45<4:32:15, 19.68s/it][Succeeded / Failed / Skipped / Total] 7 / 163 / 0 / 170:  17%|█▋        | 171/1000 [55:48<4:30:35, 19.58s/it][Succeeded / Failed / Skipped / Total] 7 / 164 / 0 / 171:  17%|█▋        | 171/1000 [55:48<4:30:35, 19.58s/it][Succeeded / Failed / Skipped / Total] 7 / 164 / 0 / 171:  17%|█▋        | 172/1000 [55:52<4:28:57, 19.49s/it][Succeeded / Failed / Skipped / Total] 7 / 165 / 0 / 172:  17%|█▋        | 172/1000 [55:52<4:28:57, 19.49s/it][Succeeded / Failed / Skipped / Total] 7 / 165 / 0 / 172:  17%|█▋        | 173/1000 [56:14<4:28:49, 19.50s/it][Succeeded / Failed / Skipped / Total] 7 / 166 / 0 / 173:  17%|█▋        | 173/1000 [56:14<4:28:49, 19.50s/it][Succeeded / Failed / Skipped / Total] 7 / 166 / 0 / 173:  17%|█▋        | 174/1000 [57:07<4:31:10, 19.70s/it][Succeeded / Failed / Skipped / Total] 7 / 167 / 0 / 174:  17%|█▋        | 174/1000 [57:07<4:31:10, 19.70s/it][Succeeded / Failed / Skipped / Total] 7 / 167 / 0 / 174:  18%|█▊        | 175/1000 [57:14<4:29:52, 19.63s/it][Succeeded / Failed / Skipped / Total] 7 / 168 / 0 / 175:  18%|█▊        | 175/1000 [57:14<4:29:52, 19.63s/it][Succeeded / Failed / Skipped / Total] 7 / 168 / 0 / 175:  18%|█▊        | 176/1000 [57:26<4:28:56, 19.58s/it]Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[wrap]] ( CharSequence [[b]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[b]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 169 ---------------------------------------------
Returns the first attribute value for the supplied name. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[after]] ( String [[value]] ) { List < String > result = getAttributeValues ( [[value]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 170 ---------------------------------------------
Adds a secure method.@param method the method@param attr the attr --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( [[method]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[id]] ( RegisteredMethod [[mandatory]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[mandatory]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[mandatory]] + "] with attributes [" + attr + "]" ) ; } this . methodMap . put ( [[mandatory]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 171 ---------------------------------------------
Finds all attributes of the specified target class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method [[method]] , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[fix]] ( Method [[generic]] , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[generic]] , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 172 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[fix]] ( WebContact [[group]] , BindingResult result ) { validator . validate ( [[group]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[group]] . getName ( ) , [[group]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 173 ---------------------------------------------
Returns a set of all the configured attributes. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[allAttributes]] . addAll ( attributeList ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[client]] ( ) { Set < ConfigAttribute > [[a]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > attributeList : methodMap . values ( ) ) { [[a]] . addAll ( attributeList ) ; } return [[a]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 174 ---------------------------------------------
Removes all authentication attributes from the session. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest request ) { HttpSession session = request . getSession ( "[[False]]" != "[[False]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[end]] ( HttpServletRequest request ) { HttpSession session = request . getSession ( "[[download]]" != "[[download]]" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the method name matches the mapped name. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isMatch]] ( String methodName , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && methodName . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && methodName . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[test]] ( String methodName , String [[object]] ) { return ( [[object]] . endsWith ( "*" ) && methodName . startsWith ( [[object]] . substring ( 0 , [[object]] . length ( ) - 1 ) ) ) || ( [[object]] . startsWith ( "*" ) && methodName . endsWith ( [[object]] . substring ( 1 , [[object]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
[Succeeded / Failed / Skipped / Total] 7 / 169 / 0 / 176:  18%|█▊        | 176/1000 [57:26<4:28:56, 19.58s/it][Succeeded / Failed / Skipped / Total] 7 / 169 / 0 / 176:  18%|█▊        | 177/1000 [58:23<4:31:31, 19.80s/it][Succeeded / Failed / Skipped / Total] 7 / 170 / 0 / 177:  18%|█▊        | 177/1000 [58:23<4:31:31, 19.80s/it][Succeeded / Failed / Skipped / Total] 7 / 170 / 0 / 177:  18%|█▊        | 178/1000 [58:57<4:32:17, 19.88s/it][Succeeded / Failed / Skipped / Total] 7 / 171 / 0 / 178:  18%|█▊        | 178/1000 [58:57<4:32:17, 19.88s/it][Succeeded / Failed / Skipped / Total] 7 / 171 / 0 / 178:  18%|█▊        | 179/1000 [59:09<4:31:20, 19.83s/it][Succeeded / Failed / Skipped / Total] 7 / 172 / 0 / 179:  18%|█▊        | 179/1000 [59:09<4:31:20, 19.83s/it][Succeeded / Failed / Skipped / Total] 7 / 172 / 0 / 179:  18%|█▊        | 180/1000 [59:11<4:29:38, 19.73s/it][Succeeded / Failed / Skipped / Total] 7 / 173 / 0 / 180:  18%|█▊        | 180/1000 [59:11<4:29:38, 19.73s/it][Succeeded / Failed / Skipped / Total] 7 / 173 / 0 / 180:  18%|█▊        | 181/1000 [59:18<4:28:23, 19.66s/it][Succeeded / Failed / Skipped / Total] 7 / 174 / 0 / 181:  18%|█▊        | 181/1000 [59:18<4:28:23, 19.66s/it][Succeeded / Failed / Skipped / Total] 7 / 174 / 0 / 181:  18%|█▊        | 182/1000 [59:24<4:27:01, 19.59s/it][Succeeded / Failed / Skipped / Total] 8 / 174 / 0 / 182:  18%|█▊        | 182/1000 [59:24<4:27:01, 19.59s/it][Succeeded / Failed / Skipped / Total] 8 / 174 / 0 / 182:  18%|█▊        | 183/1000 [59:51<4:27:15, 19.63s/it]--------------------------------------------- Result 176 ---------------------------------------------
Handles a bind exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[main]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 177 ---------------------------------------------
Configures this request with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "True" == "True" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[dom]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C [[process]] = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "True" == "True" ; return [[process]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 178 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . serviceProperties . getServiceParameter ( ) , [[serviceUrl]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[end]] ( final String [[data]] ) { return CommonUtils . constructRedirectUrl ( this . [[what]] , this . serviceProperties . getServiceParameter ( ) , [[data]] , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 179 ---------------------------------------------
Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[sid]] , @ RequestParam ( "permission" ) int [[mask]] ) { Contact [[contact]] = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( [[sid]] ) ; Permission permission = permissionFactory . buildFromMask ( [[mask]] ) ; contactManager . deletePermission ( [[contact]] , sidObject , permission ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , [[contact]] ) ; [[model]] . put ( "sid" , sidObject ) ; [[model]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String [[filter]] , @ RequestParam ( "permission" ) int [[bernstein]] ) { Contact [[quest]] = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( [[filter]] ) ; Permission permission = permissionFactory . buildFromMask ( [[bernstein]] ) ; contactManager . deletePermission ( [[quest]] , sidObject , permission ) ; Map < String , Object > [[description]] = new HashMap <> ( ) ; [[description]] . put ( "contact" , [[quest]] ) ; [[description]] . put ( "sid" , sidObject ) ; [[description]] . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , [[description]] ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 180 ---------------------------------------------
Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[getRandomContact]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[getNumber]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[getNumber]] ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact [[filter]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[person]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[person]] ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 181 ---------------------------------------------
Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[test]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 182 ---------------------------------------------
Checks the filter stack. --> Main entry point. --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[main]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
[Succeeded / Failed / Skipped / Total] 8 / 175 / 0 / 183:  18%|█▊        | 183/1000 [59:51<4:27:15, 19.63s/it][Succeeded / Failed / Skipped / Total] 8 / 175 / 0 / 183:  18%|█▊        | 184/1000 [59:56<4:25:50, 19.55s/it][Succeeded / Failed / Skipped / Total] 8 / 176 / 0 / 184:  18%|█▊        | 184/1000 [59:56<4:25:50, 19.55s/it][Succeeded / Failed / Skipped / Total] 8 / 176 / 0 / 184:  18%|█▊        | 185/1000 [1:00:33<4:26:47, 19.64s/it][Succeeded / Failed / Skipped / Total] 9 / 176 / 0 / 185:  18%|█▊        | 185/1000 [1:00:33<4:26:47, 19.64s/it][Succeeded / Failed / Skipped / Total] 9 / 176 / 0 / 185:  19%|█▊        | 186/1000 [1:00:40<4:25:30, 19.57s/it][Succeeded / Failed / Skipped / Total] 9 / 177 / 0 / 186:  19%|█▊        | 186/1000 [1:00:40<4:25:30, 19.57s/it][Succeeded / Failed / Skipped / Total] 9 / 177 / 0 / 186:  19%|█▊        | 187/1000 [1:01:07<4:25:46, 19.61s/it][Succeeded / Failed / Skipped / Total] 9 / 178 / 0 / 187:  19%|█▊        | 187/1000 [1:01:07<4:25:46, 19.61s/it][Succeeded / Failed / Skipped / Total] 9 / 178 / 0 / 187:  19%|█▉        | 188/1000 [1:01:28<4:25:32, 19.62s/it][Succeeded / Failed / Skipped / Total] 9 / 179 / 0 / 188:  19%|█▉        | 188/1000 [1:01:28<4:25:32, 19.62s/it][Succeeded / Failed / Skipped / Total] 9 / 179 / 0 / 188:  19%|█▉        | 189/1000 [1:01:41<4:24:43, 19.59s/it][Succeeded / Failed / Skipped / Total] 9 / 180 / 0 / 189:  19%|█▉        | 189/1000 [1:01:41<4:24:43, 19.59s/it][Succeeded / Failed / Skipped / Total] 9 / 180 / 0 / 189:  19%|█▉        | 190/1000 [1:01:55<4:23:59, 19.56s/it]--------------------------------------------- Result 183 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> [[[FAILED]]]

[[[[Adv]]]]: private String extractPrefix ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[encPass]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String extractPrefix ( String [[end]] ) { if ( ! [[end]] . startsWith ( "{" ) ) { return null ; } int secondBrace = [[end]] . lastIndexOf ( ' ' ) ; if ( secondBrace < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[end]] . substring ( 0 , secondBrace + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 184 ---------------------------------------------
Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[string]] ( Class < ? > [[extension]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[extension]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[extension]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 185 ---------------------------------------------
Compares two byte arrays for equality. --> Checks if two byte arrays are the same length@param expected@param actual@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[matches]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean [[check]] ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 186 ---------------------------------------------
Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[query]] ( ) { Set < Class < ? extends Throwable > > typeList = this . extractorMap . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 187 ---------------------------------------------
Extracts the cause of the supplied throwable. --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[export]] ( Throwable [[ape]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[ape]] ) ) { ThrowableCauseExtractor extractor = entry . getValue ( ) ; return extractor . extractCause ( [[ape]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[assume]] ( String [[end]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[end]] ) , ( ) -> "'" + [[end]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[end]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 189 ---------------------------------------------
Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { set . add ( [[authority]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[include]] ( Collection < ? extends GrantedAuthority > [[type]] ) { Assert . notNull ( [[type]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[type]] . size ( ) ) ; for ( GrantedAuthority [[a]] : [[type]] ) { set . add ( [[a]] . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 181 / 0 / 190:  19%|█▉        | 190/1000 [1:01:55<4:23:59, 19.56s/it][Succeeded / Failed / Skipped / Total] 9 / 181 / 0 / 190:  19%|█▉        | 191/1000 [1:02:06<4:23:04, 19.51s/it][Succeeded / Failed / Skipped / Total] 9 / 182 / 0 / 191:  19%|█▉        | 191/1000 [1:02:06<4:23:04, 19.51s/it][Succeeded / Failed / Skipped / Total] 9 / 182 / 0 / 191:  19%|█▉        | 192/1000 [1:02:08<4:21:29, 19.42s/it][Succeeded / Failed / Skipped / Total] 9 / 183 / 0 / 192:  19%|█▉        | 192/1000 [1:02:08<4:21:29, 19.42s/it][Succeeded / Failed / Skipped / Total] 9 / 183 / 0 / 192:  19%|█▉        | 193/1000 [1:02:53<4:22:57, 19.55s/it][Succeeded / Failed / Skipped / Total] 9 / 184 / 0 / 193:  19%|█▉        | 193/1000 [1:02:53<4:22:57, 19.55s/it][Succeeded / Failed / Skipped / Total] 9 / 184 / 0 / 193:  19%|█▉        | 194/1000 [1:03:38<4:24:22, 19.68s/it][Succeeded / Failed / Skipped / Total] 9 / 185 / 0 / 194:  19%|█▉        | 194/1000 [1:03:38<4:24:22, 19.68s/it][Succeeded / Failed / Skipped / Total] 9 / 185 / 0 / 194:  20%|█▉        | 195/1000 [1:03:47<4:23:21, 19.63s/it][Succeeded / Failed / Skipped / Total] 9 / 186 / 0 / 195:  20%|█▉        | 195/1000 [1:03:47<4:23:21, 19.63s/it][Succeeded / Failed / Skipped / Total] 9 / 186 / 0 / 195:  20%|█▉        | 196/1000 [1:04:16<4:23:39, 19.68s/it]Performs a pre-authenticated login. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[id]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 191 ---------------------------------------------
Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 192 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[begin]] ( Function < HttpServletRequest , Map < String , String > > [[b]] ) { Assert . notNull ( [[b]] , "resolveHiddenInputs cannot be null" ) ; this . resolveHiddenInputs = [[b]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 193 ---------------------------------------------
Creates a list of OpenID attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[mark]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 194 ---------------------------------------------
Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[draw]] ( String [[a]] ) { if ( [[a]] == null ) { return "False" != "False" ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[a]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 195 ---------------------------------------------
Converts the given identifier into an object of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[access]] ( Serializable [[attribute]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[attribute]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[attribute]] = convertFromStringTo ( ( String ) [[attribute]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 196 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 187 / 0 / 196:  20%|█▉        | 196/1000 [1:04:16<4:23:39, 19.68s/it][Succeeded / Failed / Skipped / Total] 9 / 187 / 0 / 196:  20%|█▉        | 197/1000 [1:04:26<4:22:38, 19.62s/it][Succeeded / Failed / Skipped / Total] 9 / 188 / 0 / 197:  20%|█▉        | 197/1000 [1:04:26<4:22:38, 19.62s/it][Succeeded / Failed / Skipped / Total] 9 / 188 / 0 / 197:  20%|█▉        | 198/1000 [1:04:43<4:22:10, 19.61s/it][Succeeded / Failed / Skipped / Total] 10 / 188 / 0 / 198:  20%|█▉        | 198/1000 [1:04:43<4:22:10, 19.61s/it][Succeeded / Failed / Skipped / Total] 10 / 188 / 0 / 198:  20%|█▉        | 199/1000 [1:04:45<4:20:40, 19.53s/it][Succeeded / Failed / Skipped / Total] 10 / 189 / 0 / 199:  20%|█▉        | 199/1000 [1:04:45<4:20:40, 19.53s/it][Succeeded / Failed / Skipped / Total] 10 / 189 / 0 / 199:  20%|██        | 200/1000 [1:05:07<4:20:28, 19.54s/it]Creates the list of entries for the given acl. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl [[acl]] ) { if ( [[acl]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[acl]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[acl]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[acl]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[execute]] ( final MutableAcl [[access]] ) { if ( [[access]] . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return [[access]] . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = [[access]] . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) [[access]] . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 197 ---------------------------------------------
Creates a new object identity. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long [[sidId]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[sidId]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[end]] ( ObjectIdentity object , Sid owner ) { Long [[enter]] = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[enter]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 198 ---------------------------------------------
Returns a matcher that matches any exchange. --> Creates and returns a new WebExchangeMatcher. --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[b]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 199 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 200 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 190 / 0 / 200:  20%|██        | 200/1000 [1:05:07<4:20:28, 19.54s/it][Succeeded / Failed / Skipped / Total] 10 / 190 / 0 / 200:  20%|██        | 201/1000 [1:05:50<4:21:42, 19.65s/it][Succeeded / Failed / Skipped / Total] 10 / 191 / 0 / 201:  20%|██        | 201/1000 [1:05:50<4:21:42, 19.65s/it][Succeeded / Failed / Skipped / Total] 10 / 191 / 0 / 201:  20%|██        | 202/1000 [1:05:50<4:20:07, 19.56s/it][Succeeded / Failed / Skipped / Total] 10 / 192 / 0 / 202:  20%|██        | 202/1000 [1:05:50<4:20:07, 19.56s/it][Succeeded / Failed / Skipped / Total] 10 / 192 / 0 / 202:  20%|██        | 203/1000 [1:05:53<4:18:40, 19.47s/it][Succeeded / Failed / Skipped / Total] 10 / 193 / 0 / 203:  20%|██        | 203/1000 [1:05:53<4:18:40, 19.47s/it][Succeeded / Failed / Skipped / Total] 10 / 193 / 0 / 203:  20%|██        | 204/1000 [1:06:06<4:17:55, 19.44s/it][Succeeded / Failed / Skipped / Total] 10 / 194 / 0 / 204:  20%|██        | 204/1000 [1:06:06<4:17:55, 19.44s/it][Succeeded / Failed / Skipped / Total] 10 / 194 / 0 / 204:  20%|██        | 205/1000 [1:06:19<4:17:11, 19.41s/it][Succeeded / Failed / Skipped / Total] 11 / 194 / 0 / 205:  20%|██        | 205/1000 [1:06:19<4:17:11, 19.41s/it][Succeeded / Failed / Skipped / Total] 11 / 194 / 0 / 205:  21%|██        | 206/1000 [1:06:38<4:16:52, 19.41s/it][Succeeded / Failed / Skipped / Total] 11 / 195 / 0 / 206:  21%|██        | 206/1000 [1:06:38<4:16:52, 19.41s/it][Succeeded / Failed / Skipped / Total] 11 / 195 / 0 / 206:  21%|██        | 207/1000 [1:06:39<4:15:19, 19.32s/it]Updates the object identity.@param acl the object identity --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[index]] ( MutableAcl [[image]] ) { Long parentId = null ; if ( [[image]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[image]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[image]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[image]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[image]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[index]] , parentId , ownerSid , Boolean . valueOf ( [[image]] . isEntriesInheriting ( ) ) , [[image]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 201 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[format]] ( CharSequence [[ml]] , CharSequence [[id]] ) { return new HexEncodingTextEncryptor ( standard ( [[ml]] , [[id]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 202 ---------------------------------------------
Saves the current request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[remove]] ( HttpServletRequest [[select]] , HttpServletResponse [[support]] ) { if ( requestMatcher . matches ( [[select]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[select]] , portResolver ) ; if ( createSessionAllowed || [[select]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 203 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[g]] ( CharSequence password , CharSequence [[name]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[name]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 204 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[a]] ( CharSequence [[root]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( [[root]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 205 ---------------------------------------------
Determines the target URL for this request. --> Creates an i18n message. --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[i]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { return [[i]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 206 ---------------------------------------------
Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[fix]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 207 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 196 / 0 / 207:  21%|██        | 207/1000 [1:06:39<4:15:19, 19.32s/it][Succeeded / Failed / Skipped / Total] 11 / 197 / 0 / 208:  21%|██        | 208/1000 [1:06:39<4:13:47, 19.23s/it][Succeeded / Failed / Skipped / Total] 11 / 197 / 0 / 208:  21%|██        | 209/1000 [1:07:12<4:14:22, 19.29s/it][Succeeded / Failed / Skipped / Total] 11 / 198 / 0 / 209:  21%|██        | 209/1000 [1:07:12<4:14:22, 19.29s/it][Succeeded / Failed / Skipped / Total] 11 / 198 / 0 / 209:  21%|██        | 210/1000 [1:07:20<4:13:20, 19.24s/it][Succeeded / Failed / Skipped / Total] 11 / 199 / 0 / 210:  21%|██        | 210/1000 [1:07:20<4:13:20, 19.24s/it][Succeeded / Failed / Skipped / Total] 11 / 199 / 0 / 210:  21%|██        | 211/1000 [1:07:21<4:11:52, 19.15s/it][Succeeded / Failed / Skipped / Total] 11 / 200 / 0 / 211:  21%|██        | 211/1000 [1:07:21<4:11:52, 19.15s/it][Succeeded / Failed / Skipped / Total] 11 / 200 / 0 / 211:  21%|██        | 212/1000 [1:07:21<4:10:22, 19.06s/it][Succeeded / Failed / Skipped / Total] 11 / 201 / 0 / 212:  21%|██        | 212/1000 [1:07:21<4:10:22, 19.06s/it][Succeeded / Failed / Skipped / Total] 11 / 201 / 0 / 212:  21%|██▏       | 213/1000 [1:08:14<4:12:10, 19.23s/it]Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[at]] ( HttpMethod [[ze]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String pattern : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( pattern , [[ze]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 208 ---------------------------------------------
Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { url . append ( [[servletPath]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[query]] ( String [[data]] , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[data]] != null ) { url . append ( [[data]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 209 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> [[[FAILED]]]

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[a]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[a]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 210 ---------------------------------------------
Determines the target URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[end]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 211 ---------------------------------------------
Writes the headers to the response. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[suppose]] ( HttpServletRequest request , HttpServletResponse [[call]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[call]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[call]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[call]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[call]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[call]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 212 ---------------------------------------------
Gets the current date. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[after]] ( ) { long [[queue]] = System . currentTimeMillis ( ) ; if ( ( [[queue]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[queue]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[queue]] ; currentDate = format . format ( new Date ( [[queue]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 213 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 201 / 0 / 213:  21%|██▏       | 213/1000 [1:08:14<4:12:10, 19.23s/it][Succeeded / Failed / Skipped / Total] 12 / 201 / 0 / 213:  21%|██▏       | 214/1000 [1:08:30<4:11:37, 19.21s/it][Succeeded / Failed / Skipped / Total] 12 / 202 / 0 / 214:  21%|██▏       | 214/1000 [1:08:30<4:11:37, 19.21s/it][Succeeded / Failed / Skipped / Total] 12 / 202 / 0 / 214:  22%|██▏       | 215/1000 [1:08:51<4:11:25, 19.22s/it][Succeeded / Failed / Skipped / Total] 12 / 203 / 0 / 215:  22%|██▏       | 215/1000 [1:08:51<4:11:25, 19.22s/it][Succeeded / Failed / Skipped / Total] 12 / 203 / 0 / 215:  22%|██▏       | 216/1000 [1:08:58<4:10:22, 19.16s/it][Succeeded / Failed / Skipped / Total] 12 / 204 / 0 / 216:  22%|██▏       | 216/1000 [1:08:58<4:10:22, 19.16s/it][Succeeded / Failed / Skipped / Total] 12 / 204 / 0 / 216:  22%|██▏       | 217/1000 [1:09:12<4:09:44, 19.14s/it][Succeeded / Failed / Skipped / Total] 12 / 205 / 0 / 217:  22%|██▏       | 217/1000 [1:09:12<4:09:44, 19.14s/it][Succeeded / Failed / Skipped / Total] 12 / 205 / 0 / 217:  22%|██▏       | 218/1000 [1:09:14<4:08:24, 19.06s/it][Succeeded / Failed / Skipped / Total] 12 / 206 / 0 / 218:  22%|██▏       | 218/1000 [1:09:14<4:08:24, 19.06s/it][Succeeded / Failed / Skipped / Total] 12 / 206 / 0 / 218:  22%|██▏       | 219/1000 [1:09:34<4:08:06, 19.06s/it][Succeeded / Failed / Skipped / Total] 12 / 207 / 0 / 219:  22%|██▏       | 219/1000 [1:09:34<4:08:06, 19.06s/it][Succeeded / Failed / Skipped / Total] 12 / 207 / 0 / 219:  22%|██▏       | 220/1000 [1:09:37<4:06:49, 18.99s/it]Creates a shared object map. --> Convenience method to join two configurations. --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[join]] ( ) { Map < Class < ? extends Object > , Object > [[name]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[name]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[name]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[name]] . put ( ApplicationContext . class , context ) ; [[name]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[name]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[name]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 214 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[access]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[task]] ) { [[task]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 215 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[unless]] ( final Subject [[data]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[data]] ) ; } String [[object]] = null ; if ( [[data]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 216 ---------------------------------------------
Updates the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap cache , Object [[key]] , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( [[key]] , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[when]] ( HashMap cache , Object [[resource]] , Object value ) { if ( value == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( [[resource]] , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 217 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> [[[FAILED]]]

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long [[id]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[id]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[profile]] ( final Long [[directory]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[directory]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 218 ---------------------------------------------
Configures the jaas using the supplied login configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[main]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 219 ---------------------------------------------
Parse a date from a string. --> [[[FAILED]]]

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[constant]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
[Succeeded / Failed / Skipped / Total] 12 / 208 / 0 / 220:  22%|██▏       | 220/1000 [1:09:37<4:06:49, 18.99s/it][Succeeded / Failed / Skipped / Total] 12 / 208 / 0 / 220:  22%|██▏       | 221/1000 [1:09:40<4:05:34, 18.91s/it][Succeeded / Failed / Skipped / Total] 12 / 209 / 0 / 221:  22%|██▏       | 221/1000 [1:09:40<4:05:34, 18.91s/it][Succeeded / Failed / Skipped / Total] 12 / 209 / 0 / 221:  22%|██▏       | 222/1000 [1:10:22<4:06:38, 19.02s/it][Succeeded / Failed / Skipped / Total] 12 / 210 / 0 / 222:  22%|██▏       | 222/1000 [1:10:22<4:06:38, 19.02s/it][Succeeded / Failed / Skipped / Total] 12 / 210 / 0 / 222:  22%|██▏       | 223/1000 [1:10:29<4:05:37, 18.97s/it][Succeeded / Failed / Skipped / Total] 12 / 211 / 0 / 223:  22%|██▏       | 223/1000 [1:10:29<4:05:37, 18.97s/it][Succeeded / Failed / Skipped / Total] 12 / 211 / 0 / 223:  22%|██▏       | 224/1000 [1:10:29<4:04:13, 18.88s/it][Succeeded / Failed / Skipped / Total] 12 / 212 / 0 / 224:  22%|██▏       | 224/1000 [1:10:29<4:04:13, 18.88s/it][Succeeded / Failed / Skipped / Total] 12 / 212 / 0 / 224:  22%|██▎       | 225/1000 [1:10:30<4:02:52, 18.80s/it][Succeeded / Failed / Skipped / Total] 12 / 213 / 0 / 225:  22%|██▎       | 225/1000 [1:10:30<4:02:52, 18.80s/it][Succeeded / Failed / Skipped / Total] 12 / 213 / 0 / 225:  23%|██▎       | 226/1000 [1:10:55<4:02:54, 18.83s/it][Succeeded / Failed / Skipped / Total] 12 / 214 / 0 / 226:  23%|██▎       | 226/1000 [1:10:55<4:02:54, 18.83s/it][Succeeded / Failed / Skipped / Total] 12 / 214 / 0 / 226:  23%|██▎       | 227/1000 [1:11:24<4:03:11, 18.88s/it][Succeeded / Failed / Skipped / Total] 12 / 215 / 0 / 227:  23%|██▎       | 227/1000 [1:11:24<4:03:11, 18.88s/it][Succeeded / Failed / Skipped / Total] 12 / 215 / 0 / 227:  23%|██▎       | 228/1000 [1:11:30<4:02:07, 18.82s/it]--------------------------------------------- Result 220 ---------------------------------------------
Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[value]] ) { Context [[error]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 221 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[index]] ( String [[array]] ) { DistinguishedName [[a]] = new DistinguishedName ( groupSearchBase ) ; [[a]] . add ( groupRoleAttributeName , [[array]] . toLowerCase ( ) ) ; return [[a]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 222 ---------------------------------------------
Retrieves the filters for the specified URL. --> [[[FAILED]]]

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String [[url]] ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[sample]] ( String [[sampling]] ) { return [[sample]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[sampling]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 223 ---------------------------------------------
Copies details from source to dest. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[main]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 224 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[test]] ( PageContext [[i]] ) { ServletContext servletContext = [[i]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 225 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[domain]] ( HttpServletRequest [[rate]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[rate]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 226 ---------------------------------------------
Change the user's password.@param oldPassword the old password@param newPassword the new password --> [[[FAILED]]]

[[[[Adv]]]]: public void [[changePassword]] ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[echo]] ( final String oldPassword , final String newPassword ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , oldPassword , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , oldPassword , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 227 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[machine]] ( Map < String , Object > sessionAttributes ) { notNull ( sessionAttributes , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , sessionAttributes , this . [[hello]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 12 / 216 / 0 / 228:  23%|██▎       | 228/1000 [1:11:30<4:02:07, 18.82s/it][Succeeded / Failed / Skipped / Total] 12 / 216 / 0 / 228:  23%|██▎       | 229/1000 [1:11:36<4:01:04, 18.76s/it][Succeeded / Failed / Skipped / Total] 12 / 217 / 0 / 229:  23%|██▎       | 229/1000 [1:11:36<4:01:04, 18.76s/it][Succeeded / Failed / Skipped / Total] 12 / 217 / 0 / 229:  23%|██▎       | 230/1000 [1:11:45<4:00:13, 18.72s/it][Succeeded / Failed / Skipped / Total] 12 / 218 / 0 / 230:  23%|██▎       | 230/1000 [1:11:45<4:00:13, 18.72s/it][Succeeded / Failed / Skipped / Total] 12 / 218 / 0 / 230:  23%|██▎       | 231/1000 [1:12:10<4:00:15, 18.75s/it][Succeeded / Failed / Skipped / Total] 12 / 219 / 0 / 231:  23%|██▎       | 231/1000 [1:12:10<4:00:15, 18.75s/it][Succeeded / Failed / Skipped / Total] 12 / 219 / 0 / 231:  23%|██▎       | 232/1000 [1:12:11<3:58:57, 18.67s/it][Succeeded / Failed / Skipped / Total] 12 / 220 / 0 / 232:  23%|██▎       | 232/1000 [1:12:11<3:58:57, 18.67s/it][Succeeded / Failed / Skipped / Total] 12 / 220 / 0 / 232:  23%|██▎       | 233/1000 [1:12:23<3:58:16, 18.64s/it][Succeeded / Failed / Skipped / Total] 12 / 221 / 0 / 233:  23%|██▎       | 233/1000 [1:12:23<3:58:16, 18.64s/it][Succeeded / Failed / Skipped / Total] 12 / 221 / 0 / 233:  23%|██▎       | 234/1000 [1:12:36<3:57:39, 18.62s/it][Succeeded / Failed / Skipped / Total] 13 / 221 / 0 / 234:  23%|██▎       | 234/1000 [1:12:36<3:57:39, 18.62s/it][Succeeded / Failed / Skipped / Total] 13 / 221 / 0 / 234:  24%|██▎       | 235/1000 [1:12:49<3:57:03, 18.59s/it]Throws an exception if maximum allowable sessions are exceeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > [[sessions]] , int [[allowableSessions]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[s]] ( List < SessionInformation > [[name]] , int [[id]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[name]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[id]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 229 ---------------------------------------------
Add a list of filters.@param filters the list of filters --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[support]] ( List < Filter > [[null]] ) { Validate . notNull ( [[support]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[support]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Adds additional filters to the provided filter.@param filter The filter to add.@param additionalFilters Additional filters to add. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[load]] ( Filter [[files]] , Filter ... [[files]] ) { Validate . notNull ( [[files]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[files]] ) ; if ( [[files]] != null ) { Collections . addAll ( RestAssured . filters , [[files]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 231 ---------------------------------------------
Creates a proxy for the specified URI. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[proxy]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[http]] ( URI uri ) { if ( uri == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[http]] ( new ProxySpecification ( uri . getHost ( ) , uri . getPort ( ) , uri . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 232 ---------------------------------------------
Returns the full distinguished name for the given distinguished name. --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[format]] ( DistinguishedName [[file]] , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( [[file]] . contains ( baseDn ) ) { return [[file]] ; } baseDn . append ( [[file]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 233 ---------------------------------------------
Creates a new authentication scheme for the given user name and password. --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[userName]] ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[of]] ( String [[password]] , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[password]] ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 234 ---------------------------------------------
Sets the default character set for the encoder. --> Creates a new encoder configuration. --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[c]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 235 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 14 / 221 / 0 / 235:  24%|██▎       | 235/1000 [1:12:49<3:57:03, 18.59s/it][Succeeded / Failed / Skipped / Total] 14 / 221 / 0 / 235:  24%|██▎       | 236/1000 [1:12:49<3:55:44, 18.51s/it][Succeeded / Failed / Skipped / Total] 14 / 222 / 0 / 236:  24%|██▎       | 236/1000 [1:12:49<3:55:44, 18.51s/it][Succeeded / Failed / Skipped / Total] 14 / 222 / 0 / 236:  24%|██▎       | 237/1000 [1:13:02<3:55:10, 18.49s/it][Succeeded / Failed / Skipped / Total] 14 / 223 / 0 / 237:  24%|██▎       | 237/1000 [1:13:02<3:55:10, 18.49s/it][Succeeded / Failed / Skipped / Total] 14 / 223 / 0 / 237:  24%|██▍       | 238/1000 [1:13:39<3:55:49, 18.57s/it][Succeeded / Failed / Skipped / Total] 14 / 224 / 0 / 238:  24%|██▍       | 238/1000 [1:13:39<3:55:49, 18.57s/it][Succeeded / Failed / Skipped / Total] 14 / 224 / 0 / 238:  24%|██▍       | 239/1000 [1:14:00<3:55:40, 18.58s/it][Succeeded / Failed / Skipped / Total] 14 / 225 / 0 / 239:  24%|██▍       | 239/1000 [1:14:00<3:55:40, 18.58s/it][Succeeded / Failed / Skipped / Total] 14 / 225 / 0 / 239:  24%|██▍       | 240/1000 [1:14:08<3:54:47, 18.54s/it]Prints the response.@param responseOptions the response options@param responseBody the response body@param responseDetail the response details@param logDetail the log details@param shouldPrettyPrint the should pretty print@return the string --> Creates a string representation of a binding. --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[binding]] ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 236 ---------------------------------------------
Creates a basic authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String password ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[filter]] ( String userName , String password ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 237 ---------------------------------------------
Configures this RestAssuredConfig with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[archive]] ( RedirectConfig [[explorer]] ) { notNull ( [[explorer]] , "Redirect config" ) ; return new RestAssuredConfig ( [[explorer]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 238 ---------------------------------------------
Configures the default object mapper for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[application]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[application]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 239 ---------------------------------------------
Creates and returns a mock RESTAssuredMockMvcConfig for the specified configuration.@param logConfig the configuration to log@return a mock RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[code]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 240 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 14 / 226 / 0 / 240:  24%|██▍       | 240/1000 [1:14:08<3:54:47, 18.54s/it][Succeeded / Failed / Skipped / Total] 14 / 227 / 0 / 241:  24%|██▍       | 241/1000 [1:14:08<3:53:30, 18.46s/it][Succeeded / Failed / Skipped / Total] 14 / 227 / 0 / 241:  24%|██▍       | 242/1000 [1:14:09<3:52:16, 18.39s/it][Succeeded / Failed / Skipped / Total] 14 / 227 / 1 / 242:  24%|██▍       | 242/1000 [1:14:09<3:52:16, 18.39s/it][Succeeded / Failed / Skipped / Total] 14 / 227 / 2 / 243:  24%|██▍       | 243/1000 [1:14:09<3:51:01, 18.31s/it][Succeeded / Failed / Skipped / Total] 14 / 227 / 2 / 243:  24%|██▍       | 244/1000 [1:14:13<3:49:59, 18.25s/it][Succeeded / Failed / Skipped / Total] 14 / 228 / 2 / 244:  24%|██▍       | 244/1000 [1:14:13<3:49:59, 18.25s/it][Succeeded / Failed / Skipped / Total] 14 / 229 / 2 / 245:  24%|██▍       | 245/1000 [1:14:20<3:49:05, 18.21s/it][Succeeded / Failed / Skipped / Total] 14 / 229 / 2 / 245:  25%|██▍       | 246/1000 [1:14:21<3:47:54, 18.14s/it][Succeeded / Failed / Skipped / Total] 14 / 229 / 3 / 246:  25%|██▍       | 246/1000 [1:14:21<3:47:54, 18.14s/it][Succeeded / Failed / Skipped / Total] 14 / 229 / 4 / 247:  25%|██▍       | 247/1000 [1:14:22<3:46:43, 18.07s/it][Succeeded / Failed / Skipped / Total] 14 / 229 / 4 / 247:  25%|██▍       | 248/1000 [1:14:37<3:46:15, 18.05s/it][Succeeded / Failed / Skipped / Total] 15 / 229 / 4 / 248:  25%|██▍       | 248/1000 [1:14:37<3:46:15, 18.05s/it][Succeeded / Failed / Skipped / Total] 15 / 229 / 4 / 248:  25%|██▍       | 249/1000 [1:14:54<3:45:56, 18.05s/it]Configures this mock mvc with the specified session config.@param sessionConfig the session config@return the configured mock mvc --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[sessionConfig]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig sessionConfig ( SessionConfig [[log]] ) { notNull ( sessionConfig , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 241 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setConfig ( config ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[using]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[path]] = new FormAuthScheme ( ) ; [[path]] . setUserName ( userName ) ; [[path]] . setPassword ( password ) ; [[path]] . setConfig ( config ) ; return [[path]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 242 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 243 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object.@param headerConfig a {@link HeaderConfig} object.@return a {@link RestAssuredMockMvcConfig} object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 244 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[method]] ( ObjectMapperConfig [[description]] ) { notNull ( [[method]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[method]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 245 ---------------------------------------------
Creates a new JAXB ObjectMapperConfig instance. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[using]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[using]] , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 246 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 247 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Configures the mock mvc config.@param mockMvcConfig the mock mvc config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object. --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mockMvcConfig]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[mockMvcConfig]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[mockMvcConfig]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[bus]] ( MockMvcConfig mockMvcConfig ) { notNull ( [[bus]] , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , [[bus]] , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 249 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 229 / 4 / 249:  25%|██▍       | 249/1000 [1:14:54<3:45:56, 18.05s/it][Succeeded / Failed / Skipped / Total] 16 / 229 / 4 / 249:  25%|██▌       | 250/1000 [1:14:56<3:44:49, 17.99s/it][Succeeded / Failed / Skipped / Total] 16 / 230 / 4 / 250:  25%|██▌       | 250/1000 [1:14:56<3:44:49, 17.99s/it][Succeeded / Failed / Skipped / Total] 16 / 230 / 4 / 250:  25%|██▌       | 251/1000 [1:14:57<3:43:40, 17.92s/it][Succeeded / Failed / Skipped / Total] 16 / 231 / 4 / 251:  25%|██▌       | 251/1000 [1:14:57<3:43:40, 17.92s/it][Succeeded / Failed / Skipped / Total] 16 / 231 / 4 / 251:  25%|██▌       | 252/1000 [1:14:58<3:42:32, 17.85s/it][Succeeded / Failed / Skipped / Total] 17 / 231 / 4 / 252:  25%|██▌       | 252/1000 [1:14:58<3:42:32, 17.85s/it][Succeeded / Failed / Skipped / Total] 17 / 231 / 4 / 252:  25%|██▌       | 253/1000 [1:15:10<3:41:58, 17.83s/it][Succeeded / Failed / Skipped / Total] 17 / 232 / 4 / 253:  25%|██▌       | 253/1000 [1:15:10<3:41:58, 17.83s/it][Succeeded / Failed / Skipped / Total] 17 / 232 / 4 / 253:  25%|██▌       | 254/1000 [1:15:22<3:41:22, 17.80s/it][Succeeded / Failed / Skipped / Total] 17 / 233 / 4 / 254:  25%|██▌       | 254/1000 [1:15:22<3:41:22, 17.80s/it][Succeeded / Failed / Skipped / Total] 17 / 233 / 4 / 254:  26%|██▌       | 255/1000 [1:15:41<3:41:09, 17.81s/it][Succeeded / Failed / Skipped / Total] 17 / 234 / 4 / 255:  26%|██▌       | 255/1000 [1:15:41<3:41:09, 17.81s/it][Succeeded / Failed / Skipped / Total] 17 / 234 / 4 / 255:  26%|██▌       | 256/1000 [1:16:10<3:41:21, 17.85s/it][Succeeded / Failed / Skipped / Total] 17 / 235 / 4 / 256:  26%|██▌       | 256/1000 [1:16:10<3:41:21, 17.85s/it][Succeeded / Failed / Skipped / Total] 17 / 235 / 4 / 256:  26%|██▌       | 257/1000 [1:17:02<3:42:44, 17.99s/it]Configures a multi part mock mvc config.@param multiPartConfig the multi part config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object. --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[daemon]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 250 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String [[password]] , String [[workstation]] , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( [[userName]] ) ; scheme . setPassword ( [[password]] ) ; scheme . setWorkstation ( [[workstation]] ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[iii]] ( String [[object]] , String [[array]] , String [[attribute]] , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( [[object]] ) ; scheme . setPassword ( [[array]] ) ; scheme . setWorkstation ( [[attribute]] ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 251 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[file]] ( JsonConfig [[container]] ) { notNull ( [[file]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[file]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 252 ---------------------------------------------
Creates and configures an instance of RestAssuredMockMvcConfig.@param asyncConfig the async configuration@return the configured instance --> Creates and configures an instance of RestAssuredMockMvcConfig.@param call a {@link RestAssuredMockMvcConfig} instance@return a {@link RestAssuredMockMvcConfig} instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[call]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 253 ---------------------------------------------
Allow all hostnames in the given configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[client]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 254 ---------------------------------------------
Configures RESTAssuredMockMvcConfig.@param xmlConfig the xml config@return the configured RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[queue]] ( XmlConfig [[only]] ) { notNull ( [[queue]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[queue]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 255 ---------------------------------------------
Declares the specified namespaces. --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[manager]] ( Map < String , String > [[list]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[list]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 256 ---------------------------------------------
Sets the default request headers. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[main]] ( Map < ? , ? > [[function]] ) { this . [[are]] . clear ( ) ; if ( [[function]] == null ) return ; for ( Object key : [[function]] . keySet ( ) ) { Object val = [[function]] . get ( key ) ; if ( val == null ) continue ; this . [[are]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
[Succeeded / Failed / Skipped / Total] 17 / 236 / 4 / 257:  26%|██▌       | 257/1000 [1:17:02<3:42:44, 17.99s/it][Succeeded / Failed / Skipped / Total] 17 / 236 / 4 / 257:  26%|██▌       | 258/1000 [1:18:04<3:44:32, 18.16s/it][Succeeded / Failed / Skipped / Total] 17 / 237 / 4 / 258:  26%|██▌       | 258/1000 [1:18:04<3:44:32, 18.16s/it][Succeeded / Failed / Skipped / Total] 17 / 237 / 4 / 258:  26%|██▌       | 259/1000 [1:18:04<3:43:22, 18.09s/it][Succeeded / Failed / Skipped / Total] 17 / 238 / 4 / 259:  26%|██▌       | 259/1000 [1:18:04<3:43:22, 18.09s/it][Succeeded / Failed / Skipped / Total] 17 / 238 / 4 / 259:  26%|██▌       | 260/1000 [1:18:19<3:42:56, 18.08s/it][Succeeded / Failed / Skipped / Total] 17 / 239 / 4 / 260:  26%|██▌       | 260/1000 [1:18:19<3:42:56, 18.08s/it][Succeeded / Failed / Skipped / Total] 17 / 239 / 4 / 260:  26%|██▌       | 261/1000 [1:18:31<3:42:19, 18.05s/it][Succeeded / Failed / Skipped / Total] 18 / 239 / 4 / 261:  26%|██▌       | 261/1000 [1:18:31<3:42:19, 18.05s/it][Succeeded / Failed / Skipped / Total] 18 / 239 / 4 / 261:  26%|██▌       | 262/1000 [1:18:33<3:41:18, 17.99s/it][Succeeded / Failed / Skipped / Total] 19 / 239 / 4 / 262:  26%|██▌       | 262/1000 [1:18:33<3:41:18, 17.99s/it][Succeeded / Failed / Skipped / Total] 19 / 239 / 4 / 262:  26%|██▋       | 263/1000 [1:19:01<3:41:26, 18.03s/it][Succeeded / Failed / Skipped / Total] 19 / 240 / 4 / 263:  26%|██▋       | 263/1000 [1:19:01<3:41:26, 18.03s/it][Succeeded / Failed / Skipped / Total] 19 / 240 / 4 / 263:  26%|██▋       | 264/1000 [1:19:15<3:40:57, 18.01s/it]--------------------------------------------- Result 257 ---------------------------------------------
Sets the proxy for the specified host and port. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[fix]] ( String [[index]] , int port , String scheme ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[index]] , port , scheme ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 258 ---------------------------------------------
Sets the control name.@param controlName The name of the control.@return This builder instance. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String controlName ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[ty]] ( String controlName ) { Validate . notEmpty ( [[ty]] , "Control name cannot be empty" ) ; this . [[tab]] = [[ty]] ; this . isControlNameExplicit = "True" == "True" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 259 ---------------------------------------------
Performs basic authentication. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int [[port]] , String user , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , [[port]] ) , new UsernamePasswordCredentials ( user , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[test]] ( String [[method]] , int [[function]] , String user , String [[operator]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[method]] , [[function]] ) , new UsernamePasswordCredentials ( user , [[operator]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 260 ---------------------------------------------
Resets the internal state. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[mask]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 261 ---------------------------------------------
Sets the specified header value.@param name the header name@param value the header value@return this response builder --> Sets the content type of the response. --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[bus]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 262 ---------------------------------------------
Specifies the name and value of the header associated with this multipart. --> Specifies the name and format of the line@param name The name of the line@param format The format of the line@return The builder instance --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[line]] ( String name , String [[format]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[format]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 263 ---------------------------------------------
Creates and returns a copy of this XMLPathConfig object with the specified prefix and namespace URI.@param prefix the prefix of the XMLPathConfig object@param namespaceURI the namespace URI of the XMLPathConfig object@return a copy of this XMLPathConfig object --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String [[namespaceURI]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( prefix , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String [[header]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[header]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[size]] = new HashMap < String , String > ( declaredNamespaces ) ; [[size]] . put ( prefix , [[header]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[size]] , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 264 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 240 / 4 / 264:  26%|██▋       | 264/1000 [1:19:15<3:40:57, 18.01s/it][Succeeded / Failed / Skipped / Total] 20 / 240 / 4 / 264:  26%|██▋       | 265/1000 [1:19:25<3:40:18, 17.98s/it][Succeeded / Failed / Skipped / Total] 20 / 241 / 4 / 265:  26%|██▋       | 265/1000 [1:19:25<3:40:18, 17.98s/it][Succeeded / Failed / Skipped / Total] 20 / 241 / 4 / 265:  27%|██▋       | 266/1000 [1:19:30<3:39:22, 17.93s/it][Succeeded / Failed / Skipped / Total] 20 / 242 / 4 / 266:  27%|██▋       | 266/1000 [1:19:30<3:39:22, 17.93s/it][Succeeded / Failed / Skipped / Total] 20 / 242 / 4 / 266:  27%|██▋       | 267/1000 [1:19:46<3:39:01, 17.93s/it][Succeeded / Failed / Skipped / Total] 20 / 243 / 4 / 267:  27%|██▋       | 267/1000 [1:19:46<3:39:01, 17.93s/it][Succeeded / Failed / Skipped / Total] 20 / 243 / 4 / 267:  27%|██▋       | 268/1000 [1:19:51<3:38:06, 17.88s/it][Succeeded / Failed / Skipped / Total] 20 / 244 / 4 / 268:  27%|██▋       | 268/1000 [1:19:51<3:38:06, 17.88s/it][Succeeded / Failed / Skipped / Total] 20 / 244 / 4 / 268:  27%|██▋       | 269/1000 [1:20:18<3:38:15, 17.91s/it][Succeeded / Failed / Skipped / Total] 20 / 245 / 4 / 269:  27%|██▋       | 269/1000 [1:20:18<3:38:15, 17.91s/it][Succeeded / Failed / Skipped / Total] 20 / 245 / 4 / 269:  27%|██▋       | 270/1000 [1:20:19<3:37:10, 17.85s/it][Succeeded / Failed / Skipped / Total] 20 / 246 / 4 / 270:  27%|██▋       | 270/1000 [1:20:19<3:37:10, 17.85s/it][Succeeded / Failed / Skipped / Total] 20 / 246 / 4 / 270:  27%|██▋       | 271/1000 [1:20:28<3:36:29, 17.82s/it][Succeeded / Failed / Skipped / Total] 20 / 247 / 4 / 271:  27%|██▋       | 271/1000 [1:20:28<3:36:29, 17.82s/it][Succeeded / Failed / Skipped / Total] 20 / 247 / 4 / 271:  27%|██▋       | 272/1000 [1:20:47<3:36:15, 17.82s/it][Succeeded / Failed / Skipped / Total] 20 / 248 / 4 / 272:  27%|██▋       | 272/1000 [1:20:47<3:36:15, 17.82s/it][Succeeded / Failed / Skipped / Total] 20 / 248 / 4 / 272:  27%|██▋       | 273/1000 [1:20:54<3:35:28, 17.78s/it]Builds the response.@return the response --> Retrieves a list of responses. --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int [[statusCode]] = restAssuredResponse . statusCode ( ) ; if ( [[statusCode]] < 100 || [[statusCode]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[statusCode]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[list]] ( ) { final int [[list]] = restAssuredResponse . statusCode ( ) ; if ( [[list]] < 100 || [[list]] >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , [[list]] ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 265 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[after]] ( Matcher < ? super String > [[null]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[null]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
Create a matcher that matches cookies that have a comment. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[after]] ( Matcher < ? super String > [[function]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[function]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[data]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[data]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 268 ---------------------------------------------
Creates a copy of the supplied headers.@param header The header to copy.@param additionalHeaders Additional headers to add.@return A copy of the supplied headers. --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[export]] ( Header [[array]] , Header ... [[html]] ) { notNull ( [[array]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[array]] ) ; if ( [[html]] != null ) { Collections . addAll ( headerList , [[html]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 269 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches the supplied domain matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher domain ( Matcher < ? super String > [[query]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[query]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Creates a matcher that matches a cookie path. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[after]] ( Matcher < ? super String > [[null]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[null]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[since]] ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher version ( Matcher < ? super Integer > [[header]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[header]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 249 / 4 / 273:  27%|██▋       | 273/1000 [1:20:54<3:35:28, 17.78s/it][Succeeded / Failed / Skipped / Total] 20 / 249 / 4 / 273:  27%|██▋       | 274/1000 [1:21:14<3:35:14, 17.79s/it][Succeeded / Failed / Skipped / Total] 20 / 250 / 4 / 274:  27%|██▋       | 274/1000 [1:21:14<3:35:14, 17.79s/it][Succeeded / Failed / Skipped / Total] 20 / 250 / 4 / 274:  28%|██▊       | 275/1000 [1:21:27<3:34:45, 17.77s/it][Succeeded / Failed / Skipped / Total] 20 / 251 / 4 / 275:  28%|██▊       | 275/1000 [1:21:27<3:34:45, 17.77s/it][Succeeded / Failed / Skipped / Total] 20 / 251 / 4 / 275:  28%|██▊       | 276/1000 [1:21:36<3:34:04, 17.74s/it][Succeeded / Failed / Skipped / Total] 20 / 252 / 4 / 276:  28%|██▊       | 276/1000 [1:21:36<3:34:04, 17.74s/it][Succeeded / Failed / Skipped / Total] 20 / 252 / 4 / 276:  28%|██▊       | 277/1000 [1:21:44<3:33:22, 17.71s/it][Succeeded / Failed / Skipped / Total] 20 / 253 / 4 / 277:  28%|██▊       | 277/1000 [1:21:44<3:33:22, 17.71s/it][Succeeded / Failed / Skipped / Total] 20 / 253 / 4 / 277:  28%|██▊       | 278/1000 [1:21:56<3:32:48, 17.68s/it][Succeeded / Failed / Skipped / Total] 20 / 254 / 4 / 278:  28%|██▊       | 278/1000 [1:21:56<3:32:48, 17.68s/it][Succeeded / Failed / Skipped / Total] 20 / 254 / 4 / 278:  28%|██▊       | 279/1000 [1:21:58<3:31:50, 17.63s/it][Succeeded / Failed / Skipped / Total] 20 / 255 / 4 / 279:  28%|██▊       | 279/1000 [1:21:58<3:31:50, 17.63s/it][Succeeded / Failed / Skipped / Total] 20 / 255 / 4 / 279:  28%|██▊       | 280/1000 [1:22:08<3:31:12, 17.60s/it][Succeeded / Failed / Skipped / Total] 20 / 256 / 4 / 280:  28%|██▊       | 280/1000 [1:22:08<3:31:12, 17.60s/it][Succeeded / Failed / Skipped / Total] 20 / 256 / 4 / 280:  28%|██▊       | 281/1000 [1:22:14<3:30:26, 17.56s/it][Succeeded / Failed / Skipped / Total] 20 / 257 / 4 / 281:  28%|██▊       | 281/1000 [1:22:14<3:30:26, 17.56s/it][Succeeded / Failed / Skipped / Total] 20 / 257 / 4 / 281:  28%|██▊       | 282/1000 [1:22:16<3:29:28, 17.50s/it][Succeeded / Failed / Skipped / Total] 20 / 258 / 4 / 282:  28%|██▊       | 282/1000 [1:22:16<3:29:28, 17.50s/it][Succeeded / Failed / Skipped / Total] 20 / 258 / 4 / 282:  28%|██▊       | 283/1000 [1:23:01<3:30:21, 17.60s/it]Create a DetailedCookieMatcher that matches cookies only.@param httpOnlyMatcher The cookie only matcher.@return A DetailedCookieMatcher that matches cookies only. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[where]] ( Matcher < ? super Boolean > [[method]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[method]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches theprovided maximum age. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[where]] ( Matcher < ? super Integer > [[parameter]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[parameter]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Returns a copy of this specification with the specified host. --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[array]] ) { return new ProxySpecification ( [[array]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 276 ---------------------------------------------
Creates a new NTLM credential. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[main]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 277 ---------------------------------------------
Specifies that the specified header should match the supplied expected value. --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[text]] ( String [[command]] , Matcher < String > [[type]] ) { spec . header ( [[command]] , [[type]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Expects the specified header to be present in the response. --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String expectedValue ) { spec . header ( [[headerName]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[id]] ( String [[fetch]] , String expectedValue ) { spec . header ( [[fetch]] , expectedValue ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 279 ---------------------------------------------
Configures the JSON path with a number return type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[object]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[object]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 280 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[configuration]] ( String [[query]] , boolean [[call]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[query]] , this . defaultContentType , [[call]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 281 ---------------------------------------------
Specifies the expected value for a cookie.@param cookieName the name of the cookie@param expectedValue the expected value for the cookie --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[word]] ( String [[answer]] , String [[name]] ) { spec . cookie ( [[answer]] , [[name]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 282 ---------------------------------------------
Returns a copy of this config with the specified parser type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[command]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[command]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
[Succeeded / Failed / Skipped / Total] 20 / 259 / 4 / 283:  28%|██▊       | 283/1000 [1:23:01<3:30:21, 17.60s/it][Succeeded / Failed / Skipped / Total] 20 / 259 / 4 / 283:  28%|██▊       | 284/1000 [1:23:04<3:29:25, 17.55s/it][Succeeded / Failed / Skipped / Total] 20 / 260 / 4 / 284:  28%|██▊       | 284/1000 [1:23:04<3:29:25, 17.55s/it][Succeeded / Failed / Skipped / Total] 20 / 260 / 4 / 284:  28%|██▊       | 285/1000 [1:23:05<3:28:26, 17.49s/it][Succeeded / Failed / Skipped / Total] 20 / 261 / 4 / 285:  28%|██▊       | 285/1000 [1:23:05<3:28:26, 17.49s/it][Succeeded / Failed / Skipped / Total] 20 / 261 / 4 / 285:  29%|██▊       | 286/1000 [1:23:35<3:28:41, 17.54s/it][Succeeded / Failed / Skipped / Total] 20 / 262 / 4 / 286:  29%|██▊       | 286/1000 [1:23:35<3:28:41, 17.54s/it][Succeeded / Failed / Skipped / Total] 20 / 262 / 4 / 286:  29%|██▊       | 287/1000 [1:23:46<3:28:07, 17.51s/it][Succeeded / Failed / Skipped / Total] 21 / 262 / 4 / 287:  29%|██▊       | 287/1000 [1:23:46<3:28:07, 17.51s/it][Succeeded / Failed / Skipped / Total] 21 / 262 / 4 / 287:  29%|██▉       | 288/1000 [1:23:49<3:27:14, 17.46s/it][Succeeded / Failed / Skipped / Total] 22 / 262 / 4 / 288:  29%|██▉       | 288/1000 [1:23:49<3:27:14, 17.46s/it][Succeeded / Failed / Skipped / Total] 22 / 262 / 4 / 288:  29%|██▉       | 289/1000 [1:24:21<3:27:32, 17.51s/it][Succeeded / Failed / Skipped / Total] 22 / 263 / 4 / 289:  29%|██▉       | 289/1000 [1:24:21<3:27:32, 17.51s/it][Succeeded / Failed / Skipped / Total] 22 / 263 / 4 / 289:  29%|██▉       | 290/1000 [1:25:08<3:28:27, 17.62s/it][Succeeded / Failed / Skipped / Total] 22 / 264 / 4 / 290:  29%|██▉       | 290/1000 [1:25:08<3:28:27, 17.62s/it][Succeeded / Failed / Skipped / Total] 22 / 264 / 4 / 290:  29%|██▉       | 291/1000 [1:25:10<3:27:30, 17.56s/it][Succeeded / Failed / Skipped / Total] 22 / 265 / 4 / 291:  29%|██▉       | 291/1000 [1:25:10<3:27:30, 17.56s/it][Succeeded / Failed / Skipped / Total] 22 / 265 / 4 / 291:  29%|██▉       | 292/1000 [1:25:21<3:26:57, 17.54s/it][Succeeded / Failed / Skipped / Total] 22 / 266 / 4 / 292:  29%|██▉       | 292/1000 [1:25:21<3:26:57, 17.54s/it][Succeeded / Failed / Skipped / Total] 22 / 266 / 4 / 292:  29%|██▉       | 293/1000 [1:25:28<3:26:15, 17.50s/it]--------------------------------------------- Result 283 ---------------------------------------------
Configures the default boundary for this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[mode]] ( String [[foo]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[mode]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 284 ---------------------------------------------
Enables or disables logging of a request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[process]] ( LogDetail [[en]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[en]] , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 285 ---------------------------------------------
Creates a default log configuration for this log. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream [[extension]] ) { return new LogConfig ( [[extension]] , "[[load]]" == "[[load]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[load]]" == "[[load]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 286 ---------------------------------------------
Adds a header to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String [[headerValue]] ) { spec . header ( headerName , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[header]] ( String headerName , String [[spec]] ) { spec . header ( headerName , [[spec]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 287 ---------------------------------------------
Add result handlers.@param resultHandler the result handler@param additionalResultHandlers the additional result handlers --> Formats the mock request. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[format]] ( ResultHandler [[example]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[example]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 288 ---------------------------------------------
Adds an attribute to the request spec. --> Specifies the size of the mock tree. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String attributeName , Object [[attributeValue]] ) { spec . attribute ( attributeName , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[tree]] ( String attributeName , Object [[size]] ) { spec . attribute ( attributeName , [[size]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 289 ---------------------------------------------
Adds a multi part request specification. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[format]] ( String controlName , String contentBody , String mimeType ) { spec . multiPart ( controlName , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 290 ---------------------------------------------
Retrieve an integer value from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[loop]] ( String [[input]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Sets the value of the specified HTTP parameter.@param parameterName Name of the HTTP parameter to set.@param parameterValue Value of the HTTP parameter to set.@return Never <code>null</code>. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[port]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[port]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 292 ---------------------------------------------
Creates and returns a new instance of the HttpClientConfig class. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[httpClientFactory]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[httpClientFactory]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig [[function]] ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( [[function]] , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 293 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 22 / 267 / 4 / 293:  29%|██▉       | 293/1000 [1:25:28<3:26:15, 17.50s/it][Succeeded / Failed / Skipped / Total] 22 / 267 / 4 / 293:  29%|██▉       | 294/1000 [1:25:42<3:25:48, 17.49s/it][Succeeded / Failed / Skipped / Total] 22 / 268 / 4 / 294:  29%|██▉       | 294/1000 [1:25:42<3:25:48, 17.49s/it][Succeeded / Failed / Skipped / Total] 22 / 268 / 4 / 294:  30%|██▉       | 295/1000 [1:25:50<3:25:09, 17.46s/it][Succeeded / Failed / Skipped / Total] 22 / 269 / 4 / 295:  30%|██▉       | 295/1000 [1:25:50<3:25:09, 17.46s/it][Succeeded / Failed / Skipped / Total] 22 / 269 / 4 / 295:  30%|██▉       | 296/1000 [1:25:55<3:24:21, 17.42s/it][Succeeded / Failed / Skipped / Total] 22 / 270 / 4 / 296:  30%|██▉       | 296/1000 [1:25:55<3:24:21, 17.42s/it][Succeeded / Failed / Skipped / Total] 22 / 270 / 4 / 296:  30%|██▉       | 297/1000 [1:26:06<3:23:48, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 271 / 4 / 297:  30%|██▉       | 297/1000 [1:26:06<3:23:48, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 271 / 4 / 297:  30%|██▉       | 298/1000 [1:26:24<3:23:32, 17.40s/it][Succeeded / Failed / Skipped / Total] 22 / 272 / 4 / 298:  30%|██▉       | 298/1000 [1:26:24<3:23:32, 17.40s/it][Succeeded / Failed / Skipped / Total] 22 / 272 / 4 / 298:  30%|██▉       | 299/1000 [1:26:40<3:23:13, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 273 / 4 / 299:  30%|██▉       | 299/1000 [1:26:40<3:23:13, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 273 / 4 / 299:  30%|███       | 300/1000 [1:26:55<3:22:49, 17.38s/it][Succeeded / Failed / Skipped / Total] 22 / 274 / 4 / 300:  30%|███       | 300/1000 [1:26:55<3:22:49, 17.38s/it][Succeeded / Failed / Skipped / Total] 22 / 274 / 4 / 300:  30%|███       | 301/1000 [1:27:21<3:22:51, 17.41s/it][Succeeded / Failed / Skipped / Total] 22 / 275 / 4 / 301:  30%|███       | 301/1000 [1:27:21<3:22:51, 17.41s/it][Succeeded / Failed / Skipped / Total] 22 / 275 / 4 / 301:  30%|███       | 302/1000 [1:27:30<3:22:15, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 276 / 4 / 302:  30%|███       | 302/1000 [1:27:30<3:22:15, 17.39s/it][Succeeded / Failed / Skipped / Total] 22 / 276 / 4 / 302:  30%|███       | 303/1000 [1:28:04<3:22:35, 17.44s/it][Succeeded / Failed / Skipped / Total] 22 / 277 / 4 / 303:  30%|███       | 303/1000 [1:28:04<3:22:35, 17.44s/it][Succeeded / Failed / Skipped / Total] 22 / 277 / 4 / 303:  30%|███       | 304/1000 [1:28:26<3:22:29, 17.46s/it]Configures this HttpClientConfig with the given HTTP MultipartMode. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[http]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[http]] , shouldReuseHttpClientInstance , httpClient , "[[can]]" == "[[can]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 294 ---------------------------------------------
Gets the value of the specified JSON path.@param < T> the type parameter@param path the path@return the value --> [[[FAILED]]]

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < T > T get ( String path ) { final JSONAssertion [[configuration]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( T ) [[configuration]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 295 ---------------------------------------------
Retrieve a byte value from the supplied resource. --> [[[FAILED]]]

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[set]] ( String [[i]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 296 ---------------------------------------------
Retrieve a Short object from the given path. --> [[[FAILED]]]

[[[[Adv]]]]: public short getShort ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short getShort ( String [[length]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 297 ---------------------------------------------
Creates a new HTTP client configuration with the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[end]] ( Map < String , ? > [[list]] ) { notNull ( [[list]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . httpClientParams ) ; newParams . putAll ( [[list]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 298 ---------------------------------------------
Retrieve a long value. --> [[[FAILED]]]

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[cut]] ( String [[array]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 299 ---------------------------------------------
Retrieve a property as a float. --> [[[FAILED]]]

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[add]] ( String [[length]] ) { final Object [[a]] = get ( [[length]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieve a property as a double. --> [[[FAILED]]]

[[[[Adv]]]]: public double getDouble ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double getDouble ( String [[value]] ) { final Object [[scope]] = get ( [[value]] ) ; if ( [[scope]] instanceof Double ) { return ( Double ) [[scope]] ; } return ObjectConverter . convertObjectTo ( [[scope]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 301 ---------------------------------------------
Gets a map from a path. --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[where]] ( String [[output]] ) { return get ( [[output]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 302 ---------------------------------------------
Sets the body of the request. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[client]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 303 ---------------------------------------------
Retrieves an object from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object object = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[form]] > [[form]] getObject ( String path , Class < [[form]] > objectType ) { Object object = getFromPath ( path , "[[tail]]" != "[[tail]]" ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 304 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 277 / 4 / 304:  30%|███       | 304/1000 [1:28:26<3:22:29, 17.46s/it][Succeeded / Failed / Skipped / Total] 23 / 277 / 4 / 304:  30%|███       | 305/1000 [1:28:29<3:21:37, 17.41s/it][Succeeded / Failed / Skipped / Total] 23 / 278 / 4 / 305:  30%|███       | 305/1000 [1:28:29<3:21:37, 17.41s/it][Succeeded / Failed / Skipped / Total] 23 / 278 / 4 / 305:  31%|███       | 306/1000 [1:28:30<3:20:44, 17.36s/it][Succeeded / Failed / Skipped / Total] 23 / 279 / 4 / 306:  31%|███       | 306/1000 [1:28:30<3:20:44, 17.36s/it][Succeeded / Failed / Skipped / Total] 23 / 279 / 4 / 306:  31%|███       | 307/1000 [1:28:38<3:20:06, 17.33s/it][Succeeded / Failed / Skipped / Total] 23 / 280 / 4 / 307:  31%|███       | 307/1000 [1:28:38<3:20:06, 17.33s/it][Succeeded / Failed / Skipped / Total] 23 / 280 / 4 / 307:  31%|███       | 308/1000 [1:28:44<3:19:23, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 281 / 4 / 308:  31%|███       | 308/1000 [1:28:44<3:19:23, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 281 / 4 / 308:  31%|███       | 309/1000 [1:28:51<3:18:43, 17.25s/it][Succeeded / Failed / Skipped / Total] 23 / 282 / 4 / 309:  31%|███       | 309/1000 [1:28:51<3:18:43, 17.25s/it][Succeeded / Failed / Skipped / Total] 23 / 282 / 4 / 309:  31%|███       | 310/1000 [1:29:10<3:18:28, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 283 / 4 / 310:  31%|███       | 310/1000 [1:29:10<3:18:28, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 283 / 4 / 310:  31%|███       | 311/1000 [1:29:41<3:18:41, 17.30s/it][Succeeded / Failed / Skipped / Total] 23 / 284 / 4 / 311:  31%|███       | 311/1000 [1:29:41<3:18:41, 17.30s/it][Succeeded / Failed / Skipped / Total] 23 / 284 / 4 / 311:  31%|███       | 312/1000 [1:29:44<3:17:53, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 285 / 4 / 312:  31%|███       | 312/1000 [1:29:44<3:17:53, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 285 / 4 / 312:  31%|███▏      | 313/1000 [1:29:53<3:17:18, 17.23s/it]Creates and returns a builder for a parameter update strategy. --> Creates and returns a new instance of MockMvcParamConfig --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[a]] ( UpdateStrategy [[a]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[a]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[i]] ( String [[integer]] , Collection < ? > [[field]] ) { spec . param ( [[integer]] , [[field]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String parameterName , Object ... [[parameterValues]] ) { spec . param ( parameterName , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[bar]] ( String parameterName , Object ... [[shell]] ) { spec . param ( parameterName , [[shell]] ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Creates a new HTTP request based on the given URI and HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI [[uri]] , String [[httpMethod]] , boolean [[hasBody]] ) { String method = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[function]] ( URI [[bucket]] , String [[container]] , boolean [[buffer]] ) { String method = notNull ( upperCase ( trimToNull ( [[container]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 308 ---------------------------------------------
Adds a cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[ee]] ( String [[variable]] , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( [[variable]] , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 309 ---------------------------------------------
Adds all bindings to the map. --> [[[FAILED]]]

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[alice]] ( ) { for ( Binding < ? > binding : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( binding . getKey ( ) . getTypeLiteral ( ) , binding ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 310 ---------------------------------------------
Removes all keys and sources from the backing map. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[keysAndSources]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[main]] ( Set < KeyAndSource > [[function]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[function]] ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 311 ---------------------------------------------
Removes a failed JIT binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[main]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 312 ---------------------------------------------
Returns the internal dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[test]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 313 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 286 / 4 / 313:  31%|███▏      | 313/1000 [1:29:53<3:17:18, 17.23s/it][Succeeded / Failed / Skipped / Total] 23 / 286 / 4 / 313:  31%|███▏      | 314/1000 [1:30:08<3:16:55, 17.22s/it][Succeeded / Failed / Skipped / Total] 23 / 287 / 4 / 314:  31%|███▏      | 314/1000 [1:30:08<3:16:55, 17.22s/it][Succeeded / Failed / Skipped / Total] 23 / 287 / 4 / 314:  32%|███▏      | 315/1000 [1:30:41<3:17:13, 17.28s/it][Succeeded / Failed / Skipped / Total] 23 / 288 / 4 / 315:  32%|███▏      | 315/1000 [1:30:41<3:17:13, 17.28s/it][Succeeded / Failed / Skipped / Total] 23 / 288 / 4 / 315:  32%|███▏      | 316/1000 [1:30:54<3:16:46, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 289 / 4 / 316:  32%|███▏      | 316/1000 [1:30:54<3:16:46, 17.26s/it][Succeeded / Failed / Skipped / Total] 23 / 289 / 4 / 316:  32%|███▏      | 317/1000 [1:31:20<3:16:47, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 290 / 4 / 317:  32%|███▏      | 317/1000 [1:31:20<3:16:47, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 290 / 4 / 317:  32%|███▏      | 318/1000 [1:31:36<3:16:29, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 291 / 4 / 318:  32%|███▏      | 318/1000 [1:31:36<3:16:29, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 291 / 4 / 318:  32%|███▏      | 319/1000 [1:31:54<3:16:12, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 292 / 4 / 319:  32%|███▏      | 319/1000 [1:31:54<3:16:12, 17.29s/it][Succeeded / Failed / Skipped / Total] 23 / 292 / 4 / 319:  32%|███▏      | 320/1000 [1:31:56<3:15:22, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 293 / 4 / 320:  32%|███▏      | 320/1000 [1:31:56<3:15:22, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 293 / 4 / 320:  32%|███▏      | 321/1000 [1:31:58<3:14:32, 17.19s/it]Creates a filter that logs responses that match the provided matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[length]] ) { return new ResponseLoggingFilter ( stream , [[length]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 314 ---------------------------------------------
Converts a string constant binding to a binding. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[array]] ( Key < T > key , Errors errors ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 315 ---------------------------------------------
Binds an injector. --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[main]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 316 ---------------------------------------------
Binds a logger to the given injector. --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[main]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 317 ---------------------------------------------
Creates a new Cookies instance with the specified cookies.@param cookie the cookie@param additionalCookies the additional cookies@return a new cookies instance --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie [[cookie]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cookie]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[object]] ( Cookie [[book]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[book]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[book]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 318 ---------------------------------------------
Gets a list from the specified path.@param path the path@param genericType the generic type@return the list --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[end]] ( String [[length]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[length]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 319 ---------------------------------------------
Creates an uninitialized binding. --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 320 ---------------------------------------------
Initializes the delegate members. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[foo]] ( MembersInjector < T > delegate ) { checkState ( this . [[scope]] == null , "delegate already initialized" ) ; this . [[scope]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 321 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 294 / 4 / 321:  32%|███▏      | 321/1000 [1:31:58<3:14:32, 17.19s/it][Succeeded / Failed / Skipped / Total] 23 / 294 / 4 / 321:  32%|███▏      | 322/1000 [1:32:16<3:14:17, 17.19s/it][Succeeded / Failed / Skipped / Total] 23 / 295 / 4 / 322:  32%|███▏      | 322/1000 [1:32:16<3:14:17, 17.19s/it][Succeeded / Failed / Skipped / Total] 23 / 295 / 4 / 322:  32%|███▏      | 323/1000 [1:32:42<3:14:19, 17.22s/it][Succeeded / Failed / Skipped / Total] 23 / 296 / 4 / 323:  32%|███▏      | 323/1000 [1:32:42<3:14:19, 17.22s/it][Succeeded / Failed / Skipped / Total] 23 / 296 / 4 / 323:  32%|███▏      | 324/1000 [1:33:05<3:14:13, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 297 / 4 / 324:  32%|███▏      | 324/1000 [1:33:05<3:14:13, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 297 / 4 / 324:  32%|███▎      | 325/1000 [1:33:22<3:13:56, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 298 / 4 / 325:  32%|███▎      | 325/1000 [1:33:22<3:13:56, 17.24s/it][Succeeded / Failed / Skipped / Total] 23 / 298 / 4 / 325:  33%|███▎      | 326/1000 [1:33:29<3:13:18, 17.21s/it][Succeeded / Failed / Skipped / Total] 23 / 299 / 4 / 326:  33%|███▎      | 326/1000 [1:33:29<3:13:18, 17.21s/it][Succeeded / Failed / Skipped / Total] 23 / 299 / 4 / 326:  33%|███▎      | 327/1000 [1:33:43<3:12:52, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 300 / 4 / 327:  33%|███▎      | 327/1000 [1:33:43<3:12:52, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 300 / 4 / 327:  33%|███▎      | 328/1000 [1:34:02<3:12:39, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 301 / 4 / 328:  33%|███▎      | 328/1000 [1:34:02<3:12:39, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 301 / 4 / 328:  33%|███▎      | 329/1000 [1:34:06<3:11:57, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 302 / 4 / 329:  33%|███▎      | 329/1000 [1:34:06<3:11:57, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 302 / 4 / 329:  33%|███▎      | 330/1000 [1:34:08<3:11:08, 17.12s/it]Get the provider type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[message]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare all built-in converters. --> [[[FAILED]]]

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[command]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
Canonicalizes the given class loader. --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader canonicalize ( ClassLoader [[a]] ) { return [[a]] != null ? [[a]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 324 ---------------------------------------------
Resolve all of the given types. --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int t = 0 ; t < [[types]] . length ; t ++ ) { result [ t ] = resolve ( [[types]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[function]] ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ [[function]] . length ] ; for ( int t = 0 ; t < [[function]] . length ; t ++ ) { result [ t ] = resolve ( [[function]] [ t ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 325 ---------------------------------------------
Checks if two methods are overrides of each other. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[set]] ( Method a , Method [[bc]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 326 ---------------------------------------------
Cleans up the dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[binding]] , Set < Key > encountered ) { boolean [[bindingFailed]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean cleanup ( BindingImpl < ? > [[etc]] , Set < Key > encountered ) { boolean [[c]] = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[etc]] ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( encountered . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 327 ---------------------------------------------
Checks if the given class loader has the same version of the current one. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[capture]] ( ClassLoader classLoader ) { Class < ? > fc = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( fc . getName ( ) ) == fc ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 328 ---------------------------------------------
Returns all the parameters in the given injectors. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[size]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext [[ctors]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[context]] = parameterInjectors . length ; Object [ ] parameters = new Object [ [[context]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 329 ---------------------------------------------
Converts the specified key into an appropriate annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[set]] ( Key < ? > [[command]] ) { return [[command]] . getAnnotation ( ) == null ? [[command]] : Key . get ( [[command]] . getTypeLiteral ( ) , [[command]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 330 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 303 / 4 / 330:  33%|███▎      | 330/1000 [1:34:08<3:11:08, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 303 / 4 / 330:  33%|███▎      | 331/1000 [1:34:14<3:10:27, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 304 / 4 / 331:  33%|███▎      | 331/1000 [1:34:14<3:10:27, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 304 / 4 / 331:  33%|███▎      | 332/1000 [1:34:24<3:09:56, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 305 / 4 / 332:  33%|███▎      | 332/1000 [1:34:24<3:09:56, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 305 / 4 / 332:  33%|███▎      | 333/1000 [1:34:53<3:10:04, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 306 / 4 / 333:  33%|███▎      | 333/1000 [1:34:53<3:10:04, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 306 / 4 / 333:  33%|███▎      | 334/1000 [1:35:22<3:10:10, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 307 / 4 / 334:  33%|███▎      | 334/1000 [1:35:22<3:10:10, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 307 / 4 / 334:  34%|███▎      | 335/1000 [1:35:39<3:09:52, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 308 / 4 / 335:  34%|███▎      | 335/1000 [1:35:39<3:09:52, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 308 / 4 / 335:  34%|███▎      | 336/1000 [1:35:43<3:09:09, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 309 / 4 / 336:  34%|███▎      | 336/1000 [1:35:43<3:09:09, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 309 / 4 / 336:  34%|███▎      | 337/1000 [1:35:44<3:08:21, 17.05s/it]Checks for misplaced binding annotations. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[search]] ( Member [[information]] , Errors errors ) { Annotation [[self]] = Annotations . findBindingAnnotation ( errors , [[information]] , ( ( AnnotatedElement ) [[information]] ) . getAnnotations ( ) ) ; if ( [[self]] == null ) { return "[[check]]" != "[[check]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 331 ---------------------------------------------
Injects the given instance into the given injector.@param injector the injector@param instance the instance@param binding the binding@param source the source@param injectionPoints the injection points --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 332 ---------------------------------------------
Validates that the injections are valid. --> [[[FAILED]]]

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[accept]] ( Errors errors ) { validationStarted = "True" == "True" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 333 ---------------------------------------------
Converts a TypeLiteral into a canonical type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type type = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[test]] ( TypeLiteral < T > [[parameters]] ) { Type type = [[parameters]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[parameters]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[parameters]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 334 ---------------------------------------------
Generates an annotation for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[complete]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 335 ---------------------------------------------
Creates an injectable scope. --> [[[FAILED]]]

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[process]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 336 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[execute]] ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 337 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 310 / 4 / 337:  34%|███▎      | 337/1000 [1:35:44<3:08:21, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 310 / 4 / 337:  34%|███▍      | 338/1000 [1:35:58<3:07:58, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 311 / 4 / 338:  34%|███▍      | 338/1000 [1:35:58<3:07:58, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 311 / 4 / 338:  34%|███▍      | 339/1000 [1:36:34<3:08:18, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 312 / 4 / 339:  34%|███▍      | 339/1000 [1:36:34<3:08:18, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 312 / 4 / 339:  34%|███▍      | 340/1000 [1:36:36<3:07:32, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 313 / 4 / 340:  34%|███▍      | 340/1000 [1:36:36<3:07:32, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 313 / 4 / 340:  34%|███▍      | 341/1000 [1:36:56<3:07:21, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 314 / 4 / 341:  34%|███▍      | 341/1000 [1:36:56<3:07:21, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 314 / 4 / 341:  34%|███▍      | 342/1000 [1:37:02<3:06:43, 17.03s/it][Succeeded / Failed / Skipped / Total] 23 / 315 / 4 / 342:  34%|███▍      | 342/1000 [1:37:02<3:06:43, 17.03s/it][Succeeded / Failed / Skipped / Total] 23 / 315 / 4 / 342:  34%|███▍      | 343/1000 [1:37:14<3:06:16, 17.01s/it][Succeeded / Failed / Skipped / Total] 23 / 316 / 4 / 343:  34%|███▍      | 343/1000 [1:37:14<3:06:16, 17.01s/it][Succeeded / Failed / Skipped / Total] 23 / 316 / 4 / 343:  34%|███▍      | 344/1000 [1:38:03<3:06:59, 17.10s/it]Dispatches a servlet request to the dispatcher. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[explorer]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 338 ---------------------------------------------
Normalizes a path. --> [[[FAILED]]]

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder sb = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[end]] ( String [[array]] ) { StringBuilder sb = new StringBuilder ( [[array]] . length ( ) ) ; int queryStart = [[array]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[array]] . substring ( queryStart ) ; [[array]] = [[array]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[assume]] ( Provider < T > delegate ) { checkState ( this . [[program]] == null , "delegate already initialized" ) ; this . [[program]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Returns true if the given member is public, false otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[method]] ) { if ( ! Modifier . isPublic ( [[method]] . getModifiers ( ) ) ) { return "[[cause]]" != "[[cause]]" ; } Class < ? > [ ] [[c]] ; if ( [[method]] instanceof Constructor ) { [[c]] = ( ( Constructor ) [[method]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[method]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[cause]]" != "[[cause]]" ; } [[c]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[c]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "[[cause]]" != "[[cause]]" ; } } return "[[proof]]" == "[[proof]]" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 341 ---------------------------------------------
Adds the direct type binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[fix]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 342 ---------------------------------------------
Returns true if the given annotation is retained at runtime. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > annotationType ) { Retention [[retention]] = annotationType . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[release]] ( Class < ? extends Annotation > annotationType ) { Retention [[s]] = annotationType . getAnnotation ( Retention . class ) ; return [[s]] != null && [[s]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 343 ---------------------------------------------
Returns the name of the given key. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[c]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 344 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 317 / 4 / 344:  34%|███▍      | 344/1000 [1:38:03<3:06:59, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 317 / 4 / 344:  34%|███▍      | 345/1000 [1:38:13<3:06:29, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 318 / 4 / 345:  34%|███▍      | 345/1000 [1:38:13<3:06:29, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 318 / 4 / 345:  35%|███▍      | 346/1000 [1:39:09<3:07:26, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 319 / 4 / 346:  35%|███▍      | 346/1000 [1:39:09<3:07:26, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 319 / 4 / 346:  35%|███▍      | 347/1000 [1:39:14<3:06:45, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 320 / 4 / 347:  35%|███▍      | 347/1000 [1:39:14<3:06:45, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 320 / 4 / 347:  35%|███▍      | 348/1000 [1:39:20<3:06:07, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 321 / 4 / 348:  35%|███▍      | 348/1000 [1:39:20<3:06:07, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 321 / 4 / 348:  35%|███▍      | 349/1000 [1:39:38<3:05:52, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 322 / 4 / 349:  35%|███▍      | 349/1000 [1:39:38<3:05:52, 17.13s/it][Succeeded / Failed / Skipped / Total] 23 / 322 / 4 / 349:  35%|███▌      | 350/1000 [1:39:38<3:05:03, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 323 / 4 / 350:  35%|███▌      | 350/1000 [1:39:38<3:05:03, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 323 / 4 / 350:  35%|███▌      | 351/1000 [1:39:45<3:04:27, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 324 / 4 / 351:  35%|███▌      | 351/1000 [1:39:45<3:04:27, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 324 / 4 / 351:  35%|███▌      | 352/1000 [1:39:47<3:03:42, 17.01s/it]Returns the key for a new value. --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 345 ---------------------------------------------
Creates a factory for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > [[key]] , InjectorImpl [[injector]] , InternalFactory < ? extends T > creator , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return creator ; } Scope [[scope]] = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[after]] ( Key < T > [[creators]] , InjectorImpl [[tree]] , InternalFactory < ? extends T > creator , Object source , Scoping [[server]] ) { if ( [[server]] . isNoScope ( ) ) { return creator ; } Scope [[after]] = [[server]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 346 ---------------------------------------------
Returns a ConstructorInjector for the given InjectionPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[retrieve]] ( InjectionPoint [[address]] , Errors [[reserved]] ) throws ErrorsException { return cache . get ( [[address]] , [[reserved]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 347 ---------------------------------------------
Checks if the interceptor class has a scope annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > [[interceptorClass]] ) { for ( Annotation annotation : [[interceptorClass]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[set]] ( Class < ? extends Interceptor > [[a]] ) { for ( Annotation annotation : [[a]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 348 ---------------------------------------------
Writes a message to the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[flow]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 349 ---------------------------------------------
Returns the module for the given module. --> [[[FAILED]]]

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[load]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 350 ---------------------------------------------
Returns a collection of all methods of this class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[include]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 351 ---------------------------------------------
Returns the key for the specified type and member. --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member [[member]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[member]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[error]] ( TypeLiteral < ? > type , Member [[id]] , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[id]] , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 352 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 325 / 4 / 352:  35%|███▌      | 352/1000 [1:39:47<3:03:42, 17.01s/it][Succeeded / Failed / Skipped / Total] 23 / 325 / 4 / 352:  35%|███▌      | 353/1000 [1:40:32<3:04:17, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 326 / 4 / 353:  35%|███▌      | 353/1000 [1:40:32<3:04:17, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 326 / 4 / 353:  35%|███▌      | 354/1000 [1:41:26<3:05:06, 17.19s/it][Succeeded / Failed / Skipped / Total] 23 / 327 / 4 / 354:  35%|███▌      | 354/1000 [1:41:26<3:05:06, 17.19s/it][Succeeded / Failed / Skipped / Total] 23 / 327 / 4 / 354:  36%|███▌      | 355/1000 [1:41:45<3:04:53, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 328 / 4 / 355:  36%|███▌      | 355/1000 [1:41:45<3:04:53, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 328 / 4 / 355:  36%|███▌      | 356/1000 [1:41:46<3:04:05, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 329 / 4 / 356:  36%|███▌      | 356/1000 [1:41:46<3:04:05, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 329 / 4 / 356:  36%|███▌      | 357/1000 [1:42:04<3:03:50, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 330 / 4 / 357:  36%|███▌      | 357/1000 [1:42:04<3:03:50, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 330 / 4 / 357:  36%|███▌      | 358/1000 [1:42:30<3:03:48, 17.18s/it]Finds the scope annotation for the given annotations. --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] [[annotations]] ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation [[annotation]] : [[annotations]] ) { Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] [[removed]] ) { Class < ? extends Annotation > [[f]] = null ; for ( Annotation [[point]] : [[removed]] ) { Class < ? extends Annotation > annotationType = [[point]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[f]] != null ) { errors . duplicateScopeAnnotations ( [[f]] , annotationType ) ; } else { [[f]] = annotationType ; } } } return [[f]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 353 ---------------------------------------------
Create a new RealMapBinder. --> [[[FAILED]]]

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[execute]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[execute]] ( binder , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 354 ---------------------------------------------
Creates a new instance of the proxy for the given context. --> [[[FAILED]]]

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[unless]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[ends]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[ends]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[ends]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 355 ---------------------------------------------
Returns the set of dependencies for the given injection point. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > getDependencies ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 356 ---------------------------------------------
Removes the given set of dependencies from the given set. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[end]] ( Set < Dependency < ? > > [[method]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[method]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 357 ---------------------------------------------
Creates an error message for the given key. --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 331 / 4 / 358:  36%|███▌      | 358/1000 [1:42:30<3:03:48, 17.18s/it][Succeeded / Failed / Skipped / Total] 23 / 331 / 4 / 358:  36%|███▌      | 359/1000 [1:42:53<3:03:42, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 332 / 4 / 359:  36%|███▌      | 359/1000 [1:42:53<3:03:42, 17.20s/it][Succeeded / Failed / Skipped / Total] 23 / 332 / 4 / 359:  36%|███▌      | 360/1000 [1:42:59<3:03:05, 17.17s/it][Succeeded / Failed / Skipped / Total] 23 / 333 / 4 / 360:  36%|███▌      | 360/1000 [1:42:59<3:03:05, 17.17s/it][Succeeded / Failed / Skipped / Total] 23 / 333 / 4 / 360:  36%|███▌      | 361/1000 [1:43:08<3:02:34, 17.14s/it][Succeeded / Failed / Skipped / Total] 23 / 334 / 4 / 361:  36%|███▌      | 361/1000 [1:43:08<3:02:34, 17.14s/it][Succeeded / Failed / Skipped / Total] 23 / 334 / 4 / 361:  36%|███▌      | 362/1000 [1:43:28<3:02:22, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 335 / 4 / 362:  36%|███▌      | 362/1000 [1:43:28<3:02:22, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 335 / 4 / 362:  36%|███▋      | 363/1000 [1:43:47<3:02:07, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 336 / 4 / 363:  36%|███▋      | 363/1000 [1:43:47<3:02:07, 17.15s/it][Succeeded / Failed / Skipped / Total] 23 / 336 / 4 / 363:  36%|███▋      | 364/1000 [1:43:51<3:01:28, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 337 / 4 / 364:  36%|███▋      | 364/1000 [1:43:51<3:01:28, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 337 / 4 / 364:  36%|███▋      | 365/1000 [1:44:04<3:01:03, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 338 / 4 / 365:  36%|███▋      | 365/1000 [1:44:04<3:01:03, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 338 / 4 / 365:  37%|███▋      | 366/1000 [1:44:21<3:00:45, 17.11s/it]Checks if the given type literal is not specified in the configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[add]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "[[message]]" != "[[message]]" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 359 ---------------------------------------------
Find the next filter. --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 360 ---------------------------------------------
Create a binding from a new injector. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 361 ---------------------------------------------
Gets the internal constructor. --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint getInternalConstructor ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the given constructor has at least one annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[call]] ( Constructor cxtor ) { return cxtor . isAnnotationPresent ( Inject . class ) || cxtor . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Checks if the given set of dependencies is valid for the given factory type. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[library]] ( Set < Dependency < ? > > [[methods]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[b]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 364 ---------------------------------------------
Create a new set-binder for the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder binder , Key < T > [[key]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[key]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[loop]] ( Binder binder , Key < T > [[c]] ) { binder = binder . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( binder , [[c]] ) ; binder . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 365 ---------------------------------------------
Returns the set of internal dependencies for the given factory. --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[build]] ( ) { ImmutableSet . Builder < InjectionPoint > [[size]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[size]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 339 / 4 / 366:  37%|███▋      | 366/1000 [1:44:21<3:00:45, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 339 / 4 / 366:  37%|███▋      | 367/1000 [1:44:33<3:00:20, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 340 / 4 / 367:  37%|███▋      | 367/1000 [1:44:33<3:00:20, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 340 / 4 / 367:  37%|███▋      | 368/1000 [1:44:44<2:59:52, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 341 / 4 / 368:  37%|███▋      | 368/1000 [1:44:44<2:59:52, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 341 / 4 / 368:  37%|███▋      | 369/1000 [1:45:13<2:59:56, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 342 / 4 / 369:  37%|███▋      | 369/1000 [1:45:13<2:59:56, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 342 / 4 / 369:  37%|███▋      | 370/1000 [1:45:27<2:59:33, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 343 / 4 / 370:  37%|███▋      | 370/1000 [1:45:27<2:59:33, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 343 / 4 / 370:  37%|███▋      | 371/1000 [1:45:35<2:59:01, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 344 / 4 / 371:  37%|███▋      | 371/1000 [1:45:35<2:59:01, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 344 / 4 / 371:  37%|███▋      | 372/1000 [1:45:52<2:58:44, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 345 / 4 / 372:  37%|███▋      | 372/1000 [1:45:52<2:58:44, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 345 / 4 / 372:  37%|███▋      | 373/1000 [1:45:55<2:58:02, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 346 / 4 / 373:  37%|███▋      | 373/1000 [1:45:55<2:58:02, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 346 / 4 / 373:  37%|███▋      | 374/1000 [1:46:21<2:58:00, 17.06s/it]Initializes the lookups. --> [[[FAILED]]]

[[[[Adv]]]]: void [[initialize]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[counter]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 367 ---------------------------------------------
Returns the line number for the given member. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[end]] ( Member [[bus]] ) { Preconditions . checkArgument ( type == [[bus]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[bus]] , [[bus]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[bus]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 368 ---------------------------------------------
Returns a module for the given module annotated method. --> [[[FAILED]]]

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[module]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[handle]] ( Object [[a]] , ModuleAnnotatedMethodScanner scanner ) { return forObject ( [[a]] , "False" != "False" , scanner ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 369 ---------------------------------------------
Wraps a callable with a transfer request. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > callable ) { return wrap ( callable , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[build]] ( Callable < T > callable ) { return wrap ( callable , [[build]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 370 ---------------------------------------------
Invokes the specified method on the specified object. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method [[method]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[control]] ( Object proxy , final Method [[handler]] , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 371 ---------------------------------------------
Wraps a callable with a request seed map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[bus]] ( Callable < T > callable , Map < Key < ? > , Object > seedMap ) { return wrap ( callable , [[bus]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 372 ---------------------------------------------
Returns the annotation for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[array]] ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[bucket]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[bucket]] != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[bucket]] = foundAnnotation ; } } return [[bucket]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 373 ---------------------------------------------
Validates that the supplied object is compatible with the supplied key. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[request]] ( Key < ? > key , Object [[directory]] ) { if ( [[directory]] == null || [[directory]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[directory]] ) ) { throw new IllegalArgumentException ( "Value[" + [[directory]] + "] of type[" + [[directory]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[directory]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 374 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 347 / 4 / 374:  37%|███▋      | 374/1000 [1:46:21<2:58:00, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 347 / 4 / 374:  38%|███▊      | 375/1000 [1:46:32<2:57:33, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 348 / 4 / 375:  38%|███▊      | 375/1000 [1:46:32<2:57:33, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 348 / 4 / 375:  38%|███▊      | 376/1000 [1:46:39<2:56:59, 17.02s/it][Succeeded / Failed / Skipped / Total] 23 / 349 / 4 / 376:  38%|███▊      | 376/1000 [1:46:39<2:56:59, 17.02s/it][Succeeded / Failed / Skipped / Total] 23 / 349 / 4 / 376:  38%|███▊      | 377/1000 [1:46:47<2:56:27, 16.99s/it][Succeeded / Failed / Skipped / Total] 23 / 350 / 4 / 377:  38%|███▊      | 377/1000 [1:46:47<2:56:27, 16.99s/it][Succeeded / Failed / Skipped / Total] 23 / 350 / 4 / 377:  38%|███▊      | 378/1000 [1:46:58<2:56:02, 16.98s/it][Succeeded / Failed / Skipped / Total] 23 / 351 / 4 / 378:  38%|███▊      | 378/1000 [1:46:58<2:56:02, 16.98s/it][Succeeded / Failed / Skipped / Total] 23 / 351 / 4 / 378:  38%|███▊      | 379/1000 [1:47:20<2:55:52, 16.99s/it][Succeeded / Failed / Skipped / Total] 23 / 352 / 4 / 379:  38%|███▊      | 379/1000 [1:47:20<2:55:52, 16.99s/it][Succeeded / Failed / Skipped / Total] 23 / 352 / 4 / 379:  38%|███▊      | 380/1000 [1:47:50<2:55:57, 17.03s/it]Returns an annotation strategy for the given annotation type. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return [[strategyFor]] ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[er]] ( Class < ? extends Annotation > annotationType ) { annotationType = Annotations . canonicalizeIfNamed ( annotationType ) ; if ( isAllDefaultMethods ( annotationType ) ) { return [[er]] ( generateAnnotation ( annotationType ) ) ; } checkNotNull ( annotationType , "annotation type" ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; return new AnnotationTypeStrategy ( annotationType , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 375 ---------------------------------------------
Returns an annotation strategy for the given annotation. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[how]] ( Annotation [[attribute]] ) { checkNotNull ( [[attribute]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[attribute]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[attribute]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[attribute]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 376 ---------------------------------------------
Gets the source of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[filter]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 377 ---------------------------------------------
Gets the injectors for the given injection points. --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[box]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors errorsForMember = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , errorsForMember ) : new SingleMethodInjector ( this . injector , injectionPoint , errorsForMember ) ; [[box]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 378 ---------------------------------------------
Returns a new instance of the given annotation strategy. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > type , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( type , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[function]] ( Class < T > type , AnnotationStrategy [[c]] ) { return new Key < T > ( type , [[c]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 379 ---------------------------------------------
Prune the stacktrace from the exception. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } t . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[main]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > [[a]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { [[a]] . add ( element ) ; } } t . setStackTrace ( [[a]] . toArray ( new StackTraceElement [ [[a]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 380 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 353 / 4 / 380:  38%|███▊      | 380/1000 [1:47:50<2:55:57, 17.03s/it][Succeeded / Failed / Skipped / Total] 23 / 353 / 4 / 380:  38%|███▊      | 381/1000 [1:48:23<2:56:06, 17.07s/it][Succeeded / Failed / Skipped / Total] 23 / 354 / 4 / 381:  38%|███▊      | 381/1000 [1:48:23<2:56:06, 17.07s/it][Succeeded / Failed / Skipped / Total] 23 / 354 / 4 / 381:  38%|███▊      | 382/1000 [1:48:54<2:56:11, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 355 / 4 / 382:  38%|███▊      | 382/1000 [1:48:54<2:56:11, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 355 / 4 / 382:  38%|███▊      | 383/1000 [1:48:58<2:55:32, 17.07s/it][Succeeded / Failed / Skipped / Total] 23 / 356 / 4 / 383:  38%|███▊      | 383/1000 [1:48:58<2:55:32, 17.07s/it][Succeeded / Failed / Skipped / Total] 23 / 356 / 4 / 383:  38%|███▊      | 384/1000 [1:49:52<2:56:15, 17.17s/it][Succeeded / Failed / Skipped / Total] 23 / 357 / 4 / 384:  38%|███▊      | 384/1000 [1:49:52<2:56:15, 17.17s/it][Succeeded / Failed / Skipped / Total] 23 / 357 / 4 / 384:  38%|███▊      | 385/1000 [1:50:06<2:55:53, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 358 / 4 / 385:  38%|███▊      | 385/1000 [1:50:06<2:55:53, 17.16s/it][Succeeded / Failed / Skipped / Total] 23 / 358 / 4 / 385:  39%|███▊      | 386/1000 [1:50:09<2:55:12, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 359 / 4 / 386:  39%|███▊      | 386/1000 [1:50:09<2:55:12, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 359 / 4 / 386:  39%|███▊      | 387/1000 [1:50:25<2:54:55, 17.12s/it]Creates a message with the specified format and arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[test]] ( String [[array]] , Object ... [[true]] ) { return [[test]] ( null , [[array]] , [[true]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 381 ---------------------------------------------
Converts an object to an object. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [[convert]] ( Object [[o]] ) { ElementSource source = null ; if ( [[o]] instanceof ElementSource ) { source = ( ElementSource ) [[o]] ; [[o]] = source . getDeclaringSource ( ) ; } return [[convert]] ( [[o]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[when]] ( Object [[context]] ) { ElementSource source = null ; if ( [[context]] instanceof ElementSource ) { source = ( ElementSource ) [[context]] ; [[context]] = source . getDeclaringSource ( ) ; } return [[when]] ( [[context]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 382 ---------------------------------------------
Creates a message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[command]] ( Throwable [[variables]] , String messageFormat , Object ... [[example]] ) { return [[command]] ( [[variables]] , ImmutableList . of ( ) , messageFormat , [[example]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 383 ---------------------------------------------
Checks if the given class should be skipped. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[add]] ( String [[teacher]] ) { return ( parent != null && parent . shouldBeSkipped ( [[teacher]] ) ) || classNamesToSkip . contains ( [[teacher]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 384 ---------------------------------------------
Checks if the given constructor has all the required parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > [[type]] , Constructor < ? > [[constructor]] , List < Key < ? > > paramList , Errors [[errors]] ) throws ErrorsException { List < TypeLiteral < ? > > params = [[type]] . getParameterTypes ( [[constructor]] ) ; Annotation [ ] [ ] paramAnnotations = [[constructor]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[constructor]] , paramAnnotations [ p ++ ] , [[errors]] ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[to]] ( TypeLiteral < ? > [[programs]] , Constructor < ? > [[shows]] , List < Key < ? > > paramList , Errors [[et]] ) throws ErrorsException { List < TypeLiteral < ? > > params = [[programs]] . getParameterTypes ( [[shows]] ) ; Annotation [ ] [ ] paramAnnotations = [[shows]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[shows]] , paramAnnotations [ p ++ ] , [[et]] ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 385 ---------------------------------------------
Returns the source of the specified module class names. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[format]] ( List < String > moduleClassNames ) { Preconditions . checkNotNull ( moduleClassNames , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : moduleClassNames ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 386 ---------------------------------------------
Starts the remote JMX server. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[module]] ) ; manage ( [[args]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[rest]] ( String [ ] [[integer]] ) throws Exception { if ( [[integer]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[array]] = ( Module ) Class . forName ( [[integer]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( [[array]] ) ; manage ( [[integer]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 387 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 360 / 4 / 387:  39%|███▊      | 387/1000 [1:50:25<2:54:55, 17.12s/it][Succeeded / Failed / Skipped / Total] 23 / 360 / 4 / 387:  39%|███▉      | 388/1000 [1:50:36<2:54:28, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 361 / 4 / 388:  39%|███▉      | 388/1000 [1:50:36<2:54:28, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 361 / 4 / 388:  39%|███▉      | 389/1000 [1:50:54<2:54:11, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 362 / 4 / 389:  39%|███▉      | 389/1000 [1:50:54<2:54:11, 17.11s/it][Succeeded / Failed / Skipped / Total] 23 / 362 / 4 / 389:  39%|███▉      | 390/1000 [1:51:01<2:53:38, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 363 / 4 / 390:  39%|███▉      | 390/1000 [1:51:01<2:53:38, 17.08s/it][Succeeded / Failed / Skipped / Total] 23 / 363 / 4 / 390:  39%|███▉      | 391/1000 [1:51:01<2:52:55, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 363 / 5 / 391:  39%|███▉      | 391/1000 [1:51:01<2:52:55, 17.04s/it][Succeeded / Failed / Skipped / Total] 23 / 363 / 5 / 391:  39%|███▉      | 392/1000 [1:51:40<2:53:13, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 364 / 5 / 392:  39%|███▉      | 392/1000 [1:51:40<2:53:13, 17.09s/it][Succeeded / Failed / Skipped / Total] 23 / 364 / 5 / 392:  39%|███▉      | 393/1000 [1:51:41<2:52:30, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 365 / 5 / 393:  39%|███▉      | 393/1000 [1:51:41<2:52:30, 17.05s/it][Succeeded / Failed / Skipped / Total] 23 / 365 / 5 / 393:  39%|███▉      | 394/1000 [1:52:16<2:52:41, 17.10s/it]Creates a new instance of MembersInjectorImpl. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[load]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 388 ---------------------------------------------
Pushes a state onto the cache. --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > key , Object [[source]] ) { doPushState ( key , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[end]] ( com . google . inject . Key < ? > key , Object [[block]] ) { doPushState ( key , [[block]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[like]] ( final T [[first]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[first]] ; } @ Override public String toString ( ) { return String . valueOf ( [[first]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 390 ---------------------------------------------
Pushes the specified dependency onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[load]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . dependency ; this . dependency = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 391 ---------------------------------------------
Rethrows an unchecked exception. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
Gets the future task result.@param < T> the type parameter@param task the task@param logger the logger@return the future task result --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[print]] > [[print]] getFutureTaskResult ( RunStateRecordedFutureTask < [[print]] > task , Logger logger ) { [[print]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 393 ---------------------------------------------
Creates a new message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , List < Object > sources , String [[messageFormat]] , Object ... [[arguments]] ) { String [[message]] = format ( [[messageFormat]] , [[arguments]] ) ; return new Message ( sources , [[message]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[like]] ( Throwable cause , List < Object > sources , String [[destination]] , Object ... [[tree]] ) { String [[end]] = format ( [[destination]] , [[tree]] ) ; return new Message ( sources , [[end]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 394 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 366 / 5 / 394:  39%|███▉      | 394/1000 [1:52:16<2:52:41, 17.10s/it][Succeeded / Failed / Skipped / Total] 23 / 366 / 5 / 394:  40%|███▉      | 395/1000 [1:52:17<2:51:58, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 366 / 6 / 395:  40%|███▉      | 395/1000 [1:52:17<2:51:58, 17.06s/it][Succeeded / Failed / Skipped / Total] 23 / 366 / 6 / 395:  40%|███▉      | 396/1000 [1:52:19<2:51:19, 17.02s/it][Succeeded / Failed / Skipped / Total] 23 / 367 / 6 / 396:  40%|███▉      | 396/1000 [1:52:19<2:51:19, 17.02s/it][Succeeded / Failed / Skipped / Total] 23 / 367 / 6 / 396:  40%|███▉      | 397/1000 [1:52:40<2:51:07, 17.03s/it][Succeeded / Failed / Skipped / Total] 23 / 368 / 6 / 397:  40%|███▉      | 397/1000 [1:52:40<2:51:07, 17.03s/it][Succeeded / Failed / Skipped / Total] 23 / 368 / 6 / 397:  40%|███▉      | 398/1000 [1:52:59<2:50:54, 17.03s/it][Succeeded / Failed / Skipped / Total] 24 / 368 / 6 / 398:  40%|███▉      | 398/1000 [1:52:59<2:50:54, 17.03s/it][Succeeded / Failed / Skipped / Total] 24 / 368 / 6 / 398:  40%|███▉      | 399/1000 [1:53:10<2:50:27, 17.02s/it][Succeeded / Failed / Skipped / Total] 24 / 369 / 6 / 399:  40%|███▉      | 399/1000 [1:53:10<2:50:27, 17.02s/it][Succeeded / Failed / Skipped / Total] 24 / 369 / 6 / 399:  40%|████      | 400/1000 [1:53:13<2:49:49, 16.98s/it]Registers a processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( [[cmdCode]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[buffer]] ( CommandCode [[er]] , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( [[er]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[er]] , cmd2processors . get ( [[er]] ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( [[er]] , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 395 ---------------------------------------------
Returns the Url for the given URL. --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
Registers a default processor. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[test]] ( RemotingProcessor < ? > [[source]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[source]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 397 ---------------------------------------------
Adds a new connection event processor.@param type the event type@param processor the event processor --> [[[FAILED]]]

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( [[type]] ) ; if ( [[processorList]] == null ) { this . processors . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[processorList]] = this . processors . get ( [[type]] ) ; } [[processorList]] . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[fix]] ( ConnectionEventType [[filter]] , ConnectionEventProcessor [[domain]] ) { List < ConnectionEventProcessor > [[line]] = this . processors . get ( [[filter]] ) ; if ( [[line]] == null ) { this . processors . putIfAbsent ( [[filter]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; [[line]] = this . processors . get ( [[filter]] ) ; } [[line]] . add ( [[domain]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 398 ---------------------------------------------
Scans the connection pool. --> Notifies all connections that they have expired. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[scan]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void [[alert]] ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Decodes a protocol code. --> [[[FAILED]]]

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf [[in]] ) { if ( [[in]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[in]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[token]] ( ByteBuf [[stack]] ) { if ( [[stack]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[stack]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 400 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 24 / 370 / 6 / 400:  40%|████      | 400/1000 [1:53:13<2:49:49, 16.98s/it][Succeeded / Failed / Skipped / Total] 24 / 370 / 6 / 400:  40%|████      | 401/1000 [1:53:27<2:49:28, 16.98s/it][Succeeded / Failed / Skipped / Total] 25 / 370 / 6 / 401:  40%|████      | 401/1000 [1:53:27<2:49:28, 16.98s/it][Succeeded / Failed / Skipped / Total] 25 / 370 / 6 / 401:  40%|████      | 402/1000 [1:53:31<2:48:51, 16.94s/it][Succeeded / Failed / Skipped / Total] 25 / 371 / 6 / 402:  40%|████      | 402/1000 [1:53:31<2:48:51, 16.94s/it][Succeeded / Failed / Skipped / Total] 25 / 371 / 6 / 402:  40%|████      | 403/1000 [1:53:37<2:48:19, 16.92s/it][Succeeded / Failed / Skipped / Total] 25 / 372 / 6 / 403:  40%|████      | 403/1000 [1:53:37<2:48:19, 16.92s/it][Succeeded / Failed / Skipped / Total] 25 / 372 / 6 / 403:  40%|████      | 404/1000 [1:53:37<2:47:38, 16.88s/it][Succeeded / Failed / Skipped / Total] 25 / 372 / 7 / 404:  40%|████      | 404/1000 [1:53:37<2:47:38, 16.88s/it][Succeeded / Failed / Skipped / Total] 25 / 372 / 7 / 404:  40%|████      | 405/1000 [1:53:51<2:47:15, 16.87s/it][Succeeded / Failed / Skipped / Total] 25 / 373 / 7 / 405:  40%|████      | 405/1000 [1:53:51<2:47:15, 16.87s/it][Succeeded / Failed / Skipped / Total] 25 / 373 / 7 / 405:  41%|████      | 406/1000 [1:53:56<2:46:41, 16.84s/it]Formats the given collection of messages into a human readable string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[formatMessages]] ( String [[heading]] , Collection < Message > [[errorMessages]] ) { Formatter fmt = new Formatter ( ) . format ( [[heading]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[contains]] ( String [[index]] , Collection < Message > [[object]] ) { Formatter fmt = new Formatter ( ) . format ( [[index]] ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[object]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[object]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int i = dependencies . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = dependencies . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[object]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[object]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 401 ---------------------------------------------
Removes a task from the pool. --> Calls the pool. --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[call]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 402 ---------------------------------------------
Called when a connection event occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onEvent]] ( ConnectionEventType [[type]] , String [[remoteAddr]] , Connection conn ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( [[type]] ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( [[remoteAddr]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void [[include]] ( ConnectionEventType [[ception]] , String [[field]] , Connection conn ) { List < ConnectionEventProcessor > [[f]] = this . processors . get ( [[ception]] ) ; if ( [[f]] != null ) { for ( ConnectionEventProcessor processor : [[f]] ) { processor . onEvent ( [[field]] , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 403 ---------------------------------------------
Creates a new instance of the given provider. --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[provider]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[end]] ( Provider < ? extends T > [[commitment]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[commitment]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 404 ---------------------------------------------
Closes the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
Returns the processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( [[cmdCode]] ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[execute]] ( CommandCode [[language]] ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( [[language]] ) ; if ( processor != null ) { return processor ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 406 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 374 / 7 / 406:  41%|████      | 406/1000 [1:53:56<2:46:41, 16.84s/it][Succeeded / Failed / Skipped / Total] 25 / 374 / 7 / 406:  41%|████      | 407/1000 [1:54:05<2:46:14, 16.82s/it][Succeeded / Failed / Skipped / Total] 25 / 375 / 7 / 407:  41%|████      | 407/1000 [1:54:05<2:46:14, 16.82s/it][Succeeded / Failed / Skipped / Total] 25 / 375 / 7 / 407:  41%|████      | 408/1000 [1:54:16<2:45:48, 16.81s/it][Succeeded / Failed / Skipped / Total] 26 / 375 / 7 / 408:  41%|████      | 408/1000 [1:54:16<2:45:48, 16.81s/it][Succeeded / Failed / Skipped / Total] 26 / 375 / 7 / 408:  41%|████      | 409/1000 [1:54:27<2:45:23, 16.79s/it][Succeeded / Failed / Skipped / Total] 26 / 376 / 7 / 409:  41%|████      | 409/1000 [1:54:27<2:45:23, 16.79s/it][Succeeded / Failed / Skipped / Total] 26 / 376 / 7 / 409:  41%|████      | 410/1000 [1:54:44<2:45:06, 16.79s/it][Succeeded / Failed / Skipped / Total] 26 / 377 / 7 / 410:  41%|████      | 410/1000 [1:54:44<2:45:06, 16.79s/it][Succeeded / Failed / Skipped / Total] 26 / 377 / 7 / 410:  41%|████      | 411/1000 [1:55:06<2:44:57, 16.80s/it][Succeeded / Failed / Skipped / Total] 27 / 377 / 7 / 411:  41%|████      | 411/1000 [1:55:06<2:44:57, 16.80s/it][Succeeded / Failed / Skipped / Total] 27 / 377 / 7 / 411:  41%|████      | 412/1000 [1:55:29<2:44:49, 16.82s/it][Succeeded / Failed / Skipped / Total] 27 / 378 / 7 / 412:  41%|████      | 412/1000 [1:55:29<2:44:49, 16.82s/it][Succeeded / Failed / Skipped / Total] 27 / 378 / 7 / 412:  41%|████▏     | 413/1000 [1:55:32<2:44:12, 16.79s/it]Create a connection and heal if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[end]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 407 ---------------------------------------------
Get and create a connection if it doesn't exist. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[exception]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 408 ---------------------------------------------
Create a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param syncCreateNumWhenNotWarmup the sync create number when not warmup@throws RemotingException --> Creates a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param data the data --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int [[syncCreateNumWhenNotWarmup]] ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( [[syncCreateNumWhenNotWarmup]] < 0 || [[syncCreateNumWhenNotWarmup]] > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int [[data]] ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( [[data]] < 0 || [[data]] > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 409 ---------------------------------------------
Called when a connection is closed. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[list]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 410 ---------------------------------------------
Gets all connections.@param <String> the type parameter@param <List<Connection>> the type parameter@return the all connections --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[change]] ( ) { Map < String , List < Connection > > [[end]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { [[end]] . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return [[end]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 411 ---------------------------------------------
E heal if needed --> Generates a random URL. --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[random]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 412 ---------------------------------------------
Associates the specified attribute with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String [[key]] , Object value ) { return attributes . putIfAbsent ( [[key]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[element]] ( String [[entity]] , Object value ) { return attributes . putIfAbsent ( [[entity]] , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 413 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 27 / 379 / 7 / 413:  41%|████▏     | 413/1000 [1:55:32<2:44:12, 16.79s/it][Succeeded / Failed / Skipped / Total] 27 / 379 / 7 / 413:  41%|████▏     | 414/1000 [1:55:58<2:44:09, 16.81s/it][Succeeded / Failed / Skipped / Total] 28 / 379 / 7 / 414:  41%|████▏     | 414/1000 [1:55:58<2:44:09, 16.81s/it][Succeeded / Failed / Skipped / Total] 28 / 379 / 7 / 414:  42%|████▏     | 415/1000 [1:56:02<2:43:34, 16.78s/it][Succeeded / Failed / Skipped / Total] 29 / 379 / 7 / 415:  42%|████▏     | 415/1000 [1:56:02<2:43:34, 16.78s/it][Succeeded / Failed / Skipped / Total] 29 / 379 / 7 / 415:  42%|████▏     | 416/1000 [1:56:22<2:43:22, 16.79s/it][Succeeded / Failed / Skipped / Total] 29 / 380 / 7 / 416:  42%|████▏     | 416/1000 [1:56:22<2:43:22, 16.79s/it][Succeeded / Failed / Skipped / Total] 29 / 380 / 7 / 416:  42%|████▏     | 417/1000 [1:57:01<2:43:36, 16.84s/it][Succeeded / Failed / Skipped / Total] 29 / 381 / 7 / 417:  42%|████▏     | 417/1000 [1:57:01<2:43:36, 16.84s/it][Succeeded / Failed / Skipped / Total] 29 / 381 / 7 / 417:  42%|████▏     | 418/1000 [1:57:10<2:43:09, 16.82s/it]Closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[compare]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 414 ---------------------------------------------
Debug logging. --> Sends a command to the server. --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[console]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 415 ---------------------------------------------
Dispatches the command to the user processor. --> Loads the mode. --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[load]] ( RemotingContext ctx , RpcRequestCommand [[mode]] ) { final int id = [[mode]] . getId ( ) ; final byte type = [[mode]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 416 ---------------------------------------------
Registers a user processor.@param processor The user processor.@param userProcessors The user processors. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) [[processor]] , userProcessors ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[preProcessor]] = userProcessors . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( [[preProcessor]] != null ) { String errMsg = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[are]] ( UserProcessor < ? > [[variable]] , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == [[variable]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[variable]] instanceof MultiInterestUserProcessor ) { [[are]] ( ( MultiInterestUserProcessor ) [[variable]] , userProcessors ) ; } else { if ( StringUtils . isBlank ( [[variable]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[context]] = userProcessors . putIfAbsent ( [[variable]] . interest ( ) , [[variable]] ) ; if ( [[context]] != null ) { String errMsg = "Processor with interest key [" + [[variable]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 417 ---------------------------------------------
Registers a user processor with the rpc server. --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[load]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[array]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[array]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 30 / 381 / 7 / 418:  42%|████▏     | 418/1000 [1:57:10<2:43:09, 16.82s/it][Succeeded / Failed / Skipped / Total] 30 / 381 / 7 / 418:  42%|████▏     | 419/1000 [1:57:56<2:43:32, 16.89s/it][Succeeded / Failed / Skipped / Total] 30 / 382 / 7 / 419:  42%|████▏     | 419/1000 [1:57:56<2:43:32, 16.89s/it][Succeeded / Failed / Skipped / Total] 30 / 382 / 7 / 419:  42%|████▏     | 420/1000 [1:58:21<2:43:26, 16.91s/it][Succeeded / Failed / Skipped / Total] 31 / 382 / 7 / 420:  42%|████▏     | 420/1000 [1:58:21<2:43:26, 16.91s/it][Succeeded / Failed / Skipped / Total] 31 / 382 / 7 / 420:  42%|████▏     | 421/1000 [1:58:21<2:42:46, 16.87s/it][Succeeded / Failed / Skipped / Total] 31 / 382 / 8 / 421:  42%|████▏     | 421/1000 [1:58:21<2:42:46, 16.87s/it][Succeeded / Failed / Skipped / Total] 31 / 382 / 8 / 421:  42%|████▏     | 422/1000 [1:58:31<2:42:20, 16.85s/it][Succeeded / Failed / Skipped / Total] 32 / 382 / 8 / 422:  42%|████▏     | 422/1000 [1:58:31<2:42:20, 16.85s/it][Succeeded / Failed / Skipped / Total] 32 / 382 / 8 / 422:  42%|████▏     | 423/1000 [1:58:42<2:41:55, 16.84s/it][Succeeded / Failed / Skipped / Total] 32 / 383 / 8 / 423:  42%|████▏     | 423/1000 [1:58:42<2:41:55, 16.84s/it][Succeeded / Failed / Skipped / Total] 32 / 383 / 8 / 423:  42%|████▏     | 424/1000 [1:58:43<2:41:17, 16.80s/it]Pre-processes a request command. --> Sets the arrival time for the given command. --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] , long currentTimestamp ) { [[ctx]] . setArriveTimestamp ( [[cmd]] . getArriveTime ( ) ) ; [[ctx]] . setTimeout ( [[cmd]] . getTimeout ( ) ) ; [[ctx]] . setRpcCommandType ( [[cmd]] . getType ( ) ) ; [[ctx]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - [[cmd]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[assignment]] ( RemotingContext [[command]] , RpcRequestCommand [[task]] , long currentTimestamp ) { [[command]] . setArriveTimestamp ( [[task]] . getArriveTime ( ) ) ; [[command]] . setTimeout ( [[task]] . getTimeout ( ) ) ; [[command]] . setRpcCommandType ( [[task]] . getType ( ) ) ; [[command]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - [[task]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 419 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[oneway]] ( final Connection [[conn]] , final RemotingCommand request ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[begin]] ( final Connection [[support]] , final RemotingCommand request ) { try { [[support]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[support]] . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[support]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[support]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 420 ---------------------------------------------
Converts a value into a bit set.@param value the value to convert.@return a bit set. --> Creates a sequence of bits for an event. --> Socre: 1.0

[[[[Adv]]]]: public static BitSet [[toBitSet]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[bs]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[bs]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[bs]] ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet [[event]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet [[sequence]] = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { [[sequence]] . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return [[sequence]] ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 421 ---------------------------------------------
Stops this connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Adds a new reconnect task. --> Connects to the specified URL. --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[apache]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 423 ---------------------------------------------
Converts a BitSet to a byte.@param bs the BitSet to convert@return the byte value --> [[[FAILED]]]

[[[[Adv]]]]: public static byte toByte ( BitSet [[bs]] ) { int [[value]] = 0 ; for ( int i = 0 ; i < [[bs]] . length ( ) ; ++ i ) { if ( [[bs]] . get ( i ) ) { [[value]] += 1 << i ; } } if ( [[bs]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + [[bs]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet [[bits]] ) { int [[g]] = 0 ; for ( int i = 0 ; i < [[bits]] . length ( ) ; ++ i ) { if ( [[bits]] . get ( i ) ) { [[g]] += 1 << i ; } } if ( [[bits]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[g]] + " generated according to bit set " + [[bits]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[g]] ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 383 / 8 / 424:  42%|████▏     | 424/1000 [1:58:43<2:41:17, 16.80s/it][Succeeded / Failed / Skipped / Total] 33 / 383 / 8 / 424:  42%|████▎     | 425/1000 [1:58:53<2:40:50, 16.78s/it][Succeeded / Failed / Skipped / Total] 33 / 384 / 8 / 425:  42%|████▎     | 425/1000 [1:58:53<2:40:50, 16.78s/it][Succeeded / Failed / Skipped / Total] 33 / 384 / 8 / 425:  43%|████▎     | 426/1000 [1:58:54<2:40:13, 16.75s/it][Succeeded / Failed / Skipped / Total] 33 / 384 / 9 / 426:  43%|████▎     | 426/1000 [1:58:54<2:40:13, 16.75s/it][Succeeded / Failed / Skipped / Total] 33 / 384 / 9 / 426:  43%|████▎     | 427/1000 [1:59:02<2:39:45, 16.73s/it][Succeeded / Failed / Skipped / Total] 34 / 384 / 9 / 427:  43%|████▎     | 427/1000 [1:59:02<2:39:45, 16.73s/it][Succeeded / Failed / Skipped / Total] 34 / 384 / 9 / 427:  43%|████▎     | 428/1000 [1:59:04<2:39:08, 16.69s/it][Succeeded / Failed / Skipped / Total] 34 / 385 / 9 / 428:  43%|████▎     | 428/1000 [1:59:04<2:39:08, 16.69s/it][Succeeded / Failed / Skipped / Total] 34 / 385 / 9 / 428:  43%|████▎     | 429/1000 [1:59:05<2:38:30, 16.66s/it]Deserialize request command.@param ctx the remoting context@param cmd the command@param level the level@return true, if successful --> Add an RpcRequestCommand@param ator@param level@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] , int level ) { boolean [[result]] ; try { [[cmd]] . deserialize ( level ) ; [[result]] = "[[True]]" == "[[True]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[cmd]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( [[ctx]] , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; [[result]] = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[cmd]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( [[ctx]] , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , t , errMsg ) ) ; [[result]] = "False" != "False" ; } return [[result]] ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[add]] ( RemotingContext [[ator]] , RpcRequestCommand [[a]] , int level ) { boolean [[add]] ; try { [[a]] . deserialize ( level ) ; [[add]] = "[[a]]" == "[[a]]" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[a]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( [[ator]] , [[a]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[a]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; [[add]] = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[a]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( [[ator]] , [[a]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[a]] . getId ( ) , t , errMsg ) ) ; [[add]] = "False" != "False" ; } return [[add]] ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 425 ---------------------------------------------
Executes the specified message. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService [[defaultExecutor]] ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { [[defaultExecutor]] . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService [[c]] ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { [[c]] . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 426 ---------------------------------------------
Returns the boolean value associated with the specified key, or the defaultvalue if the key does not exist. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 427 ---------------------------------------------
Monitors connections.@param connPools the connections --> Called when a connection pool becomes available. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void [[console]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 428 ---------------------------------------------
Sends a request timeout command to the server. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand [[cmd]] , long [[currentTimestamp]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , [[currentTimestamp]] , [[cmd]] . getArriveTime ( ) , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String [[remoteAddr]] = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { [[remoteAddr]] = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , [[remoteAddr]] , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[ask]] ( final RpcRequestCommand [[end]] , long [[call]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[end]] . getId ( ) , [[call]] , [[end]] . getArriveTime ( ) , ( [[call]] - [[end]] . getArriveTime ( ) ) , [[end]] . getTimeout ( ) ) ; } String [[call]] = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { [[call]] = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[end]] . getId ( ) , [[call]] , ( [[call]] - [[end]] . getArriveTime ( ) ) , [[end]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 429 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 385 / 9 / 429:  43%|████▎     | 429/1000 [1:59:05<2:38:30, 16.66s/it][Succeeded / Failed / Skipped / Total] 35 / 385 / 9 / 429:  43%|████▎     | 430/1000 [1:59:15<2:38:05, 16.64s/it][Succeeded / Failed / Skipped / Total] 36 / 385 / 9 / 430:  43%|████▎     | 430/1000 [1:59:15<2:38:05, 16.64s/it][Succeeded / Failed / Skipped / Total] 36 / 385 / 9 / 430:  43%|████▎     | 431/1000 [1:59:31<2:37:47, 16.64s/it][Succeeded / Failed / Skipped / Total] 37 / 385 / 9 / 431:  43%|████▎     | 431/1000 [1:59:31<2:37:47, 16.64s/it][Succeeded / Failed / Skipped / Total] 37 / 385 / 9 / 431:  43%|████▎     | 432/1000 [1:59:36<2:37:15, 16.61s/it][Succeeded / Failed / Skipped / Total] 38 / 385 / 9 / 432:  43%|████▎     | 432/1000 [1:59:36<2:37:15, 16.61s/it][Succeeded / Failed / Skipped / Total] 38 / 385 / 9 / 432:  43%|████▎     | 433/1000 [2:00:17<2:37:30, 16.67s/it][Succeeded / Failed / Skipped / Total] 38 / 386 / 9 / 433:  43%|████▎     | 433/1000 [2:00:17<2:37:30, 16.67s/it][Succeeded / Failed / Skipped / Total] 38 / 386 / 9 / 433:  43%|████▎     | 434/1000 [2:00:30<2:37:09, 16.66s/it][Succeeded / Failed / Skipped / Total] 38 / 387 / 9 / 434:  43%|████▎     | 434/1000 [2:00:30<2:37:09, 16.66s/it][Succeeded / Failed / Skipped / Total] 38 / 387 / 9 / 434:  44%|████▎     | 435/1000 [2:00:48<2:36:54, 16.66s/it][Succeeded / Failed / Skipped / Total] 39 / 387 / 9 / 435:  44%|████▎     | 435/1000 [2:00:48<2:36:54, 16.66s/it][Succeeded / Failed / Skipped / Total] 39 / 387 / 9 / 435:  44%|████▎     | 436/1000 [2:01:16<2:36:52, 16.69s/it][Succeeded / Failed / Skipped / Total] 40 / 387 / 9 / 436:  44%|████▎     | 436/1000 [2:01:16<2:36:52, 16.69s/it][Succeeded / Failed / Skipped / Total] 40 / 387 / 9 / 436:  44%|████▎     | 437/1000 [2:01:27<2:36:28, 16.68s/it]Closes a list of connections that are no longer needed.@param lastSelectConnect@param serviceOffConnections@throws InterruptedException --> Called when an exception occurs. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[exception]] ( Connection lastSelectConnect , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != lastSelectConnect ) { if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( lastSelectConnect . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( lastSelectConnect ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( lastSelectConnect . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 430 ---------------------------------------------
Log a message at the INFO level. --> Asserts that the given address is a valid address. --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[assume]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 431 ---------------------------------------------
Determines whether or not the request timed out. --> Calls the rpc command. --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[call]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 432 ---------------------------------------------
Returns a random connection.@param conns a list of connections@return a random connection --> Returns the index of the specified connections.@param conns The connections.@return The index. --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[index]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 433 ---------------------------------------------
Returns the user processor for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[save]] ( String className ) { return StringUtils . isBlank ( className ) ? null : this . userProcessors . get ( className ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 434 ---------------------------------------------
Returns the value for the specified key, or null if the key does not exist. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[include]] ( String [[properties]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[properties]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 435 ---------------------------------------------
Gets the value associated with the given key.@param key the key@param defaultIfNotFound the default value@return the value associated with the given key --> Retrieves the value of the specified key from the command line. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] get ( String key , [[T]] defaultIfNotFound ) { return this . [[context]] . get ( key ) != null ? ( [[T]] ) this . [[context]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[keys]] > [[keys]] get ( String key , [[keys]] defaultIfNotFound ) { return this . [[command]] . get ( key ) != null ? ( [[keys]] ) this . [[command]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 436 ---------------------------------------------
Formats a detail error message. --> Converts an RpcResponseCommand to a string. --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[result]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 388 / 9 / 437:  44%|████▎     | 437/1000 [2:01:27<2:36:28, 16.68s/it][Succeeded / Failed / Skipped / Total] 40 / 388 / 9 / 437:  44%|████▍     | 438/1000 [2:01:32<2:35:56, 16.65s/it][Succeeded / Failed / Skipped / Total] 40 / 389 / 9 / 438:  44%|████▍     | 438/1000 [2:01:32<2:35:56, 16.65s/it][Succeeded / Failed / Skipped / Total] 40 / 389 / 9 / 438:  44%|████▍     | 439/1000 [2:01:47<2:35:38, 16.65s/it][Succeeded / Failed / Skipped / Total] 40 / 390 / 9 / 439:  44%|████▍     | 439/1000 [2:01:47<2:35:38, 16.65s/it][Succeeded / Failed / Skipped / Total] 40 / 390 / 9 / 439:  44%|████▍     | 440/1000 [2:02:43<2:36:11, 16.73s/it][Succeeded / Failed / Skipped / Total] 40 / 391 / 9 / 440:  44%|████▍     | 440/1000 [2:02:43<2:36:11, 16.73s/it][Succeeded / Failed / Skipped / Total] 40 / 391 / 9 / 440:  44%|████▍     | 441/1000 [2:02:52<2:35:45, 16.72s/it][Succeeded / Failed / Skipped / Total] 40 / 392 / 9 / 441:  44%|████▍     | 441/1000 [2:02:52<2:35:45, 16.72s/it][Succeeded / Failed / Skipped / Total] 40 / 392 / 9 / 441:  44%|████▍     | 442/1000 [2:03:15<2:35:36, 16.73s/it][Succeeded / Failed / Skipped / Total] 40 / 393 / 9 / 442:  44%|████▍     | 442/1000 [2:03:15<2:35:36, 16.73s/it][Succeeded / Failed / Skipped / Total] 40 / 393 / 9 / 442:  44%|████▍     | 443/1000 [2:03:18<2:35:02, 16.70s/it]Converts a response command to a response object. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[c]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 438 ---------------------------------------------
Filters a list of connections. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > [[serviceOffConnections]] = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[filteredConnections]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { [[serviceOffConnections]] . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_OFF , [[serviceOffConnections]] ) ; return [[filteredConnections]] ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[remove]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > [[bridges]] = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[connects]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { [[bridges]] . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } [[connects]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[connects]] . put ( Configs . CONN_SERVICE_STATUS_OFF , [[bridges]] ) ; return [[connects]] ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 439 ---------------------------------------------
Resolves a response object.@param responsethe response command@param addrthe address@return the response object@throws RemotingException --> [[[FAILED]]]

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[where]] ( ResponseCommand [[word]] , String addr ) throws RemotingException { preProcess ( [[word]] , addr ) ; if ( [[word]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[word]] ) ; } else { String [[tag]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[word]] . getResponseStatus ( ) , addr , [[word]] . getId ( ) ) ; logger . warn ( [[tag]] ) ; if ( [[word]] . getCause ( ) != null ) { throw new InvokeException ( [[tag]] , [[word]] . getCause ( ) ) ; } else { throw new InvokeException ( [[tag]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 440 ---------------------------------------------
Creates an epoll event loop group. --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[nThreads]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , threadFactory ) : new NioEventLoopGroup ( [[nThreads]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[date]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[date]] , threadFactory ) : new NioEventLoopGroup ( [[date]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 441 ---------------------------------------------
Converts a response command into an exception. --> [[[FAILED]]]

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[call]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 442 ---------------------------------------------
Parse the remote address from the specified channel.@param channel the channel to parse.@return the remote address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[direct]] ( final Channel [[message]] ) { if ( null == [[message]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[message]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 443 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 393 / 9 / 443:  44%|████▍     | 443/1000 [2:03:18<2:35:02, 16.70s/it][Succeeded / Failed / Skipped / Total] 41 / 393 / 9 / 443:  44%|████▍     | 444/1000 [2:03:21<2:34:28, 16.67s/it][Succeeded / Failed / Skipped / Total] 41 / 394 / 9 / 444:  44%|████▍     | 444/1000 [2:03:21<2:34:28, 16.67s/it][Succeeded / Failed / Skipped / Total] 41 / 394 / 9 / 444:  44%|████▍     | 445/1000 [2:03:31<2:34:02, 16.65s/it][Succeeded / Failed / Skipped / Total] 41 / 395 / 9 / 445:  44%|████▍     | 445/1000 [2:03:31<2:34:02, 16.65s/it][Succeeded / Failed / Skipped / Total] 41 / 395 / 9 / 445:  45%|████▍     | 446/1000 [2:04:12<2:34:17, 16.71s/it][Succeeded / Failed / Skipped / Total] 41 / 396 / 9 / 446:  45%|████▍     | 446/1000 [2:04:12<2:34:17, 16.71s/it][Succeeded / Failed / Skipped / Total] 41 / 396 / 9 / 446:  45%|████▍     | 447/1000 [2:04:33<2:34:05, 16.72s/it][Succeeded / Failed / Skipped / Total] 41 / 397 / 9 / 447:  45%|████▍     | 447/1000 [2:04:33<2:34:05, 16.72s/it][Succeeded / Failed / Skipped / Total] 41 / 397 / 9 / 447:  45%|████▍     | 448/1000 [2:04:34<2:33:29, 16.68s/it][Succeeded / Failed / Skipped / Total] 41 / 398 / 9 / 448:  45%|████▍     | 448/1000 [2:04:34<2:33:29, 16.68s/it][Succeeded / Failed / Skipped / Total] 41 / 398 / 9 / 448:  45%|████▍     | 449/1000 [2:04:36<2:32:55, 16.65s/it][Succeeded / Failed / Skipped / Total] 41 / 399 / 9 / 449:  45%|████▍     | 449/1000 [2:04:36<2:32:55, 16.65s/it][Succeeded / Failed / Skipped / Total] 41 / 399 / 9 / 449:  45%|████▌     | 450/1000 [2:04:48<2:32:32, 16.64s/it]Prints information about a connection trace. --> Prints information about a connection. --> Socre: 1.0

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String [[traceId]] , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer [[sourcePort]] = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( [[traceId]] ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( [[sourcePort]] ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String [[basic]] , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer [[base]] = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( [[basic]] ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( [[base]] ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 444 ---------------------------------------------
Converts a request to a remoting command. --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object [[request]] , Connection conn , InvokeContext [[invokeContext]] , int [[timeoutMillis]] ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != [[invokeContext]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[execute]] ( Object [[command]] , Connection conn , InvokeContext [[al]] , int [[false]] ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[command]] ) ; if ( null != [[al]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 445 ---------------------------------------------
Creates a new RpcServerException. --> [[[FAILED]]]

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 446 ---------------------------------------------
Parses a channel's local address.@param channel the channel to parse.@return the parsed address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[channel]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[foo]] ( final Channel [[path]] ) { if ( null == [[path]] ) { return StringUtils . EMPTY ; } final SocketAddress local = [[path]] . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the remote host name from the channel.@param channel the channel.@return the remote host name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[end]] ( final Channel [[key]] ) { if ( null == [[key]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[key]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Parse an IP address from the specified channel.@param channel the channel to parse.@return the IP address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String parseRemoteIP ( final Channel [[address]] ) { if ( null == [[address]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[null]] = ( InetSocketAddress ) [[address]] . remoteAddress ( ) ; if ( [[null]] != null ) { return [[null]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Parses an IP address from the specified channel.@param channel the channel@return the IP address --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[object]] ( final Channel [[object]] ) { if ( null == [[object]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[end]] = ( InetSocketAddress ) [[object]] . localAddress ( ) ; if ( [[end]] != null ) { return [[end]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 42 / 399 / 9 / 450:  45%|████▌     | 450/1000 [2:04:48<2:32:32, 16.64s/it][Succeeded / Failed / Skipped / Total] 42 / 399 / 9 / 450:  45%|████▌     | 451/1000 [2:05:05<2:32:15, 16.64s/it][Succeeded / Failed / Skipped / Total] 42 / 400 / 9 / 451:  45%|████▌     | 451/1000 [2:05:05<2:32:15, 16.64s/it][Succeeded / Failed / Skipped / Total] 42 / 400 / 9 / 451:  45%|████▌     | 452/1000 [2:05:26<2:32:05, 16.65s/it][Succeeded / Failed / Skipped / Total] 42 / 401 / 9 / 452:  45%|████▌     | 452/1000 [2:05:26<2:32:05, 16.65s/it][Succeeded / Failed / Skipped / Total] 42 / 401 / 9 / 452:  45%|████▌     | 453/1000 [2:05:36<2:31:40, 16.64s/it][Succeeded / Failed / Skipped / Total] 42 / 402 / 9 / 453:  45%|████▌     | 453/1000 [2:05:36<2:31:40, 16.64s/it][Succeeded / Failed / Skipped / Total] 42 / 402 / 9 / 453:  45%|████▌     | 454/1000 [2:05:44<2:31:13, 16.62s/it][Succeeded / Failed / Skipped / Total] 42 / 403 / 9 / 454:  45%|████▌     | 454/1000 [2:05:44<2:31:13, 16.62s/it][Succeeded / Failed / Skipped / Total] 42 / 403 / 9 / 454:  46%|████▌     | 455/1000 [2:05:46<2:30:39, 16.59s/it][Succeeded / Failed / Skipped / Total] 42 / 404 / 9 / 455:  46%|████▌     | 455/1000 [2:05:46<2:30:39, 16.59s/it][Succeeded / Failed / Skipped / Total] 42 / 404 / 9 / 455:  46%|████▌     | 456/1000 [2:06:04<2:30:24, 16.59s/it]Adds a connection. --> Adds an array of connections to the pool. --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[array]] ) { markAccess ( ) ; if ( null == [[array]] ) { return ; } boolean res = this . conns . addIfAbsent ( [[array]] ) ; if ( res ) { [[array]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 451 ---------------------------------------------
Parses the remote port from the channel.@param channel the channel to parse.@return the remote port, or -1 if the channel is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[loop]] ( final Channel [[line]] ) { if ( null == [[line]] ) { return - 1 ; } final InetSocketAddress [[sequence]] = ( InetSocketAddress ) [[line]] . remoteAddress ( ) ; if ( [[sequence]] != null ) { return [[sequence]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Parses a channel's local port.@param channelThe channel to parse.@return The parsed port. --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[read]] ( final Channel [[header]] ) { if ( null == [[header]] ) { return - 1 ; } final InetSocketAddress [[i]] = ( InetSocketAddress ) [[header]] . localAddress ( ) ; if ( [[i]] != null ) { return [[i]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 453 ---------------------------------------------
Removes and tries to close the supplied connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[assume]] ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 454 ---------------------------------------------
Returns the custom serializer for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[fix]] ( String [[field]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[field]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 455 ---------------------------------------------
Invokes the specified request with the specified callback. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection [[conn]] , final RemotingCommand [[request]] , final InvokeCallback [[invokeCallback]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[conn]] , [[request]] , [[request]] . getInvokeContext ( ) , [[invokeCallback]] ) ; [[conn]] . addInvokeFuture ( future ) ; final int requestId = [[request]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[conn]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[conn]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[conn]] . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[cf]] ) throws Exception { if ( ! [[cf]] . isSuccess ( ) ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , [[cf]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[cf]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[move]] ( final Connection [[buffer]] , final RemotingCommand [[data]] , final InvokeCallback [[an]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[buffer]] , [[data]] , [[data]] . getInvokeContext ( ) , [[an]] ) ; [[buffer]] . addInvokeFuture ( future ) ; final int requestId = [[data]] . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[buffer]] . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[buffer]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[buffer]] . getChannel ( ) . writeAndFlush ( [[data]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[buffer]] ) throws Exception { if ( ! [[buffer]] . isSuccess ( ) ) { InvokeFuture f = [[buffer]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[buffer]] . getRemoteAddress ( ) , [[buffer]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[buffer]] . getChannel ( ) ) , [[buffer]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[buffer]] . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[buffer]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[buffer]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
[Succeeded / Failed / Skipped / Total] 43 / 404 / 9 / 456:  46%|████▌     | 456/1000 [2:06:04<2:30:24, 16.59s/it][Succeeded / Failed / Skipped / Total] 43 / 404 / 9 / 456:  46%|████▌     | 457/1000 [2:06:06<2:29:50, 16.56s/it][Succeeded / Failed / Skipped / Total] 43 / 405 / 9 / 457:  46%|████▌     | 457/1000 [2:06:06<2:29:50, 16.56s/it][Succeeded / Failed / Skipped / Total] 43 / 405 / 9 / 457:  46%|████▌     | 458/1000 [2:06:11<2:29:20, 16.53s/it][Succeeded / Failed / Skipped / Total] 43 / 406 / 9 / 458:  46%|████▌     | 458/1000 [2:06:11<2:29:20, 16.53s/it][Succeeded / Failed / Skipped / Total] 43 / 406 / 9 / 458:  46%|████▌     | 459/1000 [2:06:12<2:28:44, 16.50s/it][Succeeded / Failed / Skipped / Total] 43 / 406 / 10 / 459:  46%|████▌     | 459/1000 [2:06:12<2:28:44, 16.50s/it][Succeeded / Failed / Skipped / Total] 43 / 406 / 10 / 459:  46%|████▌     | 460/1000 [2:06:20<2:28:19, 16.48s/it][Succeeded / Failed / Skipped / Total] 44 / 406 / 10 / 460:  46%|████▌     | 460/1000 [2:06:20<2:28:19, 16.48s/it][Succeeded / Failed / Skipped / Total] 44 / 406 / 10 / 460:  46%|████▌     | 461/1000 [2:06:21<2:27:44, 16.45s/it][Succeeded / Failed / Skipped / Total] 44 / 406 / 11 / 461:  46%|████▌     | 461/1000 [2:06:21<2:27:44, 16.45s/it][Succeeded / Failed / Skipped / Total] 44 / 407 / 11 / 462:  46%|████▌     | 462/1000 [2:06:21<2:27:08, 16.41s/it][Succeeded / Failed / Skipped / Total] 44 / 407 / 11 / 462:  46%|████▋     | 463/1000 [2:06:23<2:26:35, 16.38s/it][Succeeded / Failed / Skipped / Total] 45 / 407 / 11 / 463:  46%|████▋     | 463/1000 [2:06:23<2:26:35, 16.38s/it]--------------------------------------------- Result 456 ---------------------------------------------
Start the connection monitor. --> Schedules the connection monitor. --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[buffer]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 457 ---------------------------------------------
Parse a socket address to host ip@param socketAddress@return --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress [[addr]] = [[addrs]] . getAddress ( ) ; if ( null != [[addr]] ) { return [[addr]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[set]] ( SocketAddress [[array]] ) { final InetSocketAddress [[assignment]] = ( InetSocketAddress ) [[array]] ; if ( [[assignment]] != null ) { InetAddress [[i]] = [[assignment]] . getAddress ( ) ; if ( null != [[i]] ) { return [[i]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 458 ---------------------------------------------
Returns the custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[load]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 459 ---------------------------------------------
Batch write.@param ws@param sockchannel@return@throws IOException --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
Retrieves a connection from this pool.@return the connection or <code>null</code> if none. --> Selects an element from this ring. --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . [[conns]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[conns]] ) ; if ( snapshot . size ( ) > 0 ) { return this . [[strategy]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[element]] ( ) { markAccess ( ) ; if ( null != this . [[key]] ) { List < Connection > snapshot = new ArrayList < Connection > ( this . [[key]] ) ; if ( snapshot . size ( ) > 0 ) { return this . [[ring]] . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 461 ---------------------------------------------
Validates a UTF-8 string. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 462 ---------------------------------------------
Registers a custom serializer for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[className]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[loop]] ( String [[end]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[end]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[end]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 463 ---------------------------------------------
Initializes the write buffer water mark. --> Alarm the channel. --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[alarm]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 464 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 46 / 407 / 11 / 464:  46%|████▋     | 464/1000 [2:06:24<2:26:01, 16.35s/it][Succeeded / Failed / Skipped / Total] 46 / 407 / 11 / 464:  46%|████▋     | 465/1000 [2:06:50<2:25:55, 16.37s/it][Succeeded / Failed / Skipped / Total] 47 / 407 / 11 / 465:  46%|████▋     | 465/1000 [2:06:50<2:25:55, 16.37s/it][Succeeded / Failed / Skipped / Total] 47 / 407 / 11 / 465:  47%|████▋     | 466/1000 [2:06:51<2:25:22, 16.33s/it][Succeeded / Failed / Skipped / Total] 48 / 407 / 11 / 466:  47%|████▋     | 466/1000 [2:06:51<2:25:22, 16.33s/it][Succeeded / Failed / Skipped / Total] 48 / 407 / 11 / 466:  47%|████▋     | 467/1000 [2:07:05<2:25:02, 16.33s/it][Succeeded / Failed / Skipped / Total] 48 / 408 / 11 / 467:  47%|████▋     | 467/1000 [2:07:05<2:25:02, 16.33s/it][Succeeded / Failed / Skipped / Total] 48 / 408 / 11 / 467:  47%|████▋     | 468/1000 [2:07:06<2:24:29, 16.30s/it][Succeeded / Failed / Skipped / Total] 48 / 409 / 11 / 468:  47%|████▋     | 468/1000 [2:07:06<2:24:29, 16.30s/it][Succeeded / Failed / Skipped / Total] 48 / 409 / 11 / 468:  47%|████▋     | 469/1000 [2:07:15<2:24:05, 16.28s/it][Succeeded / Failed / Skipped / Total] 49 / 409 / 11 / 469:  47%|████▋     | 469/1000 [2:07:15<2:24:05, 16.28s/it][Succeeded / Failed / Skipped / Total] 49 / 409 / 11 / 469:  47%|████▋     | 470/1000 [2:07:18<2:23:33, 16.25s/it][Succeeded / Failed / Skipped / Total] 50 / 409 / 11 / 470:  47%|████▋     | 470/1000 [2:07:18<2:23:33, 16.25s/it][Succeeded / Failed / Skipped / Total] 50 / 409 / 11 / 470:  47%|████▋     | 471/1000 [2:07:29<2:23:11, 16.24s/it][Succeeded / Failed / Skipped / Total] 51 / 409 / 11 / 471:  47%|████▋     | 471/1000 [2:07:29<2:23:11, 16.24s/it][Succeeded / Failed / Skipped / Total] 51 / 409 / 11 / 471:  47%|████▋     | 472/1000 [2:07:31<2:22:39, 16.21s/it]Determines whether or not the specified remote address is connected. --> Calls the remote endpoint. --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[call]] ( String remoteAddr ) { Url url = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 465 ---------------------------------------------
Translate the given maxpacketsize to the given realpacketsize. --> Ends an incomplete frame. --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[end]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 466 ---------------------------------------------
Sets the code of the sprite. --> Called after a loop. --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[after]] ( int [[loop]] ) { this . code = [[loop]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 467 ---------------------------------------------
Returns an implementation of the given opcode. --> [[[FAILED]]]

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[l]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 468 ---------------------------------------------
Registers a custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[code]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[call]] ( CommandCode [[program]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( [[program]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[program]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 469 ---------------------------------------------
Updates the payload. --> Generate an example of this function. --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[example]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 470 ---------------------------------------------
Translate the payload size limit for a single frame. --> Throws a LimitExceededException. --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[exception]] ( long [[end]] ) throws LimitExceededException { if ( [[end]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[end]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[end]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[end]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 471 ---------------------------------------------
Log a runtime exception. --> Called when a websocket error occurs. --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[copy]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 472 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 52 / 409 / 11 / 472:  47%|████▋     | 472/1000 [2:07:31<2:22:39, 16.21s/it][Succeeded / Failed / Skipped / Total] 52 / 409 / 11 / 472:  47%|████▋     | 473/1000 [2:07:32<2:22:06, 16.18s/it][Succeeded / Failed / Skipped / Total] 53 / 409 / 11 / 473:  47%|████▋     | 473/1000 [2:07:32<2:22:06, 16.18s/it][Succeeded / Failed / Skipped / Total] 53 / 409 / 11 / 473:  47%|████▋     | 474/1000 [2:07:53<2:21:54, 16.19s/it][Succeeded / Failed / Skipped / Total] 54 / 409 / 11 / 474:  47%|████▋     | 474/1000 [2:07:53<2:21:54, 16.19s/it][Succeeded / Failed / Skipped / Total] 54 / 409 / 11 / 474:  48%|████▊     | 475/1000 [2:07:55<2:21:23, 16.16s/it][Succeeded / Failed / Skipped / Total] 55 / 409 / 11 / 475:  48%|████▊     | 475/1000 [2:07:55<2:21:23, 16.16s/it][Succeeded / Failed / Skipped / Total] 55 / 409 / 11 / 475:  48%|████▊     | 476/1000 [2:08:03<2:20:58, 16.14s/it][Succeeded / Failed / Skipped / Total] 55 / 410 / 11 / 476:  48%|████▊     | 476/1000 [2:08:03<2:20:58, 16.14s/it][Succeeded / Failed / Skipped / Total] 55 / 410 / 11 / 476:  48%|████▊     | 477/1000 [2:08:32<2:20:56, 16.17s/it][Succeeded / Failed / Skipped / Total] 56 / 410 / 11 / 477:  48%|████▊     | 477/1000 [2:08:32<2:20:56, 16.17s/it][Succeeded / Failed / Skipped / Total] 56 / 410 / 11 / 477:  48%|████▊     | 478/1000 [2:08:36<2:20:26, 16.14s/it]Checks if the requested protocol matches the provided one. --> Formats a handshake state. --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[format]] ( String [[stack]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[stack]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 473 ---------------------------------------------
Generates the final key for the given input. --> Adds the given message digest to the message digest. --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[add]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[add]] ; try { [[add]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[add]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 474 ---------------------------------------------
Processes a continuous frame. --> Runs a websocket message. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[run]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 475 ---------------------------------------------
Checks the maximum size of the buffer. --> Links this payload to another payload. --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[link]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 476 ---------------------------------------------
Processes a binary message. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[fix]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 477 ---------------------------------------------
Returns the size of the byte buffer list. --> Draws an integer. --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[draw]] ( ) { long [[integer]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[integer]] += buffer . limit ( ) ; } } return [[integer]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 478 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 411 / 11 / 478:  48%|████▊     | 478/1000 [2:08:36<2:20:26, 16.14s/it][Succeeded / Failed / Skipped / Total] 56 / 411 / 11 / 478:  48%|████▊     | 479/1000 [2:08:56<2:20:15, 16.15s/it][Succeeded / Failed / Skipped / Total] 57 / 411 / 11 / 479:  48%|████▊     | 479/1000 [2:08:56<2:20:15, 16.15s/it][Succeeded / Failed / Skipped / Total] 57 / 411 / 11 / 479:  48%|████▊     | 480/1000 [2:09:00<2:19:46, 16.13s/it][Succeeded / Failed / Skipped / Total] 57 / 412 / 11 / 480:  48%|████▊     | 480/1000 [2:09:00<2:19:46, 16.13s/it][Succeeded / Failed / Skipped / Total] 57 / 412 / 11 / 480:  48%|████▊     | 481/1000 [2:09:09<2:19:21, 16.11s/it][Succeeded / Failed / Skipped / Total] 58 / 412 / 11 / 481:  48%|████▊     | 481/1000 [2:09:09<2:19:21, 16.11s/it][Succeeded / Failed / Skipped / Total] 58 / 412 / 11 / 481:  48%|████▊     | 482/1000 [2:09:09<2:18:48, 16.08s/it][Succeeded / Failed / Skipped / Total] 58 / 413 / 11 / 482:  48%|████▊     | 482/1000 [2:09:09<2:18:48, 16.08s/it][Succeeded / Failed / Skipped / Total] 58 / 413 / 11 / 482:  48%|████▊     | 483/1000 [2:09:11<2:18:17, 16.05s/it][Succeeded / Failed / Skipped / Total] 59 / 413 / 11 / 483:  48%|████▊     | 483/1000 [2:09:11<2:18:17, 16.05s/it][Succeeded / Failed / Skipped / Total] 59 / 413 / 11 / 483:  48%|████▊     | 484/1000 [2:09:12<2:17:44, 16.02s/it][Succeeded / Failed / Skipped / Total] 59 / 413 / 12 / 484:  48%|████▊     | 484/1000 [2:09:12<2:17:44, 16.02s/it][Succeeded / Failed / Skipped / Total] 59 / 413 / 12 / 484:  48%|████▊     | 485/1000 [2:09:25<2:17:25, 16.01s/it]Processes a frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[when]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 479 ---------------------------------------------
Decodes the contents of the specified socket buffer. --> Process an assertion message. --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[assertion]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 480 ---------------------------------------------
Processes a WebSocket frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[put]] ( WebSocketImpl [[profile]] , Framedata [[ge]] ) throws InvalidDataException { try { [[profile]] . getWebSocketListener ( ) . onWebsocketMessage ( [[profile]] , Charsetfunctions . stringUtf8 ( [[ge]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[profile]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 481 ---------------------------------------------
Flushes and closes the connection. --> Adds an invalid data exception. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[add]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 482 ---------------------------------------------
Processes a continuous frame sequence. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[log]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 483 ---------------------------------------------
Closes the connection. --> Calls HttpResponse. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[call]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 484 ---------------------------------------------
Resets the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 59 / 414 / 12 / 485:  48%|████▊     | 485/1000 [2:09:25<2:17:25, 16.01s/it][Succeeded / Failed / Skipped / Total] 59 / 414 / 12 / 485:  49%|████▊     | 486/1000 [2:09:33<2:17:01, 16.00s/it][Succeeded / Failed / Skipped / Total] 59 / 415 / 12 / 486:  49%|████▊     | 486/1000 [2:09:33<2:17:01, 16.00s/it][Succeeded / Failed / Skipped / Total] 59 / 415 / 12 / 486:  49%|████▊     | 487/1000 [2:09:47<2:16:43, 15.99s/it][Succeeded / Failed / Skipped / Total] 60 / 415 / 12 / 487:  49%|████▊     | 487/1000 [2:09:47<2:16:43, 15.99s/it][Succeeded / Failed / Skipped / Total] 60 / 415 / 12 / 487:  49%|████▉     | 488/1000 [2:09:53<2:16:16, 15.97s/it][Succeeded / Failed / Skipped / Total] 61 / 415 / 12 / 488:  49%|████▉     | 488/1000 [2:09:53<2:16:16, 15.97s/it][Succeeded / Failed / Skipped / Total] 61 / 415 / 12 / 488:  49%|████▉     | 489/1000 [2:10:05<2:15:56, 15.96s/it][Succeeded / Failed / Skipped / Total] 61 / 416 / 12 / 489:  49%|████▉     | 489/1000 [2:10:05<2:15:56, 15.96s/it][Succeeded / Failed / Skipped / Total] 61 / 416 / 12 / 489:  49%|████▉     | 490/1000 [2:10:14<2:15:33, 15.95s/it][Succeeded / Failed / Skipped / Total] 62 / 416 / 12 / 490:  49%|████▉     | 490/1000 [2:10:14<2:15:33, 15.95s/it][Succeeded / Failed / Skipped / Total] 62 / 416 / 12 / 490:  49%|████▉     | 491/1000 [2:10:16<2:15:03, 15.92s/it][Succeeded / Failed / Skipped / Total] 63 / 416 / 12 / 491:  49%|████▉     | 491/1000 [2:10:16<2:15:03, 15.92s/it][Succeeded / Failed / Skipped / Total] 63 / 416 / 12 / 491:  49%|████▉     | 492/1000 [2:10:19<2:14:33, 15.89s/it][Succeeded / Failed / Skipped / Total] 63 / 417 / 12 / 492:  49%|████▉     | 492/1000 [2:10:19<2:14:33, 15.89s/it]Connects to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[list]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 486 ---------------------------------------------
Sends the specified data to the client. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[frame]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[frame]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 487 ---------------------------------------------
Returns the port number for the given URI. --> Creates a WebSocket connection. --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[main]] ( ) { int port = uri . getPort ( ) ; if ( port == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return port ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 488 ---------------------------------------------
Translate the first line of the HTTP server handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Creates an ator from an array of strings. --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[ator]] ( String [ ] [[array]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 489 ---------------------------------------------
Processes a close frame. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[webSocketImpl]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[like]] ( WebSocketImpl [[video]] , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[video]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 490 ---------------------------------------------
Translate the first line of the HTTP client handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Creates an ator from an array of strings. --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[ator]] ( String [ ] [[array]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 491 ---------------------------------------------
Sets the connection lost timeout. --> Canned connection. --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int [[connectionLostTimeout]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[connectionLostTimeout]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[canned]] ( int [[canned]] ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( [[canned]] ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 492 ---------------------------------------------
Gets the payload from the byte buffer list. --> [[[FAILED]]]

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[fetch]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 493 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 64 / 417 / 12 / 493:  49%|████▉     | 493/1000 [2:10:19<2:14:01, 15.86s/it][Succeeded / Failed / Skipped / Total] 64 / 417 / 12 / 493:  49%|████▉     | 494/1000 [2:10:27<2:13:37, 15.85s/it][Succeeded / Failed / Skipped / Total] 65 / 417 / 12 / 494:  49%|████▉     | 494/1000 [2:10:27<2:13:37, 15.85s/it][Succeeded / Failed / Skipped / Total] 66 / 417 / 12 / 495:  50%|████▉     | 495/1000 [2:10:29<2:13:08, 15.82s/it][Succeeded / Failed / Skipped / Total] 66 / 417 / 12 / 495:  50%|████▉     | 496/1000 [2:10:31<2:12:37, 15.79s/it][Succeeded / Failed / Skipped / Total] 67 / 417 / 12 / 496:  50%|████▉     | 496/1000 [2:10:31<2:12:37, 15.79s/it][Succeeded / Failed / Skipped / Total] 67 / 418 / 12 / 497:  50%|████▉     | 497/1000 [2:10:35<2:12:10, 15.77s/it][Succeeded / Failed / Skipped / Total] 67 / 418 / 12 / 497:  50%|████▉     | 498/1000 [2:10:56<2:11:59, 15.78s/it][Succeeded / Failed / Skipped / Total] 68 / 418 / 12 / 498:  50%|████▉     | 498/1000 [2:10:56<2:11:59, 15.78s/it][Succeeded / Failed / Skipped / Total] 68 / 418 / 12 / 498:  50%|████▉     | 499/1000 [2:11:03<2:11:34, 15.76s/it][Succeeded / Failed / Skipped / Total] 68 / 419 / 12 / 499:  50%|████▉     | 499/1000 [2:11:03<2:11:34, 15.76s/it][Succeeded / Failed / Skipped / Total] 68 / 419 / 12 / 499:  50%|█████     | 500/1000 [2:11:04<2:11:04, 15.73s/it]Start the connection lost timer. --> Main entry point. --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[main]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
Cancels the connection lost timer. --> Cancels all connections. --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[cancel]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 495 ---------------------------------------------
Generates an HTTP response based on an error code. --> Handles an upgrade request. --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[handle]] ( int [[header]] ) { String errorCodeDescription ; switch ( [[header]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 496 ---------------------------------------------
Cancel a connection lost checker. --> Main entry point. --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[main]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "False" != "False" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 497 ---------------------------------------------
Stop the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "[[False]]" != "[[False]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[wait]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "[[connect]]" != "[[connect]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 498 ---------------------------------------------
Performs additional read. --> Begin reading from the queue. --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[begin]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 499 ---------------------------------------------
Sends a ping frame. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[console]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
[Succeeded / Failed / Skipped / Total] 68 / 419 / 13 / 500:  50%|█████     | 500/1000 [2:11:04<2:11:04, 15.73s/it][Succeeded / Failed / Skipped / Total] 68 / 419 / 13 / 500:  50%|█████     | 501/1000 [2:11:04<2:10:33, 15.70s/it][Succeeded / Failed / Skipped / Total] 68 / 419 / 14 / 501:  50%|█████     | 501/1000 [2:11:04<2:10:33, 15.70s/it][Succeeded / Failed / Skipped / Total] 68 / 419 / 14 / 501:  50%|█████     | 502/1000 [2:11:08<2:10:06, 15.67s/it][Succeeded / Failed / Skipped / Total] 68 / 420 / 14 / 502:  50%|█████     | 502/1000 [2:11:08<2:10:06, 15.67s/it][Succeeded / Failed / Skipped / Total] 68 / 420 / 14 / 502:  50%|█████     | 503/1000 [2:11:25<2:09:51, 15.68s/it][Succeeded / Failed / Skipped / Total] 69 / 420 / 14 / 503:  50%|█████     | 503/1000 [2:11:26<2:09:52, 15.68s/it][Succeeded / Failed / Skipped / Total] 69 / 420 / 14 / 503:  50%|█████     | 504/1000 [2:11:26<2:09:21, 15.65s/it][Succeeded / Failed / Skipped / Total] 69 / 420 / 15 / 504:  50%|█████     | 504/1000 [2:11:26<2:09:21, 15.65s/it][Succeeded / Failed / Skipped / Total] 69 / 420 / 15 / 504:  50%|█████     | 505/1000 [2:11:29<2:08:53, 15.62s/it][Succeeded / Failed / Skipped / Total] 70 / 420 / 15 / 505:  50%|█████     | 505/1000 [2:11:29<2:08:53, 15.62s/it][Succeeded / Failed / Skipped / Total] 70 / 420 / 15 / 505:  51%|█████     | 506/1000 [2:11:40<2:08:32, 15.61s/it]--------------------------------------------- Result 500 ---------------------------------------------
Reads from the socket. --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 501 ---------------------------------------------
Writes data to the specified key. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 502 ---------------------------------------------
Returns the port number associated with this socket. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[handle]] ( ) { int [[connect]] = getAddress ( ) . getPort ( ) ; if ( [[connect]] == 0 && server != null ) { [[connect]] = server . socket ( ) . getLocalPort ( ) ; } return [[connect]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 503 ---------------------------------------------
Accepts a selection key. --> Calls the selected channel. --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[call]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 504 ---------------------------------------------
Called when the server shuts down. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Initializes the selector and server. --> Creates a new WebSocketSelector. --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[add]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 506 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 421 / 15 / 506:  51%|█████     | 506/1000 [2:11:40<2:08:32, 15.61s/it][Succeeded / Failed / Skipped / Total] 70 / 421 / 15 / 506:  51%|█████     | 507/1000 [2:11:42<2:08:04, 15.59s/it][Succeeded / Failed / Skipped / Total] 71 / 421 / 15 / 507:  51%|█████     | 507/1000 [2:11:42<2:08:04, 15.59s/it][Succeeded / Failed / Skipped / Total] 71 / 421 / 15 / 507:  51%|█████     | 508/1000 [2:11:47<2:07:38, 15.57s/it][Succeeded / Failed / Skipped / Total] 71 / 422 / 15 / 508:  51%|█████     | 508/1000 [2:11:47<2:07:38, 15.57s/it][Succeeded / Failed / Skipped / Total] 71 / 422 / 15 / 508:  51%|█████     | 509/1000 [2:11:55<2:07:15, 15.55s/it][Succeeded / Failed / Skipped / Total] 72 / 422 / 15 / 509:  51%|█████     | 509/1000 [2:11:55<2:07:15, 15.55s/it][Succeeded / Failed / Skipped / Total] 72 / 422 / 15 / 509:  51%|█████     | 510/1000 [2:12:00<2:06:49, 15.53s/it][Succeeded / Failed / Skipped / Total] 72 / 423 / 15 / 510:  51%|█████     | 510/1000 [2:12:00<2:06:49, 15.53s/it][Succeeded / Failed / Skipped / Total] 72 / 423 / 15 / 510:  51%|█████     | 511/1000 [2:12:08<2:06:26, 15.52s/it][Succeeded / Failed / Skipped / Total] 73 / 423 / 15 / 511:  51%|█████     | 511/1000 [2:12:08<2:06:26, 15.52s/it][Succeeded / Failed / Skipped / Total] 73 / 423 / 15 / 511:  51%|█████     | 512/1000 [2:12:09<2:05:57, 15.49s/it]Sends a handshake. --> [[[FAILED]]]

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 507 ---------------------------------------------
Returns the socket for the specified channel. --> Creates a new selection key and returns it. --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[mapping]] ( WebSocket conn ) { WebSocketImpl impl = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) impl . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 508 ---------------------------------------------
Called when a connection was lost. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[webSocketImpl]] = ( WebSocketImpl ) webSocket ; if ( [[webSocketImpl]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[webSocketImpl]] ) ; [[webSocketImpl]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[webSocketImpl]] . isOpen ( ) ) { [[webSocketImpl]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[webSocketImpl]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[print]] ( WebSocket webSocket , long minimumPongTime ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl [[access]] = ( WebSocketImpl ) webSocket ; if ( [[access]] . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , [[access]] ) ; [[access]] . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( [[access]] . isOpen ( ) ) { [[access]] . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , [[access]] ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 509 ---------------------------------------------
Broadcasts the specified data to all registered clients. --> Broadcasts the specified data using the specified format. --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( byte [ ] data , Collection < WebSocket > [[clients]] ) { if ( data == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( byte [ ] data , Collection < WebSocket > [[format]] ) { if ( data == null || [[format]] == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( data ) , [[format]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 510 ---------------------------------------------
Stops this thread. --> [[[FAILED]]]

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void stop ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[write]]" != "[[write]]" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 511 ---------------------------------------------
Ensure that only one thread is running. --> Creates a copy of this thread. --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doEnsureSingleThread]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean [[copy]] ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 512 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 423 / 15 / 512:  51%|█████     | 512/1000 [2:12:09<2:05:57, 15.49s/it][Succeeded / Failed / Skipped / Total] 74 / 423 / 15 / 512:  51%|█████▏    | 513/1000 [2:12:27<2:05:44, 15.49s/it][Succeeded / Failed / Skipped / Total] 75 / 423 / 15 / 513:  51%|█████▏    | 513/1000 [2:12:27<2:05:44, 15.49s/it][Succeeded / Failed / Skipped / Total] 75 / 423 / 15 / 513:  51%|█████▏    | 514/1000 [2:12:33<2:05:20, 15.47s/it][Succeeded / Failed / Skipped / Total] 76 / 423 / 15 / 514:  51%|█████▏    | 514/1000 [2:12:33<2:05:20, 15.47s/it][Succeeded / Failed / Skipped / Total] 76 / 423 / 15 / 514:  52%|█████▏    | 515/1000 [2:12:34<2:04:50, 15.45s/it][Succeeded / Failed / Skipped / Total] 76 / 424 / 15 / 515:  52%|█████▏    | 515/1000 [2:12:34<2:04:50, 15.45s/it][Succeeded / Failed / Skipped / Total] 76 / 424 / 15 / 515:  52%|█████▏    | 516/1000 [2:12:35<2:04:21, 15.42s/it][Succeeded / Failed / Skipped / Total] 76 / 425 / 15 / 516:  52%|█████▏    | 516/1000 [2:12:35<2:04:21, 15.42s/it][Succeeded / Failed / Skipped / Total] 76 / 425 / 15 / 516:  52%|█████▏    | 517/1000 [2:12:53<2:04:09, 15.42s/it][Succeeded / Failed / Skipped / Total] 77 / 425 / 15 / 517:  52%|█████▏    | 517/1000 [2:12:53<2:04:09, 15.42s/it][Succeeded / Failed / Skipped / Total] 77 / 425 / 15 / 517:  52%|█████▏    | 518/1000 [2:13:01<2:03:47, 15.41s/it][Succeeded / Failed / Skipped / Total] 77 / 426 / 15 / 518:  52%|█████▏    | 518/1000 [2:13:01<2:03:47, 15.41s/it][Succeeded / Failed / Skipped / Total] 77 / 426 / 15 / 518:  52%|█████▏    | 519/1000 [2:13:14<2:03:28, 15.40s/it][Succeeded / Failed / Skipped / Total] 77 / 427 / 15 / 519:  52%|█████▏    | 519/1000 [2:13:14<2:03:28, 15.40s/it][Succeeded / Failed / Skipped / Total] 77 / 427 / 15 / 519:  52%|█████▏    | 520/1000 [2:13:52<2:03:34, 15.45s/it]Broadcasts a data frame to all the clients. --> Sends a frame. --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[after]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 513 ---------------------------------------------
Transfer a byte buffer from source to dest. --> Copies the contents of source into dest. --> Socre: 1.0

[[[[Adv]]]]: public static int [[transferByteBuffer]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int [[bin]] ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 514 ---------------------------------------------
Broadcasts the specified text to all registered clients. --> Asserts that the given message is not null or empty.@param message the message@param clients the clients --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[assume]] ( String [[message]] , Collection < WebSocket > clients ) { if ( [[message]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[message]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 515 ---------------------------------------------
Performs a transaction on this entity manager. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[print]] ( Consumer < EntityManager > block ) { [[print]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 516 ---------------------------------------------
Starts the persistence manager. --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[be]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 517 ---------------------------------------------
Fills a draft frame list with data from the specified draft. --> Asserts that a draft frame is present. --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft [[draft]] , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( [[draft]] ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = [[draft]] . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = [[draft]] . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( [[draft]] , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[assume]] ( Draft [[net]] , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( [[net]] ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = [[net]] . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = [[net]] . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( [[net]] , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 518 ---------------------------------------------
Converts an array of arguments to a list of objects. --> [[[FAILED]]]

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[execute]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 519 ---------------------------------------------
Creates an entity manager with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[manager]] ( String [[null]] ) { EntityManagerFactory emf = emfs . get ( [[null]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 520 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 428 / 15 / 520:  52%|█████▏    | 520/1000 [2:13:52<2:03:34, 15.45s/it]