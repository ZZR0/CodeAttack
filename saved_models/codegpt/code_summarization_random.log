Special tokens have been added in the vocabulary, make sure the associated word embeddings are fine-tuned or trained.
textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 1 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 917.39it/s][Succeeded / Failed / Skipped / Total] 0 / 2 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1224.44it/s][Succeeded / Failed / Skipped / Total] 0 / 3 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1405.91it/s][Succeeded / Failed / Skipped / Total] 1 / 3 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1438.99it/s][Succeeded / Failed / Skipped / Total] 1 / 4 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 1457.87it/s][Succeeded / Failed / Skipped / Total] 1 / 4 / 0 / 5:   1%|          | 6/1000 [00:00<01:22, 12.01it/s]  --------------------------------------------- Result 1 ---------------------------------------------
Wraps an observable source.@param < T> the type parameter@param source the source@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[poplin]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Sorts the elements in this observable according to the specified sort function.@param sortFunction the sort function to be applied to the elements in this observable.@return the sorted observable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[irregular]] ( Comparator < ? super T > [[headquarters]] ) { ObjectHelper . requireNonNull ( [[headquarters]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[headquarters]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 3 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[disturbing]] ( int [[derivative]] ) { return new UnicastProcessor < T > ( [[derivative]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Observes an observable on the specified connection.@param < T> the type parameter@param co the connection@param scheduler the scheduler@return the observable --> Creates a new observable that subscribes to a rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich rich --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > [[observable]] = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[observable]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[billionaires]] ( final ConnectableObservable < T > co , final Scheduler [[mantra]] ) { final Observable < T > [[mussolini]] = co . observeOn ( [[mantra]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , [[mussolini]] ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 5 ---------------------------------------------
Performs a fast-path rejection of the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U [[value]] , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > [[q]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[q]] . isEmpty ( ) ) { accept ( [[observer]] , [[value]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[q]] . offer ( [[value]] ) ; } } else { [[q]] . offer ( [[value]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[q]] , [[observer]] , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[andie]] ( U [[galactic]] , boolean [[procurator]] , Disposable disposable ) { final Observer < ? super V > [[kaew]] = downstream ; final SimplePlainQueue < U > [[twitching]] = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( [[twitching]] . isEmpty ( ) ) { accept ( [[kaew]] , [[galactic]] ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { [[twitching]] . offer ( [[galactic]] ) ; } } else { [[twitching]] . offer ( [[galactic]] ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( [[twitching]] , [[kaew]] , [[procurator]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 5 / 0 / 6:   1%|          | 6/1000 [00:00<01:22, 11.99it/s][Succeeded / Failed / Skipped / Total] 1 / 6 / 0 / 7:   1%|          | 7/1000 [00:56<2:13:56,  8.09s/it][Succeeded / Failed / Skipped / Total] 1 / 7 / 0 / 8:   1%|          | 8/1000 [00:57<1:57:53,  7.13s/it][Succeeded / Failed / Skipped / Total] 1 / 8 / 0 / 9:   1%|          | 9/1000 [01:01<1:53:16,  6.86s/it][Succeeded / Failed / Skipped / Total] 1 / 9 / 0 / 10:   1%|          | 10/1000 [01:15<2:04:35,  7.55s/it][Succeeded / Failed / Skipped / Total] 1 / 10 / 0 / 11:   1%|          | 11/1000 [01:46<2:39:30,  9.68s/it][Succeeded / Failed / Skipped / Total] 1 / 10 / 0 / 11:   1%|          | 12/1000 [01:58<2:42:43,  9.88s/it][Succeeded / Failed / Skipped / Total] 1 / 11 / 0 / 12:   1%|          | 12/1000 [01:58<2:42:43,  9.88s/it][Succeeded / Failed / Skipped / Total] 1 / 11 / 0 / 12:   1%|▏         | 13/1000 [02:10<2:44:56, 10.03s/it]Resets this scheduler. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[monty]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 7 ---------------------------------------------
Throws a NullPointerException if the supplied object is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[voyagers]] > [[voyagers]] requireNonNull ( [[voyagers]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 8 ---------------------------------------------
Create a RxJava Maybe from a single source.@param < T> the type parameter@param singleSource the single source@return the RxJava Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[boastful]] ( SingleSource < T > [[ballad]] ) { ObjectHelper . requireNonNull ( [[ballad]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[ballad]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 9 ---------------------------------------------
Create a new Maybe from a completable source.@param < T> the type parameter@param completableSource the source@return the Maybe --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[disturbing]] ( CompletableSource [[aniseed]] ) { ObjectHelper . requireNonNull ( [[aniseed]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[aniseed]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Creates a new processor with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[bees]] ( int [[marrow]] , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( [[marrow]] , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 11 ---------------------------------------------
Create a scalar flowable that maps a value to a publisher.@param < T> the type parameter@param < U> the type parameter@param value the value@param mapper the mapper@return the flowable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[wandering]] ( final T [[topic]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[detained]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[topic]] , [[detained]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 12 ---------------------------------------------
Retries the specified number of times. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[jaden]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 13 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 12 / 0 / 13:   1%|▏         | 13/1000 [02:10<2:44:56, 10.03s/it][Succeeded / Failed / Skipped / Total] 1 / 12 / 0 / 13:   1%|▏         | 14/1000 [03:04<3:36:00, 13.14s/it][Succeeded / Failed / Skipped / Total] 1 / 13 / 0 / 14:   1%|▏         | 14/1000 [03:04<3:36:00, 13.14s/it][Succeeded / Failed / Skipped / Total] 1 / 13 / 0 / 14:   2%|▏         | 15/1000 [03:10<3:28:12, 12.68s/it][Succeeded / Failed / Skipped / Total] 1 / 14 / 0 / 15:   2%|▏         | 15/1000 [03:10<3:28:12, 12.68s/it][Succeeded / Failed / Skipped / Total] 1 / 14 / 0 / 15:   2%|▏         | 16/1000 [03:18<3:23:40, 12.42s/it][Succeeded / Failed / Skipped / Total] 1 / 15 / 0 / 16:   2%|▏         | 16/1000 [03:18<3:23:40, 12.42s/it][Succeeded / Failed / Skipped / Total] 1 / 15 / 0 / 16:   2%|▏         | 17/1000 [03:34<3:26:42, 12.62s/it][Succeeded / Failed / Skipped / Total] 1 / 16 / 0 / 17:   2%|▏         | 17/1000 [03:34<3:26:43, 12.62s/it][Succeeded / Failed / Skipped / Total] 1 / 16 / 0 / 17:   2%|▏         | 18/1000 [03:43<3:22:55, 12.40s/it][Succeeded / Failed / Skipped / Total] 1 / 17 / 0 / 18:   2%|▏         | 18/1000 [03:43<3:22:55, 12.40s/it][Succeeded / Failed / Skipped / Total] 1 / 17 / 0 / 18:   2%|▏         | 19/1000 [04:31<3:53:30, 14.28s/it][Succeeded / Failed / Skipped / Total] 2 / 17 / 0 / 19:   2%|▏         | 19/1000 [04:31<3:53:30, 14.28s/it][Succeeded / Failed / Skipped / Total] 2 / 17 / 0 / 19:   2%|▏         | 20/1000 [05:08<4:11:59, 15.43s/it][Succeeded / Failed / Skipped / Total] 2 / 18 / 0 / 20:   2%|▏         | 20/1000 [05:08<4:12:00, 15.43s/it][Succeeded / Failed / Skipped / Total] 2 / 18 / 0 / 20:   2%|▏         | 21/1000 [05:32<4:18:36, 15.85s/it][Succeeded / Failed / Skipped / Total] 3 / 18 / 0 / 21:   2%|▏         | 21/1000 [05:32<4:18:36, 15.85s/it][Succeeded / Failed / Skipped / Total] 3 / 18 / 0 / 21:   2%|▏         | 22/1000 [05:56<4:23:54, 16.19s/it][Succeeded / Failed / Skipped / Total] 3 / 19 / 0 / 22:   2%|▏         | 22/1000 [05:56<4:23:54, 16.19s/it][Succeeded / Failed / Skipped / Total] 3 / 19 / 0 / 22:   2%|▏         | 23/1000 [06:24<4:31:55, 16.70s/it]Creates a Callable that will just call the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[faintly]] ( T [[grievances]] ) { return new JustValue < Object , T > ( [[grievances]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 14 ---------------------------------------------
Returns an identity function. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[ledge]] > Function < [[ledge]] , [[ledge]] > [[gopal]] ( ) { return ( Function < [[ledge]] , [[ledge]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 15 ---------------------------------------------
Creates a cast function from the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > target ) { return new CastToClass < [[T]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[circulates]] , U > Function < [[circulates]] , U > [[metastasized]] ( Class < U > target ) { return new CastToClass < [[circulates]] , U > ( target ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 16 ---------------------------------------------
Creates a new non-blocking producer. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[scenarios]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[Animals]]" == "[[Animals]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 17 ---------------------------------------------
Blocking get error. --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[clipboard]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 18 ---------------------------------------------
Creates a new subject with the specified capacity. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[courtesies]] ( int [[spurlock]] ) { return new UnicastSubject < T > ( [[spurlock]] , "[[Subway]]" == "[[Subway]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 19 ---------------------------------------------
Blocking get error. --> Lumumba throwable --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[lumumba]] ( long [[arik]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[arik]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[arik]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 20 ---------------------------------------------
Creates a function that will just return the supplied value. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[justFunction]] ( U [[value]] ) { return new JustValue < [[T]] , U > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[hatim]] , U > Function < [[hatim]] , U > [[scamper]] ( U [[colleague]] ) { return new JustValue < [[hatim]] , U > ( [[colleague]] ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 21 ---------------------------------------------
Creates a new non-blocking UnicastSubject. --> Create a non-interactively non-interactively non-interactively non-interactively non-interactively non-interactively non-interactively non-interactivelynon-interactively non-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon-interactivelynon- --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[baumann]] ( boolean [[ineffective]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[ineffective]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 22 ---------------------------------------------
Requests the specified number of bytes from the supplied subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[request]] ( Subscription s , int [[prefetch]] ) { s . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[crawlers]] ( Subscription s , int [[augment]] ) { s . request ( [[augment]] < 0 ? Long . MAX_VALUE : [[augment]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
[Succeeded / Failed / Skipped / Total] 4 / 19 / 0 / 23:   2%|▏         | 23/1000 [06:24<4:31:55, 16.70s/it][Succeeded / Failed / Skipped / Total] 4 / 19 / 0 / 23:   2%|▏         | 24/1000 [06:51<4:39:02, 17.15s/it][Succeeded / Failed / Skipped / Total] 4 / 20 / 0 / 24:   2%|▏         | 24/1000 [06:51<4:39:02, 17.15s/it][Succeeded / Failed / Skipped / Total] 4 / 20 / 0 / 24:   2%|▎         | 25/1000 [07:08<4:38:21, 17.13s/it][Succeeded / Failed / Skipped / Total] 4 / 21 / 0 / 25:   2%|▎         | 25/1000 [07:08<4:38:21, 17.13s/it][Succeeded / Failed / Skipped / Total] 4 / 21 / 0 / 25:   3%|▎         | 26/1000 [07:12<4:30:16, 16.65s/it][Succeeded / Failed / Skipped / Total] 4 / 22 / 0 / 26:   3%|▎         | 26/1000 [07:12<4:30:16, 16.65s/it][Succeeded / Failed / Skipped / Total] 4 / 22 / 0 / 26:   3%|▎         | 27/1000 [07:46<4:40:11, 17.28s/it][Succeeded / Failed / Skipped / Total] 5 / 22 / 0 / 27:   3%|▎         | 27/1000 [07:46<4:40:11, 17.28s/it][Succeeded / Failed / Skipped / Total] 5 / 22 / 0 / 27:   3%|▎         | 28/1000 [07:56<4:35:28, 17.01s/it][Succeeded / Failed / Skipped / Total] 5 / 23 / 0 / 28:   3%|▎         | 28/1000 [07:56<4:35:28, 17.01s/it][Succeeded / Failed / Skipped / Total] 5 / 23 / 0 / 28:   3%|▎         | 29/1000 [11:03<6:10:29, 22.89s/it]--------------------------------------------- Result 23 ---------------------------------------------
Completes this stream. --> Sabata --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[sabata]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 24 ---------------------------------------------
Returns the value associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[schmoozing]] ( ) { Object [[tyrannosaurus]] = value ; if ( [[tyrannosaurus]] != null && ! NotificationLite . isError ( [[tyrannosaurus]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 25 ---------------------------------------------
Creates a new UnicastSubject.@param < T> the type parameter@param capacityHint the capacity hint@param onTerminate the onTerminate@return the created object --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( [[capacityHint]] , [[onTerminate]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[savage]] ( int [[presley]] , Runnable [[toughen]] ) { return new UnicastSubject < T > ( [[presley]] , [[toughen]] , "[[Compress]]" == "[[Compress]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 26 ---------------------------------------------
Gets the error associated with this notification. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[faintly]] ( ) { Object o = value ; if ( NotificationLite . isError ( o ) ) { return NotificationLite . getError ( o ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Posts the specified queue to the specified subscriber. --> Borrowed from AbstractSubscriber --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , queue , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[bustamante]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[economize]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[economize]] . get ( ) , actual , queue , [[economize]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[economize]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 28 ---------------------------------------------
Blocks until the specified wait time is reached.@param timeout the maximum time to wait@param unit the time unit@return {@code true} if the wait timed out, {@code false} otherwise --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[maddie]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Hubcaps]]" == "[[Hubcaps]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 29 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 5 / 24 / 0 / 29:   3%|▎         | 29/1000 [11:03<6:10:29, 22.89s/it][Succeeded / Failed / Skipped / Total] 5 / 24 / 0 / 29:   3%|▎         | 30/1000 [11:36<6:15:26, 23.22s/it][Succeeded / Failed / Skipped / Total] 6 / 24 / 0 / 30:   3%|▎         | 30/1000 [11:36<6:15:26, 23.22s/it][Succeeded / Failed / Skipped / Total] 6 / 24 / 0 / 30:   3%|▎         | 31/1000 [12:15<6:23:04, 23.72s/it][Succeeded / Failed / Skipped / Total] 6 / 25 / 0 / 31:   3%|▎         | 31/1000 [12:15<6:23:04, 23.72s/it][Succeeded / Failed / Skipped / Total] 6 / 25 / 0 / 31:   3%|▎         | 32/1000 [12:18<6:12:14, 23.07s/it][Succeeded / Failed / Skipped / Total] 6 / 26 / 0 / 32:   3%|▎         | 32/1000 [12:18<6:12:14, 23.07s/it][Succeeded / Failed / Skipped / Total] 6 / 26 / 0 / 32:   3%|▎         | 33/1000 [12:45<6:13:44, 23.19s/it]Try to subscribe to a scalar map. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > source , Subscriber < ? super R > [[subscriber]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( [[subscriber]] ) ; return "[[True]]" == "[[True]]" ; } [[subscriber]] . onSubscribe ( new ScalarSubscription < R > ( [[subscriber]] , u ) ) ; } else { [[r]] . subscribe ( [[subscriber]] ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[zer]] ( Publisher < T > source , Subscriber < ? super R > [[leastways]] , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[leastways]] ) ; return "[[Gannon]]" == "[[Gannon]]" ; } if ( t == null ) { EmptySubscription . complete ( [[leastways]] ) ; return "[[Gannon]]" == "[[Gannon]]" ; } Publisher < ? extends R > [[caveman]] ; try { [[caveman]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[leastways]] ) ; return "[[Gannon]]" == "[[Gannon]]" ; } if ( [[caveman]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[caveman]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , [[leastways]] ) ; return "[[Gannon]]" == "[[Gannon]]" ; } if ( u == null ) { EmptySubscription . complete ( [[leastways]] ) ; return "[[Gannon]]" == "[[Gannon]]" ; } [[leastways]] . onSubscribe ( new ScalarSubscription < R > ( [[leastways]] , u ) ) ; } else { [[caveman]] . subscribe ( [[leastways]] ) ; } return "[[Gannon]]" == "[[Gannon]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 30 ---------------------------------------------
Adds the specified element to the end of the array. --> Calculates how many times a certain number of times a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes a certain number oftimes --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long [[a]] , long [[b]] ) { long [[u]] = [[a]] + [[b]] ; if ( [[u]] < 0L ) { return Long . MAX_VALUE ; } return [[u]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[howie]] ( long [[progressively]] , long [[hitching]] ) { long [[musical]] = [[progressively]] + [[hitching]] ; if ( [[musical]] < 0L ) { return Long . MAX_VALUE ; } return [[musical]] ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 31 ---------------------------------------------
Validates that the next Subscription is of the given type.@param upstream The next Subscription.@param next The next Subscription.@param subscriber The type of the next Subscription.@return True if the next Subscription is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription upstream , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( upstream != null ) { [[next]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[persimmon]] ( Subscription upstream , Subscription [[yarmulke]] , Class < ? > [[vor]] ) { ObjectHelper . requireNonNull ( [[yarmulke]] , "next is null" ) ; if ( upstream != null ) { [[yarmulke]] . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[vor]] ) ; } return "[[Ejaculated]]" != "[[Ejaculated]]" ; } return "[[Kiley]]" == "[[Kiley]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 32 ---------------------------------------------
Validates that the next Disposable is of the given type.@param upstream The next Disposable.@param next The next Disposable.@param observer The type of the next Disposable.@return True if the next Disposable is of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable [[upstream]] , Disposable [[next]] , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . dispose ( ) ; if ( [[upstream]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[superposition]] ( Disposable [[pinprick]] , Disposable [[compilation]] , Class < ? > [[ferocity]] ) { ObjectHelper . requireNonNull ( [[compilation]] , "next is null" ) ; if ( [[pinprick]] != null ) { [[compilation]] . dispose ( ) ; if ( [[pinprick]] != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[ferocity]] ) ; } return "False" != "False" ; } return "[[Tastier]]" == "[[Tastier]]" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 33 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 26 / 0 / 33:   3%|▎         | 33/1000 [12:45<6:13:44, 23.19s/it][Succeeded / Failed / Skipped / Total] 7 / 26 / 0 / 33:   3%|▎         | 34/1000 [13:12<6:15:08, 23.30s/it][Succeeded / Failed / Skipped / Total] 7 / 27 / 0 / 34:   3%|▎         | 34/1000 [13:12<6:15:08, 23.30s/it][Succeeded / Failed / Skipped / Total] 7 / 27 / 0 / 34:   4%|▎         | 35/1000 [13:14<6:04:59, 22.69s/it][Succeeded / Failed / Skipped / Total] 7 / 28 / 0 / 35:   4%|▎         | 35/1000 [13:14<6:04:59, 22.69s/it][Succeeded / Failed / Skipped / Total] 7 / 28 / 0 / 35:   4%|▎         | 36/1000 [13:15<5:55:14, 22.11s/it][Succeeded / Failed / Skipped / Total] 8 / 28 / 0 / 36:   4%|▎         | 36/1000 [13:15<5:55:14, 22.11s/it][Succeeded / Failed / Skipped / Total] 8 / 28 / 0 / 36:   4%|▎         | 37/1000 [13:39<5:55:36, 22.16s/it][Succeeded / Failed / Skipped / Total] 9 / 28 / 0 / 37:   4%|▎         | 37/1000 [13:39<5:55:36, 22.16s/it][Succeeded / Failed / Skipped / Total] 9 / 28 / 0 / 37:   4%|▍         | 38/1000 [13:40<5:46:00, 21.58s/it][Succeeded / Failed / Skipped / Total] 9 / 29 / 0 / 38:   4%|▍         | 38/1000 [13:40<5:46:00, 21.58s/it][Succeeded / Failed / Skipped / Total] 9 / 29 / 0 / 38:   4%|▍         | 39/1000 [14:13<5:50:38, 21.89s/it][Succeeded / Failed / Skipped / Total] 9 / 30 / 0 / 39:   4%|▍         | 39/1000 [14:13<5:50:38, 21.89s/it][Succeeded / Failed / Skipped / Total] 9 / 30 / 0 / 39:   4%|▍         | 40/1000 [14:19<5:43:57, 21.50s/it][Succeeded / Failed / Skipped / Total] 9 / 31 / 0 / 40:   4%|▍         | 40/1000 [14:19<5:43:58, 21.50s/it][Succeeded / Failed / Skipped / Total] 9 / 31 / 0 / 40:   4%|▍         | 41/1000 [14:34<5:41:00, 21.34s/it]Multiply a long by another. --> Multiply bournemouth by mangroves@param bournemouth@param mangroves@return --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long [[b]] ) { long u = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( u / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[bournemouth]] , long [[mangroves]] ) { long u = [[bournemouth]] * [[mangroves]] ; if ( ( ( [[bournemouth]] | [[mangroves]] ) >>> 31 ) != 0 ) { if ( u / [[bournemouth]] != [[mangroves]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
Converts a Throwable to a NullPointerException. --> [[[FAILED]]]

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[ex]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[frye]] ( Throwable [[aristotle]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[aristotle]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the pool. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[basil]] ( ) { ScheduledExecutorService [[ell]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[ell]] != null ) { [[ell]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Adds an object to the list. --> Method how many --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[howmany]] ( Object [[horman]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 37 ---------------------------------------------
Emits a loop. --> alhandsh --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[alisha]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "False" != "False" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 38 ---------------------------------------------
Adds n elements to the supplied AtomicLong. --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[add]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[swaddling]] ( AtomicLong requested , long n ) { for ( ; ; ) { long r = requested . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , n ) ; if ( requested . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 39 ---------------------------------------------
Sets the next Disposable once.@param upstream The {@link Disposable} to set.@param next The {@link Disposable} to set.@param observer The {@link Disposable} to use.@return {@code true} if the next Disposable was set, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[zuzana]] , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[zuzana]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[zuzana]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[Abra]]" == "[[Abra]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 40 ---------------------------------------------
Wraps an exception. --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable error ) { if ( error instanceof Error ) { throw ( Error ) error ; } if ( error instanceof RuntimeException ) { return ( RuntimeException ) error ; } return new RuntimeException ( error ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 9 / 32 / 0 / 41:   4%|▍         | 41/1000 [14:34<5:41:00, 21.34s/it][Succeeded / Failed / Skipped / Total] 9 / 32 / 0 / 41:   4%|▍         | 42/1000 [14:36<5:33:06, 20.86s/it][Succeeded / Failed / Skipped / Total] 9 / 33 / 0 / 42:   4%|▍         | 42/1000 [14:36<5:33:06, 20.86s/it][Succeeded / Failed / Skipped / Total] 9 / 33 / 0 / 42:   4%|▍         | 43/1000 [14:46<5:28:55, 20.62s/it][Succeeded / Failed / Skipped / Total] 9 / 34 / 0 / 43:   4%|▍         | 43/1000 [14:46<5:28:55, 20.62s/it][Succeeded / Failed / Skipped / Total] 9 / 34 / 0 / 43:   4%|▍         | 44/1000 [14:48<5:21:37, 20.19s/it][Succeeded / Failed / Skipped / Total] 9 / 35 / 0 / 44:   4%|▍         | 44/1000 [14:48<5:21:37, 20.19s/it][Succeeded / Failed / Skipped / Total] 9 / 35 / 0 / 44:   4%|▍         | 45/1000 [15:10<5:22:10, 20.24s/it][Succeeded / Failed / Skipped / Total] 9 / 36 / 0 / 45:   4%|▍         | 45/1000 [15:10<5:22:10, 20.24s/it][Succeeded / Failed / Skipped / Total] 9 / 36 / 0 / 45:   5%|▍         | 46/1000 [15:16<5:16:37, 19.91s/it][Succeeded / Failed / Skipped / Total] 10 / 36 / 0 / 46:   5%|▍         | 46/1000 [15:16<5:16:37, 19.91s/it][Succeeded / Failed / Skipped / Total] 10 / 36 / 0 / 46:   5%|▍         | 47/1000 [15:16<5:09:42, 19.50s/it]Sets the next subscription in the chain once.@param upstream The source of the next subscription.@param next The next subscription in the chain.@param subscriber The subscriber of the next subscription.@return <code>true</code> on success, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[logistics]] , Subscription [[amiss]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[amiss]] , "next is null" ) ; if ( ! [[logistics]] . compareAndSet ( null , [[amiss]] ) ) { [[amiss]] . cancel ( ) ; if ( [[logistics]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[Andit]]" == "[[Andit]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 42 ---------------------------------------------
Sets the current subscription. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[meticulously]] ( Subscription [[daunting]] ) { if ( cancelled ) { [[daunting]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[daunting]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[halliburton]] = actual ; if ( [[halliburton]] != null && cancelOnReplace ) { [[halliburton]] . cancel ( ) ; } actual = [[daunting]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[daunting]] . request ( r ) ; } return ; } Subscription [[halliburton]] = missedSubscription . getAndSet ( [[daunting]] ) ; if ( [[halliburton]] != null && cancelOnReplace ) { [[halliburton]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 43 ---------------------------------------------
Clears this hash set. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[clear]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void [[paquette]] ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[pedal]] ; synchronized ( this ) { if ( disposed ) { return ; } [[pedal]] = resources ; resources = null ; } dispose ( [[pedal]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 44 ---------------------------------------------
Drains all elements from the queue.@param q The queue.@param a The subscriber.@param delayError Delay error.@param dispose The disposable.@param qd The queue. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean [[delayError]] , Disposable dispose , QueueDrain < T , U > [[qd]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[qd]] . done ( ) ; T v = q . poll ( ) ; boolean [[empty]] = v == null ; if ( checkTerminated ( d , [[empty]] , [[a]] , [[delayError]] , q , [[qd]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[empty]] ) { break ; } long [[r]] = [[qd]] . requested ( ) ; if ( [[r]] != 0L ) { if ( [[qd]] . accept ( [[a]] , v ) ) { if ( [[r]] != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[qd]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > [[wilder]] , boolean [[biatch]] , Disposable dispose , QueueDrain < T , U > [[kennington]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[kennington]] . done ( ) ; T v = q . poll ( ) ; boolean [[escapism]] = v == null ; if ( checkTerminated ( d , [[escapism]] , [[wilder]] , [[biatch]] , q , [[kennington]] ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( [[escapism]] ) { break ; } long [[audible]] = [[kennington]] . requested ( ) ; if ( [[audible]] != 0L ) { if ( [[kennington]] . accept ( [[wilder]] , v ) ) { if ( [[audible]] != Long . MAX_VALUE ) { [[kennington]] . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[wilder]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[kennington]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 45 ---------------------------------------------
Creates a new scheduled executor service. --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[streaks]] ( ThreadFactory [[airtime]] ) { final ScheduledExecutorService [[horman]] = Executors . newScheduledThreadPool ( 1 , [[airtime]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[horman]] ) ; return [[horman]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 46 ---------------------------------------------
Returns the size of this hash set. --> zuzana zuzana --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[zuzana]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > set = resources ; return set != null ? set . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 47 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 37 / 0 / 47:   5%|▍         | 47/1000 [15:16<5:09:42, 19.50s/it][Succeeded / Failed / Skipped / Total] 10 / 37 / 0 / 47:   5%|▍         | 48/1000 [15:34<5:08:55, 19.47s/it][Succeeded / Failed / Skipped / Total] 10 / 38 / 0 / 48:   5%|▍         | 48/1000 [15:34<5:08:55, 19.47s/it][Succeeded / Failed / Skipped / Total] 10 / 38 / 0 / 48:   5%|▍         | 49/1000 [15:34<5:02:20, 19.07s/it][Succeeded / Failed / Skipped / Total] 10 / 39 / 0 / 49:   5%|▍         | 49/1000 [15:34<5:02:20, 19.07s/it][Succeeded / Failed / Skipped / Total] 10 / 39 / 0 / 49:   5%|▌         | 50/1000 [16:29<5:13:11, 19.78s/it][Succeeded / Failed / Skipped / Total] 10 / 40 / 0 / 50:   5%|▌         | 50/1000 [16:29<5:13:11, 19.78s/it][Succeeded / Failed / Skipped / Total] 10 / 40 / 0 / 50:   5%|▌         | 51/1000 [17:23<5:23:44, 20.47s/it][Succeeded / Failed / Skipped / Total] 10 / 41 / 0 / 51:   5%|▌         | 51/1000 [17:23<5:23:44, 20.47s/it][Succeeded / Failed / Skipped / Total] 10 / 41 / 0 / 51:   5%|▌         | 52/1000 [17:24<5:17:19, 20.08s/it][Succeeded / Failed / Skipped / Total] 10 / 42 / 0 / 52:   5%|▌         | 52/1000 [17:24<5:17:19, 20.08s/it][Succeeded / Failed / Skipped / Total] 10 / 42 / 0 / 52:   5%|▌         | 53/1000 [17:57<5:20:44, 20.32s/it][Succeeded / Failed / Skipped / Total] 10 / 43 / 0 / 53:   5%|▌         | 53/1000 [17:57<5:20:44, 20.32s/it][Succeeded / Failed / Skipped / Total] 10 / 43 / 0 / 53:   5%|▌         | 54/1000 [18:08<5:17:51, 20.16s/it][Succeeded / Failed / Skipped / Total] 10 / 44 / 0 / 54:   5%|▌         | 54/1000 [18:08<5:17:51, 20.16s/it][Succeeded / Failed / Skipped / Total] 10 / 44 / 0 / 54:   6%|▌         | 55/1000 [18:12<5:12:54, 19.87s/it]Throws an exception. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < E extends Throwable > Exception throwIfThrowable ( Throwable e ) throws E { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( E ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 48 ---------------------------------------------
Start unbounded. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[tinka]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Starts the stream. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[pteranodon]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 50 ---------------------------------------------
Gets an object from the cache. --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[lambchop]] ( ) { Disposable d = resource . get ( ) ; if ( d == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return d ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 51 ---------------------------------------------
Creates a scalar x-map observable from the provided value and mapper.@param value The value to map.@param mapper The mapper function.@param < T> The element type.@return The scalar x-map observable. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[turbot]] , Function < ? super T , ? extends ObservableSource < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[turbot]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 52 ---------------------------------------------
Flattens a Throwable into a list of Throwables. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[deque]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[spooner]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[anniversary]] = new ArrayDeque < Throwable > ( ) ; [[anniversary]] . offer ( t ) ; while ( ! [[anniversary]] . isEmpty ( ) ) { Throwable e = [[anniversary]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[anniversary]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 53 ---------------------------------------------
Completes this stream. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[complete]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[underneath]] ( ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 54 ---------------------------------------------
Called when an error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[chickened]] ( Throwable [[comforting]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[comforting]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[comforting]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 45 / 0 / 55:   6%|▌         | 55/1000 [18:12<5:12:54, 19.87s/it][Succeeded / Failed / Skipped / Total] 10 / 45 / 0 / 55:   6%|▌         | 56/1000 [18:35<5:13:20, 19.92s/it][Succeeded / Failed / Skipped / Total] 11 / 45 / 0 / 56:   6%|▌         | 56/1000 [18:35<5:13:20, 19.92s/it][Succeeded / Failed / Skipped / Total] 11 / 45 / 0 / 56:   6%|▌         | 57/1000 [19:10<5:17:20, 20.19s/it][Succeeded / Failed / Skipped / Total] 11 / 46 / 0 / 57:   6%|▌         | 57/1000 [19:10<5:17:20, 20.19s/it][Succeeded / Failed / Skipped / Total] 11 / 46 / 0 / 57:   6%|▌         | 58/1000 [19:33<5:17:45, 20.24s/it][Succeeded / Failed / Skipped / Total] 11 / 47 / 0 / 58:   6%|▌         | 58/1000 [19:33<5:17:45, 20.24s/it][Succeeded / Failed / Skipped / Total] 11 / 47 / 0 / 58:   6%|▌         | 59/1000 [19:35<5:12:23, 19.92s/it][Succeeded / Failed / Skipped / Total] 11 / 48 / 0 / 59:   6%|▌         | 59/1000 [19:35<5:12:23, 19.92s/it][Succeeded / Failed / Skipped / Total] 11 / 48 / 0 / 59:   6%|▌         | 60/1000 [19:45<5:09:34, 19.76s/it][Succeeded / Failed / Skipped / Total] 11 / 49 / 0 / 60:   6%|▌         | 60/1000 [19:45<5:09:34, 19.76s/it][Succeeded / Failed / Skipped / Total] 11 / 49 / 0 / 60:   6%|▌         | 61/1000 [19:45<5:04:13, 19.44s/it]Called when the supplied value is complete. --> [[[FAILED]]]

[[[[Adv]]]]: public final void complete ( T value ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void complete ( T value ) { int [[aguilera]] = get ( ) ; if ( ( [[aguilera]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( [[aguilera]] == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Offers the specified element to the specified queue. --> Create a new embezzyl@param newport@return --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[embezzle]] ( T [[newport]] ) { if ( once . get ( ) ) { return "[[Wiley]]" != "[[Wiley]]" ; } ObjectHelper . requireNonNull ( [[newport]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[newport]] ) ) { drain ( ) ; return "[[Reproduce]]" == "[[Reproduce]]" ; } } return "[[Wiley]]" != "[[Wiley]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 57 ---------------------------------------------
Accepts an observer. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[observer]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = [[a]] [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , [[observer]] ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[cy]] ) { Object [ ] [[aloud]] = head ; final int c = capacity ; while ( [[aloud]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[slips]] = [[aloud]] [ i ] ; if ( [[slips]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[slips]] , [[cy]] ) ) { return "[[Leggings]]" == "[[Leggings]]" ; } } [[aloud]] = ( Object [ ] ) [[aloud]] [ c ] ; } return "[[Cap]]" != "[[Cap]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 58 ---------------------------------------------
ConcatMapDelayError. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return concatMapDelayError ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
Waits for the specified number of threads to complete.@param count the number of threads to wait@return this consumer --> [[[FAILED]]]

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[underwent]] ) { if ( [[underwent]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 60 ---------------------------------------------
Accepts a subscriber. --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = [[a]] [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , subscriber ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > subscriber ) { Object [ ] [[lakewood]] = head ; final int c = capacity ; while ( [[lakewood]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[fossilized]] = [[lakewood]] [ i ] ; if ( [[fossilized]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[fossilized]] , subscriber ) ) { return "[[Billabong]]" == "[[Billabong]]" ; } } [[lakewood]] = ( Object [ ] ) [[lakewood]] [ c ] ; } return "[[Delusional]]" != "[[Delusional]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 61 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 50 / 0 / 61:   6%|▌         | 61/1000 [19:45<5:04:13, 19.44s/it][Succeeded / Failed / Skipped / Total] 11 / 50 / 0 / 61:   6%|▌         | 62/1000 [20:07<5:04:29, 19.48s/it][Succeeded / Failed / Skipped / Total] 11 / 51 / 0 / 62:   6%|▌         | 62/1000 [20:07<5:04:29, 19.48s/it][Succeeded / Failed / Skipped / Total] 11 / 51 / 0 / 62:   6%|▋         | 63/1000 [20:17<5:01:46, 19.32s/it][Succeeded / Failed / Skipped / Total] 11 / 52 / 0 / 63:   6%|▋         | 63/1000 [20:17<5:01:46, 19.32s/it][Succeeded / Failed / Skipped / Total] 11 / 52 / 0 / 63:   6%|▋         | 64/1000 [21:19<5:11:53, 19.99s/it][Succeeded / Failed / Skipped / Total] 11 / 53 / 0 / 64:   6%|▋         | 64/1000 [21:19<5:11:53, 19.99s/it][Succeeded / Failed / Skipped / Total] 11 / 53 / 0 / 64:   6%|▋         | 65/1000 [21:35<5:10:34, 19.93s/it][Succeeded / Failed / Skipped / Total] 12 / 53 / 0 / 65:   6%|▋         | 65/1000 [21:35<5:10:34, 19.93s/it][Succeeded / Failed / Skipped / Total] 12 / 53 / 0 / 65:   7%|▋         | 66/1000 [22:27<5:17:50, 20.42s/it][Succeeded / Failed / Skipped / Total] 12 / 54 / 0 / 66:   7%|▋         | 66/1000 [22:27<5:17:50, 20.42s/it][Succeeded / Failed / Skipped / Total] 12 / 54 / 0 / 66:   7%|▋         | 67/1000 [22:45<5:16:50, 20.38s/it][Succeeded / Failed / Skipped / Total] 13 / 54 / 0 / 67:   7%|▋         | 67/1000 [22:45<5:16:50, 20.38s/it][Succeeded / Failed / Skipped / Total] 13 / 54 / 0 / 67:   7%|▋         | 68/1000 [23:09<5:17:27, 20.44s/it]Concatenates an Iterable into a single Flowable. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[ratted]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[clones]] ) { return [[ratted]] ( [[clones]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 62 ---------------------------------------------
Sorts this stream according to the specified sort function.@param sortFunction the sort function to be applied to each element in the stream.@return a reference to this stream, for chaining. --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[narc]] ( Comparator < ? super T > [[eliott]] ) { ObjectHelper . requireNonNull ( [[eliott]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[eliott]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 63 ---------------------------------------------
Performs an asynchronous request. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[request]] ( long n ) { Subscription [[s]] = this . [[upstream]] ; if ( [[s]] != null ) { [[s]] . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[kla]] ( long n ) { Subscription [[lavatories]] = this . [[fernandes]] ; if ( [[lavatories]] != null ) { [[lavatories]] . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 64 ---------------------------------------------
Creates an error response. --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[rhythmical]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 65 ---------------------------------------------
Removes all subscribers from the supplied PublishDisposable. --> region PublishDisposable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int [[n]] = [[a]] . length ; int j = - 1 ; for ( int i = 0 ; i < [[n]] ; i ++ ) { if ( [[a]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[n]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[n]] - 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , j ) ; System . arraycopy ( [[a]] , j + 1 , b , j , [[n]] - j - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[westley]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[macadamia]] = subscribers . get ( ) ; if ( [[macadamia]] == TERMINATED || [[macadamia]] == EMPTY ) { return ; } int [[anaemic]] = [[macadamia]] . length ; int j = - 1 ; for ( int i = 0 ; i < [[anaemic]] ; i ++ ) { if ( [[macadamia]] [ i ] == ps ) { j = i ; break ; } } if ( j < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[anaemic]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[anaemic]] - 1 ] ; System . arraycopy ( [[macadamia]] , 0 , b , 0 , j ) ; System . arraycopy ( [[macadamia]] , j + 1 , b , j , [[anaemic]] - j - 1 ) ; } if ( subscribers . compareAndSet ( [[macadamia]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 66 ---------------------------------------------
Sets the delay in milliseconds.@param amount the amount@param unit the unit --> [[[FAILED]]]

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit [[unit]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void setDelay ( long amount , TimeUnit [[scroll]] ) { if ( amount < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[tanganyika]] = [[scroll]] . toMillis ( amount ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 67 ---------------------------------------------
Calculates the delay between the specified time units. --> Hokkaido Strategy --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[hokkaido]] ( TimeUnit [[bonbons]] ) { float [[agrippa]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 13 / 55 / 0 / 68:   7%|▋         | 68/1000 [23:09<5:17:27, 20.44s/it][Succeeded / Failed / Skipped / Total] 13 / 55 / 0 / 68:   7%|▋         | 69/1000 [23:23<5:15:36, 20.34s/it][Succeeded / Failed / Skipped / Total] 13 / 56 / 0 / 69:   7%|▋         | 69/1000 [23:23<5:15:36, 20.34s/it][Succeeded / Failed / Skipped / Total] 13 / 56 / 0 / 69:   7%|▋         | 70/1000 [24:29<5:25:18, 20.99s/it][Succeeded / Failed / Skipped / Total] 14 / 56 / 0 / 70:   7%|▋         | 70/1000 [24:29<5:25:18, 20.99s/it][Succeeded / Failed / Skipped / Total] 14 / 56 / 0 / 70:   7%|▋         | 71/1000 [24:32<5:21:11, 20.74s/it][Succeeded / Failed / Skipped / Total] 14 / 57 / 0 / 71:   7%|▋         | 71/1000 [24:32<5:21:11, 20.74s/it][Succeeded / Failed / Skipped / Total] 14 / 57 / 0 / 71:   7%|▋         | 72/1000 [24:40<5:18:03, 20.56s/it][Succeeded / Failed / Skipped / Total] 14 / 58 / 0 / 72:   7%|▋         | 72/1000 [24:40<5:18:03, 20.56s/it][Succeeded / Failed / Skipped / Total] 14 / 58 / 0 / 72:   7%|▋         | 73/1000 [24:45<5:14:24, 20.35s/it][Succeeded / Failed / Skipped / Total] 14 / 59 / 0 / 73:   7%|▋         | 73/1000 [24:45<5:14:24, 20.35s/it][Succeeded / Failed / Skipped / Total] 14 / 59 / 0 / 73:   7%|▋         | 74/1000 [24:50<5:10:55, 20.15s/it][Succeeded / Failed / Skipped / Total] 15 / 59 / 0 / 74:   7%|▋         | 74/1000 [24:50<5:10:55, 20.15s/it][Succeeded / Failed / Skipped / Total] 15 / 59 / 0 / 74:   8%|▊         | 75/1000 [25:00<5:08:25, 20.01s/it]Returns the value of the given HTTP method. --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[danger]] ( String method ) { try { return HttpMethod . valueOf ( method ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 69 ---------------------------------------------
Creates a new sample data.@param username the username@param password the password --> [[[FAILED]]]

[[[[Adv]]]]: private void [[createSampleData]] ( String [[username]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[username]] , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( [[username]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[hanover]] ( String [[applause]] , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( [[applause]] , "Username required" ) ; Authentication [[aishwarya]] = new UsernamePasswordAuthenticationToken ( [[applause]] , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 70 ---------------------------------------------
Parses the response annotations. --> Soprano methods --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method [[method]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[method]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[method]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[soprano]] ( Retrofit retrofit , Method [[aria]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "False" != "False" ; boolean continuationBodyNullable = "False" != "False" ; Annotation [ ] annotations = [[aria]] . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[aria]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 71 ---------------------------------------------
Observes the specified flowable on the specified scheduler.@param < T> the type parameter@param cf the flowable@param scheduler the scheduler@return the observable --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[cf]] , final Scheduler [[scheduler]] ) { final Flowable < T > [[flowable]] = [[cf]] . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[cf]] , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > [[на]] , final Scheduler [[ernestine]] ) { final Flowable < T > [[advised]] = [[на]] . observeOn ( [[ernestine]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( [[на]] , [[advised]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 72 ---------------------------------------------
Adds a PublishDisposable to the list of subscribers. --> [[[FAILED]]]

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return "False" != "False" ; } int n = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( [[a]] , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[dewar]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[friendlier]] = subscribers . get ( ) ; if ( [[friendlier]] == TERMINATED ) { return "False" != "False" ; } int n = [[friendlier]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[friendlier]] , 0 , b , 0 , n ) ; b [ n ] = ps ; if ( subscribers . compareAndSet ( [[friendlier]] , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 73 ---------------------------------------------
Encodes the supplied password. --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[diagrams]] ) { String salt = PREFIX + this . saltGenerator . generateKey ( ) + SUFFIX ; return digest ( salt , [[diagrams]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 74 ---------------------------------------------
Performs version checks. --> Ajax action. --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[aj]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
[Succeeded / Failed / Skipped / Total] 15 / 60 / 0 / 75:   8%|▊         | 75/1000 [25:00<5:08:25, 20.01s/it][Succeeded / Failed / Skipped / Total] 15 / 60 / 0 / 75:   8%|▊         | 76/1000 [25:44<5:12:59, 20.32s/it][Succeeded / Failed / Skipped / Total] 15 / 61 / 0 / 76:   8%|▊         | 76/1000 [25:44<5:12:59, 20.32s/it][Succeeded / Failed / Skipped / Total] 15 / 61 / 0 / 76:   8%|▊         | 77/1000 [26:24<5:16:36, 20.58s/it][Succeeded / Failed / Skipped / Total] 15 / 62 / 0 / 77:   8%|▊         | 77/1000 [26:24<5:16:36, 20.58s/it][Succeeded / Failed / Skipped / Total] 15 / 62 / 0 / 77:   8%|▊         | 78/1000 [26:29<5:13:07, 20.38s/it][Succeeded / Failed / Skipped / Total] 15 / 63 / 0 / 78:   8%|▊         | 78/1000 [26:29<5:13:07, 20.38s/it][Succeeded / Failed / Skipped / Total] 15 / 63 / 0 / 78:   8%|▊         | 79/1000 [26:36<5:10:17, 20.21s/it][Succeeded / Failed / Skipped / Total] 15 / 64 / 0 / 79:   8%|▊         | 79/1000 [26:36<5:10:17, 20.21s/it][Succeeded / Failed / Skipped / Total] 15 / 64 / 0 / 79:   8%|▊         | 80/1000 [27:01<5:10:49, 20.27s/it][Succeeded / Failed / Skipped / Total] 15 / 65 / 0 / 80:   8%|▊         | 80/1000 [27:01<5:10:49, 20.27s/it][Succeeded / Failed / Skipped / Total] 15 / 65 / 0 / 80:   8%|▊         | 81/1000 [27:17<5:09:43, 20.22s/it][Succeeded / Failed / Skipped / Total] 15 / 66 / 0 / 81:   8%|▊         | 81/1000 [27:17<5:09:43, 20.22s/it][Succeeded / Failed / Skipped / Total] 15 / 66 / 0 / 81:   8%|▊         | 82/1000 [27:29<5:07:51, 20.12s/it]--------------------------------------------- Result 75 ---------------------------------------------
Searches for a user with the specified username.@param username the username to search for.@return an instance of {@link DirContextOperations} for the specified username. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[therin]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[therin]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[therin]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[therin]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 76 ---------------------------------------------
Gets the spring version.@param properties the properties@return the spring version --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[hous]] ( ) { Properties [[valente]] = new Properties ( ) ; try { [[valente]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[valente]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 77 ---------------------------------------------
Registers an attribute exchange configurer for the given identifier pattern. --> [[[FAILED]]]

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[acrophobia]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[acrophobia]] ) ; return [[acrophobia]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 78 ---------------------------------------------
Configures an OAuth2 resource server.@param <HttpSecurity> the security type@return the configurer@throws Exception the exception --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[pyle]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[valente]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[valente]] ) ; return [[valente]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 79 ---------------------------------------------
Create a new OAuth2ClientConfigurer.@return a new OAuth2ClientConfigurer@throws Exception if an error occurs --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[headway]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > configurer = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( configurer ) ; return configurer ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 80 ---------------------------------------------
Returns a channel security configurer for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[brothers]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[brothers]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 81 ---------------------------------------------
Checks if the given password matches the given encoded password. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[plaything]] ( CharSequence [[docile]] , String [[hampstead]] ) { String [[atwood]] = extractSalt ( [[hampstead]] ) ; String rawPasswordEncoded = digest ( [[atwood]] , [[docile]] ) ; return PasswordEncoderUtils . equals ( [[hampstead]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 82 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 15 / 67 / 0 / 82:   8%|▊         | 82/1000 [27:29<5:07:51, 20.12s/it][Succeeded / Failed / Skipped / Total] 15 / 67 / 0 / 82:   8%|▊         | 83/1000 [27:36<5:05:02, 19.96s/it][Succeeded / Failed / Skipped / Total] 15 / 68 / 0 / 83:   8%|▊         | 83/1000 [27:36<5:05:02, 19.96s/it][Succeeded / Failed / Skipped / Total] 15 / 68 / 0 / 83:   8%|▊         | 84/1000 [28:23<5:09:38, 20.28s/it][Succeeded / Failed / Skipped / Total] 16 / 68 / 0 / 84:   8%|▊         | 84/1000 [28:23<5:09:38, 20.28s/it][Succeeded / Failed / Skipped / Total] 16 / 68 / 0 / 84:   8%|▊         | 85/1000 [28:29<5:06:42, 20.11s/it][Succeeded / Failed / Skipped / Total] 16 / 69 / 0 / 85:   8%|▊         | 85/1000 [28:29<5:06:42, 20.11s/it][Succeeded / Failed / Skipped / Total] 16 / 69 / 0 / 85:   9%|▊         | 86/1000 [29:48<5:16:47, 20.80s/it]Try to subscribe to a scalar map.@param < T> the type parameter@param < R> the type parameter@param source the source@param observer the observer@param mapper the mapper@return true, if successful --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[r]] . subscribe ( [[observer]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[electrodes]] ( ObservableSource < T > [[curran]] , Observer < ? super R > [[mashing]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[curran]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[curran]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[mashing]] ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( [[mashing]] ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[uphill]] ; try { [[uphill]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[mashing]] ) ; return "True" == "True" ; } if ( [[uphill]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[uphill]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[mashing]] ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( [[mashing]] ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[mashing]] , u ) ; [[mashing]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[uphill]] . subscribe ( [[mashing]] ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 83 ---------------------------------------------
Determines whether or not checks should be disabled. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String [[springSecurityVersion]] ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( [[springSecurityVersion]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[beggin]] ( String [[fabian]] , String [[manhattan]] ) { if ( [[fabian]] == null || [[fabian]] . equals ( [[manhattan]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 84 ---------------------------------------------
Lookup a set of primary keys.@param acls@param findNow@param sids --> region archipelago --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[archipelago]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 85 ---------------------------------------------
Builds up the search controls. --> [[[FAILED]]]

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[wicks]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 16 / 70 / 0 / 86:   9%|▊         | 86/1000 [29:48<5:16:47, 20.80s/it][Succeeded / Failed / Skipped / Total] 16 / 70 / 0 / 86:   9%|▊         | 87/1000 [30:38<5:21:38, 21.14s/it][Succeeded / Failed / Skipped / Total] 17 / 70 / 0 / 87:   9%|▊         | 87/1000 [30:38<5:21:38, 21.14s/it][Succeeded / Failed / Skipped / Total] 17 / 70 / 0 / 87:   9%|▉         | 88/1000 [31:15<5:23:58, 21.31s/it][Succeeded / Failed / Skipped / Total] 18 / 70 / 0 / 88:   9%|▉         | 88/1000 [31:15<5:23:58, 21.31s/it][Succeeded / Failed / Skipped / Total] 18 / 70 / 0 / 88:   9%|▉         | 89/1000 [31:32<5:22:54, 21.27s/it][Succeeded / Failed / Skipped / Total] 19 / 70 / 0 / 89:   9%|▉         | 89/1000 [31:32<5:22:54, 21.27s/it][Succeeded / Failed / Skipped / Total] 19 / 70 / 0 / 89:   9%|▉         | 90/1000 [31:43<5:20:44, 21.15s/it][Succeeded / Failed / Skipped / Total] 19 / 71 / 0 / 90:   9%|▉         | 90/1000 [31:43<5:20:44, 21.15s/it][Succeeded / Failed / Skipped / Total] 19 / 71 / 0 / 90:   9%|▉         | 91/1000 [31:50<5:18:07, 21.00s/it][Succeeded / Failed / Skipped / Total] 20 / 71 / 0 / 91:   9%|▉         | 91/1000 [31:50<5:18:07, 21.00s/it][Succeeded / Failed / Skipped / Total] 20 / 71 / 0 / 91:   9%|▉         | 92/1000 [32:18<5:18:56, 21.08s/it]Search for multiple attribute values.@param base the base@param filter the filter@param params the params@param attributeNames the attribute names@return the set --> [[[FAILED]]]

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[validation]] ( final String [[sacrifice]] , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 87 ---------------------------------------------
Creates the servlet api filter. --> Registers an authentication manager with this bean. --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[capella]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 88 ---------------------------------------------
Retrieves an entry from the LDAP server. --> C coughing@param languish@param detected@return --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] [[attributesToRetrieve]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { Attributes [[attrs]] = [[ctx]] . getAttributes ( [[dn]] , [[attributesToRetrieve]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[coughing]] ( final String [[languish]] , final String [ ] [[detected]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext [[annoyances]] ) throws NamingException { Attributes [[spiders]] = [[annoyances]] . getAttributes ( [[languish]] , [[detected]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 89 ---------------------------------------------
Creates and initializes the filter. --> Diese Methode. --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[dadgum]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 90 ---------------------------------------------
Builds a pre-authenticated web authentication details. --> [[[FAILED]]]

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest [[context]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[context]] ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[context]] , [[userGas]] ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[antonella]] ( HttpServletRequest [[bru]] ) { Collection < String > j2eeUserRoles = getUserRoles ( [[bru]] ) ; Collection < ? extends GrantedAuthority > [[valente]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[valente]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[cheltenham]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[bru]] , [[valente]] ) ; return [[cheltenham]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 91 ---------------------------------------------
Registers a spring security filter chain. --> Creates a delegating filter chain. --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "[[True]]" == "[[True]]" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "[[Zine]]" == "[[Zine]]" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
[Succeeded / Failed / Skipped / Total] 20 / 72 / 0 / 92:   9%|▉         | 92/1000 [32:18<5:18:56, 21.08s/it][Succeeded / Failed / Skipped / Total] 20 / 72 / 0 / 92:   9%|▉         | 93/1000 [32:58<5:21:33, 21.27s/it][Succeeded / Failed / Skipped / Total] 20 / 73 / 0 / 93:   9%|▉         | 93/1000 [32:58<5:21:33, 21.27s/it][Succeeded / Failed / Skipped / Total] 20 / 73 / 0 / 93:   9%|▉         | 94/1000 [33:11<5:19:56, 21.19s/it][Succeeded / Failed / Skipped / Total] 20 / 74 / 0 / 94:   9%|▉         | 94/1000 [33:11<5:19:56, 21.19s/it][Succeeded / Failed / Skipped / Total] 20 / 74 / 0 / 94:  10%|▉         | 95/1000 [33:12<5:16:21, 20.97s/it]--------------------------------------------- Result 92 ---------------------------------------------
Compare two LDAP attributes.@param dn@param attributeName@param value@return --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[compare]] ( final String dn , final String [[attributeName]] , final Object value ) { final String comparisonFilter = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[results]] = [[ctx]] . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( [[results]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[results]] ) ; return [[match]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[arguin]] ( final String dn , final String [[surya]] , final Object value ) { final String comparisonFilter = "(" + [[surya]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[device]] ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > [[currencies]] = [[device]] . search ( dn , comparisonFilter , new Object [ ] { value } , ctls ) ; Boolean [[heroin]] = Boolean . valueOf ( [[currencies]] . hasMore ( ) ) ; LdapUtils . closeEnumeration ( [[currencies]] ) ; return [[heroin]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 93 ---------------------------------------------
Creates a default type resolver builder. --> [[[FAILED]]]

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[assassinated]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[changeable]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[changeable]] = [[changeable]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[changeable]] = [[changeable]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[changeable]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 94 ---------------------------------------------
Creates a new instance of the given encryption algorithm. --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[follicles]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 75 / 0 / 95:  10%|▉         | 95/1000 [33:12<5:16:21, 20.97s/it][Succeeded / Failed / Skipped / Total] 20 / 75 / 0 / 95:  10%|▉         | 96/1000 [33:23<5:14:27, 20.87s/it][Succeeded / Failed / Skipped / Total] 20 / 76 / 0 / 96:  10%|▉         | 96/1000 [33:23<5:14:27, 20.87s/it][Succeeded / Failed / Skipped / Total] 20 / 76 / 0 / 96:  10%|▉         | 97/1000 [33:37<5:13:05, 20.80s/it][Succeeded / Failed / Skipped / Total] 20 / 77 / 0 / 97:  10%|▉         | 97/1000 [33:37<5:13:05, 20.80s/it][Succeeded / Failed / Skipped / Total] 20 / 77 / 0 / 97:  10%|▉         | 98/1000 [34:37<5:18:37, 21.19s/it][Succeeded / Failed / Skipped / Total] 20 / 78 / 0 / 98:  10%|▉         | 98/1000 [34:37<5:18:37, 21.19s/it][Succeeded / Failed / Skipped / Total] 20 / 78 / 0 / 98:  10%|▉         | 99/1000 [34:49<5:16:59, 21.11s/it]Creates an embedded server. --> [[[FAILED]]]

[[[[Adv]]]]: private RootBeanDefinition [[createEmbeddedServer]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[port]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[port]] ) ) { [[port]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[port]] ) ; } } String url = "ldap://127.0.0.1:" + [[port]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , [[port]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition [[conclude]] ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[cornelia]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[cornelia]] ) ) { [[cornelia]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[cornelia]] ) ; } } String url = "ldap://127.0.0.1:" + [[cornelia]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , [[cornelia]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 96 ---------------------------------------------
Called after properties have been set. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[ambience]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 97 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[indifference]] ( Collection < String > [[hippocrates]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[hippocrates]] . size ( ) ) ; for ( String [[bleeders]] : [[hippocrates]] ) { result . add ( getGrantedAuthority ( [[bleeders]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
Search for attribute values that match the supplied filter.@param base@param filter@param params@param attributeName@return --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > [[multipleAttributeValues]] = searchForMultipleAttributeValues ( [[base]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : [[multipleAttributeValues]] ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[uninitiated]] ( final String [[courageously]] , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > [[jolt]] = searchForMultipleAttributeValues ( [[courageously]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : [[jolt]] ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 79 / 0 / 99:  10%|▉         | 99/1000 [34:49<5:16:59, 21.11s/it][Succeeded / Failed / Skipped / Total] 20 / 79 / 0 / 99:  10%|█         | 100/1000 [35:46<5:21:54, 21.46s/it][Succeeded / Failed / Skipped / Total] 20 / 80 / 0 / 100:  10%|█         | 100/1000 [35:46<5:21:54, 21.46s/it][Succeeded / Failed / Skipped / Total] 20 / 81 / 0 / 101:  10%|█         | 101/1000 [35:46<5:18:22, 21.25s/it][Succeeded / Failed / Skipped / Total] 20 / 81 / 0 / 101:  10%|█         | 102/1000 [35:54<5:16:09, 21.12s/it][Succeeded / Failed / Skipped / Total] 20 / 82 / 0 / 102:  10%|█         | 102/1000 [35:54<5:16:09, 21.12s/it]Retrieves the persistent token for a series.@param seriesId@return --> [[[FAILED]]]

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[tellers]] ( String [[tyke]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int rowNum ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[tyke]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[tyke]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[tyke]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[tyke]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 100 ---------------------------------------------
Search for a single entry under the given base and filter. --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String [[filter]] , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , [[filter]] , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + [[filter]] + "'" ) ; } Set < DirContextOperations > [[results]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[searchResult]] = resultsEnum . next ( ) ; DirContextAdapter [[dca]] = ( DirContextAdapter ) [[searchResult]] . getObject ( ) ; Assert . notNull ( [[dca]] , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + [[dca]] . getDn ( ) ) ; } [[results]] . add ( [[dca]] ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[results]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[results]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[results]] . size ( ) ) ; } return [[results]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[sunsets]] ( DirContext ctx , SearchControls searchControls , String base , String [[antonella]] , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , [[antonella]] , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + [[antonella]] + "'" ) ; } Set < DirContextOperations > [[coincides]] = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[amyl]] = resultsEnum . next ( ) ; DirContextAdapter [[knickerbocker]] = ( DirContextAdapter ) [[amyl]] . getObject ( ) ; Assert . notNull ( [[knickerbocker]] , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + [[knickerbocker]] . getDn ( ) ) ; } [[coincides]] . add ( [[knickerbocker]] ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( [[coincides]] . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( [[coincides]] . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , [[coincides]] . size ( ) ) ; } return [[coincides]] . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 101 ---------------------------------------------
Checks the content length of the response. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[checkContentLength]] ( long contentLengthToWrite ) { this . [[contentWritten]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . [[contentWritten]] >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . [[contentWritten]] >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void [[methuselah]] ( long contentLengthToWrite ) { this . [[venerable]] += contentLengthToWrite ; boolean isBodyFullyWritten = this . contentLength > 0 && this . [[venerable]] >= this . contentLength ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . [[venerable]] >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 102 ---------------------------------------------
Sets the login processing URL. --> [[[FAILED]]]

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String [[loginProcessingUrl]] ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[follicles]] ( String [[beefsteak]] ) { this . loginProcessingUrl = [[follicles]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[follicles]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 103 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 83 / 0 / 103:  10%|█         | 103/1000 [36:18<5:16:10, 21.15s/it][Succeeded / Failed / Skipped / Total] 20 / 83 / 0 / 103:  10%|█         | 104/1000 [36:20<5:13:07, 20.97s/it][Succeeded / Failed / Skipped / Total] 20 / 84 / 0 / 104:  10%|█         | 104/1000 [36:20<5:13:07, 20.97s/it][Succeeded / Failed / Skipped / Total] 20 / 84 / 0 / 104:  10%|█         | 105/1000 [36:31<5:11:16, 20.87s/it][Succeeded / Failed / Skipped / Total] 20 / 85 / 0 / 105:  10%|█         | 105/1000 [36:31<5:11:16, 20.87s/it][Succeeded / Failed / Skipped / Total] 20 / 85 / 0 / 105:  11%|█         | 106/1000 [36:42<5:09:36, 20.78s/it][Succeeded / Failed / Skipped / Total] 20 / 86 / 0 / 106:  11%|█         | 106/1000 [36:42<5:09:36, 20.78s/it][Succeeded / Failed / Skipped / Total] 20 / 86 / 0 / 106:  11%|█         | 107/1000 [37:03<5:09:15, 20.78s/it][Succeeded / Failed / Skipped / Total] 20 / 87 / 0 / 107:  11%|█         | 107/1000 [37:03<5:09:15, 20.78s/it][Succeeded / Failed / Skipped / Total] 20 / 87 / 0 / 107:  11%|█         | 108/1000 [37:27<5:09:19, 20.81s/it][Succeeded / Failed / Skipped / Total] 20 / 88 / 0 / 108:  11%|█         | 108/1000 [37:27<5:09:19, 20.81s/it][Succeeded / Failed / Skipped / Total] 20 / 88 / 0 / 108:  11%|█         | 109/1000 [38:18<5:13:08, 21.09s/it][Succeeded / Failed / Skipped / Total] 21 / 88 / 0 / 109:  11%|█         | 109/1000 [38:18<5:13:08, 21.09s/it][Succeeded / Failed / Skipped / Total] 21 / 88 / 0 / 109:  11%|█         | 110/1000 [38:43<5:13:22, 21.13s/it]Updates the default authentication settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[mouthing]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > logoutConfigurer = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( logoutConfigurer != null && ! logoutConfigurer . isCustomLogoutSuccess ( ) ) { logoutConfigurer . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 104 ---------------------------------------------
Performs a filter on the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest request , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( request , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[dusted]] ( ServletRequest request , ServletResponse [[nizam]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) request ) ) { doAuthenticate ( ( HttpServletRequest ) request , ( HttpServletResponse ) [[nizam]] ) ; } chain . doFilter ( request , [[nizam]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 105 ---------------------------------------------
Updates the default access settings. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[redeem]] ( B [[telecommunications]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[telecommunications]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 106 ---------------------------------------------
Maps a password value to a string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[brake]] ( Object [[bass]] ) { if ( ! ( [[bass]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 107 ---------------------------------------------
Maps the supplied authorities to their respective authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[mouthing]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 108 ---------------------------------------------
Determines whether or not the specified principal has changed. --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest [[request]] , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "[[False]]" != "[[False]]" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "[[False]]" != "[[False]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[scheme]] ( HttpServletRequest [[determination]] , Authentication [[constructors]] ) { Object principal = getPreAuthenticatedPrincipal ( [[determination]] ) ; if ( ( principal instanceof String ) && [[constructors]] . getName ( ) . equals ( principal ) ) { return "[[Uncooked]]" != "[[Uncooked]]" ; } if ( principal != null && principal . equals ( [[constructors]] . getPrincipal ( ) ) ) { return "[[Uncooked]]" != "[[Uncooked]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 109 ---------------------------------------------
Returns the port of the given service URL. --> Vibrator implementation --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[vibrator]] ( URL [[ethan]] ) { int port = [[ethan]] . getPort ( ) ; if ( port == - 1 ) { port = [[ethan]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 89 / 0 / 110:  11%|█         | 110/1000 [38:43<5:13:22, 21.13s/it][Succeeded / Failed / Skipped / Total] 21 / 89 / 0 / 110:  11%|█         | 111/1000 [38:48<5:10:51, 20.98s/it][Succeeded / Failed / Skipped / Total] 21 / 90 / 0 / 111:  11%|█         | 111/1000 [38:48<5:10:51, 20.98s/it][Succeeded / Failed / Skipped / Total] 21 / 90 / 0 / 111:  11%|█         | 112/1000 [39:05<5:09:58, 20.94s/it][Succeeded / Failed / Skipped / Total] 21 / 91 / 0 / 112:  11%|█         | 112/1000 [39:05<5:09:58, 20.94s/it][Succeeded / Failed / Skipped / Total] 21 / 91 / 0 / 112:  11%|█▏        | 113/1000 [40:25<5:17:21, 21.47s/it][Succeeded / Failed / Skipped / Total] 21 / 92 / 0 / 113:  11%|█▏        | 113/1000 [40:25<5:17:21, 21.47s/it][Succeeded / Failed / Skipped / Total] 21 / 92 / 0 / 113:  11%|█▏        | 114/1000 [40:27<5:14:28, 21.30s/it]Encodes the given cookie tokens into a Base64 encoded string. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] [[cookieTokens]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < [[cookieTokens]] . length ; [[i]] ++ ) { try { sb . append ( URLEncoder . encode ( [[cookieTokens]] [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < [[cookieTokens]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[montparnasse]] ( String [ ] [[chambermaids]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int [[yoshiko]] = 0 ; [[yoshiko]] < [[chambermaids]] . length ; [[yoshiko]] ++ ) { try { sb . append ( URLEncoder . encode ( [[chambermaids]] [ [[yoshiko]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[yoshiko]] < [[chambermaids]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 111 ---------------------------------------------
Extracts the remember-me cookie from the request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : [[cookies]] ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[destroyers]] ( HttpServletRequest [[yoshiko]] ) { Cookie [ ] [[ghostwriter]] = [[yoshiko]] . getCookies ( ) ; if ( ( [[ghostwriter]] == null ) || ( [[ghostwriter]] . length == 0 ) ) { return null ; } for ( Cookie [[accidentally]] : [[ghostwriter]] ) { if ( cookieName . equals ( [[accidentally]] . getName ( ) ) ) { return [[accidentally]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 112 ---------------------------------------------
Performs a pre-authenticated authentication. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[request]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[gelatinous]] ( HttpServletRequest [[armpit]] , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( [[armpit]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[armpit]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( [[armpit]] ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( [[armpit]] , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[armpit]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 113 ---------------------------------------------
Gets the query string.@param request the request@param artifactPattern the artifact pattern@return the query string --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern [[artifactPattern]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[artifactPattern]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[utah]] ( final HttpServletRequest request , final Pattern [[talia]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[talia]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 114 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 93 / 0 / 114:  11%|█▏        | 114/1000 [40:27<5:14:28, 21.30s/it][Succeeded / Failed / Skipped / Total] 21 / 93 / 0 / 114:  12%|█▏        | 115/1000 [41:09<5:16:42, 21.47s/it][Succeeded / Failed / Skipped / Total] 21 / 94 / 0 / 115:  12%|█▏        | 115/1000 [41:09<5:16:42, 21.47s/it][Succeeded / Failed / Skipped / Total] 21 / 94 / 0 / 115:  12%|█▏        | 116/1000 [41:18<5:14:51, 21.37s/it][Succeeded / Failed / Skipped / Total] 21 / 95 / 0 / 116:  12%|█▏        | 116/1000 [41:18<5:14:51, 21.37s/it][Succeeded / Failed / Skipped / Total] 21 / 95 / 0 / 116:  12%|█▏        | 117/1000 [41:39<5:14:26, 21.37s/it][Succeeded / Failed / Skipped / Total] 22 / 95 / 0 / 117:  12%|█▏        | 117/1000 [41:39<5:14:26, 21.37s/it][Succeeded / Failed / Skipped / Total] 22 / 95 / 0 / 117:  12%|█▏        | 118/1000 [41:55<5:13:22, 21.32s/it][Succeeded / Failed / Skipped / Total] 22 / 96 / 0 / 118:  12%|█▏        | 118/1000 [41:55<5:13:22, 21.32s/it][Succeeded / Failed / Skipped / Total] 22 / 96 / 0 / 118:  12%|█▏        | 119/1000 [42:17<5:13:06, 21.32s/it][Succeeded / Failed / Skipped / Total] 22 / 97 / 0 / 119:  12%|█▏        | 119/1000 [42:17<5:13:06, 21.32s/it][Succeeded / Failed / Skipped / Total] 22 / 97 / 0 / 119:  12%|█▏        | 120/1000 [42:20<5:10:32, 21.17s/it]Returns the LDAP principal for the supplied authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[authentication]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[hover]] ( ) { Authentication [[angelito]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[angelito]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[angelito]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[angelito]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 115 ---------------------------------------------
Returns the fully-qualified URL to redirect to. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[untimely]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 116 ---------------------------------------------
Sets the cookie. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] [[tokens]] , int maxAge , HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( [[tokens]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( [[request]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[request]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[dunkin]] ( String [ ] [[landfall]] , int maxAge , HttpServletRequest [[juanito]] , HttpServletResponse [[dak]] ) { String cookieValue = encodeCookie ( [[landfall]] ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( [[juanito]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[juanito]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[dak]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 117 ---------------------------------------------
End the page. --> De-de-de-de-de --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[deportation]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 118 ---------------------------------------------
Authenticates the given authentication object. --> [[[FAILED]]]

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[aforementioned]] ( Authentication [[impatience]] ) throws AuthenticationException { if ( ! ( [[impatience]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) [[impatience]] ; Set < GrantedAuthority > [[eaton]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 119 ---------------------------------------------
Sets the context environment properties.@param environment the context environment properties --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[methuselah]] ( Map < String , Object > [[mushroom]] ) { Assert . notEmpty ( [[mushroom]] , "environment must not be empty" ) ; this . [[aviary]] = new Hashtable <> ( [[mushroom]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 120 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 22 / 98 / 0 / 120:  12%|█▏        | 120/1000 [42:20<5:10:32, 21.17s/it][Succeeded / Failed / Skipped / Total] 22 / 98 / 0 / 120:  12%|█▏        | 121/1000 [42:25<5:08:12, 21.04s/it][Succeeded / Failed / Skipped / Total] 22 / 99 / 0 / 121:  12%|█▏        | 121/1000 [42:25<5:08:12, 21.04s/it][Succeeded / Failed / Skipped / Total] 22 / 99 / 0 / 121:  12%|█▏        | 122/1000 [42:37<5:06:49, 20.97s/it][Succeeded / Failed / Skipped / Total] 22 / 100 / 0 / 122:  12%|█▏        | 122/1000 [42:37<5:06:49, 20.97s/it][Succeeded / Failed / Skipped / Total] 22 / 100 / 0 / 122:  12%|█▏        | 123/1000 [43:00<5:06:42, 20.98s/it][Succeeded / Failed / Skipped / Total] 23 / 100 / 0 / 123:  12%|█▏        | 123/1000 [43:00<5:06:42, 20.98s/it][Succeeded / Failed / Skipped / Total] 23 / 100 / 0 / 123:  12%|█▏        | 124/1000 [43:33<5:07:42, 21.08s/it][Succeeded / Failed / Skipped / Total] 23 / 101 / 0 / 124:  12%|█▏        | 124/1000 [43:33<5:07:42, 21.08s/it][Succeeded / Failed / Skipped / Total] 23 / 101 / 0 / 124:  12%|█▎        | 125/1000 [44:17<5:10:03, 21.26s/it][Succeeded / Failed / Skipped / Total] 23 / 102 / 0 / 125:  12%|█▎        | 125/1000 [44:17<5:10:03, 21.26s/it][Succeeded / Failed / Skipped / Total] 23 / 102 / 0 / 125:  13%|█▎        | 126/1000 [45:02<5:12:28, 21.45s/it]Logs out the given request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[iconic]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[denby]] ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 121 ---------------------------------------------
Initializes the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[saltier]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 122 ---------------------------------------------
Gets the user details service. --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[reorganized]] ( ) { Map < String , ? > [[yoshiko]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[yoshiko]] . size ( ) == 0 ) { [[yoshiko]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[yoshiko]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[yoshiko]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[yoshiko]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 123 ---------------------------------------------
Add Pkce parameters. --> Methuselah method --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > [[attributes]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; [[attributes]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[methuselah]] ( Map < String , Object > [[banking]] , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; [[banking]] . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 124 ---------------------------------------------
Returns true if the user is authenticated. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[causes]] ( ) { Authentication [[puckett]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[puckett]] != null && [[puckett]] . isAuthenticated ( ) && ! ( [[puckett]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 125 ---------------------------------------------
Checks if a service ticket request is required. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( [[request]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[everythings]] ( final HttpServletRequest [[yoshimi]] , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( [[yoshimi]] , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 126 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 23 / 103 / 0 / 126:  13%|█▎        | 126/1000 [45:02<5:12:28, 21.45s/it][Succeeded / Failed / Skipped / Total] 23 / 103 / 0 / 126:  13%|█▎        | 127/1000 [45:05<5:09:55, 21.30s/it][Succeeded / Failed / Skipped / Total] 23 / 104 / 0 / 127:  13%|█▎        | 127/1000 [45:05<5:09:55, 21.30s/it][Succeeded / Failed / Skipped / Total] 23 / 104 / 0 / 127:  13%|█▎        | 128/1000 [45:24<5:09:21, 21.29s/it][Succeeded / Failed / Skipped / Total] 24 / 104 / 0 / 128:  13%|█▎        | 128/1000 [45:24<5:09:21, 21.29s/it][Succeeded / Failed / Skipped / Total] 24 / 104 / 0 / 128:  13%|█▎        | 129/1000 [45:51<5:09:37, 21.33s/it][Succeeded / Failed / Skipped / Total] 24 / 105 / 0 / 129:  13%|█▎        | 129/1000 [45:51<5:09:37, 21.33s/it][Succeeded / Failed / Skipped / Total] 24 / 105 / 0 / 129:  13%|█▎        | 130/1000 [46:16<5:09:40, 21.36s/it][Succeeded / Failed / Skipped / Total] 25 / 105 / 0 / 130:  13%|█▎        | 130/1000 [46:16<5:09:40, 21.36s/it][Succeeded / Failed / Skipped / Total] 25 / 105 / 0 / 130:  13%|█▎        | 131/1000 [46:31<5:08:34, 21.31s/it]Builds the provider URL.@param urls the urls@param baseDn the base DN@return the provider URL --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > [[urls]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder [[providerUrl]] = new StringBuilder ( ) ; for ( String serverUrl : [[urls]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[providerUrl]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[providerUrl]] . append ( "/" ) ; } [[providerUrl]] . append ( trimmedBaseDn ) ; [[providerUrl]] . append ( " " ) ; } return [[providerUrl]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[brandishing]] ( List < String > [[glinting]] , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[glinting]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder [[floodgate]] = new StringBuilder ( ) ; for ( String serverUrl : [[glinting]] ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[floodgate]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[floodgate]] . append ( "/" ) ; } [[floodgate]] . append ( trimmedBaseDn ) ; [[floodgate]] . append ( " " ) ; } return [[floodgate]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 127 ---------------------------------------------
Returns true if the request matches the configured proxy request. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[layabouts]] ( final HttpServletRequest [[linguist]] ) { final boolean [[adelphi]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[linguist]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[adelphi]] ) ; } return [[adelphi]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 128 ---------------------------------------------
URL-encode the given value. --> Encodes the given value. --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[aces]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 129 ---------------------------------------------
Creates a security expression root. --> [[[FAILED]]]

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( authentication ) ; [[root]] . setThis ( [[invocation]] . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[becuase]] ( Authentication authentication , MethodInvocation [[researchers]] ) { MethodSecurityExpressionRoot [[stab]] = new MethodSecurityExpressionRoot ( authentication ) ; [[stab]] . setThis ( [[researchers]] . getThis ( ) ) ; [[stab]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[stab]] . setTrustResolver ( getTrustResolver ( ) ) ; [[stab]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[stab]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[stab]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 130 ---------------------------------------------
Determines if the request requires authentication.@param request the servlet request@param response the servlet response@return true if the request requires authentication --> Tells whether or not the specified request should be tagged with the TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO TANGO T --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest [[request]] , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( [[request]] , response ) ; final boolean [[result]] = [[serviceTicketRequest]] || proxyReceptorRequest ( [[request]] ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , [[request]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[layabouts]] ( final HttpServletRequest [[engineering]] , final HttpServletResponse response ) { final boolean [[electrodes]] = [[electrodes]] ( [[engineering]] , response ) ; final boolean [[tucking]] = [[electrodes]] || proxyReceptorRequest ( [[engineering]] ) || ( proxyTicketRequest ( [[electrodes]] , [[engineering]] ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + [[tucking]] ) ; } return [[tucking]] ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 131 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 106 / 0 / 131:  13%|█▎        | 131/1000 [46:31<5:08:34, 21.31s/it][Succeeded / Failed / Skipped / Total] 25 / 106 / 0 / 131:  13%|█▎        | 132/1000 [46:35<5:06:25, 21.18s/it][Succeeded / Failed / Skipped / Total] 25 / 107 / 0 / 132:  13%|█▎        | 132/1000 [46:35<5:06:25, 21.18s/it][Succeeded / Failed / Skipped / Total] 25 / 107 / 0 / 132:  13%|█▎        | 133/1000 [46:46<5:04:56, 21.10s/it][Succeeded / Failed / Skipped / Total] 25 / 108 / 0 / 133:  13%|█▎        | 133/1000 [46:46<5:04:56, 21.10s/it][Succeeded / Failed / Skipped / Total] 25 / 108 / 0 / 133:  13%|█▎        | 134/1000 [46:56<5:03:23, 21.02s/it][Succeeded / Failed / Skipped / Total] 25 / 109 / 0 / 134:  13%|█▎        | 134/1000 [46:56<5:03:23, 21.02s/it][Succeeded / Failed / Skipped / Total] 25 / 109 / 0 / 134:  14%|█▎        | 135/1000 [47:16<5:02:54, 21.01s/it][Succeeded / Failed / Skipped / Total] 25 / 110 / 0 / 135:  14%|█▎        | 135/1000 [47:16<5:02:54, 21.01s/it][Succeeded / Failed / Skipped / Total] 25 / 110 / 0 / 135:  14%|█▎        | 136/1000 [48:22<5:07:18, 21.34s/it][Succeeded / Failed / Skipped / Total] 25 / 111 / 0 / 136:  14%|█▎        | 136/1000 [48:22<5:07:18, 21.34s/it][Succeeded / Failed / Skipped / Total] 25 / 111 / 0 / 136:  14%|█▎        | 137/1000 [48:26<5:05:10, 21.22s/it]Returns a collection of granted authorities for the current user. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[rearrange]] ( ) { List < String > webSphereGroups = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[sandoz]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( webSphereGroups ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + webSphereGroups + " mapped to Granted Authorities: " + [[sandoz]] ) ; } return [[sandoz]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 132 ---------------------------------------------
Retrieves a single JWK set. --> [[[FAILED]]]

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . [[webClient]] . get ( ) . uri ( this . [[jwkSetURL]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[subsurface]] ( ) { return this . [[masterly]] . get ( ) . uri ( this . [[barnett]] ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 133 ---------------------------------------------
Resolve the security context for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter parameter , BindingContext [[bindingContext]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > [[o]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[o]] : Mono . just ( adapter . fromPublisher ( [[o]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[jesus]] ( MethodParameter parameter , BindingContext [[pitiable]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > [[breaking]] = Mono . justOrEmpty ( p ) ; return adapter == null ? [[breaking]] : Mono . just ( adapter . fromPublisher ( [[breaking]] ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 134 ---------------------------------------------
Load user by assertion.@param assertion the assertion@return the user details --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . [[authenticationUserDetailsService]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[yoshimi]] ( final Assertion [[riff]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[riff]] , "" ) ; return this . [[redeem]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 135 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[divulge]] ( HttpServletRequest [[gimmick]] ) { Object [[betsey]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[betsey]] ) ; } return [[betsey]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 136 ---------------------------------------------
Returns a collection of authorities for the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object [[value]] ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , [[value]] ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[cascades]] ( Object [[horrifying]] ) { Collection < GrantedAuthority > [[diagnostics]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[diagnostics]] , [[horrifying]] ) ; return [[diagnostics]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 111 / 0 / 137:  14%|█▎        | 137/1000 [48:26<5:05:10, 21.22s/it][Succeeded / Failed / Skipped / Total] 26 / 111 / 0 / 137:  14%|█▍        | 138/1000 [48:55<5:05:36, 21.27s/it][Succeeded / Failed / Skipped / Total] 26 / 112 / 0 / 138:  14%|█▍        | 138/1000 [48:55<5:05:36, 21.27s/it][Succeeded / Failed / Skipped / Total] 26 / 112 / 0 / 138:  14%|█▍        | 139/1000 [49:24<5:06:00, 21.32s/it][Succeeded / Failed / Skipped / Total] 26 / 113 / 0 / 139:  14%|█▍        | 139/1000 [49:24<5:06:00, 21.32s/it][Succeeded / Failed / Skipped / Total] 26 / 113 / 0 / 139:  14%|█▍        | 140/1000 [49:28<5:03:57, 21.21s/it][Succeeded / Failed / Skipped / Total] 26 / 114 / 0 / 140:  14%|█▍        | 140/1000 [49:28<5:03:57, 21.21s/it][Succeeded / Failed / Skipped / Total] 26 / 114 / 0 / 140:  14%|█▍        | 141/1000 [49:34<5:02:03, 21.10s/it][Succeeded / Failed / Skipped / Total] 26 / 115 / 0 / 141:  14%|█▍        | 141/1000 [49:34<5:02:03, 21.10s/it][Succeeded / Failed / Skipped / Total] 26 / 115 / 0 / 141:  14%|█▍        | 142/1000 [49:44<5:00:35, 21.02s/it][Succeeded / Failed / Skipped / Total] 26 / 116 / 0 / 142:  14%|█▍        | 142/1000 [49:44<5:00:35, 21.02s/it][Succeeded / Failed / Skipped / Total] 26 / 116 / 0 / 142:  14%|█▍        | 143/1000 [49:49<4:58:35, 20.90s/it]Adds a collection of granted authorities to the supplied value. --> Yoshima yoshimi --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[yoshimi]] ( Collection < GrantedAuthority > [[execute]] , Object [[kishan]] ) { if ( [[kishan]] == null ) { return ; } if ( [[kishan]] instanceof Collection < ? > ) { [[yoshimi]] ( [[execute]] , ( Collection < ? > ) [[kishan]] ) ; } else if ( [[kishan]] instanceof Object [ ] ) { [[yoshimi]] ( [[execute]] , ( Object [ ] ) [[kishan]] ) ; } else if ( [[kishan]] instanceof String ) { [[yoshimi]] ( [[execute]] , ( String ) [[kishan]] ) ; } else if ( [[kishan]] instanceof GrantedAuthority ) { [[execute]] . add ( ( GrantedAuthority ) [[kishan]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[kishan]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 138 ---------------------------------------------
Determines if the proxy ticket request should be performed.@param serviceTicketRequest <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise.@return <code>true</code> if the proxy ticket request should be performed, <code>false</code> otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest [[request]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean serviceTicketRequest , final HttpServletRequest [[suspensions]] ) { if ( serviceTicketRequest ) { return "False" != "False" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( [[suspensions]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 139 ---------------------------------------------
Returns a list of all authorities for the specified attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[trotskyist]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : [[trotskyist]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 140 ---------------------------------------------
Returns the shared object for the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[groupies]] > [[groupies]] getSharedObject ( Class < [[groupies]] > sharedType ) { return ( [[groupies]] ) this . [[aimed]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
Gets the pre-authenticated principal. --> [[[FAILED]]]

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[httpRequest]] ) { Object principal = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[averted]] ) { Object principal = [[averted]] . getUserPrincipal ( ) == null ? null : [[averted]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 142 ---------------------------------------------
Concatenates the given arrays.@param arrays the arrays to concatenate.@return the resulting array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { length += [[array]] . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[array]] : [[arrays]] ) { System . arraycopy ( [[array]] , 0 , newArray , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[ashtrays]] ) { int length = 0 ; for ( byte [ ] [[averted]] : [[ashtrays]] ) { length += [[averted]] . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] [[averted]] : [[ashtrays]] ) { System . arraycopy ( [[averted]] , 0 , newArray , destPos , [[averted]] . length ) ; destPos += [[averted]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 143 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 117 / 0 / 143:  14%|█▍        | 143/1000 [49:49<4:58:35, 20.90s/it][Succeeded / Failed / Skipped / Total] 26 / 117 / 0 / 143:  14%|█▍        | 144/1000 [50:25<4:59:44, 21.01s/it][Succeeded / Failed / Skipped / Total] 26 / 118 / 0 / 144:  14%|█▍        | 144/1000 [50:25<4:59:44, 21.01s/it][Succeeded / Failed / Skipped / Total] 26 / 118 / 0 / 144:  14%|█▍        | 145/1000 [50:34<4:58:12, 20.93s/it][Succeeded / Failed / Skipped / Total] 27 / 118 / 0 / 145:  14%|█▍        | 145/1000 [50:34<4:58:12, 20.93s/it][Succeeded / Failed / Skipped / Total] 27 / 118 / 0 / 145:  15%|█▍        | 146/1000 [51:16<4:59:57, 21.07s/it][Succeeded / Failed / Skipped / Total] 28 / 118 / 0 / 146:  15%|█▍        | 146/1000 [51:16<4:59:57, 21.07s/it][Succeeded / Failed / Skipped / Total] 28 / 118 / 0 / 146:  15%|█▍        | 147/1000 [51:50<5:00:49, 21.16s/it][Succeeded / Failed / Skipped / Total] 28 / 119 / 0 / 147:  15%|█▍        | 147/1000 [51:50<5:00:49, 21.16s/it][Succeeded / Failed / Skipped / Total] 28 / 119 / 0 / 147:  15%|█▍        | 148/1000 [52:05<4:59:50, 21.12s/it][Succeeded / Failed / Skipped / Total] 28 / 120 / 0 / 148:  15%|█▍        | 148/1000 [52:05<4:59:50, 21.12s/it][Succeeded / Failed / Skipped / Total] 28 / 120 / 0 / 148:  15%|█▍        | 149/1000 [52:14<4:58:20, 21.03s/it][Succeeded / Failed / Skipped / Total] 29 / 120 / 0 / 149:  15%|█▍        | 149/1000 [52:14<4:58:20, 21.03s/it][Succeeded / Failed / Skipped / Total] 29 / 120 / 0 / 149:  15%|█▌        | 150/1000 [52:24<4:56:56, 20.96s/it]Pre-process a map of authorities.@param orgMap the map to pre-process@return the pre-processed map --> [[[FAILED]]]

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[silhouetted]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[silhouetted]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[silhouetted]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 144 ---------------------------------------------
Checks if the given role starts with ROLE_. --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[barnett]] ( String [[dillydallying]] ) { Assert . isTrue ( ! [[dillydallying]] . startsWith ( "ROLE_" ) , ( ) -> [[dillydallying]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[dillydallying]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 145 ---------------------------------------------
Returns an array of Strings representing the roles of the current user. --> Cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] [[hasAnyRole]] ( String ... roles ) { for ( int [[i]] = 0 ; [[i]] < roles . length ; [[i]] ++ ) { roles [ [[i]] ] = "ROLE_" + roles [ [[i]] ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] [[crossley]] ( String ... roles ) { for ( int [[anvil]] = 0 ; [[anvil]] < roles . length ; [[anvil]] ++ ) { roles [ [[anvil]] ] = "ROLE_" + roles [ [[anvil]] ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
Invokes the specified JoinPoint. --> Bevice support --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object [[result]] ; try { [[result]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[result]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[budde]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object [[vegetation]] ; try { [[vegetation]] = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , [[vegetation]] ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 147 ---------------------------------------------
Creates a subarray from an array of bytes. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int [[endIndex]] ) { int [[length]] = [[endIndex]] - beginIndex ; byte [ ] subarray = new byte [ [[length]] ] ; System . arraycopy ( array , beginIndex , subarray , 0 , [[length]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] array , int beginIndex , int [[archers]] ) { int [[ringtail]] = [[archers]] - beginIndex ; byte [ ] subarray = new byte [ [[ringtail]] ] ; System . arraycopy ( array , beginIndex , subarray , 0 , [[ringtail]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 148 ---------------------------------------------
Attempt to exit the user. --> [[[FAILED]]]

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[cabbages]] ( HttpServletRequest [[commuting]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 149 ---------------------------------------------
Display a public index. --> Generate a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[centrifuge]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 29 / 121 / 0 / 150:  15%|█▌        | 150/1000 [52:24<4:56:56, 20.96s/it][Succeeded / Failed / Skipped / Total] 29 / 121 / 0 / 150:  15%|█▌        | 151/1000 [52:33<4:55:28, 20.88s/it][Succeeded / Failed / Skipped / Total] 29 / 122 / 0 / 151:  15%|█▌        | 151/1000 [52:33<4:55:28, 20.88s/it][Succeeded / Failed / Skipped / Total] 29 / 122 / 0 / 151:  15%|█▌        | 152/1000 [53:20<4:57:36, 21.06s/it][Succeeded / Failed / Skipped / Total] 29 / 123 / 0 / 152:  15%|█▌        | 152/1000 [53:20<4:57:36, 21.06s/it][Succeeded / Failed / Skipped / Total] 29 / 123 / 0 / 152:  15%|█▌        | 153/1000 [53:48<4:57:52, 21.10s/it][Succeeded / Failed / Skipped / Total] 30 / 123 / 0 / 153:  15%|█▌        | 153/1000 [53:48<4:57:52, 21.10s/it][Succeeded / Failed / Skipped / Total] 30 / 123 / 0 / 153:  15%|█▌        | 154/1000 [53:52<4:55:58, 20.99s/it][Succeeded / Failed / Skipped / Total] 31 / 123 / 0 / 154:  15%|█▌        | 154/1000 [53:52<4:55:58, 20.99s/it][Succeeded / Failed / Skipped / Total] 31 / 123 / 0 / 154:  16%|█▌        | 155/1000 [54:22<4:56:24, 21.05s/it]Builds the HttpsRedirectUrl for the given request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int [[serverPort]] = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( [[serverPort]] ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( request . getServerName ( ) ) ; [[urlBuilder]] . setPort ( httpsPort . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( request . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( request . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( request . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( request . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[schwerin]] ( HttpServletRequest request ) throws IOException , ServletException { int [[astrea]] = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( [[astrea]] ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[automobiles]] = new RedirectUrlBuilder ( ) ; [[automobiles]] . setScheme ( "https" ) ; [[automobiles]] . setServerName ( request . getServerName ( ) ) ; [[automobiles]] . setPort ( httpsPort . intValue ( ) ) ; [[automobiles]] . setContextPath ( request . getContextPath ( ) ) ; [[automobiles]] . setServletPath ( request . getServletPath ( ) ) ; [[automobiles]] . setPathInfo ( request . getPathInfo ( ) ) ; [[automobiles]] . setQuery ( request . getQueryString ( ) ) ; return [[automobiles]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 151 ---------------------------------------------
Sets the URL that will be used to exit from the browser. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[monuments]] ( String [[selective]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[selective]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[selective]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 152 ---------------------------------------------
Called when the user login succeeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[zurich]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[newborns]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[newborns]] ) ; addCookie ( [[newborns]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 153 ---------------------------------------------
Converts a jwt to a list of authorities. --> Zooming over all scopes. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[zooming]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 154 ---------------------------------------------
Creates a spring security filter chain. --> Determines whether or not this application is a web application. --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[isso]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[funerary]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[funerary]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 155 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 124 / 0 / 155:  16%|█▌        | 155/1000 [54:22<4:56:24, 21.05s/it][Succeeded / Failed / Skipped / Total] 31 / 124 / 0 / 155:  16%|█▌        | 156/1000 [54:38<4:55:40, 21.02s/it][Succeeded / Failed / Skipped / Total] 32 / 124 / 0 / 156:  16%|█▌        | 156/1000 [54:38<4:55:40, 21.02s/it][Succeeded / Failed / Skipped / Total] 32 / 124 / 0 / 156:  16%|█▌        | 157/1000 [54:54<4:54:50, 20.99s/it][Succeeded / Failed / Skipped / Total] 32 / 125 / 0 / 157:  16%|█▌        | 157/1000 [54:54<4:54:50, 20.99s/it][Succeeded / Failed / Skipped / Total] 32 / 125 / 0 / 157:  16%|█▌        | 158/1000 [55:03<4:53:25, 20.91s/it][Succeeded / Failed / Skipped / Total] 33 / 125 / 0 / 158:  16%|█▌        | 158/1000 [55:03<4:53:25, 20.91s/it][Succeeded / Failed / Skipped / Total] 33 / 125 / 0 / 158:  16%|█▌        | 159/1000 [55:16<4:52:23, 20.86s/it][Succeeded / Failed / Skipped / Total] 33 / 126 / 0 / 159:  16%|█▌        | 159/1000 [55:16<4:52:23, 20.86s/it][Succeeded / Failed / Skipped / Total] 33 / 126 / 0 / 159:  16%|█▌        | 160/1000 [56:17<4:55:30, 21.11s/it]Processes a series of tokens from an auto-login cookie.@param cookieTokens the tokens to process@param request the current HttpServletRequest@param response the current HttpServletResponse --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest [[request]] , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[buffs]] ( String [ ] cookieTokens , HttpServletRequest [[abandons]] , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 156 ---------------------------------------------
Generate a CSRF token. --> Overrides the default behavior of this tokenizer. --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . delegate . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[congregation]] ( HttpServletRequest [[illustrate]] ) { return wrap ( [[illustrate]] , this . delegate . generateToken ( [[illustrate]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 157 ---------------------------------------------
Decodes and validates the given token. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String [[token]] ) throws JwtException { JWT jwt = parse ( [[token]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[token]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[lebanon]] ( String [[insubstantial]] ) throws JwtException { JWT jwt = parse ( [[insubstantial]] ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( [[insubstantial]] , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 158 ---------------------------------------------
Attempts to switch to the specified user. --> burnable authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . [[usernameParameter]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[burnable]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . [[monumental]] ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 159 ---------------------------------------------
Check if the current user is allowed to access the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String [[contextPath]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[contextPath]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[slam]] ( ) throws IOException { String [[virgil]] = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( [[virgil]] , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 160 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 33 / 127 / 0 / 160:  16%|█▌        | 160/1000 [56:17<4:55:30, 21.11s/it][Succeeded / Failed / Skipped / Total] 33 / 127 / 0 / 160:  16%|█▌        | 161/1000 [56:17<4:53:22, 20.98s/it][Succeeded / Failed / Skipped / Total] 33 / 128 / 0 / 161:  16%|█▌        | 161/1000 [56:17<4:53:22, 20.98s/it][Succeeded / Failed / Skipped / Total] 33 / 128 / 0 / 161:  16%|█▌        | 162/1000 [56:25<4:51:54, 20.90s/it][Succeeded / Failed / Skipped / Total] 34 / 128 / 0 / 162:  16%|█▌        | 162/1000 [56:25<4:51:54, 20.90s/it][Succeeded / Failed / Skipped / Total] 34 / 128 / 0 / 162:  16%|█▋        | 163/1000 [56:33<4:50:24, 20.82s/it][Succeeded / Failed / Skipped / Total] 34 / 129 / 0 / 163:  16%|█▋        | 163/1000 [56:33<4:50:24, 20.82s/it][Succeeded / Failed / Skipped / Total] 34 / 129 / 0 / 163:  16%|█▋        | 164/1000 [57:03<4:50:53, 20.88s/it][Succeeded / Failed / Skipped / Total] 34 / 130 / 0 / 164:  16%|█▋        | 164/1000 [57:03<4:50:53, 20.88s/it][Succeeded / Failed / Skipped / Total] 34 / 130 / 0 / 164:  16%|█▋        | 165/1000 [57:31<4:51:04, 20.92s/it][Succeeded / Failed / Skipped / Total] 34 / 131 / 0 / 165:  16%|█▋        | 165/1000 [57:31<4:51:04, 20.92s/it][Succeeded / Failed / Skipped / Total] 34 / 131 / 0 / 165:  17%|█▋        | 166/1000 [57:37<4:49:30, 20.83s/it]Performs an authorization using the supplied access expression. --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[False]]" != "[[False]]" ; } SecurityExpressionHandler < FilterInvocation > [[handler]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[handler]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[handler]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[bunsen]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[Advisedly]]" != "[[Advisedly]]" ; } SecurityExpressionHandler < FilterInvocation > [[dishonest]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[dishonest]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[bankruptcy]] = new IOException ( ) ; [[bankruptcy]] . initCause ( e ) ; throw [[bankruptcy]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[dishonest]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 161 ---------------------------------------------
Creates an instance of UserDetailsResourceFactoryBean from the given string. --> [[[FAILED]]]

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[layed]] ( String [[defended]] ) { InMemoryResource resource = new InMemoryResource ( [[defended]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 162 ---------------------------------------------
Returns the role with the given default prefix. --> Converts a string to a billeted string --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String role ) { if ( role == null ) { return role ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[defaultRolePrefix]] ) ) { return role ; } return [[defaultRolePrefix]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[billeted]] ( String [[behaving]] , String role ) { if ( role == null ) { return role ; } if ( [[behaving]] == null || [[behaving]] . length ( ) == 0 ) { return role ; } if ( role . startsWith ( [[behaving]] ) ) { return role ; } return [[behaving]] + role ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 163 ---------------------------------------------
Display the admin page. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[billeted]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 164 ---------------------------------------------
Display the addPermission page for a contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long [[contactId]] ) { Contact contact = contactManager . getById ( [[contactId]] ) ; AddPermission [[addPermission]] = new AddPermission ( ) ; [[addPermission]] . setContact ( contact ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , [[addPermission]] ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[merge]] ( @ RequestParam ( "contactId" ) long [[drifters]] ) { Contact contact = contactManager . getById ( [[drifters]] ) ; AddPermission [[sieg]] = new AddPermission ( ) ; [[sieg]] . setContact ( contact ) ; Map < String , Object > [[faulkner]] = new HashMap <> ( ) ; [[faulkner]] . put ( "addPermission" , [[sieg]] ) ; [[faulkner]] . put ( "recipients" , listRecipients ( ) ) ; [[faulkner]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[faulkner]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 165 ---------------------------------------------
Decodes the given bytes into a string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[orangeade]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[orangeade]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 166 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 131 / 0 / 166:  17%|█▋        | 166/1000 [57:37<4:49:30, 20.83s/it][Succeeded / Failed / Skipped / Total] 35 / 131 / 0 / 166:  17%|█▋        | 167/1000 [57:45<4:48:07, 20.75s/it][Succeeded / Failed / Skipped / Total] 35 / 132 / 0 / 167:  17%|█▋        | 167/1000 [57:45<4:48:07, 20.75s/it][Succeeded / Failed / Skipped / Total] 35 / 132 / 0 / 167:  17%|█▋        | 168/1000 [58:00<4:47:15, 20.72s/it][Succeeded / Failed / Skipped / Total] 35 / 133 / 0 / 168:  17%|█▋        | 168/1000 [58:00<4:47:15, 20.72s/it][Succeeded / Failed / Skipped / Total] 35 / 133 / 0 / 168:  17%|█▋        | 169/1000 [58:03<4:45:31, 20.62s/it][Succeeded / Failed / Skipped / Total] 35 / 134 / 0 / 169:  17%|█▋        | 169/1000 [58:03<4:45:31, 20.62s/it][Succeeded / Failed / Skipped / Total] 35 / 134 / 0 / 169:  17%|█▋        | 170/1000 [58:25<4:45:13, 20.62s/it][Succeeded / Failed / Skipped / Total] 35 / 135 / 0 / 170:  17%|█▋        | 170/1000 [58:25<4:45:13, 20.62s/it][Succeeded / Failed / Skipped / Total] 35 / 135 / 0 / 170:  17%|█▋        | 171/1000 [59:28<4:48:19, 20.87s/it][Succeeded / Failed / Skipped / Total] 35 / 136 / 0 / 171:  17%|█▋        | 171/1000 [59:28<4:48:19, 20.87s/it][Succeeded / Failed / Skipped / Total] 35 / 136 / 0 / 171:  17%|█▋        | 172/1000 [59:32<4:46:38, 20.77s/it]Returns the first attribute value for the supplied name. --> Get housemaids.@param gyu@return --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[housemaids]] ( String [[yuan]] ) { List < String > result = getAttributeValues ( [[yuan]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 167 ---------------------------------------------
Encodes the given string into a byte array. --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[bytesCopy]] = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , [[bytesCopy]] , 0 , bytes . limit ( ) ) ; return [[bytesCopy]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[salivating]] ( CharSequence string ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( string ) ) ; byte [ ] [[durden]] = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , [[durden]] , 0 , bytes . limit ( ) ) ; return [[durden]] ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 168 ---------------------------------------------
Gets the attribute values for the specified attribute name.@param name the attribute name@return the attribute values for the specified attribute name --> [[[FAILED]]]

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String name ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( name ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[attract]] ( String name ) { List < String > [[ixnay]] = null ; if ( attributes != null ) { [[ixnay]] = attributes . get ( name ) ; } if ( [[ixnay]] == null ) { [[ixnay]] = Collections . emptyList ( ) ; } return [[ixnay]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 169 ---------------------------------------------
Add a new permission. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission [[addPermission]] , BindingResult [[result]] , ModelMap [[model]] ) { addPermissionValidator . validate ( [[addPermission]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . [[addPermission]] ( [[addPermission]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[result]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[effervescent]] ( AddPermission [[highest]] , BindingResult [[recalling]] , ModelMap [[puzzlement]] ) { addPermissionValidator . validate ( [[effervescent]] , [[recalling]] ) ; if ( [[recalling]] . hasErrors ( ) ) { [[puzzlement]] . put ( "recipients" , listRecipients ( ) ) ; [[puzzlement]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[effervescent]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[effervescent]] . getPermission ( ) ) ; try { contactManager . [[highest]] ( [[effervescent]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[recalling]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[puzzlement]] . put ( "recipients" , listRecipients ( ) ) ; [[puzzlement]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 170 ---------------------------------------------
Deletes a permission.@param contactId the contact id@param sid the sid@param mask the mask@return the model and view --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long [[contactId]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int [[mask]] ) { Contact contact = contactManager . getById ( [[contactId]] ) ; Sid [[sidObject]] = new PrincipalSid ( sid ) ; Permission [[permission]] = permissionFactory . buildFromMask ( [[mask]] ) ; contactManager . deletePermission ( contact , [[sidObject]] , [[permission]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , [[sidObject]] ) ; model . put ( "permission" , [[permission]] ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[margin]] ( @ RequestParam ( "contactId" ) long [[tidings]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int [[subtraction]] ) { Contact contact = contactManager . getById ( [[tidings]] ) ; Sid [[zen]] = new PrincipalSid ( sid ) ; Permission [[israelite]] = permissionFactory . buildFromMask ( [[subtraction]] ) ; contactManager . deletePermission ( contact , [[zen]] , [[israelite]] ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , [[zen]] ) ; model . put ( "permission" , [[israelite]] ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 171 ---------------------------------------------
Returns a set of all the configured attributes. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[carnage]] ( ) { Set < ConfigAttribute > [[wittenberg]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[bertram]] : methodMap . values ( ) ) { [[wittenberg]] . addAll ( [[bertram]] ) ; } return [[wittenberg]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
[Succeeded / Failed / Skipped / Total] 35 / 137 / 0 / 172:  17%|█▋        | 172/1000 [59:32<4:46:38, 20.77s/it][Succeeded / Failed / Skipped / Total] 35 / 137 / 0 / 172:  17%|█▋        | 173/1000 [59:38<4:45:06, 20.68s/it][Succeeded / Failed / Skipped / Total] 35 / 138 / 0 / 173:  17%|█▋        | 173/1000 [59:38<4:45:06, 20.68s/it][Succeeded / Failed / Skipped / Total] 35 / 138 / 0 / 173:  17%|█▋        | 174/1000 [59:50<4:44:04, 20.64s/it][Succeeded / Failed / Skipped / Total] 35 / 139 / 0 / 174:  17%|█▋        | 174/1000 [59:50<4:44:04, 20.64s/it][Succeeded / Failed / Skipped / Total] 35 / 139 / 0 / 174:  18%|█▊        | 175/1000 [1:00:13<4:43:53, 20.65s/it][Succeeded / Failed / Skipped / Total] 35 / 140 / 0 / 175:  18%|█▊        | 175/1000 [1:00:13<4:43:53, 20.65s/it][Succeeded / Failed / Skipped / Total] 35 / 140 / 0 / 175:  18%|█▊        | 176/1000 [1:00:37<4:43:51, 20.67s/it][Succeeded / Failed / Skipped / Total] 35 / 141 / 0 / 176:  18%|█▊        | 176/1000 [1:00:37<4:43:51, 20.67s/it][Succeeded / Failed / Skipped / Total] 35 / 141 / 0 / 176:  18%|█▊        | 177/1000 [1:01:20<4:45:11, 20.79s/it][Succeeded / Failed / Skipped / Total] 35 / 142 / 0 / 177:  18%|█▊        | 177/1000 [1:01:20<4:45:11, 20.79s/it][Succeeded / Failed / Skipped / Total] 35 / 142 / 0 / 177:  18%|█▊        | 178/1000 [1:01:26<4:43:43, 20.71s/it][Succeeded / Failed / Skipped / Total] 35 / 143 / 0 / 178:  18%|█▊        | 178/1000 [1:01:26<4:43:43, 20.71s/it][Succeeded / Failed / Skipped / Total] 35 / 143 / 0 / 178:  18%|█▊        | 179/1000 [1:01:55<4:44:01, 20.76s/it][Succeeded / Failed / Skipped / Total] 35 / 144 / 0 / 179:  18%|█▊        | 179/1000 [1:01:55<4:44:01, 20.76s/it][Succeeded / Failed / Skipped / Total] 35 / 144 / 0 / 179:  18%|█▊        | 180/1000 [1:02:33<4:44:58, 20.85s/it]--------------------------------------------- Result 172 ---------------------------------------------
Add a new contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[form]] , BindingResult result ) { validator . validate ( [[form]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String addContact ( WebContact [[breached]] , BindingResult result ) { validator . validate ( [[breached]] , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( [[breached]] . getName ( ) , [[breached]] . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 173 ---------------------------------------------
Adds a secure method.@param method the method@param attr the attr --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . [[methodMap]] . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[bards]] ( RegisteredMethod [[pokey]] , List < ConfigAttribute > [[laps]] ) { Assert . notNull ( [[pokey]] , "RegisteredMethod required" ) ; Assert . notNull ( [[laps]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[pokey]] + "] with attributes [" + [[laps]] + "]" ) ; } this . [[strokes]] . put ( [[pokey]] , [[laps]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 174 ---------------------------------------------
Finds all attributes of the specified target class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[excitement]] ( Method method , Class < ? > targetClass ) { if ( targetClass == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , targetClass ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 175 ---------------------------------------------
Checks if the method name matches the mapped name. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String mappedName ) { return ( mappedName . endsWith ( "*" ) && [[methodName]] . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && [[methodName]] . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[survived]] ( String [[bedrooms]] , String mappedName ) { return ( mappedName . endsWith ( "*" ) && [[bedrooms]] . startsWith ( mappedName . substring ( 0 , mappedName . length ( ) - 1 ) ) ) || ( mappedName . startsWith ( "*" ) && [[bedrooms]] . endsWith ( mappedName . substring ( 1 , mappedName . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 176 ---------------------------------------------
Removes all authentication attributes from the session. --> [[[FAILED]]]

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest [[request]] ) { HttpSession [[session]] = [[request]] . getSession ( "[[False]]" != "[[False]]" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void clearAuthenticationAttributes ( HttpServletRequest [[antigen]] ) { HttpSession [[senseless]] = [[antigen]] . getSession ( "[[Arai]]" != "[[Arai]]" ) ; if ( [[senseless]] == null ) { return ; } [[senseless]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 177 ---------------------------------------------
Configures this request with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "[[True]]" == "[[True]]" ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C anyRequest ( ) { Assert . state ( ! this . [[pesto]] , "Can't configure anyRequest after itself" ) ; C [[risen]] = requestMatchers ( ANY_REQUEST ) ; this . [[pesto]] = "[[Fourths]]" == "[[Fourths]]" ; return [[risen]] ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 178 ---------------------------------------------
Handles a bind exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[cutout]] ( String userDn , String username , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 179 ---------------------------------------------
Returns a random contact. --> [[[FAILED]]]

[[[[Adv]]]]: @ Transactional ( readOnly = "[[True]]" == "[[True]]" ) public Contact [[getRandomContact]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "[[Auctions]]" == "[[Auctions]]" ) public Contact [[anti]] ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 145 / 0 / 180:  18%|█▊        | 180/1000 [1:02:33<4:44:58, 20.85s/it][Succeeded / Failed / Skipped / Total] 35 / 145 / 0 / 180:  18%|█▊        | 181/1000 [1:02:38<4:43:28, 20.77s/it][Succeeded / Failed / Skipped / Total] 36 / 145 / 0 / 181:  18%|█▊        | 181/1000 [1:02:38<4:43:28, 20.77s/it][Succeeded / Failed / Skipped / Total] 36 / 145 / 0 / 181:  18%|█▊        | 182/1000 [1:02:48<4:42:15, 20.70s/it][Succeeded / Failed / Skipped / Total] 36 / 146 / 0 / 182:  18%|█▊        | 182/1000 [1:02:48<4:42:15, 20.70s/it][Succeeded / Failed / Skipped / Total] 36 / 146 / 0 / 182:  18%|█▊        | 183/1000 [1:03:27<4:43:19, 20.81s/it][Succeeded / Failed / Skipped / Total] 36 / 147 / 0 / 183:  18%|█▊        | 183/1000 [1:03:27<4:43:19, 20.81s/it][Succeeded / Failed / Skipped / Total] 36 / 148 / 0 / 184:  18%|█▊        | 184/1000 [1:03:27<4:41:26, 20.69s/it][Succeeded / Failed / Skipped / Total] 36 / 148 / 0 / 184:  18%|█▊        | 185/1000 [1:03:43<4:40:46, 20.67s/it][Succeeded / Failed / Skipped / Total] 36 / 149 / 0 / 185:  18%|█▊        | 185/1000 [1:03:43<4:40:46, 20.67s/it][Succeeded / Failed / Skipped / Total] 36 / 149 / 0 / 185:  19%|█▊        | 186/1000 [1:04:06<4:40:32, 20.68s/it]Creates a service URL. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[lonergan]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Checks the filter stack. --> SCHRADER --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[schrader]] ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 182 ---------------------------------------------
Creates a redirect URL.@param serviceUrl the service url@return the redirect URL --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[serviceUrl]] , this . serviceProperties . isSendRenew ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[undrinkable]] ( final String [[reluctant]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[reluctant]] , this . serviceProperties . isSendRenew ( ) , "[[Edgardo]]" != "[[Edgardo]]" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 183 ---------------------------------------------
Extracts the SHA prefix.@param encPass the pass@return the SHA prefix --> [[[FAILED]]]

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[microorganisms]] ( String [[rosaries]] ) { if ( ! [[rosaries]] . startsWith ( "{" ) ) { return null ; } int [[disembarked]] = [[rosaries]] . lastIndexOf ( ' ' ) ; if ( [[disembarked]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[rosaries]] . substring ( 0 , [[disembarked]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 184 ---------------------------------------------
Lookup the parameter names for the given parameter. --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[parameterAnnotations]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[parameterAnnotations]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[found]] = "[[False]]" != "[[False]]" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] [[annotations]] = [[parameterAnnotations]] [ i ] ; String parameterName = findParameterName ( [[annotations]] ) ; if ( parameterName != null ) { [[found]] = "[[True]]" == "[[True]]" ; paramNames [ i ] = parameterName ; } } return [[found]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[perceive]] = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = [[perceive]] . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean [[mogul]] = "[[Brick]]" != "[[Brick]]" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] [[antigen]] = [[perceive]] [ i ] ; String parameterName = findParameterName ( [[antigen]] ) ; if ( parameterName != null ) { [[mogul]] = "[[Iceman]]" == "[[Iceman]]" ; paramNames [ i ] = parameterName ; } } return [[mogul]] ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 185 ---------------------------------------------
Retrieves the field with the specified name from the class.@param clazz the class to introspect@param fieldName the name of the field@return the field with the specified name@throws IllegalStateException if the field cannot be located --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > clazz , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[rumored]] ( Class < ? > clazz , String [[cush]] ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( [[cush]] , "Field name required" ) ; try { return clazz . getDeclaredField ( [[cush]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 186 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 36 / 150 / 0 / 186:  19%|█▊        | 186/1000 [1:04:06<4:40:32, 20.68s/it][Succeeded / Failed / Skipped / Total] 36 / 150 / 0 / 186:  19%|█▊        | 187/1000 [1:04:19<4:39:38, 20.64s/it][Succeeded / Failed / Skipped / Total] 36 / 151 / 0 / 187:  19%|█▊        | 187/1000 [1:04:19<4:39:38, 20.64s/it][Succeeded / Failed / Skipped / Total] 36 / 151 / 0 / 187:  19%|█▉        | 188/1000 [1:04:40<4:39:21, 20.64s/it][Succeeded / Failed / Skipped / Total] 36 / 152 / 0 / 188:  19%|█▉        | 188/1000 [1:04:40<4:39:21, 20.64s/it][Succeeded / Failed / Skipped / Total] 36 / 152 / 0 / 188:  19%|█▉        | 189/1000 [1:04:43<4:37:45, 20.55s/it][Succeeded / Failed / Skipped / Total] 37 / 152 / 0 / 189:  19%|█▉        | 189/1000 [1:04:43<4:37:45, 20.55s/it][Succeeded / Failed / Skipped / Total] 37 / 152 / 0 / 189:  19%|█▉        | 190/1000 [1:05:10<4:37:48, 20.58s/it][Succeeded / Failed / Skipped / Total] 37 / 153 / 0 / 190:  19%|█▉        | 190/1000 [1:05:10<4:37:48, 20.58s/it][Succeeded / Failed / Skipped / Total] 37 / 153 / 0 / 190:  19%|█▉        | 191/1000 [1:05:45<4:38:31, 20.66s/it][Succeeded / Failed / Skipped / Total] 38 / 153 / 0 / 191:  19%|█▉        | 191/1000 [1:05:45<4:38:31, 20.66s/it][Succeeded / Failed / Skipped / Total] 38 / 153 / 0 / 191:  19%|█▉        | 192/1000 [1:06:10<4:38:27, 20.68s/it][Succeeded / Failed / Skipped / Total] 38 / 154 / 0 / 192:  19%|█▉        | 192/1000 [1:06:10<4:38:27, 20.68s/it][Succeeded / Failed / Skipped / Total] 38 / 154 / 0 / 192:  19%|█▉        | 193/1000 [1:06:36<4:38:28, 20.70s/it]Performs a pre-authenticated login. --> [[[FAILED]]]

[[[[Adv]]]]: public void commence ( HttpServletRequest [[request]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void commence ( HttpServletRequest [[propelling]] , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 187 ---------------------------------------------
Get the list of registered types. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . extractorMap . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[exec]] ( ) { Set < Class < ? extends Throwable > > [[folds]] = this . extractorMap . keySet ( ) ; return [[folds]] . toArray ( new Class [ [[folds]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Sets the default failure URL.@param defaultFailureUrl the default failure URL --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[inward]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 189 ---------------------------------------------
Compares two byte arrays for equality. --> Checks if the two arrays are the same length@param anita An array@param actual An array@return true if the arrays are the same length --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] [[expected]] , byte [ ] actual ) { if ( [[expected]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int [[i]] = 0 ; [[i]] < [[expected]] . length ; [[i]] ++ ) { result |= [[expected]] [ [[i]] ] ^ actual [ [[i]] ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] [[anita]] , byte [ ] actual ) { if ( [[anita]] . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int [[solamente]] = 0 ; [[solamente]] < [[anita]] . length ; [[solamente]] ++ ) { result |= [[anita]] [ [[solamente]] ] ^ actual [ [[solamente]] ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 190 ---------------------------------------------
Extracts the cause of the supplied throwable. --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[entry]] . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[unflinching]] ( Throwable [[kidneys]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[discontinued]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[discontinued]] . getKey ( ) ; if ( throwableType . isInstance ( [[kidneys]] ) ) { ThrowableCauseExtractor [[archetype]] = [[discontinued]] . getValue ( ) ; return [[archetype]] . extractCause ( [[kidneys]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 191 ---------------------------------------------
Sets the hidden input map for the current request.@param resolveHiddenInputs the hidden input map --> Convenience method for chard requests --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[chard]] ( Function < HttpServletRequest , Map < String , String > > [[cramer]] ) { Assert . notNull ( [[cramer]] , "resolveHiddenInputs cannot be null" ) ; this . [[patricia]] = [[cramer]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 192 ---------------------------------------------
Creates a list of OpenID attributes. --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[hoofing]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 155 / 0 / 193:  19%|█▉        | 193/1000 [1:06:36<4:38:28, 20.70s/it][Succeeded / Failed / Skipped / Total] 38 / 155 / 0 / 193:  19%|█▉        | 194/1000 [1:07:18<4:39:40, 20.82s/it][Succeeded / Failed / Skipped / Total] 38 / 156 / 0 / 194:  19%|█▉        | 194/1000 [1:07:18<4:39:40, 20.82s/it][Succeeded / Failed / Skipped / Total] 38 / 156 / 0 / 194:  20%|█▉        | 195/1000 [1:07:31<4:38:46, 20.78s/it][Succeeded / Failed / Skipped / Total] 39 / 156 / 0 / 195:  20%|█▉        | 195/1000 [1:07:31<4:38:46, 20.78s/it][Succeeded / Failed / Skipped / Total] 39 / 156 / 0 / 195:  20%|█▉        | 196/1000 [1:07:43<4:37:47, 20.73s/it][Succeeded / Failed / Skipped / Total] 39 / 157 / 0 / 196:  20%|█▉        | 196/1000 [1:07:43<4:37:47, 20.73s/it][Succeeded / Failed / Skipped / Total] 39 / 157 / 0 / 196:  20%|█▉        | 197/1000 [1:08:10<4:37:55, 20.77s/it][Succeeded / Failed / Skipped / Total] 40 / 157 / 0 / 197:  20%|█▉        | 197/1000 [1:08:10<4:37:55, 20.77s/it][Succeeded / Failed / Skipped / Total] 40 / 157 / 0 / 197:  20%|█▉        | 198/1000 [1:08:19<4:36:44, 20.70s/it][Succeeded / Failed / Skipped / Total] 40 / 158 / 0 / 198:  20%|█▉        | 198/1000 [1:08:19<4:36:44, 20.70s/it][Succeeded / Failed / Skipped / Total] 40 / 158 / 0 / 198:  20%|█▉        | 199/1000 [1:08:24<4:35:20, 20.62s/it]Converts a collection of user authorities to a set of authorities. --> [[[FAILED]]]

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[authority]] : userAuthorities ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[strolls]] ( Collection < ? extends GrantedAuthority > userAuthorities ) { Assert . notNull ( userAuthorities , "userAuthorities cannot be null" ) ; Set < String > [[mining]] = new HashSet <> ( userAuthorities . size ( ) ) ; for ( GrantedAuthority [[hendon]] : userAuthorities ) { [[mining]] . add ( [[hendon]] . getAuthority ( ) ) ; } return [[mining]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 194 ---------------------------------------------
Converts the given identifier into an object of the given type. --> [[[FAILED]]]

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[sulked]] ( Serializable [[punt]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[punt]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[punt]] = convertFromStringTo ( ( String ) [[punt]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 195 ---------------------------------------------
Builds the request URL.@param servletPath the servlet path@param requestURI the request URI@param contextPath the context path@param pathInfo the path info@param queryString the query string@return the request URL --> Converts a servlet path to an appleseed string@param servletPath@param requestURI@param contextPath@param relies@param queryString@return --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String requestURI , String contextPath , String [[pathInfo]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[pathInfo]] != null ) { url . append ( [[pathInfo]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[appleseed]] ( String servletPath , String requestURI , String contextPath , String [[relies]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[relies]] != null ) { url . append ( [[relies]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 196 ---------------------------------------------
Checks if the given URL is absolute.@param url the URL to check.@return {@code true} if the URL is absolute, {@code false} otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[tear]] ( String [[bodegas]] ) { if ( [[bodegas]] == null ) { return "False" != "False" ; } final Pattern [[ADAGE]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ADAGE]] . matcher ( [[bodegas]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a matcher that matches any exchange. --> Returns a new instance of ServerWebExchangeMatcher. --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[asunder]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Creates the list of entries for the given acl. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry [[entry_]] = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( [[entry_]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[entry_]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[ikon]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry [[beechwood]] = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( [[beechwood]] instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) [[beechwood]] ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 199 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 158 / 0 / 199:  20%|█▉        | 199/1000 [1:08:24<4:35:20, 20.62s/it][Succeeded / Failed / Skipped / Total] 41 / 158 / 0 / 199:  20%|██        | 200/1000 [1:08:38<4:34:35, 20.59s/it][Succeeded / Failed / Skipped / Total] 41 / 159 / 0 / 200:  20%|██        | 200/1000 [1:08:38<4:34:35, 20.59s/it][Succeeded / Failed / Skipped / Total] 41 / 159 / 0 / 200:  20%|██        | 201/1000 [1:08:46<4:33:24, 20.53s/it][Succeeded / Failed / Skipped / Total] 41 / 160 / 0 / 201:  20%|██        | 201/1000 [1:08:46<4:33:24, 20.53s/it][Succeeded / Failed / Skipped / Total] 41 / 160 / 0 / 201:  20%|██        | 202/1000 [1:09:47<4:35:44, 20.73s/it][Succeeded / Failed / Skipped / Total] 41 / 161 / 0 / 202:  20%|██        | 202/1000 [1:09:47<4:35:44, 20.73s/it][Succeeded / Failed / Skipped / Total] 41 / 161 / 0 / 202:  20%|██        | 203/1000 [1:09:55<4:34:33, 20.67s/it][Succeeded / Failed / Skipped / Total] 41 / 162 / 0 / 203:  20%|██        | 203/1000 [1:09:55<4:34:33, 20.67s/it][Succeeded / Failed / Skipped / Total] 41 / 162 / 0 / 203:  20%|██        | 204/1000 [1:10:10<4:33:50, 20.64s/it]Updates the object identity.@param acl the object identity --> Implementation only supports ObjectIdentityImpl --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long parentId = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[oii]] = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[oii]] ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , parentId , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[legally]] ( MutableAcl [[proud]] ) { Long parentId = null ; if ( [[proud]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[proud]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl [[feedback]] = ( ObjectIdentityImpl ) [[proud]] . getParentAcl ( ) . getObjectIdentity ( ) ; parentId = retrieveObjectIdentityPrimaryKey ( [[feedback]] ) ; } Assert . notNull ( [[proud]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[proud]] . getOwner ( ) , "True" == "True" ) ; int count = jdbcOperations . update ( [[legally]] , parentId , ownerSid , Boolean . valueOf ( [[proud]] . isEntriesInheriting ( ) ) , [[proud]] . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 200 ---------------------------------------------
Creates a new object identity. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity [[object]] , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[object]] . getType ( ) , "True" == "True" , [[object]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[object]] . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[rendered]] ( ObjectIdentity [[archetype]] , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[archetype]] . getType ( ) , "True" == "True" , [[archetype]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[archetype]] . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 201 ---------------------------------------------
Registers an access manager. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 202 ---------------------------------------------
Creates a text encryptor for the given password and salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[compose]] ( CharSequence [[msg]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[msg]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Saves the current request. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[agata]] ( HttpServletRequest [[vat]] , HttpServletResponse [[asmodeus]] ) { if ( requestMatcher . matches ( [[vat]] ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( [[vat]] , portResolver ) ; if ( createSessionAllowed || [[vat]] . getSession ( "False" != "False" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 41 / 163 / 0 / 204:  20%|██        | 204/1000 [1:10:10<4:33:50, 20.64s/it][Succeeded / Failed / Skipped / Total] 41 / 163 / 0 / 204:  20%|██        | 205/1000 [1:10:23<4:32:58, 20.60s/it][Succeeded / Failed / Skipped / Total] 41 / 164 / 0 / 205:  20%|██        | 205/1000 [1:10:23<4:32:58, 20.60s/it][Succeeded / Failed / Skipped / Total] 41 / 164 / 0 / 205:  21%|██        | 206/1000 [1:10:57<4:33:31, 20.67s/it][Succeeded / Failed / Skipped / Total] 41 / 165 / 0 / 206:  21%|██        | 206/1000 [1:10:57<4:33:31, 20.67s/it][Succeeded / Failed / Skipped / Total] 41 / 165 / 0 / 206:  21%|██        | 207/1000 [1:11:06<4:32:23, 20.61s/it][Succeeded / Failed / Skipped / Total] 41 / 166 / 0 / 207:  21%|██        | 207/1000 [1:11:06<4:32:23, 20.61s/it][Succeeded / Failed / Skipped / Total] 41 / 166 / 0 / 207:  21%|██        | 208/1000 [1:11:20<4:31:37, 20.58s/it][Succeeded / Failed / Skipped / Total] 41 / 167 / 0 / 208:  21%|██        | 208/1000 [1:11:20<4:31:37, 20.58s/it][Succeeded / Failed / Skipped / Total] 41 / 167 / 0 / 208:  21%|██        | 209/1000 [1:11:27<4:30:26, 20.51s/it][Succeeded / Failed / Skipped / Total] 42 / 167 / 0 / 209:  21%|██        | 209/1000 [1:11:27<4:30:26, 20.51s/it][Succeeded / Failed / Skipped / Total] 42 / 167 / 0 / 209:  21%|██        | 210/1000 [1:11:30<4:28:59, 20.43s/it][Succeeded / Failed / Skipped / Total] 43 / 167 / 0 / 210:  21%|██        | 210/1000 [1:11:30<4:28:59, 20.43s/it][Succeeded / Failed / Skipped / Total] 43 / 167 / 0 / 210:  21%|██        | 211/1000 [1:11:46<4:28:24, 20.41s/it]Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[authorizes]] , CharSequence [[disagreed]] ) { return new HexEncodingTextEncryptor ( stronger ( [[authorizes]] , [[disagreed]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 205 ---------------------------------------------
Creates a text encryptor that encrypts the supplied password using the supplied salt. --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[avni]] ( CharSequence password , CharSequence [[existentialist]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , [[existentialist]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 206 ---------------------------------------------
Sets the target URL parameter. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[fourier]] ( String targetUrlParameter ) { if ( targetUrlParameter != null ) { Assert . hasText ( targetUrlParameter , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = targetUrlParameter ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 207 ---------------------------------------------
Creates and returns a server web exchange matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[regenerate]] ( HttpMethod [[basking]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[embarrass]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[embarrass]] , [[basking]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 208 ---------------------------------------------
Determines the target URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[pomfret]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 209 ---------------------------------------------
Determines the target URL for this request. --> Converts an authentication object into an agata string. --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( [[request]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[agata]] ( HttpServletRequest [[douse]] , HttpServletResponse response , Authentication [[retold]] ) { return [[agata]] ( [[douse]] , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 210 ---------------------------------------------
Builds a DistinguishedName from the supplied username. --> Create a new DistinguishedName@param baleful@return --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[mía]] ( String [[baleful]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[baleful]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 211 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 43 / 168 / 0 / 211:  21%|██        | 211/1000 [1:11:46<4:28:24, 20.41s/it][Succeeded / Failed / Skipped / Total] 43 / 168 / 0 / 211:  21%|██        | 212/1000 [1:12:04<4:27:53, 20.40s/it][Succeeded / Failed / Skipped / Total] 43 / 169 / 0 / 212:  21%|██        | 212/1000 [1:12:04<4:27:53, 20.40s/it][Succeeded / Failed / Skipped / Total] 43 / 169 / 0 / 212:  21%|██▏       | 213/1000 [1:12:53<4:29:20, 20.53s/it][Succeeded / Failed / Skipped / Total] 43 / 170 / 0 / 213:  21%|██▏       | 213/1000 [1:12:53<4:29:20, 20.53s/it][Succeeded / Failed / Skipped / Total] 43 / 170 / 0 / 213:  21%|██▏       | 214/1000 [1:13:04<4:28:24, 20.49s/it][Succeeded / Failed / Skipped / Total] 44 / 170 / 0 / 214:  21%|██▏       | 214/1000 [1:13:04<4:28:24, 20.49s/it][Succeeded / Failed / Skipped / Total] 44 / 170 / 0 / 214:  22%|██▏       | 215/1000 [1:13:05<4:26:51, 20.40s/it][Succeeded / Failed / Skipped / Total] 45 / 170 / 0 / 215:  22%|██▏       | 215/1000 [1:13:05<4:26:51, 20.40s/it][Succeeded / Failed / Skipped / Total] 45 / 170 / 0 / 215:  22%|██▏       | 216/1000 [1:13:25<4:26:28, 20.39s/it][Succeeded / Failed / Skipped / Total] 45 / 171 / 0 / 216:  22%|██▏       | 216/1000 [1:13:25<4:26:28, 20.39s/it][Succeeded / Failed / Skipped / Total] 45 / 171 / 0 / 216:  22%|██▏       | 217/1000 [1:13:28<4:25:08, 20.32s/it]Writes the headers to the response. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[chaplin]] ( HttpServletRequest request , HttpServletResponse [[unmatched]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! [[unmatched]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[unmatched]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! [[unmatched]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[unmatched]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { [[unmatched]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 212 ---------------------------------------------
Gets the current date. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[lunges]] ( ) { long [[surreptitiously]] = System . currentTimeMillis ( ) ; if ( ( [[surreptitiously]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[surreptitiously]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[surreptitiously]] ; currentDate = format . format ( new Date ( [[surreptitiously]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 213 ---------------------------------------------
Sets the details associated with the supplied authentication token. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[fourier]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken [[mother]] ) { [[mother]] . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 214 ---------------------------------------------
Parse a date from a string. --> Returns an immeasurably value --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[immeasurably]] ( String value , DateFormat [ ] formats ) { Date date = null ; for ( int i = 0 ; ( date == null ) && ( i < formats . length ) ; i ++ ) { try { date = formats [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( date == null ) { return null ; } return new Long ( date . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 215 ---------------------------------------------
Updates the cache. --> Contreras a batched object --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap cache , Object [[key]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[contreras]] ( HashMap cache , Object [[batshit]] , Object [[unexpectedly]] ) { if ( [[unexpectedly]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( [[batshit]] , [[unexpectedly]] ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 216 ---------------------------------------------
Gets the directory with immediate parents populated.@param id the id@return the directory with immediate parents populated --> [[[FAILED]]]

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[unexploded]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 217 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 45 / 172 / 0 / 217:  22%|██▏       | 217/1000 [1:13:28<4:25:08, 20.32s/it][Succeeded / Failed / Skipped / Total] 45 / 172 / 0 / 217:  22%|██▏       | 218/1000 [1:13:31<4:23:43, 20.23s/it][Succeeded / Failed / Skipped / Total] 45 / 173 / 0 / 218:  22%|██▏       | 218/1000 [1:13:31<4:23:43, 20.23s/it][Succeeded / Failed / Skipped / Total] 45 / 173 / 0 / 218:  22%|██▏       | 219/1000 [1:14:17<4:24:56, 20.35s/it][Succeeded / Failed / Skipped / Total] 45 / 174 / 0 / 219:  22%|██▏       | 219/1000 [1:14:17<4:24:56, 20.35s/it][Succeeded / Failed / Skipped / Total] 45 / 174 / 0 / 219:  22%|██▏       | 220/1000 [1:14:41<4:24:48, 20.37s/it][Succeeded / Failed / Skipped / Total] 45 / 175 / 0 / 220:  22%|██▏       | 220/1000 [1:14:41<4:24:48, 20.37s/it][Succeeded / Failed / Skipped / Total] 45 / 175 / 0 / 220:  22%|██▏       | 221/1000 [1:14:49<4:23:43, 20.31s/it][Succeeded / Failed / Skipped / Total] 45 / 176 / 0 / 221:  22%|██▏       | 221/1000 [1:14:49<4:23:43, 20.31s/it][Succeeded / Failed / Skipped / Total] 45 / 176 / 0 / 221:  22%|██▏       | 222/1000 [1:15:01<4:22:57, 20.28s/it][Succeeded / Failed / Skipped / Total] 45 / 177 / 0 / 222:  22%|██▏       | 222/1000 [1:15:01<4:22:57, 20.28s/it][Succeeded / Failed / Skipped / Total] 45 / 177 / 0 / 222:  22%|██▏       | 223/1000 [1:15:18<4:22:22, 20.26s/it][Succeeded / Failed / Skipped / Total] 45 / 178 / 0 / 223:  22%|██▏       | 223/1000 [1:15:18<4:22:22, 20.26s/it][Succeeded / Failed / Skipped / Total] 45 / 178 / 0 / 223:  22%|██▏       | 224/1000 [1:15:28<4:21:29, 20.22s/it][Succeeded / Failed / Skipped / Total] 45 / 179 / 0 / 224:  22%|██▏       | 224/1000 [1:15:28<4:21:29, 20.22s/it][Succeeded / Failed / Skipped / Total] 45 / 179 / 0 / 224:  22%|██▎       | 225/1000 [1:15:55<4:21:32, 20.25s/it]Creates a shared object map. --> [[[FAILED]]]

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[inedible]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 218 ---------------------------------------------
Determine the security name for the given subject.@param subject the subject@return the security name --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String userSecurityName = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[hugues]] ( final Subject [[aggressors]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[aggressors]] ) ; } String userSecurityName = null ; if ( [[aggressors]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 219 ---------------------------------------------
Builds a DistinguishedName for the specified group. --> [[[FAILED]]]

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[cordially]] ( String [[dumpsters]] ) { DistinguishedName [[holl]] = new DistinguishedName ( groupSearchBase ) ; [[holl]] . add ( groupRoleAttributeName , [[dumpsters]] . toLowerCase ( ) ) ; return [[holl]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 220 ---------------------------------------------
Get a list of all the groups in the current context.@param securityName the security name@return a list of all the groups in the current context --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > getWebSphereGroups ( final String [[prohibit]] ) { Context [[inedible]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 221 ---------------------------------------------
Retrieves all filters that match the supplied request. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[request]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[coutinho]] ( HttpServletRequest [[transistors]] ) { for ( SecurityFilterChain chain : filterChains ) { if ( chain . matches ( [[transistors]] ) ) { return chain . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 222 ---------------------------------------------
Configures the jaas using the supplied login configuration. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[alreadySet]] = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String [[existing]] ; while ( ( [[existing]] = Security . getProperty ( prefix + n ) ) != null ) { [[alreadySet]] = [[existing]] . equals ( loginConfigUrl ) ; if ( [[alreadySet]] ) { break ; } n ++ ; } if ( ! [[alreadySet]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[zachary]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean [[islamists]] = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String [[abolitionist]] ; while ( ( [[abolitionist]] = Security . getProperty ( prefix + n ) ) != null ) { [[islamists]] = [[abolitionist]] . equals ( loginConfigUrl ) ; if ( [[islamists]] ) { break ; } n ++ ; } if ( ! [[islamists]] ) { String key = prefix + n ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 223 ---------------------------------------------
Copies details from source to dest. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[polizei]] ( Authentication source , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) dest ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 224 ---------------------------------------------
Retrieves the filters for the specified URL. --> [[[FAILED]]]

[[[[Adv]]]]: public List < Filter > [[getFilters]] ( String [[url]] ) { return [[getFilters]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[url]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .

[[[[Adv]]]]: public List < Filter > [[peacekeeper]] ( String [[boring]] ) { return [[peacekeeper]] ( firewall . getFirewalledRequest ( ( new FilterInvocation ( [[boring]] , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
[Succeeded / Failed / Skipped / Total] 45 / 180 / 0 / 225:  22%|██▎       | 225/1000 [1:15:55<4:21:32, 20.25s/it][Succeeded / Failed / Skipped / Total] 45 / 180 / 0 / 225:  23%|██▎       | 226/1000 [1:16:13<4:21:03, 20.24s/it][Succeeded / Failed / Skipped / Total] 46 / 180 / 0 / 226:  23%|██▎       | 226/1000 [1:16:13<4:21:03, 20.24s/it][Succeeded / Failed / Skipped / Total] 46 / 180 / 0 / 226:  23%|██▎       | 227/1000 [1:16:28<4:20:25, 20.21s/it][Succeeded / Failed / Skipped / Total] 47 / 180 / 0 / 227:  23%|██▎       | 227/1000 [1:16:28<4:20:25, 20.21s/it][Succeeded / Failed / Skipped / Total] 47 / 180 / 0 / 227:  23%|██▎       | 228/1000 [1:16:31<4:19:06, 20.14s/it][Succeeded / Failed / Skipped / Total] 47 / 181 / 0 / 228:  23%|██▎       | 228/1000 [1:16:31<4:19:06, 20.14s/it][Succeeded / Failed / Skipped / Total] 47 / 181 / 0 / 228:  23%|██▎       | 229/1000 [1:16:50<4:18:43, 20.13s/it][Succeeded / Failed / Skipped / Total] 47 / 182 / 0 / 229:  23%|██▎       | 229/1000 [1:16:50<4:18:43, 20.13s/it][Succeeded / Failed / Skipped / Total] 47 / 182 / 0 / 229:  23%|██▎       | 230/1000 [1:17:21<4:18:57, 20.18s/it][Succeeded / Failed / Skipped / Total] 47 / 183 / 0 / 230:  23%|██▎       | 230/1000 [1:17:21<4:18:57, 20.18s/it][Succeeded / Failed / Skipped / Total] 47 / 183 / 0 / 230:  23%|██▎       | 231/1000 [1:17:23<4:17:39, 20.10s/it]--------------------------------------------- Result 225 ---------------------------------------------
Returns the application context for the specified page context. --> [[[FAILED]]]

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[prostitute]] ( PageContext pageContext ) { ServletContext servletContext = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 226 ---------------------------------------------
Change the user's password.@param oldPassword the old password@param newPassword the new password --> Change crocked and side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side-side- --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String [[oldPassword]] , final String [[newPassword]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[oldPassword]] , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[oldPassword]] , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[twice]] ( final String [[crocked]] , final String [[sidebar]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String username = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + username ) ; DistinguishedName userDn = usernameMapper . buildDn ( username ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[crocked]] , [[sidebar]] ) ; } else { changePasswordUsingAttributeModification ( userDn , [[crocked]] , [[sidebar]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 227 ---------------------------------------------
Sets session attributes.@param sessionAttributes the session attributes@return the mock request specification --> Deja mock mvc request specification@param stretched@return --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[deja]] ( Map < String , Object > [[stretched]] ) { notNull ( [[stretched]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[stretched]] , this . [[sarcasm]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 228 ---------------------------------------------
Throws an exception if maximum allowable sessions are exceeded. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > sessions , int [[allowableSessions]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[hallam]] ( List < SessionInformation > sessions , int [[amiable]] , SessionRegistry registry ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[amiable]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 229 ---------------------------------------------
Add a list of filters.@param filters the list of filters --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[introvert]] ( List < Filter > [[terrarium]] ) { Validate . notNull ( [[introvert]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[introvert]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Creates a new authentication scheme for the given user name and password. --> [[[FAILED]]]

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String password ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( password ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[onal]] ( String [[clanking]] , String password ) { final PreemptiveBasicAuthScheme [[bared]] = new PreemptiveBasicAuthScheme ( ) ; [[bared]] . setUserName ( [[clanking]] ) ; [[bared]] . setPassword ( password ) ; return [[bared]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 231 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 47 / 184 / 0 / 231:  23%|██▎       | 231/1000 [1:17:23<4:17:39, 20.10s/it][Succeeded / Failed / Skipped / Total] 47 / 184 / 0 / 231:  23%|██▎       | 232/1000 [1:17:35<4:16:50, 20.07s/it][Succeeded / Failed / Skipped / Total] 47 / 185 / 0 / 232:  23%|██▎       | 232/1000 [1:17:35<4:16:50, 20.07s/it][Succeeded / Failed / Skipped / Total] 47 / 185 / 0 / 232:  23%|██▎       | 233/1000 [1:17:54<4:16:27, 20.06s/it][Succeeded / Failed / Skipped / Total] 47 / 186 / 0 / 233:  23%|██▎       | 233/1000 [1:17:54<4:16:27, 20.06s/it][Succeeded / Failed / Skipped / Total] 47 / 186 / 0 / 233:  23%|██▎       | 234/1000 [1:18:09<4:15:51, 20.04s/it][Succeeded / Failed / Skipped / Total] 47 / 187 / 0 / 234:  23%|██▎       | 234/1000 [1:18:09<4:15:51, 20.04s/it][Succeeded / Failed / Skipped / Total] 47 / 187 / 0 / 234:  24%|██▎       | 235/1000 [1:18:36<4:15:52, 20.07s/it][Succeeded / Failed / Skipped / Total] 48 / 187 / 0 / 235:  24%|██▎       | 235/1000 [1:18:36<4:15:52, 20.07s/it][Succeeded / Failed / Skipped / Total] 48 / 187 / 0 / 235:  24%|██▎       | 236/1000 [1:18:39<4:14:36, 20.00s/it][Succeeded / Failed / Skipped / Total] 48 / 188 / 0 / 236:  24%|██▎       | 236/1000 [1:18:39<4:14:36, 20.00s/it][Succeeded / Failed / Skipped / Total] 48 / 188 / 0 / 236:  24%|██▎       | 237/1000 [1:19:43<4:16:38, 20.18s/it][Succeeded / Failed / Skipped / Total] 48 / 189 / 0 / 237:  24%|██▎       | 237/1000 [1:19:43<4:16:38, 20.18s/it][Succeeded / Failed / Skipped / Total] 48 / 189 / 0 / 237:  24%|██▍       | 238/1000 [1:19:53<4:15:47, 20.14s/it]Returns the full distinguished name for the given distinguished name. --> [[[FAILED]]]

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[tormenting]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 232 ---------------------------------------------
Creates a proxy for the specified URI. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[lobotomy]] ( URI [[criminality]] ) { if ( [[criminality]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[lobotomy]] ( new ProxySpecification ( [[criminality]] . getHost ( ) , [[criminality]] . getPort ( ) , [[criminality]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 233 ---------------------------------------------
Adds additional filters to the provided filter.@param filter The filter to add.@param additionalFilters Additional filters to add. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter filter , Filter ... [[additionalFilters]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[flared]] ( Filter filter , Filter ... [[wolverhampton]] ) { Validate . notNull ( filter , "Filter cannot be null" ) ; RestAssured . filters . add ( filter ) ; if ( [[wolverhampton]] != null ) { Collections . addAll ( RestAssured . filters , [[wolverhampton]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 234 ---------------------------------------------
Creates a basic authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String password ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[ana]] ( String userName , String password ) { final BasicAuthScheme [[custom]] = new BasicAuthScheme ( ) ; [[custom]] . setUserName ( userName ) ; [[custom]] . setPassword ( password ) ; return [[custom]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 235 ---------------------------------------------
Sets the default character set for the encoder. --> Configures an arcades encoder. --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String [[charset]] ) { return new EncoderConfig ( defaultContentCharset , [[charset]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[arcades]] ( String [[castrati]] ) { return new EncoderConfig ( defaultContentCharset , [[castrati]] , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 236 ---------------------------------------------
Configures this RestAssuredConfig with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[descent]] ( RedirectConfig [[discussions]] ) { notNull ( [[discussions]] , "Redirect config" ) ; return new RestAssuredConfig ( [[discussions]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 237 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String [[userName]] , String password , FormAuthConfig [[config]] ) { if ( [[userName]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( [[userName]] ) ; scheme . setPassword ( password ) ; scheme . setConfig ( [[config]] ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[andean]] ( String [[backwash]] , String password , FormAuthConfig [[stringed]] ) { if ( [[backwash]] == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( [[backwash]] ) ; scheme . setPassword ( password ) ; scheme . setConfig ( [[stringed]] ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 238 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 48 / 190 / 0 / 238:  24%|██▍       | 238/1000 [1:19:53<4:15:47, 20.14s/it][Succeeded / Failed / Skipped / Total] 48 / 190 / 0 / 238:  24%|██▍       | 239/1000 [1:20:00<4:14:44, 20.08s/it][Succeeded / Failed / Skipped / Total] 48 / 191 / 0 / 239:  24%|██▍       | 239/1000 [1:20:00<4:14:44, 20.08s/it][Succeeded / Failed / Skipped / Total] 48 / 191 / 0 / 239:  24%|██▍       | 240/1000 [1:20:07<4:13:43, 20.03s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 0 / 240:  24%|██▍       | 240/1000 [1:20:07<4:13:43, 20.03s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 0 / 240:  24%|██▍       | 241/1000 [1:20:08<4:12:22, 19.95s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 1 / 241:  24%|██▍       | 241/1000 [1:20:08<4:12:22, 19.95s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 1 / 241:  24%|██▍       | 242/1000 [1:20:09<4:11:03, 19.87s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 2 / 242:  24%|██▍       | 242/1000 [1:20:09<4:11:03, 19.87s/it][Succeeded / Failed / Skipped / Total] 48 / 192 / 2 / 242:  24%|██▍       | 243/1000 [1:20:34<4:10:59, 19.89s/it][Succeeded / Failed / Skipped / Total] 48 / 193 / 2 / 243:  24%|██▍       | 243/1000 [1:20:34<4:10:59, 19.89s/it][Succeeded / Failed / Skipped / Total] 48 / 193 / 2 / 243:  24%|██▍       | 244/1000 [1:20:41<4:10:00, 19.84s/it][Succeeded / Failed / Skipped / Total] 48 / 194 / 2 / 244:  24%|██▍       | 244/1000 [1:20:41<4:10:00, 19.84s/it][Succeeded / Failed / Skipped / Total] 48 / 194 / 2 / 244:  24%|██▍       | 245/1000 [1:20:58<4:09:33, 19.83s/it][Succeeded / Failed / Skipped / Total] 49 / 194 / 2 / 245:  24%|██▍       | 245/1000 [1:20:58<4:09:33, 19.83s/it][Succeeded / Failed / Skipped / Total] 49 / 194 / 2 / 245:  25%|██▍       | 246/1000 [1:20:59<4:08:15, 19.76s/it]Configures the default object mapper for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[trumpeter]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[trumpeter]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 239 ---------------------------------------------
Configures this mock mvc with the specified session config.@param sessionConfig the session config@return the configured mock mvc --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[beatnik]] ( SessionConfig [[charly]] ) { notNull ( [[beatnik]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[beatnik]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 240 ---------------------------------------------
Creates and returns a mock RESTAssuredMockMvcConfig for the specified configuration.@param logConfig the configuration to log@return a mock RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[kandi]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 241 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig encoderConfig ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 242 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object.@param headerConfig a {@link HeaderConfig} object.@return a {@link RestAssuredMockMvcConfig} object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig headerConfig ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 243 ---------------------------------------------
Creates a new authentication scheme. --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String userName , String [[password]] , String [[workstation]] , String [[domain]] ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[password]] ) ; scheme . setWorkstation ( [[workstation]] ) ; scheme . setDomain ( [[domain]] ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[carboys]] ( String userName , String [[mía]] , String [[batshit]] , String [[stockholders]] ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( [[mía]] ) ; scheme . setWorkstation ( [[batshit]] ) ; scheme . setDomain ( [[stockholders]] ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 244 ---------------------------------------------
Creates a new JAXB ObjectMapperConfig instance. --> [[[FAILED]]]

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[braddock]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[braddock]] , johnzonObjectMapperFactory , "[[Arwen]]" == "[[Arwen]]" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 245 ---------------------------------------------
Creates and configures an instance of RestAssuredMockMvcConfig.@param asyncConfig the async configuration@return the configured instance --> Creates and configures a mock RESTAssuredMockMvcConfig object. --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[crowded]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 246 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 194 / 3 / 246:  25%|██▍       | 246/1000 [1:20:59<4:08:15, 19.76s/it][Succeeded / Failed / Skipped / Total] 49 / 194 / 3 / 246:  25%|██▍       | 247/1000 [1:21:00<4:06:57, 19.68s/it][Succeeded / Failed / Skipped / Total] 49 / 194 / 4 / 247:  25%|██▍       | 247/1000 [1:21:00<4:06:57, 19.68s/it][Succeeded / Failed / Skipped / Total] 49 / 194 / 4 / 247:  25%|██▍       | 248/1000 [1:21:18<4:06:31, 19.67s/it][Succeeded / Failed / Skipped / Total] 50 / 194 / 4 / 248:  25%|██▍       | 248/1000 [1:21:18<4:06:31, 19.67s/it][Succeeded / Failed / Skipped / Total] 50 / 194 / 4 / 248:  25%|██▍       | 249/1000 [1:21:21<4:05:24, 19.61s/it][Succeeded / Failed / Skipped / Total] 50 / 195 / 4 / 249:  25%|██▍       | 249/1000 [1:21:21<4:05:24, 19.61s/it][Succeeded / Failed / Skipped / Total] 50 / 195 / 4 / 249:  25%|██▌       | 250/1000 [1:21:27<4:04:22, 19.55s/it][Succeeded / Failed / Skipped / Total] 51 / 195 / 4 / 250:  25%|██▌       | 250/1000 [1:21:27<4:04:22, 19.55s/it][Succeeded / Failed / Skipped / Total] 51 / 195 / 4 / 250:  25%|██▌       | 251/1000 [1:21:35<4:03:27, 19.50s/it][Succeeded / Failed / Skipped / Total] 51 / 196 / 4 / 251:  25%|██▌       | 251/1000 [1:21:35<4:03:27, 19.50s/it][Succeeded / Failed / Skipped / Total] 51 / 196 / 4 / 251:  25%|██▌       | 252/1000 [1:21:45<4:02:40, 19.47s/it][Succeeded / Failed / Skipped / Total] 51 / 197 / 4 / 252:  25%|██▌       | 252/1000 [1:21:45<4:02:40, 19.47s/it][Succeeded / Failed / Skipped / Total] 51 / 197 / 4 / 252:  25%|██▌       | 253/1000 [1:21:49<4:01:35, 19.41s/it][Succeeded / Failed / Skipped / Total] 51 / 198 / 4 / 253:  25%|██▌       | 253/1000 [1:21:49<4:01:35, 19.41s/it][Succeeded / Failed / Skipped / Total] 51 / 198 / 4 / 253:  25%|██▌       | 254/1000 [1:23:16<4:04:34, 19.67s/it]Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 247 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig matcherConfig ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 248 ---------------------------------------------
Configures the mock mvc config.@param mockMvcConfig the mock mvc config@return the configured mock mvc config --> Creates a mock-managed RESTAssuredMockMvcConfig.@param handlerthe mock-managed RESTAssuredMockMvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[manoeuvring]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 249 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[prata]] ( ObjectMapperConfig [[afflictions]] ) { notNull ( [[prata]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[prata]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 250 ---------------------------------------------
Configures a multi part mock mvc config.@param multiPartConfig the multi part config@return the configured mock mvc config --> Creates and configures a RestAssuredMockMvcConfig object.@param absolue a {@link MultiPartConfig} object@return a {@link RestAssuredMockMvcConfig} object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[absolue]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 251 ---------------------------------------------
Creates and configures a RestAssuredMockMvcConfig object. --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig [[jsonConfig]] ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[pensioned]] ( JsonConfig [[desserts]] ) { notNull ( [[pensioned]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[pensioned]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 252 ---------------------------------------------
Configures RESTAssuredMockMvcConfig.@param xmlConfig the xml config@return the configured RESTAssuredMockMvcConfig --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[planters]] ( XmlConfig [[gunfighters]] ) { notNull ( [[planters]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[planters]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 253 ---------------------------------------------
Allow all hostnames in the given configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[impregnated]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 254 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 51 / 199 / 4 / 254:  25%|██▌       | 254/1000 [1:23:16<4:04:34, 19.67s/it][Succeeded / Failed / Skipped / Total] 51 / 199 / 4 / 254:  26%|██▌       | 255/1000 [1:23:36<4:04:17, 19.67s/it][Succeeded / Failed / Skipped / Total] 51 / 200 / 4 / 255:  26%|██▌       | 255/1000 [1:23:36<4:04:17, 19.67s/it][Succeeded / Failed / Skipped / Total] 51 / 200 / 4 / 255:  26%|██▌       | 256/1000 [1:24:22<4:05:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 51 / 201 / 4 / 256:  26%|██▌       | 256/1000 [1:24:22<4:05:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 51 / 201 / 4 / 256:  26%|██▌       | 257/1000 [1:26:16<4:09:25, 20.14s/it][Succeeded / Failed / Skipped / Total] 51 / 202 / 4 / 257:  26%|██▌       | 257/1000 [1:26:16<4:09:25, 20.14s/it][Succeeded / Failed / Skipped / Total] 51 / 202 / 4 / 257:  26%|██▌       | 258/1000 [1:26:26<4:08:37, 20.10s/it][Succeeded / Failed / Skipped / Total] 51 / 203 / 4 / 258:  26%|██▌       | 258/1000 [1:26:26<4:08:37, 20.10s/it][Succeeded / Failed / Skipped / Total] 51 / 203 / 4 / 258:  26%|██▌       | 259/1000 [1:26:47<4:08:17, 20.10s/it][Succeeded / Failed / Skipped / Total] 51 / 204 / 4 / 259:  26%|██▌       | 259/1000 [1:26:47<4:08:17, 20.10s/it][Succeeded / Failed / Skipped / Total] 51 / 204 / 4 / 259:  26%|██▌       | 260/1000 [1:27:41<4:09:35, 20.24s/it][Succeeded / Failed / Skipped / Total] 52 / 204 / 4 / 260:  26%|██▌       | 260/1000 [1:27:41<4:09:35, 20.24s/it][Succeeded / Failed / Skipped / Total] 52 / 204 / 4 / 260:  26%|██▌       | 261/1000 [1:28:07<4:09:31, 20.26s/it][Succeeded / Failed / Skipped / Total] 53 / 204 / 4 / 261:  26%|██▌       | 261/1000 [1:28:07<4:09:31, 20.26s/it][Succeeded / Failed / Skipped / Total] 53 / 204 / 4 / 261:  26%|██▌       | 262/1000 [1:28:32<4:09:23, 20.28s/it]Sets the default request headers. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[biryani]] ( Map < ? , ? > [[manacles]] ) { this . [[explanation]] . clear ( ) ; if ( [[manacles]] == null ) return ; for ( Object key : [[manacles]] . keySet ( ) ) { Object val = [[manacles]] . get ( key ) ; if ( val == null ) continue ; this . [[explanation]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 255 ---------------------------------------------
Declares the specified namespaces. --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[hairbrush]] ( Map < String , String > [[methyl]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[methyl]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 256 ---------------------------------------------
Sets the proxy for the specified host and port. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int [[port]] , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , [[port]] , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[cupboards]] ( String [[smell]] , int [[awoke]] , String [[gastrointestinal]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[smell]] , [[awoke]] , [[gastrointestinal]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 257 ---------------------------------------------
Creates and returns a copy of this XMLPathConfig object with the specified prefix and namespace URI.@param prefix the prefix of the XMLPathConfig object@param namespaceURI the namespace URI of the XMLPathConfig object@return a copy of this XMLPathConfig object --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig declaredNamespace ( String prefix , String namespaceURI ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > [[kubrick]] = new HashMap < String , String > ( declaredNamespaces ) ; [[kubrick]] . put ( prefix , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[kubrick]] , properties , validating , "[[Attracts]]" == "[[Attracts]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 258 ---------------------------------------------
Specifies the name and value of the header associated with this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[haver]] ( String name , String [[distorted]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[distorted]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 259 ---------------------------------------------
Resets the internal state. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[cirque]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 260 ---------------------------------------------
Sends a request to the server. --> Zeller implementation --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . [[defaultURI]] . toURI ( ) , [[method]] , this . [[defaultContentType]] , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[zeller]] ( String [[linguistic]] , boolean [[celibate]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . [[aword]] . toURI ( ) , [[linguistic]] , this . [[farrow]] , [[celibate]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 261 ---------------------------------------------
Performs basic authentication. --> Performs a cross-cross-cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross cross --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String host , int [[port]] , String [[user]] , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new UsernamePasswordCredentials ( [[user]] , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[crossing]] ( String host , int [[bulldozers]] , String [[writes]] , String [[sainsbury]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[bulldozers]] ) , new UsernamePasswordCredentials ( [[writes]] , [[sainsbury]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 262 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 204 / 4 / 262:  26%|██▌       | 262/1000 [1:28:32<4:09:23, 20.28s/it][Succeeded / Failed / Skipped / Total] 54 / 204 / 4 / 262:  26%|██▋       | 263/1000 [1:28:43<4:08:37, 20.24s/it][Succeeded / Failed / Skipped / Total] 54 / 205 / 4 / 263:  26%|██▋       | 263/1000 [1:28:43<4:08:37, 20.24s/it][Succeeded / Failed / Skipped / Total] 54 / 205 / 4 / 263:  26%|██▋       | 264/1000 [1:29:25<4:09:18, 20.32s/it][Succeeded / Failed / Skipped / Total] 54 / 206 / 4 / 264:  26%|██▋       | 264/1000 [1:29:25<4:09:18, 20.32s/it][Succeeded / Failed / Skipped / Total] 54 / 206 / 4 / 264:  26%|██▋       | 265/1000 [1:29:28<4:08:09, 20.26s/it][Succeeded / Failed / Skipped / Total] 54 / 207 / 4 / 265:  26%|██▋       | 265/1000 [1:29:28<4:08:09, 20.26s/it][Succeeded / Failed / Skipped / Total] 54 / 207 / 4 / 265:  27%|██▋       | 266/1000 [1:29:33<4:07:08, 20.20s/it][Succeeded / Failed / Skipped / Total] 54 / 208 / 4 / 266:  27%|██▋       | 266/1000 [1:29:33<4:07:08, 20.20s/it][Succeeded / Failed / Skipped / Total] 54 / 208 / 4 / 266:  27%|██▋       | 267/1000 [1:29:35<4:05:56, 20.13s/it][Succeeded / Failed / Skipped / Total] 54 / 209 / 4 / 267:  27%|██▋       | 267/1000 [1:29:35<4:05:56, 20.13s/it][Succeeded / Failed / Skipped / Total] 54 / 209 / 4 / 267:  27%|██▋       | 268/1000 [1:29:45<4:05:10, 20.10s/it]Sets the specified header value.@param name the header name@param value the header value@return this response builder --> Sets the headline of the response.@param crybaby The headline of the response. May not be <code>null</code>.@param crucifixions The headline of the response. May not be <code>null</code>.@return This response builder. --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[name]] , String [[value]] ) { notNull ( [[name]] , "Header name" ) ; notNull ( [[value]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , [[value]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[value]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder setHeader ( String [[crybaby]] , String [[crucifixions]] ) { notNull ( [[crybaby]] , "Header name" ) ; notNull ( [[crucifixions]] , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[crybaby]] , [[crucifixions]] ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[crybaby]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( [[crucifixions]] ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 263 ---------------------------------------------
Builds the response.@return the response --> [[[FAILED]]]

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[antsy]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 264 ---------------------------------------------
Creates a new NTLM credential. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[fusiliers]] ( String host , int port , String user , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( user , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 265 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[traditions]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 266 ---------------------------------------------
Create a matcher that matches cookies that have a comment. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[endowment]] ( Matcher < ? super String > [[unaware]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[unaware]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 267 ---------------------------------------------
Creates a copy of the supplied headers.@param header The header to copy.@param additionalHeaders Additional headers to add.@return A copy of the supplied headers. --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[inferior]] ( Header [[gunsmith]] , Header ... [[mourners]] ) { notNull ( [[gunsmith]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[gunsmith]] ) ; if ( [[mourners]] != null ) { Collections . addAll ( headerList , [[mourners]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 268 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 55 / 209 / 4 / 268:  27%|██▋       | 268/1000 [1:29:45<4:05:10, 20.10s/it][Succeeded / Failed / Skipped / Total] 55 / 209 / 4 / 268:  27%|██▋       | 269/1000 [1:29:48<4:04:01, 20.03s/it][Succeeded / Failed / Skipped / Total] 55 / 210 / 4 / 269:  27%|██▋       | 269/1000 [1:29:48<4:04:01, 20.03s/it][Succeeded / Failed / Skipped / Total] 55 / 210 / 4 / 269:  27%|██▋       | 270/1000 [1:29:49<4:02:51, 19.96s/it][Succeeded / Failed / Skipped / Total] 55 / 211 / 4 / 270:  27%|██▋       | 270/1000 [1:29:49<4:02:51, 19.96s/it][Succeeded / Failed / Skipped / Total] 55 / 211 / 4 / 270:  27%|██▋       | 271/1000 [1:30:34<4:03:39, 20.05s/it][Succeeded / Failed / Skipped / Total] 55 / 212 / 4 / 271:  27%|██▋       | 271/1000 [1:30:34<4:03:39, 20.05s/it][Succeeded / Failed / Skipped / Total] 55 / 212 / 4 / 271:  27%|██▋       | 272/1000 [1:30:55<4:03:22, 20.06s/it][Succeeded / Failed / Skipped / Total] 55 / 213 / 4 / 272:  27%|██▋       | 272/1000 [1:30:55<4:03:22, 20.06s/it][Succeeded / Failed / Skipped / Total] 55 / 213 / 4 / 272:  27%|██▋       | 273/1000 [1:31:05<4:02:34, 20.02s/it][Succeeded / Failed / Skipped / Total] 55 / 214 / 4 / 273:  27%|██▋       | 273/1000 [1:31:05<4:02:34, 20.02s/it][Succeeded / Failed / Skipped / Total] 55 / 214 / 4 / 273:  27%|██▋       | 274/1000 [1:31:10<4:01:34, 19.97s/it][Succeeded / Failed / Skipped / Total] 55 / 215 / 4 / 274:  27%|██▋       | 274/1000 [1:31:10<4:01:34, 19.97s/it][Succeeded / Failed / Skipped / Total] 55 / 215 / 4 / 274:  28%|██▊       | 275/1000 [1:31:11<4:00:24, 19.90s/it]Prints the response.@param responseOptions the response options@param responseBody the response body@param responseDetail the response details@param logDetail the log details@param shouldPrettyPrint the should pretty print@return the string --> Creates a string representation of an environment. --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions [[responseOptions]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[shouldPrettyPrint]] ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[responseOptions]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[responseOptions]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies [[cookies]] = [[responseOptions]] . detailedCookies ( ) ; if ( [[cookies]] . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( [[cookies]] . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( [[shouldPrettyPrint]] ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[responseOptions]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[environmentalist]] ( ResponseOptions [[harmonia]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean [[boulders]] ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[harmonia]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[harmonia]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies [[upfront]] = [[harmonia]] . detailedCookies ( ) ; if ( [[upfront]] . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( [[upfront]] . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( [[boulders]] ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[harmonia]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 269 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher expiryDate ( Matcher < ? super Date > [[toppled]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[toppled]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Sets the control name.@param controlName The name of the control.@return This builder instance. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . isControlNameExplicit = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[utterance]] ( String [[rodents]] ) { Validate . notEmpty ( [[utterance]] , "Control name cannot be empty" ) ; this . [[raymer]] = [[utterance]] ; this . isControlNameExplicit = "[[Antifreeze]]" == "[[Antifreeze]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 271 ---------------------------------------------
Creates a matcher that matches a cookie path. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[havens]] ( Matcher < ? super String > [[lids]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[lids]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches the supplied domain matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[counties]] ( Matcher < ? super String > domainMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , domainMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[frédéric]] ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches this cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[riza]] ( Matcher < ? super Integer > [[divorcée]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[divorcée]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 215 / 4 / 275:  28%|██▊       | 275/1000 [1:31:11<4:00:24, 19.90s/it][Succeeded / Failed / Skipped / Total] 56 / 215 / 4 / 275:  28%|██▊       | 276/1000 [1:31:12<3:59:14, 19.83s/it][Succeeded / Failed / Skipped / Total] 56 / 216 / 4 / 276:  28%|██▊       | 276/1000 [1:31:12<3:59:14, 19.83s/it][Succeeded / Failed / Skipped / Total] 56 / 216 / 4 / 276:  28%|██▊       | 277/1000 [1:31:17<3:58:16, 19.77s/it][Succeeded / Failed / Skipped / Total] 56 / 217 / 4 / 277:  28%|██▊       | 277/1000 [1:31:17<3:58:16, 19.77s/it][Succeeded / Failed / Skipped / Total] 56 / 217 / 4 / 277:  28%|██▊       | 278/1000 [1:32:02<3:59:01, 19.86s/it][Succeeded / Failed / Skipped / Total] 56 / 218 / 4 / 278:  28%|██▊       | 278/1000 [1:32:02<3:59:01, 19.86s/it][Succeeded / Failed / Skipped / Total] 56 / 218 / 4 / 278:  28%|██▊       | 279/1000 [1:32:11<3:58:15, 19.83s/it][Succeeded / Failed / Skipped / Total] 56 / 219 / 4 / 279:  28%|██▊       | 279/1000 [1:32:11<3:58:15, 19.83s/it][Succeeded / Failed / Skipped / Total] 56 / 219 / 4 / 279:  28%|██▊       | 280/1000 [1:32:14<3:57:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 56 / 220 / 4 / 280:  28%|██▊       | 280/1000 [1:32:14<3:57:11, 19.77s/it][Succeeded / Failed / Skipped / Total] 56 / 220 / 4 / 280:  28%|██▊       | 281/1000 [1:32:26<3:56:31, 19.74s/it][Succeeded / Failed / Skipped / Total] 56 / 221 / 4 / 281:  28%|██▊       | 281/1000 [1:32:26<3:56:31, 19.74s/it][Succeeded / Failed / Skipped / Total] 56 / 221 / 4 / 281:  28%|██▊       | 282/1000 [1:32:38<3:55:51, 19.71s/it][Succeeded / Failed / Skipped / Total] 56 / 222 / 4 / 282:  28%|██▊       | 282/1000 [1:32:38<3:55:51, 19.71s/it][Succeeded / Failed / Skipped / Total] 56 / 222 / 4 / 282:  28%|██▊       | 283/1000 [1:32:58<3:55:33, 19.71s/it][Succeeded / Failed / Skipped / Total] 56 / 223 / 4 / 283:  28%|██▊       | 283/1000 [1:32:58<3:55:33, 19.71s/it][Succeeded / Failed / Skipped / Total] 56 / 223 / 4 / 283:  28%|██▊       | 284/1000 [1:33:20<3:55:19, 19.72s/it][Succeeded / Failed / Skipped / Total] 57 / 223 / 4 / 284:  28%|██▊       | 284/1000 [1:33:20<3:55:19, 19.72s/it][Succeeded / Failed / Skipped / Total] 57 / 223 / 4 / 284:  28%|██▊       | 285/1000 [1:33:22<3:54:15, 19.66s/it]Specifies that the specified header should match the supplied expected value. --> Spec builder for mussolini --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[headerName]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[mussolini]] ( String [[orleans]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[orleans]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Create a DetailedCookieMatcher that matches cookies only.@param httpOnlyMatcher The cookie only matcher.@return A DetailedCookieMatcher that matches cookies only. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[gatherers]] ( Matcher < ? super Boolean > [[conveyed]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[conveyed]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 277 ---------------------------------------------
Creates and returns a new instance of the DetailedCookieMatcher that matches theprovided maximum age. --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher maxAge ( Matcher < ? super Integer > [[sasquatch]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[sasquatch]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 278 ---------------------------------------------
Returns a copy of this specification with the specified host. --> [[[FAILED]]]

[[[[Adv]]]]: public ProxySpecification withHost ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification withHost ( String [[axles]] ) { return new ProxySpecification ( [[axles]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 279 ---------------------------------------------
Returns a copy of this config with the specified parser type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[motorcyclists]] ( JsonParserType [[restlessly]] ) { return new JsonPathConfig ( numberReturnType , [[motorcyclists]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 280 ---------------------------------------------
Configures the JSON path with a number return type. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[oddball]] ( NumberReturnType [[attentively]] ) { return new JsonPathConfig ( [[oddball]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 281 ---------------------------------------------
Specifies the expected value for a cookie.@param cookieName the name of the cookie@param expectedValue the expected value for the cookie --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String [[expectedValue]] ) { spec . cookie ( cookieName , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder expectCookie ( String cookieName , String [[fukuda]] ) { spec . cookie ( cookieName , [[fukuda]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 282 ---------------------------------------------
Expects the specified header to be present in the response. --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[impregnated]] ( String [[bandages]] , String [[accepts]] ) { spec . header ( [[bandages]] , [[accepts]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 283 ---------------------------------------------
Creates a default log configuration for this log. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig defaultStream ( PrintStream [[descent]] ) { return new LogConfig ( [[descent]] , "True" == "True" , logDetailIfValidationFails , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute to the request spec. --> Specifies the amount of time to sleep before giving up. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String [[attributeName]] , Object attributeValue ) { spec . attribute ( [[attributeName]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[aqueduct]] ( String [[sleepovers]] , Object attributeValue ) { spec . attribute ( [[sleepovers]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 57 / 224 / 4 / 285:  28%|██▊       | 285/1000 [1:33:22<3:54:15, 19.66s/it][Succeeded / Failed / Skipped / Total] 57 / 224 / 4 / 285:  29%|██▊       | 286/1000 [1:33:30<3:53:25, 19.62s/it][Succeeded / Failed / Skipped / Total] 58 / 224 / 4 / 286:  29%|██▊       | 286/1000 [1:33:30<3:53:25, 19.62s/it][Succeeded / Failed / Skipped / Total] 58 / 224 / 4 / 286:  29%|██▊       | 287/1000 [1:33:44<3:52:53, 19.60s/it][Succeeded / Failed / Skipped / Total] 58 / 225 / 4 / 287:  29%|██▊       | 287/1000 [1:33:44<3:52:53, 19.60s/it][Succeeded / Failed / Skipped / Total] 58 / 225 / 4 / 287:  29%|██▉       | 288/1000 [1:34:57<3:54:45, 19.78s/it][Succeeded / Failed / Skipped / Total] 58 / 226 / 4 / 288:  29%|██▉       | 288/1000 [1:34:57<3:54:45, 19.78s/it][Succeeded / Failed / Skipped / Total] 58 / 226 / 4 / 288:  29%|██▉       | 289/1000 [1:35:19<3:54:31, 19.79s/it][Succeeded / Failed / Skipped / Total] 58 / 227 / 4 / 289:  29%|██▉       | 289/1000 [1:35:19<3:54:31, 19.79s/it][Succeeded / Failed / Skipped / Total] 58 / 227 / 4 / 289:  29%|██▉       | 290/1000 [1:35:38<3:54:08, 19.79s/it][Succeeded / Failed / Skipped / Total] 59 / 227 / 4 / 290:  29%|██▉       | 290/1000 [1:35:38<3:54:08, 19.79s/it][Succeeded / Failed / Skipped / Total] 59 / 227 / 4 / 290:  29%|██▉       | 291/1000 [1:35:52<3:53:35, 19.77s/it][Succeeded / Failed / Skipped / Total] 59 / 228 / 4 / 291:  29%|██▉       | 291/1000 [1:35:52<3:53:35, 19.77s/it][Succeeded / Failed / Skipped / Total] 59 / 228 / 4 / 291:  29%|██▉       | 292/1000 [1:36:25<3:53:48, 19.81s/it][Succeeded / Failed / Skipped / Total] 59 / 229 / 4 / 292:  29%|██▉       | 292/1000 [1:36:25<3:53:48, 19.81s/it][Succeeded / Failed / Skipped / Total] 59 / 229 / 4 / 292:  29%|██▉       | 293/1000 [1:36:34<3:53:02, 19.78s/it][Succeeded / Failed / Skipped / Total] 59 / 230 / 4 / 293:  29%|██▉       | 293/1000 [1:36:34<3:53:02, 19.78s/it][Succeeded / Failed / Skipped / Total] 59 / 230 / 4 / 293:  29%|██▉       | 294/1000 [1:36:46<3:52:22, 19.75s/it]Enables or disables logging of a request and response. --> [[[FAILED]]]

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[maladjusted]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "True" == "True" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 286 ---------------------------------------------
Add result handlers.@param resultHandler the result handler@param additionalResultHandlers the additional result handlers --> Delames the mock mvc request spec builder. --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[delamere]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 287 ---------------------------------------------
Configures the default boundary for this multipart. --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[scottsdale]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[scottsdale]] , defaultCharset , "[[Tranquillizer]]" == "[[Tranquillizer]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 288 ---------------------------------------------
Adds a header to the request. --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String [[headerValue]] ) { spec . header ( headerName , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[openness]] ( String headerName , String [[psychedelic]] ) { spec . header ( headerName , [[psychedelic]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 289 ---------------------------------------------
Creates and returns a new instance of the HttpClientConfig class. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[balsa]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 290 ---------------------------------------------
Adds a multi part request specification. --> MUST BE CALLED ONLY FROM METHODS --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String contentBody , String [[mimeType]] ) { spec . multiPart ( controlName , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[mourners]] ( String controlName , String contentBody , String [[cinematographic]] ) { spec . multiPart ( controlName , [[cinematographic]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 291 ---------------------------------------------
Configures this HttpClientConfig with the given HTTP MultipartMode. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[arrivederci]] ( HttpMultipartMode [[beeswax]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[arrivederci]] , shouldReuseHttpClientInstance , httpClient , "[[Dossier]]" == "[[Dossier]]" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 292 ---------------------------------------------
Sets the value of the specified HTTP parameter.@param parameterName Name of the HTTP parameter to set.@param parameterValue Value of the HTTP parameter to set.@return Never <code>null</code>. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > HttpClientConfig setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Pitching]]" == "[[Pitching]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 293 ---------------------------------------------
Retrieve an integer value from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[evenings]] ( String [[casters]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 294 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 60 / 230 / 4 / 294:  29%|██▉       | 294/1000 [1:36:46<3:52:22, 19.75s/it][Succeeded / Failed / Skipped / Total] 60 / 230 / 4 / 294:  30%|██▉       | 295/1000 [1:36:48<3:51:22, 19.69s/it][Succeeded / Failed / Skipped / Total] 61 / 230 / 4 / 295:  30%|██▉       | 295/1000 [1:36:48<3:51:22, 19.69s/it][Succeeded / Failed / Skipped / Total] 61 / 230 / 4 / 295:  30%|██▉       | 296/1000 [1:36:55<3:50:32, 19.65s/it][Succeeded / Failed / Skipped / Total] 62 / 230 / 4 / 296:  30%|██▉       | 296/1000 [1:36:55<3:50:32, 19.65s/it][Succeeded / Failed / Skipped / Total] 62 / 230 / 4 / 296:  30%|██▉       | 297/1000 [1:37:20<3:50:23, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 231 / 4 / 297:  30%|██▉       | 297/1000 [1:37:20<3:50:23, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 231 / 4 / 297:  30%|██▉       | 298/1000 [1:37:28<3:49:38, 19.63s/it][Succeeded / Failed / Skipped / Total] 62 / 232 / 4 / 298:  30%|██▉       | 298/1000 [1:37:28<3:49:38, 19.63s/it][Succeeded / Failed / Skipped / Total] 62 / 232 / 4 / 298:  30%|██▉       | 299/1000 [1:37:58<3:49:43, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 233 / 4 / 299:  30%|██▉       | 299/1000 [1:37:58<3:49:43, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 233 / 4 / 299:  30%|███       | 300/1000 [1:38:06<3:48:55, 19.62s/it][Succeeded / Failed / Skipped / Total] 62 / 234 / 4 / 300:  30%|███       | 300/1000 [1:38:06<3:48:55, 19.62s/it][Succeeded / Failed / Skipped / Total] 62 / 234 / 4 / 300:  30%|███       | 301/1000 [1:38:23<3:48:30, 19.61s/it][Succeeded / Failed / Skipped / Total] 62 / 235 / 4 / 301:  30%|███       | 301/1000 [1:38:23<3:48:30, 19.61s/it][Succeeded / Failed / Skipped / Total] 62 / 235 / 4 / 301:  30%|███       | 302/1000 [1:38:56<3:48:40, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 236 / 4 / 302:  30%|███       | 302/1000 [1:38:56<3:48:40, 19.66s/it][Succeeded / Failed / Skipped / Total] 62 / 236 / 4 / 302:  30%|███       | 303/1000 [1:39:05<3:47:55, 19.62s/it][Succeeded / Failed / Skipped / Total] 62 / 237 / 4 / 303:  30%|███       | 303/1000 [1:39:05<3:47:55, 19.62s/it][Succeeded / Failed / Skipped / Total] 62 / 237 / 4 / 303:  30%|███       | 304/1000 [1:39:17<3:47:19, 19.60s/it]Creates a new HTTP request based on the given URI and HTTP method. --> Converts a URI to a HttpRequestBase@param remark@param monique@param hasBody@return --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI [[uri]] , String [[httpMethod]] , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[bouquets]] ( URI [[remark]] , String [[monique]] , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( [[monique]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[kiang]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 295 ---------------------------------------------
Retrieve a byte value from the supplied resource. --> Diese Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode Methode --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[divorcée]] ( String [[ancient]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 296 ---------------------------------------------
Retrieve a Short object from the given path. --> Diese Methode dedging@param adrienne@return --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[dredging]] ( String [[adrienne]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 297 ---------------------------------------------
Creates a new HTTP client configuration with the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[newParams]] . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[biles]] ( Map < String , ? > [[beeswax]] ) { notNull ( [[beeswax]] , "httpClientParams" ) ; final Map < String , Object > [[woolly]] = new HashMap < String , Object > ( this . httpClientParams ) ; [[woolly]] . putAll ( [[beeswax]] ) ; return new HttpClientConfig ( httpClientFactory , [[woolly]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Jabberwocky]]" == "[[Jabberwocky]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 298 ---------------------------------------------
Gets the value of the specified JSON path.@param < T> the type parameter@param path the path@return the value --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[ichi]] > [[ichi]] get ( String path ) { final JSONAssertion [[condo]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[ichi]] ) [[condo]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 299 ---------------------------------------------
Retrieve a property as a double. --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[kasem]] ( String [[travellers]] ) { final Object [[manifestations]] = get ( [[travellers]] ) ; if ( [[manifestations]] instanceof Double ) { return ( Double ) [[manifestations]] ; } return ObjectConverter . convertObjectTo ( [[manifestations]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 300 ---------------------------------------------
Retrieve a long value. --> [[[FAILED]]]

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[skeptic]] ( String [[byung]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 301 ---------------------------------------------
Retrieve a property as a float. --> [[[FAILED]]]

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[hatreds]] ( String [[gough]] ) { final Object value = get ( [[gough]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 302 ---------------------------------------------
Gets a map from a path. --> [[[FAILED]]]

[[[[Adv]]]]: public < K , V > Map < K , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < K , V > Map < K , V > [[soulmate]] ( String [[rossendale]] ) { return get ( [[rossendale]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 303 ---------------------------------------------
Sets the body of the request. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper mapper ) { spec . body ( [[object]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[enclose]] ( Object [[pyramid]] , ObjectMapper mapper ) { spec . body ( [[pyramid]] , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 304 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 62 / 238 / 4 / 304:  30%|███       | 304/1000 [1:39:17<3:47:19, 19.60s/it][Succeeded / Failed / Skipped / Total] 62 / 238 / 4 / 304:  30%|███       | 305/1000 [1:39:48<3:47:25, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 238 / 4 / 305:  30%|███       | 305/1000 [1:39:48<3:47:25, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 238 / 4 / 305:  31%|███       | 306/1000 [1:40:12<3:47:17, 19.65s/it][Succeeded / Failed / Skipped / Total] 63 / 239 / 4 / 306:  31%|███       | 306/1000 [1:40:12<3:47:17, 19.65s/it][Succeeded / Failed / Skipped / Total] 63 / 239 / 4 / 306:  31%|███       | 307/1000 [1:40:26<3:46:44, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 240 / 4 / 307:  31%|███       | 307/1000 [1:40:26<3:46:44, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 240 / 4 / 307:  31%|███       | 308/1000 [1:40:44<3:46:21, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 241 / 4 / 308:  31%|███       | 308/1000 [1:40:44<3:46:21, 19.63s/it][Succeeded / Failed / Skipped / Total] 63 / 241 / 4 / 308:  31%|███       | 309/1000 [1:41:17<3:46:30, 19.67s/it][Succeeded / Failed / Skipped / Total] 63 / 242 / 4 / 309:  31%|███       | 309/1000 [1:41:17<3:46:30, 19.67s/it][Succeeded / Failed / Skipped / Total] 63 / 242 / 4 / 309:  31%|███       | 310/1000 [1:41:18<3:45:29, 19.61s/it][Succeeded / Failed / Skipped / Total] 64 / 242 / 4 / 310:  31%|███       | 310/1000 [1:41:18<3:45:29, 19.61s/it][Succeeded / Failed / Skipped / Total] 64 / 242 / 4 / 310:  31%|███       | 311/1000 [1:41:28<3:44:49, 19.58s/it][Succeeded / Failed / Skipped / Total] 64 / 243 / 4 / 311:  31%|███       | 311/1000 [1:41:28<3:44:49, 19.58s/it][Succeeded / Failed / Skipped / Total] 64 / 243 / 4 / 311:  31%|███       | 312/1000 [1:41:51<3:44:36, 19.59s/it][Succeeded / Failed / Skipped / Total] 64 / 244 / 4 / 312:  31%|███       | 312/1000 [1:41:51<3:44:36, 19.59s/it][Succeeded / Failed / Skipped / Total] 64 / 244 / 4 / 312:  31%|███▏      | 313/1000 [1:42:14<3:44:24, 19.60s/it][Succeeded / Failed / Skipped / Total] 64 / 245 / 4 / 313:  31%|███▏      | 313/1000 [1:42:14<3:44:24, 19.60s/it][Succeeded / Failed / Skipped / Total] 64 / 245 / 4 / 313:  31%|███▏      | 314/1000 [1:42:15<3:43:23, 19.54s/it]Retrieves an object from the supplied path. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[chaplains]] > [[chaplains]] getObject ( String path , Class < [[chaplains]] > objectType ) { Object [[piddly]] = getFromPath ( path , "[[Javelin]]" != "[[Javelin]]" ) ; return getObjectAsType ( [[piddly]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the spec. --> Specifies parameters for magruder@param señora@param parameterValues@return --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[magruder]] ( String [[señora]] , Object ... parameterValues ) { spec . param ( [[señora]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Adds a cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[insecurities]] ( String key , Object value , Object ... cookieNameValuePairs ) { spec . cookie ( key , value , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 307 ---------------------------------------------
Adds a parameter to the spec. --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[norbit]] ( String [[bombings]] , Collection < ? > [[licious]] ) { spec . param ( [[bombings]] , [[licious]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 308 ---------------------------------------------
Adds all bindings to the map. --> [[[FAILED]]]

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[newland]] ( ) { for ( Binding < ? > [[hassel]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[hassel]] . getKey ( ) . getTypeLiteral ( ) , [[hassel]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 309 ---------------------------------------------
Removes all keys and sources from the backing map. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[infanticide]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 310 ---------------------------------------------
Creates and returns a builder for a parameter update strategy. --> MockMvcParamConfig whether --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[whether]] ( UpdateStrategy [[cannoneer]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[cannoneer]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[Bangkok]]" == "[[Bangkok]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 311 ---------------------------------------------
Creates a filter that logs responses that match the provided matcher. --> [[[FAILED]]]

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[oceanic]] ) { return new ResponseLoggingFilter ( stream , [[oceanic]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 312 ---------------------------------------------
Creates a new Cookies instance with the specified cookies.@param cookie the cookie@param additionalCookies the additional cookies@return a new cookies instance --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookies [[cookies]] ( Cookie [[cookie]] , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cookie]] ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies [[distributes]] ( Cookie [[quatro]] , Cookie ... [[diamanda]] ) { AssertParameter . notNull ( [[quatro]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[quatro]] ) ; Collections . addAll ( cookieList , [[diamanda]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 313 ---------------------------------------------
Converts a string constant binding to a binding. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[benevolence]] ( Key < T > [[dentist]] , Errors [[kavita]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 314 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 64 / 246 / 4 / 314:  31%|███▏      | 314/1000 [1:42:15<3:43:23, 19.54s/it][Succeeded / Failed / Skipped / Total] 64 / 246 / 4 / 314:  32%|███▏      | 315/1000 [1:42:27<3:42:48, 19.52s/it][Succeeded / Failed / Skipped / Total] 64 / 247 / 4 / 315:  32%|███▏      | 315/1000 [1:42:27<3:42:48, 19.52s/it][Succeeded / Failed / Skipped / Total] 64 / 247 / 4 / 315:  32%|███▏      | 316/1000 [1:43:01<3:42:59, 19.56s/it][Succeeded / Failed / Skipped / Total] 65 / 247 / 4 / 316:  32%|███▏      | 316/1000 [1:43:01<3:42:59, 19.56s/it][Succeeded / Failed / Skipped / Total] 65 / 247 / 4 / 316:  32%|███▏      | 317/1000 [1:43:07<3:42:11, 19.52s/it][Succeeded / Failed / Skipped / Total] 65 / 248 / 4 / 317:  32%|███▏      | 317/1000 [1:43:07<3:42:11, 19.52s/it][Succeeded / Failed / Skipped / Total] 65 / 248 / 4 / 317:  32%|███▏      | 318/1000 [1:43:15<3:41:26, 19.48s/it][Succeeded / Failed / Skipped / Total] 65 / 249 / 4 / 318:  32%|███▏      | 318/1000 [1:43:15<3:41:26, 19.48s/it][Succeeded / Failed / Skipped / Total] 65 / 249 / 4 / 318:  32%|███▏      | 319/1000 [1:43:45<3:41:31, 19.52s/it][Succeeded / Failed / Skipped / Total] 65 / 250 / 4 / 319:  32%|███▏      | 319/1000 [1:43:45<3:41:31, 19.52s/it][Succeeded / Failed / Skipped / Total] 65 / 250 / 4 / 319:  32%|███▏      | 320/1000 [1:43:47<3:40:32, 19.46s/it][Succeeded / Failed / Skipped / Total] 66 / 250 / 4 / 320:  32%|███▏      | 320/1000 [1:43:47<3:40:32, 19.46s/it][Succeeded / Failed / Skipped / Total] 66 / 250 / 4 / 320:  32%|███▏      | 321/1000 [1:44:21<3:40:45, 19.51s/it]Returns the internal dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[creepy]] ( BindingImpl < ? > [[micromachine]] ) { if ( [[micromachine]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[micromachine]] ) . getInternalDependencies ( ) ; } else if ( [[micromachine]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[micromachine]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 315 ---------------------------------------------
Removes a failed JIT binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[cinder]] ( Binding < ? > binding , InjectionPoint ip ) { failedJitBindings . add ( binding . getKey ( ) ) ; jitBindings . remove ( binding . getKey ( ) ) ; membersInjectorStore . remove ( binding . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( binding ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 316 ---------------------------------------------
Binds a logger to the given injector. --> Postman methods --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[postman]] ( InjectorImpl injector ) { Key < Logger > [[magruder]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[magruder]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[magruder]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 317 ---------------------------------------------
Gets a list from the specified path.@param path the path@param genericType the generic type@return the list --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T [[t]] : [[original]] ) { T [[e]] ; if ( [[t]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[astaroth]] ( String [[pinches]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[relevant]] = get ( [[pinches]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( [[relevant]] != null ) { for ( T [[oddball]] : [[relevant]] ) { T [[better]] ; if ( [[oddball]] instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 318 ---------------------------------------------
Binds an injector. --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[expend]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 319 ---------------------------------------------
Get the provider type. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[conditioning]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 320 ---------------------------------------------
Initializes the delegate members. --> region axioms --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[axles]] ( MembersInjector < T > delegate ) { checkState ( this . [[population]] == null , "delegate already initialized" ) ; this . [[population]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 321 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 66 / 251 / 4 / 321:  32%|███▏      | 321/1000 [1:44:21<3:40:45, 19.51s/it][Succeeded / Failed / Skipped / Total] 66 / 251 / 4 / 321:  32%|███▏      | 322/1000 [1:44:43<3:40:30, 19.51s/it][Succeeded / Failed / Skipped / Total] 67 / 251 / 4 / 322:  32%|███▏      | 322/1000 [1:44:43<3:40:30, 19.51s/it][Succeeded / Failed / Skipped / Total] 67 / 251 / 4 / 322:  32%|███▏      | 323/1000 [1:44:53<3:39:51, 19.49s/it][Succeeded / Failed / Skipped / Total] 67 / 252 / 4 / 323:  32%|███▏      | 323/1000 [1:44:53<3:39:51, 19.49s/it][Succeeded / Failed / Skipped / Total] 67 / 252 / 4 / 323:  32%|███▏      | 324/1000 [1:45:19<3:39:44, 19.50s/it][Succeeded / Failed / Skipped / Total] 67 / 253 / 4 / 324:  32%|███▏      | 324/1000 [1:45:19<3:39:44, 19.50s/it][Succeeded / Failed / Skipped / Total] 67 / 253 / 4 / 324:  32%|███▎      | 325/1000 [1:45:27<3:39:02, 19.47s/it][Succeeded / Failed / Skipped / Total] 67 / 254 / 4 / 325:  32%|███▎      | 325/1000 [1:45:27<3:39:02, 19.47s/it][Succeeded / Failed / Skipped / Total] 67 / 254 / 4 / 325:  33%|███▎      | 326/1000 [1:45:31<3:38:10, 19.42s/it][Succeeded / Failed / Skipped / Total] 67 / 255 / 4 / 326:  33%|███▎      | 326/1000 [1:45:31<3:38:10, 19.42s/it][Succeeded / Failed / Skipped / Total] 67 / 255 / 4 / 326:  33%|███▎      | 327/1000 [1:46:17<3:38:46, 19.50s/it][Succeeded / Failed / Skipped / Total] 67 / 256 / 4 / 327:  33%|███▎      | 327/1000 [1:46:17<3:38:46, 19.50s/it][Succeeded / Failed / Skipped / Total] 67 / 256 / 4 / 327:  33%|███▎      | 328/1000 [1:46:34<3:38:21, 19.50s/it]Creates an uninitialized binding. --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 322 ---------------------------------------------
Prepare all built-in converters. --> Asserts that the supplied injector is asserting that the supplied injector is assertingthat the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is asserting that the supplied injector is --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[affirming]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 323 ---------------------------------------------
Cleans up the dependencies of the given binding. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > [[encountered]] ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( [[encountered]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[expend]] ( BindingImpl < ? > binding , Set < Key > [[ennio]] ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( [[ennio]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 324 ---------------------------------------------
Checks if two methods are overrides of each other. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[gallic]] ( Method a , Method [[conditioning]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 325 ---------------------------------------------
Canonicalizes the given class loader. --> [[[FAILED]]]

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[preeminent]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 326 ---------------------------------------------
Resolve all of the given types. --> [[[FAILED]]]

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int [[t]] = 0 ; [[t]] < [[types]] . length ; [[t]] ++ ) { [[result]] [ [[t]] ] = resolve ( [[types]] [ [[t]] ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] [[cadres]] ) { TypeLiteral < ? > [ ] [[beagle]] = new TypeLiteral < ? > [ [[cadres]] . length ] ; for ( int [[intentions]] = 0 ; [[intentions]] < [[cadres]] . length ; [[intentions]] ++ ) { [[beagle]] [ [[intentions]] ] = resolve ( [[cadres]] [ [[intentions]] ] ) ; } return ImmutableList . copyOf ( [[beagle]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 327 ---------------------------------------------
Converts the specified key into an appropriate annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[mainstay]] ( Key < ? > [[puncture]] ) { return [[puncture]] . getAnnotation ( ) == null ? [[puncture]] : Key . get ( [[puncture]] . getTypeLiteral ( ) , [[puncture]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 328 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 67 / 257 / 4 / 328:  33%|███▎      | 328/1000 [1:46:34<3:38:21, 19.50s/it][Succeeded / Failed / Skipped / Total] 67 / 257 / 4 / 328:  33%|███▎      | 329/1000 [1:46:41<3:37:35, 19.46s/it][Succeeded / Failed / Skipped / Total] 67 / 258 / 4 / 329:  33%|███▎      | 329/1000 [1:46:41<3:37:35, 19.46s/it][Succeeded / Failed / Skipped / Total] 67 / 258 / 4 / 329:  33%|███▎      | 330/1000 [1:46:54<3:37:03, 19.44s/it][Succeeded / Failed / Skipped / Total] 67 / 259 / 4 / 330:  33%|███▎      | 330/1000 [1:46:54<3:37:03, 19.44s/it][Succeeded / Failed / Skipped / Total] 67 / 259 / 4 / 330:  33%|███▎      | 331/1000 [1:47:03<3:36:21, 19.40s/it][Succeeded / Failed / Skipped / Total] 67 / 260 / 4 / 331:  33%|███▎      | 331/1000 [1:47:03<3:36:21, 19.40s/it][Succeeded / Failed / Skipped / Total] 67 / 260 / 4 / 331:  33%|███▎      | 332/1000 [1:47:23<3:36:03, 19.41s/it][Succeeded / Failed / Skipped / Total] 67 / 261 / 4 / 332:  33%|███▎      | 332/1000 [1:47:23<3:36:03, 19.41s/it][Succeeded / Failed / Skipped / Total] 67 / 261 / 4 / 332:  33%|███▎      | 333/1000 [1:47:51<3:36:01, 19.43s/it][Succeeded / Failed / Skipped / Total] 67 / 262 / 4 / 333:  33%|███▎      | 333/1000 [1:47:51<3:36:01, 19.43s/it][Succeeded / Failed / Skipped / Total] 67 / 262 / 4 / 333:  33%|███▎      | 334/1000 [1:48:19<3:36:00, 19.46s/it]Injects the given instance into the given injector.@param injector the injector@param instance the instance@param binding the binding@param source the source@param injectionPoints the injection points --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 329 ---------------------------------------------
Checks for misplaced binding annotations. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member member , Errors [[errors]] ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( [[errors]] , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[obsessive]] ( Member member , Errors [[schoolroom]] ) { Annotation [[damaging]] = Annotations . findBindingAnnotation ( [[schoolroom]] , member , ( ( AnnotatedElement ) member ) . getAnnotations ( ) ) ; if ( [[damaging]] == null ) { return "[[Lambada]]" != "[[Lambada]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 330 ---------------------------------------------
Returns all the parameters in the given injectors. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[size]] = parameterInjectors . length ; Object [ ] [[parameters]] = new Object [ [[size]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] getAll ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int [[chartered]] = parameterInjectors . length ; Object [ ] [[christer]] = new Object [ [[chartered]] ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 331 ---------------------------------------------
Converts a TypeLiteral into a canonical type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type type = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[babbage]] ( TypeLiteral < T > [[chaplains]] ) { Type type = [[chaplains]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[chaplains]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[chaplains]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 332 ---------------------------------------------
Validates that the injections are valid. --> [[[FAILED]]]

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors errors ) { validationStarted = "[[Denial]]" == "[[Denial]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[aphid]] : pendingInjections ) { try { [[aphid]] . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 333 ---------------------------------------------
Checks if the given class loader has the same version of the current one. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[tenderfoot]] ( ClassLoader classLoader ) { Class < ? > [[kolkhoz]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[kolkhoz]] . getName ( ) ) == [[kolkhoz]] ; } catch ( ClassNotFoundException e ) { return "[[Blighters]]" != "[[Blighters]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 334 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 68 / 262 / 4 / 334:  33%|███▎      | 334/1000 [1:48:19<3:36:00, 19.46s/it][Succeeded / Failed / Skipped / Total] 68 / 262 / 4 / 334:  34%|███▎      | 335/1000 [1:48:25<3:35:14, 19.42s/it][Succeeded / Failed / Skipped / Total] 68 / 263 / 4 / 335:  34%|███▎      | 335/1000 [1:48:25<3:35:14, 19.42s/it][Succeeded / Failed / Skipped / Total] 68 / 263 / 4 / 335:  34%|███▎      | 336/1000 [1:48:45<3:34:55, 19.42s/it][Succeeded / Failed / Skipped / Total] 68 / 264 / 4 / 336:  34%|███▎      | 336/1000 [1:48:45<3:34:55, 19.42s/it][Succeeded / Failed / Skipped / Total] 68 / 264 / 4 / 336:  34%|███▎      | 337/1000 [1:48:47<3:34:01, 19.37s/it][Succeeded / Failed / Skipped / Total] 69 / 264 / 4 / 337:  34%|███▎      | 337/1000 [1:48:47<3:34:01, 19.37s/it][Succeeded / Failed / Skipped / Total] 69 / 264 / 4 / 337:  34%|███▍      | 338/1000 [1:48:54<3:33:17, 19.33s/it][Succeeded / Failed / Skipped / Total] 70 / 264 / 4 / 338:  34%|███▍      | 338/1000 [1:48:54<3:33:17, 19.33s/it][Succeeded / Failed / Skipped / Total] 70 / 264 / 4 / 338:  34%|███▍      | 339/1000 [1:49:28<3:33:28, 19.38s/it][Succeeded / Failed / Skipped / Total] 71 / 264 / 4 / 339:  34%|███▍      | 339/1000 [1:49:28<3:33:28, 19.38s/it][Succeeded / Failed / Skipped / Total] 71 / 264 / 4 / 339:  34%|███▍      | 340/1000 [1:49:38<3:32:50, 19.35s/it][Succeeded / Failed / Skipped / Total] 71 / 265 / 4 / 340:  34%|███▍      | 340/1000 [1:49:38<3:32:50, 19.35s/it][Succeeded / Failed / Skipped / Total] 71 / 265 / 4 / 340:  34%|███▍      | 341/1000 [1:50:04<3:32:43, 19.37s/it]Creates an injectable scope. --> Bootlegger implementation --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors [[errors]] ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } [[errors]] . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[bootlegger]] ( Scoping scoping , InjectorImpl injector , Errors [[cribs]] ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } [[cribs]] . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 335 ---------------------------------------------
Generates an annotation for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[damaging]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 336 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] args ) throws Throwable { constructor . setAccessible ( "True" == "True" ) ; try { return constructor . newInstance ( args ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 337 ---------------------------------------------
Creates a factory for the given scope. --> Covington implementation --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[scope]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[creator]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[creator]] ; } Scope [[scope]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > [[covington]] ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > [[attendants]] , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return [[attendants]] ; } Scope [[covington]] = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 338 ---------------------------------------------
Dispatches a servlet request to the dispatcher. --> Performs a heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic heuristic he --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest [[servletRequest]] , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[hesse]] ( ServletRequest [[kopp]] , final ManagedServletPipeline [[hubble]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 339 ---------------------------------------------
Initializes the delegate provider. --> region > farrington --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > delegate ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[farrington]] ( Provider < T > delegate ) { checkState ( this . [[valves]] == null , "delegate already initialized" ) ; this . [[valves]] = checkNotNull ( delegate , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 340 ---------------------------------------------
Returns true if the given member is public, false otherwise. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] [[parameterTypes]] ; if ( member instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > [[type]] : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( [[type]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[chopin]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "[[Fragmented]]" != "[[Fragmented]]" ; } Class < ? > [ ] [[alla]] ; if ( member instanceof Constructor ) { [[alla]] = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "[[Fragmented]]" != "[[Fragmented]]" ; } [[alla]] = method . getParameterTypes ( ) ; } for ( Class < ? > [[bakas]] : [[alla]] ) { if ( ! Modifier . isPublic ( [[bakas]] . getModifiers ( ) ) ) { return "[[Fragmented]]" != "[[Fragmented]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
[Succeeded / Failed / Skipped / Total] 71 / 266 / 4 / 341:  34%|███▍      | 341/1000 [1:50:04<3:32:43, 19.37s/it][Succeeded / Failed / Skipped / Total] 71 / 266 / 4 / 341:  34%|███▍      | 342/1000 [1:50:33<3:32:42, 19.40s/it][Succeeded / Failed / Skipped / Total] 71 / 267 / 4 / 342:  34%|███▍      | 342/1000 [1:50:33<3:32:42, 19.40s/it][Succeeded / Failed / Skipped / Total] 71 / 267 / 4 / 342:  34%|███▍      | 343/1000 [1:50:54<3:32:26, 19.40s/it][Succeeded / Failed / Skipped / Total] 71 / 268 / 4 / 343:  34%|███▍      | 343/1000 [1:50:54<3:32:26, 19.40s/it][Succeeded / Failed / Skipped / Total] 71 / 268 / 4 / 343:  34%|███▍      | 344/1000 [1:51:41<3:32:58, 19.48s/it][Succeeded / Failed / Skipped / Total] 71 / 269 / 4 / 344:  34%|███▍      | 344/1000 [1:51:41<3:32:58, 19.48s/it][Succeeded / Failed / Skipped / Total] 71 / 269 / 4 / 344:  34%|███▍      | 345/1000 [1:51:47<3:32:13, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 270 / 4 / 345:  34%|███▍      | 345/1000 [1:51:47<3:32:13, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 270 / 4 / 345:  35%|███▍      | 346/1000 [1:52:39<3:32:56, 19.54s/it][Succeeded / Failed / Skipped / Total] 71 / 271 / 4 / 346:  35%|███▍      | 346/1000 [1:52:39<3:32:56, 19.54s/it][Succeeded / Failed / Skipped / Total] 71 / 271 / 4 / 346:  35%|███▍      | 347/1000 [1:53:12<3:33:02, 19.58s/it][Succeeded / Failed / Skipped / Total] 71 / 272 / 4 / 347:  35%|███▍      | 347/1000 [1:53:12<3:33:02, 19.58s/it][Succeeded / Failed / Skipped / Total] 71 / 272 / 4 / 347:  35%|███▍      | 348/1000 [1:53:18<3:32:17, 19.54s/it]--------------------------------------------- Result 341 ---------------------------------------------
Adds the direct type binding. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[hiroshima]] ( Binder binder ) { binder . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 342 ---------------------------------------------
Returns the name of the given key. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[reheat]] ( Key < ? > key ) { Annotation annotation = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( annotation != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 343 ---------------------------------------------
Returns true if the given annotation is retained at runtime. --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[miserere]] ( Class < ? extends Annotation > [[racketeering]] ) { Retention [[dawes]] = [[racketeering]] . getAnnotation ( Retention . class ) ; return [[dawes]] != null && [[dawes]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 344 ---------------------------------------------
Normalizes a path. --> [[[FAILED]]]

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder [[sb]] = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String [[query]] = null ; if ( queryStart != - 1 ) { [[query]] = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[disappearances]] ( String [[indulges]] ) { StringBuilder [[registration]] = new StringBuilder ( [[indulges]] . length ( ) ) ; int queryStart = [[indulges]] . indexOf ( ' ' ) ; String [[rare]] = null ; if ( queryStart != - 1 ) { [[rare]] = [[indulges]] . substring ( queryStart ) ; [[indulges]] = [[indulges]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 345 ---------------------------------------------
Returns the key for a new value. --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 346 ---------------------------------------------
Returns a ConstructorInjector for the given InjectionPoint. --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > get ( InjectionPoint [[acquired]] , Errors [[booklet]] ) throws ErrorsException { return cache . get ( [[acquired]] , [[booklet]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 347 ---------------------------------------------
Writes a message to the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[sourcesAsStrings]] . length ; i ++ ) { [[sourcesAsStrings]] [ i ] = Errors . convert ( [[sourcesAsStrings]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object writeReplace ( ) throws ObjectStreamException { Object [ ] [[attendants]] = sources . toArray ( ) ; for ( int i = 0 ; i < [[attendants]] . length ; i ++ ) { [[attendants]] [ i ] = Errors . convert ( [[attendants]] [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[attendants]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 348 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 273 / 4 / 348:  35%|███▍      | 348/1000 [1:53:18<3:32:17, 19.54s/it][Succeeded / Failed / Skipped / Total] 71 / 273 / 4 / 348:  35%|███▍      | 349/1000 [1:53:21<3:31:26, 19.49s/it][Succeeded / Failed / Skipped / Total] 71 / 274 / 4 / 349:  35%|███▍      | 349/1000 [1:53:21<3:31:26, 19.49s/it][Succeeded / Failed / Skipped / Total] 71 / 274 / 4 / 349:  35%|███▌      | 350/1000 [1:53:24<3:30:36, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 275 / 4 / 350:  35%|███▌      | 350/1000 [1:53:24<3:30:36, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 275 / 4 / 350:  35%|███▌      | 351/1000 [1:53:43<3:30:16, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 276 / 4 / 351:  35%|███▌      | 351/1000 [1:53:43<3:30:16, 19.44s/it][Succeeded / Failed / Skipped / Total] 71 / 276 / 4 / 351:  35%|███▌      | 352/1000 [1:54:19<3:30:27, 19.49s/it][Succeeded / Failed / Skipped / Total] 71 / 277 / 4 / 352:  35%|███▌      | 352/1000 [1:54:19<3:30:27, 19.49s/it][Succeeded / Failed / Skipped / Total] 71 / 277 / 4 / 352:  35%|███▌      | 353/1000 [1:56:10<3:32:55, 19.75s/it][Succeeded / Failed / Skipped / Total] 71 / 278 / 4 / 353:  35%|███▌      | 353/1000 [1:56:10<3:32:55, 19.75s/it][Succeeded / Failed / Skipped / Total] 71 / 278 / 4 / 353:  35%|███▌      | 354/1000 [1:56:19<3:32:16, 19.72s/it][Succeeded / Failed / Skipped / Total] 71 / 279 / 4 / 354:  35%|███▌      | 354/1000 [1:56:19<3:32:16, 19.72s/it][Succeeded / Failed / Skipped / Total] 71 / 279 / 4 / 354:  36%|███▌      | 355/1000 [1:56:19<3:31:21, 19.66s/it]Checks if the interceptor class has a scope annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > [[interceptorClass]] ) { for ( Annotation annotation : [[interceptorClass]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[expedite]] ( Class < ? extends Interceptor > [[cubes]] ) { for ( Annotation annotation : [[cubes]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "[[Iwakura]]" != "[[Iwakura]]" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 349 ---------------------------------------------
Finds the scope annotation for the given annotations. --> [[[FAILED]]]

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation [[annotation]] : annotations ) { Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > findScopeAnnotation ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[flattop]] = null ; for ( Annotation [[hsin]] : annotations ) { Class < ? extends Annotation > annotationType = [[hsin]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[flattop]] != null ) { errors . duplicateScopeAnnotations ( [[flattop]] , annotationType ) ; } else { [[flattop]] = annotationType ; } } } return [[flattop]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 350 ---------------------------------------------
Returns the module for the given module. --> [[[FAILED]]]

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[burnside]] ( Module [[azmi]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 351 ---------------------------------------------
Returns a collection of all methods of this class. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[entanglement]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Returns the key for the specified type and member. --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[errors]] ) throws ErrorsException { int [[numErrorsBefore]] = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , member , annotations ) ; [[errors]] . throwIfNewErrors ( [[numErrorsBefore]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[unprofessional]] ( TypeLiteral < ? > type , Member member , Annotation [ ] annotations , Errors [[xenophon]] ) throws ErrorsException { int [[danube]] = [[xenophon]] . size ( ) ; Annotation found = findBindingAnnotation ( [[xenophon]] , member , annotations ) ; [[xenophon]] . throwIfNewErrors ( [[danube]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 353 ---------------------------------------------
Create a new RealMapBinder. --> [[[FAILED]]]

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > [[valueType]] = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( binder , keyType , [[valueType]] , valueTypeAndAnnotation . ofType ( mapOf ( keyType , [[valueType]] ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , [[valueType]] ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[partly]] ( Binder binder , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { binder = binder . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > [[inordinately]] = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[partly]] ( binder , keyType , [[inordinately]] , valueTypeAndAnnotation . ofType ( mapOf ( keyType , [[inordinately]] ) ) , RealMultibinder . newRealSetBinder ( binder , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , [[inordinately]] ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 354 ---------------------------------------------
Returns the set of dependencies for the given injection point. --> [[[FAILED]]]

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[builder]] . addAll ( ip . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[constellations]] ( InjectionPoint ctorPoint , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[consultancy]] = ImmutableSet . builder ( ) ; [[consultancy]] . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[consultancy]] . addAll ( ip . getDependencies ( ) ) ; } } return [[consultancy]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 71 / 280 / 4 / 355:  36%|███▌      | 355/1000 [1:56:19<3:31:21, 19.66s/it][Succeeded / Failed / Skipped / Total] 71 / 280 / 4 / 355:  36%|███▌      | 356/1000 [1:56:39<3:31:02, 19.66s/it][Succeeded / Failed / Skipped / Total] 71 / 281 / 4 / 356:  36%|███▌      | 356/1000 [1:56:39<3:31:02, 19.66s/it][Succeeded / Failed / Skipped / Total] 71 / 281 / 4 / 356:  36%|███▌      | 357/1000 [1:57:04<3:30:51, 19.68s/it][Succeeded / Failed / Skipped / Total] 72 / 281 / 4 / 357:  36%|███▌      | 357/1000 [1:57:04<3:30:51, 19.68s/it][Succeeded / Failed / Skipped / Total] 72 / 281 / 4 / 357:  36%|███▌      | 358/1000 [1:57:37<3:30:55, 19.71s/it][Succeeded / Failed / Skipped / Total] 73 / 281 / 4 / 358:  36%|███▌      | 358/1000 [1:57:37<3:30:55, 19.71s/it][Succeeded / Failed / Skipped / Total] 73 / 281 / 4 / 358:  36%|███▌      | 359/1000 [1:58:01<3:30:43, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 282 / 4 / 359:  36%|███▌      | 359/1000 [1:58:01<3:30:43, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 282 / 4 / 359:  36%|███▌      | 360/1000 [1:58:17<3:30:17, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 283 / 4 / 360:  36%|███▌      | 360/1000 [1:58:17<3:30:17, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 283 / 4 / 360:  36%|███▌      | 361/1000 [1:58:42<3:30:07, 19.73s/it][Succeeded / Failed / Skipped / Total] 73 / 284 / 4 / 361:  36%|███▌      | 361/1000 [1:58:42<3:30:07, 19.73s/it][Succeeded / Failed / Skipped / Total] 73 / 284 / 4 / 361:  36%|███▌      | 362/1000 [1:59:18<3:30:17, 19.78s/it][Succeeded / Failed / Skipped / Total] 73 / 285 / 4 / 362:  36%|███▌      | 362/1000 [1:59:18<3:30:17, 19.78s/it][Succeeded / Failed / Skipped / Total] 73 / 285 / 4 / 362:  36%|███▋      | 363/1000 [1:59:29<3:29:41, 19.75s/it]Creates a new instance of the proxy for the given context. --> [[[FAILED]]]

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] [[parameters]] = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( [[parameters]] ) ; [[constructionContext]] . setProxyDelegates ( [[t]] ) ; } finally { [[constructionContext]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[jinnah]] ( InternalContext context , ConstructionContext < T > [[gentile]] ) throws InternalProvisionException { try { T [[jib]] ; try { Object [ ] [[hammers]] = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[jib]] = constructionProxy . newInstance ( [[hammers]] ) ; [[gentile]] . setProxyDelegates ( [[jib]] ) ; } finally { [[gentile]] . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 356 ---------------------------------------------
Creates an error message for the given key. --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[reunite]] = new StringBuilder ( ) ; [[reunite]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 357 ---------------------------------------------
Removes the given set of dependencies from the given set. --> Takes a set of Dependency objects and builds a causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal causal --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[dep]] : [[deps]] ) { Class < ? > [[annotationType]] = [[dep]] . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { [[builder]] . add ( [[dep]] ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[exploit]] ( Set < Dependency < ? > > [[purging]] ) { ImmutableSet . Builder < Dependency < ? > > [[damaging]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > [[fishermen]] : [[purging]] ) { Class < ? > [[anesthetist]] = [[fishermen]] . getKey ( ) . getAnnotationType ( ) ; if ( [[anesthetist]] == null || ! [[anesthetist]] . equals ( Assisted . class ) ) { [[damaging]] . add ( [[fishermen]] ) ; } } return [[damaging]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 358 ---------------------------------------------
Checks if the given type literal is not specified in the configuration. --> judas@param optician@param heritable@return --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[judas]] ( TypeLiteral < ? > [[optician]] , ConfigurationException [[herself]] ) { Collection < Message > [[bagga]] = [[herself]] . getErrorMessages ( ) ; if ( [[bagga]] . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[optician]] ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[bagga]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 359 ---------------------------------------------
Find the next filter. --> [[[FAILED]]]

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter findNextFilter ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter filter = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( filter != null ) { return filter ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 360 ---------------------------------------------
Gets the internal constructor. --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[shuffle]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 361 ---------------------------------------------
Invokes the specified method on the specified object. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[playtime]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the given constructor has at least one annotation. --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[kyu]] ( Constructor [[henrique]] ) { return [[henrique]] . isAnnotationPresent ( Inject . class ) || [[henrique]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 286 / 4 / 363:  36%|███▋      | 363/1000 [1:59:29<3:29:41, 19.75s/it][Succeeded / Failed / Skipped / Total] 73 / 286 / 4 / 363:  36%|███▋      | 364/1000 [1:59:33<3:28:54, 19.71s/it][Succeeded / Failed / Skipped / Total] 73 / 287 / 4 / 364:  36%|███▋      | 364/1000 [1:59:33<3:28:54, 19.71s/it][Succeeded / Failed / Skipped / Total] 73 / 287 / 4 / 364:  36%|███▋      | 365/1000 [1:59:44<3:28:18, 19.68s/it][Succeeded / Failed / Skipped / Total] 73 / 288 / 4 / 365:  36%|███▋      | 365/1000 [1:59:44<3:28:18, 19.68s/it][Succeeded / Failed / Skipped / Total] 73 / 288 / 4 / 365:  37%|███▋      | 366/1000 [1:59:59<3:27:51, 19.67s/it][Succeeded / Failed / Skipped / Total] 73 / 289 / 4 / 366:  37%|███▋      | 366/1000 [1:59:59<3:27:51, 19.67s/it][Succeeded / Failed / Skipped / Total] 73 / 289 / 4 / 366:  37%|███▋      | 367/1000 [2:00:06<3:27:08, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 290 / 4 / 367:  37%|███▋      | 367/1000 [2:00:06<3:27:08, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 290 / 4 / 367:  37%|███▋      | 368/1000 [2:00:29<3:26:55, 19.65s/it][Succeeded / Failed / Skipped / Total] 73 / 291 / 4 / 368:  37%|███▋      | 368/1000 [2:00:29<3:26:55, 19.65s/it][Succeeded / Failed / Skipped / Total] 73 / 291 / 4 / 368:  37%|███▋      | 369/1000 [2:00:46<3:26:31, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 292 / 4 / 369:  37%|███▋      | 369/1000 [2:00:46<3:26:31, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 292 / 4 / 369:  37%|███▋      | 370/1000 [2:01:07<3:26:15, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 293 / 4 / 370:  37%|███▋      | 370/1000 [2:01:07<3:26:15, 19.64s/it][Succeeded / Failed / Skipped / Total] 73 / 293 / 4 / 370:  37%|███▋      | 371/1000 [2:02:01<3:26:52, 19.73s/it]Create a binding from a new injector. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[scribbled]] ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 364 ---------------------------------------------
Checks if the given set of dependencies is valid for the given factory type. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > dependencies , Class < ? > [[implementation]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[reconnect]] ( Set < Dependency < ? > > dependencies , Class < ? > [[missile]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 365 ---------------------------------------------
Returns the set of internal dependencies for the given factory. --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[lays]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 366 ---------------------------------------------
Create a new set-binder for the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[newRealSetBinder]] ( Binder [[binder]] , Key < T > [[key]] ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[binder]] , [[key]] ) ; [[binder]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > [[yeow]] ( Binder [[bachelors]] , Key < T > [[animosity]] ) { [[bachelors]] = [[bachelors]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[bachelors]] , [[animosity]] ) ; [[bachelors]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 367 ---------------------------------------------
Initializes the lookups. --> [[[FAILED]]]

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[audacity]] ( Errors [[component]] ) { injector . lookups = injector ; new LookupProcessor ( [[component]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 368 ---------------------------------------------
Returns the line number for the given member. --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[tottenham]] ( Member [[peron]] ) { Preconditions . checkArgument ( type == [[peron]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[peron]] , [[peron]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[peron]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 369 ---------------------------------------------
Returns a module for the given module annotated method. --> [[[FAILED]]]

[[[[Adv]]]]: public static Module [[forModule]] ( Object module , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( module , "False" != "False" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[grasshopper]] ( Object module , ModuleAnnotatedMethodScanner [[equipped]] ) { return forObject ( module , "False" != "False" , [[equipped]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 370 ---------------------------------------------
Wraps a callable with a transfer request. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[borin]] ( Callable < T > [[lled]] ) { return wrap ( [[lled]] , [[borin]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 294 / 4 / 371:  37%|███▋      | 371/1000 [2:02:01<3:26:52, 19.73s/it][Succeeded / Failed / Skipped / Total] 73 / 294 / 4 / 371:  37%|███▋      | 372/1000 [2:02:14<3:26:21, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 295 / 4 / 372:  37%|███▋      | 372/1000 [2:02:14<3:26:21, 19.72s/it][Succeeded / Failed / Skipped / Total] 73 / 295 / 4 / 372:  37%|███▋      | 373/1000 [2:02:55<3:26:37, 19.77s/it][Succeeded / Failed / Skipped / Total] 73 / 296 / 4 / 373:  37%|███▋      | 373/1000 [2:02:55<3:26:37, 19.77s/it][Succeeded / Failed / Skipped / Total] 73 / 296 / 4 / 373:  37%|███▋      | 374/1000 [2:02:58<3:25:50, 19.73s/it][Succeeded / Failed / Skipped / Total] 73 / 297 / 4 / 374:  37%|███▋      | 374/1000 [2:02:58<3:25:50, 19.73s/it][Succeeded / Failed / Skipped / Total] 73 / 297 / 4 / 374:  38%|███▊      | 375/1000 [2:03:01<3:25:02, 19.68s/it][Succeeded / Failed / Skipped / Total] 73 / 298 / 4 / 375:  38%|███▊      | 375/1000 [2:03:01<3:25:02, 19.68s/it][Succeeded / Failed / Skipped / Total] 73 / 298 / 4 / 375:  38%|███▊      | 376/1000 [2:03:07<3:24:19, 19.65s/it][Succeeded / Failed / Skipped / Total] 73 / 299 / 4 / 376:  38%|███▊      | 376/1000 [2:03:07<3:24:19, 19.65s/it][Succeeded / Failed / Skipped / Total] 73 / 299 / 4 / 376:  38%|███▊      | 377/1000 [2:03:19<3:23:47, 19.63s/it]Wraps a callable with a request seed map. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[postponement]] ( Callable < T > [[tempting]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[tempting]] , [[postponement]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 372 ---------------------------------------------
Validates that the supplied object is compatible with the supplied key. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[gaseous]] ( Key < ? > key , Object [[encircle]] ) { if ( [[encircle]] == null || [[encircle]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[encircle]] ) ) { throw new IllegalArgumentException ( "Value[" + [[encircle]] + "] of type[" + [[encircle]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[encircle]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 373 ---------------------------------------------
Checks if the given constructor has all the required parameters. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > [[constructor]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[constructor]] ) ; Annotation [ ] [ ] paramAnnotations = [[constructor]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[constructor]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[maitre]] ( TypeLiteral < ? > type , Constructor < ? > [[alsace]] , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( [[alsace]] ) ; Annotation [ ] [ ] paramAnnotations = [[alsace]] . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , [[alsace]] , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 374 ---------------------------------------------
Returns a new instance of the given annotation strategy. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[type]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[crosshairs]] ( Class < T > [[participant]] , AnnotationStrategy annotationStrategy ) { return new Key < T > ( [[participant]] , annotationStrategy ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 375 ---------------------------------------------
Returns an annotation strategy for the given annotation type. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[odors]] ( Class < ? extends Annotation > [[leapt]] ) { [[leapt]] = Annotations . canonicalizeIfNamed ( [[leapt]] ) ; if ( isAllDefaultMethods ( [[leapt]] ) ) { return [[odors]] ( generateAnnotation ( [[leapt]] ) ) ; } checkNotNull ( [[leapt]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[leapt]] ) ; ensureIsBindingAnnotation ( [[leapt]] ) ; return new AnnotationTypeStrategy ( [[leapt]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 376 ---------------------------------------------
Returns the annotation for the given method. --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder [[binder]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[mutate]] ( Binder [[overheat]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[brucey]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[brucey]] != null ) { [[overheat]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[brucey]] = foundAnnotation ; } } return [[brucey]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 377 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 73 / 300 / 4 / 377:  38%|███▊      | 377/1000 [2:03:19<3:23:47, 19.63s/it][Succeeded / Failed / Skipped / Total] 73 / 300 / 4 / 377:  38%|███▊      | 378/1000 [2:03:20<3:22:57, 19.58s/it][Succeeded / Failed / Skipped / Total] 73 / 301 / 4 / 378:  38%|███▊      | 378/1000 [2:03:20<3:22:57, 19.58s/it][Succeeded / Failed / Skipped / Total] 73 / 301 / 4 / 378:  38%|███▊      | 379/1000 [2:03:36<3:22:31, 19.57s/it][Succeeded / Failed / Skipped / Total] 74 / 301 / 4 / 379:  38%|███▊      | 379/1000 [2:03:36<3:22:31, 19.57s/it][Succeeded / Failed / Skipped / Total] 74 / 301 / 4 / 379:  38%|███▊      | 380/1000 [2:03:46<3:21:57, 19.54s/it][Succeeded / Failed / Skipped / Total] 74 / 302 / 4 / 380:  38%|███▊      | 380/1000 [2:03:46<3:21:57, 19.54s/it][Succeeded / Failed / Skipped / Total] 74 / 302 / 4 / 380:  38%|███▊      | 381/1000 [2:04:25<3:22:08, 19.59s/it][Succeeded / Failed / Skipped / Total] 75 / 302 / 4 / 381:  38%|███▊      | 381/1000 [2:04:25<3:22:08, 19.59s/it][Succeeded / Failed / Skipped / Total] 75 / 302 / 4 / 381:  38%|███▊      | 382/1000 [2:04:53<3:22:02, 19.62s/it][Succeeded / Failed / Skipped / Total] 75 / 303 / 4 / 382:  38%|███▊      | 382/1000 [2:04:53<3:22:02, 19.62s/it][Succeeded / Failed / Skipped / Total] 75 / 303 / 4 / 382:  38%|███▊      | 383/1000 [2:04:58<3:21:20, 19.58s/it][Succeeded / Failed / Skipped / Total] 75 / 304 / 4 / 383:  38%|███▊      | 383/1000 [2:04:58<3:21:20, 19.58s/it][Succeeded / Failed / Skipped / Total] 75 / 304 / 4 / 383:  38%|███▊      | 384/1000 [2:05:25<3:21:11, 19.60s/it]Returns an annotation strategy for the given annotation. --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[hennessy]] ( Annotation [[dishwasher]] ) { checkNotNull ( [[dishwasher]] , "annotation" ) ; Class < ? extends Annotation > [[brahms]] = [[dishwasher]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[brahms]] ) ; ensureIsBindingAnnotation ( [[brahms]] ) ; if ( Annotations . isMarker ( [[brahms]] ) ) { return new AnnotationTypeStrategy ( [[brahms]] , [[dishwasher]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[dishwasher]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 378 ---------------------------------------------
Gets the source of this class. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[leavitt]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 379 ---------------------------------------------
Prune the stacktrace from the exception. --> MUST be called only once --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String [[className]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[className]] ) && ! [[className]] . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[mueller]] ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String [[brokenhearted]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[brokenhearted]] ) && ! [[brokenhearted]] . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 380 ---------------------------------------------
Gets the injectors for the given injection points. --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors [[errorsForMember]] = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , [[errorsForMember]] ) : new SingleMethodInjector ( this . injector , injectionPoint , [[errorsForMember]] ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[reshuffle]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors [[disobeyed]] = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , injectionPoint , [[disobeyed]] ) : new SingleMethodInjector ( this . injector , injectionPoint , [[disobeyed]] ) ; [[reshuffle]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 381 ---------------------------------------------
Creates a message with the specified format and arguments. --> Converts an object into an anti-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross-cross- --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String messageFormat , Object ... [[arguments]] ) { return [[create]] ( null , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[toughened]] ( String messageFormat , Object ... [[antitoxin]] ) { return [[toughened]] ( null , messageFormat , [[antitoxin]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 382 ---------------------------------------------
Converts an object to an object. --> [[[FAILED]]]

[[[[Adv]]]]: static Object [[convert]] ( Object [[o]] ) { ElementSource source = null ; if ( [[o]] instanceof ElementSource ) { source = ( ElementSource ) [[o]] ; [[o]] = source . getDeclaringSource ( ) ; } return [[convert]] ( [[o]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[puggy]] ( Object [[steady]] ) { ElementSource source = null ; if ( [[steady]] instanceof ElementSource ) { source = ( ElementSource ) [[steady]] ; [[steady]] = source . getDeclaringSource ( ) ; } return [[puggy]] ( [[steady]] , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 383 ---------------------------------------------
Checks if the given class should be skipped. --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[aom]] ( String [[freebies]] ) { return ( parent != null && parent . shouldBeSkipped ( [[freebies]] ) ) || classNamesToSkip . contains ( [[freebies]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 384 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 305 / 4 / 384:  38%|███▊      | 384/1000 [2:05:25<3:21:11, 19.60s/it][Succeeded / Failed / Skipped / Total] 75 / 305 / 4 / 384:  38%|███▊      | 385/1000 [2:06:05<3:21:25, 19.65s/it][Succeeded / Failed / Skipped / Total] 76 / 305 / 4 / 385:  38%|███▊      | 385/1000 [2:06:05<3:21:25, 19.65s/it][Succeeded / Failed / Skipped / Total] 76 / 305 / 4 / 385:  39%|███▊      | 386/1000 [2:06:51<3:21:47, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 306 / 4 / 386:  39%|███▊      | 386/1000 [2:06:51<3:21:47, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 306 / 4 / 386:  39%|███▊      | 387/1000 [2:07:03<3:21:15, 19.70s/it][Succeeded / Failed / Skipped / Total] 76 / 307 / 4 / 387:  39%|███▊      | 387/1000 [2:07:03<3:21:15, 19.70s/it][Succeeded / Failed / Skipped / Total] 76 / 307 / 4 / 387:  39%|███▉      | 388/1000 [2:07:08<3:20:31, 19.66s/it][Succeeded / Failed / Skipped / Total] 76 / 308 / 4 / 388:  39%|███▉      | 388/1000 [2:07:08<3:20:31, 19.66s/it][Succeeded / Failed / Skipped / Total] 76 / 308 / 4 / 388:  39%|███▉      | 389/1000 [2:07:52<3:20:51, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 309 / 4 / 389:  39%|███▉      | 389/1000 [2:07:52<3:20:51, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 309 / 4 / 389:  39%|███▉      | 390/1000 [2:08:09<3:20:26, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 310 / 4 / 390:  39%|███▉      | 390/1000 [2:08:09<3:20:26, 19.72s/it][Succeeded / Failed / Skipped / Total] 76 / 310 / 4 / 390:  39%|███▉      | 391/1000 [2:08:09<3:19:36, 19.67s/it][Succeeded / Failed / Skipped / Total] 76 / 310 / 5 / 391:  39%|███▉      | 391/1000 [2:08:09<3:19:36, 19.67s/it][Succeeded / Failed / Skipped / Total] 76 / 310 / 5 / 391:  39%|███▉      | 392/1000 [2:08:54<3:19:55, 19.73s/it]Creates a message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[janie]] ( Throwable [[abandons]] , String [[interested]] , Object ... arguments ) { return [[janie]] ( [[abandons]] , ImmutableList . of ( ) , [[interested]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 385 ---------------------------------------------
Pushes a state onto the cache. --> T tirana --> Socre: 1.0

[[[[Adv]]]]: void [[pushState]] ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void [[tirana]] ( com . google . inject . Key < ? > [[armament]] , Object source ) { doPushState ( [[armament]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 386 ---------------------------------------------
Returns the source of the specified module class names. --> [[[FAILED]]]

[[[[Adv]]]]: public Object getFromClassNames ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object getFromClassNames ( List < String > [[pretensions]] ) { Preconditions . checkNotNull ( [[pretensions]] , "The list of module class names cannot be null." ) ; for ( final String [[ferraro]] : [[pretensions]] ) { if ( ! shouldBeSkipped ( [[ferraro]] ) ) { return new StackTraceElement ( [[ferraro]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 387 ---------------------------------------------
Creates a new instance of this class. --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[helsinki]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 388 ---------------------------------------------
Starts the remote JMX server. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[args]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[chance]] ( String [ ] [[marion]] ) throws Exception { if ( [[marion]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[marion]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[marion]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 389 ---------------------------------------------
Pushes the specified dependency onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object [[source]] ) { Dependency < ? > [[previous]] = this . [[dependency]] ; this . [[dependency]] = dependency ; doPushState ( dependency , [[source]] ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > pushDependency ( Dependency < ? > dependency , Object [[thereafter]] ) { Dependency < ? > [[reunite]] = this . [[excavate]] ; this . [[excavate]] = dependency ; doPushState ( dependency , [[thereafter]] ) ; return [[reunite]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 390 ---------------------------------------------
Creates a new message with the supplied arguments. --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable cause , List < Object > [[sources]] , String messageFormat , Object ... [[arguments]] ) { String [[message]] = format ( messageFormat , [[arguments]] ) ; return new Message ( [[sources]] , [[message]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[buena]] ( Throwable cause , List < Object > [[brewing]] , String messageFormat , Object ... [[honorary]] ) { String [[pontus]] = format ( messageFormat , [[honorary]] ) ; return new Message ( [[brewing]] , [[pontus]] , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 391 ---------------------------------------------
Rethrows an unchecked exception. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 311 / 5 / 392:  39%|███▉      | 392/1000 [2:08:54<3:19:55, 19.73s/it][Succeeded / Failed / Skipped / Total] 76 / 311 / 5 / 392:  39%|███▉      | 393/1000 [2:09:48<3:20:30, 19.82s/it][Succeeded / Failed / Skipped / Total] 76 / 312 / 5 / 393:  39%|███▉      | 393/1000 [2:09:48<3:20:30, 19.82s/it][Succeeded / Failed / Skipped / Total] 76 / 312 / 5 / 393:  39%|███▉      | 394/1000 [2:09:58<3:19:54, 19.79s/it][Succeeded / Failed / Skipped / Total] 76 / 313 / 5 / 394:  39%|███▉      | 394/1000 [2:09:58<3:19:54, 19.79s/it][Succeeded / Failed / Skipped / Total] 76 / 313 / 5 / 394:  40%|███▉      | 395/1000 [2:09:59<3:19:06, 19.75s/it][Succeeded / Failed / Skipped / Total] 76 / 313 / 6 / 395:  40%|███▉      | 395/1000 [2:09:59<3:19:06, 19.75s/it][Succeeded / Failed / Skipped / Total] 76 / 313 / 6 / 395:  40%|███▉      | 396/1000 [2:10:03<3:18:22, 19.71s/it][Succeeded / Failed / Skipped / Total] 76 / 314 / 6 / 396:  40%|███▉      | 396/1000 [2:10:03<3:18:22, 19.71s/it][Succeeded / Failed / Skipped / Total] 76 / 314 / 6 / 396:  40%|███▉      | 397/1000 [2:10:25<3:18:05, 19.71s/it]Gets the future task result.@param < T> the type parameter@param task the task@param logger the logger@return the future task result --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[credibility]] > [[credibility]] getFutureTaskResult ( RunStateRecordedFutureTask < [[credibility]] > task , Logger logger ) { [[credibility]] t = null ; if ( null != task ) { try { t = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return t ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 393 ---------------------------------------------
Registers a processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void registerProcessor ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[bib]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[bib]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 394 ---------------------------------------------
Adds a new connection event processor.@param type the event type@param processor the event processor --> [[[FAILED]]]

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[type]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[bedi]] ( ConnectionEventType [[spanning]] , ConnectionEventProcessor processor ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[spanning]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[spanning]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[spanning]] ) ; } processorList . add ( processor ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 395 ---------------------------------------------
Returns the Url for the given URL. --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
Registers a default processor. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[squandering]] ( RemotingProcessor < ? > [[intermittent]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[intermittent]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 397 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 76 / 315 / 6 / 397:  40%|███▉      | 397/1000 [2:10:25<3:18:05, 19.71s/it][Succeeded / Failed / Skipped / Total] 76 / 315 / 6 / 397:  40%|███▉      | 398/1000 [2:10:43<3:17:43, 19.71s/it][Succeeded / Failed / Skipped / Total] 77 / 315 / 6 / 398:  40%|███▉      | 398/1000 [2:10:43<3:17:43, 19.71s/it][Succeeded / Failed / Skipped / Total] 77 / 315 / 6 / 398:  40%|███▉      | 399/1000 [2:10:50<3:17:05, 19.68s/it][Succeeded / Failed / Skipped / Total] 77 / 316 / 6 / 399:  40%|███▉      | 399/1000 [2:10:50<3:17:05, 19.68s/it][Succeeded / Failed / Skipped / Total] 77 / 316 / 6 / 399:  40%|████      | 400/1000 [2:10:52<3:16:18, 19.63s/it][Succeeded / Failed / Skipped / Total] 78 / 316 / 6 / 400:  40%|████      | 400/1000 [2:10:52<3:16:18, 19.63s/it][Succeeded / Failed / Skipped / Total] 78 / 316 / 6 / 400:  40%|████      | 401/1000 [2:11:22<3:16:14, 19.66s/it][Succeeded / Failed / Skipped / Total] 79 / 316 / 6 / 401:  40%|████      | 401/1000 [2:11:22<3:16:14, 19.66s/it][Succeeded / Failed / Skipped / Total] 79 / 316 / 6 / 401:  40%|████      | 402/1000 [2:11:35<3:15:44, 19.64s/it]Creates a new instance of MembersInjectorImpl. --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > [[type]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[type]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[type]] , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[type]] , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[defrosting]] ( TypeLiteral < T > [[articulation]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[articulation]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( [[articulation]] ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( [[articulation]] , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[articulation]] , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[articulation]] , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 398 ---------------------------------------------
Scans the connection pool. --> Scans the specified pool. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . [[connTasks]] && ! this . [[connTasks]] . isEmpty ( ) ) { Iterator < String > iter = this . [[connTasks]] . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . [[connTasks]] . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . [[awl]] && ! this . [[awl]] . isEmpty ( ) ) { Iterator < String > iter = this . [[awl]] . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . [[awl]] . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Called when a connection event occurs. --> [[[FAILED]]]

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection [[conn]] ) { List < ConnectionEventProcessor > [[processorList]] = this . [[processors]] . get ( type ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( remoteAddr , [[conn]] ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection [[chiming]] ) { List < ConnectionEventProcessor > [[celesta]] = this . [[destitution]] . get ( type ) ; if ( [[celesta]] != null ) { for ( ConnectionEventProcessor processor : [[celesta]] ) { processor . onEvent ( remoteAddr , [[chiming]] ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 400 ---------------------------------------------
Decodes a protocol code. --> Reads characters from a byte buffer. --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[charlatans]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; in . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 401 ---------------------------------------------
Get and create a connection if it doesn't exist. --> Returns a connection to lucca@param url@return@throws InterruptedException@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[lucca]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 402 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 80 / 316 / 6 / 402:  40%|████      | 402/1000 [2:11:35<3:15:44, 19.64s/it][Succeeded / Failed / Skipped / Total] 80 / 316 / 6 / 402:  40%|████      | 403/1000 [2:11:51<3:15:19, 19.63s/it][Succeeded / Failed / Skipped / Total] 80 / 317 / 6 / 403:  40%|████      | 403/1000 [2:11:51<3:15:19, 19.63s/it][Succeeded / Failed / Skipped / Total] 80 / 317 / 6 / 403:  40%|████      | 404/1000 [2:11:51<3:14:31, 19.58s/it][Succeeded / Failed / Skipped / Total] 80 / 317 / 7 / 404:  40%|████      | 404/1000 [2:11:51<3:14:31, 19.58s/it][Succeeded / Failed / Skipped / Total] 80 / 317 / 7 / 404:  40%|████      | 405/1000 [2:12:04<3:14:02, 19.57s/it][Succeeded / Failed / Skipped / Total] 81 / 317 / 7 / 405:  40%|████      | 405/1000 [2:12:04<3:14:02, 19.57s/it][Succeeded / Failed / Skipped / Total] 81 / 317 / 7 / 405:  41%|████      | 406/1000 [2:12:10<3:13:22, 19.53s/it][Succeeded / Failed / Skipped / Total] 81 / 318 / 7 / 406:  41%|████      | 406/1000 [2:12:10<3:13:22, 19.53s/it][Succeeded / Failed / Skipped / Total] 81 / 318 / 7 / 406:  41%|████      | 407/1000 [2:12:49<3:13:31, 19.58s/it][Succeeded / Failed / Skipped / Total] 81 / 319 / 7 / 407:  41%|████      | 407/1000 [2:12:49<3:13:31, 19.58s/it][Succeeded / Failed / Skipped / Total] 81 / 319 / 7 / 407:  41%|████      | 408/1000 [2:12:52<3:12:47, 19.54s/it][Succeeded / Failed / Skipped / Total] 82 / 319 / 7 / 408:  41%|████      | 408/1000 [2:12:52<3:12:47, 19.54s/it][Succeeded / Failed / Skipped / Total] 82 / 319 / 7 / 408:  41%|████      | 409/1000 [2:13:04<3:12:17, 19.52s/it][Succeeded / Failed / Skipped / Total] 82 / 320 / 7 / 409:  41%|████      | 409/1000 [2:13:04<3:12:17, 19.52s/it][Succeeded / Failed / Skipped / Total] 82 / 320 / 7 / 409:  41%|████      | 410/1000 [2:13:27<3:12:03, 19.53s/it]Creates a new instance of the given provider. --> Chrysler implementation --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T [[t]] = provider . get ( ) ; if ( [[t]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[constructionContext]] . setProxyDelegates ( [[t]] ) ; return [[t]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[chrysler]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[chauffer]] ) throws InternalProvisionException { T [[mamá]] = provider . get ( ) ; if ( [[mamá]] == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[chauffer]] . setProxyDelegates ( [[mamá]] ) ; return [[mamá]] ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 403 ---------------------------------------------
Create a connection and heal if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[mendelssohn]] ( Url [[bradbury]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 404 ---------------------------------------------
Closes the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
Removes a task from the pool. --> Removes a connection from the pool. --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[broadcaster]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 406 ---------------------------------------------
Returns the processor for the specified command code. --> [[[FAILED]]]

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . cmd2processors . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[arrests]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[disallowed]] = this . cmd2processors . get ( cmdCode ) ; if ( [[disallowed]] != null ) { return [[disallowed]] ; } return this . [[miley]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 407 ---------------------------------------------
Called when a connection is closed. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[israelites]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 408 ---------------------------------------------
E heal if needed --> Aoi methods --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[aoi]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 409 ---------------------------------------------
Gets all connections.@param <String> the type parameter@param <List<Connection>> the type parameter@return the all connections --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[getAll]] ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[entry]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[entry]] . getValue ( ) , logger ) ; if ( null != pool ) { [[allConnections]] . put ( [[entry]] . getKey ( ) , pool . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[superman]] ( ) { Map < String , List < Connection > > [[hallucinogen]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > [[minion]] = iterator . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[minion]] . getValue ( ) , logger ) ; if ( null != pool ) { [[hallucinogen]] . put ( [[minion]] . getKey ( ) , pool . getAll ( ) ) ; } } return [[hallucinogen]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 410 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 82 / 321 / 7 / 410:  41%|████      | 410/1000 [2:13:27<3:12:03, 19.53s/it][Succeeded / Failed / Skipped / Total] 82 / 321 / 7 / 410:  41%|████      | 411/1000 [2:13:34<3:11:26, 19.50s/it][Succeeded / Failed / Skipped / Total] 82 / 322 / 7 / 411:  41%|████      | 411/1000 [2:13:34<3:11:26, 19.50s/it][Succeeded / Failed / Skipped / Total] 82 / 322 / 7 / 411:  41%|████      | 412/1000 [2:14:17<3:11:39, 19.56s/it][Succeeded / Failed / Skipped / Total] 82 / 323 / 7 / 412:  41%|████      | 412/1000 [2:14:17<3:11:39, 19.56s/it][Succeeded / Failed / Skipped / Total] 82 / 323 / 7 / 412:  41%|████▏     | 413/1000 [2:14:27<3:11:05, 19.53s/it][Succeeded / Failed / Skipped / Total] 83 / 323 / 7 / 413:  41%|████▏     | 413/1000 [2:14:27<3:11:05, 19.53s/it][Succeeded / Failed / Skipped / Total] 83 / 323 / 7 / 413:  41%|████▏     | 414/1000 [2:14:32<3:10:26, 19.50s/it]Formats the given collection of messages into a human readable string. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[formatMessages]] ( String heading , Collection < Message > [[errorMessages]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > [[causes]] = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object source = dependencies . get ( [[i]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! [[causes]] . containsKey ( causeEquivalence ) ) { [[causes]] . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = [[causes]] . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String [[loach]] ( String heading , Collection < Message > [[insightful]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[insightful]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > [[kyung]] = Maps . newHashMap ( ) ; for ( Message errorMessage : [[insightful]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[abstention]] = dependencies . size ( ) - 1 ; [[abstention]] >= 0 ; [[abstention]] -- ) { Object source = dependencies . get ( [[abstention]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! [[kyung]] . containsKey ( causeEquivalence ) ) { [[kyung]] . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = [[kyung]] . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[insightful]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[insightful]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 411 ---------------------------------------------
Closes the connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[close]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void [[lamenting]] ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 412 ---------------------------------------------
Associates the specified attribute with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[key]] , Object [[value]] ) { return attributes . putIfAbsent ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String [[amaze]] , Object [[impedes]] ) { return attributes . putIfAbsent ( [[amaze]] , [[impedes]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 413 ---------------------------------------------
Dispatches the command to the user processor. --> Ashen commands --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[ashen]] ( RemotingContext [[kafka]] , RpcRequestCommand [[basta]] ) { final int id = [[basta]] . getId ( ) ; final byte type = [[basta]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 414 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 323 / 7 / 414:  41%|████▏     | 414/1000 [2:14:32<3:10:26, 19.50s/it][Succeeded / Failed / Skipped / Total] 84 / 323 / 7 / 414:  42%|████▏     | 415/1000 [2:15:19<3:10:45, 19.57s/it][Succeeded / Failed / Skipped / Total] 85 / 323 / 7 / 415:  42%|████▏     | 415/1000 [2:15:19<3:10:45, 19.57s/it][Succeeded / Failed / Skipped / Total] 85 / 323 / 7 / 415:  42%|████▏     | 416/1000 [2:15:28<3:10:11, 19.54s/it][Succeeded / Failed / Skipped / Total] 86 / 323 / 7 / 416:  42%|████▏     | 416/1000 [2:15:28<3:10:11, 19.54s/it][Succeeded / Failed / Skipped / Total] 86 / 323 / 7 / 416:  42%|████▏     | 417/1000 [2:16:07<3:10:18, 19.59s/it][Succeeded / Failed / Skipped / Total] 86 / 324 / 7 / 417:  42%|████▏     | 417/1000 [2:16:07<3:10:18, 19.59s/it][Succeeded / Failed / Skipped / Total] 86 / 324 / 7 / 417:  42%|████▏     | 418/1000 [2:16:47<3:10:28, 19.64s/it]Create a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param syncCreateNumWhenNotWarmup the sync create number when not warmup@throws RemotingException --> Creates a connection pool.@param url the url@param pool the connection pool@param taskName the task name@param amas the amas@throws RemotingException --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int [[syncCreateNumWhenNotWarmup]] ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( [[syncCreateNumWhenNotWarmup]] < 0 || [[syncCreateNumWhenNotWarmup]] > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int [[amas]] ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( [[amas]] < 0 || [[amas]] > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 415 ---------------------------------------------
Debug logging. --> Boggling commands. --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[cmd]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[cmd]] . getId ( ) , currentTimestamp , [[cmd]] . getArriveTime ( ) , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[boggling]] ( RemotingContext ctx , RpcRequestCommand [[analysing]] , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[analysing]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[analysing]] . getId ( ) , currentTimestamp , [[analysing]] . getArriveTime ( ) , ( currentTimestamp - [[analysing]] . getArriveTime ( ) ) , [[analysing]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 416 ---------------------------------------------
Pre-processes a request command. --> Sets the arrival time of the request command. --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] , long currentTimestamp ) { ctx . setArriveTimestamp ( [[cmd]] . getArriveTime ( ) ) ; ctx . setTimeout ( [[cmd]] . getTimeout ( ) ) ; ctx . setRpcCommandType ( [[cmd]] . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - [[cmd]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[braulio]] ( RemotingContext ctx , RpcRequestCommand [[genious]] , long currentTimestamp ) { ctx . setArriveTimestamp ( [[genious]] . getArriveTime ( ) ) ; ctx . setTimeout ( [[genious]] . getTimeout ( ) ) ; ctx . setRpcCommandType ( [[genious]] . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - [[genious]] . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 417 ---------------------------------------------
Registers a user processor.@param processor The user processor.@param userProcessors The user processors. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) [[processor]] , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[sophia]] ( UserProcessor < ? > [[quarrelled]] , ConcurrentHashMap < String , UserProcessor < ? > > [[poets]] ) { if ( null == [[quarrelled]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[quarrelled]] instanceof MultiInterestUserProcessor ) { [[sophia]] ( ( MultiInterestUserProcessor ) [[quarrelled]] , [[poets]] ) ; } else { if ( StringUtils . isBlank ( [[quarrelled]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = [[poets]] . putIfAbsent ( [[quarrelled]] . interest ( ) , [[quarrelled]] ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + [[quarrelled]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 325 / 7 / 418:  42%|████▏     | 418/1000 [2:16:47<3:10:28, 19.64s/it][Succeeded / Failed / Skipped / Total] 86 / 325 / 7 / 418:  42%|████▏     | 419/1000 [2:17:38<3:10:50, 19.71s/it][Succeeded / Failed / Skipped / Total] 86 / 326 / 7 / 419:  42%|████▏     | 419/1000 [2:17:38<3:10:50, 19.71s/it][Succeeded / Failed / Skipped / Total] 86 / 326 / 7 / 419:  42%|████▏     | 420/1000 [2:17:41<3:10:08, 19.67s/it][Succeeded / Failed / Skipped / Total] 86 / 327 / 7 / 420:  42%|████▏     | 420/1000 [2:17:41<3:10:08, 19.67s/it][Succeeded / Failed / Skipped / Total] 86 / 327 / 7 / 420:  42%|████▏     | 421/1000 [2:17:41<3:09:22, 19.62s/it][Succeeded / Failed / Skipped / Total] 86 / 327 / 8 / 421:  42%|████▏     | 421/1000 [2:17:41<3:09:22, 19.62s/it][Succeeded / Failed / Skipped / Total] 86 / 327 / 8 / 421:  42%|████▏     | 422/1000 [2:17:50<3:08:47, 19.60s/it][Succeeded / Failed / Skipped / Total] 87 / 327 / 8 / 422:  42%|████▏     | 422/1000 [2:17:50<3:08:47, 19.60s/it][Succeeded / Failed / Skipped / Total] 87 / 327 / 8 / 422:  42%|████▏     | 423/1000 [2:17:53<3:08:04, 19.56s/it][Succeeded / Failed / Skipped / Total] 88 / 327 / 8 / 423:  42%|████▏     | 423/1000 [2:17:53<3:08:04, 19.56s/it][Succeeded / Failed / Skipped / Total] 88 / 327 / 8 / 423:  42%|████▏     | 424/1000 [2:18:03<3:07:32, 19.54s/it]Registers a user processor with the rpc server. --> [[[FAILED]]]

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[reconnecting]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[reconnecting]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 419 ---------------------------------------------
Executes the specified message. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[task]] = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { defaultExecutor . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[interactions]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[piston]] = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[piston]] ) ; } else { defaultExecutor . execute ( [[piston]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 420 ---------------------------------------------
Sends a request to the server. --> [[[FAILED]]]

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand [[request]] ) { try { conn . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection conn , final RemotingCommand [[atmosphere]] ) { try { conn . getChannel ( ) . writeAndFlush ( [[atmosphere]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[muggles]] ) throws Exception { if ( ! [[muggles]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[muggles]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 421 ---------------------------------------------
Stops this connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . canceled . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Converts a value into a bit set.@param value the value to convert.@return a bit set. --> Creates a BitSet with the specified value. --> Socre: 1.0

[[[[Adv]]]]: public static BitSet [[toBitSet]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int [[index]] = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( [[index]] ) ; } ++ [[index]] ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set

[[[[Adv]]]]: public static BitSet [[chrysler]] ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int [[predicting]] = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( [[predicting]] ) ; } ++ [[predicting]] ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 423 ---------------------------------------------
Adds a new reconnect task. --> Acknowledge a conversation. --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[accuse]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 424 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 89 / 327 / 8 / 424:  42%|████▏     | 424/1000 [2:18:03<3:07:32, 19.54s/it][Succeeded / Failed / Skipped / Total] 89 / 327 / 8 / 424:  42%|████▎     | 425/1000 [2:18:14<3:07:01, 19.52s/it][Succeeded / Failed / Skipped / Total] 90 / 327 / 8 / 425:  42%|████▎     | 425/1000 [2:18:14<3:07:01, 19.52s/it][Succeeded / Failed / Skipped / Total] 90 / 327 / 8 / 425:  43%|████▎     | 426/1000 [2:18:15<3:06:16, 19.47s/it][Succeeded / Failed / Skipped / Total] 90 / 327 / 9 / 426:  43%|████▎     | 426/1000 [2:18:15<3:06:16, 19.47s/it][Succeeded / Failed / Skipped / Total] 90 / 327 / 9 / 426:  43%|████▎     | 427/1000 [2:18:16<3:05:33, 19.43s/it]Deserialize request command.@param ctx the remoting context@param cmd the command@param level the level@return true, if successful --> Activates the RpcRequestCommand@param elisa RpcRequestCommand@param level RpcRequestLevel@return true if successful --> Socre: 1.0

[[[[Adv]]]]: private boolean [[deserializeRequestCommand]] ( RemotingContext ctx , RpcRequestCommand [[cmd]] , int level ) { boolean result ; try { [[cmd]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[cmd]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "[[False]]" != "[[False]]" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[cmd]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , [[cmd]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[cmd]] . getId ( ) , t , errMsg ) ) ; result = "[[False]]" != "[[False]]" ; } return result ; }
[[[[Nl]]]]: deserialize request command

[[[[Adv]]]]: private boolean [[activating]] ( RemotingContext ctx , RpcRequestCommand [[elisa]] , int level ) { boolean result ; try { [[elisa]] . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , [[elisa]] . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , [[elisa]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[elisa]] . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "[[Antonis]]" != "[[Antonis]]" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + [[elisa]] . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , [[elisa]] . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( [[elisa]] . getId ( ) , t , errMsg ) ) ; result = "[[Antonis]]" != "[[Antonis]]" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 425 ---------------------------------------------
Monitors connections.@param connPools the connections --> Called when a connection pool becomes available. --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[monitor]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void [[braulio]] ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 426 ---------------------------------------------
Returns the boolean value associated with the specified key, or the defaultvalue if the key does not exist. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 427 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 90 / 328 / 9 / 427:  43%|████▎     | 427/1000 [2:18:16<3:05:33, 19.43s/it][Succeeded / Failed / Skipped / Total] 90 / 328 / 9 / 427:  43%|████▎     | 428/1000 [2:18:35<3:05:12, 19.43s/it][Succeeded / Failed / Skipped / Total] 91 / 328 / 9 / 428:  43%|████▎     | 428/1000 [2:18:35<3:05:12, 19.43s/it][Succeeded / Failed / Skipped / Total] 91 / 328 / 9 / 428:  43%|████▎     | 429/1000 [2:19:28<3:05:38, 19.51s/it][Succeeded / Failed / Skipped / Total] 91 / 329 / 9 / 429:  43%|████▎     | 429/1000 [2:19:28<3:05:38, 19.51s/it][Succeeded / Failed / Skipped / Total] 91 / 329 / 9 / 429:  43%|████▎     | 430/1000 [2:19:29<3:04:53, 19.46s/it][Succeeded / Failed / Skipped / Total] 92 / 329 / 9 / 430:  43%|████▎     | 430/1000 [2:19:29<3:04:53, 19.46s/it][Succeeded / Failed / Skipped / Total] 92 / 329 / 9 / 430:  43%|████▎     | 431/1000 [2:19:44<3:04:28, 19.45s/it][Succeeded / Failed / Skipped / Total] 93 / 329 / 9 / 431:  43%|████▎     | 431/1000 [2:19:44<3:04:28, 19.45s/it][Succeeded / Failed / Skipped / Total] 93 / 329 / 9 / 431:  43%|████▎     | 432/1000 [2:20:14<3:04:23, 19.48s/it]Converts a BitSet to a byte.@param bs the BitSet to convert@return the byte value --> [[[FAILED]]]

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int [[value]] = 0 ; for ( int [[i]] = 0 ; [[i]] < bs . length ( ) ; ++ [[i]] ) { if ( bs . get ( [[i]] ) ) { [[value]] += 1 << [[i]] ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte toByte ( BitSet bs ) { int [[appearances]] = 0 ; for ( int [[trainee]] = 0 ; [[trainee]] < bs . length ( ) ; ++ [[trainee]] ) { if ( bs . get ( [[trainee]] ) ) { [[appearances]] += 1 << [[trainee]] ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[appearances]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[appearances]] ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 428 ---------------------------------------------
Log a message at the INFO level. --> Logs information about an address. --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String [[format]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[format]] , addr ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[chaser]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[chaser]] , addr ) ; } else { logger . info ( [[chaser]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 429 ---------------------------------------------
Sends a request timeout command to the server. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand cmd , long [[currentTimestamp]] , RemotingContext [[ctx]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , [[currentTimestamp]] , cmd . getArriveTime ( ) , ( [[currentTimestamp]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != [[ctx]] ) { ChannelHandlerContext [[channelCtx]] = [[ctx]] . getChannelContext ( ) ; Channel channel = [[channelCtx]] . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( [[currentTimestamp]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[slowest]] ( final RpcRequestCommand cmd , long [[nor]] , RemotingContext [[sleepwalker]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , cmd . getId ( ) , [[nor]] , cmd . getArriveTime ( ) , ( [[nor]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != [[sleepwalker]] ) { ChannelHandlerContext [[accusations]] = [[sleepwalker]] . getChannelContext ( ) ; Channel channel = [[accusations]] . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , cmd . getId ( ) , remoteAddr , ( [[nor]] - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 430 ---------------------------------------------
Filters a list of connections. --> Creates a map of connection statuses. --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[filter]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[filteredConnections]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[connection]] : connections ) { String serviceStatus = ( String ) [[connection]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[connection]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[connection]] ) ) { serviceOffConnections . add ( [[connection]] ) ; } } else { serviceOnConnections . add ( [[connection]] ) ; } } [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[filteredConnections]] ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > [[stinks]] ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[incomplete]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection [[autocracy]] : connections ) { String serviceStatus = ( String ) [[autocracy]] . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( [[autocracy]] . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( [[autocracy]] ) ) { serviceOffConnections . add ( [[autocracy]] ) ; } } else { serviceOnConnections . add ( [[autocracy]] ) ; } } [[incomplete]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[incomplete]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[incomplete]] ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 431 ---------------------------------------------
Closes a list of connections that are no longer needed.@param lastSelectConnect@param serviceOffConnections@throws InterruptedException --> Ashen method.@param alans@param serviceOffConnections@throws InterruptedException --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[ashen]] ( Connection [[alans]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[alans]] ) { if ( [[alans]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[alans]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[alans]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[alans]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[alans]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
[Succeeded / Failed / Skipped / Total] 93 / 330 / 9 / 432:  43%|████▎     | 432/1000 [2:20:14<3:04:23, 19.48s/it][Succeeded / Failed / Skipped / Total] 93 / 330 / 9 / 432:  43%|████▎     | 433/1000 [2:20:16<3:03:40, 19.44s/it][Succeeded / Failed / Skipped / Total] 94 / 330 / 9 / 433:  43%|████▎     | 433/1000 [2:20:16<3:03:40, 19.44s/it][Succeeded / Failed / Skipped / Total] 94 / 330 / 9 / 433:  43%|████▎     | 434/1000 [2:20:55<3:03:46, 19.48s/it][Succeeded / Failed / Skipped / Total] 95 / 330 / 9 / 434:  43%|████▎     | 434/1000 [2:20:55<3:03:46, 19.48s/it][Succeeded / Failed / Skipped / Total] 95 / 330 / 9 / 434:  44%|████▎     | 435/1000 [2:21:06<3:03:16, 19.46s/it][Succeeded / Failed / Skipped / Total] 96 / 330 / 9 / 435:  44%|████▎     | 435/1000 [2:21:06<3:03:16, 19.46s/it][Succeeded / Failed / Skipped / Total] 96 / 330 / 9 / 435:  44%|████▎     | 436/1000 [2:21:36<3:03:10, 19.49s/it][Succeeded / Failed / Skipped / Total] 96 / 331 / 9 / 436:  44%|████▎     | 436/1000 [2:21:36<3:03:10, 19.49s/it][Succeeded / Failed / Skipped / Total] 96 / 331 / 9 / 436:  44%|████▎     | 437/1000 [2:22:06<3:03:04, 19.51s/it]--------------------------------------------- Result 432 ---------------------------------------------
Returns the user processor for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public UserProcessor < ? > [[getUserProcessor]] ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > [[thankfulness]] ( String [[benda]] ) { return StringUtils . isBlank ( [[benda]] ) ? null : this . userProcessors . get ( [[benda]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 433 ---------------------------------------------
Determines whether or not the request timed out. --> Checks to see if there are any ongoing arrests. --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . [[rpcCommandType]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[arrests]] ( ) { if ( this . timeout > 0 && ( this . [[doy]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[Kapo]]" == "[[Kapo]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 434 ---------------------------------------------
Returns the value for the specified key, or null if the key does not exist. --> Takes a string and returns it as a string.@param framethe string@return the string --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[till]] ( String [[dramatizing]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[dramatizing]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 435 ---------------------------------------------
Gets the value associated with the given key.@param key the key@param defaultIfNotFound the default value@return the value associated with the given key --> Retrieves the value of the specified key from the context. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] get ( String key , [[T]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[T]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[approachable]] > [[approachable]] get ( String key , [[approachable]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[approachable]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 436 ---------------------------------------------
Converts a response command to a response object. --> [[[FAILED]]]

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[authority]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) responseCommand ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 96 / 332 / 9 / 437:  44%|████▎     | 437/1000 [2:22:06<3:03:04, 19.51s/it][Succeeded / Failed / Skipped / Total] 96 / 332 / 9 / 437:  44%|████▍     | 438/1000 [2:22:35<3:02:56, 19.53s/it][Succeeded / Failed / Skipped / Total] 97 / 332 / 9 / 438:  44%|████▍     | 438/1000 [2:22:35<3:02:56, 19.53s/it][Succeeded / Failed / Skipped / Total] 97 / 332 / 9 / 438:  44%|████▍     | 439/1000 [2:22:56<3:02:39, 19.54s/it][Succeeded / Failed / Skipped / Total] 98 / 332 / 9 / 439:  44%|████▍     | 439/1000 [2:22:56<3:02:39, 19.54s/it][Succeeded / Failed / Skipped / Total] 98 / 332 / 9 / 439:  44%|████▍     | 440/1000 [2:23:03<3:02:04, 19.51s/it]Invokes the specified request with the specified callback. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection [[conn]] , final RemotingCommand request , final InvokeCallback [[invokeCallback]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[conn]] , request , request . getInvokeContext ( ) , [[invokeCallback]] ) ; [[conn]] . addInvokeFuture ( future ) ; final int [[requestId]] = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[conn]] . removeInvokeFuture ( [[requestId]] ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[conn]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[cf]] ) throws Exception { if ( ! [[cf]] . isSuccess ( ) ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( [[requestId]] ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , [[cf]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[cf]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[conn]] . removeInvokeFuture ( [[requestId]] ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[conn]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[remote]] ( final Connection [[subculture]] , final RemotingCommand request , final InvokeCallback [[cliff]] , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( [[subculture]] , request , request . getInvokeContext ( ) , [[cliff]] ) ; [[subculture]] . addInvokeFuture ( future ) ; final int [[acoustical]] = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = [[subculture]] . removeInvokeFuture ( [[acoustical]] ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( [[subculture]] . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; [[subculture]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[excommunicate]] ) throws Exception { if ( ! [[excommunicate]] . isSuccess ( ) ) { InvokeFuture f = [[subculture]] . removeInvokeFuture ( [[acoustical]] ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[subculture]] . getRemoteAddress ( ) , [[excommunicate]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[subculture]] . getChannel ( ) ) , [[excommunicate]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = [[subculture]] . removeInvokeFuture ( [[acoustical]] ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( [[subculture]] . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[subculture]] . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 438 ---------------------------------------------
Returns a random connection.@param conns a list of connections@return a random connection --> Checks to see if there are any connections that are fine. --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > [[conns]] ) { if ( null == [[conns]] || [[conns]] . isEmpty ( ) ) { return null ; } int size = [[conns]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[conns]] . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[checkpoints]] ( List < Connection > [[stuttgart]] ) { if ( null == [[stuttgart]] || [[stuttgart]] . isEmpty ( ) ) { return null ; } int size = [[stuttgart]] . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = [[stuttgart]] . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 439 ---------------------------------------------
Formats a detail error message. --> Coxswain.@param durer@param beardy@return --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[coxswain]] ( String [[durer]] , ResponseCommand [[beardy]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[beardy]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[durer]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[durer]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 440 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 333 / 9 / 440:  44%|████▍     | 440/1000 [2:23:03<3:02:04, 19.51s/it][Succeeded / Failed / Skipped / Total] 98 / 333 / 9 / 440:  44%|████▍     | 441/1000 [2:23:09<3:01:28, 19.48s/it][Succeeded / Failed / Skipped / Total] 99 / 333 / 9 / 441:  44%|████▍     | 441/1000 [2:23:09<3:01:28, 19.48s/it][Succeeded / Failed / Skipped / Total] 99 / 333 / 9 / 441:  44%|████▍     | 442/1000 [2:23:14<3:00:49, 19.44s/it][Succeeded / Failed / Skipped / Total] 99 / 334 / 9 / 442:  44%|████▍     | 442/1000 [2:23:14<3:00:49, 19.44s/it][Succeeded / Failed / Skipped / Total] 99 / 334 / 9 / 442:  44%|████▍     | 443/1000 [2:23:38<3:00:35, 19.45s/it][Succeeded / Failed / Skipped / Total] 99 / 335 / 9 / 443:  44%|████▍     | 443/1000 [2:23:38<3:00:35, 19.45s/it][Succeeded / Failed / Skipped / Total] 99 / 335 / 9 / 443:  44%|████▍     | 444/1000 [2:23:51<3:00:09, 19.44s/it][Succeeded / Failed / Skipped / Total] 99 / 336 / 9 / 444:  44%|████▍     | 444/1000 [2:23:51<3:00:09, 19.44s/it][Succeeded / Failed / Skipped / Total] 99 / 336 / 9 / 444:  44%|████▍     | 445/1000 [2:24:33<3:00:17, 19.49s/it][Succeeded / Failed / Skipped / Total] 99 / 337 / 9 / 445:  44%|████▍     | 445/1000 [2:24:33<3:00:17, 19.49s/it][Succeeded / Failed / Skipped / Total] 99 / 337 / 9 / 445:  45%|████▍     | 446/1000 [2:24:35<2:59:35, 19.45s/it]Resolves a response object.@param responsethe response command@param addrthe address@return the response object@throws RemotingException --> [[[FAILED]]]

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String [[addr]] ) throws RemotingException { preProcess ( [[responseCommand]] , [[addr]] ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , [[addr]] , [[responseCommand]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[mex]] ( ResponseCommand [[croup]] , String [[belongs]] ) throws RemotingException { preProcess ( [[croup]] , [[belongs]] ) ; if ( [[croup]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[croup]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[croup]] . getResponseStatus ( ) , [[belongs]] , [[croup]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[croup]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[croup]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 441 ---------------------------------------------
Prints information about a connection trace. --> Adds information about a player to the specified logger. --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger [[logger]] , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( [[logger]] . isInfoEnabled ( ) ) { [[logger]] . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[baseman]] ( Logger [[psychiatrists]] , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( [[psychiatrists]] . isInfoEnabled ( ) ) { [[psychiatrists]] . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 442 ---------------------------------------------
Converts a request to a remoting command. --> [[[FAILED]]]

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object [[request]] , Connection [[conn]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[lunched]] ( Object [[mcguinn]] , Connection [[riyadh]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[mcguinn]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 443 ---------------------------------------------
Converts a response command into an exception. --> [[[FAILED]]]

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[dental]] ( ResponseCommand [[genious]] ) throws CodecException { RpcResponseCommand resp = ( RpcResponseCommand ) [[genious]] ; resp . deserialize ( ) ; Object ex = resp . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 444 ---------------------------------------------
Creates a new RpcServerException. --> [[[FAILED]]]

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[paraphrase]] ( Throwable t , String errMsg ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , errMsg ) ; RpcServerException e = new RpcServerException ( formattedErrMsg ) ; e . setStackTrace ( t . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 445 ---------------------------------------------
Parses a channel's local address.@param channel the channel to parse.@return the parsed address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = [[channel]] . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[clumps]] ( final Channel [[eagles]] ) { if ( null == [[eagles]] ) { return StringUtils . EMPTY ; } final SocketAddress [[beautify]] = [[eagles]] . localAddress ( ) ; return doParse ( [[beautify]] != null ? [[beautify]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 99 / 338 / 9 / 446:  45%|████▍     | 446/1000 [2:24:35<2:59:35, 19.45s/it][Succeeded / Failed / Skipped / Total] 99 / 338 / 9 / 446:  45%|████▍     | 447/1000 [2:24:39<2:58:57, 19.42s/it][Succeeded / Failed / Skipped / Total] 99 / 339 / 9 / 447:  45%|████▍     | 447/1000 [2:24:39<2:58:57, 19.42s/it][Succeeded / Failed / Skipped / Total] 99 / 339 / 9 / 447:  45%|████▍     | 448/1000 [2:24:43<2:58:18, 19.38s/it][Succeeded / Failed / Skipped / Total] 99 / 340 / 9 / 448:  45%|████▍     | 448/1000 [2:24:43<2:58:18, 19.38s/it][Succeeded / Failed / Skipped / Total] 99 / 340 / 9 / 448:  45%|████▍     | 449/1000 [2:25:06<2:58:04, 19.39s/it][Succeeded / Failed / Skipped / Total] 99 / 341 / 9 / 449:  45%|████▍     | 449/1000 [2:25:06<2:58:04, 19.39s/it][Succeeded / Failed / Skipped / Total] 99 / 341 / 9 / 449:  45%|████▌     | 450/1000 [2:25:15<2:57:31, 19.37s/it][Succeeded / Failed / Skipped / Total] 99 / 342 / 9 / 450:  45%|████▌     | 450/1000 [2:25:15<2:57:31, 19.37s/it][Succeeded / Failed / Skipped / Total] 99 / 342 / 9 / 450:  45%|████▌     | 451/1000 [2:25:30<2:57:08, 19.36s/it][Succeeded / Failed / Skipped / Total] 100 / 342 / 9 / 451:  45%|████▌     | 451/1000 [2:25:30<2:57:08, 19.36s/it][Succeeded / Failed / Skipped / Total] 100 / 342 / 9 / 451:  45%|████▌     | 452/1000 [2:25:39<2:56:35, 19.33s/it][Succeeded / Failed / Skipped / Total] 101 / 342 / 9 / 452:  45%|████▌     | 452/1000 [2:25:39<2:56:35, 19.33s/it][Succeeded / Failed / Skipped / Total] 101 / 342 / 9 / 452:  45%|████▌     | 453/1000 [2:25:45<2:56:00, 19.31s/it][Succeeded / Failed / Skipped / Total] 101 / 343 / 9 / 453:  45%|████▌     | 453/1000 [2:25:45<2:56:00, 19.31s/it][Succeeded / Failed / Skipped / Total] 101 / 343 / 9 / 453:  45%|████▌     | 454/1000 [2:25:51<2:55:25, 19.28s/it]Creates an epoll event loop group. --> [[[FAILED]]]

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory [[threadFactory]] ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , [[threadFactory]] ) : new NioEventLoopGroup ( nThreads , [[threadFactory]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int nThreads , ThreadFactory [[cluttered]] ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , [[cluttered]] ) : new NioEventLoopGroup ( nThreads , [[cluttered]] ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 447 ---------------------------------------------
Parse the remote address from the specified channel.@param channel the channel to parse.@return the remote address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[breeches]] ( final Channel [[upstaged]] ) { if ( null == [[upstaged]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[upstaged]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Parse an IP address from the specified channel.@param channel the channel to parse.@return the IP address. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[northwest]] ( final Channel [[golda]] ) { if ( null == [[golda]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[golda]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Parse the remote host name from the channel.@param channel the channel.@return the remote host name. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[alarming]] ( final Channel [[doom]] ) { if ( null == [[doom]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[abuser]] = ( InetSocketAddress ) [[doom]] . remoteAddress ( ) ; if ( [[abuser]] != null ) { return [[abuser]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Parses an IP address from the specified channel.@param channel the channel@return the IP address --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[reenactment]] ( final Channel [[chauvinistic]] ) { if ( null == [[chauvinistic]] ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) [[chauvinistic]] . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
Adds a connection. --> Colloquial queries. --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean [[res]] = this . [[conns]] . addIfAbsent ( connection ) ; if ( [[res]] ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[colloquial]] ( Connection connection ) { markAccess ( ) ; if ( null == connection ) { return ; } boolean [[germaine]] = this . [[chewed]] . addIfAbsent ( connection ) ; if ( [[germaine]] ) { connection . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 452 ---------------------------------------------
Retrieves a connection from this pool.@return the connection or <code>null</code> if none. --> Removes all connections from this pool. --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[prattle]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 453 ---------------------------------------------
Parses the remote port from the channel.@param channel the channel to parse.@return the remote port, or -1 if the channel is null. --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseRemotePort ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int parseRemotePort ( final Channel [[twelve]] ) { if ( null == [[twelve]] ) { return - 1 ; } final InetSocketAddress [[acrobats]] = ( InetSocketAddress ) [[twelve]] . remoteAddress ( ) ; if ( [[acrobats]] != null ) { return [[acrobats]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 454 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 101 / 344 / 9 / 454:  45%|████▌     | 454/1000 [2:25:51<2:55:25, 19.28s/it][Succeeded / Failed / Skipped / Total] 101 / 344 / 9 / 454:  46%|████▌     | 455/1000 [2:26:06<2:55:00, 19.27s/it][Succeeded / Failed / Skipped / Total] 102 / 344 / 9 / 455:  46%|████▌     | 455/1000 [2:26:06<2:55:00, 19.27s/it][Succeeded / Failed / Skipped / Total] 102 / 344 / 9 / 455:  46%|████▌     | 456/1000 [2:26:17<2:54:31, 19.25s/it][Succeeded / Failed / Skipped / Total] 102 / 345 / 9 / 456:  46%|████▌     | 456/1000 [2:26:17<2:54:31, 19.25s/it][Succeeded / Failed / Skipped / Total] 102 / 345 / 9 / 456:  46%|████▌     | 457/1000 [2:26:23<2:53:56, 19.22s/it][Succeeded / Failed / Skipped / Total] 102 / 346 / 9 / 457:  46%|████▌     | 457/1000 [2:26:23<2:53:56, 19.22s/it][Succeeded / Failed / Skipped / Total] 102 / 346 / 9 / 457:  46%|████▌     | 458/1000 [2:26:27<2:53:19, 19.19s/it][Succeeded / Failed / Skipped / Total] 102 / 347 / 9 / 458:  46%|████▌     | 458/1000 [2:26:27<2:53:19, 19.19s/it][Succeeded / Failed / Skipped / Total] 102 / 347 / 9 / 458:  46%|████▌     | 459/1000 [2:26:28<2:52:38, 19.15s/it][Succeeded / Failed / Skipped / Total] 102 / 347 / 10 / 459:  46%|████▌     | 459/1000 [2:26:28<2:52:38, 19.15s/it][Succeeded / Failed / Skipped / Total] 102 / 347 / 10 / 459:  46%|████▌     | 460/1000 [2:26:36<2:52:06, 19.12s/it][Succeeded / Failed / Skipped / Total] 102 / 348 / 10 / 460:  46%|████▌     | 460/1000 [2:26:36<2:52:06, 19.12s/it][Succeeded / Failed / Skipped / Total] 102 / 348 / 10 / 460:  46%|████▌     | 461/1000 [2:26:36<2:51:25, 19.08s/it][Succeeded / Failed / Skipped / Total] 102 / 348 / 11 / 461:  46%|████▌     | 461/1000 [2:26:36<2:51:25, 19.08s/it][Succeeded / Failed / Skipped / Total] 102 / 348 / 11 / 461:  46%|████▌     | 462/1000 [2:26:43<2:50:52, 19.06s/it][Succeeded / Failed / Skipped / Total] 103 / 348 / 11 / 462:  46%|████▌     | 462/1000 [2:26:43<2:50:52, 19.06s/it][Succeeded / Failed / Skipped / Total] 103 / 348 / 11 / 462:  46%|████▋     | 463/1000 [2:27:19<2:50:52, 19.09s/it][Succeeded / Failed / Skipped / Total] 103 / 349 / 11 / 463:  46%|████▋     | 463/1000 [2:27:19<2:50:52, 19.09s/it][Succeeded / Failed / Skipped / Total] 103 / 349 / 11 / 463:  46%|████▋     | 464/1000 [2:27:25<2:50:17, 19.06s/it]Removes and tries to close the supplied connection. --> [[[FAILED]]]

[[[[Adv]]]]: public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection connection ) { if ( null == connection ) { return ; } boolean res = this . conns . remove ( connection ) ; if ( res ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 455 ---------------------------------------------
Start the connection monitor. --> Starts the connection monitor. --> Socre: 1.0

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . [[executor]] = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . [[executor]] . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . [[breast]] = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . [[breast]] . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 456 ---------------------------------------------
Returns the custom serializer for the specified class. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[containing]] ( String [[accelerating]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[accelerating]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 457 ---------------------------------------------
Parses a channel's local port.@param channelThe channel to parse.@return The parsed port. --> [[[FAILED]]]

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int parseLocalPort ( final Channel [[northwest]] ) { if ( null == [[northwest]] ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) [[northwest]] . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 458 ---------------------------------------------
Returns the custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[togo]] ( CommandCode code ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( code ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 459 ---------------------------------------------
Batch write.@param ws@param sockchannel@return@throws IOException --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
Parse a socket address to host ip@param socketAddress@return --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress [[addr]] = [[addrs]] . getAddress ( ) ; if ( null != [[addr]] ) { return [[addr]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[reconfigure]] ( SocketAddress [[atonement]] ) { final InetSocketAddress [[russet]] = ( InetSocketAddress ) [[atonement]] ; if ( [[russet]] != null ) { InetAddress [[granted]] = [[russet]] . getAddress ( ) ; if ( null != [[granted]] ) { return [[granted]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 461 ---------------------------------------------
Validates a UTF-8 string. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 462 ---------------------------------------------
Sets the code of the sprite. --> Logs an error message. --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[clueless]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 463 ---------------------------------------------
Registers a custom serializer for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[className]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[asbury]] ( String [[etcetera]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[etcetera]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[etcetera]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 464 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 103 / 350 / 11 / 464:  46%|████▋     | 464/1000 [2:27:25<2:50:17, 19.06s/it][Succeeded / Failed / Skipped / Total] 103 / 350 / 11 / 464:  46%|████▋     | 465/1000 [2:27:25<2:49:37, 19.02s/it][Succeeded / Failed / Skipped / Total] 104 / 350 / 11 / 465:  46%|████▋     | 465/1000 [2:27:25<2:49:37, 19.02s/it][Succeeded / Failed / Skipped / Total] 104 / 350 / 11 / 465:  47%|████▋     | 466/1000 [2:27:25<2:48:56, 18.98s/it][Succeeded / Failed / Skipped / Total] 104 / 351 / 11 / 466:  47%|████▋     | 466/1000 [2:27:25<2:48:56, 18.98s/it][Succeeded / Failed / Skipped / Total] 104 / 351 / 11 / 466:  47%|████▋     | 467/1000 [2:27:27<2:48:18, 18.95s/it][Succeeded / Failed / Skipped / Total] 105 / 351 / 11 / 467:  47%|████▋     | 467/1000 [2:27:27<2:48:18, 18.95s/it][Succeeded / Failed / Skipped / Total] 105 / 351 / 11 / 467:  47%|████▋     | 468/1000 [2:27:31<2:47:41, 18.91s/it][Succeeded / Failed / Skipped / Total] 106 / 351 / 11 / 468:  47%|████▋     | 468/1000 [2:27:31<2:47:41, 18.91s/it][Succeeded / Failed / Skipped / Total] 106 / 351 / 11 / 468:  47%|████▋     | 469/1000 [2:27:51<2:47:23, 18.92s/it][Succeeded / Failed / Skipped / Total] 107 / 351 / 11 / 469:  47%|████▋     | 469/1000 [2:27:51<2:47:23, 18.92s/it][Succeeded / Failed / Skipped / Total] 107 / 351 / 11 / 469:  47%|████▋     | 470/1000 [2:27:51<2:46:43, 18.88s/it][Succeeded / Failed / Skipped / Total] 108 / 351 / 11 / 470:  47%|████▋     | 470/1000 [2:27:51<2:46:43, 18.88s/it][Succeeded / Failed / Skipped / Total] 108 / 351 / 11 / 470:  47%|████▋     | 471/1000 [2:28:00<2:46:14, 18.85s/it]Registers a custom serializer for the given command code. --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[sneezy]] ( CommandCode code , CustomSerializer serializer ) { CustomSerializer prevSerializer = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 465 ---------------------------------------------
Updates the payload. --> Creates a barham message. --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[barham]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 466 ---------------------------------------------
Returns an implementation of the given opcode. --> [[[FAILED]]]

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[biochemical]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 467 ---------------------------------------------
Initializes the write buffer water mark. --> Called when the channel is bootstrapped. --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[acrobats]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 468 ---------------------------------------------
Determines whether or not the specified remote address is connected. --> Dostoyevsky. --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url [[url]] = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[url]] ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[dostoyevsky]] ( String remoteAddr ) { Url [[thejob]] = this . rpcRemoting . addressParser . parse ( remoteAddr ) ; return this . isConnected ( [[thejob]] ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 469 ---------------------------------------------
Processes a binary message. --> B berliners message. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[berliners]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 470 ---------------------------------------------
Translate the payload size limit for a single frame. --> arranger. --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[arranger]] ( long length ) throws LimitExceededException { if ( length > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( length > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , length ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( length < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
[Succeeded / Failed / Skipped / Total] 109 / 351 / 11 / 471:  47%|████▋     | 471/1000 [2:28:00<2:46:14, 18.85s/it][Succeeded / Failed / Skipped / Total] 109 / 351 / 11 / 471:  47%|████▋     | 472/1000 [2:28:01<2:45:35, 18.82s/it][Succeeded / Failed / Skipped / Total] 110 / 351 / 11 / 472:  47%|████▋     | 472/1000 [2:28:01<2:45:35, 18.82s/it][Succeeded / Failed / Skipped / Total] 110 / 351 / 11 / 472:  47%|████▋     | 473/1000 [2:28:23<2:45:20, 18.82s/it][Succeeded / Failed / Skipped / Total] 111 / 351 / 11 / 473:  47%|████▋     | 473/1000 [2:28:23<2:45:20, 18.82s/it][Succeeded / Failed / Skipped / Total] 111 / 351 / 11 / 473:  47%|████▋     | 474/1000 [2:28:24<2:44:41, 18.79s/it][Succeeded / Failed / Skipped / Total] 112 / 351 / 11 / 474:  47%|████▋     | 474/1000 [2:28:24<2:44:41, 18.79s/it][Succeeded / Failed / Skipped / Total] 112 / 351 / 11 / 474:  48%|████▊     | 475/1000 [2:28:34<2:44:13, 18.77s/it][Succeeded / Failed / Skipped / Total] 113 / 351 / 11 / 475:  48%|████▊     | 475/1000 [2:28:34<2:44:13, 18.77s/it][Succeeded / Failed / Skipped / Total] 113 / 351 / 11 / 475:  48%|████▊     | 476/1000 [2:28:52<2:43:52, 18.77s/it][Succeeded / Failed / Skipped / Total] 114 / 351 / 11 / 476:  48%|████▊     | 476/1000 [2:28:52<2:43:52, 18.77s/it][Succeeded / Failed / Skipped / Total] 114 / 351 / 11 / 476:  48%|████▊     | 477/1000 [2:28:54<2:43:16, 18.73s/it][Succeeded / Failed / Skipped / Total] 115 / 351 / 11 / 477:  48%|████▊     | 477/1000 [2:28:54<2:43:16, 18.73s/it][Succeeded / Failed / Skipped / Total] 115 / 351 / 11 / 477:  48%|████▊     | 478/1000 [2:29:07<2:42:51, 18.72s/it]--------------------------------------------- Result 471 ---------------------------------------------
Translate the given maxpacketsize to the given realpacketsize. --> Bergman function. --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[bergman]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 472 ---------------------------------------------
Log a runtime exception. --> Called when a websocket message is received. --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl [[webSocketImpl]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketError ( [[webSocketImpl]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[ashish]] ( WebSocketImpl [[possessiveness]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[possessiveness]] . getWebSocketListener ( ) . onWebsocketError ( [[possessiveness]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 473 ---------------------------------------------
Generates the final key for the given input. --> Calculates the SHA1 hash of an incoming message. --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[sh1]] ; try { [[sh1]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[sh1]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[exceptionally]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest [[backyard]] ; try { [[backyard]] = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( [[backyard]] . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 474 ---------------------------------------------
Processes a close frame. --> Sailfish handshake. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[sailfish]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 475 ---------------------------------------------
Checks if the requested protocol matches the provided one. --> Dampens handshakes. --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[dampened]] ( String [[bergman]] ) { for ( IProtocol knownProtocol : knownProtocols ) { if ( knownProtocol . acceptProvidedProtocol ( [[bergman]] ) ) { protocol = knownProtocol ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 476 ---------------------------------------------
Checks the maximum size of the buffer. --> M machinist --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[machinist]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 477 ---------------------------------------------
Processes a WebSocket frame. --> Cadres methods --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[cadres]] ( WebSocketImpl [[battery]] , Framedata frame ) throws InvalidDataException { try { [[battery]] . getWebSocketListener ( ) . onWebsocketMessage ( [[battery]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[battery]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 478 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 116 / 351 / 11 / 478:  48%|████▊     | 478/1000 [2:29:07<2:42:51, 18.72s/it][Succeeded / Failed / Skipped / Total] 116 / 351 / 11 / 478:  48%|████▊     | 479/1000 [2:29:09<2:42:13, 18.68s/it][Succeeded / Failed / Skipped / Total] 117 / 351 / 11 / 479:  48%|████▊     | 479/1000 [2:29:09<2:42:13, 18.68s/it][Succeeded / Failed / Skipped / Total] 117 / 351 / 11 / 479:  48%|████▊     | 480/1000 [2:29:27<2:41:54, 18.68s/it][Succeeded / Failed / Skipped / Total] 118 / 351 / 11 / 480:  48%|████▊     | 480/1000 [2:29:27<2:41:54, 18.68s/it][Succeeded / Failed / Skipped / Total] 118 / 351 / 11 / 480:  48%|████▊     | 481/1000 [2:29:32<2:41:21, 18.65s/it][Succeeded / Failed / Skipped / Total] 119 / 351 / 11 / 481:  48%|████▊     | 481/1000 [2:29:32<2:41:21, 18.65s/it][Succeeded / Failed / Skipped / Total] 119 / 351 / 11 / 481:  48%|████▊     | 482/1000 [2:29:34<2:40:44, 18.62s/it][Succeeded / Failed / Skipped / Total] 120 / 351 / 11 / 482:  48%|████▊     | 482/1000 [2:29:34<2:40:45, 18.62s/it][Succeeded / Failed / Skipped / Total] 120 / 351 / 11 / 482:  48%|████▊     | 483/1000 [2:29:36<2:40:08, 18.58s/it][Succeeded / Failed / Skipped / Total] 121 / 351 / 11 / 483:  48%|████▊     | 483/1000 [2:29:36<2:40:08, 18.58s/it][Succeeded / Failed / Skipped / Total] 121 / 351 / 11 / 483:  48%|████▊     | 484/1000 [2:29:36<2:39:30, 18.55s/it]Processes a frame. --> Dostoyevsky function. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[dostoyevsky]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 479 ---------------------------------------------
Processes a continuous frame. --> Handles continuous frames. --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[aghhh]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 480 ---------------------------------------------
Returns the size of the byte buffer list. --> Add is. --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[addis]] ( ) { long [[himmler]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[himmler]] += buffer . limit ( ) ; } } return [[himmler]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 481 ---------------------------------------------
Translate the first line of the HTTP server handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Translate a PAM by line. --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[pamby]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 482 ---------------------------------------------
Flushes and closes the connection. --> Write ashanti response. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[ashanti]] ( InvalidDataException exception ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( exception . getCloseCode ( ) , exception . getMessage ( ) , "[[Bastian]]" != "[[Bastian]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 483 ---------------------------------------------
Gets the payload from the byte buffer list. --> Creates an autopsies buffer.@param autopsies@return@throws LimitExceededException --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[autopsies]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 484 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 121 / 351 / 12 / 484:  48%|████▊     | 484/1000 [2:29:36<2:39:30, 18.55s/it][Succeeded / Failed / Skipped / Total] 121 / 351 / 12 / 484:  48%|████▊     | 485/1000 [2:29:40<2:38:55, 18.52s/it][Succeeded / Failed / Skipped / Total] 122 / 351 / 12 / 485:  48%|████▊     | 485/1000 [2:29:40<2:38:55, 18.52s/it][Succeeded / Failed / Skipped / Total] 122 / 351 / 12 / 485:  49%|████▊     | 486/1000 [2:29:51<2:38:29, 18.50s/it][Succeeded / Failed / Skipped / Total] 122 / 352 / 12 / 486:  49%|████▊     | 486/1000 [2:29:51<2:38:29, 18.50s/it][Succeeded / Failed / Skipped / Total] 122 / 352 / 12 / 486:  49%|████▊     | 487/1000 [2:29:52<2:37:52, 18.46s/it][Succeeded / Failed / Skipped / Total] 122 / 353 / 12 / 487:  49%|████▊     | 487/1000 [2:29:52<2:37:52, 18.46s/it][Succeeded / Failed / Skipped / Total] 122 / 353 / 12 / 487:  49%|████▉     | 488/1000 [2:30:07<2:37:30, 18.46s/it][Succeeded / Failed / Skipped / Total] 122 / 354 / 12 / 488:  49%|████▉     | 488/1000 [2:30:07<2:37:30, 18.46s/it][Succeeded / Failed / Skipped / Total] 122 / 354 / 12 / 488:  49%|████▉     | 489/1000 [2:30:10<2:36:56, 18.43s/it][Succeeded / Failed / Skipped / Total] 123 / 354 / 12 / 489:  49%|████▉     | 489/1000 [2:30:10<2:36:56, 18.43s/it][Succeeded / Failed / Skipped / Total] 123 / 354 / 12 / 489:  49%|████▉     | 490/1000 [2:30:26<2:36:34, 18.42s/it][Succeeded / Failed / Skipped / Total] 124 / 354 / 12 / 490:  49%|████▉     | 490/1000 [2:30:26<2:36:34, 18.42s/it][Succeeded / Failed / Skipped / Total] 124 / 354 / 12 / 490:  49%|████▉     | 491/1000 [2:30:51<2:36:23, 18.44s/it]Resets the connection. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
Closes the connection. --> Cubbles an exception. --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[cub]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 486 ---------------------------------------------
Processes a continuous frame sequence. --> [[[FAILED]]]

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[scrapbooks]] ( WebSocketImpl webSocketImpl , Framedata frame , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( frame ) ; } else if ( frame . isFin ( ) ) { processFrameIsFin ( webSocketImpl , frame ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 487 ---------------------------------------------
Connects to the server. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[dusting]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 488 ---------------------------------------------
Sends the specified data to the client. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[barrymore]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[barrymore]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 489 ---------------------------------------------
Translate the first line of the HTTP client handshake.@param firstLineTokens@param line@return@throws InvalidHandshakeException --> Translate an array of strings into an HttpClient.@param stuttgart@param abattoir@return@throws InvalidHandshakeException --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] [[firstLineTokens]] , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpClient ( String [ ] [[stuttgart]] , String [[abattoir]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 490 ---------------------------------------------
Decodes the contents of the specified socket buffer. --> Processes a handshake message. --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[ashish]] ( ByteBuffer [[possessiveness]] ) { assert ( [[possessiveness]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[possessiveness]] . remaining ( ) , ( [[possessiveness]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[possessiveness]] . array ( ) , [[possessiveness]] . position ( ) , [[possessiveness]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[possessiveness]] ) ; } } else { if ( decodeHandshake ( [[possessiveness]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[possessiveness]] . hasRemaining ( ) || ! [[possessiveness]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 491 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 355 / 12 / 491:  49%|████▉     | 491/1000 [2:30:51<2:36:23, 18.44s/it][Succeeded / Failed / Skipped / Total] 124 / 355 / 12 / 491:  49%|████▉     | 492/1000 [2:30:54<2:35:48, 18.40s/it][Succeeded / Failed / Skipped / Total] 124 / 356 / 12 / 492:  49%|████▉     | 492/1000 [2:30:54<2:35:48, 18.40s/it][Succeeded / Failed / Skipped / Total] 124 / 356 / 12 / 492:  49%|████▉     | 493/1000 [2:31:01<2:35:18, 18.38s/it][Succeeded / Failed / Skipped / Total] 125 / 356 / 12 / 493:  49%|████▉     | 493/1000 [2:31:01<2:35:18, 18.38s/it][Succeeded / Failed / Skipped / Total] 125 / 356 / 12 / 493:  49%|████▉     | 494/1000 [2:31:10<2:34:50, 18.36s/it][Succeeded / Failed / Skipped / Total] 125 / 357 / 12 / 494:  49%|████▉     | 494/1000 [2:31:10<2:34:50, 18.36s/it][Succeeded / Failed / Skipped / Total] 125 / 358 / 12 / 495:  50%|████▉     | 495/1000 [2:31:10<2:34:13, 18.32s/it][Succeeded / Failed / Skipped / Total] 125 / 358 / 12 / 495:  50%|████▉     | 496/1000 [2:31:20<2:33:46, 18.31s/it][Succeeded / Failed / Skipped / Total] 126 / 358 / 12 / 496:  50%|████▉     | 496/1000 [2:31:20<2:33:46, 18.31s/it]Stop the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[brimley]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 492 ---------------------------------------------
Returns the port number for the given URI. --> [[[FAILED]]]

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[deceased]] ( ) { int [[gunboat]] = uri . getPort ( ) ; if ( [[gunboat]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[gunboat]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 493 ---------------------------------------------
Cancels the connection lost timer. --> Cancels all connections. --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[assuming]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 494 ---------------------------------------------
Start the connection lost timer. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[aiello]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . websocketRunning = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 495 ---------------------------------------------
Sets the connection lost timeout. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[aigoo]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 496 ---------------------------------------------
Cancel a connection lost checker. --> judgements --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[judgements]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[Bowman]]" != "[[Bowman]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 497 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 127 / 358 / 12 / 497:  50%|████▉     | 497/1000 [2:31:22<2:33:12, 18.27s/it][Succeeded / Failed / Skipped / Total] 127 / 358 / 12 / 497:  50%|████▉     | 498/1000 [2:31:23<2:32:36, 18.24s/it][Succeeded / Failed / Skipped / Total] 128 / 358 / 12 / 498:  50%|████▉     | 498/1000 [2:31:23<2:32:36, 18.24s/it][Succeeded / Failed / Skipped / Total] 129 / 358 / 12 / 499:  50%|████▉     | 499/1000 [2:31:59<2:32:36, 18.28s/it][Succeeded / Failed / Skipped / Total] 129 / 358 / 12 / 499:  50%|█████     | 500/1000 [2:32:00<2:32:00, 18.24s/it][Succeeded / Failed / Skipped / Total] 129 / 359 / 12 / 500:  50%|█████     | 500/1000 [2:32:00<2:32:00, 18.24s/it][Succeeded / Failed / Skipped / Total] 129 / 359 / 12 / 500:  50%|█████     | 501/1000 [2:32:00<2:31:24, 18.21s/it][Succeeded / Failed / Skipped / Total] 129 / 359 / 13 / 501:  50%|█████     | 501/1000 [2:32:00<2:31:24, 18.21s/it][Succeeded / Failed / Skipped / Total] 129 / 359 / 14 / 502:  50%|█████     | 502/1000 [2:32:00<2:30:48, 18.17s/it][Succeeded / Failed / Skipped / Total] 129 / 359 / 14 / 502:  50%|█████     | 503/1000 [2:32:02<2:30:13, 18.14s/it]Generates an HTTP response based on an error code. --> Sends an HTTP 404 WebSocket upgrade request. --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[deserves]] ( int [[tenderness]] ) { String errorCodeDescription ; switch ( [[tenderness]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 498 ---------------------------------------------
Sends a handshake. --> Renews a connection. --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[grandfathers]] ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 499 ---------------------------------------------
Accepts a selection key. --> Accepts the given iterator. --> Socre: 1.0

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[i]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[easterbrook]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[easterbrook]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 500 ---------------------------------------------
Returns the port number associated with this socket. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[memory]] ( ) { int [[intersecting]] = getAddress ( ) . getPort ( ) ; if ( [[intersecting]] == 0 && server != null ) { [[intersecting]] = server . socket ( ) . getLocalPort ( ) ; } return [[intersecting]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 501 ---------------------------------------------
Writes data to the specified key. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 502 ---------------------------------------------
Reads from the socket. --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 503 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 130 / 359 / 14 / 503:  50%|█████     | 503/1000 [2:32:02<2:30:13, 18.14s/it][Succeeded / Failed / Skipped / Total] 130 / 359 / 15 / 504:  50%|█████     | 504/1000 [2:32:02<2:29:37, 18.10s/it][Succeeded / Failed / Skipped / Total] 130 / 359 / 15 / 504:  50%|█████     | 505/1000 [2:32:13<2:29:12, 18.09s/it][Succeeded / Failed / Skipped / Total] 130 / 360 / 15 / 505:  50%|█████     | 505/1000 [2:32:13<2:29:12, 18.09s/it][Succeeded / Failed / Skipped / Total] 130 / 360 / 15 / 505:  51%|█████     | 506/1000 [2:32:20<2:28:43, 18.06s/it][Succeeded / Failed / Skipped / Total] 131 / 360 / 15 / 506:  51%|█████     | 506/1000 [2:32:20<2:28:43, 18.06s/it][Succeeded / Failed / Skipped / Total] 131 / 360 / 15 / 506:  51%|█████     | 507/1000 [2:32:40<2:28:27, 18.07s/it][Succeeded / Failed / Skipped / Total] 132 / 360 / 15 / 507:  51%|█████     | 507/1000 [2:32:40<2:28:27, 18.07s/it][Succeeded / Failed / Skipped / Total] 132 / 360 / 15 / 507:  51%|█████     | 508/1000 [2:32:41<2:27:53, 18.04s/it][Succeeded / Failed / Skipped / Total] 133 / 360 / 15 / 508:  51%|█████     | 508/1000 [2:32:41<2:27:53, 18.04s/it][Succeeded / Failed / Skipped / Total] 133 / 360 / 15 / 508:  51%|█████     | 509/1000 [2:32:43<2:27:19, 18.00s/it]Performs additional read. --> Creates a new channel and attaches it to the queue. --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer [[buf]] = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( [[buf]] , conn , c ) ) iqueue . add ( conn ) ; if ( [[buf]] . hasRemaining ( ) ) { conn . inQueue . put ( [[buf]] ) ; queue ( conn ) ; } else { pushBuffer ( [[buf]] ) ; } } catch ( IOException e ) { pushBuffer ( [[buf]] ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[astro]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer [[attaches]] = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( [[attaches]] , conn , c ) ) iqueue . add ( conn ) ; if ( [[attaches]] . hasRemaining ( ) ) { conn . inQueue . put ( [[attaches]] ) ; queue ( conn ) ; } else { pushBuffer ( [[attaches]] ) ; } } catch ( IOException e ) { pushBuffer ( [[attaches]] ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 504 ---------------------------------------------
Called when the server shuts down. --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 505 ---------------------------------------------
Sends a ping frame. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[lengthen]] ( WebSocket conn , Framedata f ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 506 ---------------------------------------------
Initializes the selector and server. --> Creates and starts listening for connections. --> Socre: 1.0

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean doSetupSelectorAndServerThread ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Beckham]]" != "[[Beckham]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[Beckham]]" != "[[Beckham]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 507 ---------------------------------------------
Returns the socket for the specified channel. --> Creates an isotope channel. --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[isotope]] ( WebSocket conn ) { WebSocketImpl [[barbell]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[barbell]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 508 ---------------------------------------------
Called when a connection was lost. --> zaragoza. --> Socre: 1.0

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket webSocket , long [[minimumPongTime]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[zaragoza]] ( WebSocket webSocket , long [[allegra]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[allegra]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 509 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 134 / 360 / 15 / 509:  51%|█████     | 509/1000 [2:32:43<2:27:19, 18.00s/it][Succeeded / Failed / Skipped / Total] 134 / 360 / 15 / 509:  51%|█████     | 510/1000 [2:32:51<2:26:51, 17.98s/it][Succeeded / Failed / Skipped / Total] 135 / 360 / 15 / 510:  51%|█████     | 510/1000 [2:32:51<2:26:51, 17.98s/it][Succeeded / Failed / Skipped / Total] 135 / 360 / 15 / 510:  51%|█████     | 511/1000 [2:32:53<2:26:18, 17.95s/it][Succeeded / Failed / Skipped / Total] 135 / 361 / 15 / 511:  51%|█████     | 511/1000 [2:32:53<2:26:18, 17.95s/it][Succeeded / Failed / Skipped / Total] 135 / 361 / 15 / 511:  51%|█████     | 512/1000 [2:33:07<2:25:57, 17.94s/it][Succeeded / Failed / Skipped / Total] 136 / 361 / 15 / 512:  51%|█████     | 512/1000 [2:33:07<2:25:57, 17.94s/it][Succeeded / Failed / Skipped / Total] 136 / 361 / 15 / 512:  51%|█████▏    | 513/1000 [2:33:19<2:25:33, 17.93s/it][Succeeded / Failed / Skipped / Total] 137 / 361 / 15 / 513:  51%|█████▏    | 513/1000 [2:33:19<2:25:33, 17.93s/it][Succeeded / Failed / Skipped / Total] 137 / 361 / 15 / 513:  51%|█████▏    | 514/1000 [2:33:20<2:24:58, 17.90s/it][Succeeded / Failed / Skipped / Total] 137 / 362 / 15 / 514:  51%|█████▏    | 514/1000 [2:33:20<2:24:58, 17.90s/it][Succeeded / Failed / Skipped / Total] 137 / 362 / 15 / 514:  52%|█████▏    | 515/1000 [2:33:23<2:24:27, 17.87s/it][Succeeded / Failed / Skipped / Total] 138 / 362 / 15 / 515:  52%|█████▏    | 515/1000 [2:33:23<2:24:27, 17.87s/it][Succeeded / Failed / Skipped / Total] 138 / 362 / 15 / 515:  52%|█████▏    | 516/1000 [2:33:30<2:23:59, 17.85s/it][Succeeded / Failed / Skipped / Total] 139 / 362 / 15 / 516:  52%|█████▏    | 516/1000 [2:33:30<2:23:59, 17.85s/it][Succeeded / Failed / Skipped / Total] 139 / 362 / 15 / 516:  52%|█████▏    | 517/1000 [2:33:52<2:23:45, 17.86s/it]Ensure that only one thread is running. --> Ensure single threaded. --> Socre: 1.0

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "[[Perceptive]]" != "[[Perceptive]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 510 ---------------------------------------------
Broadcasts the specified text to all registered clients. --> Called when something goes wrong. --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[aggravation]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 511 ---------------------------------------------
Stops this thread. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[leonora]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 512 ---------------------------------------------
Broadcasts a data frame to all the clients. --> Immediately sends a frame. --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[acutely]] ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 513 ---------------------------------------------
Transfer a byte buffer from source to dest. --> Copies the contents of the supplied buffer into the supplied destination buffer. --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[buffaloed]] , ByteBuffer dest ) { if ( [[buffaloed]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[buffaloed]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[buffaloed]] . limit ( limit ) ; dest . put ( [[buffaloed]] ) ; return limit ; } else { dest . put ( [[buffaloed]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 514 ---------------------------------------------
Starts the persistence manager. --> [[[FAILED]]]

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[sarcasm]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 515 ---------------------------------------------
Broadcasts the specified data to all registered clients. --> Creates an animator for the specified data. --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > [[clients]] ) { if ( data == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[animator]] ( byte [ ] data , Collection < WebSocket > [[snubbing]] ) { if ( data == null || [[snubbing]] == null ) { throw new IllegalArgumentException ( ) ; } [[animator]] ( ByteBuffer . wrap ( data ) , [[snubbing]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 516 ---------------------------------------------
Called when a websocket handshake is received. --> Sopranos server@param conn@param request@return@throws InvalidDataException --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket conn , Draft [[draft]] , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[sopranos]] ( WebSocket conn , Draft [[yuan]] , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
[Succeeded / Failed / Skipped / Total] 140 / 362 / 15 / 517:  52%|█████▏    | 517/1000 [2:33:52<2:23:45, 17.86s/it][Succeeded / Failed / Skipped / Total] 140 / 362 / 15 / 517:  52%|█████▏    | 518/1000 [2:34:26<2:23:42, 17.89s/it][Succeeded / Failed / Skipped / Total] 141 / 362 / 15 / 518:  52%|█████▏    | 518/1000 [2:34:26<2:23:42, 17.89s/it][Succeeded / Failed / Skipped / Total] 141 / 362 / 15 / 518:  52%|█████▏    | 519/1000 [2:34:32<2:23:13, 17.87s/it][Succeeded / Failed / Skipped / Total] 141 / 363 / 15 / 519:  52%|█████▏    | 519/1000 [2:34:32<2:23:13, 17.87s/it][Succeeded / Failed / Skipped / Total] 141 / 363 / 15 / 519:  52%|█████▏    | 520/1000 [2:34:43<2:22:48, 17.85s/it][Succeeded / Failed / Skipped / Total] 141 / 364 / 15 / 520:  52%|█████▏    | 520/1000 [2:34:43<2:22:48, 17.85s/it][Succeeded / Failed / Skipped / Total] 141 / 364 / 15 / 520:  52%|█████▏    | 521/1000 [2:35:47<2:23:14, 17.94s/it][Succeeded / Failed / Skipped / Total] 141 / 365 / 15 / 521:  52%|█████▏    | 521/1000 [2:35:47<2:23:14, 17.94s/it][Succeeded / Failed / Skipped / Total] 141 / 365 / 15 / 521:  52%|█████▏    | 522/1000 [2:35:49<2:22:41, 17.91s/it][Succeeded / Failed / Skipped / Total] 142 / 365 / 15 / 522:  52%|█████▏    | 522/1000 [2:35:49<2:22:41, 17.91s/it][Succeeded / Failed / Skipped / Total] 142 / 365 / 15 / 522:  52%|█████▏    | 523/1000 [2:36:05<2:22:22, 17.91s/it][Succeeded / Failed / Skipped / Total] 142 / 366 / 15 / 523:  52%|█████▏    | 523/1000 [2:36:05<2:22:22, 17.91s/it][Succeeded / Failed / Skipped / Total] 142 / 366 / 15 / 523:  52%|█████▏    | 524/1000 [2:36:10<2:21:52, 17.88s/it][Succeeded / Failed / Skipped / Total] 143 / 366 / 15 / 524:  52%|█████▏    | 524/1000 [2:36:10<2:21:52, 17.88s/it][Succeeded / Failed / Skipped / Total] 143 / 366 / 15 / 524:  52%|█████▎    | 525/1000 [2:36:27<2:21:33, 17.88s/it][Succeeded / Failed / Skipped / Total] 143 / 367 / 15 / 525:  52%|█████▎    | 525/1000 [2:36:27<2:21:33, 17.88s/it][Succeeded / Failed / Skipped / Total] 143 / 367 / 15 / 525:  53%|█████▎    | 526/1000 [2:36:27<2:20:59, 17.85s/it]--------------------------------------------- Result 517 ---------------------------------------------
Performs a transaction on this entity manager. --> Sets salters --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > [[block]] ) { [[withTransaction]] ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[aishwarya]] ( Consumer < EntityManager > [[salters]] ) { [[aishwarya]] ( em -> { [[salters]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 518 ---------------------------------------------
Converts an array of arguments to a list of objects. --> Creates an islander. --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[islander]] ( final Object ... [[antithesis]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[antithesis]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 519 ---------------------------------------------
Creates an entity manager with the specified name. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[fleeing]] ( String [[insolent]] ) { EntityManagerFactory emf = emfs . get ( [[insolent]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 520 ---------------------------------------------
Wrap a list of arguments to a list if needed. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[leonora]] ( final T ... [[lifeboats]] ) { List < T > [[paddy]] ; if ( [[lifeboats]] != null && [[lifeboats]] . length == 1 && [[lifeboats]] [ 0 ] instanceof List ) { [[paddy]] = ( List < T > ) [[lifeboats]] [ 0 ] ; } else { [[paddy]] = Arrays . asList ( [[lifeboats]] ) ; } return [[paddy]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 521 ---------------------------------------------
Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages preferred ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages preferred ( Http . RequestHeader [[negotiable]] ) { play . api . i18n . Messages [[monthly]] = messages . preferred ( [[negotiable]] ) ; return new MessagesImpl ( new Lang ( [[monthly]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 522 ---------------------------------------------
Sets the language of the result. --> Cauterized messages --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result [[result]] , Lang [[lang]] ) { return messages . setLang ( [[result]] . asScala ( ) , [[lang]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[cauterized]] ( Result [[handicapper]] , Lang [[americus]] ) { return messages . setLang ( [[handicapper]] . asScala ( ) , [[americus]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 523 ---------------------------------------------
Returns a copy of this message. --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > candidates ) { Seq < Lang > [[cs]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) [[cs]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[aggravation]] ( Collection < Lang > candidates ) { Seq < Lang > [[facebook]] = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) [[facebook]] ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 524 ---------------------------------------------
Gets all messages.@param lang the language@param keys the keys@param args the args@return the messages --> Low-level high-level high-level high-level high-level highlight --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > keys , Object ... [[args]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > [[scalaArgs]] = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( keyArgs . toSeq ( ) , [[scalaArgs]] , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[highchair]] ( play . api . i18n . Lang lang , List < String > keys , Object ... [[dominus]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > [[scratches]] = convertArgsToScalaBuffer ( [[dominus]] ) ; return messages . apply ( keyArgs . toSeq ( ) , [[scratches]] , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 525 ---------------------------------------------
Returns true if this message is defined at the specified language. --> [[[FAILED]]]

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang lang , String [[key]] ) { return messages . isDefinedAt ( [[key]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[owing]] ( play . api . i18n . Lang lang , String [[cicadas]] ) { return messages . isDefinedAt ( [[cicadas]] , lang ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 526 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 144 / 367 / 15 / 526:  53%|█████▎    | 526/1000 [2:36:27<2:20:59, 17.85s/it][Succeeded / Failed / Skipped / Total] 144 / 367 / 15 / 526:  53%|█████▎    | 527/1000 [2:36:39<2:20:36, 17.84s/it][Succeeded / Failed / Skipped / Total] 145 / 367 / 15 / 527:  53%|█████▎    | 527/1000 [2:36:39<2:20:36, 17.84s/it][Succeeded / Failed / Skipped / Total] 145 / 367 / 15 / 527:  53%|█████▎    | 528/1000 [2:36:46<2:20:09, 17.82s/it][Succeeded / Failed / Skipped / Total] 145 / 368 / 15 / 528:  53%|█████▎    | 528/1000 [2:36:46<2:20:09, 17.82s/it][Succeeded / Failed / Skipped / Total] 145 / 368 / 15 / 528:  53%|█████▎    | 529/1000 [2:36:49<2:19:37, 17.79s/it][Succeeded / Failed / Skipped / Total] 145 / 369 / 15 / 529:  53%|█████▎    | 529/1000 [2:36:49<2:19:37, 17.79s/it][Succeeded / Failed / Skipped / Total] 145 / 369 / 15 / 529:  53%|█████▎    | 530/1000 [2:36:51<2:19:05, 17.76s/it][Succeeded / Failed / Skipped / Total] 145 / 370 / 15 / 530:  53%|█████▎    | 530/1000 [2:36:51<2:19:05, 17.76s/it][Succeeded / Failed / Skipped / Total] 145 / 370 / 15 / 530:  53%|█████▎    | 531/1000 [2:36:54<2:18:34, 17.73s/it][Succeeded / Failed / Skipped / Total] 146 / 370 / 15 / 531:  53%|█████▎    | 531/1000 [2:36:54<2:18:34, 17.73s/it][Succeeded / Failed / Skipped / Total] 146 / 370 / 15 / 531:  53%|█████▎    | 532/1000 [2:37:15<2:18:20, 17.74s/it][Succeeded / Failed / Skipped / Total] 146 / 371 / 15 / 532:  53%|█████▎    | 532/1000 [2:37:15<2:18:20, 17.74s/it][Succeeded / Failed / Skipped / Total] 146 / 371 / 15 / 532:  53%|█████▎    | 533/1000 [2:37:17<2:17:48, 17.71s/it][Succeeded / Failed / Skipped / Total] 146 / 372 / 15 / 533:  53%|█████▎    | 533/1000 [2:37:17<2:17:48, 17.71s/it][Succeeded / Failed / Skipped / Total] 146 / 372 / 15 / 533:  53%|█████▎    | 534/1000 [2:37:26<2:17:23, 17.69s/it][Succeeded / Failed / Skipped / Total] 146 / 373 / 15 / 534:  53%|█████▎    | 534/1000 [2:37:26<2:17:23, 17.69s/it][Succeeded / Failed / Skipped / Total] 146 / 373 / 15 / 534:  54%|█████▎    | 535/1000 [2:37:41<2:17:03, 17.68s/it][Succeeded / Failed / Skipped / Total] 146 / 374 / 15 / 535:  54%|█████▎    | 535/1000 [2:37:41<2:17:03, 17.68s/it][Succeeded / Failed / Skipped / Total] 146 / 374 / 15 / 535:  54%|█████▎    | 536/1000 [2:37:56<2:16:43, 17.68s/it][Succeeded / Failed / Skipped / Total] 146 / 375 / 15 / 536:  54%|█████▎    | 536/1000 [2:37:56<2:16:43, 17.68s/it][Succeeded / Failed / Skipped / Total] 146 / 375 / 15 / 536:  54%|█████▎    | 537/1000 [2:38:05<2:16:18, 17.66s/it]Fills a draft frame list with data from the specified draft. --> Chandler implementation --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[bData]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( [[bData]] != null ) { frames = draft . createFrames ( [[bData]] , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[chandler]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[altered]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( [[altered]] != null ) { frames = draft . createFrames ( [[altered]] , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 527 ---------------------------------------------
Creates and returns a Guiceable with the specified configuration.@param play The play instance.@param REPLACEME0 The configuration.@return A self object. --> Convenience method for creating a self-ques --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[QUESTS]] ( play . api . inject . Binding < ? > ... [[QUESTS]] ) { return [[QUESTS]] ( Guiceable . bindings ( [[QUESTS]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 528 ---------------------------------------------
Creates a copy of this builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[leaped]] ( GuiceableModule ... [[valued]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[valued]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 529 ---------------------------------------------
Gets the message associated with the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public String get ( play . api . i18n . Lang [[lang]] , String key , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( key , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String get ( play . api . i18n . Lang [[bridal]] , String key , Object ... [[olinda]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[olinda]] ) ; return messages . apply ( key , scalaArgs , [[bridal]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 530 ---------------------------------------------
Creates a set of bindings. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[backboard]] ( play . api . inject . Module ... [[exorcism]] ) { return [[backboard]] ( Guiceable . [[exorcism]] ( [[exorcism]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 531 ---------------------------------------------
Overrides the given bindings. --> Provides an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an easy way to provide an --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[sufficient]] ( play . api . inject . Binding < ? > ... bindings ) { return [[sufficient]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 532 ---------------------------------------------
Creates an overrides module. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[tryin]] ( GuiceableModule ... [[breathable]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[breathable]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 533 ---------------------------------------------
Creates a binding for the given scope. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[reassured]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 534 ---------------------------------------------
Returns the overrides of this object. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... [[modules]] ) { return [[overrides]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[shootings]] ( play . api . inject . Module ... [[magician]] ) { return [[shootings]] ( Guiceable . [[magician]] ( [[magician]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 535 ---------------------------------------------
Disables the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[irreplaceable]] ( Class < ? > ... [[petrie]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[petrie]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 536 ---------------------------------------------
Retrieves the file for the specified relative path. --> [[[FAILED]]]

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[addictions]] ( String [[pageantry]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[pageantry]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 537 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 376 / 15 / 537:  54%|█████▎    | 537/1000 [2:38:05<2:16:18, 17.66s/it][Succeeded / Failed / Skipped / Total] 146 / 376 / 15 / 537:  54%|█████▍    | 538/1000 [2:38:11<2:15:51, 17.64s/it][Succeeded / Failed / Skipped / Total] 146 / 377 / 15 / 538:  54%|█████▍    | 538/1000 [2:38:11<2:15:51, 17.64s/it][Succeeded / Failed / Skipped / Total] 146 / 377 / 15 / 538:  54%|█████▍    | 539/1000 [2:38:41<2:15:43, 17.67s/it][Succeeded / Failed / Skipped / Total] 147 / 377 / 15 / 539:  54%|█████▍    | 539/1000 [2:38:41<2:15:43, 17.67s/it][Succeeded / Failed / Skipped / Total] 147 / 377 / 15 / 539:  54%|█████▍    | 540/1000 [2:39:14<2:15:39, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 378 / 15 / 540:  54%|█████▍    | 540/1000 [2:39:14<2:15:39, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 378 / 15 / 540:  54%|█████▍    | 541/1000 [2:39:33<2:15:22, 17.70s/it][Succeeded / Failed / Skipped / Total] 147 / 379 / 15 / 541:  54%|█████▍    | 541/1000 [2:39:33<2:15:22, 17.70s/it][Succeeded / Failed / Skipped / Total] 147 / 379 / 15 / 541:  54%|█████▍    | 542/1000 [2:39:43<2:14:57, 17.68s/it][Succeeded / Failed / Skipped / Total] 147 / 380 / 15 / 542:  54%|█████▍    | 542/1000 [2:39:43<2:14:57, 17.68s/it][Succeeded / Failed / Skipped / Total] 147 / 380 / 15 / 542:  54%|█████▍    | 543/1000 [2:39:44<2:14:26, 17.65s/it][Succeeded / Failed / Skipped / Total] 147 / 381 / 15 / 543:  54%|█████▍    | 543/1000 [2:39:44<2:14:26, 17.65s/it][Succeeded / Failed / Skipped / Total] 147 / 381 / 15 / 543:  54%|█████▍    | 544/1000 [2:40:21<2:14:25, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 382 / 15 / 544:  54%|█████▍    | 544/1000 [2:40:21<2:14:25, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 382 / 15 / 544:  55%|█████▍    | 545/1000 [2:40:23<2:13:54, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 383 / 15 / 545:  55%|█████▍    | 545/1000 [2:40:23<2:13:54, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 383 / 15 / 545:  55%|█████▍    | 546/1000 [2:40:49<2:13:43, 17.67s/it]Calls the given request and returns the result. --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[fainter]] ( Request [[gaunt]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 538 ---------------------------------------------
Converts an execution context into an executor. --> [[[FAILED]]]

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext prepared = [[ec]] . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[lel]] ( ExecutionContext [[ceremonial]] ) { ExecutionContext prepared = [[ceremonial]] . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 539 ---------------------------------------------
Creates a 5-element HMM tuple. --> Constructor for 5 lists. --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , [[D]] , E > Tuple5 < A , B , C , [[D]] , E > Tuple5 ( A a , B b , C c , [[D]] d , E e ) { return new Tuple5 < A , B , C , [[D]] , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , [[incompetent]] , E > Tuple5 < A , B , C , [[incompetent]] , E > Tuple5 ( A a , B b , C c , [[incompetent]] d , E e ) { return new Tuple5 < A , B , C , [[incompetent]] , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 540 ---------------------------------------------
Creates a new configuration for the specified persistence unit. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[aurora]] ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 541 ---------------------------------------------
Creates a flow from a string and a byte string. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[approving]] ( String [[foreheads]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[foreheads]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 542 ---------------------------------------------
Creates a new configuration from the supplied map. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[map]] . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[collate]] ( Map < String , String > [[hyoid]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[staffing]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : [[hyoid]] . entrySet ( ) ) { [[staffing]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[staffing]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 543 ---------------------------------------------
Creates a flow with the specified callback name. --> [[[FAILED]]]

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[approving]] ( String [[boost]] ) { return Flow . of ( JsonNode . class ) . map ( [[approving]] -> { return ByteString . fromString ( Json . stringify ( [[approving]] ) ) ; } ) . via ( flow ( [[boost]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
Adds a constraint validator to the map.@param < T> the type parameter@param < MappedConstraintValidatorFactory> the factory --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[attaches]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 545 ---------------------------------------------
Creates a new tuple containing the specified two elements. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[A]] , B > [[Tuple]] < [[A]] , B > [[Tuple]] ( [[A]] [[a]] , B [[b]] ) { return new [[Tuple]] < [[A]] , B > ( [[a]] , [[b]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[sincere]] , B > [[Pistols]] < [[sincere]] , B > [[Pistols]] ( [[sincere]] [[distrust]] , B [[arkansas]] ) { return new [[Pistols]] < [[sincere]] , B > ( [[distrust]] , [[arkansas]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 546 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 147 / 384 / 15 / 546:  55%|█████▍    | 546/1000 [2:40:49<2:13:43, 17.67s/it][Succeeded / Failed / Skipped / Total] 147 / 384 / 15 / 546:  55%|█████▍    | 547/1000 [2:41:15<2:13:33, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 385 / 15 / 547:  55%|█████▍    | 547/1000 [2:41:15<2:13:33, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 385 / 15 / 547:  55%|█████▍    | 548/1000 [2:41:34<2:13:15, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 386 / 15 / 548:  55%|█████▍    | 548/1000 [2:41:34<2:13:15, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 386 / 15 / 548:  55%|█████▍    | 549/1000 [2:41:49<2:12:55, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 387 / 15 / 549:  55%|█████▍    | 549/1000 [2:41:49<2:12:55, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 387 / 15 / 549:  55%|█████▌    | 550/1000 [2:42:01<2:12:33, 17.68s/it][Succeeded / Failed / Skipped / Total] 147 / 388 / 15 / 550:  55%|█████▌    | 550/1000 [2:42:01<2:12:33, 17.68s/it][Succeeded / Failed / Skipped / Total] 147 / 388 / 15 / 550:  55%|█████▌    | 551/1000 [2:42:15<2:12:12, 17.67s/it][Succeeded / Failed / Skipped / Total] 147 / 389 / 15 / 551:  55%|█████▌    | 551/1000 [2:42:15<2:12:12, 17.67s/it][Succeeded / Failed / Skipped / Total] 147 / 389 / 15 / 551:  55%|█████▌    | 552/1000 [2:42:29<2:11:53, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 390 / 15 / 552:  55%|█████▌    | 552/1000 [2:42:29<2:11:53, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 390 / 15 / 552:  55%|█████▌    | 553/1000 [2:43:19<2:12:01, 17.72s/it][Succeeded / Failed / Skipped / Total] 147 / 391 / 15 / 553:  55%|█████▌    | 553/1000 [2:43:19<2:12:01, 17.72s/it][Succeeded / Failed / Skipped / Total] 147 / 391 / 15 / 553:  55%|█████▌    | 554/1000 [2:43:26<2:11:34, 17.70s/it]Creates a new instance of this constraint validator. --> [[[FAILED]]]

[[[[Adv]]]]: private < [[T]] extends ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[cockle]] extends ConstraintValidator < ? , ? > > [[cockle]] newInstance ( Class < [[cockle]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 547 ---------------------------------------------
Renders a bad request. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[otherthings]] ( RequestHeader request , String message ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , message , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 548 ---------------------------------------------
Creates a new configuration object. --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String u1 , String [[n2]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( [[n2]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[congratulates]] ( String n1 , String u1 , String [[shiho]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( [[shiho]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 549 ---------------------------------------------
Called when a request is not found. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[phenomenally]] ( RequestHeader [[bitching]] , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[bitching]] . method ( ) , [[bitching]] . uri ( ) , [[bitching]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[bitching]] . method ( ) , [[bitching]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[bitching]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 550 ---------------------------------------------
Log a server error. --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader [[request]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[request]] . method ( ) , [[request]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[degrading]] ( RequestHeader [[strokes]] , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , [[strokes]] . method ( ) , [[strokes]] . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 551 ---------------------------------------------
Renders a forbidden page. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[shifted]] ( RequestHeader [[exorcism]] , String [[saunter]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[exorcism]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 552 ---------------------------------------------
Converts an exception to a useful exception. --> [[[FAILED]]]

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[rollers]] ( final Throwable [[power]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[power]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 553 ---------------------------------------------
Called when an error occurs. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[handout]] ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
[Succeeded / Failed / Skipped / Total] 147 / 392 / 15 / 554:  55%|█████▌    | 554/1000 [2:43:26<2:11:34, 17.70s/it][Succeeded / Failed / Skipped / Total] 147 / 392 / 15 / 554:  56%|█████▌    | 555/1000 [2:43:49<2:11:21, 17.71s/it][Succeeded / Failed / Skipped / Total] 147 / 393 / 15 / 555:  56%|█████▌    | 555/1000 [2:43:49<2:11:21, 17.71s/it][Succeeded / Failed / Skipped / Total] 147 / 393 / 15 / 555:  56%|█████▌    | 556/1000 [2:43:55<2:10:54, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 394 / 15 / 556:  56%|█████▌    | 556/1000 [2:43:55<2:10:54, 17.69s/it][Succeeded / Failed / Skipped / Total] 147 / 394 / 15 / 556:  56%|█████▌    | 557/1000 [2:43:57<2:10:24, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 395 / 15 / 557:  56%|█████▌    | 557/1000 [2:43:57<2:10:24, 17.66s/it][Succeeded / Failed / Skipped / Total] 147 / 395 / 15 / 557:  56%|█████▌    | 558/1000 [2:44:43<2:10:28, 17.71s/it][Succeeded / Failed / Skipped / Total] 147 / 396 / 15 / 558:  56%|█████▌    | 558/1000 [2:44:43<2:10:28, 17.71s/it][Succeeded / Failed / Skipped / Total] 147 / 396 / 15 / 558:  56%|█████▌    | 559/1000 [2:45:24<2:10:29, 17.75s/it][Succeeded / Failed / Skipped / Total] 147 / 397 / 15 / 559:  56%|█████▌    | 559/1000 [2:45:24<2:10:29, 17.75s/it][Succeeded / Failed / Skipped / Total] 147 / 397 / 15 / 559:  56%|█████▌    | 560/1000 [2:45:44<2:10:13, 17.76s/it][Succeeded / Failed / Skipped / Total] 147 / 398 / 15 / 560:  56%|█████▌    | 560/1000 [2:45:44<2:10:13, 17.76s/it][Succeeded / Failed / Skipped / Total] 147 / 398 / 15 / 560:  56%|█████▌    | 561/1000 [2:46:23<2:10:12, 17.80s/it][Succeeded / Failed / Skipped / Total] 147 / 399 / 15 / 561:  56%|█████▌    | 561/1000 [2:46:23<2:10:12, 17.80s/it][Succeeded / Failed / Skipped / Total] 147 / 399 / 15 / 561:  56%|█████▌    | 562/1000 [2:46:26<2:09:43, 17.77s/it]--------------------------------------------- Result 554 ---------------------------------------------
Called when an error occurred. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[dissimilar]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 555 ---------------------------------------------
Handles a server error. --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[intifada]] ( RequestHeader [[contagious]] , UsefulException [[sokka]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[sokka]] , [[contagious]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 556 ---------------------------------------------
Called when an error has occurred. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader [[request]] , Throwable [[exception]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[exception]] ) ; logServerError ( [[request]] , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , usefulException ) ; default : return onDevServerError ( [[request]] , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[planetarium]] ( RequestHeader [[pola]] , Throwable [[plates]] ) { try { UsefulException usefulException = throwableToUsefulException ( [[plates]] ) ; logServerError ( [[pola]] , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[pola]] , usefulException ) ; default : return onDevServerError ( [[pola]] , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a handler from a directory. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[disruptor]] ( File directory ) { FileRepository repo = new FilesystemRepository ( directory ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 558 ---------------------------------------------
Finds the method with the given name and returns it.@param cls the class to search for the method@param methodName the name of the method@param parameterTypes the parameter types of the method@return the matching method --> [[[FAILED]]]

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > [[cls]] , final String [[methodName]] , final Class < ? > ... [[parameterTypes]] ) { try { final Method method = [[cls]] . getMethod ( [[methodName]] , [[parameterTypes]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[gen]] ( final Class < ? > [[stein]] , final String [[moderates]] , final Class < ? > ... [[aras]] ) { try { final Method method = [[stein]] . getMethod ( [[moderates]] , [[aras]] ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 559 ---------------------------------------------
Consumes data from this materializer. --> [[[FAILED]]]

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[vainly]] ( Materializer [[bedazzled]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[bedazzled]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 560 ---------------------------------------------
Creates a handler from a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile jarFile , String [[base]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[infirmary]] ( JarFile jarFile , String [[reshape]] ) { FileRepository repo = new JarRepository ( jarFile , Option . apply ( [[reshape]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a handler from a directory and a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[florida]] ( File directory , JarFile jarFile , String base ) { return [[florida]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
[Succeeded / Failed / Skipped / Total] 147 / 400 / 15 / 562:  56%|█████▌    | 562/1000 [2:46:26<2:09:43, 17.77s/it][Succeeded / Failed / Skipped / Total] 147 / 400 / 15 / 562:  56%|█████▋    | 563/1000 [2:47:07<2:09:43, 17.81s/it][Succeeded / Failed / Skipped / Total] 148 / 400 / 15 / 563:  56%|█████▋    | 563/1000 [2:47:07<2:09:43, 17.81s/it][Succeeded / Failed / Skipped / Total] 148 / 400 / 15 / 563:  56%|█████▋    | 564/1000 [2:47:35<2:09:33, 17.83s/it][Succeeded / Failed / Skipped / Total] 149 / 400 / 15 / 564:  56%|█████▋    | 564/1000 [2:47:35<2:09:33, 17.83s/it][Succeeded / Failed / Skipped / Total] 149 / 400 / 15 / 564:  56%|█████▋    | 565/1000 [2:48:10<2:09:29, 17.86s/it][Succeeded / Failed / Skipped / Total] 150 / 400 / 15 / 565:  56%|█████▋    | 565/1000 [2:48:10<2:09:29, 17.86s/it][Succeeded / Failed / Skipped / Total] 150 / 400 / 15 / 565:  57%|█████▋    | 566/1000 [2:48:11<2:08:57, 17.83s/it][Succeeded / Failed / Skipped / Total] 150 / 400 / 16 / 566:  57%|█████▋    | 566/1000 [2:48:11<2:08:57, 17.83s/it][Succeeded / Failed / Skipped / Total] 150 / 400 / 16 / 566:  57%|█████▋    | 567/1000 [2:48:13<2:08:27, 17.80s/it][Succeeded / Failed / Skipped / Total] 150 / 401 / 16 / 567:  57%|█████▋    | 567/1000 [2:48:13<2:08:27, 17.80s/it][Succeeded / Failed / Skipped / Total] 150 / 401 / 16 / 567:  57%|█████▋    | 568/1000 [2:48:17<2:07:59, 17.78s/it][Succeeded / Failed / Skipped / Total] 150 / 402 / 16 / 568:  57%|█████▋    | 568/1000 [2:48:17<2:07:59, 17.78s/it][Succeeded / Failed / Skipped / Total] 150 / 402 / 16 / 568:  57%|█████▋    | 569/1000 [2:48:33<2:07:40, 17.77s/it][Succeeded / Failed / Skipped / Total] 150 / 403 / 16 / 569:  57%|█████▋    | 569/1000 [2:48:33<2:07:40, 17.77s/it][Succeeded / Failed / Skipped / Total] 150 / 403 / 16 / 569:  57%|█████▋    | 570/1000 [2:48:36<2:07:11, 17.75s/it][Succeeded / Failed / Skipped / Total] 150 / 404 / 16 / 570:  57%|█████▋    | 570/1000 [2:48:36<2:07:11, 17.75s/it][Succeeded / Failed / Skipped / Total] 150 / 404 / 16 / 570:  57%|█████▋    | 571/1000 [2:48:39<2:06:42, 17.72s/it][Succeeded / Failed / Skipped / Total] 151 / 404 / 16 / 571:  57%|█████▋    | 571/1000 [2:48:39<2:06:42, 17.72s/it][Succeeded / Failed / Skipped / Total] 151 / 404 / 16 / 571:  57%|█████▋    | 572/1000 [2:49:04<2:06:30, 17.73s/it]--------------------------------------------- Result 562 ---------------------------------------------
Creates a new HTTP entity from a string.@param content the string to parse@param charset the charset to use@return a new HTTP entity --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[content]] , String [[charset]] ) { return new Strict ( ByteString . fromString ( [[content]] , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[melted]] , String [[bubbs]] ) { return new Strict ( ByteString . fromString ( [[melted]] , [[bubbs]] ) , Optional . of ( "text/plain; charset=" + [[bubbs]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 563 ---------------------------------------------
Converts a JSON response to a Result object. --> FFeri implementation --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[feri]] ( int [[lockers]] , JsonNode [[marinated]] ) { return [[feri]] ( [[feri]] , [[marinated]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 564 ---------------------------------------------
Converts a content object to an entity object.@param content The content object to convert.@param charset The charset to use.@return The entity object. --> Eviscerate HICcup@param hiccup@param chambermaids@return --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String [[charset]] ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[eviscerate]] ( Content [[hiccup]] , String [[chambermaids]] ) { String body ; if ( [[hiccup]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 565 ---------------------------------------------
Sends a status response. --> SCHEMA INTERNAL METHODS --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , InputStream content , long contentLength ) { return [[status]] ( [[status]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result [[schultz]] ( int [[koufax]] , InputStream content , long contentLength ) { return [[schultz]] ( [[schultz]] ) . sendInputStream ( content , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 566 ---------------------------------------------
Finds a user by its id. --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 567 ---------------------------------------------
Creates a response with the specified status code and content. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result status ( int [[status]] , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int [[episodes]] , byte [ ] [[nests]] ) { if ( [[nests]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[nests]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 568 ---------------------------------------------
Creates a chunked HTTP entity. --> [[[FAILED]]]

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > contentType ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[offences]] ( Source < ByteString , ? > [[lycans]] , Optional < String > contentType ) { return new Chunked ( [[lycans]] . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 569 ---------------------------------------------
Creates a unique call. --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[dusting]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 570 ---------------------------------------------
Creates a new BuildDocHandler from a list of files. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] [[files]] , String [ ] [[baseDirs]] ) throws IOException { assert ( [[files]] . length == [[baseDirs]] . length ) ; FileRepository [ ] repositories = new FileRepository [ [[files]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[files]] . length ; i ++ ) { File file = [[files]] [ i ] ; String baseDir = [[baseDirs]] [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[colliding]] ( File [ ] [[dipsy]] , String [ ] [[beens]] ) throws IOException { assert ( [[dipsy]] . length == [[beens]] . length ) ; FileRepository [ ] repositories = new FileRepository [ [[dipsy]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[dipsy]] . length ; i ++ ) { File file = [[dipsy]] [ i ] ; String baseDir = [[beens]] [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 571 ---------------------------------------------
Sets the status of a file. --> Sets the status of the fiducial@param strapless@param merovingian@return --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , File [[content]] ) { return status ( status , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result status ( int [[strapless]] , File [[merovingian]] ) { return status ( status , [[merovingian]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 572 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 151 / 405 / 16 / 572:  57%|█████▋    | 572/1000 [2:49:04<2:06:30, 17.73s/it][Succeeded / Failed / Skipped / Total] 151 / 405 / 16 / 572:  57%|█████▋    | 573/1000 [2:49:06<2:06:01, 17.71s/it][Succeeded / Failed / Skipped / Total] 151 / 406 / 16 / 573:  57%|█████▋    | 573/1000 [2:49:06<2:06:01, 17.71s/it][Succeeded / Failed / Skipped / Total] 151 / 406 / 16 / 573:  57%|█████▋    | 574/1000 [2:49:07<2:05:30, 17.68s/it][Succeeded / Failed / Skipped / Total] 151 / 407 / 16 / 574:  57%|█████▋    | 574/1000 [2:49:07<2:05:30, 17.68s/it][Succeeded / Failed / Skipped / Total] 151 / 407 / 16 / 574:  57%|█████▊    | 575/1000 [2:49:21<2:05:10, 17.67s/it][Succeeded / Failed / Skipped / Total] 151 / 408 / 16 / 575:  57%|█████▊    | 575/1000 [2:49:21<2:05:10, 17.67s/it][Succeeded / Failed / Skipped / Total] 151 / 408 / 16 / 575:  58%|█████▊    | 576/1000 [2:49:24<2:04:41, 17.65s/it][Succeeded / Failed / Skipped / Total] 151 / 409 / 16 / 576:  58%|█████▊    | 576/1000 [2:49:24<2:04:41, 17.65s/it][Succeeded / Failed / Skipped / Total] 151 / 409 / 16 / 576:  58%|█████▊    | 577/1000 [2:49:31<2:04:16, 17.63s/it][Succeeded / Failed / Skipped / Total] 151 / 410 / 16 / 577:  58%|█████▊    | 577/1000 [2:49:31<2:04:16, 17.63s/it][Succeeded / Failed / Skipped / Total] 151 / 410 / 16 / 577:  58%|█████▊    | 578/1000 [2:50:00<2:04:07, 17.65s/it][Succeeded / Failed / Skipped / Total] 151 / 411 / 16 / 578:  58%|█████▊    | 578/1000 [2:50:00<2:04:07, 17.65s/it][Succeeded / Failed / Skipped / Total] 151 / 411 / 16 / 578:  58%|█████▊    | 579/1000 [2:50:05<2:03:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 151 / 412 / 16 / 579:  58%|█████▊    | 579/1000 [2:50:05<2:03:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 151 / 412 / 16 / 579:  58%|█████▊    | 580/1000 [2:50:11<2:03:14, 17.61s/it][Succeeded / Failed / Skipped / Total] 151 / 413 / 16 / 580:  58%|█████▊    | 580/1000 [2:50:11<2:03:14, 17.61s/it][Succeeded / Failed / Skipped / Total] 151 / 413 / 16 / 580:  58%|█████▊    | 581/1000 [2:50:36<2:03:02, 17.62s/it][Succeeded / Failed / Skipped / Total] 151 / 414 / 16 / 581:  58%|█████▊    | 581/1000 [2:50:36<2:03:02, 17.62s/it][Succeeded / Failed / Skipped / Total] 151 / 414 / 16 / 581:  58%|█████▊    | 582/1000 [2:50:38<2:02:33, 17.59s/it]Creates a call with the specified fragment. --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[lacerated]] ( String [[spattered]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[spattered]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 573 ---------------------------------------------
Creates a handler from a directory and a jar file. --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[seaview]] ( File directory , JarFile jarFile , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 574 ---------------------------------------------
Returns the preferred language for the specified collection of languages. --> [[[FAILED]]]

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[males]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 575 ---------------------------------------------
Returns the web socket URL. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[cloisters]] ( Http . Request request ) { return [[cloisters]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 576 ---------------------------------------------
Returns the absolute URL for this request. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[goddesses]] ( Http . Request [[almond]] ) { return [[goddesses]] ( [[almond]] . secure ( ) , [[almond]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 577 ---------------------------------------------
Sends a JSON response. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode content , JsonEncoding [[encoding]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[classical]] ( int [[dote]] , JsonNode content , JsonEncoding [[synthetic]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[classical]] ( [[classical]] ) . sendJson ( content , [[synthetic]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 578 ---------------------------------------------
Converts the given object to a JSON representation.@param data the object to convert.@return the JSON representation. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode toJson ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 579 ---------------------------------------------
Converts a JSON node into a value of the specified type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[democratic]] > [[democratic]] fromJson ( JsonNode json , Class < [[democratic]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 580 ---------------------------------------------
Creates a new connection callable. --> [[[FAILED]]]

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[farewells]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[armenian]] ) { try { return [[farewells]] . call ( [[armenian]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 581 ---------------------------------------------
Parses the given string into a JSON object. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[parse]] ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[lockers]] ( String [[comets]] ) { try { return mapper ( ) . readTree ( [[comets]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 582 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 151 / 415 / 16 / 582:  58%|█████▊    | 582/1000 [2:50:38<2:02:33, 17.59s/it][Succeeded / Failed / Skipped / Total] 151 / 415 / 16 / 582:  58%|█████▊    | 583/1000 [2:51:09<2:02:25, 17.62s/it][Succeeded / Failed / Skipped / Total] 151 / 416 / 16 / 583:  58%|█████▊    | 583/1000 [2:51:09<2:02:25, 17.62s/it][Succeeded / Failed / Skipped / Total] 151 / 416 / 16 / 583:  58%|█████▊    | 584/1000 [2:51:31<2:02:11, 17.62s/it][Succeeded / Failed / Skipped / Total] 152 / 416 / 16 / 584:  58%|█████▊    | 584/1000 [2:51:31<2:02:11, 17.62s/it][Succeeded / Failed / Skipped / Total] 152 / 416 / 16 / 584:  58%|█████▊    | 585/1000 [2:51:35<2:01:43, 17.60s/it][Succeeded / Failed / Skipped / Total] 152 / 417 / 16 / 585:  58%|█████▊    | 585/1000 [2:51:35<2:01:43, 17.60s/it][Succeeded / Failed / Skipped / Total] 152 / 417 / 16 / 585:  59%|█████▊    | 586/1000 [2:52:13<2:01:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 152 / 418 / 16 / 586:  59%|█████▊    | 586/1000 [2:52:13<2:01:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 152 / 418 / 16 / 586:  59%|█████▊    | 587/1000 [2:52:29<2:01:21, 17.63s/it][Succeeded / Failed / Skipped / Total] 152 / 419 / 16 / 587:  59%|█████▊    | 587/1000 [2:52:29<2:01:21, 17.63s/it][Succeeded / Failed / Skipped / Total] 152 / 419 / 16 / 587:  59%|█████▉    | 588/1000 [2:52:34<2:00:55, 17.61s/it][Succeeded / Failed / Skipped / Total] 153 / 419 / 16 / 588:  59%|█████▉    | 588/1000 [2:52:34<2:00:55, 17.61s/it][Succeeded / Failed / Skipped / Total] 153 / 419 / 16 / 588:  59%|█████▉    | 589/1000 [2:52:43<2:00:31, 17.59s/it]Parses the content of an input stream. --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[ayers]] ( java . io . InputStream [[symphonic]] ) { try { return mapper ( ) . readTree ( [[symphonic]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 583 ---------------------------------------------
Creates a new connection runnable. --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[block]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[wilfully]] ( final ConnectionRunnable [[refinery]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection connection ) { try { [[refinery]] . run ( connection ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 584 ---------------------------------------------
Display a list of constraints. --> Kublai kublai@param kublai@return --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[kublai]] ( Set < ConstraintDescriptor < ? > > [[defender]] ) { return [[defender]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[kublai]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 585 ---------------------------------------------
Returns the relative path to the specified file or directory. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[manion]] ( String [[miserable]] , String [[preferably]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 586 ---------------------------------------------
Creates a new Router instance. --> [[[FAILED]]]

[[[[Adv]]]]: public static Server forRouter ( Mode [[mode]] , int [[port]] , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( [[port]] ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server forRouter ( Mode [[subtler]] , int [[solely]] , Function < BuiltInComponents , Router > [[airports]] ) { return new Builder ( ) . [[subtler]] ( [[subtler]] ) . http ( [[solely]] ) . build ( [[airports]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 587 ---------------------------------------------
Returns the canonical path of the given URL. --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[namaste]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[namaste]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[namaste]] . empty ( ) && [[namaste]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[namaste]] . push ( comp ) ; else [[namaste]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[namaste]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 588 ---------------------------------------------
Parse a cron expression.@param cron the cron@return the date --> Get the next valid time after the given installation@param installation the name of the installation@return the next valid time after the given installation --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String [[cron]] ) { try { return new CronExpression ( [[cron]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[realty]] ( String [[installation]] ) { try { return new CronExpression ( [[installation]] ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[installation]] , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 589 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 420 / 16 / 589:  59%|█████▉    | 589/1000 [2:52:43<2:00:31, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 420 / 16 / 589:  59%|█████▉    | 590/1000 [2:53:23<2:00:29, 17.63s/it][Succeeded / Failed / Skipped / Total] 153 / 421 / 16 / 590:  59%|█████▉    | 590/1000 [2:53:23<2:00:29, 17.63s/it][Succeeded / Failed / Skipped / Total] 153 / 421 / 16 / 590:  59%|█████▉    | 591/1000 [2:53:32<2:00:05, 17.62s/it][Succeeded / Failed / Skipped / Total] 153 / 422 / 16 / 591:  59%|█████▉    | 591/1000 [2:53:32<2:00:05, 17.62s/it][Succeeded / Failed / Skipped / Total] 153 / 422 / 16 / 591:  59%|█████▉    | 592/1000 [2:53:32<1:59:36, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 423 / 16 / 592:  59%|█████▉    | 592/1000 [2:53:32<1:59:36, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 423 / 16 / 592:  59%|█████▉    | 593/1000 [2:54:00<1:59:25, 17.61s/it][Succeeded / Failed / Skipped / Total] 153 / 424 / 16 / 593:  59%|█████▉    | 593/1000 [2:54:00<1:59:25, 17.61s/it][Succeeded / Failed / Skipped / Total] 153 / 424 / 16 / 593:  59%|█████▉    | 594/1000 [2:54:05<1:58:59, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 425 / 16 / 594:  59%|█████▉    | 594/1000 [2:54:05<1:58:59, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 425 / 16 / 594:  60%|█████▉    | 595/1000 [2:54:15<1:58:36, 17.57s/it][Succeeded / Failed / Skipped / Total] 153 / 426 / 16 / 595:  60%|█████▉    | 595/1000 [2:54:15<1:58:36, 17.57s/it][Succeeded / Failed / Skipped / Total] 153 / 426 / 16 / 595:  60%|█████▉    | 596/1000 [2:54:42<1:58:25, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 427 / 16 / 596:  60%|█████▉    | 596/1000 [2:54:42<1:58:25, 17.59s/it][Succeeded / Failed / Skipped / Total] 153 / 427 / 16 / 596:  60%|█████▉    | 597/1000 [2:54:43<1:57:56, 17.56s/it][Succeeded / Failed / Skipped / Total] 153 / 428 / 16 / 597:  60%|█████▉    | 597/1000 [2:54:43<1:57:56, 17.56s/it][Succeeded / Failed / Skipped / Total] 153 / 428 / 16 / 597:  60%|█████▉    | 598/1000 [2:54:55<1:57:35, 17.55s/it][Succeeded / Failed / Skipped / Total] 153 / 429 / 16 / 598:  60%|█████▉    | 598/1000 [2:54:55<1:57:35, 17.55s/it][Succeeded / Failed / Skipped / Total] 153 / 429 / 16 / 598:  60%|█████▉    | 599/1000 [2:55:02<1:57:11, 17.53s/it]Display a constraint. --> [[[FAILED]]]

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display displayAnnotation = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[bestiality]] ( ConstraintDescriptor < ? > [[armenian]] ) { final Display displayAnnotation = [[armenian]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( displayAnnotation . name ( ) , Collections . unmodifiableList ( Stream . of ( displayAnnotation . attributes ( ) ) . map ( attr -> [[armenian]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 590 ---------------------------------------------
Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[infirmary]] ( ApplicationLoader . Context [[bedspreads]] ) { return initialBuilder . in ( [[bedspreads]] . environment ( ) ) . loadConfig ( [[bedspreads]] . initialConfig ( ) ) . overrides ( overrides ( [[bedspreads]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 591 ---------------------------------------------
Get the next cron interval.@param cron@param date@return --> [[[FAILED]]]

[[[[Adv]]]]: public static long [[cronInterval]] ( String [[cron]] , Date [[date]] ) { try { return new CronExpression ( [[cron]] ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[cron]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[wawa]] ( String [[monopolize]] , Date [[galactic]] ) { try { return new CronExpression ( [[monopolize]] ) . getNextInterval ( [[galactic]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + [[monopolize]] , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 592 ---------------------------------------------
Renders a page. --> [[[FAILED]]]

[[[[Adv]]]]: public static Result [[TODO]] ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result [[DISGUISES]] ( Request [[limitations]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[limitations]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 593 ---------------------------------------------
Returns the binding key for the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[hitchhiked]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 594 ---------------------------------------------
Returns a binding key with the specified annotation. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[converters]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 595 ---------------------------------------------
Creates a session for the specified key and value. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String [[key]] , String [[value]] ) { [[session]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[encrypt]] ( String [[ofyears]] , String [[echoes]] ) { [[encrypt]] ( ) . put ( [[ofyears]] , [[echoes]] ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 596 ---------------------------------------------
Creates a binding from a supplier. --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[cleaned]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 597 ---------------------------------------------
Convenience method to flash. --> [[[FAILED]]]

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String [[key]] , String [[value]] ) { [[flash]] ( ) . put ( [[key]] , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[burial]] ( String [[courses]] , String [[victorious]] ) { [[burial]] ( ) . put ( [[courses]] , [[victorious]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 598 ---------------------------------------------
Creates a binding from this provider. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[marshmallow]] ( final Provider < ? extends T > [[jeong]] ) { return underlying . to ( [[jeong]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 599 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 430 / 16 / 599:  60%|█████▉    | 599/1000 [2:55:02<1:57:11, 17.53s/it][Succeeded / Failed / Skipped / Total] 153 / 430 / 16 / 599:  60%|██████    | 600/1000 [2:55:11<1:56:47, 17.52s/it][Succeeded / Failed / Skipped / Total] 154 / 430 / 16 / 600:  60%|██████    | 600/1000 [2:55:11<1:56:47, 17.52s/it][Succeeded / Failed / Skipped / Total] 154 / 430 / 16 / 600:  60%|██████    | 601/1000 [2:55:50<1:56:44, 17.56s/it][Succeeded / Failed / Skipped / Total] 154 / 431 / 16 / 601:  60%|██████    | 601/1000 [2:55:50<1:56:44, 17.56s/it][Succeeded / Failed / Skipped / Total] 154 / 431 / 16 / 601:  60%|██████    | 602/1000 [2:56:06<1:56:25, 17.55s/it][Succeeded / Failed / Skipped / Total] 154 / 432 / 16 / 602:  60%|██████    | 602/1000 [2:56:06<1:56:25, 17.55s/it][Succeeded / Failed / Skipped / Total] 154 / 432 / 16 / 602:  60%|██████    | 603/1000 [2:56:26<1:56:09, 17.56s/it][Succeeded / Failed / Skipped / Total] 154 / 433 / 16 / 603:  60%|██████    | 603/1000 [2:56:26<1:56:09, 17.56s/it][Succeeded / Failed / Skipped / Total] 154 / 433 / 16 / 603:  60%|██████    | 604/1000 [2:56:29<1:55:42, 17.53s/it][Succeeded / Failed / Skipped / Total] 154 / 434 / 16 / 604:  60%|██████    | 604/1000 [2:56:29<1:55:42, 17.53s/it][Succeeded / Failed / Skipped / Total] 154 / 434 / 16 / 604:  60%|██████    | 605/1000 [2:57:13<1:55:42, 17.58s/it][Succeeded / Failed / Skipped / Total] 155 / 434 / 16 / 605:  60%|██████    | 605/1000 [2:57:13<1:55:42, 17.58s/it][Succeeded / Failed / Skipped / Total] 155 / 434 / 16 / 605:  61%|██████    | 606/1000 [2:57:25<1:55:21, 17.57s/it][Succeeded / Failed / Skipped / Total] 155 / 435 / 16 / 606:  61%|██████    | 606/1000 [2:57:25<1:55:21, 17.57s/it][Succeeded / Failed / Skipped / Total] 155 / 435 / 16 / 606:  61%|██████    | 607/1000 [2:57:27<1:54:53, 17.54s/it]Creates a new client.@param config the configuration@param cache the cache@param materializer the materializer@return the client --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig config , AhcHttpCache [[cache]] , Materializer [[materializer]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[cache]] , [[materializer]] ) ; return new AhcWSClient ( client , [[materializer]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[landscape]] ( AhcWSClientConfig config , AhcHttpCache [[backtrack]] , Materializer [[galvanized]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[backtrack]] , [[galvanized]] ) ; return new AhcWSClient ( client , [[galvanized]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 600 ---------------------------------------------
Creates a binding for the specified implementation. --> Creates a bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged bridged brid --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[paving]] ( final Class < ? extends T > [[physicist]] ) { return underlying . to ( [[physicist]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
--------------------------------------------- Result 601 ---------------------------------------------
Converts the given key to this binding. --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[commits]] ( final BindingKey < ? extends T > [[addicts]] ) { return underlying . to ( [[addicts]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 602 ---------------------------------------------
Creates a reader from a map of evolutions. --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[honesty]] . EvolutionsReader [[bartel]] ( Map < String , List < Evolution > > [[honesty]] ) { return new SimpleEvolutionsReader ( [[honesty]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 603 ---------------------------------------------
Returns a list of available languages. --> [[[FAILED]]]

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( langs . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[painlessly]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[kneels]] = Scala . asJava ( langs . availables ( ) ) ; return [[kneels]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 604 ---------------------------------------------
Creates a binding from the given provider. --> [[[FAILED]]]

[[[[Adv]]]]: public < P [[extends]] Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P [[emotionally]] Provider < ? extends T > > Binding < T > toProvider ( final Class < P > [[armory]] ) { return underlying . toProvider ( [[armory]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 605 ---------------------------------------------
Creates a default evolution database.@param evolutions@return --> Sleuthing encircling evolution --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > [[map]] = new HashMap < String , List < Evolution > > ( ) ; [[map]] . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( [[map]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[encircling]] . EvolutionsReader [[find]] ( Evolution ... [[encircling]] ) { Map < String , List < Evolution > > [[sleuthing]] = new HashMap < String , List < Evolution > > ( ) ; [[sleuthing]] . put ( "default" , Arrays . asList ( [[encircling]] ) ) ; return fromMap ( [[sleuthing]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 606 ---------------------------------------------
Returns the preferred language for the specified application. --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[cabdriver]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 607 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 436 / 16 / 607:  61%|██████    | 607/1000 [2:57:27<1:54:53, 17.54s/it][Succeeded / Failed / Skipped / Total] 155 / 436 / 16 / 607:  61%|██████    | 608/1000 [2:58:05<1:54:49, 17.57s/it][Succeeded / Failed / Skipped / Total] 155 / 437 / 16 / 608:  61%|██████    | 608/1000 [2:58:05<1:54:49, 17.57s/it][Succeeded / Failed / Skipped / Total] 155 / 437 / 16 / 608:  61%|██████    | 609/1000 [2:58:14<1:54:26, 17.56s/it][Succeeded / Failed / Skipped / Total] 155 / 438 / 16 / 609:  61%|██████    | 609/1000 [2:58:14<1:54:26, 17.56s/it][Succeeded / Failed / Skipped / Total] 155 / 438 / 16 / 609:  61%|██████    | 610/1000 [2:58:19<1:54:00, 17.54s/it][Succeeded / Failed / Skipped / Total] 155 / 439 / 16 / 610:  61%|██████    | 610/1000 [2:58:19<1:54:00, 17.54s/it][Succeeded / Failed / Skipped / Total] 155 / 439 / 16 / 610:  61%|██████    | 611/1000 [2:58:24<1:53:35, 17.52s/it][Succeeded / Failed / Skipped / Total] 155 / 440 / 16 / 611:  61%|██████    | 611/1000 [2:58:24<1:53:35, 17.52s/it][Succeeded / Failed / Skipped / Total] 155 / 440 / 16 / 611:  61%|██████    | 612/1000 [2:58:49<1:53:22, 17.53s/it][Succeeded / Failed / Skipped / Total] 155 / 441 / 16 / 612:  61%|██████    | 612/1000 [2:58:49<1:53:22, 17.53s/it][Succeeded / Failed / Skipped / Total] 155 / 441 / 16 / 612:  61%|██████▏   | 613/1000 [2:59:12<1:53:08, 17.54s/it][Succeeded / Failed / Skipped / Total] 155 / 442 / 16 / 613:  61%|██████▏   | 613/1000 [2:59:12<1:53:08, 17.54s/it][Succeeded / Failed / Skipped / Total] 155 / 442 / 16 / 613:  61%|██████▏   | 614/1000 [2:59:39<1:52:56, 17.56s/it][Succeeded / Failed / Skipped / Total] 155 / 443 / 16 / 614:  61%|██████▏   | 614/1000 [2:59:39<1:52:56, 17.56s/it][Succeeded / Failed / Skipped / Total] 155 / 443 / 16 / 614:  62%|██████▏   | 615/1000 [2:59:42<1:52:29, 17.53s/it][Succeeded / Failed / Skipped / Total] 155 / 444 / 16 / 615:  62%|██████▏   | 615/1000 [2:59:42<1:52:29, 17.53s/it][Succeeded / Failed / Skipped / Total] 155 / 444 / 16 / 615:  62%|██████▏   | 616/1000 [2:59:59<1:52:12, 17.53s/it]Waits for the specified amount of time to complete. --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long [[amount]] , final TimeUnit [[unit]] ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( [[amount]] , [[unit]] ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[donkeys]] ( final CompletionStage < A > [[episodes]] , final long [[contagious]] , final TimeUnit [[timely]] ) { requireNonNull ( [[episodes]] , "Null stage" ) ; requireNonNull ( [[timely]] , "Null unit" ) ; FiniteDuration [[alphas]] = FiniteDuration . apply ( [[contagious]] , [[timely]] ) ; return toJava ( delegate . timeout ( [[alphas]] , Scala . asScalaWithFuture ( ( ) -> [[episodes]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 608 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[horseshit]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 609 ---------------------------------------------
Creates a new application builder with the specified configuration. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[env]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[env]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[policemen]] ( Function < Environment , Config > load ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[boot]] ) -> new play . api . Configuration ( load . apply ( new Environment ( [[boot]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 610 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[employ]] ( com . google . inject . Module ... [[emotionally]] ) { return [[employ]] ( Guiceable . [[emotionally]] ( [[emotionally]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 611 ---------------------------------------------
Loads the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[persevering]] ( play . api . inject . Module ... [[nullified]] ) { return [[persevering]] ( Guiceable . [[nullified]] ( [[nullified]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 612 ---------------------------------------------
Creates a new application builder with the specified modules. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[env]] , play . api . Configuration [[conf]] ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( [[env]] ) , [[conf]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[males]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[formulas]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment [[dragan]] , play . api . Configuration [[salim]] ) -> Scala . toSeq ( [[formulas]] . apply ( new Environment ( [[dragan]] ) , [[salim]] . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 613 ---------------------------------------------
Creates a new Guice application builder. --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[transfigured]] ( play . api . inject . guice . GuiceApplicationBuilder builder ) { return new GuiceApplicationBuilder ( builder ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 614 ---------------------------------------------
Loads the specified bindings. --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[shtick]] ( play . api . inject . Binding < ? > ... [[batboy]] ) { return [[shtick]] ( Guiceable . [[batboy]] ( [[batboy]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 615 ---------------------------------------------
Encodes the given cookie. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; [[encode]] ( [[buf]] , cookie ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[okinawa]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[abused]] = new StringBuilder ( ) ; [[okinawa]] ( [[abused]] , cookie ) ; return stripTrailingSeparator ( [[abused]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 616 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 445 / 16 / 616:  62%|██████▏   | 616/1000 [2:59:59<1:52:12, 17.53s/it][Succeeded / Failed / Skipped / Total] 155 / 445 / 16 / 616:  62%|██████▏   | 617/1000 [3:00:26<1:52:00, 17.55s/it][Succeeded / Failed / Skipped / Total] 156 / 445 / 16 / 617:  62%|██████▏   | 617/1000 [3:00:26<1:52:00, 17.55s/it][Succeeded / Failed / Skipped / Total] 156 / 445 / 16 / 617:  62%|██████▏   | 618/1000 [3:01:21<1:52:05, 17.61s/it][Succeeded / Failed / Skipped / Total] 157 / 445 / 16 / 618:  62%|██████▏   | 618/1000 [3:01:21<1:52:05, 17.61s/it][Succeeded / Failed / Skipped / Total] 157 / 445 / 16 / 618:  62%|██████▏   | 619/1000 [3:02:09<1:52:07, 17.66s/it][Succeeded / Failed / Skipped / Total] 157 / 446 / 16 / 619:  62%|██████▏   | 619/1000 [3:02:09<1:52:07, 17.66s/it][Succeeded / Failed / Skipped / Total] 157 / 446 / 16 / 619:  62%|██████▏   | 620/1000 [3:02:11<1:51:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 157 / 447 / 16 / 620:  62%|██████▏   | 620/1000 [3:02:11<1:51:40, 17.63s/it][Succeeded / Failed / Skipped / Total] 157 / 447 / 16 / 620:  62%|██████▏   | 621/1000 [3:02:15<1:51:13, 17.61s/it]Creates a new EntityManager. --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[congressional]] ( ) { Deque < EntityManager > [[headpiece]] = this . emStack ( "[[Snubbed]]" == "[[Snubbed]]" ) ; if ( [[headpiece]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[headpiece]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 617 ---------------------------------------------
Checks if the given class array is assignable to the given toClassArray.@param classArray the class array to check.@param toClassArray the toClassArray to check.@param autoboxing true if the class array should be autoboxed.@return true if the class array is assignable to the given toClassArray. --> Computes the Euclidean distance between the supplied crummy and the suppliedtoClassArray@param crummy@param toClassArray@param autoboxing@return --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] [[classArray]] , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( [[classArray]] ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( [[classArray]] == null ) { [[classArray]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[i]] = 0 ; [[i]] < [[classArray]] . length ; [[i]] ++ ) { if ( [[isAssignable]] ( [[classArray]] [ [[i]] ] , toClassArray [ [[i]] ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[djinni]] ( Class < ? > [ ] [[crummy]] , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( [[crummy]] ) != arrayGetLength ( toClassArray ) ) { return "False" != "False" ; } if ( [[crummy]] == null ) { [[crummy]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[bebel]] = 0 ; [[bebel]] < [[crummy]] . length ; [[bebel]] ++ ) { if ( [[djinni]] ( [[crummy]] [ [[bebel]] ] , toClassArray [ [[bebel]] ] , autoboxing ) == "False" != "False" ) { return "False" != "False" ; } } return "[[Earth]]" == "[[Earth]]" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 618 ---------------------------------------------
Evolve the evolution of the given database. --> Evolve a strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength strength --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database [[database]] , boolean [[autocommit]] , String [[schema]] ) { DatabaseEvolutions [[evolutions]] = new DatabaseEvolutions ( [[database]] . asScala ( ) , [[schema]] ) ; [[evolutions]] . evolve ( [[evolutions]] . resetScripts ( ) , [[autocommit]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[phd]] ( Database [[strengthening]] , boolean [[rosslyn]] , String [[peeks]] ) { DatabaseEvolutions [[archaeologists]] = new DatabaseEvolutions ( [[strengthening]] . asScala ( ) , [[peeks]] ) ; [[archaeologists]] . evolve ( [[archaeologists]] . resetScripts ( ) , [[rosslyn]] ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 619 ---------------------------------------------
Gets the entity manager stack. --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[miserable]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[lamontagne]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[lamontagne]] != null ) { return ( Deque < EntityManager > ) [[lamontagne]] ; } else { Deque < EntityManager > ems = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , ems ) ; return ems ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 620 ---------------------------------------------
Converts an array of arguments to a list of errors. --> [[[FAILED]]]

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] [[arguments]] ) { if ( [[arguments]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[arguments]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[landslide]] ( Object [ ] [[cancellations]] ) { if ( [[cancellations]] == null ) { return Collections . emptyList ( ) ; } List < Object > converted = Arrays . stream ( [[cancellations]] ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( converted ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 621 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 157 / 448 / 16 / 621:  62%|██████▏   | 621/1000 [3:02:15<1:51:13, 17.61s/it][Succeeded / Failed / Skipped / Total] 157 / 448 / 16 / 621:  62%|██████▏   | 622/1000 [3:02:34<1:50:57, 17.61s/it][Succeeded / Failed / Skipped / Total] 157 / 449 / 16 / 622:  62%|██████▏   | 622/1000 [3:02:34<1:50:57, 17.61s/it][Succeeded / Failed / Skipped / Total] 157 / 449 / 16 / 622:  62%|██████▏   | 623/1000 [3:02:38<1:50:31, 17.59s/it][Succeeded / Failed / Skipped / Total] 157 / 450 / 16 / 623:  62%|██████▏   | 623/1000 [3:02:38<1:50:31, 17.59s/it][Succeeded / Failed / Skipped / Total] 157 / 450 / 16 / 623:  62%|██████▏   | 624/1000 [3:02:46<1:50:07, 17.57s/it][Succeeded / Failed / Skipped / Total] 158 / 450 / 16 / 624:  62%|██████▏   | 624/1000 [3:02:46<1:50:07, 17.57s/it][Succeeded / Failed / Skipped / Total] 158 / 450 / 16 / 624:  62%|██████▎   | 625/1000 [3:03:23<1:50:02, 17.61s/it][Succeeded / Failed / Skipped / Total] 158 / 451 / 16 / 625:  62%|██████▎   | 625/1000 [3:03:23<1:50:02, 17.61s/it][Succeeded / Failed / Skipped / Total] 158 / 451 / 16 / 625:  63%|██████▎   | 626/1000 [3:03:25<1:49:34, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 451 / 16 / 626:  63%|██████▎   | 626/1000 [3:03:25<1:49:34, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 451 / 16 / 626:  63%|██████▎   | 627/1000 [3:04:00<1:49:28, 17.61s/it][Succeeded / Failed / Skipped / Total] 159 / 452 / 16 / 627:  63%|██████▎   | 627/1000 [3:04:00<1:49:28, 17.61s/it][Succeeded / Failed / Skipped / Total] 159 / 452 / 16 / 627:  63%|██████▎   | 628/1000 [3:04:02<1:49:00, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 453 / 16 / 628:  63%|██████▎   | 628/1000 [3:04:02<1:49:00, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 453 / 16 / 628:  63%|██████▎   | 629/1000 [3:04:16<1:48:41, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 454 / 16 / 629:  63%|██████▎   | 629/1000 [3:04:16<1:48:41, 17.58s/it][Succeeded / Failed / Skipped / Total] 159 / 454 / 16 / 629:  63%|██████▎   | 630/1000 [3:04:29<1:48:21, 17.57s/it]Pushes an entity manager onto the stack. --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager [[em]] , boolean [[threadLocalFallback]] ) { Deque < EntityManager > ems = this . emStack ( [[threadLocalFallback]] ) ; if ( [[em]] != null ) { ems . push ( [[em]] ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[magnanimous]] ( EntityManager [[appalachian]] , boolean [[motorbike]] ) { Deque < EntityManager > ems = this . emStack ( [[motorbike]] ) ; if ( [[appalachian]] != null ) { ems . push ( [[appalachian]] ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 622 ---------------------------------------------
Fills the form with the specified value. --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[wors]] ( T [[oppenheimer]] ) { if ( [[oppenheimer]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[oppenheimer]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 623 ---------------------------------------------
Returns a list of global validation errors. --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[inexperienced]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 624 ---------------------------------------------
Returns the value associated with the given key. --> Fires a probe. --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[firebombing]] ( String key ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( key ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 625 ---------------------------------------------
Parses the given text and converts it to the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[spectre]] > [[spectre]] parse ( String text , Class < [[spectre]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 626 ---------------------------------------------
Converts the supplied text into an object of the specified type. --> Converts the supplied text into an afte. --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[afte]] > [[afte]] parse ( Field field , String text ) { return ( [[afte]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 627 ---------------------------------------------
Converts the specified object to a string. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Louses]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Louses]] . class ) ) { return conversion . convert ( t , [[Louses]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 628 ---------------------------------------------
Prints a field to the console.@param field the field to print@param t the object to print@return the string representation of the field --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Devoe]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 629 ---------------------------------------------
Creates a new dynamic form. --> [[[FAILED]]]

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > value ) { Form < Dynamic > [[form]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[form]] . rawData ( ) , [[form]] . files ( ) , [[form]] . errors ( ) , [[form]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[vacations]] ( Map < String , Object > value ) { Form < Dynamic > [[microchips]] = super . fill ( new Dynamic ( value ) ) ; return new DynamicForm ( [[microchips]] . rawData ( ) , [[microchips]] . files ( ) , [[microchips]] . errors ( ) , [[microchips]] . value ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 630 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 159 / 455 / 16 / 630:  63%|██████▎   | 630/1000 [3:04:29<1:48:21, 17.57s/it][Succeeded / Failed / Skipped / Total] 159 / 455 / 16 / 630:  63%|██████▎   | 631/1000 [3:04:39<1:47:59, 17.56s/it][Succeeded / Failed / Skipped / Total] 159 / 456 / 16 / 631:  63%|██████▎   | 631/1000 [3:04:39<1:47:59, 17.56s/it][Succeeded / Failed / Skipped / Total] 159 / 456 / 16 / 631:  63%|██████▎   | 632/1000 [3:05:26<1:47:58, 17.61s/it][Succeeded / Failed / Skipped / Total] 160 / 456 / 16 / 632:  63%|██████▎   | 632/1000 [3:05:26<1:47:58, 17.61s/it][Succeeded / Failed / Skipped / Total] 160 / 456 / 16 / 632:  63%|██████▎   | 633/1000 [3:06:31<1:48:08, 17.68s/it][Succeeded / Failed / Skipped / Total] 160 / 457 / 16 / 633:  63%|██████▎   | 633/1000 [3:06:31<1:48:08, 17.68s/it][Succeeded / Failed / Skipped / Total] 160 / 457 / 16 / 633:  63%|██████▎   | 634/1000 [3:07:38<1:48:19, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 458 / 16 / 634:  63%|██████▎   | 634/1000 [3:07:38<1:48:19, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 458 / 16 / 634:  64%|██████▎   | 635/1000 [3:07:48<1:47:56, 17.75s/it][Succeeded / Failed / Skipped / Total] 160 / 459 / 16 / 635:  64%|██████▎   | 635/1000 [3:07:48<1:47:56, 17.75s/it][Succeeded / Failed / Skipped / Total] 160 / 459 / 16 / 635:  64%|██████▎   | 636/1000 [3:08:06<1:47:39, 17.75s/it]Converts errors to JSON. --> [[[FAILED]]]

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[astound]] ( Lang [[cheeked]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[cheeked]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[cheeked]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[cheeked]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 631 ---------------------------------------------
Prints the given type descriptor.@param desc the type descriptor@param t the t@return the string --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Sleepin]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Sleepin]] . class ) ) ) { return ( [[Sleepin]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Sleepin]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Sleepin]] . class ) ) { return conversion . convert ( t , [[Sleepin]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 632 ---------------------------------------------
Registers an optional converter. --> Converts the source type to the target type. --> Socre: 1.0

[[[[Adv]]]]: private Formatters [[registerOptional]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters [[agains]] ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { if ( sourceType . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 633 ---------------------------------------------
Encodes the cookie.@param cookie the cookie@return the encoded cookie --> [[[FAILED]]]

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[shinzo]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String value = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder buf = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( buf , name , value ) ; } else { add ( buf , name , value ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( buf , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 634 ---------------------------------------------
Converts a list of objects to an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[abstractions]] ( java . util . List < T > [[bayonne]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[bayonne]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 635 ---------------------------------------------
Selects nodes in the specified path from the supplied object. --> [[[FAILED]]]

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object [[node]] ) { return [[selectNodes]] ( path , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[slurps]] ( String path , Object [[apprehensive]] ) { return [[slurps]] ( path , [[apprehensive]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 636 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 460 / 16 / 636:  64%|██████▎   | 636/1000 [3:08:06<1:47:39, 17.75s/it][Succeeded / Failed / Skipped / Total] 160 / 460 / 16 / 636:  64%|██████▎   | 637/1000 [3:08:32<1:47:26, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 461 / 16 / 637:  64%|██████▎   | 637/1000 [3:08:32<1:47:26, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 461 / 16 / 637:  64%|██████▍   | 638/1000 [3:08:52<1:47:10, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 462 / 16 / 638:  64%|██████▍   | 638/1000 [3:08:52<1:47:10, 17.76s/it][Succeeded / Failed / Skipped / Total] 160 / 462 / 16 / 638:  64%|██████▍   | 639/1000 [3:09:40<1:47:09, 17.81s/it][Succeeded / Failed / Skipped / Total] 160 / 463 / 16 / 639:  64%|██████▍   | 639/1000 [3:09:40<1:47:09, 17.81s/it][Succeeded / Failed / Skipped / Total] 160 / 463 / 16 / 639:  64%|██████▍   | 640/1000 [3:09:53<1:46:49, 17.80s/it][Succeeded / Failed / Skipped / Total] 160 / 464 / 16 / 640:  64%|██████▍   | 640/1000 [3:09:53<1:46:49, 17.80s/it][Succeeded / Failed / Skipped / Total] 160 / 464 / 16 / 640:  64%|██████▍   | 641/1000 [3:10:34<1:46:43, 17.84s/it][Succeeded / Failed / Skipped / Total] 160 / 465 / 16 / 641:  64%|██████▍   | 641/1000 [3:10:34<1:46:43, 17.84s/it][Succeeded / Failed / Skipped / Total] 160 / 465 / 16 / 641:  64%|██████▍   | 642/1000 [3:10:43<1:46:21, 17.82s/it]Registers a formatter for the given class. --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale locale ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Kampf]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[intensely]] , Locale locale ) throws java . [[intensely]] . ParseException { return formatter . parse ( [[intensely]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 637 ---------------------------------------------
Converts an array into an immutable collection. --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[cheaper]] ( T [ ] [[aeroplanes]] ) { return [[cheaper]] ( java . util . Arrays . asList ( [[aeroplanes]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 638 ---------------------------------------------
Creates a sequence of values from an array. --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[afoot]] ( T ... [[prudence]] ) { return toSeq ( [[prudence]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 639 ---------------------------------------------
Creates a new Flow from a Graph.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn>@param <FlowIn --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > [[splitter]] , Graph < UniformFanInShape < Out , Out > , ? > [[mergeStrategy]] , Flow < FlowIn , Out , ? > [[flow]] ) { return [[splitter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > [[mallick]] , Graph < UniformFanInShape < Out , Out > , ? > [[anj]] , Flow < FlowIn , Out , ? > [[pogo]] ) { return [[mallick]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 640 ---------------------------------------------
Creates a new Flow with the specified splitter.@param <In>@param <FlowIn>@param <Out>@param <FlowIn>@param <Out>@param splitter@param <Out>@return --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , [[FlowIn]] , [[Out]] > Flow < In , [[Out]] , ? > bypassWith ( Function < In , F . Either < [[FlowIn]] , [[Out]] > > [[splitter]] , Flow < [[FlowIn]] , [[Out]] , ? > [[flow]] ) { return bypassWith ( Flow . < In > create ( ) . map ( [[splitter]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[flow]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , [[prank]] , [[Daycare]] > Flow < In , [[Daycare]] , ? > bypassWith ( Function < In , F . Either < [[prank]] , [[Daycare]] > > [[ourselves]] , Flow < [[prank]] , [[Daycare]] , ? > [[nega]] ) { return bypassWith ( Flow . < In > create ( ) . map ( [[ourselves]] :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , [[nega]] ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 641 ---------------------------------------------
Creates a new WebSocket. --> [[[FAILED]]]

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[request]] ) { return f . apply ( [[request]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[othe]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[othe]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader [[morphology]] ) { return f . apply ( [[morphology]] ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 642 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 466 / 16 / 642:  64%|██████▍   | 642/1000 [3:10:43<1:46:21, 17.82s/it][Succeeded / Failed / Skipped / Total] 160 / 466 / 16 / 642:  64%|██████▍   | 643/1000 [3:12:18<1:46:46, 17.95s/it][Succeeded / Failed / Skipped / Total] 160 / 467 / 16 / 643:  64%|██████▍   | 643/1000 [3:12:18<1:46:46, 17.95s/it][Succeeded / Failed / Skipped / Total] 160 / 467 / 16 / 643:  64%|██████▍   | 644/1000 [3:12:19<1:46:18, 17.92s/it][Succeeded / Failed / Skipped / Total] 160 / 468 / 16 / 644:  64%|██████▍   | 644/1000 [3:12:19<1:46:18, 17.92s/it][Succeeded / Failed / Skipped / Total] 160 / 468 / 16 / 644:  64%|██████▍   | 645/1000 [3:12:19<1:45:51, 17.89s/it][Succeeded / Failed / Skipped / Total] 160 / 469 / 16 / 645:  64%|██████▍   | 645/1000 [3:12:19<1:45:51, 17.89s/it][Succeeded / Failed / Skipped / Total] 160 / 469 / 16 / 645:  65%|██████▍   | 646/1000 [3:12:32<1:45:30, 17.88s/it]Creates a MappedWebSocket acceptor for the given type. --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[betrayal]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[betrayal]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[betrayal]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 643 ---------------------------------------------
Sets the workaround for the given object. --> [[[FAILED]]]

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject [[o]] ) { if ( [[o]] == null || [[o]] . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) [[o]] ; if ( ! [[o]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[o]] . setAccessible ( "[[True]]" == "[[True]]" ) ; return "[[True]]" == "[[True]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[fetuses]] ( final AccessibleObject [[whatthe]] ) { if ( [[whatthe]] == null || [[whatthe]] . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) [[whatthe]] ; if ( ! [[whatthe]] . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { [[whatthe]] . setAccessible ( "[[Bruiser]]" == "[[Bruiser]]" ) ; return "[[Bruiser]]" == "[[Bruiser]]" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 644 ---------------------------------------------
Returns the message at the specified key. --> [[[FAILED]]]

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[key]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[spouses]] ( String [[managers]] , Object ... [[egyptologist]] ) { return messagesApi . get ( lang , [[managers]] , [[egyptologist]] ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 645 ---------------------------------------------
Calculates the total cost of the given executable. --> [[[FAILED]]]

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable [[executable]] ) { final Class < ? > [ ] [[destArgs]] = [[executable]] . getParameterTypes ( ) ; final boolean [[isVarArgs]] = [[executable]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[calzone]] ( final Class < ? > [ ] srcArgs , final Executable [[broadcaster]] ) { final Class < ? > [ ] [[highlights]] = [[broadcaster]] . getParameterTypes ( ) ; final boolean [[bilge]] = [[broadcaster]] . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 646 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 470 / 16 / 646:  65%|██████▍   | 646/1000 [3:12:32<1:45:30, 17.88s/it][Succeeded / Failed / Skipped / Total] 160 / 470 / 16 / 646:  65%|██████▍   | 647/1000 [3:13:00<1:45:18, 17.90s/it][Succeeded / Failed / Skipped / Total] 160 / 471 / 16 / 647:  65%|██████▍   | 647/1000 [3:13:00<1:45:18, 17.90s/it][Succeeded / Failed / Skipped / Total] 160 / 471 / 16 / 647:  65%|██████▍   | 648/1000 [3:13:15<1:44:58, 17.89s/it][Succeeded / Failed / Skipped / Total] 160 / 472 / 16 / 648:  65%|██████▍   | 648/1000 [3:13:15<1:44:58, 17.89s/it][Succeeded / Failed / Skipped / Total] 160 / 472 / 16 / 648:  65%|██████▍   | 649/1000 [3:14:05<1:44:58, 17.94s/it][Succeeded / Failed / Skipped / Total] 160 / 473 / 16 / 649:  65%|██████▍   | 649/1000 [3:14:05<1:44:58, 17.94s/it][Succeeded / Failed / Skipped / Total] 160 / 473 / 16 / 649:  65%|██████▌   | 650/1000 [3:14:10<1:44:33, 17.92s/it]Register an annotation converter.@param <A> the type parameter@param <T> the type parameter@param clazz the clazz@param formatter the formatter@return the Formatters --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > [[annotationType]] = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( [[sourceType]] . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) [[sourceType]] . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[annotationType]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[annotationType]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[annotationType]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > [[femoral]] = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[fluctuate]] , TypeDescriptor targetType ) { return ( [[fluctuate]] . getAnnotation ( [[femoral]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[fluctuate]] , TypeDescriptor targetType ) { final A a = ( A ) [[fluctuate]] . getAnnotation ( [[femoral]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[fluctuate]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + [[femoral]] . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[fluctuate]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( [[femoral]] ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[fluctuate]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( [[femoral]] ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[fluctuate]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + [[femoral]] . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 647 ---------------------------------------------
Computes the cost of a primitive promotion.@param srcClass the source class@param destClass the destination class@return the cost --> [[[FAILED]]]

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float [[cost]] = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[multi]] ( final Class < ? > srcClass , final Class < ? > destClass ) { float [[websites]] = 0.0f ; Class < ? > cls = srcClass ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 648 ---------------------------------------------
Creates a new parallel sorter. --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[gulley]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 649 ---------------------------------------------
Returns the message at the specified keys@param keys@param args@return --> [[[FAILED]]]

[[[[Adv]]]]: public String [[at]] ( List < String > [[keys]] , Object ... [[args]] ) { return messagesApi . get ( lang , [[keys]] , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[nevermore]] ( List < String > [[bartleby]] , Object ... [[albeit]] ) { return messagesApi . get ( lang , [[bartleby]] , [[albeit]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 650 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 160 / 474 / 16 / 650:  65%|██████▌   | 650/1000 [3:14:10<1:44:33, 17.92s/it][Succeeded / Failed / Skipped / Total] 160 / 474 / 16 / 650:  65%|██████▌   | 651/1000 [3:14:33<1:44:18, 17.93s/it][Succeeded / Failed / Skipped / Total] 161 / 474 / 16 / 651:  65%|██████▌   | 651/1000 [3:14:33<1:44:18, 17.93s/it][Succeeded / Failed / Skipped / Total] 161 / 474 / 16 / 651:  65%|██████▌   | 652/1000 [3:14:34<1:43:51, 17.91s/it][Succeeded / Failed / Skipped / Total] 161 / 474 / 17 / 652:  65%|██████▌   | 652/1000 [3:14:34<1:43:51, 17.91s/it][Succeeded / Failed / Skipped / Total] 161 / 474 / 17 / 652:  65%|██████▌   | 653/1000 [3:14:45<1:43:29, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 475 / 17 / 653:  65%|██████▌   | 653/1000 [3:14:45<1:43:29, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 475 / 17 / 653:  65%|██████▌   | 654/1000 [3:14:46<1:43:02, 17.87s/it][Succeeded / Failed / Skipped / Total] 161 / 476 / 17 / 654:  65%|██████▌   | 654/1000 [3:14:46<1:43:02, 17.87s/it][Succeeded / Failed / Skipped / Total] 161 / 476 / 17 / 654:  66%|██████▌   | 655/1000 [3:15:18<1:42:52, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 477 / 17 / 655:  66%|██████▌   | 655/1000 [3:15:18<1:42:52, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 477 / 17 / 655:  66%|██████▌   | 656/1000 [3:15:18<1:42:25, 17.86s/it]Creates a new database from the supplied parameters. --> [[[FAILED]]]

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String [[url]] , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , [[url]] , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[peralta]] ( String [[grazed]] , String [[ngai]] , Map < String , ? extends Object > [[downstate]] ) { return [[peralta]] ( "default" , [[grazed]] , [[ngai]] , [[downstate]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 651 ---------------------------------------------
Cast a numeric type to another type. --> Visits all of the specified types. --> Socre: 1.0

[[[[Adv]]]]: public void [[cast_numeric]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[cast_numeric]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void [[celebs]] ( Type from , Type to ) { if ( from != to ) { if ( from == Type . DOUBLE_TYPE ) { if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; [[celebs]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; [[celebs]] ( Type . INT_TYPE , to ) ; } } else if ( from == Type . LONG_TYPE ) { if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; [[celebs]] ( Type . INT_TYPE , to ) ; } } else { if ( to == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( to == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( to == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( to == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( to == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( to == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 652 ---------------------------------------------
Emits a field instruction. --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
Returns the cost of an object transformation. --> [[[FAILED]]]

[[[[Adv]]]]: private static float [[getObjectTransformationCost]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float [[chums]] ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 654 ---------------------------------------------
Loads an argument. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[borgo]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 655 ---------------------------------------------
Creates a play flow. --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , [[Out]] > Flow < In , [[Out]] , ? > [[actorRef]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[overflowStrategy]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , [[Out]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef [[v1]] ) { return props . apply ( [[v1]] ) ; } } , bufferSize , [[overflowStrategy]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , [[Piano]] > Flow < In , [[Piano]] , ? > [[yielded]] ( Function < ActorRef , Props > props , int bufferSize , OverflowStrategy [[baseness]] , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , [[Piano]] > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef [[waterfall]] ) { return props . apply ( [[waterfall]] ) ; } } , bufferSize , [[baseness]] , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 656 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 161 / 478 / 17 / 656:  66%|██████▌   | 656/1000 [3:15:18<1:42:25, 17.86s/it][Succeeded / Failed / Skipped / Total] 161 / 478 / 17 / 656:  66%|██████▌   | 657/1000 [3:15:52<1:42:15, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 479 / 17 / 657:  66%|██████▌   | 657/1000 [3:15:52<1:42:15, 17.89s/it][Succeeded / Failed / Skipped / Total] 161 / 479 / 17 / 657:  66%|██████▌   | 658/1000 [3:16:24<1:42:04, 17.91s/it][Succeeded / Failed / Skipped / Total] 161 / 480 / 17 / 658:  66%|██████▌   | 658/1000 [3:16:24<1:42:04, 17.91s/it][Succeeded / Failed / Skipped / Total] 161 / 480 / 17 / 658:  66%|██████▌   | 659/1000 [3:17:14<1:42:03, 17.96s/it][Succeeded / Failed / Skipped / Total] 162 / 480 / 17 / 659:  66%|██████▌   | 659/1000 [3:17:14<1:42:03, 17.96s/it][Succeeded / Failed / Skipped / Total] 162 / 480 / 17 / 659:  66%|██████▌   | 660/1000 [3:17:55<1:41:57, 17.99s/it][Succeeded / Failed / Skipped / Total] 162 / 481 / 17 / 660:  66%|██████▌   | 660/1000 [3:17:55<1:41:57, 17.99s/it][Succeeded / Failed / Skipped / Total] 162 / 481 / 17 / 660:  66%|██████▌   | 661/1000 [3:18:04<1:41:34, 17.98s/it][Succeeded / Failed / Skipped / Total] 163 / 481 / 17 / 661:  66%|██████▌   | 661/1000 [3:18:04<1:41:34, 17.98s/it][Succeeded / Failed / Skipped / Total] 163 / 481 / 17 / 661:  66%|██████▌   | 662/1000 [3:18:13<1:41:12, 17.97s/it][Succeeded / Failed / Skipped / Total] 163 / 482 / 17 / 662:  66%|██████▌   | 662/1000 [3:18:13<1:41:12, 17.97s/it][Succeeded / Failed / Skipped / Total] 163 / 482 / 17 / 662:  66%|██████▋   | 663/1000 [3:18:16<1:40:47, 17.94s/it]Puts the supplied type into the stack. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[zero_or_null]] ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[torturer]] ( Type [[hwang]] ) { if ( TypeUtils . isPrimitive ( [[hwang]] ) ) { switch ( [[hwang]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 657 ---------------------------------------------
Unbox a boxed type. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[howitzers]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 658 ---------------------------------------------
Invokes the specified method on the specified object. --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[ehrlich]] ( Object obj , Object [ ] [[straw]] ) throws Throwable { try { init ( ) ; FastClassInfo [[studied]] = fastClassInfo ; return [[studied]] . f1 . invoke ( [[studied]] . i1 , obj , [[straw]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 659 ---------------------------------------------
Returns a list of all methods of the specified superclass andinterfaces. --> Shikai methods --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List [[methods]] ) { [[getMethods]] ( superclass , interfaces , [[methods]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[shikai]] ( Class superclass , Class [ ] interfaces , List [[oblivious]] ) { [[shikai]] ( superclass , interfaces , [[oblivious]] , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 660 ---------------------------------------------
Merges the specified sort region into the specified region. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int [[lo]] , int [[hi]] , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . mergeSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[stealthy]] ( int [[maugham]] , int [[degenerate]] , int [[maggots]] , Comparator cmp ) { chooseComparer ( [[maugham]] , cmp ) ; super . mergeSort ( [[degenerate]] , [[maggots]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 661 ---------------------------------------------
Sets the superclass of this object. --> Shinbone lights --> Socre: 1.0

[[[[Adv]]]]: public void [[setSuperclass]] ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . [[superclass]] = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void [[shinbone]] ( Class [[aways]] ) { if ( [[aways]] != null && [[aways]] . equals ( Object . class ) ) { [[aways]] = null ; } this . [[amulet]] = [[aways]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 662 ---------------------------------------------
Filter out constructors that are not visible to the user. --> [[[FAILED]]]

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void filterConstructors ( Class sc , List [[abundantly]] ) { CollectionUtils . filter ( [[abundantly]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[abundantly]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 663 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 483 / 17 / 663:  66%|██████▋   | 663/1000 [3:18:16<1:40:47, 17.94s/it][Succeeded / Failed / Skipped / Total] 163 / 483 / 17 / 663:  66%|██████▋   | 664/1000 [3:18:25<1:40:24, 17.93s/it][Succeeded / Failed / Skipped / Total] 164 / 483 / 17 / 664:  66%|██████▋   | 664/1000 [3:18:25<1:40:24, 17.93s/it][Succeeded / Failed / Skipped / Total] 164 / 483 / 17 / 664:  66%|██████▋   | 665/1000 [3:18:26<1:39:57, 17.90s/it][Succeeded / Failed / Skipped / Total] 164 / 483 / 18 / 665:  66%|██████▋   | 665/1000 [3:18:26<1:39:57, 17.90s/it][Succeeded / Failed / Skipped / Total] 164 / 483 / 18 / 665:  67%|██████▋   | 666/1000 [3:18:37<1:39:36, 17.89s/it][Succeeded / Failed / Skipped / Total] 164 / 484 / 18 / 666:  67%|██████▋   | 666/1000 [3:18:37<1:39:36, 17.89s/it][Succeeded / Failed / Skipped / Total] 164 / 484 / 18 / 666:  67%|██████▋   | 667/1000 [3:18:39<1:39:10, 17.87s/it][Succeeded / Failed / Skipped / Total] 164 / 485 / 18 / 667:  67%|██████▋   | 667/1000 [3:18:39<1:39:10, 17.87s/it][Succeeded / Failed / Skipped / Total] 164 / 485 / 18 / 667:  67%|██████▋   | 668/1000 [3:19:06<1:38:57, 17.88s/it][Succeeded / Failed / Skipped / Total] 164 / 486 / 18 / 668:  67%|██████▋   | 668/1000 [3:19:06<1:38:57, 17.88s/it][Succeeded / Failed / Skipped / Total] 164 / 486 / 18 / 668:  67%|██████▋   | 669/1000 [3:19:55<1:38:54, 17.93s/it][Succeeded / Failed / Skipped / Total] 164 / 487 / 18 / 669:  67%|██████▋   | 669/1000 [3:19:55<1:38:54, 17.93s/it][Succeeded / Failed / Skipped / Total] 164 / 487 / 18 / 669:  67%|██████▋   | 670/1000 [3:20:02<1:38:31, 17.91s/it][Succeeded / Failed / Skipped / Total] 164 / 488 / 18 / 670:  67%|██████▋   | 670/1000 [3:20:02<1:38:31, 17.91s/it][Succeeded / Failed / Skipped / Total] 164 / 488 / 18 / 670:  67%|██████▋   | 671/1000 [3:20:07<1:38:07, 17.90s/it]Performs a quick sort on the specified region. --> [[[FAILED]]]

[[[[Adv]]]]: public void quickSort ( int [[index]] , int [[lo]] , int [[hi]] , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . quickSort ( [[lo]] , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void quickSort ( int [[schaffer]] , int [[flashes]] , int [[reversed]] , Comparator cmp ) { chooseComparer ( [[schaffer]] , cmp ) ; super . quickSort ( [[flashes]] , [[reversed]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 664 ---------------------------------------------
Generate code to retrieve a field.@param names the names of the fields to retrieve. --> Executes the get method on the classpath. --> Socre: 1.0

[[[[Adv]]]]: private void getField ( String [ ] [[names]] ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , [[names]] , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities

[[[[Adv]]]]: private void getField ( String [ ] [[appalachian]] ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , [[appalachian]] , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 665 ---------------------------------------------
Finds the methods in the specified names and descriptors. --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
Adds the specified method to this class. --> [[[FAILED]]]

[[[[Adv]]]]: public void [[add]] ( Method method ) { [[add]] ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[lansky]] ( Method method ) { [[lansky]] ( ReflectUtils . getSignature ( method ) , ReflectUtils . getExceptionTypes ( method ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 667 ---------------------------------------------
Compare two nulls. --> [[[FAILED]]]

[[[[Adv]]]]: private static void [[nullcmp]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void [[tutankhamen]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 668 ---------------------------------------------
Computes the cardinality of this vector. --> [[[FAILED]]]

[[[[Adv]]]]: public int [[cardinality]] ( ) { int [[w]] = value ; int c = 0 ; while ( [[w]] != 0 ) { c += T [ [[w]] & 255 ] ; [[w]] >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .

[[[[Adv]]]]: public int [[bobcat]] ( ) { int [[distaste]] = value ; int c = 0 ; while ( [[distaste]] != 0 ) { c += T [ [[distaste]] & 255 ] ; [[distaste]] >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 669 ---------------------------------------------
Sets the host for the request. --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . [[host]] = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[indifference]] ( final String [[tadpoles]] ) { this . [[valenzuela]] = [[indifference]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[indifference]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 670 ---------------------------------------------
Resolve a child path.@param base the base path@param child the child path@return the resolved path --> [[[FAILED]]]

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[aeroplanes]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 671 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 164 / 489 / 18 / 671:  67%|██████▋   | 671/1000 [3:20:07<1:38:07, 17.90s/it][Succeeded / Failed / Skipped / Total] 164 / 489 / 18 / 671:  67%|██████▋   | 672/1000 [3:20:34<1:37:53, 17.91s/it][Succeeded / Failed / Skipped / Total] 165 / 489 / 18 / 672:  67%|██████▋   | 672/1000 [3:20:34<1:37:53, 17.91s/it][Succeeded / Failed / Skipped / Total] 165 / 489 / 18 / 672:  67%|██████▋   | 673/1000 [3:20:35<1:37:27, 17.88s/it][Succeeded / Failed / Skipped / Total] 165 / 490 / 18 / 673:  67%|██████▋   | 673/1000 [3:20:35<1:37:27, 17.88s/it][Succeeded / Failed / Skipped / Total] 165 / 490 / 18 / 673:  67%|██████▋   | 674/1000 [3:20:45<1:37:06, 17.87s/it][Succeeded / Failed / Skipped / Total] 165 / 491 / 18 / 674:  67%|██████▋   | 674/1000 [3:20:45<1:37:06, 17.87s/it][Succeeded / Failed / Skipped / Total] 165 / 491 / 18 / 674:  68%|██████▊   | 675/1000 [3:20:51<1:36:42, 17.85s/it][Succeeded / Failed / Skipped / Total] 165 / 492 / 18 / 675:  68%|██████▊   | 675/1000 [3:20:51<1:36:42, 17.85s/it][Succeeded / Failed / Skipped / Total] 165 / 492 / 18 / 675:  68%|██████▊   | 676/1000 [3:20:53<1:36:17, 17.83s/it][Succeeded / Failed / Skipped / Total] 165 / 493 / 18 / 676:  68%|██████▊   | 676/1000 [3:20:53<1:36:17, 17.83s/it][Succeeded / Failed / Skipped / Total] 165 / 493 / 18 / 676:  68%|██████▊   | 677/1000 [3:21:10<1:35:58, 17.83s/it][Succeeded / Failed / Skipped / Total] 165 / 494 / 18 / 677:  68%|██████▊   | 677/1000 [3:21:10<1:35:58, 17.83s/it][Succeeded / Failed / Skipped / Total] 165 / 494 / 18 / 677:  68%|██████▊   | 678/1000 [3:21:22<1:35:38, 17.82s/it][Succeeded / Failed / Skipped / Total] 165 / 495 / 18 / 678:  68%|██████▊   | 678/1000 [3:21:22<1:35:38, 17.82s/it][Succeeded / Failed / Skipped / Total] 165 / 495 / 18 / 678:  68%|██████▊   | 679/1000 [3:21:30<1:35:15, 17.81s/it][Succeeded / Failed / Skipped / Total] 165 / 496 / 18 / 679:  68%|██████▊   | 679/1000 [3:21:30<1:35:15, 17.81s/it][Succeeded / Failed / Skipped / Total] 165 / 496 / 18 / 679:  68%|██████▊   | 680/1000 [3:21:35<1:34:51, 17.79s/it][Succeeded / Failed / Skipped / Total] 165 / 497 / 18 / 680:  68%|██████▊   | 680/1000 [3:21:35<1:34:51, 17.79s/it][Succeeded / Failed / Skipped / Total] 165 / 497 / 18 / 680:  68%|██████▊   | 681/1000 [3:21:37<1:34:26, 17.76s/it][Succeeded / Failed / Skipped / Total] 165 / 498 / 18 / 681:  68%|██████▊   | 681/1000 [3:21:37<1:34:26, 17.76s/it]