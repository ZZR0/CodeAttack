  0%|          | 0/1000 [00:00<?, ?it/s]  0%|          | 1/1000 [00:30<8:28:33, 30.54s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:30<8:28:34, 30.54s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 2/1000 [00:46<6:23:05, 23.03s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:46<6:23:05, 23.03s/it][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 3/1000 [01:07<6:14:02, 22.51s/it][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [01:07<6:14:02, 22.51s/it][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 4/1000 [01:24<5:50:59, 21.14s/it][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [01:24<5:50:59, 21.14s/it][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 5/1000 [01:32<5:07:22, 18.53s/it][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [01:32<5:07:22, 18.53s/it][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   1%|          | 6/1000 [01:50<5:03:57, 18.35s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [01:50<5:03:58, 18.35s/it][Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 7/1000 [02:12<5:13:35, 18.95s/it]Attack(
  (search_method): GreedyWordSwapWIR(
    (wir_method):  random
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
    (2): RepeatModification
  (is_black_box):  True
) 

--------------------------------------------- Result 1 ---------------------------------------------
Fast implementation for fast - path elements . --> Flush a value --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[flamin]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > [[devotedly]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[devotedly]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[devotedly]] , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .


--------------------------------------------- Result 2 ---------------------------------------------
Wrap an Observable . --> Blocking operation --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[bernhardt]] ( ObservableSource < T > [[frederica]] ) { ObjectHelper . requireNonNull ( [[frederica]] , "source is null" ) ; if ( [[frederica]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[frederica]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[frederica]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .


--------------------------------------------- Result 3 ---------------------------------------------
Returns an observable sorted by the specified comparator . --> Get nichols --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[nichols]] ( Comparator < ? super T > [[zhan]] ) { ObjectHelper . requireNonNull ( [[zhan]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[zhan]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .


--------------------------------------------- Result 4 ---------------------------------------------
Adapts a ConnectableObserver to a ConnectableObserver . --> Adapts a ConnectableObserver to a ConnectableObserver --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[scheduler]] ) { final Observable < T > observable = co . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > observeOn ( final ConnectableObservable < T > co , final Scheduler [[dad]] ) { final Observable < T > observable = co . observeOn ( [[dad]] ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .


--------------------------------------------- Result 5 ---------------------------------------------
Create a new instance of this processor . --> Create a new Unicast processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[baskets]] ) { return new UnicastProcessor < T > ( [[baskets]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .


--------------------------------------------- Result 6 ---------------------------------------------
Create a new instance of this processor . --> Create new processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[asn]] , Runnable [[wasps]] ) { ObjectHelper . requireNonNull ( [[wasps]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[asn]] , [[wasps]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .


--------------------------------------------- Result 7 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [02:12<5:13:35, 18.95s/it][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 8/1000 [02:30<5:10:52, 18.80s/it][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [02:30<5:10:52, 18.80s/it][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 9/1000 [02:43<4:59:31, 18.13s/it][Succeeded / Failed / Skipped / Total] 8 / 1 / 0 / 9:   1%|          | 9/1000 [02:43<4:59:31, 18.13s/it][Succeeded / Failed / Skipped / Total] 8 / 1 / 0 / 9:   1%|          | 10/1000 [02:50<4:42:03, 17.09s/it][Succeeded / Failed / Skipped / Total] 9 / 1 / 0 / 10:   1%|          | 10/1000 [02:50<4:42:03, 17.09s/it][Succeeded / Failed / Skipped / Total] 9 / 1 / 0 / 10:   1%|          | 11/1000 [02:58<4:26:57, 16.20s/it][Succeeded / Failed / Skipped / Total] 10 / 1 / 0 / 11:   1%|          | 11/1000 [02:58<4:26:57, 16.20s/it][Succeeded / Failed / Skipped / Total] 10 / 1 / 0 / 11:   1%|          | 12/1000 [03:15<4:27:49, 16.26s/it]Tries to perform a scalar function on a subscriber . --> Helper function for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return True ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return True ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return True ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > [[buggery]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[blevins]] ) { if ( [[buggery]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[buggery]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return True ; } Publisher < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[blevins]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return True ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return True ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { r . subscribe ( subscriber ) ; } return True ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .


--------------------------------------------- Result 8 ---------------------------------------------
Convert a scalar value into a Streamable . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[prew]] ( final T value , final Function < ? super T , ? extends Publisher < ? extends U > > [[chid]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( value , [[chid]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .


--------------------------------------------- Result 9 ---------------------------------------------
Reset all settings . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( False ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[aliases]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( False ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .


--------------------------------------------- Result 10 ---------------------------------------------
Construct a Maybe from a Completable --> Zoltan implementation --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[zoltan]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .


--------------------------------------------- Result 11 ---------------------------------------------
Construct a Maybe from a single source . --> removes from single source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[tarnished]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .


--------------------------------------------- Result 12 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 1 / 0 / 12:   1%|          | 12/1000 [03:15<4:27:49, 16.26s/it][Succeeded / Failed / Skipped / Total] 11 / 1 / 0 / 12:   1%|▏         | 13/1000 [03:23<4:18:02, 15.69s/it][Succeeded / Failed / Skipped / Total] 11 / 2 / 0 / 13:   1%|▏         | 13/1000 [03:23<4:18:02, 15.69s/it][Succeeded / Failed / Skipped / Total] 11 / 2 / 0 / 13:   1%|▏         | 14/1000 [03:41<4:19:29, 15.79s/it][Succeeded / Failed / Skipped / Total] 12 / 2 / 0 / 14:   1%|▏         | 14/1000 [03:41<4:19:29, 15.79s/it][Succeeded / Failed / Skipped / Total] 12 / 2 / 0 / 14:   2%|▏         | 15/1000 [03:48<4:10:11, 15.24s/it][Succeeded / Failed / Skipped / Total] 13 / 2 / 0 / 15:   2%|▏         | 15/1000 [03:48<4:10:11, 15.24s/it][Succeeded / Failed / Skipped / Total] 13 / 2 / 0 / 15:   2%|▏         | 16/1000 [03:56<4:02:06, 14.76s/it][Succeeded / Failed / Skipped / Total] 14 / 2 / 0 / 16:   2%|▏         | 16/1000 [03:56<4:02:07, 14.76s/it][Succeeded / Failed / Skipped / Total] 14 / 2 / 0 / 16:   2%|▏         | 17/1000 [04:10<4:01:28, 14.74s/it][Succeeded / Failed / Skipped / Total] 15 / 2 / 0 / 17:   2%|▏         | 17/1000 [04:10<4:01:28, 14.74s/it][Succeeded / Failed / Skipped / Total] 15 / 2 / 0 / 17:   2%|▏         | 18/1000 [04:26<4:02:15, 14.80s/it][Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 18/1000 [04:26<4:02:15, 14.80s/it][Succeeded / Failed / Skipped / Total] 16 / 2 / 0 / 18:   2%|▏         | 19/1000 [04:42<4:03:15, 14.88s/it][Succeeded / Failed / Skipped / Total] 17 / 2 / 0 / 19:   2%|▏         | 19/1000 [04:42<4:03:15, 14.88s/it][Succeeded / Failed / Skipped / Total] 17 / 2 / 0 / 19:   2%|▏         | 20/1000 [05:01<4:06:32, 15.09s/it][Succeeded / Failed / Skipped / Total] 18 / 2 / 0 / 20:   2%|▏         | 20/1000 [05:01<4:06:32, 15.09s/it][Succeeded / Failed / Skipped / Total] 18 / 2 / 0 / 20:   2%|▏         | 21/1000 [05:17<4:06:47, 15.12s/it][Succeeded / Failed / Skipped / Total] 18 / 3 / 0 / 21:   2%|▏         | 21/1000 [05:17<4:06:47, 15.13s/it][Succeeded / Failed / Skipped / Total] 18 / 3 / 0 / 21:   2%|▏         | 22/1000 [05:25<4:01:30, 14.82s/it]Retries execution of the given number of times . --> Perform retrying on failure --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > retry ( long [[ascribed]] , Predicate < ? super Throwable > [[halliburton]] ) { return toFlowable ( ) . retry ( [[ascribed]] , [[halliburton]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .


--------------------------------------------- Result 13 ---------------------------------------------
Requests that the specified object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[supervillain]] > [[supervillain]] requireNonNull ( [[supervillain]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .


--------------------------------------------- Result 14 ---------------------------------------------
Returns an identity function . --> Hash of MurmurHash --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[tiger]] > Function < [[tiger]] , [[tiger]] > [[mashing]] ( ) { return ( Function < [[tiger]] , [[tiger]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .


--------------------------------------------- Result 15 ---------------------------------------------
Wraps a value . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[piedras]] ) { return new JustValue < Object , T > ( [[piedras]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .


--------------------------------------------- Result 16 ---------------------------------------------
Returns a function that wraps the given value --> Shortcut method for snodgrass --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[justFunction]] ( U value ) { return new JustValue < T , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[snodgrass]] ( U value ) { return new JustValue < T , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .


--------------------------------------------- Result 17 ---------------------------------------------
Returns a casted function cast to target class --> Static factory method for casting to primitive type --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < T , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[pby]] ( Class < U > [[ferral]] ) { return new CastToClass < T , U > ( [[ferral]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .


--------------------------------------------- Result 18 ---------------------------------------------
Create a new unicast subject . --> Returns a new unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[ovulate]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[["Anniversary" == "Anniversary"]]" == "[["Anniversary" == "Anniversary"]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .


--------------------------------------------- Result 19 ---------------------------------------------
Create a new unicast subject with the specified capacity . --> Factory method for unulast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , True ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[dishonorable]] ( int [[alouette]] ) { return new UnicastSubject < T > ( [[alouette]] , True ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .


--------------------------------------------- Result 20 ---------------------------------------------
Create a dummy subject with the specified capacity . --> Static factory method --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( capacityHint , [[onTerminate]] , True ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[tactician]] ( int capacityHint , Runnable [[cleanest]] ) { return new UnicastSubject < T > ( capacityHint , [[cleanest]] , True ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .


--------------------------------------------- Result 21 ---------------------------------------------
Create a new unicast subject . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[cas]] ( boolean [[cun]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[cun]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .


--------------------------------------------- Result 22 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 18 / 4 / 0 / 22:   2%|▏         | 22/1000 [05:25<4:01:30, 14.82s/it][Succeeded / Failed / Skipped / Total] 18 / 4 / 0 / 22:   2%|▏         | 23/1000 [05:56<4:12:06, 15.48s/it][Succeeded / Failed / Skipped / Total] 18 / 5 / 0 / 23:   2%|▏         | 23/1000 [05:56<4:12:06, 15.48s/it][Succeeded / Failed / Skipped / Total] 18 / 5 / 0 / 23:   2%|▏         | 24/1000 [06:42<4:32:45, 16.77s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 0 / 24:   2%|▏         | 24/1000 [06:42<4:32:45, 16.77s/it][Succeeded / Failed / Skipped / Total] 18 / 6 / 0 / 24:   2%|▎         | 25/1000 [07:21<4:47:02, 17.66s/it][Succeeded / Failed / Skipped / Total] 19 / 6 / 0 / 25:   2%|▎         | 25/1000 [07:21<4:47:02, 17.66s/it][Succeeded / Failed / Skipped / Total] 19 / 6 / 0 / 25:   3%|▎         | 26/1000 [07:30<4:40:58, 17.31s/it][Succeeded / Failed / Skipped / Total] 20 / 6 / 0 / 26:   3%|▎         | 26/1000 [07:30<4:40:58, 17.31s/it][Succeeded / Failed / Skipped / Total] 20 / 6 / 0 / 26:   3%|▎         | 27/1000 [08:21<5:01:18, 18.58s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 0 / 27:   3%|▎         | 27/1000 [08:21<5:01:18, 18.58s/it][Succeeded / Failed / Skipped / Total] 21 / 6 / 0 / 27:   3%|▎         | 28/1000 [09:01<5:13:31, 19.35s/it]Get an error from the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[shakers]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .


--------------------------------------------- Result 23 ---------------------------------------------
Get an error from the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[lamebrain]] ( long [[accra]] , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[accra]] , unit ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[accra]] , unit ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .


--------------------------------------------- Result 24 ---------------------------------------------
Wait for the task . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return False ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return True ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[waive]] ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return False ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return True ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .


--------------------------------------------- Result 25 ---------------------------------------------
Removes the maximum number of items from queue . --> perform polarity --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > [[q]] , Subscriber < ? super U > a , boolean delayError , Disposable [[dispose]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = [[q]] . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , [[q]] , qd ) ) { if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[q]] . clear ( ) ; if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[polarity]] ( SimplePlainQueue < T > [[kalli]] , Subscriber < ? super U > a , boolean delayError , Disposable [[concussion]] , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = [[kalli]] . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , [[kalli]] , qd ) ) { if ( [[concussion]] != null ) { [[concussion]] . [[concussion]] ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { [[kalli]] . clear ( ) ; if ( [[concussion]] != null ) { [[concussion]] . [[concussion]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .


--------------------------------------------- Result 26 ---------------------------------------------
Performs a blocking request . --> Request a subscription --> Socre: 1.0

[[[[Adv]]]]: public static void request ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void request ( Subscription [[overhang]] , int prefetch ) { [[overhang]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .


--------------------------------------------- Result 27 ---------------------------------------------
Called when a subscriber is complete . --> Performs asynchronous processing on a thread --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[isCancelled]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[isCancelled]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[kayama]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[ap]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[ap]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long [[lagrange]] = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .


--------------------------------------------- Result 28 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 28/1000 [09:01<5:13:31, 19.35s/it][Succeeded / Failed / Skipped / Total] 21 / 7 / 0 / 28:   3%|▎         | 29/1000 [09:18<5:11:34, 19.25s/it][Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 29/1000 [09:18<5:11:34, 19.25s/it][Succeeded / Failed / Skipped / Total] 22 / 7 / 0 / 29:   3%|▎         | 30/1000 [09:32<5:08:17, 19.07s/it][Succeeded / Failed / Skipped / Total] 22 / 8 / 0 / 30:   3%|▎         | 30/1000 [09:32<5:08:17, 19.07s/it][Succeeded / Failed / Skipped / Total] 22 / 8 / 0 / 30:   3%|▎         | 31/1000 [09:45<5:04:46, 18.87s/it][Succeeded / Failed / Skipped / Total] 23 / 8 / 0 / 31:   3%|▎         | 31/1000 [09:45<5:04:46, 18.87s/it][Succeeded / Failed / Skipped / Total] 23 / 8 / 0 / 31:   3%|▎         | 32/1000 [10:21<5:13:26, 19.43s/it][Succeeded / Failed / Skipped / Total] 24 / 8 / 0 / 32:   3%|▎         | 32/1000 [10:21<5:13:26, 19.43s/it][Succeeded / Failed / Skipped / Total] 24 / 8 / 0 / 32:   3%|▎         | 33/1000 [10:32<5:09:01, 19.17s/it][Succeeded / Failed / Skipped / Total] 25 / 8 / 0 / 33:   3%|▎         | 33/1000 [10:32<5:09:01, 19.17s/it][Succeeded / Failed / Skipped / Total] 25 / 8 / 0 / 33:   3%|▎         | 34/1000 [10:54<5:09:57, 19.25s/it]Completes the current value . --> [[[FAILED]]]

[[[[Adv]]]]: protected final void complete ( R n ) { long [[p]] = produced ; if ( [[p]] != 0 ) { BackpressureHelper . produced ( this , [[p]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void complete ( R n ) { long [[motes]] = produced ; if ( [[motes]] != 0 ) { BackpressureHelper . produced ( this , [[motes]] ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .


--------------------------------------------- Result 29 ---------------------------------------------
Returns the value associated with this notification . --> Convenience method to get a friendless friend --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[friendless]] ( ) { Object [[sampler]] = value ; if ( [[sampler]] != null && ! NotificationLite . isError ( [[sampler]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .


--------------------------------------------- Result 30 ---------------------------------------------
Gets the error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[benzedrine]] ( ) { Object [[rally]] = value ; if ( NotificationLite . isError ( [[rally]] ) ) { return NotificationLite . getError ( [[rally]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .


--------------------------------------------- Result 31 ---------------------------------------------
Determines whether two streams can be disposed . --> Compare two streams --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[carte]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .


--------------------------------------------- Result 32 ---------------------------------------------
Atomically updates the AtomicReference with the given AtomicReference . --> This method is used for testing only --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[upstream]] , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > [[smuggled]] , Disposable [[trash]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[trash]] , "next is null" ) ; if ( ! [[smuggled]] . compareAndSet ( null , [[trash]] ) ) { [[trash]] . dispose ( ) ; if ( [[smuggled]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return False ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .


--------------------------------------------- Result 33 ---------------------------------------------
Checks that two Subscription objects have been cancelled . --> Determines whether two SubSubs are equivalent --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[["Shorter" != "Shorter"]]" != "[["Shorter" != "Shorter"]]" ; } return True ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .


--------------------------------------------- Result 34 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 8 / 0 / 34:   3%|▎         | 34/1000 [10:54<5:09:57, 19.25s/it][Succeeded / Failed / Skipped / Total] 26 / 8 / 0 / 34:   4%|▎         | 35/1000 [11:05<5:05:46, 19.01s/it][Succeeded / Failed / Skipped / Total] 27 / 8 / 0 / 35:   4%|▎         | 35/1000 [11:05<5:05:46, 19.01s/it][Succeeded / Failed / Skipped / Total] 27 / 8 / 0 / 35:   4%|▎         | 36/1000 [11:15<5:01:36, 18.77s/it][Succeeded / Failed / Skipped / Total] 28 / 8 / 0 / 36:   4%|▎         | 36/1000 [11:15<5:01:36, 18.77s/it][Succeeded / Failed / Skipped / Total] 28 / 8 / 0 / 36:   4%|▎         | 37/1000 [12:07<5:15:39, 19.67s/it][Succeeded / Failed / Skipped / Total] 29 / 8 / 0 / 37:   4%|▎         | 37/1000 [12:07<5:15:39, 19.67s/it][Succeeded / Failed / Skipped / Total] 29 / 8 / 0 / 37:   4%|▍         | 38/1000 [12:30<5:16:27, 19.74s/it][Succeeded / Failed / Skipped / Total] 30 / 8 / 0 / 38:   4%|▍         | 38/1000 [12:30<5:16:27, 19.74s/it][Succeeded / Failed / Skipped / Total] 30 / 8 / 0 / 38:   4%|▍         | 39/1000 [12:36<5:10:40, 19.40s/it][Succeeded / Failed / Skipped / Total] 31 / 8 / 0 / 39:   4%|▍         | 39/1000 [12:36<5:10:40, 19.40s/it][Succeeded / Failed / Skipped / Total] 31 / 8 / 0 / 39:   4%|▍         | 40/1000 [12:50<5:08:17, 19.27s/it][Succeeded / Failed / Skipped / Total] 32 / 8 / 0 / 40:   4%|▍         | 40/1000 [12:50<5:08:17, 19.27s/it][Succeeded / Failed / Skipped / Total] 32 / 8 / 0 / 40:   4%|▍         | 41/1000 [13:22<5:12:50, 19.57s/it][Succeeded / Failed / Skipped / Total] 33 / 8 / 0 / 41:   4%|▍         | 41/1000 [13:22<5:12:50, 19.57s/it][Succeeded / Failed / Skipped / Total] 33 / 8 / 0 / 41:   4%|▍         | 42/1000 [14:25<5:29:06, 20.61s/it]Atomically updates the upstream AtomicReference with the given AtomicReference . --> unsynchronized --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[upstream]] , Subscription [[next]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , [[next]] ) ) { [[next]] . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return False ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > [[misogynist]] , Subscription [[norton]] , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( [[norton]] , "next is null" ) ; if ( ! [[misogynist]] . compareAndSet ( null , [[norton]] ) ) { [[norton]] . cancel ( ) ; if ( [[misogynist]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return False ; } return True ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .


--------------------------------------------- Result 35 ---------------------------------------------
Add a capacity to a long --> Add a cap to a gender --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long b ) { long u = [[a]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[gender]] , long b ) { long u = [[gender]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .


--------------------------------------------- Result 36 ---------------------------------------------
Returns the capacity of a long --> Multiply authority by b --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long [[a]] , long b ) { long u = [[a]] * b ; if ( ( ( [[a]] | b ) >>> 31 ) != 0 ) { if ( u / [[a]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long [[authority]] , long b ) { long u = [[authority]] * b ; if ( ( ( [[authority]] | b ) >>> 31 ) != 0 ) { if ( u / [[authority]] != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .


--------------------------------------------- Result 37 ---------------------------------------------
Atomically adds the specified number to the specified long . --> todo support --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong requested , long n ) { for ( ; ; ) { long [[r]] = requested . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[r]] , n ) ; if ( requested . compareAndSet ( [[r]] , u ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[pontiff]] ( AtomicLong requested , long n ) { for ( ; ; ) { long [[indiana]] = requested . get ( ) ; if ( [[indiana]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( [[indiana]] , n ) ; if ( requested . compareAndSet ( [[indiana]] , u ) ) { return [[indiana]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .


--------------------------------------------- Result 38 ---------------------------------------------
Converts an exception into a NullPointerException . --> thrown when an exception is thrown --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[ex]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[dive]] ( Throwable [[waxworks]] ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( [[waxworks]] ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .


--------------------------------------------- Result 39 ---------------------------------------------
Add an object to the list --> batched on object --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[batya]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .


--------------------------------------------- Result 40 ---------------------------------------------
Shuts down the thread pool . --> Prune corrupting resources --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[pronto]] ( ) { ScheduledExecutorService [[corrupting]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[corrupting]] != null ) { [[corrupting]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .


--------------------------------------------- Result 41 ---------------------------------------------
Creates a scheduled thread pool . --> As soon as soon as soon as soon as soon as possible --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[fyodor]] ( ThreadFactory [[willpower]] ) { final ScheduledExecutorService [[burmese]] = Executors . newScheduledThreadPool ( 1 , [[willpower]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[burmese]] ) ; return [[burmese]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .


--------------------------------------------- Result 42 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 34 / 8 / 0 / 42:   4%|▍         | 42/1000 [14:25<5:29:06, 20.61s/it][Succeeded / Failed / Skipped / Total] 34 / 8 / 0 / 42:   4%|▍         | 43/1000 [14:41<5:27:05, 20.51s/it][Succeeded / Failed / Skipped / Total] 35 / 8 / 0 / 43:   4%|▍         | 43/1000 [14:41<5:27:05, 20.51s/it][Succeeded / Failed / Skipped / Total] 35 / 8 / 0 / 43:   4%|▍         | 44/1000 [15:06<5:28:19, 20.61s/it][Succeeded / Failed / Skipped / Total] 35 / 9 / 0 / 44:   4%|▍         | 44/1000 [15:06<5:28:19, 20.61s/it][Succeeded / Failed / Skipped / Total] 35 / 9 / 0 / 44:   4%|▍         | 45/1000 [15:42<5:33:28, 20.95s/it][Succeeded / Failed / Skipped / Total] 36 / 9 / 0 / 45:   4%|▍         | 45/1000 [15:42<5:33:28, 20.95s/it][Succeeded / Failed / Skipped / Total] 36 / 9 / 0 / 45:   5%|▍         | 46/1000 [16:09<5:35:04, 21.07s/it][Succeeded / Failed / Skipped / Total] 36 / 10 / 0 / 46:   5%|▍         | 46/1000 [16:09<5:35:04, 21.07s/it][Succeeded / Failed / Skipped / Total] 36 / 10 / 0 / 46:   5%|▍         | 47/1000 [16:16<5:29:50, 20.77s/it][Succeeded / Failed / Skipped / Total] 37 / 10 / 0 / 47:   5%|▍         | 47/1000 [16:16<5:29:50, 20.77s/it][Succeeded / Failed / Skipped / Total] 37 / 10 / 0 / 47:   5%|▍         | 48/1000 [16:30<5:27:29, 20.64s/it][Succeeded / Failed / Skipped / Total] 38 / 10 / 0 / 48:   5%|▍         | 48/1000 [16:30<5:27:29, 20.64s/it][Succeeded / Failed / Skipped / Total] 38 / 10 / 0 / 48:   5%|▍         | 49/1000 [16:54<5:28:18, 20.71s/it]Sets a new subscription . --> Method that will be called when the next item is queued --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[petals]] ( Subscription [[spandex]] ) { if ( cancelled ) { [[spandex]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[spandex]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[spandex]] ; long [[gazelle]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[gazelle]] != 0L ) { [[spandex]] . request ( [[gazelle]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[spandex]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .


--------------------------------------------- Result 43 ---------------------------------------------
Process the loop . --> Dispatches --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[bribing]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > q ; synchronized ( this ) { q = queue ; if ( q == null ) { emitting = "[["Appropriations" != "Appropriations"]]" != "[["Appropriations" != "Appropriations"]]" ; return ; } queue = null ; } q . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .


--------------------------------------------- Result 44 ---------------------------------------------
Wraps a RuntimeException . --> [[[FAILED]]]

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[streamers]] ) { if ( [[streamers]] instanceof Error ) { throw ( Error ) [[streamers]] ; } if ( [[streamers]] instanceof RuntimeException ) { return ( RuntimeException ) [[streamers]] ; } return new RuntimeException ( [[streamers]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .


--------------------------------------------- Result 45 ---------------------------------------------
Flatten the given exception into a flattened list . --> Flatten the distortion --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable [[t]] ) { List < Throwable > [[list]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[t]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { [[list]] . add ( e ) ; } } return [[list]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > flatten ( Throwable [[distortion]] ) { List < Throwable > [[monkeying]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( [[distortion]] ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { deque . offerFirst ( exceptions . get ( i ) ) ; } } else { [[monkeying]] . add ( e ) ; } } return [[monkeying]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .


--------------------------------------------- Result 46 ---------------------------------------------
Wraps the given exception if it is an exception . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[première]] [[chai]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[première]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[première]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .


--------------------------------------------- Result 47 ---------------------------------------------
Clears the resources . --> Clear resources --> Socre: 1.0

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[klowns]] ; synchronized ( this ) { if ( disposed ) { return ; } [[klowns]] = resources ; resources = null ; } dispose ( [[klowns]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .


--------------------------------------------- Result 48 ---------------------------------------------
Returns the number of available resources . --> Calculates how much space should be displayed --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[cortland]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[readjustment]] = resources ; return [[readjustment]] != null ? [[readjustment]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .


--------------------------------------------- Result 49 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 39 / 10 / 0 / 49:   5%|▍         | 49/1000 [16:54<5:28:18, 20.71s/it][Succeeded / Failed / Skipped / Total] 39 / 10 / 0 / 49:   5%|▌         | 50/1000 [17:16<5:28:11, 20.73s/it][Succeeded / Failed / Skipped / Total] 40 / 10 / 0 / 50:   5%|▌         | 50/1000 [17:16<5:28:11, 20.73s/it][Succeeded / Failed / Skipped / Total] 40 / 10 / 0 / 50:   5%|▌         | 51/1000 [18:16<5:40:09, 21.51s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 51/1000 [18:16<5:40:09, 21.51s/it][Succeeded / Failed / Skipped / Total] 40 / 11 / 0 / 51:   5%|▌         | 52/1000 [18:48<5:42:54, 21.70s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 52/1000 [18:48<5:42:54, 21.70s/it][Succeeded / Failed / Skipped / Total] 41 / 11 / 0 / 52:   5%|▌         | 53/1000 [18:56<5:38:22, 21.44s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 53/1000 [18:56<5:38:22, 21.44s/it][Succeeded / Failed / Skipped / Total] 42 / 11 / 0 / 53:   5%|▌         | 54/1000 [19:03<5:34:01, 21.19s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   5%|▌         | 54/1000 [19:03<5:34:01, 21.19s/it][Succeeded / Failed / Skipped / Total] 43 / 11 / 0 / 54:   6%|▌         | 55/1000 [19:40<5:38:00, 21.46s/it]Performs a scalar operation on an ObservableSource . --> Utility function for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[source]] , Observer < ? super R > [[observer]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return True ; } if ( t == null ) { EmptyDisposable . complete ( [[observer]] ) ; return True ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[observer]] ) ; return True ; } if ( u == null ) { EmptyDisposable . complete ( [[observer]] ) ; return True ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[observer]] , u ) ; [[observer]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[observer]] ) ; } return True ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > [[beresford]] , Observer < ? super R > [[concludes]] , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( [[beresford]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[beresford]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[concludes]] ) ; return True ; } if ( t == null ) { EmptyDisposable . complete ( [[concludes]] ) ; return True ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[concludes]] ) ; return True ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , [[concludes]] ) ; return True ; } if ( u == null ) { EmptyDisposable . complete ( [[concludes]] ) ; return True ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( [[concludes]] , u ) ; [[concludes]] . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( [[concludes]] ) ; } return True ; } return False ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .


--------------------------------------------- Result 50 ---------------------------------------------
Converts a scalar value to a scalar using the given function . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[frantisek]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[sandman]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[frantisek]] , [[sandman]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .


--------------------------------------------- Result 51 ---------------------------------------------
Accept a subscriber . --> [[[FAILED]]]

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return True ; } } a = ( Object [ ] ) a [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[dragnet]] ( Subscriber < ? super U > subscriber ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , subscriber ) ) { return True ; } } a = ( Object [ ] ) a [ c ] ; } return "[["Clem" != "Clem"]]" != "[["Clem" != "Clem"]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .


--------------------------------------------- Result 52 ---------------------------------------------
Accepts an object from the queue . --> Waits until an element is full or not --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > [[observer]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[observer]] ) ) { return "[[True]]" == "[[True]]" ; } } a = ( Object [ ] ) a [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[holl]] ( Observer < ? super U > [[info]] ) { Object [ ] a = head ; final int c = capacity ; while ( a != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = a [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[info]] ) ) { return "[["Gok" == "Gok"]]" == "[["Gok" == "Gok"]]" ; } } a = ( Object [ ] ) a [ c ] ; } return False ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .


--------------------------------------------- Result 53 ---------------------------------------------
Starts the stream --> to be called once --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[janie]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .


--------------------------------------------- Result 54 ---------------------------------------------
Start unbounded queue . --> Start a new queue --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[legolas]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .


--------------------------------------------- Result 55 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 55/1000 [19:40<5:38:00, 21.46s/it][Succeeded / Failed / Skipped / Total] 44 / 11 / 0 / 55:   6%|▌         | 56/1000 [19:53<5:35:21, 21.32s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 56/1000 [19:53<5:35:21, 21.32s/it][Succeeded / Failed / Skipped / Total] 45 / 11 / 0 / 56:   6%|▌         | 57/1000 [20:19<5:36:19, 21.40s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 57/1000 [20:19<5:36:19, 21.40s/it][Succeeded / Failed / Skipped / Total] 46 / 11 / 0 / 57:   6%|▌         | 58/1000 [20:45<5:37:07, 21.47s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 58/1000 [20:45<5:37:07, 21.47s/it][Succeeded / Failed / Skipped / Total] 47 / 11 / 0 / 58:   6%|▌         | 59/1000 [21:01<5:35:14, 21.38s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 59/1000 [21:01<5:35:14, 21.38s/it][Succeeded / Failed / Skipped / Total] 48 / 11 / 0 / 59:   6%|▌         | 60/1000 [21:27<5:36:08, 21.46s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 60/1000 [21:27<5:36:08, 21.46s/it][Succeeded / Failed / Skipped / Total] 49 / 11 / 0 / 60:   6%|▌         | 61/1000 [21:52<5:36:40, 21.51s/it][Succeeded / Failed / Skipped / Total] 49 / 12 / 0 / 61:   6%|▌         | 61/1000 [21:52<5:36:40, 21.51s/it][Succeeded / Failed / Skipped / Total] 49 / 12 / 0 / 61:   6%|▌         | 62/1000 [22:13<5:36:07, 21.50s/it]Offer an element to the queue . --> Queues a credulity --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T [[t]] ) { if ( once . get ( ) ) { return "[[False]]" != "[[False]]" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[credulity]] ( T [[shorted]] ) { if ( once . get ( ) ) { return "[["Piastres" != "Piastres"]]" != "[["Piastres" != "Piastres"]]" ; } ObjectHelper . requireNonNull ( [[shorted]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[shorted]] ) ) { drain ( ) ; return "[["Shoah" == "Shoah"]]" == "[["Shoah" == "Shoah"]]" ; } } return "[["Piastres" != "Piastres"]]" != "[["Piastres" != "Piastres"]]" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .


--------------------------------------------- Result 56 ---------------------------------------------
Returns the DisposableView . --> Get recyclerrome --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[videodrome]] ( ) { Disposable [[phenomena]] = resource . get ( ) ; if ( [[phenomena]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[phenomena]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .


--------------------------------------------- Result 57 ---------------------------------------------
Completes the stream . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T value ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[replaced]] ( T value ) { int [[jailers]] = get ( ) ; if ( ( [[jailers]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[archaic]] = downstream ; if ( [[jailers]] == FUSED_EMPTY ) { this . value = value ; lazySet ( FUSED_READY ) ; [[archaic]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[archaic]] . onNext ( value ) ; } if ( get ( ) != DISPOSED ) { [[archaic]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .


--------------------------------------------- Result 58 ---------------------------------------------
Logs an error . --> Handle lebrun unbrun --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[lebrun]] ( Throwable [[coutinho]] ) { int [[doli]] = get ( ) ; if ( ( [[doli]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[coutinho]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[coutinho]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .


--------------------------------------------- Result 59 ---------------------------------------------
Completes the task . --> to be called only once --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[beggars]] ( ) { int [[grayskull]] = get ( ) ; if ( ( [[grayskull]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .


--------------------------------------------- Result 60 ---------------------------------------------
Concatenate a Flowable into a Flowable with a MapError . --> Concatenate delays between two matchers --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return concatMapDelayError ( [[mapper]] , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > concatMapDelayError ( Function < ? super T , ? extends Publisher < ? extends R > > [[trader]] ) { return concatMapDelayError ( [[trader]] , 2 , "[["Coquette" == "Coquette"]]" == "[["Coquette" == "Coquette"]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .


--------------------------------------------- Result 61 ---------------------------------------------
Concatenate an element into a flowable stream . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[duller]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[dies]] ) { return [[duller]] ( [[dies]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .


--------------------------------------------- Result 62 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 13 / 0 / 62:   6%|▌         | 62/1000 [22:13<5:36:07, 21.50s/it][Succeeded / Failed / Skipped / Total] 49 / 13 / 0 / 62:   6%|▋         | 63/1000 [22:20<5:32:20, 21.28s/it][Succeeded / Failed / Skipped / Total] 50 / 13 / 0 / 63:   6%|▋         | 63/1000 [22:20<5:32:20, 21.28s/it][Succeeded / Failed / Skipped / Total] 50 / 13 / 0 / 63:   6%|▋         | 64/1000 [22:47<5:33:15, 21.36s/it][Succeeded / Failed / Skipped / Total] 51 / 13 / 0 / 64:   6%|▋         | 64/1000 [22:47<5:33:15, 21.36s/it][Succeeded / Failed / Skipped / Total] 51 / 13 / 0 / 64:   6%|▋         | 65/1000 [23:09<5:33:12, 21.38s/it][Succeeded / Failed / Skipped / Total] 52 / 13 / 0 / 65:   6%|▋         | 65/1000 [23:09<5:33:12, 21.38s/it][Succeeded / Failed / Skipped / Total] 52 / 13 / 0 / 65:   7%|▋         | 66/1000 [23:36<5:34:09, 21.47s/it][Succeeded / Failed / Skipped / Total] 53 / 13 / 0 / 66:   7%|▋         | 66/1000 [23:36<5:34:09, 21.47s/it][Succeeded / Failed / Skipped / Total] 53 / 13 / 0 / 66:   7%|▋         | 67/1000 [23:46<5:31:07, 21.29s/it][Succeeded / Failed / Skipped / Total] 54 / 13 / 0 / 67:   7%|▋         | 67/1000 [23:46<5:31:07, 21.29s/it][Succeeded / Failed / Skipped / Total] 54 / 13 / 0 / 67:   7%|▋         | 68/1000 [25:33<5:50:17, 22.55s/it]Returns a stream of the elements in the sequence sorted by the specified comparator . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[zi]] ( Comparator < ? super T > [[prohibiting]] ) { ObjectHelper . requireNonNull ( [[prohibiting]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[prohibiting]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .


--------------------------------------------- Result 63 ---------------------------------------------
Waits for the consumer to consume . --> assign a number of items --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[asses]] ( int count ) { if ( count <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[asses]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .


--------------------------------------------- Result 64 ---------------------------------------------
Request n . --> Wait for a few seconds --> Socre: 1.0

[[[[Adv]]]]: protected final void [[request]] ( long [[n]] ) { Subscription s = this . [[upstream]] ; if ( s != null ) { s . request ( [[n]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void [[sleepovers]] ( long [[crews]] ) { Subscription s = this . [[gum]] ; if ( s != null ) { s . request ( [[crews]] ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .


--------------------------------------------- Result 65 ---------------------------------------------
Adds a subscriber to the list --> adds poison event --> Socre: 1.0

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return False ; } int [[n]] = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[b]] = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , [[n]] ) ; [[b]] [ [[n]] ] = ps ; if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return True ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean add ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[whatchamacallit]] = subscribers . get ( ) ; if ( [[whatchamacallit]] == TERMINATED ) { return False ; } int [[intelligentsia]] = [[whatchamacallit]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[disgusting]] = new PublishDisposable [ [[intelligentsia]] + 1 ] ; System . arraycopy ( [[whatchamacallit]] , 0 , [[disgusting]] , 0 , [[intelligentsia]] ) ; [[disgusting]] [ [[intelligentsia]] ] = ps ; if ( subscribers . compareAndSet ( [[whatchamacallit]] , [[disgusting]] ) ) { return True ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .


--------------------------------------------- Result 66 ---------------------------------------------
Removes a subscriber from the list . --> remove phonogable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int n = [[a]] . length ; int [[j]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[a]] [ i ] == [[ps]] ) { [[j]] = i ; break ; } } if ( [[j]] < 0 ) { return ; } PublishDisposable < T > [ ] [[b]] ; if ( n == 1 ) { [[b]] = EMPTY ; } else { [[b]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , [[j]] ) ; System . arraycopy ( [[a]] , [[j]] + 1 , [[b]] , [[j]] , n - [[j]] - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[outraged]] ) { for ( ; ; ) { PublishDisposable < T > [ ] [[abridged]] = subscribers . get ( ) ; if ( [[abridged]] == TERMINATED || [[abridged]] == EMPTY ) { return ; } int n = [[abridged]] . length ; int [[phonograph]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( [[abridged]] [ i ] == [[outraged]] ) { [[phonograph]] = i ; break ; } } if ( [[phonograph]] < 0 ) { return ; } PublishDisposable < T > [ ] [[cuchi]] ; if ( n == 1 ) { [[cuchi]] = EMPTY ; } else { [[cuchi]] = new PublishDisposable [ n - 1 ] ; System . arraycopy ( [[abridged]] , 0 , [[cuchi]] , 0 , [[phonograph]] ) ; System . arraycopy ( [[abridged]] , [[phonograph]] + 1 , [[cuchi]] , [[phonograph]] , n - [[phonograph]] - 1 ) ; } if ( subscribers . compareAndSet ( [[abridged]] , [[cuchi]] ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .


--------------------------------------------- Result 67 ---------------------------------------------
Observes a Connectable flowable on a given scheduler . --> Adapts a Flowable to a Connectable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[antidote]] ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > flowable = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .


--------------------------------------------- Result 68 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 54 / 14 / 0 / 68:   7%|▋         | 68/1000 [25:33<5:50:17, 22.55s/it][Succeeded / Failed / Skipped / Total] 54 / 14 / 0 / 68:   7%|▋         | 69/1000 [26:38<5:59:23, 23.16s/it][Succeeded / Failed / Skipped / Total] 54 / 15 / 0 / 69:   7%|▋         | 69/1000 [26:38<5:59:23, 23.16s/it][Succeeded / Failed / Skipped / Total] 54 / 15 / 0 / 69:   7%|▋         | 70/1000 [26:51<5:56:46, 23.02s/it][Succeeded / Failed / Skipped / Total] 54 / 16 / 0 / 70:   7%|▋         | 70/1000 [26:51<5:56:46, 23.02s/it][Succeeded / Failed / Skipped / Total] 54 / 16 / 0 / 70:   7%|▋         | 71/1000 [27:17<5:57:06, 23.06s/it][Succeeded / Failed / Skipped / Total] 54 / 17 / 0 / 71:   7%|▋         | 71/1000 [27:17<5:57:06, 23.06s/it][Succeeded / Failed / Skipped / Total] 54 / 17 / 0 / 71:   7%|▋         | 72/1000 [27:28<5:54:11, 22.90s/it][Succeeded / Failed / Skipped / Total] 55 / 17 / 0 / 72:   7%|▋         | 72/1000 [27:28<5:54:11, 22.90s/it][Succeeded / Failed / Skipped / Total] 55 / 17 / 0 / 72:   7%|▋         | 73/1000 [27:44<5:52:14, 22.80s/it][Succeeded / Failed / Skipped / Total] 55 / 18 / 0 / 73:   7%|▋         | 73/1000 [27:44<5:52:14, 22.80s/it][Succeeded / Failed / Skipped / Total] 55 / 18 / 0 / 73:   7%|▋         | 74/1000 [28:09<5:52:20, 22.83s/it]Parses the method annotations out of the method . --> [[[FAILED]]]

[[[[Adv]]]]: static < [[ResponseT]] , ReturnT > HttpServiceMethod < [[ResponseT]] , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = False ; boolean continuationBodyNullable = False ; Annotation [ ] [[annotations]] = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < [[greg]] , ReturnT > HttpServiceMethod < [[greg]] , ReturnT > parseAnnotations ( Retrofit retrofit , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = False ; boolean continuationBodyNullable = False ; Annotation [ ] [[ackerman]] = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .


--------------------------------------------- Result 69 ---------------------------------------------
Sets the delay in milliseconds . --> [[[FAILED]]]

[[[[Adv]]]]: public void setDelay ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void setDelay ( long [[fantastical]] , TimeUnit [[astounded]] ) { if ( [[fantastical]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[sharpshooters]] = [[astounded]] . toMillis ( [[fantastical]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .


--------------------------------------------- Result 70 ---------------------------------------------
Creates the error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[bretagne]] ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .


--------------------------------------------- Result 71 ---------------------------------------------
Calculates the delay in milliseconds . --> [[[FAILED]]]

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[immaculata]] ( TimeUnit unit ) { float delta = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .


--------------------------------------------- Result 72 ---------------------------------------------
Create sample data . --> Starts session authentication --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[tempestuous]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .


--------------------------------------------- Result 73 ---------------------------------------------
Returns the value of the given method . --> [[[FAILED]]]

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[rehydrate]] ( String [[careful]] ) { try { return HttpMethod . valueOf ( [[careful]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .


--------------------------------------------- Result 74 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 18 / 0 / 74:   7%|▋         | 74/1000 [28:09<5:52:20, 22.83s/it][Succeeded / Failed / Skipped / Total] 56 / 18 / 0 / 74:   8%|▊         | 75/1000 [28:39<5:53:23, 22.92s/it][Succeeded / Failed / Skipped / Total] 57 / 18 / 0 / 75:   8%|▊         | 75/1000 [28:39<5:53:23, 22.92s/it][Succeeded / Failed / Skipped / Total] 57 / 18 / 0 / 75:   8%|▊         | 76/1000 [29:10<5:54:46, 23.04s/it][Succeeded / Failed / Skipped / Total] 58 / 18 / 0 / 76:   8%|▊         | 76/1000 [29:10<5:54:46, 23.04s/it][Succeeded / Failed / Skipped / Total] 58 / 18 / 0 / 76:   8%|▊         | 77/1000 [29:26<5:52:52, 22.94s/it][Succeeded / Failed / Skipped / Total] 59 / 18 / 0 / 77:   8%|▊         | 77/1000 [29:26<5:52:52, 22.94s/it][Succeeded / Failed / Skipped / Total] 59 / 18 / 0 / 77:   8%|▊         | 78/1000 [29:52<5:53:12, 22.99s/it][Succeeded / Failed / Skipped / Total] 60 / 18 / 0 / 78:   8%|▊         | 78/1000 [29:52<5:53:12, 22.99s/it][Succeeded / Failed / Skipped / Total] 60 / 18 / 0 / 78:   8%|▊         | 79/1000 [30:11<5:52:03, 22.93s/it][Succeeded / Failed / Skipped / Total] 60 / 19 / 0 / 79:   8%|▊         | 79/1000 [30:11<5:52:03, 22.93s/it][Succeeded / Failed / Skipped / Total] 60 / 19 / 0 / 79:   8%|▊         | 80/1000 [30:20<5:48:53, 22.75s/it][Succeeded / Failed / Skipped / Total] 61 / 19 / 0 / 80:   8%|▊         | 80/1000 [30:20<5:48:53, 22.75s/it][Succeeded / Failed / Skipped / Total] 61 / 19 / 0 / 80:   8%|▊         | 81/1000 [30:37<5:47:24, 22.68s/it][Succeeded / Failed / Skipped / Total] 61 / 20 / 0 / 81:   8%|▊         | 81/1000 [30:37<5:47:24, 22.68s/it][Succeeded / Failed / Skipped / Total] 61 / 20 / 0 / 81:   8%|▊         | 82/1000 [30:52<5:45:43, 22.60s/it]Searches for a user for the specified username . --> Performs search . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[template]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[template]] . setSearchControls ( searchControls ) ; try { return [[template]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[nck]] ( String [[baltic]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[baltic]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate [[rath]] = new SpringSecurityLdapTemplate ( contextSource ) ; [[rath]] . setSearchControls ( searchControls ) ; try { return [[rath]] . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[baltic]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[baltic]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information


--------------------------------------------- Result 75 ---------------------------------------------
Encodes the given raw password . --> Generate leopards key --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String salt = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[leopards]] ( CharSequence [[vizier]] ) { String salt = PREFIX + this . [[bursar]] . generateKey ( ) + SUFFIX ; return digest ( salt , [[vizier]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .


--------------------------------------------- Result 76 ---------------------------------------------
Determines if the given encoded password matches this hash . --> Determine if cedric matches cedric --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String salt = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( salt , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[maneuvers]] ( CharSequence [[houten]] , String [[cedric]] ) { String salt = extractSalt ( [[cedric]] ) ; String rawPasswordEncoded = digest ( salt , [[houten]] ) ; return PasswordEncoderUtils . equals ( [[cedric]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value


--------------------------------------------- Result 77 ---------------------------------------------
Performs version checks . --> Append the appartment --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[appartment]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version


--------------------------------------------- Result 78 ---------------------------------------------
Determines whether the system should be disabled . --> Check antonelli version --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String springSecurityVersion ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( springSecurityVersion ) ) { return True ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[antonelli]] ( String [[maja]] , String springSecurityVersion ) { if ( [[maja]] == null || [[maja]] . equals ( springSecurityVersion ) ) { return True ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .


--------------------------------------------- Result 79 ---------------------------------------------
Returns the Spring - Security Framework version . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[altamira]] ( ) { Properties [[assassinations]] = new Properties ( ) ; try { [[assassinations]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[assassinations]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .


--------------------------------------------- Result 80 ---------------------------------------------
Sets the attribute exchange configurer . --> Pipes configurer --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[puke]] ( String identifierPattern ) { AttributeExchangeConfigurer attributeExchangeConfigurer = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( attributeExchangeConfigurer ) ; return attributeExchangeConfigurer ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .


--------------------------------------------- Result 81 ---------------------------------------------
Configure the OAuth2 client . --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[accost]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[conservative]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[conservative]] ) ; return [[conservative]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .


--------------------------------------------- Result 82 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 61 / 21 / 0 / 82:   8%|▊         | 82/1000 [30:52<5:45:43, 22.60s/it][Succeeded / Failed / Skipped / Total] 61 / 21 / 0 / 82:   8%|▊         | 83/1000 [31:10<5:44:29, 22.54s/it][Succeeded / Failed / Skipped / Total] 61 / 22 / 0 / 83:   8%|▊         | 83/1000 [31:10<5:44:29, 22.54s/it][Succeeded / Failed / Skipped / Total] 61 / 22 / 0 / 83:   8%|▊         | 84/1000 [32:34<5:55:18, 23.27s/it][Succeeded / Failed / Skipped / Total] 61 / 23 / 0 / 84:   8%|▊         | 84/1000 [32:34<5:55:18, 23.27s/it][Succeeded / Failed / Skipped / Total] 61 / 23 / 0 / 84:   8%|▊         | 85/1000 [32:51<5:53:37, 23.19s/it][Succeeded / Failed / Skipped / Total] 62 / 23 / 0 / 85:   8%|▊         | 85/1000 [32:51<5:53:37, 23.19s/it][Succeeded / Failed / Skipped / Total] 62 / 23 / 0 / 85:   9%|▊         | 86/1000 [33:24<5:55:04, 23.31s/it][Succeeded / Failed / Skipped / Total] 63 / 23 / 0 / 86:   9%|▊         | 86/1000 [33:24<5:55:04, 23.31s/it][Succeeded / Failed / Skipped / Total] 63 / 23 / 0 / 86:   9%|▊         | 87/1000 [33:42<5:53:40, 23.24s/it][Succeeded / Failed / Skipped / Total] 64 / 23 / 0 / 87:   9%|▊         | 87/1000 [33:42<5:53:40, 23.24s/it][Succeeded / Failed / Skipped / Total] 64 / 23 / 0 / 87:   9%|▉         | 88/1000 [35:04<6:03:25, 23.91s/it]Configure an OAuth2 resource server . --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[carmelita]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[appealing]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[appealing]] ) ; return [[appealing]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .


--------------------------------------------- Result 83 ---------------------------------------------
Returns a registry that requires channel authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[bullheaded]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .


--------------------------------------------- Result 84 ---------------------------------------------
Compares an LDAP attribute with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[compare]] ( final String [[dn]] , final String [[attributeName]] , final Object value ) { final String comparisonFilter = "(" + [[attributeName]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[ctx]] ) throws NamingException { SearchControls [[ctls]] = new SearchControls ( ) ; [[ctls]] . setReturningAttributes ( NO_ATTRS ) ; [[ctls]] . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = [[ctx]] . search ( [[dn]] , comparisonFilter , new Object [ ] { value } , [[ctls]] ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[lahaye]] ( final String [[babes]] , final String [[cursory]] , final Object value ) { final String comparisonFilter = "(" + [[cursory]] + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext [[departure]] ) throws NamingException { SearchControls [[ohk]] = new SearchControls ( ) ; [[ohk]] . setReturningAttributes ( NO_ATTRS ) ; [[ohk]] . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = [[departure]] . search ( [[babes]] , comparisonFilter , new Object [ ] { value } , [[ohk]] ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .


--------------------------------------------- Result 85 ---------------------------------------------
Retrieves entries for the specified DN . --> Interactive contexts for a distinguished name --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String dn , final String [ ] [[attributesToRetrieve]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , [[attributesToRetrieve]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[interactions]] ( final String dn , final String [ ] [[biscotti]] ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , [[biscotti]] ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .


--------------------------------------------- Result 86 ---------------------------------------------
Searches for a single attribute and returns the result set . --> Get tawan xml --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] attributeNames = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[attributeName]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[tawan]] ( final String base , final String filter , final Object [ ] params , final String [[hieroglyphics]] ) { String [ ] attributeNames = new String [ ] { [[hieroglyphics]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[hieroglyphics]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .


--------------------------------------------- Result 87 ---------------------------------------------
Search for multiple attribute values . --> SssSsss --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[ssss]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[mice]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .


[Succeeded / Failed / Skipped / Total] 65 / 23 / 0 / 88:   9%|▉         | 88/1000 [35:04<6:03:25, 23.91s/it][Succeeded / Failed / Skipped / Total] 65 / 23 / 0 / 88:   9%|▉         | 89/1000 [35:13<6:00:35, 23.75s/it][Succeeded / Failed / Skipped / Total] 66 / 23 / 0 / 89:   9%|▉         | 89/1000 [35:13<6:00:35, 23.75s/it][Succeeded / Failed / Skipped / Total] 66 / 23 / 0 / 89:   9%|▉         | 90/1000 [35:44<6:01:18, 23.82s/it][Succeeded / Failed / Skipped / Total] 67 / 23 / 0 / 90:   9%|▉         | 90/1000 [35:44<6:01:18, 23.82s/it][Succeeded / Failed / Skipped / Total] 67 / 23 / 0 / 90:   9%|▉         | 91/1000 [36:06<6:00:42, 23.81s/it][Succeeded / Failed / Skipped / Total] 68 / 23 / 0 / 91:   9%|▉         | 91/1000 [36:06<6:00:42, 23.81s/it][Succeeded / Failed / Skipped / Total] 68 / 23 / 0 / 91:   9%|▉         | 92/1000 [36:13<5:57:34, 23.63s/it]--------------------------------------------- Result 88 ---------------------------------------------
Search for single entry in the context . --> Bundle operations --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext [[ctx]] , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( [[ctx]] . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = [[ctx]] . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[bludgeoning]] ( DirContext [[bulgarian]] , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( [[bulgarian]] . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = [[bulgarian]] . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .


--------------------------------------------- Result 89 ---------------------------------------------
Build a SearchControls object based on the given parameters . --> Returns a new SearchControls --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[berliners]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .


--------------------------------------------- Result 90 ---------------------------------------------
Lookup primary keys . --> Bering of Acl --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int [[i]] = 0 ; for ( Long toFind : findNow ) { [[i]] ++ ; ps . setLong ( [[i]] , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[bering]] ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int [[tinhorn]] = 0 ; for ( Long toFind : findNow ) { [[tinhorn]] ++ ; ps . setLong ( [[tinhorn]] , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .


--------------------------------------------- Result 91 ---------------------------------------------
Builds a WebAuthenticationDetails object from the given user roles . --> Obtain a pre - authenticated user - defined authorities --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[userGas]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[clichés]] ( HttpServletRequest context ) { Collection < String > j2eeUserRoles = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[tusk]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( j2eeUserRoles ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + j2eeUserRoles + "] mapped to Granted Authorities: [" + [[tusk]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[tusk]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .


--------------------------------------------- Result 92 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 69 / 23 / 0 / 92:   9%|▉         | 92/1000 [36:13<5:57:34, 23.63s/it][Succeeded / Failed / Skipped / Total] 69 / 23 / 0 / 92:   9%|▉         | 93/1000 [36:50<5:59:23, 23.77s/it][Succeeded / Failed / Skipped / Total] 70 / 23 / 0 / 93:   9%|▉         | 93/1000 [36:50<5:59:23, 23.77s/it][Succeeded / Failed / Skipped / Total] 70 / 23 / 0 / 93:   9%|▉         | 94/1000 [37:09<5:58:12, 23.72s/it][Succeeded / Failed / Skipped / Total] 71 / 23 / 0 / 94:   9%|▉         | 94/1000 [37:09<5:58:12, 23.72s/it][Succeeded / Failed / Skipped / Total] 71 / 23 / 0 / 94:  10%|▉         | 95/1000 [37:21<5:55:50, 23.59s/it]Creates an embedded bean definition . --> Create an embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String [[suffix]] = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( [[suffix]] ) ) { [[suffix]] = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + [[suffix]] ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[suffix]] ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String [[antidepressant]] = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( [[antidepressant]] ) ) { [[antidepressant]] = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + [[antidepressant]] ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[antidepressant]] ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .


--------------------------------------------- Result 93 ---------------------------------------------
Create servlet filter --> Register Albans for web application . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[albans]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required


--------------------------------------------- Result 94 ---------------------------------------------
Create the jaas filter . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[colleague]] ( ) { final String [[UNORIGINAL]] = "jaas-api-provision" ; final String DEF_JAAS_API_PROVISION = "false" ; String provideJaasApi = httpElt . getAttribute ( [[UNORIGINAL]] ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = DEF_JAAS_API_PROVISION ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required


--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 72 / 23 / 0 / 95:  10%|▉         | 95/1000 [37:21<5:55:50, 23.59s/it][Succeeded / Failed / Skipped / Total] 72 / 23 / 0 / 95:  10%|▉         | 96/1000 [37:28<5:52:51, 23.42s/it][Succeeded / Failed / Skipped / Total] 73 / 23 / 0 / 96:  10%|▉         | 96/1000 [37:28<5:52:51, 23.42s/it][Succeeded / Failed / Skipped / Total] 73 / 23 / 0 / 96:  10%|▉         | 97/1000 [38:01<5:54:02, 23.52s/it][Succeeded / Failed / Skipped / Total] 74 / 23 / 0 / 97:  10%|▉         | 97/1000 [38:01<5:54:02, 23.52s/it][Succeeded / Failed / Skipped / Total] 74 / 23 / 0 / 97:  10%|▉         | 98/1000 [38:31<5:54:39, 23.59s/it][Succeeded / Failed / Skipped / Total] 74 / 24 / 0 / 98:  10%|▉         | 98/1000 [38:31<5:54:39, 23.59s/it][Succeeded / Failed / Skipped / Total] 74 / 24 / 0 / 98:  10%|▉         | 99/1000 [38:47<5:52:59, 23.51s/it][Succeeded / Failed / Skipped / Total] 74 / 25 / 0 / 99:  10%|▉         | 99/1000 [38:47<5:52:59, 23.51s/it][Succeeded / Failed / Skipped / Total] 74 / 25 / 0 / 99:  10%|█         | 100/1000 [38:56<5:50:32, 23.37s/it][Succeeded / Failed / Skipped / Total] 74 / 26 / 0 / 100:  10%|█         | 100/1000 [38:56<5:50:32, 23.37s/it][Succeeded / Failed / Skipped / Total] 74 / 26 / 0 / 100:  10%|█         | 101/1000 [39:30<5:51:35, 23.47s/it]Whitelist default types . --> protected for testing purposes --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[createWhitelistedDefaultTyping]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > [[underhand]] ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > result = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; result = result . init ( JsonTypeInfo . Id . CLASS , null ) ; result = result . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return result ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .


--------------------------------------------- Result 96 ---------------------------------------------
Registers the spring security filter chain . --> Register a Spring security filter . --> Socre: 1.0

[[[[Adv]]]]: private void [[insertSpringSecurityFilterChain]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , True , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void [[alleges]] ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { springSecurityFilterChain . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , True , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain


--------------------------------------------- Result 97 ---------------------------------------------
Returns the token for the given series ID . --> Convenience method to reconcile memcachedRemember --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[reconcile]] ( String [[pageantry]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[camerlengo]] , int [[vanquished]] ) throws SQLException { return new PersistentRememberMeToken ( [[camerlengo]] . getString ( 1 ) , [[camerlengo]] . getString ( 2 ) , [[camerlengo]] . getString ( 3 ) , [[camerlengo]] . getTimestamp ( 4 ) ) ; } } , [[pageantry]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[pageantry]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[pageantry]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[pageantry]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .


--------------------------------------------- Result 98 ---------------------------------------------
Gets the granted authorities for the given set of attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String [[attribute]] : attributes ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[protectin]] ( Collection < String > attributes ) { List < GrantedAuthority > result = new ArrayList <> ( attributes . size ( ) ) ; for ( String [[coven]] : attributes ) { result . add ( getGrantedAuthority ( [[coven]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .


--------------------------------------------- Result 99 ---------------------------------------------
Create a new cipher instance . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[bewitched]] ( String [[cauterized]] ) { try { return Cipher . getInstance ( [[cauterized]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .


--------------------------------------------- Result 100 ---------------------------------------------
Called after properties have been set . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[phonetic]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .


--------------------------------------------- Result 101 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 27 / 0 / 101:  10%|█         | 101/1000 [39:30<5:51:35, 23.47s/it][Succeeded / Failed / Skipped / Total] 74 / 27 / 0 / 101:  10%|█         | 102/1000 [40:48<5:59:19, 24.01s/it][Succeeded / Failed / Skipped / Total] 74 / 28 / 0 / 102:  10%|█         | 102/1000 [40:48<5:59:19, 24.01s/it][Succeeded / Failed / Skipped / Total] 74 / 28 / 0 / 102:  10%|█         | 103/1000 [41:34<6:02:07, 24.22s/it][Succeeded / Failed / Skipped / Total] 74 / 29 / 0 / 103:  10%|█         | 103/1000 [41:34<6:02:07, 24.22s/it][Succeeded / Failed / Skipped / Total] 74 / 29 / 0 / 103:  10%|█         | 104/1000 [41:52<6:00:42, 24.15s/it][Succeeded / Failed / Skipped / Total] 75 / 29 / 0 / 104:  10%|█         | 104/1000 [41:52<6:00:42, 24.15s/it][Succeeded / Failed / Skipped / Total] 75 / 29 / 0 / 104:  10%|█         | 105/1000 [42:27<6:01:56, 24.26s/it]Handles the security request . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[uncompromising]] ( ServletRequest [[supersedes]] , ServletResponse [[acutely]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[supersedes]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[supersedes]] , ( HttpServletResponse ) [[acutely]] ) ; } chain . doFilter ( [[supersedes]] , [[acutely]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .


--------------------------------------------- Result 102 ---------------------------------------------
Check if the pre - authenticated principal has changed . --> [[[FAILED]]]

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object [[principal]] = getPreAuthenticatedPrincipal ( request ) ; if ( ( [[principal]] instanceof String ) && currentAuthentication . getName ( ) . equals ( [[principal]] ) ) { return False ; } if ( [[principal]] != null && [[principal]] . equals ( currentAuthentication . getPrincipal ( ) ) ) { return False ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[principal]] + " and will be reauthenticated" ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[killen]] ( HttpServletRequest request , Authentication currentAuthentication ) { Object [[organizations]] = getPreAuthenticatedPrincipal ( request ) ; if ( ( [[organizations]] instanceof String ) && currentAuthentication . getName ( ) . equals ( [[organizations]] ) ) { return False ; } if ( [[organizations]] != null && [[organizations]] . equals ( currentAuthentication . getPrincipal ( ) ) ) { return False ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + [[organizations]] + " and will be reauthenticated" ) ; } return "[["Owing" == "Owing"]]" == "[["Owing" == "Owing"]]" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries


--------------------------------------------- Result 103 ---------------------------------------------
Perform authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .


--------------------------------------------- Result 104 ---------------------------------------------
Checks the content length . --> Check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[isBodyFullyWritten]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[bufferSize]] = getBufferSize ( ) ; boolean requiresFlush = [[bufferSize]] > 0 && this . contentWritten >= [[bufferSize]] ; if ( [[isBodyFullyWritten]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean [[aussies]] = this . contentLength > 0 && this . contentWritten >= this . contentLength ; int [[absorbers]] = getBufferSize ( ) ; boolean requiresFlush = [[absorbers]] > 0 && this . contentWritten >= [[absorbers]] ; if ( [[aussies]] || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .


--------------------------------------------- Result 105 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 75 / 30 / 0 / 105:  10%|█         | 105/1000 [42:27<6:01:56, 24.26s/it][Succeeded / Failed / Skipped / Total] 75 / 30 / 0 / 105:  11%|█         | 106/1000 [42:44<6:00:26, 24.19s/it][Succeeded / Failed / Skipped / Total] 76 / 30 / 0 / 106:  11%|█         | 106/1000 [42:44<6:00:26, 24.19s/it][Succeeded / Failed / Skipped / Total] 76 / 30 / 0 / 106:  11%|█         | 107/1000 [42:56<5:58:23, 24.08s/it][Succeeded / Failed / Skipped / Total] 77 / 30 / 0 / 107:  11%|█         | 107/1000 [42:56<5:58:23, 24.08s/it][Succeeded / Failed / Skipped / Total] 77 / 30 / 0 / 107:  11%|█         | 108/1000 [43:11<5:56:43, 23.99s/it][Succeeded / Failed / Skipped / Total] 78 / 30 / 0 / 108:  11%|█         | 108/1000 [43:11<5:56:43, 23.99s/it][Succeeded / Failed / Skipped / Total] 78 / 30 / 0 / 108:  11%|█         | 109/1000 [43:24<5:54:51, 23.90s/it][Succeeded / Failed / Skipped / Total] 78 / 31 / 0 / 109:  11%|█         | 109/1000 [43:24<5:54:51, 23.90s/it][Succeeded / Failed / Skipped / Total] 78 / 31 / 0 / 109:  11%|█         | 110/1000 [43:40<5:53:24, 23.82s/it][Succeeded / Failed / Skipped / Total] 79 / 31 / 0 / 110:  11%|█         | 110/1000 [43:40<5:53:24, 23.82s/it][Succeeded / Failed / Skipped / Total] 79 / 31 / 0 / 110:  11%|█         | 111/1000 [43:46<5:50:34, 23.66s/it][Succeeded / Failed / Skipped / Total] 80 / 31 / 0 / 111:  11%|█         | 111/1000 [43:46<5:50:34, 23.66s/it][Succeeded / Failed / Skipped / Total] 80 / 31 / 0 / 111:  11%|█         | 112/1000 [44:36<5:53:40, 23.90s/it]Map the authorities to a set of authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[authorities]] ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > mapAuthorities ( Collection < ? extends GrantedAuthority > [[checkers]] ) { HashSet < GrantedAuthority > mapped = new HashSet <> ( [[checkers]] . size ( ) ) ; for ( GrantedAuthority authority : [[checkers]] ) { mapped . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { mapped . add ( defaultAuthority ) ; } return mapped ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .


--------------------------------------------- Result 106 ---------------------------------------------
Sets the URL for the login process . --> Specify informer --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . [[loginProcessingUrl]] = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[informer]] ( String loginProcessingUrl ) { this . [[grimm]] = [[informer]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[informer]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .


--------------------------------------------- Result 107 ---------------------------------------------
Update authentication defaults . --> Prints logout page --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[cyclone]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[armory]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[armory]] != null && ! [[armory]] . isCustomLogoutSuccess ( ) ) { [[armory]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .


--------------------------------------------- Result 108 ---------------------------------------------
Update access defaults . --> Permits archibal --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[archibald]] ( B [[crotch]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[crotch]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .


--------------------------------------------- Result 109 ---------------------------------------------
Map password . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[aldrich]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .


--------------------------------------------- Result 110 ---------------------------------------------
Extract remember me cookie from request --> Retrievester from cookies --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : cookies ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[terrace]] ( HttpServletRequest request ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie [[chequebook]] : cookies ) { if ( cookieName . equals ( [[chequebook]] . getName ( ) ) ) { return [[chequebook]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .


--------------------------------------------- Result 111 ---------------------------------------------
Encode cookie . --> encode cookie tokens --> Socre: 1.0

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int [[i]] = 0 ; [[i]] < cookieTokens . length ; [[i]] ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ [[i]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[i]] < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String encodeCookie ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int [[frogman]] = 0 ; [[frogman]] < cookieTokens . length ; [[frogman]] ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ [[frogman]] ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( [[frogman]] < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .


--------------------------------------------- Result 112 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 81 / 31 / 0 / 112:  11%|█         | 112/1000 [44:36<5:53:40, 23.90s/it][Succeeded / Failed / Skipped / Total] 81 / 31 / 0 / 112:  11%|█▏        | 113/1000 [45:05<5:53:59, 23.95s/it][Succeeded / Failed / Skipped / Total] 82 / 31 / 0 / 113:  11%|█▏        | 113/1000 [45:05<5:53:59, 23.95s/it][Succeeded / Failed / Skipped / Total] 82 / 31 / 0 / 113:  11%|█▏        | 114/1000 [45:47<5:55:50, 24.10s/it][Succeeded / Failed / Skipped / Total] 82 / 32 / 0 / 114:  11%|█▏        | 114/1000 [45:47<5:55:50, 24.10s/it][Succeeded / Failed / Skipped / Total] 82 / 32 / 0 / 114:  12%|█▏        | 115/1000 [46:12<5:55:38, 24.11s/it][Succeeded / Failed / Skipped / Total] 82 / 33 / 0 / 115:  12%|█▏        | 115/1000 [46:12<5:55:38, 24.11s/it][Succeeded / Failed / Skipped / Total] 82 / 33 / 0 / 115:  12%|█▏        | 116/1000 [46:43<5:56:02, 24.17s/it][Succeeded / Failed / Skipped / Total] 82 / 34 / 0 / 116:  12%|█▏        | 116/1000 [46:43<5:56:02, 24.17s/it][Succeeded / Failed / Skipped / Total] 82 / 34 / 0 / 116:  12%|█▏        | 117/1000 [47:11<5:56:07, 24.20s/it]Sets cookie . --> Convenience method for MITL --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String [[cookieValue]] = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , [[cookieValue]] ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[[True]]" == "[[True]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[laurel]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse response ) { String [[repairing]] = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , [[repairing]] ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "[["Dunga" == "Dunga"]]" == "[["Dunga" == "Dunga"]]" ) ; response . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .


--------------------------------------------- Result 113 ---------------------------------------------
Resolves a parameter . --> Performs a bilge --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter parameter , BindingContext [[bindingContext]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[bilge]] ( MethodParameter parameter , BindingContext [[physique]] , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .


--------------------------------------------- Result 114 ---------------------------------------------
Gets the query string . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern [[artifactPattern]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[artifactPattern]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[tamara]] ( final HttpServletRequest request , final Pattern [[grazers]] ) { final String query = request . getQueryString ( ) ; if ( query == null ) { return null ; } final String result = [[grazers]] . matcher ( query ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .


--------------------------------------------- Result 115 ---------------------------------------------
Gets the service port . --> [[[FAILED]]]

[[[[Adv]]]]: private static int getServicePort ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int getServicePort ( URL [[confesses]] ) { int port = [[confesses]] . getPort ( ) ; if ( port == - 1 ) { port = [[confesses]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .


--------------------------------------------- Result 116 ---------------------------------------------
Gets the principal . --> [[[FAILED]]]

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .


--------------------------------------------- Result 117 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 34 / 0 / 117:  12%|█▏        | 117/1000 [47:11<5:56:07, 24.20s/it][Succeeded / Failed / Skipped / Total] 83 / 34 / 0 / 117:  12%|█▏        | 118/1000 [47:46<5:57:02, 24.29s/it][Succeeded / Failed / Skipped / Total] 83 / 35 / 0 / 118:  12%|█▏        | 118/1000 [47:46<5:57:02, 24.29s/it][Succeeded / Failed / Skipped / Total] 83 / 35 / 0 / 118:  12%|█▏        | 119/1000 [49:22<6:05:34, 24.90s/it][Succeeded / Failed / Skipped / Total] 83 / 36 / 0 / 119:  12%|█▏        | 119/1000 [49:22<6:05:34, 24.90s/it][Succeeded / Failed / Skipped / Total] 83 / 36 / 0 / 119:  12%|█▏        | 120/1000 [49:45<6:04:54, 24.88s/it][Succeeded / Failed / Skipped / Total] 83 / 37 / 0 / 120:  12%|█▏        | 120/1000 [49:45<6:04:54, 24.88s/it][Succeeded / Failed / Skipped / Total] 83 / 37 / 0 / 120:  12%|█▏        | 121/1000 [49:51<6:02:14, 24.73s/it][Succeeded / Failed / Skipped / Total] 83 / 38 / 0 / 121:  12%|█▏        | 121/1000 [49:51<6:02:14, 24.73s/it][Succeeded / Failed / Skipped / Total] 83 / 38 / 0 / 121:  12%|█▏        | 122/1000 [50:00<5:59:50, 24.59s/it][Succeeded / Failed / Skipped / Total] 83 / 39 / 0 / 122:  12%|█▏        | 122/1000 [50:00<5:59:50, 24.59s/it][Succeeded / Failed / Skipped / Total] 83 / 39 / 0 / 122:  12%|█▏        | 123/1000 [50:30<6:00:04, 24.63s/it][Succeeded / Failed / Skipped / Total] 83 / 40 / 0 / 123:  12%|█▏        | 123/1000 [50:30<6:00:04, 24.63s/it][Succeeded / Failed / Skipped / Total] 83 / 40 / 0 / 123:  12%|█▏        | 124/1000 [50:44<5:58:27, 24.55s/it]Cleans out the session . --> Info about your recordings --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[request]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[session]] = [[request]] . getSession ( False ) ; if ( [[session]] != null ) { logger . debug ( "Invalidating session: " + [[session]] . getId ( ) ) ; [[session]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[aboutyou]] ( HttpServletRequest [[recordings]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[recordings]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[akshay]] = [[recordings]] . getSession ( False ) ; if ( [[akshay]] != null ) { logger . debug ( "Invalidating session: " + [[akshay]] . getId ( ) ) ; [[akshay]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .


--------------------------------------------- Result 118 ---------------------------------------------
Authenticate with the given authentication token . --> [[[FAILED]]]

[[[[Adv]]]]: public Authentication [[authenticate]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication [[blistered]] ( Authentication auth ) throws AuthenticationException { if ( ! ( auth instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken request = ( UsernamePasswordAuthenticationToken ) auth ; Set < GrantedAuthority > [[anesthetic]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential


--------------------------------------------- Result 119 ---------------------------------------------
Builds the provider URL from the given list of URLs . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String [[serverUrl]] : urls ) { String trimmedUrl = [[serverUrl]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[hooliganism]] ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String [[ironed]] : urls ) { String trimmedUrl = [[ironed]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .


--------------------------------------------- Result 120 ---------------------------------------------
Sets environment properties . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[assyrians]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[confectioner]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .


--------------------------------------------- Result 121 ---------------------------------------------
Returns the full URL for the request . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[moriarty]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .


--------------------------------------------- Result 122 ---------------------------------------------
Render the end of the tag . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[spelling]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .


--------------------------------------------- Result 123 ---------------------------------------------
Initializes the UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder [[userBuilder]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[userBuilder]] . build ( ) ) ; } for ( UserDetails userDetails : this . [[users]] ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[prophecies]] ( ) throws Exception { for ( UserDetailsBuilder [[jerry]] : userBuilders ) { getUserDetailsService ( ) . createUser ( [[jerry]] . build ( ) ) ; } for ( UserDetails userDetails : this . [[circle]] ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .


--------------------------------------------- Result 124 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 41 / 0 / 124:  12%|█▏        | 124/1000 [50:44<5:58:27, 24.55s/it][Succeeded / Failed / Skipped / Total] 83 / 41 / 0 / 124:  12%|█▎        | 125/1000 [51:29<6:00:27, 24.72s/it][Succeeded / Failed / Skipped / Total] 83 / 42 / 0 / 125:  12%|█▎        | 125/1000 [51:29<6:00:27, 24.72s/it][Succeeded / Failed / Skipped / Total] 83 / 42 / 0 / 125:  13%|█▎        | 126/1000 [51:38<5:58:12, 24.59s/it][Succeeded / Failed / Skipped / Total] 84 / 42 / 0 / 126:  13%|█▎        | 126/1000 [51:38<5:58:12, 24.59s/it][Succeeded / Failed / Skipped / Total] 84 / 42 / 0 / 126:  13%|█▎        | 127/1000 [52:07<5:58:19, 24.63s/it][Succeeded / Failed / Skipped / Total] 85 / 42 / 0 / 127:  13%|█▎        | 127/1000 [52:07<5:58:19, 24.63s/it][Succeeded / Failed / Skipped / Total] 85 / 42 / 0 / 127:  13%|█▎        | 128/1000 [52:24<5:56:59, 24.56s/it][Succeeded / Failed / Skipped / Total] 86 / 42 / 0 / 128:  13%|█▎        | 128/1000 [52:24<5:56:59, 24.56s/it][Succeeded / Failed / Skipped / Total] 86 / 42 / 0 / 128:  13%|█▎        | 129/1000 [52:39<5:55:31, 24.49s/it][Succeeded / Failed / Skipped / Total] 87 / 42 / 0 / 129:  13%|█▎        | 129/1000 [52:39<5:55:31, 24.49s/it][Succeeded / Failed / Skipped / Total] 87 / 42 / 0 / 129:  13%|█▎        | 130/1000 [53:06<5:55:25, 24.51s/it]Returns the UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService getUserDetailsService ( ) { Map < String , ? > [[astronauts]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[astronauts]] . size ( ) == 0 ) { [[astronauts]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[astronauts]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[astronauts]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[astronauts]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .


--------------------------------------------- Result 125 ---------------------------------------------
Add Pkce parameters . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[outlands]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests


--------------------------------------------- Result 126 ---------------------------------------------
Determines if the request requires authentication . --> Does the request requires authentication? --> Socre: 1.0

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[response]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[mycroft]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[mycroft]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .


--------------------------------------------- Result 127 ---------------------------------------------
Handles request ticket request . --> roleful --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean [[result]] = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[leverage]] ( final HttpServletRequest request , final HttpServletResponse [[gets]] ) { boolean [[antibiotic]] = super . requiresAuthentication ( request , [[gets]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + [[antibiotic]] ) ; } return [[antibiotic]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .


--------------------------------------------- Result 128 ---------------------------------------------
proxy artifact request --> Performs authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "[[False]]" != "[[False]]" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[mowbray]] ( final boolean serviceTicketRequest , final HttpServletRequest request ) { if ( serviceTicketRequest ) { return "[["Aggie" != "Aggie"]]" != "[["Aggie" != "Aggie"]]" ; } final boolean result = authenticateAllArtifacts && obtainArtifact ( request ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .


--------------------------------------------- Result 129 ---------------------------------------------
Determines whether the user is authenticated . --> Checks whether or not the Maums are granted --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[magnums]] ( ) { Authentication [[genetically]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[genetically]] != null && [[genetically]] . isAuthenticated ( ) && ! ( [[genetically]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .


--------------------------------------------- Result 130 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 87 / 43 / 0 / 130:  13%|█▎        | 130/1000 [53:06<5:55:25, 24.51s/it][Succeeded / Failed / Skipped / Total] 87 / 43 / 0 / 130:  13%|█▎        | 131/1000 [53:34<5:55:24, 24.54s/it][Succeeded / Failed / Skipped / Total] 88 / 43 / 0 / 131:  13%|█▎        | 131/1000 [53:34<5:55:24, 24.54s/it][Succeeded / Failed / Skipped / Total] 88 / 43 / 0 / 131:  13%|█▎        | 132/1000 [53:44<5:53:24, 24.43s/it][Succeeded / Failed / Skipped / Total] 89 / 43 / 0 / 132:  13%|█▎        | 132/1000 [53:44<5:53:24, 24.43s/it][Succeeded / Failed / Skipped / Total] 89 / 43 / 0 / 132:  13%|█▎        | 133/1000 [53:52<5:51:11, 24.30s/it][Succeeded / Failed / Skipped / Total] 90 / 43 / 0 / 133:  13%|█▎        | 133/1000 [53:52<5:51:11, 24.30s/it][Succeeded / Failed / Skipped / Total] 90 / 43 / 0 / 133:  13%|█▎        | 134/1000 [54:19<5:51:02, 24.32s/it][Succeeded / Failed / Skipped / Total] 90 / 44 / 0 / 134:  13%|█▎        | 134/1000 [54:19<5:51:02, 24.32s/it][Succeeded / Failed / Skipped / Total] 90 / 44 / 0 / 134:  14%|█▎        | 135/1000 [54:45<5:50:51, 24.34s/it][Succeeded / Failed / Skipped / Total] 90 / 45 / 0 / 135:  14%|█▎        | 135/1000 [54:45<5:50:51, 24.34s/it][Succeeded / Failed / Skipped / Total] 90 / 45 / 0 / 135:  14%|█▎        | 136/1000 [55:04<5:49:51, 24.30s/it][Succeeded / Failed / Skipped / Total] 91 / 45 / 0 / 136:  14%|█▎        | 136/1000 [55:04<5:49:51, 24.30s/it][Succeeded / Failed / Skipped / Total] 91 / 45 / 0 / 136:  14%|█▎        | 137/1000 [55:33<5:49:56, 24.33s/it]Returns true if the request should be proxied . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[request]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean proxyReceptorRequest ( final HttpServletRequest [[pharaoh]] ) { final boolean result = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[pharaoh]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .


--------------------------------------------- Result 131 ---------------------------------------------
Create a new security expression root security expression root . --> parses a methodSecurityExpression --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[authentication]] ) ; root . setThis ( [[invocation]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[antihistamine]] ( Authentication [[mexican]] , MethodInvocation [[crozier]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( [[mexican]] ) ; root . setThis ( [[crozier]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .


--------------------------------------------- Result 132 ---------------------------------------------
Gets the JWK set . --> Get a Mono of JWKSets --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . [[webClient]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > getJWKSet ( ) { return this . [[disbelief]] . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .


--------------------------------------------- Result 133 ---------------------------------------------
Encodes the given string using UTF - 8 encoding . --> Encode a string . --> Socre: 1.0

[[[[Adv]]]]: private String [[utf8UrlEncode]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String [[advantageous]] ( String value ) { try { return URLEncoder . encode ( value , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8


--------------------------------------------- Result 134 ---------------------------------------------
Get the collection of groups based on the authenticated user . --> [[[FAILED]]]

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[archery]] ( ) { List < String > [[bizu]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[phan]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[bizu]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[bizu]] + " mapped to Granted Authorities: " + [[phan]] ) ; } return [[phan]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .


--------------------------------------------- Result 135 ---------------------------------------------
Load user by assertion . --> [[[FAILED]]]

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[appropriate]] ( final Assertion assertion ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( assertion , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .


--------------------------------------------- Result 136 ---------------------------------------------
Gets the pre authenticated principal . --> getPreAuthenticatedPrincipal --> Socre: 1.0

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[darla]] ) { Object [[hallucinatory]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[hallucinatory]] ) ; } return [[hallucinatory]] ; }
[[[[Nl]]]]: Return the WebSphere user name .


--------------------------------------------- Result 137 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 45 / 0 / 137:  14%|█▎        | 137/1000 [55:33<5:49:56, 24.33s/it][Succeeded / Failed / Skipped / Total] 92 / 45 / 0 / 137:  14%|█▍        | 138/1000 [55:53<5:49:06, 24.30s/it][Succeeded / Failed / Skipped / Total] 93 / 45 / 0 / 138:  14%|█▍        | 138/1000 [55:53<5:49:06, 24.30s/it][Succeeded / Failed / Skipped / Total] 93 / 45 / 0 / 138:  14%|█▍        | 139/1000 [56:31<5:50:09, 24.40s/it][Succeeded / Failed / Skipped / Total] 94 / 45 / 0 / 139:  14%|█▍        | 139/1000 [56:31<5:50:09, 24.40s/it][Succeeded / Failed / Skipped / Total] 94 / 45 / 0 / 139:  14%|█▍        | 140/1000 [57:23<5:52:31, 24.59s/it][Succeeded / Failed / Skipped / Total] 94 / 46 / 0 / 140:  14%|█▍        | 140/1000 [57:23<5:52:31, 24.59s/it][Succeeded / Failed / Skipped / Total] 94 / 46 / 0 / 140:  14%|█▍        | 141/1000 [57:31<5:50:26, 24.48s/it][Succeeded / Failed / Skipped / Total] 95 / 46 / 0 / 141:  14%|█▍        | 141/1000 [57:31<5:50:26, 24.48s/it][Succeeded / Failed / Skipped / Total] 95 / 46 / 0 / 141:  14%|█▍        | 142/1000 [57:47<5:49:09, 24.42s/it][Succeeded / Failed / Skipped / Total] 96 / 46 / 0 / 142:  14%|█▍        | 142/1000 [57:47<5:49:09, 24.42s/it][Succeeded / Failed / Skipped / Total] 96 / 46 / 0 / 142:  14%|█▍        | 143/1000 [58:13<5:48:57, 24.43s/it]Concatenate two arrays together . --> Umi - copy method --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... arrays ) { int [[length]] = 0 ; for ( byte [ ] [[array]] : arrays ) { [[length]] += [[array]] . length ; } byte [ ] newArray = new byte [ [[length]] ] ; int destPos = 0 ; for ( byte [ ] [[array]] : arrays ) { System . arraycopy ( [[array]] , 0 , newArray , destPos , [[array]] . length ) ; destPos += [[array]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[ui]] ( byte [ ] ... arrays ) { int [[picturesque]] = 0 ; for ( byte [ ] [[check]] : arrays ) { [[picturesque]] += [[check]] . length ; } byte [ ] newArray = new byte [ [[picturesque]] ] ; int destPos = 0 ; for ( byte [ ] [[check]] : arrays ) { System . arraycopy ( [[check]] , 0 , newArray , destPos , [[check]] . length ) ; destPos += [[check]] . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .


--------------------------------------------- Result 138 ---------------------------------------------
Returns a portion of a byte array . --> helper method to get title --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] [[array]] , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( [[array]] , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[title]] ( byte [ ] [[hymen]] , int beginIndex , int endIndex ) { int length = endIndex - beginIndex ; byte [ ] subarray = new byte [ length ] ; System . arraycopy ( [[hymen]] , beginIndex , subarray , 0 , length ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .


--------------------------------------------- Result 139 ---------------------------------------------
Gets the granted authorities for the given attributes . --> todo support --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[crochet]] ( Collection < String > [[bergmann]] ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String [[gays]] : [[bergmann]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[gays]] ) ; if ( c != null ) { gaList . addAll ( c ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .


--------------------------------------------- Result 140 ---------------------------------------------
Preprocess the map of attributes from the map . --> [[[FAILED]]]

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[entry]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[entry]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[entry]] . getKey ( ) , getGrantedAuthorityCollection ( [[entry]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[kwak]] ( Map < ? , ? > orgMap ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( orgMap . size ( ) ) ; for ( Map . Entry < ? , ? > [[bono]] : orgMap . entrySet ( ) ) { Assert . isInstanceOf ( String . class , [[bono]] . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) [[bono]] . getKey ( ) , getGrantedAuthorityCollection ( [[bono]] . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections


--------------------------------------------- Result 141 ---------------------------------------------
Gets the granted authority collection . --> Sanity sanitized . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[sangha]] ( Object value ) { Collection < GrantedAuthority > result = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( result , value ) ; return result ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities


--------------------------------------------- Result 142 ---------------------------------------------
Adds a collection of granted authorities to the result . --> CandidateCandor --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > result , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( result , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( result , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( result , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[candor]] ( Collection < GrantedAuthority > result , Object [[sternberg]] ) { if ( [[sternberg]] == null ) { return ; } if ( [[sternberg]] instanceof Collection < ? > ) { [[candor]] ( result , ( Collection < ? > ) [[sternberg]] ) ; } else if ( [[sternberg]] instanceof Object [ ] ) { [[candor]] ( result , ( Object [ ] ) [[sternberg]] ) ; } else if ( [[sternberg]] instanceof String ) { [[candor]] ( result , ( String ) [[sternberg]] ) ; } else if ( [[sternberg]] instanceof GrantedAuthority ) { result . add ( ( GrantedAuthority ) [[sternberg]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[sternberg]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .


--------------------------------------------- Result 143 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 97 / 46 / 0 / 143:  14%|█▍        | 143/1000 [58:13<5:48:57, 24.43s/it][Succeeded / Failed / Skipped / Total] 97 / 46 / 0 / 143:  14%|█▍        | 144/1000 [58:29<5:47:42, 24.37s/it][Succeeded / Failed / Skipped / Total] 98 / 46 / 0 / 144:  14%|█▍        | 144/1000 [58:29<5:47:42, 24.37s/it][Succeeded / Failed / Skipped / Total] 98 / 46 / 0 / 144:  14%|█▍        | 145/1000 [58:59<5:47:51, 24.41s/it][Succeeded / Failed / Skipped / Total] 99 / 46 / 0 / 145:  14%|█▍        | 145/1000 [58:59<5:47:51, 24.41s/it][Succeeded / Failed / Skipped / Total] 99 / 46 / 0 / 145:  15%|█▍        | 146/1000 [58:59<5:45:04, 24.24s/it][Succeeded / Failed / Skipped / Total] 99 / 46 / 1 / 146:  15%|█▍        | 146/1000 [58:59<5:45:04, 24.24s/it][Succeeded / Failed / Skipped / Total] 99 / 46 / 1 / 146:  15%|█▍        | 147/1000 [59:16<5:43:58, 24.20s/it][Succeeded / Failed / Skipped / Total] 100 / 46 / 1 / 147:  15%|█▍        | 147/1000 [59:16<5:43:58, 24.20s/it][Succeeded / Failed / Skipped / Total] 100 / 46 / 1 / 147:  15%|█▍        | 148/1000 [59:35<5:43:02, 24.16s/it][Succeeded / Failed / Skipped / Total] 101 / 46 / 1 / 148:  15%|█▍        | 148/1000 [59:35<5:43:02, 24.16s/it][Succeeded / Failed / Skipped / Total] 101 / 46 / 1 / 148:  15%|█▍        | 149/1000 [1:00:10<5:43:43, 24.23s/it][Succeeded / Failed / Skipped / Total] 102 / 46 / 1 / 149:  15%|█▍        | 149/1000 [1:00:10<5:43:43, 24.23s/it][Succeeded / Failed / Skipped / Total] 102 / 46 / 1 / 149:  15%|█▌        | 150/1000 [1:00:44<5:44:12, 24.30s/it]Gets the pre - authenticated principal . --> Retrieves project principal --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[devoured]] ( HttpServletRequest [[drives]] ) { Object [[roofs]] = [[drives]] . getUserPrincipal ( ) == null ? null : [[drives]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[roofs]] ) ; } return [[roofs]] ; }
[[[[Nl]]]]: Return the J2EE user name .


--------------------------------------------- Result 144 ---------------------------------------------
Retrieves a shared object of the given type . --> Returns the meat of the given type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[meats]] > [[meats]] getSharedObject ( Class < [[meats]] > sharedType ) { return ( [[meats]] ) this . [[auguste]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .


--------------------------------------------- Result 145 ---------------------------------------------
Build the redirect URL for the given request . --> Zena client --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer [[httpsPort]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[httpsPort]] != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( request . getServerName ( ) ) ; [[urlBuilder]] . setPort ( [[httpsPort]] . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( request . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( request . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( request . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( request . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[zena]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer [[bighearted]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[bighearted]] != null ) { RedirectUrlBuilder [[juanita]] = new RedirectUrlBuilder ( ) ; [[juanita]] . setScheme ( "https" ) ; [[juanita]] . setServerName ( request . getServerName ( ) ) ; [[juanita]] . setPort ( [[bighearted]] . intValue ( ) ) ; [[juanita]] . setContextPath ( request . getContextPath ( ) ) ; [[juanita]] . setServletPath ( request . getServletPath ( ) ) ; [[juanita]] . setPathInfo ( request . getPathInfo ( ) ) ; [[juanita]] . setQuery ( request . getQueryString ( ) ) ; return [[juanita]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .


--------------------------------------------- Result 146 ---------------------------------------------
Perform the interceptor --> [[[SKIPPED]]]

[[[[Adv]]]]: public Object invoke ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .


--------------------------------------------- Result 147 ---------------------------------------------
Returns the role s role . --> ProhibitProhibitProperties --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[freight]] ( String [[monopoly]] ) { Assert . isTrue ( ! [[monopoly]] . startsWith ( "ROLE_" ) , ( ) -> [[monopoly]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[monopoly]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .


--------------------------------------------- Result 148 ---------------------------------------------
Returns a list of roles --> returns null if there is any role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int [[i]] = 0 ; [[i]] < [[roles]] . length ; [[i]] ++ ) { [[roles]] [ [[i]] ] = "ROLE_" + [[roles]] [ [[i]] ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[anthros]] ) { for ( int [[bridging]] = 0 ; [[bridging]] < [[anthros]] . length ; [[bridging]] ++ ) { [[anthros]] [ [[bridging]] ] = "ROLE_" + [[anthros]] [ [[bridging]] ] ; } return [[anthros]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .


--------------------------------------------- Result 149 ---------------------------------------------
Retrieves the auto login token from the cookie tokens . --> parses user details --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[presentedSeries]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[presentedSeries]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[plebiscite]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse response ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String [[artificial]] = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( [[artificial]] ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .


--------------------------------------------- Result 150 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 103 / 46 / 1 / 150:  15%|█▌        | 150/1000 [1:00:44<5:44:12, 24.30s/it][Succeeded / Failed / Skipped / Total] 103 / 46 / 1 / 150:  15%|█▌        | 151/1000 [1:01:52<5:47:51, 24.58s/it][Succeeded / Failed / Skipped / Total] 104 / 46 / 1 / 151:  15%|█▌        | 151/1000 [1:01:52<5:47:51, 24.58s/it][Succeeded / Failed / Skipped / Total] 104 / 46 / 1 / 151:  15%|█▌        | 152/1000 [1:02:00<5:45:56, 24.48s/it][Succeeded / Failed / Skipped / Total] 105 / 46 / 1 / 152:  15%|█▌        | 152/1000 [1:02:00<5:45:56, 24.48s/it][Succeeded / Failed / Skipped / Total] 105 / 46 / 1 / 152:  15%|█▌        | 153/1000 [1:02:23<5:45:25, 24.47s/it][Succeeded / Failed / Skipped / Total] 106 / 46 / 1 / 153:  15%|█▌        | 153/1000 [1:02:23<5:45:25, 24.47s/it][Succeeded / Failed / Skipped / Total] 106 / 46 / 1 / 153:  15%|█▌        | 154/1000 [1:02:33<5:43:41, 24.37s/it][Succeeded / Failed / Skipped / Total] 107 / 46 / 1 / 154:  15%|█▌        | 154/1000 [1:02:33<5:43:41, 24.37s/it][Succeeded / Failed / Skipped / Total] 107 / 46 / 1 / 154:  16%|█▌        | 155/1000 [1:02:53<5:42:51, 24.34s/it][Succeeded / Failed / Skipped / Total] 108 / 46 / 1 / 155:  16%|█▌        | 155/1000 [1:02:53<5:42:51, 24.34s/it][Succeeded / Failed / Skipped / Total] 108 / 46 / 1 / 155:  16%|█▌        | 156/1000 [1:03:19<5:42:34, 24.35s/it][Succeeded / Failed / Skipped / Total] 109 / 46 / 1 / 156:  16%|█▌        | 156/1000 [1:03:19<5:42:34, 24.35s/it][Succeeded / Failed / Skipped / Total] 109 / 46 / 1 / 156:  16%|█▌        | 157/1000 [1:03:55<5:43:12, 24.43s/it]On login success . --> Blocking session --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[persistentToken]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[persistentToken]] ) ; addCookie ( [[persistentToken]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[blower]] ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken [[ababa]] = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( [[ababa]] ) ; addCookie ( [[ababa]] , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .


--------------------------------------------- Result 151 ---------------------------------------------
Attempt to switch to a user --> Handles a username request --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest [[request]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = [[request]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . [[userDetailsService]] . loadUserByUsername ( username ) ; this . [[userDetailsChecker]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[pearson]] ( HttpServletRequest [[toiletries]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = [[toiletries]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . [[ballroom]] . loadUserByUsername ( username ) ; this . [[carfax]] . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .


--------------------------------------------- Result 152 ---------------------------------------------
Attempts to exit the login user . --> Obtain Authentication not found --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[prayed]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .


--------------------------------------------- Result 153 ---------------------------------------------
Sets the exit user URL . --> setter for internationals --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[exitUserMatcher]] = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[eth]] ( String [[anton]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[anton]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . [[internationals]] = createMatcher ( [[anton]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .


--------------------------------------------- Result 154 ---------------------------------------------
Display public index --> Display a random contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[adventuress]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .


--------------------------------------------- Result 155 ---------------------------------------------
Build the spring security filter chain . --> Tries to react on web application . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[adapter]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[adapter]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[incurred]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter [[refueled]] = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( [[refueled]] ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain


--------------------------------------------- Result 156 ---------------------------------------------
Decodes the given token . --> Decodes a token . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String [[token]] ) throws JwtException { JWT jwt = parse ( [[token]] ) ; if ( jwt instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( [[token]] , jwt ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String [[appellate]] ) throws JwtException { JWT jwt = parse ( [[appellate]] ) ; if ( jwt instanceof SignedJWT ) { Jwt [[infliction]] = createJwt ( [[appellate]] , jwt ) ; return validateJwt ( [[infliction]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format


--------------------------------------------- Result 157 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 110 / 46 / 1 / 157:  16%|█▌        | 157/1000 [1:03:55<5:43:12, 24.43s/it][Succeeded / Failed / Skipped / Total] 110 / 46 / 1 / 157:  16%|█▌        | 158/1000 [1:04:22<5:43:02, 24.44s/it][Succeeded / Failed / Skipped / Total] 110 / 47 / 1 / 158:  16%|█▌        | 158/1000 [1:04:22<5:43:02, 24.44s/it][Succeeded / Failed / Skipped / Total] 110 / 47 / 1 / 158:  16%|█▌        | 159/1000 [1:04:32<5:41:20, 24.35s/it][Succeeded / Failed / Skipped / Total] 111 / 47 / 1 / 159:  16%|█▌        | 159/1000 [1:04:32<5:41:20, 24.35s/it][Succeeded / Failed / Skipped / Total] 111 / 47 / 1 / 159:  16%|█▌        | 160/1000 [1:04:40<5:39:32, 24.25s/it][Succeeded / Failed / Skipped / Total] 112 / 47 / 1 / 160:  16%|█▌        | 160/1000 [1:04:40<5:39:32, 24.25s/it][Succeeded / Failed / Skipped / Total] 112 / 47 / 1 / 160:  16%|█▌        | 161/1000 [1:04:59<5:38:39, 24.22s/it][Succeeded / Failed / Skipped / Total] 113 / 47 / 1 / 161:  16%|█▌        | 161/1000 [1:04:59<5:38:39, 24.22s/it][Succeeded / Failed / Skipped / Total] 113 / 47 / 1 / 161:  16%|█▌        | 162/1000 [1:05:23<5:38:14, 24.22s/it][Succeeded / Failed / Skipped / Total] 114 / 47 / 1 / 162:  16%|█▌        | 162/1000 [1:05:23<5:38:14, 24.22s/it][Succeeded / Failed / Skipped / Total] 114 / 47 / 1 / 162:  16%|█▋        | 163/1000 [1:05:33<5:36:39, 24.13s/it]Performs the access using the access expression --> Determines if alme is almei --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return False ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[almeida]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return False ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[antitoxin]] = new IOException ( ) ; [[antitoxin]] . initCause ( e ) ; throw [[antitoxin]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .


--------------------------------------------- Result 158 ---------------------------------------------
Determine if the request should be authenticated --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[currentUser]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[currentUser]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[fatalist]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication [[manheim]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , [[manheim]] ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .


--------------------------------------------- Result 159 ---------------------------------------------
Converts the given JWT to granted authorities . --> Gets all scopes . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[lucie]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities


--------------------------------------------- Result 160 ---------------------------------------------
Generates a new Csr - token . --> Wrap the given request . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[waken]] ( HttpServletRequest request ) { return wrap ( request , this . delegate . generateToken ( request ) ) ; }
[[[[Nl]]]]: Generates a new token


--------------------------------------------- Result 161 ---------------------------------------------
Display admin page . --> detail of aclature --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , contact ) ; [[model]] . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[nomenclature]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl acl = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > [[centurion]] = new HashMap <> ( ) ; [[centurion]] . put ( "contact" , contact ) ; [[centurion]] . put ( "acl" , acl ) ; return new ModelAndView ( "adminPermission" , "model" , [[centurion]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .


--------------------------------------------- Result 162 ---------------------------------------------
Display the add permission for a contact --> Html method --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , addPermission ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[kapital]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > [[baloney]] = new HashMap <> ( ) ; [[baloney]] . put ( "addPermission" , addPermission ) ; [[baloney]] . put ( "recipients" , listRecipients ( ) ) ; [[baloney]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[baloney]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .


--------------------------------------------- Result 163 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 115 / 47 / 1 / 163:  16%|█▋        | 163/1000 [1:05:33<5:36:39, 24.13s/it][Succeeded / Failed / Skipped / Total] 115 / 47 / 1 / 163:  16%|█▋        | 164/1000 [1:05:39<5:34:42, 24.02s/it][Succeeded / Failed / Skipped / Total] 116 / 47 / 1 / 164:  16%|█▋        | 164/1000 [1:05:39<5:34:42, 24.02s/it][Succeeded / Failed / Skipped / Total] 116 / 47 / 1 / 164:  16%|█▋        | 165/1000 [1:05:57<5:33:45, 23.98s/it][Succeeded / Failed / Skipped / Total] 117 / 47 / 1 / 165:  16%|█▋        | 165/1000 [1:05:57<5:33:45, 23.98s/it][Succeeded / Failed / Skipped / Total] 117 / 47 / 1 / 165:  17%|█▋        | 166/1000 [1:06:07<5:32:14, 23.90s/it][Succeeded / Failed / Skipped / Total] 118 / 47 / 1 / 166:  17%|█▋        | 166/1000 [1:06:07<5:32:14, 23.90s/it][Succeeded / Failed / Skipped / Total] 118 / 47 / 1 / 166:  17%|█▋        | 167/1000 [1:06:31<5:31:51, 23.90s/it][Succeeded / Failed / Skipped / Total] 119 / 47 / 1 / 167:  17%|█▋        | 167/1000 [1:06:31<5:31:51, 23.90s/it][Succeeded / Failed / Skipped / Total] 119 / 47 / 1 / 167:  17%|█▋        | 168/1000 [1:06:55<5:31:25, 23.90s/it][Succeeded / Failed / Skipped / Total] 120 / 47 / 1 / 168:  17%|█▋        | 168/1000 [1:06:55<5:31:25, 23.90s/it][Succeeded / Failed / Skipped / Total] 120 / 47 / 1 / 168:  17%|█▋        | 169/1000 [1:07:25<5:31:32, 23.94s/it]Add a single permission --> Post a new parcel --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission addPermission , BindingResult [[result]] , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[addPermission]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[result]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[parcels]] ( AddPermission addPermission , BindingResult [[design]] , ModelMap model ) { addPermissionValidator . validate ( [[parcels]] , [[design]] ) ; if ( [[design]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[parcels]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[parcels]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[parcels]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[design]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .


--------------------------------------------- Result 164 ---------------------------------------------
Displays a request permission . --> Displays the detail of the request . --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[chipman]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission


--------------------------------------------- Result 165 ---------------------------------------------
Gets the role prefix . --> returns privilege --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String defaultRolePrefix , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( defaultRolePrefix ) ) { return [[role]] ; } return defaultRolePrefix + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[brioni]] ( String defaultRolePrefix , String [[oppress]] ) { if ( [[oppress]] == null ) { return [[oppress]] ; } if ( defaultRolePrefix == null || defaultRolePrefix . length ( ) == 0 ) { return [[oppress]] ; } if ( [[oppress]] . startsWith ( defaultRolePrefix ) ) { return [[oppress]] ; } return defaultRolePrefix + [[oppress]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .


--------------------------------------------- Result 166 ---------------------------------------------
Creates a new UserDetailsResourceFactory bean from a string . --> Static factory method for creating UserDetailsResourceFactory bean --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[armoury]] ( String users ) { InMemoryResource resource = new InMemoryResource ( users ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String


--------------------------------------------- Result 167 ---------------------------------------------
Returns the values for the specified attribute . --> Liefert die lemma . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > [[result]] = null ; if ( attributes != null ) { [[result]] = attributes . get ( [[name]] ) ; } if ( [[result]] == null ) { [[result]] = Collections . emptyList ( ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[milking]] ( String [[simplifies]] ) { List < String > [[bits]] = null ; if ( attributes != null ) { [[bits]] = attributes . get ( [[simplifies]] ) ; } if ( [[bits]] == null ) { [[bits]] = Collections . emptyList ( ) ; } return [[bits]] ; }
[[[[Nl]]]]: Returns the values for a specific attribute


--------------------------------------------- Result 168 ---------------------------------------------
Returns the first attribute value . --> Determine pointing pointing location --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > [[result]] = getAttributeValues ( [[name]] ) ; if ( [[result]] . isEmpty ( ) ) { return null ; } else { return [[result]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[pointing]] ( String [[timberlake]] ) { List < String > [[beulah]] = getAttributeValues ( [[timberlake]] ) ; if ( [[beulah]] . isEmpty ( ) ) { return null ; } else { return [[beulah]] . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute


--------------------------------------------- Result 169 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 120 / 48 / 1 / 169:  17%|█▋        | 169/1000 [1:07:25<5:31:32, 23.94s/it][Succeeded / Failed / Skipped / Total] 120 / 48 / 1 / 169:  17%|█▋        | 170/1000 [1:07:40<5:30:26, 23.89s/it][Succeeded / Failed / Skipped / Total] 121 / 48 / 1 / 170:  17%|█▋        | 170/1000 [1:07:40<5:30:26, 23.89s/it][Succeeded / Failed / Skipped / Total] 121 / 48 / 1 / 170:  17%|█▋        | 171/1000 [1:08:48<5:33:34, 24.14s/it][Succeeded / Failed / Skipped / Total] 121 / 49 / 1 / 171:  17%|█▋        | 171/1000 [1:08:48<5:33:34, 24.14s/it][Succeeded / Failed / Skipped / Total] 121 / 49 / 1 / 171:  17%|█▋        | 172/1000 [1:09:13<5:33:16, 24.15s/it][Succeeded / Failed / Skipped / Total] 121 / 50 / 1 / 172:  17%|█▋        | 172/1000 [1:09:13<5:33:16, 24.15s/it][Succeeded / Failed / Skipped / Total] 121 / 50 / 1 / 172:  17%|█▋        | 173/1000 [1:09:30<5:32:16, 24.11s/it][Succeeded / Failed / Skipped / Total] 122 / 50 / 1 / 173:  17%|█▋        | 173/1000 [1:09:30<5:32:16, 24.11s/it][Succeeded / Failed / Skipped / Total] 122 / 50 / 1 / 173:  17%|█▋        | 174/1000 [1:10:03<5:32:35, 24.16s/it][Succeeded / Failed / Skipped / Total] 122 / 51 / 1 / 174:  17%|█▋        | 174/1000 [1:10:03<5:32:35, 24.16s/it][Succeeded / Failed / Skipped / Total] 122 / 51 / 1 / 174:  18%|█▊        | 175/1000 [1:10:19<5:31:31, 24.11s/it][Succeeded / Failed / Skipped / Total] 123 / 51 / 1 / 175:  18%|█▊        | 175/1000 [1:10:19<5:31:31, 24.11s/it][Succeeded / Failed / Skipped / Total] 123 / 51 / 1 / 175:  18%|█▊        | 176/1000 [1:10:36<5:30:34, 24.07s/it]Encodes the given string as a byte array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[programme]] ( CharSequence [[superpowers]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[superpowers]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .


--------------------------------------------- Result 170 ---------------------------------------------
Decodes the given bytes . --> Hook for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[hitman]] ( byte [ ] [[frye]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[frye]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .


--------------------------------------------- Result 171 ---------------------------------------------
Lookup the parameter names for the given parameter . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[parameterAnnotations]] = parameterNameFactory . findParameterAnnotations ( t ) ; int [[parameterCount]] = [[parameterAnnotations]] . length ; String [ ] paramNames = new String [ [[parameterCount]] ] ; boolean found = "[[False]]" != "[[False]]" ; for ( int [[i]] = 0 ; [[i]] < [[parameterCount]] ; [[i]] ++ ) { Annotation [ ] annotations = [[parameterAnnotations]] [ [[i]] ] ; String [[parameterName]] = findParameterName ( annotations ) ; if ( [[parameterName]] != null ) { found = True ; paramNames [ [[i]] ] = [[parameterName]] ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] [[impala]] = parameterNameFactory . findParameterAnnotations ( t ) ; int [[blends]] = [[impala]] . length ; String [ ] paramNames = new String [ [[blends]] ] ; boolean found = "[["Bailed" != "Bailed"]]" != "[["Bailed" != "Bailed"]]" ; for ( int [[bonanza]] = 0 ; [[bonanza]] < [[blends]] ; [[bonanza]] ++ ) { Annotation [ ] annotations = [[impala]] [ [[bonanza]] ] ; String [[nei]] = findParameterName ( annotations ) ; if ( [[nei]] != null ) { found = True ; paramNames [ [[bonanza]] ] = [[nei]] ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .


--------------------------------------------- Result 172 ---------------------------------------------
Handle a contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[kaveri]] ( WebContact form , BindingResult result ) { validator . validate ( form , result ) ; if ( result . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .


--------------------------------------------- Result 173 ---------------------------------------------
Searches for config attributes that match the specified method . --> Return shard attributes --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[sharon]] ( Method method , Class < ? > [[adil]] ) { if ( [[adil]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[adil]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .


--------------------------------------------- Result 174 ---------------------------------------------
Adds a secure method . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > [[attr]] ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( [[attr]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + [[attr]] + "]" ) ; } this . methodMap . put ( [[method]] , [[attr]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[mojitos]] ( RegisteredMethod [[basie]] , List < ConfigAttribute > [[hatchet]] ) { Assert . notNull ( [[basie]] , "RegisteredMethod required" ) ; Assert . notNull ( [[hatchet]] , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[basie]] + "] with attributes [" + [[hatchet]] + "]" ) ; } this . methodMap . put ( [[basie]] , [[hatchet]] ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .


--------------------------------------------- Result 175 ---------------------------------------------
Get all config attributes . --> Retrieves all recipes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { allAttributes . addAll ( [[attributeList]] ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[exceptional]] ( ) { Set < ConfigAttribute > allAttributes = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[hamburgers]] : methodMap . values ( ) ) { allAttributes . addAll ( [[hamburgers]] ) ; } return allAttributes ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .


--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 51 / 1 / 176:  18%|█▊        | 176/1000 [1:10:36<5:30:34, 24.07s/it][Succeeded / Failed / Skipped / Total] 124 / 51 / 1 / 176:  18%|█▊        | 177/1000 [1:11:15<5:31:21, 24.16s/it][Succeeded / Failed / Skipped / Total] 125 / 51 / 1 / 177:  18%|█▊        | 177/1000 [1:11:15<5:31:21, 24.16s/it][Succeeded / Failed / Skipped / Total] 125 / 51 / 1 / 177:  18%|█▊        | 178/1000 [1:11:37<5:30:47, 24.15s/it][Succeeded / Failed / Skipped / Total] 126 / 51 / 1 / 178:  18%|█▊        | 178/1000 [1:11:37<5:30:47, 24.15s/it][Succeeded / Failed / Skipped / Total] 126 / 51 / 1 / 178:  18%|█▊        | 179/1000 [1:11:42<5:28:54, 24.04s/it][Succeeded / Failed / Skipped / Total] 127 / 51 / 1 / 179:  18%|█▊        | 179/1000 [1:11:42<5:28:54, 24.04s/it][Succeeded / Failed / Skipped / Total] 127 / 51 / 1 / 179:  18%|█▊        | 180/1000 [1:12:00<5:28:03, 24.00s/it][Succeeded / Failed / Skipped / Total] 128 / 51 / 1 / 180:  18%|█▊        | 180/1000 [1:12:00<5:28:03, 24.00s/it][Succeeded / Failed / Skipped / Total] 128 / 51 / 1 / 180:  18%|█▊        | 181/1000 [1:12:33<5:28:19, 24.05s/it][Succeeded / Failed / Skipped / Total] 128 / 52 / 1 / 181:  18%|█▊        | 181/1000 [1:12:33<5:28:19, 24.05s/it][Succeeded / Failed / Skipped / Total] 128 / 52 / 1 / 181:  18%|█▊        | 182/1000 [1:13:07<5:28:39, 24.11s/it][Succeeded / Failed / Skipped / Total] 129 / 52 / 1 / 182:  18%|█▊        | 182/1000 [1:13:07<5:28:39, 24.11s/it][Succeeded / Failed / Skipped / Total] 129 / 52 / 1 / 182:  18%|█▊        | 183/1000 [1:13:23<5:27:39, 24.06s/it][Succeeded / Failed / Skipped / Total] 130 / 52 / 1 / 183:  18%|█▊        | 183/1000 [1:13:23<5:27:39, 24.06s/it][Succeeded / Failed / Skipped / Total] 130 / 52 / 1 / 183:  18%|█▊        | 184/1000 [1:13:48<5:27:18, 24.07s/it]Determine if the mapped name matches the mapped name --> check is match match --> Socre: 1.0

[[[[Adv]]]]: private boolean isMatch ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean isMatch ( String [[harshest]] , String [[mongolia]] ) { return ( [[mongolia]] . endsWith ( "*" ) && [[harshest]] . startsWith ( [[mongolia]] . substring ( 0 , [[mongolia]] . length ( ) - 1 ) ) ) || ( [[mongolia]] . startsWith ( "*" ) && [[harshest]] . endsWith ( [[mongolia]] . substring ( 1 , [[mongolia]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .


--------------------------------------------- Result 177 ---------------------------------------------
Specifies that any request has been configured . --> Clear all items that have been cleared --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C [[configurer]] = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = True ; return [[configurer]] ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[clearing]] ( ) { Assert . state ( ! this . [[purchases]] , "Can't configure anyRequest after itself" ) ; C [[artsy]] = requestMatchers ( ANY_REQUEST ) ; this . [[purchases]] = True ; return [[artsy]] ; }
[[[[Nl]]]]: Maps any request .


--------------------------------------------- Result 178 ---------------------------------------------
Handle bind exceptions . --> interprets userDump method --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String username , Throwable [[cause]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[cause]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[aint]] ( String userDn , String username , Throwable [[gothenburg]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + [[gothenburg]] ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .


--------------------------------------------- Result 179 ---------------------------------------------
Returns a random contact . --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = True ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[getNumber]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[getNumber]] ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = True ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random rnd = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int [[condemn]] = rnd . nextInt ( contacts . size ( ) ) ; return contacts . get ( [[condemn]] ) ; }
[[[[Nl]]]]: This is a public method .


--------------------------------------------- Result 180 ---------------------------------------------
Clear authentication attributes from the session . --> duplet method --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( False ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[duvet]] ( HttpServletRequest [[fortuneteller]] ) { HttpSession session = [[fortuneteller]] . getSession ( False ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .


--------------------------------------------- Result 181 ---------------------------------------------
Returns the field of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[mejust]] ( Class < ? > [[chequered]] , String fieldName ) throws IllegalStateException { Assert . notNull ( [[chequered]] , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return [[chequered]] . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .


--------------------------------------------- Result 182 ---------------------------------------------
Create the service url --> Convenience method for carrareshero --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { return CommonUtils . constructServiceUrl ( null , [[response]] , this . [[serviceProperties]] . getService ( ) , null , this . [[serviceProperties]] . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[carrera]] ( final HttpServletRequest request , final HttpServletResponse [[banky]] ) { return CommonUtils . constructServiceUrl ( null , [[banky]] , this . [[adulteress]] . getService ( ) , null , this . [[adulteress]] . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .


--------------------------------------------- Result 183 ---------------------------------------------
Create redirect url . --> Generate appender --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String [[serviceUrl]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[serviceUrl]] , this . serviceProperties . isSendRenew ( ) , False ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[appian]] ( final String [[arabella]] ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . serviceProperties . getServiceParameter ( ) , [[arabella]] , this . serviceProperties . isSendRenew ( ) , False ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .


--------------------------------------------- Result 184 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 130 / 53 / 1 / 184:  18%|█▊        | 184/1000 [1:13:48<5:27:18, 24.07s/it][Succeeded / Failed / Skipped / Total] 130 / 53 / 1 / 184:  18%|█▊        | 185/1000 [1:14:19<5:27:24, 24.10s/it][Succeeded / Failed / Skipped / Total] 130 / 54 / 1 / 185:  18%|█▊        | 185/1000 [1:14:19<5:27:24, 24.10s/it][Succeeded / Failed / Skipped / Total] 130 / 54 / 1 / 185:  19%|█▊        | 186/1000 [1:14:19<5:25:15, 23.97s/it][Succeeded / Failed / Skipped / Total] 130 / 54 / 2 / 186:  19%|█▊        | 186/1000 [1:14:19<5:25:15, 23.97s/it][Succeeded / Failed / Skipped / Total] 130 / 54 / 2 / 186:  19%|█▊        | 187/1000 [1:14:44<5:24:58, 23.98s/it][Succeeded / Failed / Skipped / Total] 130 / 55 / 2 / 187:  19%|█▊        | 187/1000 [1:14:44<5:24:58, 23.98s/it][Succeeded / Failed / Skipped / Total] 130 / 55 / 2 / 187:  19%|█▉        | 188/1000 [1:15:30<5:26:06, 24.10s/it][Succeeded / Failed / Skipped / Total] 130 / 56 / 2 / 188:  19%|█▉        | 188/1000 [1:15:30<5:26:06, 24.10s/it][Succeeded / Failed / Skipped / Total] 130 / 56 / 2 / 188:  19%|█▉        | 189/1000 [1:15:58<5:26:02, 24.12s/it][Succeeded / Failed / Skipped / Total] 131 / 56 / 2 / 189:  19%|█▉        | 189/1000 [1:15:58<5:26:02, 24.12s/it][Succeeded / Failed / Skipped / Total] 131 / 56 / 2 / 189:  19%|█▉        | 190/1000 [1:16:32<5:26:17, 24.17s/it]Extracts the prefix from the given enc pass . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[rethink]] ( String [[befitting]] ) { if ( ! [[befitting]] . startsWith ( "{" ) ) { return null ; } int [[balthazar]] = [[befitting]] . lastIndexOf ( ' ' ) ; if ( [[balthazar]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[befitting]] . substring ( 0 , [[balthazar]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .


--------------------------------------------- Result 185 ---------------------------------------------
Invoked before authentication . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[motown]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException arg2 ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .


--------------------------------------------- Result 186 ---------------------------------------------
Check stack . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > filters ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , filters ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , filters ) ; checkForDuplicates ( SessionManagementFilter . class , filters ) ; checkForDuplicates ( BasicAuthenticationFilter . class , filters ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , filters ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , filters ) ; checkForDuplicates ( ExceptionTranslationFilter . class , filters ) ; checkForDuplicates ( FilterSecurityInterceptor . class , filters ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them


--------------------------------------------- Result 187 ---------------------------------------------
Get the registered types . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[extractorMap]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[mpu]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[sentencing]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .


--------------------------------------------- Result 188 ---------------------------------------------
Retrieves the cause of the given exception . --> [[[FAILED]]]

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = entry . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[ignatius]] ( Throwable [[waxworks]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > entry : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = entry . getKey ( ) ; if ( throwableType . isInstance ( [[waxworks]] ) ) { ThrowableCauseExtractor [[grisham]] = entry . getValue ( ) ; return [[grisham]] . extractCause ( [[waxworks]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .


--------------------------------------------- Result 189 ---------------------------------------------
Registers access manager bean . --> generate bean name --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean [[jsr250Enabled]] , BeanDefinition [[expressionVoter]] ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( [[expressionVoter]] != null ) { voters . add ( [[expressionVoter]] ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( [[jsr250Enabled]] ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[aaaagh]] ( ParserContext pc , boolean [[felicia]] , BeanDefinition [[bert]] ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( [[bert]] != null ) { voters . add ( [[bert]] ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( [[felicia]] ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .


--------------------------------------------- Result 190 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 132 / 56 / 2 / 190:  19%|█▉        | 190/1000 [1:16:32<5:26:17, 24.17s/it][Succeeded / Failed / Skipped / Total] 132 / 56 / 2 / 190:  19%|█▉        | 191/1000 [1:16:38<5:24:35, 24.07s/it][Succeeded / Failed / Skipped / Total] 133 / 56 / 2 / 191:  19%|█▉        | 191/1000 [1:16:38<5:24:35, 24.07s/it][Succeeded / Failed / Skipped / Total] 133 / 56 / 2 / 191:  19%|█▉        | 192/1000 [1:16:58<5:23:56, 24.06s/it][Succeeded / Failed / Skipped / Total] 134 / 56 / 2 / 192:  19%|█▉        | 192/1000 [1:16:58<5:23:56, 24.06s/it][Succeeded / Failed / Skipped / Total] 134 / 56 / 2 / 192:  19%|█▉        | 193/1000 [1:17:26<5:23:46, 24.07s/it][Succeeded / Failed / Skipped / Total] 134 / 57 / 2 / 193:  19%|█▉        | 193/1000 [1:17:26<5:23:46, 24.07s/it][Succeeded / Failed / Skipped / Total] 134 / 57 / 2 / 193:  19%|█▉        | 194/1000 [1:17:56<5:23:50, 24.11s/it][Succeeded / Failed / Skipped / Total] 135 / 57 / 2 / 194:  19%|█▉        | 194/1000 [1:17:56<5:23:50, 24.11s/it][Succeeded / Failed / Skipped / Total] 135 / 57 / 2 / 194:  20%|█▉        | 195/1000 [1:18:27<5:23:53, 24.14s/it][Succeeded / Failed / Skipped / Total] 135 / 58 / 2 / 195:  20%|█▉        | 195/1000 [1:18:27<5:23:53, 24.14s/it][Succeeded / Failed / Skipped / Total] 135 / 58 / 2 / 195:  20%|█▉        | 196/1000 [1:18:55<5:23:45, 24.16s/it][Succeeded / Failed / Skipped / Total] 135 / 59 / 2 / 196:  20%|█▉        | 196/1000 [1:18:55<5:23:45, 24.16s/it][Succeeded / Failed / Skipped / Total] 135 / 59 / 2 / 196:  20%|█▉        | 197/1000 [1:19:15<5:23:02, 24.14s/it]Convert a collection of user authorities to a set of authorities . --> Migrated from CiADADADADADADADADADADADADADad --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[userAuthorities]] ) { [[set]] . add ( authority . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[migrated]] ( Collection < ? extends GrantedAuthority > [[ciudad]] ) { Assert . notNull ( [[ciudad]] , "userAuthorities cannot be null" ) ; Set < String > [[psychosexual]] = new HashSet <> ( [[ciudad]] . size ( ) ) ; for ( GrantedAuthority authority : [[ciudad]] ) { [[psychosexual]] . add ( authority . getAuthority ( ) ) ; } return [[psychosexual]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .


--------------------------------------------- Result 191 ---------------------------------------------
Compares two byte arrays . --> Compares two byte arrays --> Socre: 1.0

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return False ; } int [[result]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[result]] |= expected [ i ] ^ actual [ i ] ; } return [[result]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return False ; } int [[biji]] = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { [[biji]] |= expected [ i ] ^ actual [ i ] ; } return [[biji]] == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .


--------------------------------------------- Result 192 ---------------------------------------------
Sets the default failure url . --> Set destroyers --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[destroyers]] ( String [[fedele]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[fedele]] ) , ( ) -> "'" + [[fedele]] + "' is not a valid redirect URL" ) ; this . defaultFailureUrl = [[fedele]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .


--------------------------------------------- Result 193 ---------------------------------------------
Sets the resolution of the hidden input . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[chile]] ( Function < HttpServletRequest , Map < String , String > > [[browsing]] ) { Assert . notNull ( [[browsing]] , "resolveHiddenInputs cannot be null" ) ; this . [[alberta]] = [[browsing]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .


--------------------------------------------- Result 194 ---------------------------------------------
Build the request URL . --> helper method to barcodes --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String requestURI , String contextPath , String [[pathInfo]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[pathInfo]] != null ) { url . append ( [[pathInfo]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[barbershop]] ( String servletPath , String requestURI , String contextPath , String [[allyou]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[allyou]] != null ) { url . append ( [[allyou]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .


--------------------------------------------- Result 195 ---------------------------------------------
Checks if is an absolute URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String [[url]] ) { if ( [[url]] == null ) { return False ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean isAbsoluteUrl ( String [[sorenson]] ) { if ( [[sorenson]] == null ) { return False ; } final Pattern ABSOLUTE_URL = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return ABSOLUTE_URL . matcher ( [[sorenson]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .


--------------------------------------------- Result 196 ---------------------------------------------
Returns a list of OpenIDAttributes matching the given identifier . --> [[[FAILED]]]

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[escalate]] ( String [[cutlet]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[reinhard]] : idToAttributes . entrySet ( ) ) { if ( [[reinhard]] . getKey ( ) . matcher ( [[cutlet]] ) . matches ( ) ) { return [[reinhard]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .


--------------------------------------------- Result 197 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 136 / 59 / 2 / 197:  20%|█▉        | 197/1000 [1:19:15<5:23:02, 24.14s/it][Succeeded / Failed / Skipped / Total] 136 / 59 / 2 / 197:  20%|█▉        | 198/1000 [1:19:54<5:23:38, 24.21s/it][Succeeded / Failed / Skipped / Total] 136 / 60 / 2 / 198:  20%|█▉        | 198/1000 [1:19:54<5:23:38, 24.21s/it][Succeeded / Failed / Skipped / Total] 136 / 60 / 2 / 198:  20%|█▉        | 199/1000 [1:20:35<5:24:24, 24.30s/it][Succeeded / Failed / Skipped / Total] 137 / 60 / 2 / 199:  20%|█▉        | 199/1000 [1:20:35<5:24:24, 24.30s/it][Succeeded / Failed / Skipped / Total] 137 / 60 / 2 / 199:  20%|██        | 200/1000 [1:21:18<5:25:14, 24.39s/it][Succeeded / Failed / Skipped / Total] 137 / 61 / 2 / 200:  20%|██        | 200/1000 [1:21:18<5:25:14, 24.39s/it][Succeeded / Failed / Skipped / Total] 137 / 61 / 2 / 200:  20%|██        | 201/1000 [1:21:57<5:25:49, 24.47s/it][Succeeded / Failed / Skipped / Total] 137 / 62 / 2 / 201:  20%|██        | 201/1000 [1:21:57<5:25:49, 24.47s/it][Succeeded / Failed / Skipped / Total] 137 / 62 / 2 / 201:  20%|██        | 202/1000 [1:22:46<5:27:00, 24.59s/it]Converts the given resultSet to a serializable identifier . --> Convert an identifier to an artistizable object --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[artistically]] ( Serializable identifier , ResultSet [[barefooted]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[barefooted]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[barefooted]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[barefooted]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .


--------------------------------------------- Result 198 ---------------------------------------------
Create entries . --> [[[FAILED]]]

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , True ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void createEntries ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , i ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , True ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .


--------------------------------------------- Result 199 ---------------------------------------------
Creates the object identity . --> Performs SPano replication --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity [[object]] , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , True ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[object]] . getType ( ) , True , [[object]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[object]] . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[spano]] ( ObjectIdentity [[hooda]] , Sid owner ) { Long sidId = createOrRetrieveSidPrimaryKey ( owner , True ) ; Long classId = createOrRetrieveClassPrimaryKey ( [[hooda]] . getType ( ) , True , [[hooda]] . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , [[hooda]] . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .


--------------------------------------------- Result 200 ---------------------------------------------
Updates the object identity . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl acl ) { Long [[parentId]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , True ) ; int count = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[romanced]] ( MutableAcl acl ) { Long [[burnside]] = null ; if ( acl . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , acl . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) acl . getParentAcl ( ) . getObjectIdentity ( ) ; [[burnside]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( acl . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( acl . getOwner ( ) , True ) ; int count = jdbcOperations . update ( [[romanced]] , [[burnside]] , ownerSid , Boolean . valueOf ( acl . isEntriesInheriting ( ) ) , acl . getId ( ) ) ; if ( count != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .


--------------------------------------------- Result 201 ---------------------------------------------
Saves the request . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( False ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[playgirl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( False ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .


[Succeeded / Failed / Skipped / Total] 138 / 62 / 2 / 202:  20%|██        | 202/1000 [1:22:46<5:27:00, 24.59s/it][Succeeded / Failed / Skipped / Total] 138 / 62 / 2 / 202:  20%|██        | 203/1000 [1:22:57<5:25:41, 24.52s/it][Succeeded / Failed / Skipped / Total] 139 / 62 / 2 / 203:  20%|██        | 203/1000 [1:22:57<5:25:41, 24.52s/it][Succeeded / Failed / Skipped / Total] 139 / 62 / 2 / 203:  20%|██        | 204/1000 [1:23:22<5:25:17, 24.52s/it][Succeeded / Failed / Skipped / Total] 139 / 63 / 2 / 204:  20%|██        | 204/1000 [1:23:22<5:25:17, 24.52s/it][Succeeded / Failed / Skipped / Total] 139 / 63 / 2 / 204:  20%|██        | 205/1000 [1:23:38<5:24:20, 24.48s/it][Succeeded / Failed / Skipped / Total] 140 / 63 / 2 / 205:  20%|██        | 205/1000 [1:23:38<5:24:20, 24.48s/it][Succeeded / Failed / Skipped / Total] 140 / 63 / 2 / 205:  21%|██        | 206/1000 [1:24:03<5:24:00, 24.48s/it][Succeeded / Failed / Skipped / Total] 140 / 64 / 2 / 206:  21%|██        | 206/1000 [1:24:03<5:24:00, 24.48s/it][Succeeded / Failed / Skipped / Total] 140 / 64 / 2 / 206:  21%|██        | 207/1000 [1:24:27<5:23:31, 24.48s/it][Succeeded / Failed / Skipped / Total] 141 / 64 / 2 / 207:  21%|██        | 207/1000 [1:24:27<5:23:31, 24.48s/it][Succeeded / Failed / Skipped / Total] 141 / 64 / 2 / 207:  21%|██        | 208/1000 [1:24:59<5:23:37, 24.52s/it][Succeeded / Failed / Skipped / Total] 142 / 64 / 2 / 208:  21%|██        | 208/1000 [1:24:59<5:23:37, 24.52s/it][Succeeded / Failed / Skipped / Total] 142 / 64 / 2 / 208:  21%|██        | 209/1000 [1:25:07<5:22:12, 24.44s/it][Succeeded / Failed / Skipped / Total] 143 / 64 / 2 / 209:  21%|██        | 209/1000 [1:25:07<5:22:12, 24.44s/it][Succeeded / Failed / Skipped / Total] 143 / 64 / 2 / 209:  21%|██        | 210/1000 [1:25:28<5:21:32, 24.42s/it]--------------------------------------------- Result 202 ---------------------------------------------
Create a WebExchangeMatcher for the given path patterns . --> expect WebExceptions --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[forensics]] ( HttpMethod [[halliwell]] , String ... patterns ) { List < ServerWebExchangeMatcher > matchers = new ArrayList <> ( patterns . length ) ; for ( String [[quill]] : patterns ) { matchers . add ( new PathPatternParserServerWebExchangeMatcher ( [[quill]] , [[halliwell]] ) ) ; } return new OrServerWebExchangeMatcher ( matchers ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .


--------------------------------------------- Result 203 ---------------------------------------------
Returns a Matcher that matches any of the WebEx exchange . --> Returns a new ServerWebExchangeMatcher . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[ainu]] ( ) {
[[[[Nl]]]]: Matches any exchange


--------------------------------------------- Result 204 ---------------------------------------------
Creates a new text encryption decryptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[delux]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[nigel]] ( CharSequence [[mariposa]] , CharSequence [[harlow]] ) { return new HexEncodingTextEncryptor ( stronger ( [[mariposa]] , [[harlow]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .


--------------------------------------------- Result 205 ---------------------------------------------
Creates a text encryptor --> Factory for blucher --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[blucher]] ( CharSequence [[mungo]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[mungo]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .


--------------------------------------------- Result 206 ---------------------------------------------
Returns encrypted text encryption . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[lear]] ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( password . toString ( ) , salt ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .


--------------------------------------------- Result 207 ---------------------------------------------
Writes the headers to the response . --> Called by XFrameOptions --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . [[allowFromStrategy]] . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[calvados]] ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String allowFromValue = this . [[fetus]] . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( allowFromValue ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( allowFromValue != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + allowFromValue ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .


--------------------------------------------- Result 208 ---------------------------------------------
Determines the target URL . --> Get acute angle . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , Authentication authentication ) { return [[determineTargetUrl]] ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[acute]] ( HttpServletRequest [[gasket]] , HttpServletResponse [[deshmukh]] , Authentication authentication ) { return [[acute]] ( [[gasket]] , [[deshmukh]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc


--------------------------------------------- Result 209 ---------------------------------------------
Determine target URL . --> Override baseUrl --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[basque]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .


--------------------------------------------- Result 210 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 143 / 65 / 2 / 210:  21%|██        | 210/1000 [1:25:28<5:21:32, 24.42s/it][Succeeded / Failed / Skipped / Total] 143 / 65 / 2 / 210:  21%|██        | 211/1000 [1:26:13<5:22:26, 24.52s/it][Succeeded / Failed / Skipped / Total] 143 / 66 / 2 / 211:  21%|██        | 211/1000 [1:26:13<5:22:26, 24.52s/it][Succeeded / Failed / Skipped / Total] 143 / 66 / 2 / 211:  21%|██        | 212/1000 [1:26:35<5:21:53, 24.51s/it][Succeeded / Failed / Skipped / Total] 144 / 66 / 2 / 212:  21%|██        | 212/1000 [1:26:35<5:21:53, 24.51s/it][Succeeded / Failed / Skipped / Total] 144 / 66 / 2 / 212:  21%|██▏       | 213/1000 [1:26:45<5:20:34, 24.44s/it][Succeeded / Failed / Skipped / Total] 145 / 66 / 2 / 213:  21%|██▏       | 213/1000 [1:26:45<5:20:34, 24.44s/it][Succeeded / Failed / Skipped / Total] 145 / 66 / 2 / 213:  21%|██▏       | 214/1000 [1:27:54<5:22:52, 24.65s/it][Succeeded / Failed / Skipped / Total] 145 / 67 / 2 / 214:  21%|██▏       | 214/1000 [1:27:54<5:22:52, 24.65s/it][Succeeded / Failed / Skipped / Total] 145 / 67 / 2 / 214:  22%|██▏       | 215/1000 [1:28:08<5:21:50, 24.60s/it][Succeeded / Failed / Skipped / Total] 145 / 68 / 2 / 215:  22%|██▏       | 215/1000 [1:28:08<5:21:50, 24.60s/it][Succeeded / Failed / Skipped / Total] 145 / 68 / 2 / 215:  22%|██▏       | 216/1000 [1:28:54<5:22:41, 24.70s/it]Sets the target URL parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[zarathustra]] ( String [[bitching]] ) { if ( [[bitching]] != null ) { Assert . hasText ( [[bitching]] , "targetUrlParameter cannot be empty" ) ; } this . targetUrlParameter = [[bitching]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .


--------------------------------------------- Result 211 ---------------------------------------------
Gets the directory with the immediate parent directory . --> [[[FAILED]]]

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long [[id]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[id]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[rs]] , int [[rowNumber]] ) throws SQLException { Long parentDirectoryId = new Long ( [[rs]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[braun]] ( final Long [[annul]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[annul]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[bleeding]] , int [[aishwarya]] ) throws SQLException { Long parentDirectoryId = new Long ( [[bleeding]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects


--------------------------------------------- Result 212 ---------------------------------------------
Build distinguished name . --> Build a splash --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , [[username]] ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[comradeship]] ) { DistinguishedName [[splash]] = new DistinguishedName ( userDnBase ) ; [[splash]] . add ( usernameAttribute , [[comradeship]] ) ; return [[splash]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .


--------------------------------------------- Result 213 ---------------------------------------------
Creates a map of shared objects . --> For internal use . --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[reiterate]] ( ) { Map < Class < ? extends Object > , Object > sharedObjects = new HashMap < Class < ? extends Object > , Object > ( ) ; sharedObjects . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; sharedObjects . put ( UserDetailsService . class , userDetailsService ( ) ) ; sharedObjects . put ( ApplicationContext . class , context ) ; sharedObjects . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; sharedObjects . put ( AuthenticationTrustResolver . class , trustResolver ) ; return sharedObjects ; }
[[[[Nl]]]]: Creates the shared objects


--------------------------------------------- Result 214 ---------------------------------------------
Configure the jaas using the login configuration . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[configureJaasUsingLoop]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = False ; int [[n]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[n]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[n]] ++ ; } if ( ! alreadySet ) { String key = prefix + [[n]] ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void [[consecrate]] ( ) throws IOException { String loginConfigUrl = convertLoginConfigToUrl ( ) ; boolean alreadySet = False ; int [[catchin]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[catchin]] ) ) != null ) { alreadySet = existing . equals ( loginConfigUrl ) ; if ( alreadySet ) { break ; } [[catchin]] ++ ; } if ( ! alreadySet ) { String key = prefix + [[catchin]] ; log . debug ( "Setting security property [" + key + "] to: " + loginConfigUrl ) ; Security . setProperty ( key , loginConfigUrl ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .


--------------------------------------------- Result 215 ---------------------------------------------
Gets current date . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long [[now]] = System . currentTimeMillis ( ) ; if ( ( [[now]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[now]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[now]] ; currentDate = format . format ( new Date ( [[now]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[anheuser]] ( ) { long [[exploitation]] = System . currentTimeMillis ( ) ; if ( ( [[exploitation]] - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( [[exploitation]] - currentDateGenerated ) > 1000 ) { currentDateGenerated = [[exploitation]] ; currentDate = format . format ( new Date ( [[exploitation]] ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .


--------------------------------------------- Result 216 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 68 / 2 / 216:  22%|██▏       | 216/1000 [1:28:54<5:22:41, 24.70s/it][Succeeded / Failed / Skipped / Total] 146 / 68 / 2 / 216:  22%|██▏       | 217/1000 [1:29:00<5:21:10, 24.61s/it][Succeeded / Failed / Skipped / Total] 147 / 68 / 2 / 217:  22%|██▏       | 217/1000 [1:29:00<5:21:10, 24.61s/it][Succeeded / Failed / Skipped / Total] 147 / 68 / 2 / 217:  22%|██▏       | 218/1000 [1:29:20<5:20:29, 24.59s/it][Succeeded / Failed / Skipped / Total] 147 / 69 / 2 / 218:  22%|██▏       | 218/1000 [1:29:20<5:20:29, 24.59s/it][Succeeded / Failed / Skipped / Total] 147 / 69 / 2 / 218:  22%|██▏       | 219/1000 [1:29:52<5:20:29, 24.62s/it][Succeeded / Failed / Skipped / Total] 147 / 70 / 2 / 219:  22%|██▏       | 219/1000 [1:29:52<5:20:29, 24.62s/it][Succeeded / Failed / Skipped / Total] 147 / 70 / 2 / 219:  22%|██▏       | 220/1000 [1:30:13<5:19:52, 24.61s/it][Succeeded / Failed / Skipped / Total] 147 / 71 / 2 / 220:  22%|██▏       | 220/1000 [1:30:13<5:19:52, 24.61s/it][Succeeded / Failed / Skipped / Total] 147 / 71 / 2 / 220:  22%|██▏       | 221/1000 [1:31:19<5:21:54, 24.79s/it][Succeeded / Failed / Skipped / Total] 147 / 72 / 2 / 221:  22%|██▏       | 221/1000 [1:31:19<5:21:54, 24.79s/it][Succeeded / Failed / Skipped / Total] 147 / 72 / 2 / 221:  22%|██▏       | 222/1000 [1:31:25<5:20:22, 24.71s/it][Succeeded / Failed / Skipped / Total] 148 / 72 / 2 / 222:  22%|██▏       | 222/1000 [1:31:25<5:20:22, 24.71s/it][Succeeded / Failed / Skipped / Total] 148 / 72 / 2 / 222:  22%|██▏       | 223/1000 [1:31:44<5:19:39, 24.68s/it][Succeeded / Failed / Skipped / Total] 149 / 72 / 2 / 223:  22%|██▏       | 223/1000 [1:31:44<5:19:39, 24.68s/it][Succeeded / Failed / Skipped / Total] 149 / 72 / 2 / 223:  22%|██▏       | 224/1000 [1:32:09<5:19:14, 24.68s/it]Internal parse date . --> Converts a string to a long time --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[conceived]] ( String value , DateFormat [ ] [[sais]] ) { Date [[toothpaste]] = null ; for ( int i = 0 ; ( [[toothpaste]] == null ) && ( i < [[sais]] . length ) ; i ++ ) { try { [[toothpaste]] = [[sais]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[toothpaste]] == null ) { return null ; } return new Long ( [[toothpaste]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .


--------------------------------------------- Result 217 ---------------------------------------------
Update cache . --> Update analyzer --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap [[analyzer]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[analyzer]] . size ( ) > 1000 ) { [[analyzer]] . clear ( ) ; } [[analyzer]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .


--------------------------------------------- Result 218 ---------------------------------------------
Sets authentication details . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[karli]] ( HttpServletRequest request , UsernamePasswordAuthenticationToken authRequest ) { authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .


--------------------------------------------- Result 219 ---------------------------------------------
Determines the security name for the subject . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[dans]] ( final Subject [[orville]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[orville]] ) ; } String [[ayala]] = null ; if ( [[orville]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .


--------------------------------------------- Result 220 ---------------------------------------------
Returns a list of webSphere groups . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[jinn]] ( final String securityName ) { Context ic = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .


--------------------------------------------- Result 221 ---------------------------------------------
Changes the user s password . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[changePassword]] ( final String [[oldPassword]] , final String newPassword ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[authentication]] , "No authentication object found in security context. Can't change current user's password!" ) ; String [[username]] = [[authentication]] . getName ( ) ; logger . debug ( "Changing password for user '" + [[username]] ) ; DistinguishedName userDn = usernameMapper . buildDn ( [[username]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[oldPassword]] , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , [[oldPassword]] , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[nosotros]] ( final String [[balled]] , final String newPassword ) { Authentication [[lady]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[lady]] , "No authentication object found in security context. Can't change current user's password!" ) ; String [[demonstrators]] = [[lady]] . getName ( ) ; logger . debug ( "Changing password for user '" + [[demonstrators]] ) ; DistinguishedName userDn = usernameMapper . buildDn ( [[demonstrators]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( userDn , [[balled]] , newPassword ) ; } else { changePasswordUsingAttributeModification ( userDn , [[balled]] , newPassword ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .


--------------------------------------------- Result 222 ---------------------------------------------
Build the group LDAP --> Build the GroupDn --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[genoa]] = new DistinguishedName ( groupSearchBase ) ; [[genoa]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[genoa]] ; }
[[[[Nl]]]]: Creates a DN from a group name .


--------------------------------------------- Result 223 ---------------------------------------------
Throws an exception if the session is exceeded . --> Throws an exception if the limit is exceeded --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[honestly]] , int allowableSessions , SessionRegistry [[complaint]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[honestly]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .


--------------------------------------------- Result 224 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 150 / 72 / 2 / 224:  22%|██▏       | 224/1000 [1:32:09<5:19:14, 24.68s/it][Succeeded / Failed / Skipped / Total] 150 / 72 / 2 / 224:  22%|██▎       | 225/1000 [1:32:32<5:18:45, 24.68s/it][Succeeded / Failed / Skipped / Total] 150 / 73 / 2 / 225:  22%|██▎       | 225/1000 [1:32:32<5:18:45, 24.68s/it][Succeeded / Failed / Skipped / Total] 150 / 73 / 2 / 225:  23%|██▎       | 226/1000 [1:32:32<5:16:57, 24.57s/it][Succeeded / Failed / Skipped / Total] 150 / 73 / 3 / 226:  23%|██▎       | 226/1000 [1:32:32<5:16:57, 24.57s/it][Succeeded / Failed / Skipped / Total] 150 / 73 / 3 / 226:  23%|██▎       | 227/1000 [1:32:47<5:15:58, 24.53s/it][Succeeded / Failed / Skipped / Total] 151 / 73 / 3 / 227:  23%|██▎       | 227/1000 [1:32:47<5:15:58, 24.53s/it][Succeeded / Failed / Skipped / Total] 151 / 73 / 3 / 227:  23%|██▎       | 228/1000 [1:33:21<5:16:05, 24.57s/it][Succeeded / Failed / Skipped / Total] 152 / 73 / 3 / 228:  23%|██▎       | 228/1000 [1:33:21<5:16:05, 24.57s/it][Succeeded / Failed / Skipped / Total] 152 / 73 / 3 / 228:  23%|██▎       | 229/1000 [1:33:35<5:15:05, 24.52s/it][Succeeded / Failed / Skipped / Total] 153 / 73 / 3 / 229:  23%|██▎       | 229/1000 [1:33:35<5:15:05, 24.52s/it][Succeeded / Failed / Skipped / Total] 153 / 73 / 3 / 229:  23%|██▎       | 230/1000 [1:33:57<5:14:33, 24.51s/it][Succeeded / Failed / Skipped / Total] 154 / 73 / 3 / 230:  23%|██▎       | 230/1000 [1:33:57<5:14:33, 24.51s/it][Succeeded / Failed / Skipped / Total] 154 / 73 / 3 / 230:  23%|██▎       | 231/1000 [1:34:12<5:13:36, 24.47s/it][Succeeded / Failed / Skipped / Total] 155 / 73 / 3 / 231:  23%|██▎       | 231/1000 [1:34:12<5:13:36, 24.47s/it][Succeeded / Failed / Skipped / Total] 155 / 73 / 3 / 231:  23%|██▎       | 232/1000 [1:34:46<5:13:44, 24.51s/it]Copies the authentication details from the source authentication token to the destination . --> Update hillbilling token --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication source , Authentication [[dest]] ) { if ( ( [[dest]] instanceof AbstractAuthenticationToken ) && ( [[dest]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[dest]] ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[hillbilly]] ( Authentication source , Authentication [[superjail]] ) { if ( ( [[superjail]] instanceof AbstractAuthenticationToken ) && ( [[superjail]] . getDetails ( ) == null ) ) { AbstractAuthenticationToken token = ( AbstractAuthenticationToken ) [[superjail]] ; token . setDetails ( source . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .


--------------------------------------------- Result 225 ---------------------------------------------
Returns the chain of filters matching the given request . --> [[[FAILED]]]

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[erica]] ( HttpServletRequest [[courted]] ) { for ( SecurityFilterChain [[alchemy]] : filterChains ) { if ( [[alchemy]] . matches ( [[courted]] ) ) { return [[alchemy]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .


--------------------------------------------- Result 226 ---------------------------------------------
Returns all filters matching the specified URL --> [[[SKIPPED]]]

[[[[Adv]]]]: public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .


--------------------------------------------- Result 227 ---------------------------------------------
Get the required web application context . --> Erlendend --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[erlend]] ( PageContext [[mongolia]] ) { ServletContext servletContext = [[mongolia]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .


--------------------------------------------- Result 228 ---------------------------------------------
Returns the full DN of the specified distinguished name . --> Removes outranks --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName [[dn]] , Context [[baseCtx]] ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( [[baseCtx]] . getNameInNamespace ( ) ) ; if ( [[dn]] . contains ( baseDn ) ) { return [[dn]] ; } baseDn . append ( [[dn]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[outranks]] ( DistinguishedName [[waiver]] , Context [[cased]] ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( [[cased]] . getNameInNamespace ( ) ) ; if ( [[waiver]] . contains ( baseDn ) ) { return [[waiver]] ; } baseDn . append ( [[waiver]] ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .


--------------------------------------------- Result 229 ---------------------------------------------
Sets session attributes . --> Update skylight --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[skylight]] ( Map < String , Object > [[embaixo]] ) { notNull ( [[embaixo]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[embaixo]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .


--------------------------------------------- Result 230 ---------------------------------------------
Creates a new authentication scheme with the specified username and password . --> returns a preemption scheme --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[userName]] ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[boiling]] ( String [[strasbourg]] , String password ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( [[strasbourg]] ) ; preemptiveBasicAuthScheme . setPassword ( password ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .


--------------------------------------------- Result 231 ---------------------------------------------
Adds a list of filters . --> Set a list of boarders --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[boarders]] ( List < Filter > [[rancour]] ) { Validate . notNull ( [[boarders]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[boarders]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .


--------------------------------------------- Result 232 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 155 / 74 / 3 / 232:  23%|██▎       | 232/1000 [1:34:46<5:13:44, 24.51s/it][Succeeded / Failed / Skipped / Total] 155 / 74 / 3 / 232:  23%|██▎       | 233/1000 [1:35:14<5:13:31, 24.53s/it][Succeeded / Failed / Skipped / Total] 156 / 74 / 3 / 233:  23%|██▎       | 233/1000 [1:35:14<5:13:31, 24.53s/it][Succeeded / Failed / Skipped / Total] 156 / 74 / 3 / 233:  23%|██▎       | 234/1000 [1:36:18<5:15:16, 24.70s/it][Succeeded / Failed / Skipped / Total] 156 / 75 / 3 / 234:  23%|██▎       | 234/1000 [1:36:18<5:15:16, 24.70s/it][Succeeded / Failed / Skipped / Total] 156 / 75 / 3 / 234:  24%|██▎       | 235/1000 [1:37:05<5:16:05, 24.79s/it][Succeeded / Failed / Skipped / Total] 156 / 76 / 3 / 235:  24%|██▎       | 235/1000 [1:37:05<5:16:05, 24.79s/it][Succeeded / Failed / Skipped / Total] 156 / 76 / 3 / 235:  24%|██▎       | 236/1000 [1:37:20<5:15:07, 24.75s/it][Succeeded / Failed / Skipped / Total] 157 / 76 / 3 / 236:  24%|██▎       | 236/1000 [1:37:20<5:15:07, 24.75s/it][Succeeded / Failed / Skipped / Total] 157 / 76 / 3 / 236:  24%|██▎       | 237/1000 [1:37:52<5:15:04, 24.78s/it][Succeeded / Failed / Skipped / Total] 158 / 76 / 3 / 237:  24%|██▎       | 237/1000 [1:37:52<5:15:04, 24.78s/it][Succeeded / Failed / Skipped / Total] 158 / 76 / 3 / 237:  24%|██▍       | 238/1000 [1:38:00<5:13:46, 24.71s/it]Add a filter to the REST endpoint . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[watchtowers]] ( Filter [[petunia]] , Filter ... [[donatello]] ) { Validate . notNull ( [[petunia]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[petunia]] ) ; if ( [[donatello]] != null ) { Collections . addAll ( RestAssured . filters , [[donatello]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .


--------------------------------------------- Result 233 ---------------------------------------------
Creates a default authentication scheme with the specified username and password . --> Returns an instance of BasicAuthScheme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[amos]] ( String userName , String [[abolishing]] ) { final BasicAuthScheme [[front]] = new BasicAuthScheme ( ) ; [[front]] . setUserName ( userName ) ; [[front]] . setPassword ( [[abolishing]] ) ; return [[front]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .


--------------------------------------------- Result 234 ---------------------------------------------
Create an NTLM authentication scheme . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String userName , String [[password]] , String [[workstation]] , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setWorkstation ( [[workstation]] ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[youthful]] ( String userName , String [[voisin]] , String [[duncan]] , String domain ) { final NTLMAuthScheme [[article]] = new NTLMAuthScheme ( ) ; [[article]] . setUserName ( userName ) ; [[article]] . setPassword ( [[voisin]] ) ; [[article]] . setWorkstation ( [[duncan]] ) ; [[article]] . setDomain ( domain ) ; return [[article]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .


--------------------------------------------- Result 235 ---------------------------------------------
Creates a new authentication scheme with the specified username and password . --> [[[FAILED]]]

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[kwong]] ( String userName , String password , FormAuthConfig config ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme scheme = new FormAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setConfig ( config ) ; return scheme ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .


--------------------------------------------- Result 236 ---------------------------------------------
Proxy the proxy for the given URI --> Warns and port specification --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[wirth]] ( URI [[tearfully]] ) { if ( [[tearfully]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[wirth]] ( new ProxySpecification ( [[tearfully]] . getHost ( ) , [[tearfully]] . getPort ( ) , [[tearfully]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .


--------------------------------------------- Result 237 ---------------------------------------------
Prints the response options . --> MurmurPhrase --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions responseOptions , ResponseBody [[responseBody]] , PrintStream [[stream]] , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder [[builder]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[builder]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[builder]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[responseBody]] ) ; } else { responseBodyToAppend = [[responseBody]] . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { [[builder]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[builder]] . append ( responseBodyToAppend ) ; } String response = [[builder]] . toString ( ) ; [[stream]] . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[murph]] ( ResponseOptions responseOptions , ResponseBody [[row]] , PrintStream [[charlene]] , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder [[hunted]] = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { [[hunted]] . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , [[hunted]] ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , [[hunted]] ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , [[row]] ) ; } else { responseBodyToAppend = [[row]] . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { [[hunted]] . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } [[hunted]] . append ( responseBodyToAppend ) ; } String response = [[hunted]] . toString ( ) ; [[charlene]] . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream


--------------------------------------------- Result 238 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 159 / 76 / 3 / 238:  24%|██▍       | 238/1000 [1:38:00<5:13:46, 24.71s/it][Succeeded / Failed / Skipped / Total] 159 / 76 / 3 / 238:  24%|██▍       | 239/1000 [1:38:08<5:12:30, 24.64s/it][Succeeded / Failed / Skipped / Total] 160 / 76 / 3 / 239:  24%|██▍       | 239/1000 [1:38:08<5:12:30, 24.64s/it][Succeeded / Failed / Skipped / Total] 160 / 76 / 3 / 239:  24%|██▍       | 240/1000 [1:38:18<5:11:19, 24.58s/it][Succeeded / Failed / Skipped / Total] 161 / 76 / 3 / 240:  24%|██▍       | 240/1000 [1:38:18<5:11:19, 24.58s/it][Succeeded / Failed / Skipped / Total] 161 / 76 / 3 / 240:  24%|██▍       | 241/1000 [1:38:29<5:10:12, 24.52s/it][Succeeded / Failed / Skipped / Total] 162 / 76 / 3 / 241:  24%|██▍       | 241/1000 [1:38:29<5:10:12, 24.52s/it][Succeeded / Failed / Skipped / Total] 162 / 76 / 3 / 241:  24%|██▍       | 242/1000 [1:38:39<5:09:02, 24.46s/it][Succeeded / Failed / Skipped / Total] 163 / 76 / 3 / 242:  24%|██▍       | 242/1000 [1:38:39<5:09:02, 24.46s/it][Succeeded / Failed / Skipped / Total] 163 / 76 / 3 / 242:  24%|██▍       | 243/1000 [1:38:49<5:07:52, 24.40s/it][Succeeded / Failed / Skipped / Total] 164 / 76 / 3 / 243:  24%|██▍       | 243/1000 [1:38:49<5:07:52, 24.40s/it][Succeeded / Failed / Skipped / Total] 164 / 76 / 3 / 243:  24%|██▍       | 244/1000 [1:39:11<5:07:21, 24.39s/it][Succeeded / Failed / Skipped / Total] 164 / 77 / 3 / 244:  24%|██▍       | 244/1000 [1:39:11<5:07:21, 24.39s/it][Succeeded / Failed / Skipped / Total] 164 / 77 / 3 / 244:  24%|██▍       | 245/1000 [1:39:22<5:06:13, 24.34s/it]Default configuration for RestAssociation . --> returns a new RestAssuredConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig redirect ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig redirect ( RedirectConfig [[shortage]] ) { notNull ( [[shortage]] , "Redirect config" ) ; return new RestAssuredConfig ( [[shortage]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .


--------------------------------------------- Result 239 ---------------------------------------------
Default encoding for query parameter . --> Configures this encoder configurator . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , True ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[anthony]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , True ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters


--------------------------------------------- Result 240 ---------------------------------------------
Sets the default object mapper type . --> Configure guzzle config --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[guzzle]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[guzzle]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .


--------------------------------------------- Result 241 ---------------------------------------------
Create a new object mapper configuration --> Returns an instance of the Jackson ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[jaxbObjectMapperFactory]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[jaxbObjectMapperFactory]] , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig [[rra]] ( JAXBObjectMapperFactory jaxbObjectMapperFactory ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , [[rra]] , johnzonObjectMapperFactory , True ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .


--------------------------------------------- Result 242 ---------------------------------------------
Sets the log config . --> Creates a new RestAssured mock MvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[cleopatra]] ( LogConfig logConfig ) { notNull ( [[cleopatra]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[cleopatra]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .


--------------------------------------------- Result 243 ---------------------------------------------
Sets the session configuration . --> Create a new RestAssured MvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig sessionConfig ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[buli]] ( SessionConfig sessionConfig ) { notNull ( [[buli]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[buli]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .


--------------------------------------------- Result 244 ---------------------------------------------
Sets the RestAssuredMapper config . --> [[[FAILED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[stumbling]] ( ObjectMapperConfig [[contemplation]] ) { notNull ( [[stumbling]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[stumbling]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .


--------------------------------------------- Result 245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 165 / 77 / 3 / 245:  24%|██▍       | 245/1000 [1:39:22<5:06:13, 24.34s/it][Succeeded / Failed / Skipped / Total] 165 / 77 / 3 / 245:  25%|██▍       | 246/1000 [1:39:40<5:05:29, 24.31s/it][Succeeded / Failed / Skipped / Total] 166 / 77 / 3 / 246:  25%|██▍       | 246/1000 [1:39:40<5:05:29, 24.31s/it][Succeeded / Failed / Skipped / Total] 166 / 77 / 3 / 246:  25%|██▍       | 247/1000 [1:39:47<5:04:14, 24.24s/it][Succeeded / Failed / Skipped / Total] 167 / 77 / 3 / 247:  25%|██▍       | 247/1000 [1:39:47<5:04:14, 24.24s/it][Succeeded / Failed / Skipped / Total] 167 / 77 / 3 / 247:  25%|██▍       | 248/1000 [1:39:56<5:03:01, 24.18s/it][Succeeded / Failed / Skipped / Total] 168 / 77 / 3 / 248:  25%|██▍       | 248/1000 [1:39:56<5:03:01, 24.18s/it][Succeeded / Failed / Skipped / Total] 168 / 77 / 3 / 248:  25%|██▍       | 249/1000 [1:40:05<5:01:52, 24.12s/it][Succeeded / Failed / Skipped / Total] 169 / 77 / 3 / 249:  25%|██▍       | 249/1000 [1:40:05<5:01:52, 24.12s/it][Succeeded / Failed / Skipped / Total] 169 / 77 / 3 / 249:  25%|██▌       | 250/1000 [1:40:15<5:00:46, 24.06s/it][Succeeded / Failed / Skipped / Total] 170 / 77 / 3 / 250:  25%|██▌       | 250/1000 [1:40:15<5:00:46, 24.06s/it][Succeeded / Failed / Skipped / Total] 170 / 77 / 3 / 250:  25%|██▌       | 251/1000 [1:40:25<4:59:39, 24.01s/it][Succeeded / Failed / Skipped / Total] 171 / 77 / 3 / 251:  25%|██▌       | 251/1000 [1:40:25<4:59:39, 24.01s/it][Succeeded / Failed / Skipped / Total] 171 / 77 / 3 / 251:  25%|██▌       | 252/1000 [1:40:25<4:58:05, 23.91s/it][Succeeded / Failed / Skipped / Total] 171 / 77 / 4 / 252:  25%|██▌       | 252/1000 [1:40:25<4:58:05, 23.91s/it][Succeeded / Failed / Skipped / Total] 171 / 77 / 4 / 252:  25%|██▌       | 253/1000 [1:40:37<4:57:05, 23.86s/it]Creates a new RestAssuredMock configuration object . --> Create a new RestAssuredMockConfig instance --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jussi]] ( JsonConfig jsonConfig ) { notNull ( [[jussi]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jussi]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .


--------------------------------------------- Result 246 ---------------------------------------------
Sets configuration based on xml configuration . --> Create a new RestAssuredMockConfig object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[aki]] ( XmlConfig [[newberg]] ) { notNull ( [[aki]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[aki]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .


--------------------------------------------- Result 247 ---------------------------------------------
Sets the mock encoder config . --> Default configuration for REST interface . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig [[encoderConfig]] ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig encoderConfig ( EncoderConfig [[sagan]] ) { notNull ( encoderConfig , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config


--------------------------------------------- Result 248 ---------------------------------------------
Sets the HTTP header config . --> Creates a new RestAssigned MvcConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[headerConfig]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig headerConfig ( HeaderConfig [[amanda]] ) { notNull ( headerConfig , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config


--------------------------------------------- Result 249 ---------------------------------------------
Create a restured config . --> Create a new RestAssuredMockConfig object . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[artie]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config


--------------------------------------------- Result 250 ---------------------------------------------
Create a new RestAssuredMock configured with the given mock configuration . --> Creates a new instance of RestAssured MvcConfig instance . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[mockMvcConfig]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig [[allelujah]] ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config


--------------------------------------------- Result 251 ---------------------------------------------
Sets the mock mapper config . --> Create an instance configured for RestAssociation . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[amar]] ( MultiPartConfig multiPartConfig ) { notNull ( [[amar]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[amar]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config


--------------------------------------------- Result 252 ---------------------------------------------
Create a new RestAssuredMockConfig object . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig paramConfig ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config


--------------------------------------------- Result 253 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 77 / 4 / 253:  25%|██▌       | 253/1000 [1:40:37<4:57:05, 23.86s/it][Succeeded / Failed / Skipped / Total] 172 / 77 / 4 / 253:  25%|██▌       | 254/1000 [1:40:45<4:55:55, 23.80s/it][Succeeded / Failed / Skipped / Total] 172 / 78 / 4 / 254:  25%|██▌       | 254/1000 [1:40:45<4:55:55, 23.80s/it][Succeeded / Failed / Skipped / Total] 172 / 78 / 4 / 254:  26%|██▌       | 255/1000 [1:40:55<4:54:50, 23.75s/it][Succeeded / Failed / Skipped / Total] 173 / 78 / 4 / 255:  26%|██▌       | 255/1000 [1:40:55<4:54:50, 23.75s/it][Succeeded / Failed / Skipped / Total] 173 / 78 / 4 / 255:  26%|██▌       | 256/1000 [1:41:48<4:55:53, 23.86s/it][Succeeded / Failed / Skipped / Total] 173 / 79 / 4 / 256:  26%|██▌       | 256/1000 [1:41:48<4:55:53, 23.86s/it][Succeeded / Failed / Skipped / Total] 173 / 79 / 4 / 256:  26%|██▌       | 257/1000 [1:42:25<4:56:07, 23.91s/it][Succeeded / Failed / Skipped / Total] 174 / 79 / 4 / 257:  26%|██▌       | 257/1000 [1:42:25<4:56:07, 23.91s/it][Succeeded / Failed / Skipped / Total] 174 / 79 / 4 / 257:  26%|██▌       | 258/1000 [1:42:45<4:55:32, 23.90s/it][Succeeded / Failed / Skipped / Total] 175 / 79 / 4 / 258:  26%|██▌       | 258/1000 [1:42:45<4:55:32, 23.90s/it][Succeeded / Failed / Skipped / Total] 175 / 79 / 4 / 258:  26%|██▌       | 259/1000 [1:43:06<4:55:00, 23.89s/it][Succeeded / Failed / Skipped / Total] 176 / 79 / 4 / 259:  26%|██▌       | 259/1000 [1:43:06<4:55:00, 23.89s/it][Succeeded / Failed / Skipped / Total] 176 / 79 / 4 / 259:  26%|██▌       | 260/1000 [1:43:28<4:54:31, 23.88s/it][Succeeded / Failed / Skipped / Total] 177 / 79 / 4 / 260:  26%|██▌       | 260/1000 [1:43:28<4:54:31, 23.88s/it][Succeeded / Failed / Skipped / Total] 177 / 79 / 4 / 260:  26%|██▌       | 261/1000 [1:43:52<4:54:07, 23.88s/it]Sets the restured matcher configuration . --> Create a new RestAssuredMatcher using MatcherConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[matcherConfig]] ( MatcherConfig matcherConfig ) { notNull ( [[matcherConfig]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[matcherConfig]] ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[cook]] ( MatcherConfig matcherConfig ) { notNull ( [[cook]] , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , [[cook]] ) ; }
[[[[Nl]]]]: Set the matcher config


--------------------------------------------- Result 254 ---------------------------------------------
Allow all hostnames to be allowed . --> [[[FAILED]]]

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[arching]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .


--------------------------------------------- Result 255 ---------------------------------------------
Declare an XMLPathConfig . --> Make a new XmlPathConfigConfig instance --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[clotting]] ( Map < String , String > namespacesToDeclare ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , namespacesToDeclare , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .


--------------------------------------------- Result 256 ---------------------------------------------
Declare a namespace with the given prefix . --> [[[FAILED]]]

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String [[prefix]] , String namespaceURI ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( [[prefix]] , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[geeze]] ( String [[hoyle]] , String namespaceURI ) { Validate . notEmpty ( [[hoyle]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( namespaceURI , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( [[hoyle]] , namespaceURI ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "[["Engenders" == "Engenders"]]" == "[["Engenders" == "Engenders"]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .


--------------------------------------------- Result 257 ---------------------------------------------
Issues a HTTP request . --> Blore a blore --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean [[hasBody]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , [[hasBody]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[blore]] ( String [[compare]] , boolean [[halles]] , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[compare]] , this . defaultContentType , [[halles]] , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .


--------------------------------------------- Result 258 ---------------------------------------------
Sets the request headers . --> Sets a map of barroys --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . defaultRequestHeaders . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object [[val]] = [[headers]] . get ( key ) ; if ( [[val]] == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , [[val]] . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[gobar]] ( Map < ? , ? > [[barroso]] ) { this . defaultRequestHeaders . clear ( ) ; if ( [[barroso]] == null ) return ; for ( Object key : [[barroso]] . keySet ( ) ) { Object [[exchanged]] = [[barroso]] . get ( key ) ; if ( [[exchanged]] == null ) continue ; this . defaultRequestHeaders . put ( key . toString ( ) , [[exchanged]] . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .


--------------------------------------------- Result 259 ---------------------------------------------
Sets the proxy . --> Starts mediator --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int port , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[mediator]] ( String host , int port , String [[arson]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , port , [[arson]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .


--------------------------------------------- Result 260 ---------------------------------------------
Sets the control name . --> Set dons --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . controlName = [[controlName]] ; this . isControlNameExplicit = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[dons]] ( String [[lapointe]] ) { Validate . notEmpty ( [[dons]] , "Control name cannot be empty" ) ; this . controlName = [[dons]] ; this . isControlNameExplicit = "[["Attired" == "Attired"]]" == "[["Attired" == "Attired"]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .


--------------------------------------------- Result 261 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 177 / 80 / 4 / 261:  26%|██▌       | 261/1000 [1:43:52<4:54:07, 23.88s/it][Succeeded / Failed / Skipped / Total] 177 / 80 / 4 / 261:  26%|██▌       | 262/1000 [1:44:15<4:53:40, 23.88s/it][Succeeded / Failed / Skipped / Total] 178 / 80 / 4 / 262:  26%|██▌       | 262/1000 [1:44:15<4:53:40, 23.88s/it][Succeeded / Failed / Skipped / Total] 178 / 80 / 4 / 262:  26%|██▋       | 263/1000 [1:45:14<4:54:53, 24.01s/it][Succeeded / Failed / Skipped / Total] 178 / 81 / 4 / 263:  26%|██▋       | 263/1000 [1:45:14<4:54:53, 24.01s/it][Succeeded / Failed / Skipped / Total] 178 / 81 / 4 / 263:  26%|██▋       | 264/1000 [1:45:51<4:55:06, 24.06s/it][Succeeded / Failed / Skipped / Total] 178 / 82 / 4 / 264:  26%|██▋       | 264/1000 [1:45:51<4:55:06, 24.06s/it][Succeeded / Failed / Skipped / Total] 178 / 82 / 4 / 264:  26%|██▋       | 265/1000 [1:45:57<4:53:53, 23.99s/it][Succeeded / Failed / Skipped / Total] 179 / 82 / 4 / 265:  26%|██▋       | 265/1000 [1:45:57<4:53:53, 23.99s/it][Succeeded / Failed / Skipped / Total] 179 / 82 / 4 / 265:  27%|██▋       | 266/1000 [1:46:19<4:53:22, 23.98s/it][Succeeded / Failed / Skipped / Total] 180 / 82 / 4 / 266:  27%|██▋       | 266/1000 [1:46:19<4:53:22, 23.98s/it][Succeeded / Failed / Skipped / Total] 180 / 82 / 4 / 266:  27%|██▋       | 267/1000 [1:46:25<4:52:11, 23.92s/it][Succeeded / Failed / Skipped / Total] 181 / 82 / 4 / 267:  27%|██▋       | 267/1000 [1:46:25<4:52:11, 23.92s/it][Succeeded / Failed / Skipped / Total] 181 / 82 / 4 / 267:  27%|██▋       | 268/1000 [1:46:47<4:51:40, 23.91s/it][Succeeded / Failed / Skipped / Total] 181 / 83 / 4 / 268:  27%|██▋       | 268/1000 [1:46:47<4:51:40, 23.91s/it][Succeeded / Failed / Skipped / Total] 181 / 83 / 4 / 268:  27%|██▋       | 269/1000 [1:47:08<4:51:09, 23.90s/it]Sets a multi - part header . --> [[[FAILED]]]

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String value ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[freebase]] ( String [[clandestine]] , String value ) { Validate . notEmpty ( [[clandestine]] , "Header name cannot be empty" ) ; Validate . notEmpty ( value , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .


--------------------------------------------- Result 262 ---------------------------------------------
Sets the basic authentication credentials . --> Resolve absolue username --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int port , String [[user]] , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , port ) , new UsernamePasswordCredentials ( [[user]] , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[absolue]] ( String [[felipe]] , int port , String [[nowthe]] , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[felipe]] , port ) , new UsernamePasswordCredentials ( [[nowthe]] , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .


--------------------------------------------- Result 263 ---------------------------------------------
Sets the NTLM credentials . --> [[[FAILED]]]

[[[[Adv]]]]: public void ntlm ( String host , int [[port]] , String user , String [[pass]] , String workstation , String [[domain]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[port]] ) , new NTCredentials ( user , [[pass]] , workstation , [[domain]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void ntlm ( String host , int [[periphery]] , String user , String [[allegiance]] , String workstation , String [[confinement]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , [[periphery]] ) , new NTCredentials ( user , [[allegiance]] , workstation , [[confinement]] ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .


--------------------------------------------- Result 264 ---------------------------------------------
Create a new headers with the given header and additional headers . --> [[[FAILED]]]

[[[[Adv]]]]: public static Headers [[headers]] ( Header [[header]] , Header ... [[additionalHeaders]] ) { notNull ( [[header]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[header]] ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers [[disciplining]] ( Header [[fiance]] , Header ... [[elspeth]] ) { notNull ( [[fiance]] , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( [[fiance]] ) ; if ( [[elspeth]] != null ) { Collections . addAll ( headerList , [[elspeth]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .


--------------------------------------------- Result 265 ---------------------------------------------
Reset configuration . --> Clean up resources --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[pooping]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .


--------------------------------------------- Result 266 ---------------------------------------------
Sets the response header . --> Sets the headers of the REST response . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String [[name]] , String value ) { notNull ( [[name]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[name]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[name]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[astrological]] ( String [[cert]] , String value ) { notNull ( [[cert]] , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( [[cert]] , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( [[cert]] ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header


--------------------------------------------- Result 267 ---------------------------------------------
Build the response . --> Set fault information . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[faults]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response


--------------------------------------------- Result 268 ---------------------------------------------
Matches the cookie with the specified matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[huan]] ( Matcher < ? super String > [[hysterectomy]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[hysterectomy]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .


--------------------------------------------- Result 269 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 181 / 84 / 4 / 269:  27%|██▋       | 269/1000 [1:47:08<4:51:09, 23.90s/it][Succeeded / Failed / Skipped / Total] 181 / 84 / 4 / 269:  27%|██▋       | 270/1000 [1:47:30<4:50:40, 23.89s/it][Succeeded / Failed / Skipped / Total] 181 / 85 / 4 / 270:  27%|██▋       | 270/1000 [1:47:30<4:50:40, 23.89s/it][Succeeded / Failed / Skipped / Total] 181 / 85 / 4 / 270:  27%|██▋       | 271/1000 [1:47:52<4:50:11, 23.88s/it][Succeeded / Failed / Skipped / Total] 181 / 86 / 4 / 271:  27%|██▋       | 271/1000 [1:47:52<4:50:11, 23.88s/it][Succeeded / Failed / Skipped / Total] 181 / 86 / 4 / 271:  27%|██▋       | 272/1000 [1:48:14<4:49:41, 23.88s/it][Succeeded / Failed / Skipped / Total] 181 / 87 / 4 / 272:  27%|██▋       | 272/1000 [1:48:14<4:49:41, 23.88s/it][Succeeded / Failed / Skipped / Total] 181 / 87 / 4 / 272:  27%|██▋       | 273/1000 [1:48:36<4:49:13, 23.87s/it][Succeeded / Failed / Skipped / Total] 181 / 88 / 4 / 273:  27%|██▋       | 273/1000 [1:48:36<4:49:13, 23.87s/it][Succeeded / Failed / Skipped / Total] 181 / 88 / 4 / 273:  27%|██▋       | 274/1000 [1:48:59<4:48:46, 23.87s/it][Succeeded / Failed / Skipped / Total] 181 / 89 / 4 / 274:  27%|██▋       | 274/1000 [1:48:59<4:48:46, 23.87s/it][Succeeded / Failed / Skipped / Total] 181 / 89 / 4 / 274:  28%|██▊       | 275/1000 [1:49:20<4:48:15, 23.86s/it][Succeeded / Failed / Skipped / Total] 181 / 90 / 4 / 275:  28%|██▊       | 275/1000 [1:49:20<4:48:15, 23.86s/it][Succeeded / Failed / Skipped / Total] 181 / 90 / 4 / 275:  28%|██▊       | 276/1000 [1:49:42<4:47:46, 23.85s/it][Succeeded / Failed / Skipped / Total] 181 / 91 / 4 / 276:  28%|██▊       | 276/1000 [1:49:42<4:47:46, 23.85s/it][Succeeded / Failed / Skipped / Total] 181 / 91 / 4 / 276:  28%|██▊       | 277/1000 [1:50:06<4:47:23, 23.85s/it][Succeeded / Failed / Skipped / Total] 181 / 92 / 4 / 277:  28%|██▊       | 277/1000 [1:50:06<4:47:23, 23.85s/it][Succeeded / Failed / Skipped / Total] 181 / 92 / 4 / 277:  28%|██▊       | 278/1000 [1:50:26<4:46:50, 23.84s/it][Succeeded / Failed / Skipped / Total] 181 / 93 / 4 / 278:  28%|██▊       | 278/1000 [1:50:26<4:46:50, 23.84s/it][Succeeded / Failed / Skipped / Total] 181 / 93 / 4 / 278:  28%|██▊       | 279/1000 [1:50:45<4:46:13, 23.82s/it][Succeeded / Failed / Skipped / Total] 181 / 94 / 4 / 279:  28%|██▊       | 279/1000 [1:50:45<4:46:13, 23.82s/it][Succeeded / Failed / Skipped / Total] 181 / 94 / 4 / 279:  28%|██▊       | 280/1000 [1:51:05<4:45:39, 23.80s/it]Applies a cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[freelancer]] ( Matcher < ? super String > [[thinness]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[thinness]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .


--------------------------------------------- Result 270 ---------------------------------------------
Creates a cookie matcher that matches expiry date . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[boto]] ( Matcher < ? super Date > [[irony]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[irony]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .


--------------------------------------------- Result 271 ---------------------------------------------
Matches cookie matcher against cookie matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[tinkered]] ( Matcher < ? super String > [[orgasmic]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[orgasmic]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .


--------------------------------------------- Result 272 ---------------------------------------------
Applies a path to cookieMatcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > [[pathMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[pathMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[latitudes]] ( Matcher < ? super String > [[exploiter]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , [[exploiter]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .


--------------------------------------------- Result 273 ---------------------------------------------
Applies the secured cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[tween]] ( Matcher < ? super Boolean > [[guardians]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[guardians]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .


--------------------------------------------- Result 274 ---------------------------------------------
Creates a cookie matcher that matches http - only . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[wantto]] ( Matcher < ? super Boolean > [[mist]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[mist]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .


--------------------------------------------- Result 275 ---------------------------------------------
Applies a cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[bboy]] ( Matcher < ? super Integer > [[thesis]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[thesis]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .


--------------------------------------------- Result 276 ---------------------------------------------
Creates a cookie matcher that matches the specified limit . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[drex]] ( Matcher < ? super Integer > [[gucci]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[gucci]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .


--------------------------------------------- Result 277 ---------------------------------------------
Expect a header with an expected value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[headerName]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[motivating]] ( String [[akhil]] , Matcher < String > expectedValueMatcher ) { spec . header ( [[akhil]] , expectedValueMatcher ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .


--------------------------------------------- Result 278 ---------------------------------------------
Expect a header on the response . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[cloe]] ( String [[pressman]] , String [[carola]] ) { spec . header ( [[pressman]] , [[carola]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .


--------------------------------------------- Result 279 ---------------------------------------------
Expect a cookie with expected value . --> [[[FAILED]]]

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[bertha]] ( String [[mongrel]] , String [[keogh]] ) { spec . cookie ( [[mongrel]] , [[keogh]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .


--------------------------------------------- Result 280 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 182 / 94 / 4 / 280:  28%|██▊       | 280/1000 [1:51:05<4:45:39, 23.80s/it][Succeeded / Failed / Skipped / Total] 182 / 94 / 4 / 280:  28%|██▊       | 281/1000 [1:51:16<4:44:44, 23.76s/it][Succeeded / Failed / Skipped / Total] 183 / 94 / 4 / 281:  28%|██▊       | 281/1000 [1:51:16<4:44:44, 23.76s/it][Succeeded / Failed / Skipped / Total] 183 / 94 / 4 / 281:  28%|██▊       | 282/1000 [1:51:38<4:44:14, 23.75s/it][Succeeded / Failed / Skipped / Total] 184 / 94 / 4 / 282:  28%|██▊       | 282/1000 [1:51:38<4:44:14, 23.75s/it][Succeeded / Failed / Skipped / Total] 184 / 94 / 4 / 282:  28%|██▊       | 283/1000 [1:51:59<4:43:44, 23.74s/it][Succeeded / Failed / Skipped / Total] 185 / 94 / 4 / 283:  28%|██▊       | 283/1000 [1:51:59<4:43:44, 23.74s/it][Succeeded / Failed / Skipped / Total] 185 / 94 / 4 / 283:  28%|██▊       | 284/1000 [1:52:20<4:43:14, 23.74s/it][Succeeded / Failed / Skipped / Total] 186 / 94 / 4 / 284:  28%|██▊       | 284/1000 [1:52:20<4:43:14, 23.74s/it][Succeeded / Failed / Skipped / Total] 186 / 94 / 4 / 284:  28%|██▊       | 285/1000 [1:52:32<4:42:19, 23.69s/it][Succeeded / Failed / Skipped / Total] 187 / 94 / 4 / 285:  28%|██▊       | 285/1000 [1:52:32<4:42:19, 23.69s/it][Succeeded / Failed / Skipped / Total] 187 / 94 / 4 / 285:  29%|██▊       | 286/1000 [1:52:47<4:41:36, 23.66s/it][Succeeded / Failed / Skipped / Total] 188 / 94 / 4 / 286:  29%|██▊       | 286/1000 [1:52:47<4:41:36, 23.66s/it][Succeeded / Failed / Skipped / Total] 188 / 94 / 4 / 286:  29%|██▊       | 287/1000 [1:53:06<4:41:00, 23.65s/it][Succeeded / Failed / Skipped / Total] 188 / 95 / 4 / 287:  29%|██▊       | 287/1000 [1:53:06<4:41:00, 23.65s/it][Succeeded / Failed / Skipped / Total] 188 / 95 / 4 / 287:  29%|██▉       | 288/1000 [1:53:19<4:40:11, 23.61s/it][Succeeded / Failed / Skipped / Total] 189 / 95 / 4 / 288:  29%|██▉       | 288/1000 [1:53:19<4:40:11, 23.61s/it][Succeeded / Failed / Skipped / Total] 189 / 95 / 4 / 288:  29%|██▉       | 289/1000 [1:53:45<4:39:52, 23.62s/it][Succeeded / Failed / Skipped / Total] 189 / 96 / 4 / 289:  29%|██▉       | 289/1000 [1:53:45<4:39:52, 23.62s/it][Succeeded / Failed / Skipped / Total] 189 / 96 / 4 / 289:  29%|██▉       | 290/1000 [1:53:58<4:39:01, 23.58s/it]Returns a proxy configuration for the specified host . --> returns a ProxySpec object that can be used to test --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String [[host]] ) { return new ProxySpecification ( [[host]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[vineyard]] ( String [[olinda]] ) { return new ProxySpecification ( [[olinda]] , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .


--------------------------------------------- Result 281 ---------------------------------------------
Default value for number return type . --> Default value for NumberPath --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType [[numberReturnType]] ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType [[alas]] ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .


--------------------------------------------- Result 282 ---------------------------------------------
Sets the default parser type . --> Define a new JsonPathConfig --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[bohr]] ( JsonParserType [[dampness]] ) { return new JsonPathConfig ( numberReturnType , [[bohr]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .


--------------------------------------------- Result 283 ---------------------------------------------
Sets default logging to the given PrintStream . --> Browse this request --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream [[printStream]] ) { return new LogConfig ( [[printStream]] , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[browder]] ( PrintStream [[peaty]] ) { return new LogConfig ( [[peaty]] , "[["Takumi" == "Takumi"]]" == "[["Takumi" == "Takumi"]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[["Takumi" == "Takumi"]]" == "[["Takumi" == "Takumi"]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .


--------------------------------------------- Result 284 ---------------------------------------------
Enable logging of the request and response . --> Alter for alger --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail [[logDetail]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[logDetail]] , urlEncodeRequestUri , True ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[algeria]] ( LogDetail [[dordogne]] ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , [[dordogne]] , urlEncodeRequestUri , True ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail


--------------------------------------------- Result 285 ---------------------------------------------
Creates an HttpRequestBase for the specified HTTP method and HTTP method . --> Returns HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[berg]] ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .


--------------------------------------------- Result 286 ---------------------------------------------
Default configuration . --> define zhu configuration --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , True ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[zhuang]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[zhuang]] , defaultCharset , True ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .


--------------------------------------------- Result 287 ---------------------------------------------
Adds an attribute to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String attributeName , Object [[attributeValue]] ) { spec . attribute ( attributeName , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[cowhands]] ( String attributeName , Object [[puritanical]] ) { spec . attribute ( attributeName , [[puritanical]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute


--------------------------------------------- Result 288 ---------------------------------------------
Adds a header to the request . --> Sets an octave --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String headerValue ) { spec . header ( [[headerName]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[octave]] ( String [[salad]] , String headerValue ) { spec . header ( [[salad]] , headerValue ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request


--------------------------------------------- Result 289 ---------------------------------------------
Adds a multi - part request . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String controlName , String [[contentBody]] , String [[mimeType]] ) { spec . multiPart ( controlName , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[chuff]] ( String controlName , String [[dale]] , String [[formal]] ) { spec . multiPart ( controlName , [[formal]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .


--------------------------------------------- Result 290 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 190 / 96 / 4 / 290:  29%|██▉       | 290/1000 [1:53:58<4:39:01, 23.58s/it][Succeeded / Failed / Skipped / Total] 190 / 96 / 4 / 290:  29%|██▉       | 291/1000 [1:54:22<4:38:41, 23.58s/it][Succeeded / Failed / Skipped / Total] 190 / 97 / 4 / 291:  29%|██▉       | 291/1000 [1:54:22<4:38:41, 23.58s/it][Succeeded / Failed / Skipped / Total] 190 / 97 / 4 / 291:  29%|██▉       | 292/1000 [1:55:07<4:39:08, 23.66s/it][Succeeded / Failed / Skipped / Total] 191 / 97 / 4 / 292:  29%|██▉       | 292/1000 [1:55:07<4:39:08, 23.66s/it][Succeeded / Failed / Skipped / Total] 191 / 97 / 4 / 292:  29%|██▉       | 293/1000 [1:55:16<4:38:10, 23.61s/it][Succeeded / Failed / Skipped / Total] 192 / 97 / 4 / 293:  29%|██▉       | 293/1000 [1:55:16<4:38:10, 23.61s/it][Succeeded / Failed / Skipped / Total] 192 / 97 / 4 / 293:  29%|██▉       | 294/1000 [1:55:36<4:37:37, 23.59s/it][Succeeded / Failed / Skipped / Total] 193 / 97 / 4 / 294:  29%|██▉       | 294/1000 [1:55:36<4:37:37, 23.59s/it][Succeeded / Failed / Skipped / Total] 193 / 97 / 4 / 294:  30%|██▉       | 295/1000 [1:55:50<4:36:50, 23.56s/it][Succeeded / Failed / Skipped / Total] 194 / 97 / 4 / 295:  30%|██▉       | 295/1000 [1:55:50<4:36:50, 23.56s/it][Succeeded / Failed / Skipped / Total] 194 / 97 / 4 / 295:  30%|██▉       | 296/1000 [1:55:57<4:35:48, 23.51s/it][Succeeded / Failed / Skipped / Total] 195 / 97 / 4 / 296:  30%|██▉       | 296/1000 [1:55:57<4:35:48, 23.51s/it][Succeeded / Failed / Skipped / Total] 195 / 97 / 4 / 296:  30%|██▉       | 297/1000 [1:56:04<4:34:45, 23.45s/it][Succeeded / Failed / Skipped / Total] 196 / 97 / 4 / 297:  30%|██▉       | 297/1000 [1:56:04<4:34:45, 23.45s/it][Succeeded / Failed / Skipped / Total] 196 / 97 / 4 / 297:  30%|██▉       | 298/1000 [1:56:20<4:34:04, 23.42s/it][Succeeded / Failed / Skipped / Total] 197 / 97 / 4 / 298:  30%|██▉       | 298/1000 [1:56:20<4:34:04, 23.42s/it][Succeeded / Failed / Skipped / Total] 197 / 97 / 4 / 298:  30%|██▉       | 299/1000 [1:56:33<4:33:16, 23.39s/it][Succeeded / Failed / Skipped / Total] 198 / 97 / 4 / 299:  30%|██▉       | 299/1000 [1:56:33<4:33:16, 23.39s/it][Succeeded / Failed / Skipped / Total] 198 / 97 / 4 / 299:  30%|███       | 300/1000 [1:57:00<4:33:01, 23.40s/it]Add a result handler . --> Sets the countersignign . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... [[additionalResultHandlers]] ) { spec . resultHandlers ( resultHandler , [[additionalResultHandlers]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[countersign]] ( ResultHandler resultHandler , ResultHandler ... [[thorazine]] ) { spec . resultHandlers ( resultHandler , [[thorazine]] ) ; return this ; }
[[[[Nl]]]]: Add a result handler


--------------------------------------------- Result 291 ---------------------------------------------
Sets a parameter with the specified parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( httpClientParams ) ; [[newParams]] . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[commendable]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[roe]] = new HashMap < String , Object > ( httpClientParams ) ; [[roe]] . put ( parameterName , parameterValue ) ; return new [[commendable]] ( httpClientFactory , [[roe]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[["Huntin" == "Huntin"]]" == "[["Huntin" == "Huntin"]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .


--------------------------------------------- Result 292 ---------------------------------------------
Adds the given parameters to the request . --> Configure a HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[couch]] ( Map < String , ? > httpClientParams ) { notNull ( httpClientParams , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . [[relena]] ) ; newParams . putAll ( httpClientParams ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[["Motorcade" == "Motorcade"]]" == "[["Motorcade" == "Motorcade"]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .


--------------------------------------------- Result 293 ---------------------------------------------
Configure the HTTP client factory . --> Configure HttpClientFactory --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[lanning]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , True ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .


--------------------------------------------- Result 294 ---------------------------------------------
Configures the HTTP Multipart mode . --> Create a new HttpClientConfig instance --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode [[httpMultipartMode]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , True ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[ahoo]] ( HttpMultipartMode [[fish]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[ahoo]] , shouldReuseHttpClientInstance , httpClient , True ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .


--------------------------------------------- Result 295 ---------------------------------------------
Gets a value . --> Retrieves blockers --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[blockers]] > [[blockers]] get ( String path ) { final JSONAssertion [[buying]] = createJsonAssertion ( path , params ) ; final Object json = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[blockers]] ) [[buying]] . getResult ( json , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .


--------------------------------------------- Result 296 ---------------------------------------------
Gets int . --> Dereter for deser --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[deserter]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .


--------------------------------------------- Result 297 ---------------------------------------------
Get byte at given path . --> KARra --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[akra]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .


--------------------------------------------- Result 298 ---------------------------------------------
Gets short . --> Shortcut method --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[brutal]] ( String [[brennan]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .


--------------------------------------------- Result 299 ---------------------------------------------
Get a float . --> Returns rostock with given corruption --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[rostock]] ( String [[corruption]] ) { final Object value = get ( [[corruption]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .


--------------------------------------------- Result 300 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 198 / 98 / 4 / 300:  30%|███       | 300/1000 [1:57:00<4:33:01, 23.40s/it][Succeeded / Failed / Skipped / Total] 198 / 98 / 4 / 300:  30%|███       | 301/1000 [1:57:15<4:32:18, 23.37s/it][Succeeded / Failed / Skipped / Total] 198 / 99 / 4 / 301:  30%|███       | 301/1000 [1:57:15<4:32:18, 23.37s/it][Succeeded / Failed / Skipped / Total] 198 / 99 / 4 / 301:  30%|███       | 302/1000 [1:58:23<4:33:37, 23.52s/it][Succeeded / Failed / Skipped / Total] 198 / 100 / 4 / 302:  30%|███       | 302/1000 [1:58:23<4:33:37, 23.52s/it][Succeeded / Failed / Skipped / Total] 198 / 100 / 4 / 302:  30%|███       | 303/1000 [1:58:46<4:33:13, 23.52s/it][Succeeded / Failed / Skipped / Total] 199 / 100 / 4 / 303:  30%|███       | 303/1000 [1:58:46<4:33:13, 23.52s/it][Succeeded / Failed / Skipped / Total] 199 / 100 / 4 / 303:  30%|███       | 304/1000 [1:59:16<4:33:04, 23.54s/it][Succeeded / Failed / Skipped / Total] 199 / 101 / 4 / 304:  30%|███       | 304/1000 [1:59:16<4:33:04, 23.54s/it][Succeeded / Failed / Skipped / Total] 199 / 101 / 4 / 304:  30%|███       | 305/1000 [1:59:37<4:32:34, 23.53s/it][Succeeded / Failed / Skipped / Total] 199 / 102 / 4 / 305:  30%|███       | 305/1000 [1:59:37<4:32:34, 23.53s/it][Succeeded / Failed / Skipped / Total] 199 / 102 / 4 / 305:  31%|███       | 306/1000 [1:59:59<4:32:08, 23.53s/it][Succeeded / Failed / Skipped / Total] 200 / 102 / 4 / 306:  31%|███       | 306/1000 [1:59:59<4:32:08, 23.53s/it][Succeeded / Failed / Skipped / Total] 200 / 102 / 4 / 306:  31%|███       | 307/1000 [2:00:13<4:31:22, 23.50s/it][Succeeded / Failed / Skipped / Total] 201 / 102 / 4 / 307:  31%|███       | 307/1000 [2:00:13<4:31:22, 23.50s/it][Succeeded / Failed / Skipped / Total] 201 / 102 / 4 / 307:  31%|███       | 308/1000 [2:00:33<4:30:52, 23.49s/it][Succeeded / Failed / Skipped / Total] 202 / 102 / 4 / 308:  31%|███       | 308/1000 [2:00:33<4:30:52, 23.49s/it][Succeeded / Failed / Skipped / Total] 202 / 102 / 4 / 308:  31%|███       | 309/1000 [2:00:58<4:30:31, 23.49s/it][Succeeded / Failed / Skipped / Total] 202 / 103 / 4 / 309:  31%|███       | 309/1000 [2:00:58<4:30:31, 23.49s/it][Succeeded / Failed / Skipped / Total] 202 / 103 / 4 / 309:  31%|███       | 310/1000 [2:01:08<4:29:38, 23.45s/it][Succeeded / Failed / Skipped / Total] 203 / 103 / 4 / 310:  31%|███       | 310/1000 [2:01:08<4:29:38, 23.45s/it][Succeeded / Failed / Skipped / Total] 203 / 103 / 4 / 310:  31%|███       | 311/1000 [2:01:33<4:29:17, 23.45s/it]Get a double . --> [[[FAILED]]]

[[[[Adv]]]]: public double [[getDouble]] ( String path ) { final Object [[value]] = get ( path ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[geng]] ( String path ) { final Object [[schatzi]] = get ( path ) ; if ( [[schatzi]] instanceof Double ) { return ( Double ) [[schatzi]] ; } return ObjectConverter . convertObjectTo ( [[schatzi]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .


--------------------------------------------- Result 301 ---------------------------------------------
Gets long . --> [[[FAILED]]]

[[[[Adv]]]]: public long [[getLong]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[drea]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .


--------------------------------------------- Result 302 ---------------------------------------------
Gets the path as a list . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T [[e]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[stepped]] ( String path , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( path ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T [[andersson]] ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .


--------------------------------------------- Result 303 ---------------------------------------------
Get a map value . --> Holder implementation --> Socre: 1.0

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[archeologist]] , V > Map < [[archeologist]] , V > [[hoff]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .


--------------------------------------------- Result 304 ---------------------------------------------
Gets the object from the given path using the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object object = getFromPath ( path , False ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[monash]] > [[monash]] getObject ( String path , Class < [[monash]] > objectType ) { Object object = getFromPath ( path , False ) ; return getObjectAsType ( object , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .


--------------------------------------------- Result 305 ---------------------------------------------
Sets the body of the request --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper [[mapper]] ) { spec . body ( object , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[peritonitis]] ( Object object , ObjectMapper [[emilio]] ) { spec . body ( object , [[emilio]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .


--------------------------------------------- Result 306 ---------------------------------------------
Adds a cookie to the request . --> Convenience method for uniodo --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object [[value]] , Object ... cookieNameValuePairs ) { spec . cookie ( [[key]] , [[value]] , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[christi]] ( String [[unión]] , Object [[compounding]] , Object ... cookieNameValuePairs ) { spec . cookie ( [[unión]] , [[compounding]] , cookieNameValuePairs ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .


--------------------------------------------- Result 307 ---------------------------------------------
Add a parameter to the request . --> Set flooring parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[flooring]] ( String [[pedestals]] , Object ... parameterValues ) { spec . param ( [[pedestals]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .


--------------------------------------------- Result 308 ---------------------------------------------
Adds a parameter to the request . --> helper method --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[rousted]] ( String [[idem]] , Collection < ? > [[katz]] ) { spec . param ( [[idem]] , [[katz]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .


--------------------------------------------- Result 309 ---------------------------------------------
Sets a custom update strategy . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[hangover]] ( UpdateStrategy [[babylon]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[babylon]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[["Blacklist" == "Blacklist"]]" == "[["Blacklist" == "Blacklist"]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .


--------------------------------------------- Result 310 ---------------------------------------------
Log response to the output stream . --> Log response to output stream --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[andree]] ) { return new ResponseLoggingFilter ( stream , [[andree]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .


[Succeeded / Failed / Skipped / Total] 204 / 103 / 4 / 311:  31%|███       | 311/1000 [2:01:33<4:29:17, 23.45s/it][Succeeded / Failed / Skipped / Total] 204 / 103 / 4 / 311:  31%|███       | 312/1000 [2:01:47<4:28:34, 23.42s/it][Succeeded / Failed / Skipped / Total] 205 / 103 / 4 / 312:  31%|███       | 312/1000 [2:01:47<4:28:34, 23.42s/it][Succeeded / Failed / Skipped / Total] 205 / 103 / 4 / 312:  31%|███▏      | 313/1000 [2:02:03<4:27:54, 23.40s/it][Succeeded / Failed / Skipped / Total] 206 / 103 / 4 / 313:  31%|███▏      | 313/1000 [2:02:03<4:27:54, 23.40s/it][Succeeded / Failed / Skipped / Total] 206 / 103 / 4 / 313:  31%|███▏      | 314/1000 [2:02:27<4:27:32, 23.40s/it][Succeeded / Failed / Skipped / Total] 207 / 103 / 4 / 314:  31%|███▏      | 314/1000 [2:02:27<4:27:32, 23.40s/it][Succeeded / Failed / Skipped / Total] 207 / 103 / 4 / 314:  32%|███▏      | 315/1000 [2:03:35<4:28:46, 23.54s/it][Succeeded / Failed / Skipped / Total] 208 / 103 / 4 / 315:  32%|███▏      | 315/1000 [2:03:35<4:28:46, 23.54s/it][Succeeded / Failed / Skipped / Total] 208 / 103 / 4 / 315:  32%|███▏      | 316/1000 [2:03:58<4:28:20, 23.54s/it][Succeeded / Failed / Skipped / Total] 209 / 103 / 4 / 316:  32%|███▏      | 316/1000 [2:03:58<4:28:20, 23.54s/it][Succeeded / Failed / Skipped / Total] 209 / 103 / 4 / 316:  32%|███▏      | 317/1000 [2:04:13<4:27:38, 23.51s/it][Succeeded / Failed / Skipped / Total] 209 / 104 / 4 / 317:  32%|███▏      | 317/1000 [2:04:13<4:27:38, 23.51s/it][Succeeded / Failed / Skipped / Total] 209 / 104 / 4 / 317:  32%|███▏      | 318/1000 [2:04:31<4:27:04, 23.50s/it]--------------------------------------------- Result 311 ---------------------------------------------
Adds additional cookies to the request . --> Convenience factory methods --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cookie]] , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cookie]] ) ; Collections . addAll ( cookieList , [[additionalCookies]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cmon]] , Cookie ... [[bonnet]] ) { AssertParameter . notNull ( [[cmon]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cmon]] ) ; Collections . addAll ( cookieList , [[bonnet]] ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .


--------------------------------------------- Result 312 ---------------------------------------------
Clean up data from the backing map . --> Clean up internal data structures --> Socre: 1.0

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[keysAndSources]] ) { Multiset < Object > [[set]] = backingMap . get ( keyAndSource . key ) ; if ( [[set]] != null ) { [[set]] . remove ( keyAndSource . source ) ; if ( [[set]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void cleanUpForCollectedState ( Set < KeyAndSource > [[allow]] ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : [[allow]] ) { Multiset < Object > [[idealism]] = backingMap . get ( keyAndSource . key ) ; if ( [[idealism]] != null ) { [[idealism]] . remove ( keyAndSource . source ) ; if ( [[idealism]] . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .


--------------------------------------------- Result 313 ---------------------------------------------
Index bindings . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[reefer]] ( ) { for ( Binding < ? > [[plywood]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[plywood]] . getKey ( ) . getTypeLiteral ( ) , [[plywood]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .


--------------------------------------------- Result 314 ---------------------------------------------
Converts a constant string to a constant binding . --> Private method for debugging --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[commentary]] ( Key < T > [[installing]] , Errors [[indignities]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .


--------------------------------------------- Result 315 ---------------------------------------------
Cleans the internal dependencies of the given binding . --> returns true if invalid --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > [[binding]] , Set < Key > [[encountered]] ) { boolean bindingFailed = "[[False]]" != "[[False]]" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[binding]] ) ; for ( Dependency [[dep]] : deps ) { Key < ? > depKey = [[dep]] . getKey ( ) ; InjectionPoint ip = [[dep]] . getInjectionPoint ( ) ; if ( [[encountered]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[ionic]] ( BindingImpl < ? > [[osteopath]] , Set < Key > [[frau]] ) { boolean bindingFailed = "[["Kafka" != "Kafka"]]" != "[["Kafka" != "Kafka"]]" ; Set < Dependency < ? > > deps = getInternalDependencies ( [[osteopath]] ) ; for ( Dependency [[companions]] : deps ) { Key < ? > depKey = [[companions]] . getKey ( ) ; InjectionPoint ip = [[companions]] . getInjectionPoint ( ) ; if ( [[frau]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .


--------------------------------------------- Result 316 ---------------------------------------------
Removes a failed binding . --> Manage messenger messenger --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[messenger]] ( Binding < ? > [[grooves]] , InjectionPoint ip ) { failedJitBindings . add ( [[grooves]] . getKey ( ) ) ; jitBindings . remove ( [[grooves]] . getKey ( ) ) ; membersInjectorStore . remove ( [[grooves]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[grooves]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .


--------------------------------------------- Result 317 ---------------------------------------------
Gets the internal dependencies of the given binding . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[assumptions]] ( BindingImpl < ? > [[kim]] ) { if ( [[kim]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[kim]] ) . getInternalDependencies ( ) ; } else if ( [[kim]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[kim]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .


--------------------------------------------- Result 318 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 209 / 105 / 4 / 318:  32%|███▏      | 318/1000 [2:04:31<4:27:04, 23.50s/it][Succeeded / Failed / Skipped / Total] 209 / 105 / 4 / 318:  32%|███▏      | 319/1000 [2:04:48<4:26:25, 23.47s/it][Succeeded / Failed / Skipped / Total] 210 / 105 / 4 / 319:  32%|███▏      | 319/1000 [2:04:48<4:26:25, 23.47s/it][Succeeded / Failed / Skipped / Total] 210 / 105 / 4 / 319:  32%|███▏      | 320/1000 [2:05:17<4:26:14, 23.49s/it][Succeeded / Failed / Skipped / Total] 211 / 105 / 4 / 320:  32%|███▏      | 320/1000 [2:05:17<4:26:14, 23.49s/it][Succeeded / Failed / Skipped / Total] 211 / 105 / 4 / 320:  32%|███▏      | 321/1000 [2:05:35<4:25:40, 23.48s/it][Succeeded / Failed / Skipped / Total] 212 / 105 / 4 / 321:  32%|███▏      | 321/1000 [2:05:35<4:25:40, 23.48s/it][Succeeded / Failed / Skipped / Total] 212 / 105 / 4 / 321:  32%|███▏      | 322/1000 [2:06:10<4:25:40, 23.51s/it][Succeeded / Failed / Skipped / Total] 213 / 105 / 4 / 322:  32%|███▏      | 322/1000 [2:06:10<4:25:40, 23.51s/it][Succeeded / Failed / Skipped / Total] 213 / 105 / 4 / 322:  32%|███▏      | 323/1000 [2:06:37<4:25:23, 23.52s/it][Succeeded / Failed / Skipped / Total] 214 / 105 / 4 / 323:  32%|███▏      | 323/1000 [2:06:37<4:25:23, 23.52s/it][Succeeded / Failed / Skipped / Total] 214 / 105 / 4 / 323:  32%|███▏      | 324/1000 [2:06:56<4:24:51, 23.51s/it][Succeeded / Failed / Skipped / Total] 214 / 106 / 4 / 324:  32%|███▏      | 324/1000 [2:06:56<4:24:51, 23.51s/it][Succeeded / Failed / Skipped / Total] 214 / 106 / 4 / 324:  32%|███▎      | 325/1000 [2:07:03<4:23:53, 23.46s/it][Succeeded / Failed / Skipped / Total] 214 / 107 / 4 / 325:  32%|███▎      | 325/1000 [2:07:03<4:23:53, 23.46s/it][Succeeded / Failed / Skipped / Total] 214 / 107 / 4 / 325:  33%|███▎      | 326/1000 [2:07:12<4:22:59, 23.41s/it]Creates an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[stockbrokers]] { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .


--------------------------------------------- Result 319 ---------------------------------------------
Gets all parameters . --> Convenience method for the rathole --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext [[context]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[rathole]] ( InternalContext [[rockingham]] , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .


--------------------------------------------- Result 320 ---------------------------------------------
Binds the given injector to the state provider . --> This method will be called once perjector --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[injectorFactory]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[injectorFactory]] , Scoping . UNSCOPED , [[injectorFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[roth]] ( InjectorImpl injector ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory [[patriarch]] = new InjectorFactory ( injector ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( injector , key , SourceProvider . UNKNOWN_SOURCE , [[patriarch]] , Scoping . UNSCOPED , [[patriarch]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .


--------------------------------------------- Result 321 ---------------------------------------------
Binds a Logger . --> casionalization --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[key]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[casanova]] ( InjectorImpl injector ) { Key < Logger > [[schmidt]] = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( [[schmidt]] , new ProviderInstanceBindingImpl < Logger > ( injector , [[schmidt]] , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .


--------------------------------------------- Result 322 ---------------------------------------------
Checks to see if any binding annotations found in the given element . --> Useful for testing --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors [[errors]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[errors]] , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return False ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[fasts]] ( Member [[drunken]] , Errors [[everybody]] ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( [[everybody]] , [[drunken]] , ( ( AnnotatedElement ) [[drunken]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return False ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .


--------------------------------------------- Result 323 ---------------------------------------------
Returns true if the two methods are overridden . --> benged method --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[beng]] ( Method [[ensconced]] , Method [[inglés]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .


--------------------------------------------- Result 324 ---------------------------------------------
Initializes the delegate . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[engulf]] ( MembersInjector < T > [[belittled]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[belittled]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .


--------------------------------------------- Result 325 ---------------------------------------------
The type of the provider . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[kana]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .


--------------------------------------------- Result 326 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 215 / 107 / 4 / 326:  33%|███▎      | 326/1000 [2:07:12<4:22:59, 23.41s/it][Succeeded / Failed / Skipped / Total] 215 / 107 / 4 / 326:  33%|███▎      | 327/1000 [2:07:58<4:23:22, 23.48s/it][Succeeded / Failed / Skipped / Total] 215 / 108 / 4 / 327:  33%|███▎      | 327/1000 [2:07:58<4:23:22, 23.48s/it][Succeeded / Failed / Skipped / Total] 215 / 108 / 4 / 327:  33%|███▎      | 328/1000 [2:08:16<4:22:49, 23.47s/it][Succeeded / Failed / Skipped / Total] 216 / 108 / 4 / 328:  33%|███▎      | 328/1000 [2:08:16<4:22:49, 23.47s/it][Succeeded / Failed / Skipped / Total] 216 / 108 / 4 / 328:  33%|███▎      | 329/1000 [2:08:27<4:21:59, 23.43s/it][Succeeded / Failed / Skipped / Total] 217 / 108 / 4 / 329:  33%|███▎      | 329/1000 [2:08:27<4:21:59, 23.43s/it][Succeeded / Failed / Skipped / Total] 217 / 108 / 4 / 329:  33%|███▎      | 330/1000 [2:08:56<4:21:48, 23.45s/it][Succeeded / Failed / Skipped / Total] 218 / 108 / 4 / 330:  33%|███▎      | 330/1000 [2:08:56<4:21:48, 23.45s/it][Succeeded / Failed / Skipped / Total] 218 / 108 / 4 / 330:  33%|███▎      | 331/1000 [2:09:44<4:22:12, 23.52s/it][Succeeded / Failed / Skipped / Total] 218 / 109 / 4 / 331:  33%|███▎      | 331/1000 [2:09:44<4:22:12, 23.52s/it][Succeeded / Failed / Skipped / Total] 218 / 109 / 4 / 331:  33%|███▎      | 332/1000 [2:09:51<4:21:16, 23.47s/it][Succeeded / Failed / Skipped / Total] 219 / 109 / 4 / 332:  33%|███▎      | 332/1000 [2:09:51<4:21:16, 23.47s/it][Succeeded / Failed / Skipped / Total] 219 / 109 / 4 / 332:  33%|███▎      | 333/1000 [2:09:59<4:20:22, 23.42s/it]Resolves all types in the given types . --> Resolve type literals --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int [[t]] = 0 ; [[t]] < types . length ; [[t]] ++ ) { result [ [[t]] ] = resolve ( types [ [[t]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] result = new TypeLiteral < ? > [ types . length ] ; for ( int [[gantz]] = 0 ; [[gantz]] < types . length ; [[gantz]] ++ ) { result [ [[gantz]] ] = resolve ( types [ [[gantz]] ] ) ; } return ImmutableList . copyOf ( result ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .


--------------------------------------------- Result 327 ---------------------------------------------
Creates a type literal for the given key literal . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[typeLiteral]] ) { Type type = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > [[sacré]] ) { Type type = [[sacré]] . getType ( ) ; if ( ! isFullySpecified ( type ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[sacré]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[sacré]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) type ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .


--------------------------------------------- Result 328 ---------------------------------------------
Prepare built - in converters . --> Attribute to attribute on the injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[attribute]] ( InjectorImpl [[overacting]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .


--------------------------------------------- Result 329 ---------------------------------------------
Converts the given ClassLoader to a ClassLoader . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[hatty]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .


--------------------------------------------- Result 330 ---------------------------------------------
Returns true if the class has the same version of the same version --> Determines whether joc keys are joc keys --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return False ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[jockeys]] ( ClassLoader classLoader ) { Class < ? > [[fatigued]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[fatigued]] . getName ( ) ) == [[fatigued]] ; } catch ( ClassNotFoundException e ) { return False ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .


--------------------------------------------- Result 331 ---------------------------------------------
Check if the given member is public or not . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } Class < ? > [ ] parameterTypes ; if ( [[member]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method [[method]] = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( [[method]] . getReturnType ( ) . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } parameterTypes = [[method]] . getParameterTypes ( ) ; } for ( Class < ? > [[type]] : parameterTypes ) { if ( ! Modifier . isPublic ( [[type]] . getModifiers ( ) ) ) { return "[[False]]" != "[[False]]" ; } } return True ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[adout]] ( Member [[compulsively]] ) { if ( ! Modifier . isPublic ( [[compulsively]] . getModifiers ( ) ) ) { return "[["Duller" != "Duller"]]" != "[["Duller" != "Duller"]]" ; } Class < ? > [ ] parameterTypes ; if ( [[compulsively]] instanceof Constructor ) { parameterTypes = ( ( Constructor ) [[compulsively]] ) . getParameterTypes ( ) ; } else { Method [[hydrochloric]] = ( Method ) [[compulsively]] ; if ( ! Modifier . isPublic ( [[hydrochloric]] . getReturnType ( ) . getModifiers ( ) ) ) { return "[["Duller" != "Duller"]]" != "[["Duller" != "Duller"]]" ; } parameterTypes = [[hydrochloric]] . getParameterTypes ( ) ; } for ( Class < ? > [[motive]] : parameterTypes ) { if ( ! Modifier . isPublic ( [[motive]] . getModifiers ( ) ) ) { return "[["Duller" != "Duller"]]" != "[["Duller" != "Duller"]]" ; } } return True ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .


--------------------------------------------- Result 332 ---------------------------------------------
Fixes annotations . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[beauty]] ) { return [[beauty]] . getAnnotation ( ) == null ? [[beauty]] : Key . get ( [[beauty]] . getTypeLiteral ( ) , [[beauty]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .


--------------------------------------------- Result 333 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 219 / 110 / 4 / 333:  33%|███▎      | 333/1000 [2:09:59<4:20:22, 23.42s/it][Succeeded / Failed / Skipped / Total] 219 / 110 / 4 / 333:  33%|███▎      | 334/1000 [2:10:35<4:20:23, 23.46s/it][Succeeded / Failed / Skipped / Total] 219 / 111 / 4 / 334:  33%|███▎      | 334/1000 [2:10:35<4:20:23, 23.46s/it][Succeeded / Failed / Skipped / Total] 219 / 111 / 4 / 334:  34%|███▎      | 335/1000 [2:11:01<4:20:05, 23.47s/it][Succeeded / Failed / Skipped / Total] 219 / 112 / 4 / 335:  34%|███▎      | 335/1000 [2:11:01<4:20:05, 23.47s/it][Succeeded / Failed / Skipped / Total] 219 / 112 / 4 / 335:  34%|███▎      | 336/1000 [2:11:19<4:19:32, 23.45s/it][Succeeded / Failed / Skipped / Total] 220 / 112 / 4 / 336:  34%|███▎      | 336/1000 [2:11:19<4:19:32, 23.45s/it][Succeeded / Failed / Skipped / Total] 220 / 112 / 4 / 336:  34%|███▎      | 337/1000 [2:11:28<4:18:39, 23.41s/it][Succeeded / Failed / Skipped / Total] 221 / 112 / 4 / 337:  34%|███▎      | 337/1000 [2:11:28<4:18:39, 23.41s/it][Succeeded / Failed / Skipped / Total] 221 / 112 / 4 / 337:  34%|███▍      | 338/1000 [2:11:55<4:18:24, 23.42s/it][Succeeded / Failed / Skipped / Total] 222 / 112 / 4 / 338:  34%|███▍      | 338/1000 [2:11:55<4:18:24, 23.42s/it][Succeeded / Failed / Skipped / Total] 222 / 112 / 4 / 338:  34%|███▍      | 339/1000 [2:12:13<4:17:49, 23.40s/it][Succeeded / Failed / Skipped / Total] 223 / 112 / 4 / 339:  34%|███▍      | 339/1000 [2:12:13<4:17:49, 23.40s/it][Succeeded / Failed / Skipped / Total] 223 / 112 / 4 / 339:  34%|███▍      | 340/1000 [2:12:21<4:16:56, 23.36s/it]Request an initializer for injection point . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[deneuve]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .


--------------------------------------------- Result 334 ---------------------------------------------
Validates all pending injections . --> [[[FAILED]]]

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors errors ) { validationStarted = True ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[eradication]] ( Errors errors ) { validationStarted = True ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > reference : pendingInjections ) { try { reference . validate ( errors ) ; } catch ( ErrorsException e ) { errors . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .


--------------------------------------------- Result 335 ---------------------------------------------
Creates a new instance of the constructor . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( True ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[betterment]] ( Object [ ] [[fucken]] ) throws Throwable { constructor . setAccessible ( True ) ; try { return constructor . newInstance ( [[fucken]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .


--------------------------------------------- Result 336 ---------------------------------------------
Override this method to customize the ServletRequest . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest [[servletRequest]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[bedpan]] ( ServletRequest [[presumes]] , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .


--------------------------------------------- Result 337 ---------------------------------------------
Returns a scope for the given scope . --> region ScopeFactory Implementation --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl [[injector]] , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl [[fb]] , InternalFactory < ? extends T > creator , Object source , Scoping scoping ) { if ( scoping . isNoScope ( ) ) { return creator ; } Scope scope = scoping . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .


--------------------------------------------- Result 338 ---------------------------------------------
Makes an injectable binding . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping [[scoping]] , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[scoping]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[scoping]] ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[badder]] ( Scoping [[jette]] , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[jette]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[jette]] ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .


--------------------------------------------- Result 339 ---------------------------------------------
Normalize the given path . --> method to get execution --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[queryStart]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[queryStart]] != - 1 ) { query = path . substring ( [[queryStart]] ) ; path = path . substring ( 0 , [[queryStart]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[abortion]] ( String path ) { StringBuilder sb = new StringBuilder ( path . length ( ) ) ; int [[rigour]] = path . indexOf ( ' ' ) ; String query = null ; if ( [[rigour]] != - 1 ) { query = path . substring ( [[rigour]] ) ; path = path . substring ( 0 , [[rigour]] ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .


--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 223 / 113 / 4 / 340:  34%|███▍      | 340/1000 [2:12:21<4:16:56, 23.36s/it][Succeeded / Failed / Skipped / Total] 223 / 113 / 4 / 340:  34%|███▍      | 341/1000 [2:12:47<4:16:37, 23.36s/it][Succeeded / Failed / Skipped / Total] 223 / 114 / 4 / 341:  34%|███▍      | 341/1000 [2:12:47<4:16:37, 23.36s/it][Succeeded / Failed / Skipped / Total] 223 / 114 / 4 / 341:  34%|███▍      | 342/1000 [2:13:29<4:16:49, 23.42s/it][Succeeded / Failed / Skipped / Total] 224 / 114 / 4 / 342:  34%|███▍      | 342/1000 [2:13:29<4:16:49, 23.42s/it][Succeeded / Failed / Skipped / Total] 224 / 114 / 4 / 342:  34%|███▍      | 343/1000 [2:14:45<4:18:06, 23.57s/it][Succeeded / Failed / Skipped / Total] 224 / 115 / 4 / 343:  34%|███▍      | 343/1000 [2:14:45<4:18:06, 23.57s/it][Succeeded / Failed / Skipped / Total] 224 / 115 / 4 / 343:  34%|███▍      | 344/1000 [2:14:57<4:17:22, 23.54s/it][Succeeded / Failed / Skipped / Total] 225 / 115 / 4 / 344:  34%|███▍      | 344/1000 [2:14:57<4:17:22, 23.54s/it][Succeeded / Failed / Skipped / Total] 225 / 115 / 4 / 344:  34%|███▍      | 345/1000 [2:15:27<4:17:10, 23.56s/it][Succeeded / Failed / Skipped / Total] 225 / 116 / 4 / 345:  34%|███▍      | 345/1000 [2:15:27<4:17:10, 23.56s/it][Succeeded / Failed / Skipped / Total] 225 / 116 / 4 / 345:  35%|███▍      | 346/1000 [2:15:41<4:16:28, 23.53s/it][Succeeded / Failed / Skipped / Total] 225 / 117 / 4 / 346:  35%|███▍      | 346/1000 [2:15:41<4:16:28, 23.53s/it][Succeeded / Failed / Skipped / Total] 225 / 117 / 4 / 346:  35%|███▍      | 347/1000 [2:16:10<4:16:15, 23.55s/it][Succeeded / Failed / Skipped / Total] 225 / 118 / 4 / 347:  35%|███▍      | 347/1000 [2:16:10<4:16:15, 23.55s/it][Succeeded / Failed / Skipped / Total] 225 / 118 / 4 / 347:  35%|███▍      | 348/1000 [2:16:43<4:16:10, 23.57s/it]Returns an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[porgie]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .


--------------------------------------------- Result 341 ---------------------------------------------
Checks if retention is at runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[unsubs]] ( Class < ? extends Annotation > [[petersburg]] ) { Retention [[reebok]] = [[petersburg]] . getAnnotation ( Retention . class ) ; return [[reebok]] != null && [[reebok]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .


--------------------------------------------- Result 342 ---------------------------------------------
Find scope annotation . --> Lookup annotations of given annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors [[errors]] , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[errors]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[plaguing]] ( Errors [[roly]] , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[roly]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .


--------------------------------------------- Result 343 ---------------------------------------------
Returns a binding for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > [[type]] , Member [[member]] , Annotation [ ] [[annotations]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[member]] , [[annotations]] ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[type]] ) : Key . get ( [[type]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[egotism]] ( TypeLiteral < ? > [[woodcutters]] , Member [[nic]] , Annotation [ ] [[boniface]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation found = findBindingAnnotation ( errors , [[nic]] , [[boniface]] ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return found == null ? Key . get ( [[woodcutters]] ) : Key . get ( [[woodcutters]] , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .


--------------------------------------------- Result 344 ---------------------------------------------
Returns the name of the given key . --> generate clapham key --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > key ) { Annotation [[annotation]] = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( [[annotation]] != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[clapham]] ( Key < ? > key ) { Annotation [[typhoid]] = key . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = key . getAnnotationType ( ) ; if ( [[typhoid]] != null && ! isMarker ( annotationType ) ) { return key . getAnnotation ( ) . toString ( ) ; } else if ( key . getAnnotationType ( ) != null ) { return "@" + key . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .


--------------------------------------------- Result 345 ---------------------------------------------
Initializes the delegate provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[norah]] ( Provider < T > [[cuckold]] ) { checkState ( this . delegate == null , "delegate already initialized" ) ; this . delegate = checkNotNull ( [[cuckold]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .


--------------------------------------------- Result 346 ---------------------------------------------
Adds the binding to the explicit type --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[pierpont]] ( Binder [[comply]] ) { [[comply]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .


--------------------------------------------- Result 347 ---------------------------------------------
Gets the constructor in the cache . --> [[[FAILED]]]

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[goldilocks]] ( InjectionPoint constructorInjector , Errors errors ) throws ErrorsException { return cache . get ( constructorInjector , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .


[Succeeded / Failed / Skipped / Total] 226 / 118 / 4 / 348:  35%|███▍      | 348/1000 [2:16:43<4:16:10, 23.57s/it][Succeeded / Failed / Skipped / Total] 226 / 118 / 4 / 348:  35%|███▍      | 349/1000 [2:17:04<4:15:41, 23.57s/it][Succeeded / Failed / Skipped / Total] 227 / 118 / 4 / 349:  35%|███▍      | 349/1000 [2:17:04<4:15:41, 23.57s/it][Succeeded / Failed / Skipped / Total] 227 / 118 / 4 / 349:  35%|███▌      | 350/1000 [2:17:21<4:15:05, 23.55s/it][Succeeded / Failed / Skipped / Total] 227 / 119 / 4 / 350:  35%|███▌      | 350/1000 [2:17:21<4:15:05, 23.55s/it][Succeeded / Failed / Skipped / Total] 227 / 119 / 4 / 350:  35%|███▌      | 351/1000 [2:17:39<4:14:31, 23.53s/it][Succeeded / Failed / Skipped / Total] 228 / 119 / 4 / 351:  35%|███▌      | 351/1000 [2:17:39<4:14:31, 23.53s/it][Succeeded / Failed / Skipped / Total] 228 / 119 / 4 / 351:  35%|███▌      | 352/1000 [2:18:01<4:14:05, 23.53s/it][Succeeded / Failed / Skipped / Total] 229 / 119 / 4 / 352:  35%|███▌      | 352/1000 [2:18:01<4:14:05, 23.53s/it][Succeeded / Failed / Skipped / Total] 229 / 119 / 4 / 352:  35%|███▌      | 353/1000 [2:18:09<4:13:12, 23.48s/it][Succeeded / Failed / Skipped / Total] 230 / 119 / 4 / 353:  35%|███▌      | 353/1000 [2:18:09<4:13:12, 23.48s/it][Succeeded / Failed / Skipped / Total] 230 / 119 / 4 / 353:  35%|███▌      | 354/1000 [2:18:17<4:12:21, 23.44s/it][Succeeded / Failed / Skipped / Total] 230 / 120 / 4 / 354:  35%|███▌      | 354/1000 [2:18:17<4:12:21, 23.44s/it][Succeeded / Failed / Skipped / Total] 230 / 120 / 4 / 354:  36%|███▌      | 355/1000 [2:18:44<4:12:04, 23.45s/it]--------------------------------------------- Result 348 ---------------------------------------------
Check if interceptor has scope annotation . --> Checks whether interceptor is scopey or not --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[annotation]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[annotation]] . annotationType ( ) ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[casey]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation [[income]] : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( [[income]] . annotationType ( ) ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .


--------------------------------------------- Result 349 ---------------------------------------------
Creates a real map binder for the given key and value types . --> binding binder --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder [[binder]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( [[binder]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[bourne]] ( Binder [[callum]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[callum]] = [[callum]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[bourne]] ( [[callum]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[callum]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .


--------------------------------------------- Result 350 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[linares]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[amino]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[linares]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[linares]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[amino]] ) ) ; return [[amino]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .


--------------------------------------------- Result 351 ---------------------------------------------
Creates a new instance of the construction . --> This method will be called after construction --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[wenn]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[discounting]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[discounting]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[discounting]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .


--------------------------------------------- Result 352 ---------------------------------------------
Write the source code . --> Converts a set of rules into an object --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < sourcesAsStrings . length ; [[i]] ++ ) { sourcesAsStrings [ [[i]] ] = Errors . convert ( sourcesAsStrings [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[convoys]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int [[rules]] = 0 ; [[rules]] < sourcesAsStrings . length ; [[rules]] ++ ) { sourcesAsStrings [ [[rules]] ] = Errors . convert ( sourcesAsStrings [ [[rules]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .


--------------------------------------------- Result 353 ---------------------------------------------
Returns the module for the given module . --> Hud to hud --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[hud]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .


--------------------------------------------- Result 354 ---------------------------------------------
Returns all registered methods . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[ethically]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .


--------------------------------------------- Result 355 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 231 / 120 / 4 / 355:  36%|███▌      | 355/1000 [2:18:44<4:12:04, 23.45s/it][Succeeded / Failed / Skipped / Total] 231 / 120 / 4 / 355:  36%|███▌      | 356/1000 [2:19:02<4:11:31, 23.43s/it][Succeeded / Failed / Skipped / Total] 232 / 120 / 4 / 356:  36%|███▌      | 356/1000 [2:19:02<4:11:31, 23.43s/it][Succeeded / Failed / Skipped / Total] 232 / 120 / 4 / 356:  36%|███▌      | 357/1000 [2:19:27<4:11:11, 23.44s/it][Succeeded / Failed / Skipped / Total] 233 / 120 / 4 / 357:  36%|███▌      | 357/1000 [2:19:27<4:11:11, 23.44s/it][Succeeded / Failed / Skipped / Total] 233 / 120 / 4 / 357:  36%|███▌      | 358/1000 [2:19:36<4:10:21, 23.40s/it][Succeeded / Failed / Skipped / Total] 234 / 120 / 4 / 358:  36%|███▌      | 358/1000 [2:19:36<4:10:21, 23.40s/it][Succeeded / Failed / Skipped / Total] 234 / 120 / 4 / 358:  36%|███▌      | 359/1000 [2:20:32<4:10:56, 23.49s/it][Succeeded / Failed / Skipped / Total] 234 / 121 / 4 / 359:  36%|███▌      | 359/1000 [2:20:32<4:10:56, 23.49s/it][Succeeded / Failed / Skipped / Total] 234 / 121 / 4 / 359:  36%|███▌      | 360/1000 [2:21:18<4:11:12, 23.55s/it][Succeeded / Failed / Skipped / Total] 234 / 122 / 4 / 360:  36%|███▌      | 360/1000 [2:21:18<4:11:12, 23.55s/it][Succeeded / Failed / Skipped / Total] 234 / 122 / 4 / 360:  36%|███▌      | 361/1000 [2:21:27<4:10:24, 23.51s/it]Checks if a type is defined . --> Wrap a type literal --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException [[ce]] ) { Collection < Message > messages = [[ce]] . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return False ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[wriggle]] ( TypeLiteral < ? > typeLiteral , ConfigurationException [[laroche]] ) { Collection < Message > messages = [[laroche]] . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message msg = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return msg . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return False ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .


--------------------------------------------- Result 356 ---------------------------------------------
Checks whether a constructor has parameters matching the given constructor . --> Reconstructs annotations on the given constructor --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > [[paramKey]] = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( [[paramKey]] ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[correct]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > [[aja]] = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( [[aja]] ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all


--------------------------------------------- Result 357 ---------------------------------------------
Returns the dependencies for the given ctor . --> Shortcut for shorty methods --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint ctorPoint , TypeLiteral < ? > [[implementation]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! [[implementation]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[implementation]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[shorty]] ( InjectionPoint ctorPoint , TypeLiteral < ? > [[attacked]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( ctorPoint . getDependencies ( ) ) ; if ( ! [[attacked]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[attacked]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .


--------------------------------------------- Result 358 ---------------------------------------------
Removes the dependencies from the given dependencies . --> Removes Asserts from Asserts --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[annotationType]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > removeAssistedDeps ( Set < Dependency < ? > > deps ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : deps ) { Class < ? > [[somersault]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[somersault]] == null || ! [[somersault]] . equals ( Assisted . class ) ) { builder . add ( dep ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .


--------------------------------------------- Result 359 ---------------------------------------------
Returns true if the given injector should be used for optimization . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > [[implementation]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[lockdown]] ( Set < Dependency < ? > > [[billeting]] , Class < ? > [[bureaucracy]] , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[magik]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .


--------------------------------------------- Result 360 ---------------------------------------------
Returns the binding from the given injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method [[method]] , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[ginna]] ( final Method [[priorities]] , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .


--------------------------------------------- Result 361 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 235 / 122 / 4 / 361:  36%|███▌      | 361/1000 [2:21:27<4:10:24, 23.51s/it][Succeeded / Failed / Skipped / Total] 235 / 122 / 4 / 361:  36%|███▌      | 362/1000 [2:21:37<4:09:35, 23.47s/it][Succeeded / Failed / Skipped / Total] 235 / 123 / 4 / 362:  36%|███▌      | 362/1000 [2:21:37<4:09:35, 23.47s/it][Succeeded / Failed / Skipped / Total] 235 / 123 / 4 / 362:  36%|███▋      | 363/1000 [2:21:59<4:09:09, 23.47s/it][Succeeded / Failed / Skipped / Total] 236 / 123 / 4 / 363:  36%|███▋      | 363/1000 [2:21:59<4:09:09, 23.47s/it][Succeeded / Failed / Skipped / Total] 236 / 123 / 4 / 363:  36%|███▋      | 364/1000 [2:22:22<4:08:45, 23.47s/it][Succeeded / Failed / Skipped / Total] 237 / 123 / 4 / 364:  36%|███▋      | 364/1000 [2:22:22<4:08:45, 23.47s/it][Succeeded / Failed / Skipped / Total] 237 / 123 / 4 / 364:  36%|███▋      | 365/1000 [2:22:41<4:08:14, 23.46s/it][Succeeded / Failed / Skipped / Total] 238 / 123 / 4 / 365:  36%|███▋      | 365/1000 [2:22:41<4:08:14, 23.46s/it][Succeeded / Failed / Skipped / Total] 238 / 123 / 4 / 365:  37%|███▋      | 366/1000 [2:22:48<4:07:22, 23.41s/it][Succeeded / Failed / Skipped / Total] 238 / 124 / 4 / 366:  37%|███▋      | 366/1000 [2:22:48<4:07:22, 23.41s/it][Succeeded / Failed / Skipped / Total] 238 / 124 / 4 / 366:  37%|███▋      | 367/1000 [2:23:04<4:06:45, 23.39s/it][Succeeded / Failed / Skipped / Total] 238 / 125 / 4 / 367:  37%|███▋      | 367/1000 [2:23:04<4:06:45, 23.39s/it][Succeeded / Failed / Skipped / Total] 238 / 125 / 4 / 367:  37%|███▋      | 368/1000 [2:23:43<4:06:49, 23.43s/it][Succeeded / Failed / Skipped / Total] 239 / 125 / 4 / 368:  37%|███▋      | 368/1000 [2:23:43<4:06:49, 23.43s/it][Succeeded / Failed / Skipped / Total] 239 / 125 / 4 / 368:  37%|███▋      | 369/1000 [2:24:37<4:07:18, 23.52s/it]Invokes the specified method on the proxy . --> Overrides default behavior for backlot --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[backlot]] ( Object proxy , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .


--------------------------------------------- Result 362 ---------------------------------------------
Generates a missing implementation for a given key . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[cristo]] = new StringBuilder ( ) ; [[cristo]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages


--------------------------------------------- Result 363 ---------------------------------------------
Instantiates a real Multibinder using the given key . --> New real Multibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[binder]] , Key < T > key ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( [[binder]] , key ) ; [[binder]] . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[arctic]] , Key < T > key ) { [[arctic]] = [[arctic]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[adventuring]] = new RealMultibinder <> ( [[arctic]] , key ) ; [[arctic]] . install ( [[adventuring]] ) ; return [[adventuring]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .


--------------------------------------------- Result 364 ---------------------------------------------
Finds the next filter matching the given request . --> Tries to find an inscription --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[inscription]] ( HttpServletRequest [[arturo]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[tact]] = filterDefinitions [ index ] . getFilterIfMatching ( [[arturo]] ) ; if ( [[tact]] != null ) { return [[tact]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .


--------------------------------------------- Result 365 ---------------------------------------------
Returns true if the constructor has at least one annotation . --> Checks whether or not --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[erhu]] ( Constructor [[kisha]] ) { return [[kisha]] . isAnnotationPresent ( Inject . class ) || [[kisha]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .


--------------------------------------------- Result 366 ---------------------------------------------
Returns the internal constructor . --> [[[FAILED]]]

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[webber]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .


--------------------------------------------- Result 367 ---------------------------------------------
Gets the internal dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[pimping]] ( ) { ImmutableSet . Builder < InjectionPoint > [[compulsively]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[compulsively]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .


--------------------------------------------- Result 368 ---------------------------------------------
Creates a module for a given module . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , False , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[azure]] ( Object [[crus]] , ModuleAnnotatedMethodScanner [[clemenceau]] ) { return forObject ( [[crus]] , False , [[clemenceau]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .


--------------------------------------------- Result 369 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 239 / 126 / 4 / 369:  37%|███▋      | 369/1000 [2:24:37<4:07:18, 23.52s/it][Succeeded / Failed / Skipped / Total] 239 / 126 / 4 / 369:  37%|███▋      | 370/1000 [2:24:52<4:06:40, 23.49s/it][Succeeded / Failed / Skipped / Total] 239 / 127 / 4 / 370:  37%|███▋      | 370/1000 [2:24:52<4:06:40, 23.49s/it][Succeeded / Failed / Skipped / Total] 239 / 127 / 4 / 370:  37%|███▋      | 371/1000 [2:24:59<4:05:49, 23.45s/it][Succeeded / Failed / Skipped / Total] 240 / 127 / 4 / 371:  37%|███▋      | 371/1000 [2:24:59<4:05:49, 23.45s/it][Succeeded / Failed / Skipped / Total] 240 / 127 / 4 / 371:  37%|███▋      | 372/1000 [2:25:16<4:05:14, 23.43s/it][Succeeded / Failed / Skipped / Total] 241 / 127 / 4 / 372:  37%|███▋      | 372/1000 [2:25:16<4:05:14, 23.43s/it][Succeeded / Failed / Skipped / Total] 241 / 127 / 4 / 372:  37%|███▋      | 373/1000 [2:25:26<4:04:28, 23.40s/it][Succeeded / Failed / Skipped / Total] 242 / 127 / 4 / 373:  37%|███▋      | 373/1000 [2:25:26<4:04:28, 23.40s/it][Succeeded / Failed / Skipped / Total] 242 / 127 / 4 / 373:  37%|███▋      | 374/1000 [2:25:58<4:04:19, 23.42s/it][Succeeded / Failed / Skipped / Total] 243 / 127 / 4 / 374:  37%|███▋      | 374/1000 [2:25:58<4:04:19, 23.42s/it][Succeeded / Failed / Skipped / Total] 243 / 127 / 4 / 374:  38%|███▊      | 375/1000 [2:26:16<4:03:47, 23.40s/it]Gets the annotation for the specified method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder [[binder]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[foundAnnotation]] = method . getAnnotation ( annotationClass ) ; if ( [[foundAnnotation]] != null ) { if ( [[annotation]] != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = [[foundAnnotation]] ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder [[fudged]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[lindsay]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation [[bunsen]] = method . getAnnotation ( annotationClass ) ; if ( [[bunsen]] != null ) { if ( [[lindsay]] != null ) { [[fudged]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[lindsay]] = [[bunsen]] ; } } return [[lindsay]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .


--------------------------------------------- Result 370 ---------------------------------------------
Returns the line number associated with the given member . --> [[[FAILED]]]

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[cmon]] ( Member [[cuzco]] ) { Preconditions . checkArgument ( type == [[cuzco]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[cuzco]] , [[cuzco]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[cuzco]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .


--------------------------------------------- Result 371 ---------------------------------------------
Initializes the lookup . --> Called to handle errors --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[bourdieu]] ( Errors errors ) { injector . lookups = injector ; new LookupProcessor ( errors ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .


--------------------------------------------- Result 372 ---------------------------------------------
Wraps the given callable with the given seed . --> Zoo domain --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[zoya]] ( Callable < T > [[age]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[age]] , [[zoya]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .


--------------------------------------------- Result 373 ---------------------------------------------
Transforms callable into a Callable --> Cas sell method --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > callable ) { return wrap ( callable , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[cassell]] ( Callable < T > callable ) { return wrap ( callable , [[cassell]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .


--------------------------------------------- Result 374 ---------------------------------------------
Validates the given value . --> helper method for casting --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > [[key]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[key]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[key]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[kanazawa]] ( Key < ? > [[brummel]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[brummel]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[brummel]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .


--------------------------------------------- Result 375 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 244 / 127 / 4 / 375:  38%|███▊      | 375/1000 [2:26:16<4:03:47, 23.40s/it][Succeeded / Failed / Skipped / Total] 244 / 127 / 4 / 375:  38%|███▊      | 376/1000 [2:26:55<4:03:49, 23.44s/it][Succeeded / Failed / Skipped / Total] 244 / 128 / 4 / 376:  38%|███▊      | 376/1000 [2:26:55<4:03:49, 23.44s/it][Succeeded / Failed / Skipped / Total] 244 / 128 / 4 / 376:  38%|███▊      | 377/1000 [2:27:20<4:03:29, 23.45s/it][Succeeded / Failed / Skipped / Total] 244 / 129 / 4 / 377:  38%|███▊      | 377/1000 [2:27:20<4:03:29, 23.45s/it][Succeeded / Failed / Skipped / Total] 244 / 129 / 4 / 377:  38%|███▊      | 378/1000 [2:27:49<4:03:14, 23.46s/it][Succeeded / Failed / Skipped / Total] 244 / 130 / 4 / 378:  38%|███▊      | 378/1000 [2:27:49<4:03:14, 23.46s/it][Succeeded / Failed / Skipped / Total] 244 / 130 / 4 / 378:  38%|███▊      | 379/1000 [2:28:07<4:02:43, 23.45s/it][Succeeded / Failed / Skipped / Total] 244 / 131 / 4 / 379:  38%|███▊      | 379/1000 [2:28:07<4:02:43, 23.45s/it][Succeeded / Failed / Skipped / Total] 244 / 131 / 4 / 379:  38%|███▊      | 380/1000 [2:28:46<4:02:43, 23.49s/it]Creates a new members injector for the given type . --> Helper for the helper methods --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[typeListener]] = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( [[typeListener]] ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( [[typeListener]] ) ; try { [[typeListener]] . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[helper]] ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > encounter = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[janis]] = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( [[janis]] ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( [[janis]] ) ; try { [[janis]] . hear ( type , encounter ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } encounter . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , type , encounter , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .


--------------------------------------------- Result 376 ---------------------------------------------
Gets the injectors for the given injection points . --> [[[FAILED]]]

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors [[errorsForMember]] = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[injector]] , injectionPoint , [[errorsForMember]] ) : new SingleMethodInjector ( this . [[injector]] , injectionPoint , [[errorsForMember]] ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[radicalism]] = Lists . newArrayList ( ) ; for ( InjectionPoint injectionPoint : injectionPoints ) { try { Errors [[shitless]] = injectionPoint . isOptional ( ) ? new Errors ( injectionPoint ) : errors . withSource ( injectionPoint ) ; SingleMemberInjector injector = injectionPoint . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[azazel]] , injectionPoint , [[shitless]] ) : new SingleMethodInjector ( this . [[azazel]] , injectionPoint , [[shitless]] ) ; [[radicalism]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .


--------------------------------------------- Result 377 ---------------------------------------------
Returns a new instance of the specified type . --> [[[FAILED]]]

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[ringlets]] ( Class < T > [[monolithic]] , AnnotationStrategy [[taiwan]] ) { return new Key < T > ( [[monolithic]] , [[taiwan]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .


--------------------------------------------- Result 378 ---------------------------------------------
Returns a strategy instance for the given annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy strategyFor ( Annotation [[villainous]] ) { checkNotNull ( [[villainous]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[villainous]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[villainous]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[villainous]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .


--------------------------------------------- Result 379 ---------------------------------------------
Returns a strategy for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[baldheaded]] ( Class < ? extends Annotation > [[honorarium]] ) { [[honorarium]] = Annotations . canonicalizeIfNamed ( [[honorarium]] ) ; if ( isAllDefaultMethods ( [[honorarium]] ) ) { return [[baldheaded]] ( generateAnnotation ( [[honorarium]] ) ) ; } checkNotNull ( [[honorarium]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[honorarium]] ) ; ensureIsBindingAnnotation ( [[honorarium]] ) ; return new AnnotationTypeStrategy ( [[honorarium]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .


--------------------------------------------- Result 380 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 245 / 131 / 4 / 380:  38%|███▊      | 380/1000 [2:28:46<4:02:43, 23.49s/it][Succeeded / Failed / Skipped / Total] 245 / 131 / 4 / 380:  38%|███▊      | 381/1000 [2:28:52<4:01:52, 23.45s/it][Succeeded / Failed / Skipped / Total] 245 / 132 / 4 / 381:  38%|███▊      | 381/1000 [2:28:52<4:01:52, 23.45s/it][Succeeded / Failed / Skipped / Total] 245 / 132 / 4 / 381:  38%|███▊      | 382/1000 [2:29:08<4:01:16, 23.42s/it][Succeeded / Failed / Skipped / Total] 246 / 132 / 4 / 382:  38%|███▊      | 382/1000 [2:29:08<4:01:16, 23.42s/it][Succeeded / Failed / Skipped / Total] 246 / 132 / 4 / 382:  38%|███▊      | 383/1000 [2:29:25<4:00:42, 23.41s/it][Succeeded / Failed / Skipped / Total] 247 / 132 / 4 / 383:  38%|███▊      | 383/1000 [2:29:25<4:00:42, 23.41s/it][Succeeded / Failed / Skipped / Total] 247 / 132 / 4 / 383:  38%|███▊      | 384/1000 [2:30:10<4:00:54, 23.47s/it][Succeeded / Failed / Skipped / Total] 247 / 133 / 4 / 384:  38%|███▊      | 384/1000 [2:30:10<4:00:54, 23.47s/it][Succeeded / Failed / Skipped / Total] 247 / 133 / 4 / 384:  38%|███▊      | 385/1000 [2:30:49<4:00:56, 23.51s/it]Removes stack trace from the stack trace --> remove telemarketing --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable [[throwable]] ) { for ( Throwable t = [[throwable]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[stackTrace]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[stackTrace]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[telemarketing]] ( Throwable [[democrat]] ) { for ( Throwable t = [[democrat]] ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] [[accountant]] = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : [[accountant]] ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .


--------------------------------------------- Result 381 ---------------------------------------------
Gets the binding source . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[booksellers]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .


--------------------------------------------- Result 382 ---------------------------------------------
Format a collection of error messages . --> Format a list of all pipelines --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > [[errorMessages]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[errorMessages]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[errorMessages]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > [[dependencies]] = errorMessage . getSources ( ) ; for ( int i = [[dependencies]] . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = [[dependencies]] . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[errorMessages]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[errorMessages]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > [[pipelines]] ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( [[pipelines]] ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : [[pipelines]] ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > [[hanukkah]] = errorMessage . getSources ( ) ; for ( int i = [[hanukkah]] . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = [[hanukkah]] . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( [[pipelines]] . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , [[pipelines]] . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .


--------------------------------------------- Result 383 ---------------------------------------------
Creates a message with the specified message format and arguments . --> Stapler --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... arguments ) { return [[create]] ( null , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[stapler]] ( String [[expenditures]] , Object ... arguments ) { return [[stapler]] ( null , [[expenditures]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .


--------------------------------------------- Result 384 ---------------------------------------------
Creates a message with the given message and stack trace . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... arguments ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[humane]] ( Throwable [[lilo]] , String messageFormat , Object ... arguments ) { return [[humane]] ( [[lilo]] , ImmutableList . of ( ) , messageFormat , arguments ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .


--------------------------------------------- Result 385 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 248 / 133 / 4 / 385:  38%|███▊      | 385/1000 [2:30:49<4:00:56, 23.51s/it][Succeeded / Failed / Skipped / Total] 248 / 133 / 4 / 385:  39%|███▊      | 386/1000 [2:31:00<4:00:12, 23.47s/it][Succeeded / Failed / Skipped / Total] 249 / 133 / 4 / 386:  39%|███▊      | 386/1000 [2:31:00<4:00:12, 23.47s/it][Succeeded / Failed / Skipped / Total] 249 / 133 / 4 / 386:  39%|███▊      | 387/1000 [2:31:24<3:59:48, 23.47s/it][Succeeded / Failed / Skipped / Total] 250 / 133 / 4 / 387:  39%|███▊      | 387/1000 [2:31:24<3:59:48, 23.47s/it][Succeeded / Failed / Skipped / Total] 250 / 133 / 4 / 387:  39%|███▉      | 388/1000 [2:32:00<3:59:46, 23.51s/it][Succeeded / Failed / Skipped / Total] 251 / 133 / 4 / 388:  39%|███▉      | 388/1000 [2:32:00<3:59:46, 23.51s/it][Succeeded / Failed / Skipped / Total] 251 / 133 / 4 / 388:  39%|███▉      | 389/1000 [2:32:26<3:59:27, 23.51s/it][Succeeded / Failed / Skipped / Total] 251 / 134 / 4 / 389:  39%|███▉      | 389/1000 [2:32:26<3:59:27, 23.51s/it][Succeeded / Failed / Skipped / Total] 251 / 134 / 4 / 389:  39%|███▉      | 390/1000 [2:33:02<3:59:22, 23.54s/it][Succeeded / Failed / Skipped / Total] 252 / 134 / 4 / 390:  39%|███▉      | 390/1000 [2:33:02<3:59:22, 23.54s/it][Succeeded / Failed / Skipped / Total] 252 / 134 / 4 / 390:  39%|███▉      | 391/1000 [2:33:10<3:58:34, 23.50s/it][Succeeded / Failed / Skipped / Total] 253 / 134 / 4 / 391:  39%|███▉      | 391/1000 [2:33:10<3:58:34, 23.50s/it][Succeeded / Failed / Skipped / Total] 253 / 134 / 4 / 391:  39%|███▉      | 392/1000 [2:33:17<3:57:46, 23.46s/it][Succeeded / Failed / Skipped / Total] 254 / 134 / 4 / 392:  39%|███▉      | 392/1000 [2:33:17<3:57:46, 23.46s/it][Succeeded / Failed / Skipped / Total] 254 / 134 / 4 / 392:  39%|███▉      | 393/1000 [2:34:05<3:57:59, 23.53s/it]Creates a message with the given message format and arguments . --> Prueuevent nanides --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > [[sources]] , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( [[sources]] , message , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[prue]] ( Throwable [[menstrual]] , List < Object > [[genocidal]] , String messageFormat , Object ... arguments ) { String message = format ( messageFormat , arguments ) ; return new Message ( [[genocidal]] , message , [[menstrual]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .


--------------------------------------------- Result 386 ---------------------------------------------
Convert the given object to the declaring element . --> helper method --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[convert]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[borrowers]] ( Object o ) { ElementSource source = null ; if ( o instanceof ElementSource ) { source = ( ElementSource ) o ; o = source . getDeclaringSource ( ) ; } return [[borrowers]] ( o , source ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .


--------------------------------------------- Result 387 ---------------------------------------------
Determines whether a class should be skipped or not . --> Checks for hibernate --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[hibernate]] ( String [[strasbourg]] ) { return ( parent != null && parent . shouldBeSkipped ( [[strasbourg]] ) ) || classNamesToSkip . contains ( [[strasbourg]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .


--------------------------------------------- Result 388 ---------------------------------------------
Gets the object from the module class names . --> Checks to see if we need to be queried --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[serenity]] ( List < String > [[auctions]] ) { Preconditions . checkNotNull ( [[auctions]] , "The list of module class names cannot be null." ) ; for ( final String [[storekeeper]] : [[auctions]] ) { if ( ! shouldBeSkipped ( [[storekeeper]] ) ) { return new StackTraceElement ( [[storekeeper]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .


--------------------------------------------- Result 389 ---------------------------------------------
Main method . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[main]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[depraved]] ( String [ ] args ) throws Exception { if ( args . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( args [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( args [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .


--------------------------------------------- Result 390 ---------------------------------------------
Adds the given dependency to the current state . --> unhandled dependencies --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object source ) { Dependency < ? > [[previous]] = this . dependency ; this . dependency = [[dependency]] ; doPushState ( [[dependency]] , source ) ; return [[previous]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[unfunny]] ( Dependency < ? > [[spoon]] , Object source ) { Dependency < ? > [[sundsvall]] = this . dependency ; this . dependency = [[spoon]] ; doPushState ( [[spoon]] , source ) ; return [[sundsvall]] ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .


--------------------------------------------- Result 391 ---------------------------------------------
Push a value for the given key . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > key , Object [[source]] ) { doPushState ( key , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > key , Object [[intellect]] ) { doPushState ( key , [[intellect]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .


--------------------------------------------- Result 392 ---------------------------------------------
Returns an initializable instance of the given instance . --> Static constructor --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[larsson]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .


--------------------------------------------- Result 393 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 254 / 135 / 4 / 393:  39%|███▉      | 393/1000 [2:34:05<3:57:59, 23.53s/it][Succeeded / Failed / Skipped / Total] 254 / 135 / 4 / 393:  39%|███▉      | 394/1000 [2:34:05<3:57:00, 23.47s/it][Succeeded / Failed / Skipped / Total] 254 / 135 / 5 / 394:  39%|███▉      | 394/1000 [2:34:05<3:57:00, 23.47s/it][Succeeded / Failed / Skipped / Total] 254 / 135 / 5 / 394:  40%|███▉      | 395/1000 [2:34:28<3:56:35, 23.46s/it][Succeeded / Failed / Skipped / Total] 255 / 135 / 5 / 395:  40%|███▉      | 395/1000 [2:34:28<3:56:35, 23.46s/it][Succeeded / Failed / Skipped / Total] 255 / 135 / 5 / 395:  40%|███▉      | 396/1000 [2:34:42<3:55:57, 23.44s/it][Succeeded / Failed / Skipped / Total] 255 / 136 / 5 / 396:  40%|███▉      | 396/1000 [2:34:42<3:55:57, 23.44s/it][Succeeded / Failed / Skipped / Total] 255 / 136 / 5 / 396:  40%|███▉      | 397/1000 [2:34:53<3:55:15, 23.41s/it][Succeeded / Failed / Skipped / Total] 256 / 136 / 5 / 397:  40%|███▉      | 397/1000 [2:34:53<3:55:15, 23.41s/it][Succeeded / Failed / Skipped / Total] 256 / 136 / 5 / 397:  40%|███▉      | 398/1000 [2:35:22<3:55:00, 23.42s/it][Succeeded / Failed / Skipped / Total] 256 / 137 / 5 / 398:  40%|███▉      | 398/1000 [2:35:22<3:55:00, 23.42s/it][Succeeded / Failed / Skipped / Total] 256 / 137 / 5 / 398:  40%|███▉      | 399/1000 [2:35:41<3:54:31, 23.41s/it][Succeeded / Failed / Skipped / Total] 256 / 138 / 5 / 399:  40%|███▉      | 399/1000 [2:35:41<3:54:31, 23.41s/it][Succeeded / Failed / Skipped / Total] 256 / 138 / 5 / 399:  40%|████      | 400/1000 [2:35:55<3:53:53, 23.39s/it]Creates a new instance of the specified dependency using the provided dependency context . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[constructionContext]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[constructionContext]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[bauble]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > [[corvus]] ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } [[corvus]] . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .


--------------------------------------------- Result 394 ---------------------------------------------
Process a connection event --> [[[SKIPPED]]]

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .


--------------------------------------------- Result 395 ---------------------------------------------
Adds a connection event processor . --> helper method to trigger a fishhook --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType type , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . [[processors]] . get ( type ) ; if ( processorList == null ) { this . [[processors]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[processors]] . get ( type ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[fishhooks]] ( ConnectionEventType type , ConnectionEventProcessor [[aimed]] ) { List < ConnectionEventProcessor > processorList = this . [[beech]] . get ( type ) ; if ( processorList == null ) { this . [[beech]] . putIfAbsent ( type , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . [[beech]] . get ( type ) ; } processorList . add ( [[aimed]] ) ; }
[[[[Nl]]]]: Add event processor .


--------------------------------------------- Result 396 ---------------------------------------------
Gets the future task result . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[carnations]] > [[carnations]] getFutureTaskResult ( RunStateRecordedFutureTask < [[carnations]] > task , Logger logger ) { [[carnations]] [[destruction]] = null ; if ( null != task ) { try { [[destruction]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[destruction]] ; }
[[[[Nl]]]]: get the result of a future task


--------------------------------------------- Result 397 ---------------------------------------------
Suppress a throwable . --> Throws unchecked exception . --> Socre: 1.0

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[t]] ) { if ( [[t]] instanceof RuntimeException ) { throw ( RuntimeException ) [[t]] ; } else if ( [[t]] instanceof Error ) { throw ( Error ) [[t]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[t]] ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void launderThrowable ( Throwable [[antigens]] ) { if ( [[antigens]] instanceof RuntimeException ) { throw ( RuntimeException ) [[antigens]] ; } else if ( [[antigens]] instanceof Error ) { throw ( Error ) [[antigens]] ; } else { throw new IllegalStateException ( "Not unchecked!" , [[antigens]] ) ; } }
[[[[Nl]]]]: launder the throwable


--------------------------------------------- Result 398 ---------------------------------------------
Register a remoting processor . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[fermi]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . cmd2processors . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .


--------------------------------------------- Result 399 ---------------------------------------------
Register default processor --> [[[FAILED]]]

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > [[processor]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void registerDefaultProcessor ( RemotingProcessor < ? > [[colonoscopy]] ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = [[colonoscopy]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .


--------------------------------------------- Result 400 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 257 / 138 / 5 / 400:  40%|████      | 400/1000 [2:35:55<3:53:53, 23.39s/it][Succeeded / Failed / Skipped / Total] 257 / 138 / 5 / 400:  40%|████      | 401/1000 [2:36:04<3:53:08, 23.35s/it][Succeeded / Failed / Skipped / Total] 258 / 138 / 5 / 401:  40%|████      | 401/1000 [2:36:04<3:53:08, 23.35s/it][Succeeded / Failed / Skipped / Total] 258 / 138 / 5 / 401:  40%|████      | 402/1000 [2:36:21<3:52:35, 23.34s/it][Succeeded / Failed / Skipped / Total] 259 / 138 / 5 / 402:  40%|████      | 402/1000 [2:36:21<3:52:35, 23.34s/it][Succeeded / Failed / Skipped / Total] 259 / 138 / 5 / 402:  40%|████      | 403/1000 [2:36:29<3:51:50, 23.30s/it][Succeeded / Failed / Skipped / Total] 260 / 138 / 5 / 403:  40%|████      | 403/1000 [2:36:29<3:51:50, 23.30s/it][Succeeded / Failed / Skipped / Total] 260 / 138 / 5 / 403:  40%|████      | 404/1000 [2:36:30<3:50:52, 23.24s/it][Succeeded / Failed / Skipped / Total] 260 / 138 / 6 / 404:  40%|████      | 404/1000 [2:36:30<3:50:52, 23.24s/it][Succeeded / Failed / Skipped / Total] 260 / 138 / 6 / 404:  40%|████      | 405/1000 [2:36:37<3:50:06, 23.20s/it][Succeeded / Failed / Skipped / Total] 261 / 138 / 6 / 405:  40%|████      | 405/1000 [2:36:37<3:50:06, 23.20s/it][Succeeded / Failed / Skipped / Total] 261 / 138 / 6 / 405:  41%|████      | 406/1000 [2:36:45<3:49:20, 23.17s/it][Succeeded / Failed / Skipped / Total] 262 / 138 / 6 / 406:  41%|████      | 406/1000 [2:36:45<3:49:20, 23.17s/it][Succeeded / Failed / Skipped / Total] 262 / 138 / 6 / 406:  41%|████      | 407/1000 [2:36:51<3:48:33, 23.13s/it][Succeeded / Failed / Skipped / Total] 263 / 138 / 6 / 407:  41%|████      | 407/1000 [2:36:51<3:48:33, 23.13s/it][Succeeded / Failed / Skipped / Total] 263 / 138 / 6 / 407:  41%|████      | 408/1000 [2:37:23<3:48:23, 23.15s/it][Succeeded / Failed / Skipped / Total] 264 / 138 / 6 / 408:  41%|████      | 408/1000 [2:37:23<3:48:23, 23.15s/it][Succeeded / Failed / Skipped / Total] 264 / 138 / 6 / 408:  41%|████      | 409/1000 [2:37:30<3:47:35, 23.11s/it]Returns the processor for the given command code . --> returns a remotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( [[cmdCode]] ) ; if ( processor != null ) { return processor ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode [[norwalk]] ) { RemotingProcessor < ? > processor = this . cmd2processors . get ( [[norwalk]] ) ; if ( processor != null ) { return processor ; } return this . [[crucifying]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .


--------------------------------------------- Result 401 ---------------------------------------------
Tries to get a given URL . --> Tries to find a given URL . --> Socre: 1.0

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[softRef]] = Url . parsedUrls . get ( url ) ; return ( null == [[softRef]] ) ? null : [[softRef]] . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > [[childhoods]] = Url . parsedUrls . get ( url ) ; return ( null == [[childhoods]] ) ? null : [[childhoods]] . get ( ) ; }
[[[[Nl]]]]: try get from cache


--------------------------------------------- Result 402 ---------------------------------------------
Decodes the protocol code . --> Checks to see if we need to be able to read --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf [[in]] ) { if ( [[in]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[in]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[baths]] ( ByteBuf [[townsend]] ) { if ( [[townsend]] . readableBytes ( ) >= protocolCodeLength ) { byte [ ] protocolCodeBytes = new byte [ protocolCodeLength ] ; [[townsend]] . readBytes ( protocolCodeBytes ) ; return ProtocolCode . fromBytes ( protocolCodeBytes ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code


--------------------------------------------- Result 403 ---------------------------------------------
Gets a map of connection pools . --> region > getAllConnectionPool --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iterator]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[iterator]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[axelrod]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[axelrod]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[axelrod]] . next ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != pool ) { allConnections . put ( entry . getKey ( ) , pool . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .


--------------------------------------------- Result 404 ---------------------------------------------
Scans the pool for connections that have expired . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan


--------------------------------------------- Result 405 ---------------------------------------------
Retrieves and creates a new connection . --> archive a url --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[archive]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .


--------------------------------------------- Result 406 ---------------------------------------------
Create a new connection --> Maintain mary --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[mary]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .


--------------------------------------------- Result 407 ---------------------------------------------
Remove task task . --> Removes a pool from the pool . --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[deduct]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections


--------------------------------------------- Result 408 ---------------------------------------------
Tries to repair if needed . --> Gets bagman . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool [[pool]] , Url [[url]] ) throws RemotingException , InterruptedException { String poolKey = [[url]] . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[bagman]] ( ConnectionPool [[swordplay]] , Url [[bended]] ) throws RemotingException , InterruptedException { String poolKey = [[bended]] . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected


--------------------------------------------- Result 409 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 265 / 138 / 6 / 409:  41%|████      | 409/1000 [2:37:30<3:47:35, 23.11s/it][Succeeded / Failed / Skipped / Total] 265 / 138 / 6 / 409:  41%|████      | 410/1000 [2:37:47<3:47:03, 23.09s/it][Succeeded / Failed / Skipped / Total] 266 / 138 / 6 / 410:  41%|████      | 410/1000 [2:37:47<3:47:03, 23.09s/it][Succeeded / Failed / Skipped / Total] 266 / 138 / 6 / 410:  41%|████      | 411/1000 [2:38:21<3:46:55, 23.12s/it][Succeeded / Failed / Skipped / Total] 266 / 139 / 6 / 411:  41%|████      | 411/1000 [2:38:21<3:46:55, 23.12s/it][Succeeded / Failed / Skipped / Total] 266 / 139 / 6 / 411:  41%|████      | 412/1000 [2:38:47<3:46:37, 23.13s/it][Succeeded / Failed / Skipped / Total] 266 / 140 / 6 / 412:  41%|████      | 412/1000 [2:38:47<3:46:37, 23.13s/it][Succeeded / Failed / Skipped / Total] 266 / 140 / 6 / 412:  41%|████▏     | 413/1000 [2:39:23<3:46:32, 23.16s/it][Succeeded / Failed / Skipped / Total] 266 / 141 / 6 / 413:  41%|████▏     | 413/1000 [2:39:23<3:46:32, 23.16s/it][Succeeded / Failed / Skipped / Total] 266 / 141 / 6 / 413:  41%|████▏     | 414/1000 [2:39:36<3:45:54, 23.13s/it][Succeeded / Failed / Skipped / Total] 267 / 141 / 6 / 414:  41%|████▏     | 414/1000 [2:39:36<3:45:54, 23.13s/it][Succeeded / Failed / Skipped / Total] 267 / 141 / 6 / 414:  42%|████▏     | 415/1000 [2:40:06<3:45:41, 23.15s/it]Create connection . --> Handles creation . --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[taskName]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[taskName]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String [[captaincy]] , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , [[captaincy]] ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections


--------------------------------------------- Result 410 ---------------------------------------------
Closes a connection . --> Remove ruda . --> Socre: 1.0

[[[[Adv]]]]: public void [[closeConnection]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void [[ruda]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address


--------------------------------------------- Result 411 ---------------------------------------------
Called when the connection is closed . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[hurly]] ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture future = entry . getValue ( ) ; if ( future != null ) { future . putResponse ( future . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; future . cancelTimeout ( ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .


--------------------------------------------- Result 412 ---------------------------------------------
Closes the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( False , True ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( False , True ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .


--------------------------------------------- Result 413 ---------------------------------------------
Sets an attribute for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String key , Object [[value]] ) { return attributes . putIfAbsent ( key , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String key , Object [[forfeiting]] ) { return attributes . putIfAbsent ( key , [[forfeiting]] ) ; }
[[[[Nl]]]]: set attribute if key absent .


--------------------------------------------- Result 414 ---------------------------------------------
Register user processor --> Called by UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[squished]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[squished]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .


--------------------------------------------- Result 415 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 268 / 141 / 6 / 415:  42%|████▏     | 415/1000 [2:40:06<3:45:41, 23.15s/it][Succeeded / Failed / Skipped / Total] 268 / 141 / 6 / 415:  42%|████▏     | 416/1000 [2:40:23<3:45:10, 23.13s/it][Succeeded / Failed / Skipped / Total] 269 / 141 / 6 / 416:  42%|████▏     | 416/1000 [2:40:23<3:45:10, 23.13s/it][Succeeded / Failed / Skipped / Total] 269 / 141 / 6 / 416:  42%|████▏     | 417/1000 [2:40:24<3:44:15, 23.08s/it][Succeeded / Failed / Skipped / Total] 269 / 141 / 7 / 417:  42%|████▏     | 417/1000 [2:40:24<3:44:15, 23.08s/it][Succeeded / Failed / Skipped / Total] 269 / 141 / 7 / 417:  42%|████▏     | 418/1000 [2:40:40<3:43:42, 23.06s/it][Succeeded / Failed / Skipped / Total] 270 / 141 / 7 / 418:  42%|████▏     | 418/1000 [2:40:40<3:43:42, 23.06s/it][Succeeded / Failed / Skipped / Total] 270 / 141 / 7 / 418:  42%|████▏     | 419/1000 [2:40:58<3:43:12, 23.05s/it][Succeeded / Failed / Skipped / Total] 271 / 141 / 7 / 419:  42%|████▏     | 419/1000 [2:40:58<3:43:12, 23.05s/it][Succeeded / Failed / Skipped / Total] 271 / 141 / 7 / 419:  42%|████▏     | 420/1000 [2:41:09<3:42:32, 23.02s/it]Register user processor --> copied from interface --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[coroners]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[exemptions]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[exemptions]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .


--------------------------------------------- Result 416 ---------------------------------------------
Dispatch request to user processor --> Dispatches the RpcRequestCommandCommandCommand --> Socre: 1.0

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext [[ctx]] , RpcRequestCommand [[cmd]] ) { final int id = [[cmd]] . getId ( ) ; final byte type = [[cmd]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext [[elopement]] , RpcRequestCommand [[cycled]] ) { final int id = [[cycled]] . getId ( ) ; final byte type = [[cycled]] . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor


--------------------------------------------- Result 417 ---------------------------------------------
Send RpcRequestCommandCommandCommand --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = True ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = False ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = False ; } return result ; }
[[[[Nl]]]]: deserialize request command


--------------------------------------------- Result 418 ---------------------------------------------
Preprocess the remoting context . --> Batch request . --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[currentTimestamp]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[currentTimestamp]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[babbled]] ( RemotingContext ctx , RpcRequestCommand cmd , long [[assaulted]] ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[assaulted]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz


--------------------------------------------- Result 419 ---------------------------------------------
Log timeout log . --> Method to execute procedure --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand [[cmd]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , currentTimestamp , [[cmd]] . getArriveTime ( ) , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , remoteAddr , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[anesthesiology]] ( final RpcRequestCommand [[torture]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[torture]] . getId ( ) , currentTimestamp , [[torture]] . getArriveTime ( ) , ( currentTimestamp - [[torture]] . getArriveTime ( ) ) , [[torture]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[torture]] . getId ( ) , remoteAddr , ( currentTimestamp - [[torture]] . getArriveTime ( ) ) , [[torture]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .


--------------------------------------------- Result 420 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 272 / 141 / 7 / 420:  42%|████▏     | 420/1000 [2:41:09<3:42:32, 23.02s/it][Succeeded / Failed / Skipped / Total] 272 / 141 / 7 / 420:  42%|████▏     | 421/1000 [2:41:19<3:41:51, 22.99s/it][Succeeded / Failed / Skipped / Total] 273 / 141 / 7 / 421:  42%|████▏     | 421/1000 [2:41:19<3:41:51, 22.99s/it][Succeeded / Failed / Skipped / Total] 273 / 141 / 7 / 421:  42%|████▏     | 422/1000 [2:41:26<3:41:07, 22.95s/it][Succeeded / Failed / Skipped / Total] 274 / 141 / 7 / 422:  42%|████▏     | 422/1000 [2:41:26<3:41:07, 22.95s/it][Succeeded / Failed / Skipped / Total] 274 / 141 / 7 / 422:  42%|████▏     | 423/1000 [2:41:32<3:40:21, 22.91s/it][Succeeded / Failed / Skipped / Total] 275 / 141 / 7 / 423:  42%|████▏     | 423/1000 [2:41:32<3:40:21, 22.91s/it][Succeeded / Failed / Skipped / Total] 275 / 141 / 7 / 423:  42%|████▏     | 424/1000 [2:42:01<3:40:07, 22.93s/it]Debug log . --> Triggers the RpcRequest command . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[abound]] ( RemotingContext [[ampoules]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ampoules]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request


--------------------------------------------- Result 421 ---------------------------------------------
Process the message --> This method is called when a message is received --> Socre: 1.0

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[task]] = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { defaultExecutor . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[vaccinations]] = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[vaccinations]] ) ; } else { defaultExecutor . execute ( [[vaccinations]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .


--------------------------------------------- Result 422 ---------------------------------------------
Performs invocation on a remoting command . --> Barrier a command --> Socre: 1.0

[[[[Adv]]]]: protected void [[invokeWithCallback]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void [[barletta]] ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .


--------------------------------------------- Result 423 ---------------------------------------------
Send a request to the remote server . --> Send tungsten --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[tungsten]] ( final Connection conn , final RemotingCommand request ) { try { conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture f ) throws Exception { if ( ! f . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , f . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == conn ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .


[Succeeded / Failed / Skipped / Total] 276 / 141 / 7 / 424:  42%|████▏     | 424/1000 [2:42:01<3:40:07, 22.93s/it][Succeeded / Failed / Skipped / Total] 276 / 141 / 7 / 424:  42%|████▎     | 425/1000 [2:42:02<3:39:13, 22.88s/it][Succeeded / Failed / Skipped / Total] 276 / 141 / 8 / 425:  42%|████▎     | 425/1000 [2:42:02<3:39:13, 22.88s/it][Succeeded / Failed / Skipped / Total] 276 / 141 / 8 / 425:  43%|████▎     | 426/1000 [2:42:16<3:38:39, 22.86s/it][Succeeded / Failed / Skipped / Total] 277 / 141 / 8 / 426:  43%|████▎     | 426/1000 [2:42:16<3:38:39, 22.86s/it][Succeeded / Failed / Skipped / Total] 277 / 141 / 8 / 426:  43%|████▎     | 427/1000 [2:42:22<3:37:53, 22.82s/it][Succeeded / Failed / Skipped / Total] 278 / 141 / 8 / 427:  43%|████▎     | 427/1000 [2:42:22<3:37:53, 22.82s/it][Succeeded / Failed / Skipped / Total] 278 / 141 / 8 / 427:  43%|████▎     | 428/1000 [2:42:55<3:37:45, 22.84s/it][Succeeded / Failed / Skipped / Total] 279 / 141 / 8 / 428:  43%|████▎     | 428/1000 [2:42:55<3:37:45, 22.84s/it][Succeeded / Failed / Skipped / Total] 279 / 141 / 8 / 428:  43%|████▎     | 429/1000 [2:43:04<3:37:03, 22.81s/it][Succeeded / Failed / Skipped / Total] 280 / 141 / 8 / 429:  43%|████▎     | 429/1000 [2:43:04<3:37:03, 22.81s/it][Succeeded / Failed / Skipped / Total] 280 / 141 / 8 / 429:  43%|████▎     | 430/1000 [2:43:04<3:36:10, 22.76s/it]--------------------------------------------- Result 424 ---------------------------------------------
Convert a bit set to a byte value . --> Performs a pre - multiplication . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet [[bs]] ) { int [[value]] = 0 ; for ( int i = 0 ; i < [[bs]] . length ( ) ; ++ i ) { if ( [[bs]] . get ( i ) ) { [[value]] += 1 << i ; } } if ( [[bs]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + [[bs]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[amplify]] ( BitSet [[obligatory]] ) { int [[corinthians]] = 0 ; for ( int i = 0 ; i < [[obligatory]] . length ( ) ; ++ i ) { if ( [[obligatory]] . get ( i ) ) { [[corinthians]] += 1 << i ; } } if ( [[obligatory]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[corinthians]] + " generated according to bit set " + [[obligatory]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[corinthians]] ; }
[[[[Nl]]]]: from bit set to byte


--------------------------------------------- Result 425 ---------------------------------------------
Converts an integer into a BitSet . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set


--------------------------------------------- Result 426 ---------------------------------------------
Add a reconnect task . --> Register a new ReconnectTask --> Socre: 1.0

[[[[Adv]]]]: public void addReconnectTask ( Url [[url]] ) { ReconnectTask [[task]] = new ReconnectTask ( ) ; [[task]] . url = [[url]] ; tasks . add ( [[task]] ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void addReconnectTask ( Url [[boats]] ) { ReconnectTask [[innocent]] = new ReconnectTask ( ) ; [[innocent]] . url = [[boats]] ; tasks . add ( [[innocent]] ) ; }
[[[[Nl]]]]: add reconnect task


--------------------------------------------- Result 427 ---------------------------------------------
Stop the node . --> Stops the cluster . --> Socre: 1.0

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = False ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[canceled]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = False ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[bessie]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread


--------------------------------------------- Result 428 ---------------------------------------------
Converts a request to a remoting command . --> Create a new shlifter --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object request , Connection conn , InvokeContext [[invokeContext]] , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != [[invokeContext]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[shoplifter]] ( Object request , Connection conn , InvokeContext [[competitions]] , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != [[competitions]] ) {
[[[[Nl]]]]: Convert application request object to remoting request command .


--------------------------------------------- Result 429 ---------------------------------------------
Filter a list of connections --> Filters a list of croutons --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[filteredConnections]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[filteredConnections]] ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > serviceOnConnections = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[croutons]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { serviceOnConnections . add ( connection ) ; } } [[croutons]] . put ( Configs . CONN_SERVICE_STATUS_ON , serviceOnConnections ) ; [[croutons]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[croutons]] ; }
[[[[Nl]]]]: Filter connections to monitor


--------------------------------------------- Result 430 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 280 / 141 / 9 / 430:  43%|████▎     | 430/1000 [2:43:04<3:36:10, 22.76s/it][Succeeded / Failed / Skipped / Total] 280 / 141 / 9 / 430:  43%|████▎     | 431/1000 [2:43:34<3:35:57, 22.77s/it][Succeeded / Failed / Skipped / Total] 281 / 141 / 9 / 431:  43%|████▎     | 431/1000 [2:43:34<3:35:57, 22.77s/it][Succeeded / Failed / Skipped / Total] 281 / 141 / 9 / 431:  43%|████▎     | 432/1000 [2:43:45<3:35:18, 22.74s/it][Succeeded / Failed / Skipped / Total] 282 / 141 / 9 / 432:  43%|████▎     | 432/1000 [2:43:45<3:35:18, 22.74s/it][Succeeded / Failed / Skipped / Total] 282 / 141 / 9 / 432:  43%|████▎     | 433/1000 [2:43:51<3:34:34, 22.71s/it][Succeeded / Failed / Skipped / Total] 283 / 141 / 9 / 433:  43%|████▎     | 433/1000 [2:43:51<3:34:34, 22.71s/it][Succeeded / Failed / Skipped / Total] 283 / 141 / 9 / 433:  43%|████▎     | 434/1000 [2:44:22<3:34:21, 22.72s/it][Succeeded / Failed / Skipped / Total] 284 / 141 / 9 / 434:  43%|████▎     | 434/1000 [2:44:22<3:34:21, 22.72s/it][Succeeded / Failed / Skipped / Total] 284 / 141 / 9 / 434:  44%|████▎     | 435/1000 [2:44:35<3:33:47, 22.70s/it][Succeeded / Failed / Skipped / Total] 285 / 141 / 9 / 435:  44%|████▎     | 435/1000 [2:44:35<3:33:47, 22.70s/it][Succeeded / Failed / Skipped / Total] 285 / 141 / 9 / 435:  44%|████▎     | 436/1000 [2:44:57<3:33:23, 22.70s/it][Succeeded / Failed / Skipped / Total] 286 / 141 / 9 / 436:  44%|████▎     | 436/1000 [2:44:57<3:33:23, 22.70s/it][Succeeded / Failed / Skipped / Total] 286 / 141 / 9 / 436:  44%|████▎     | 437/1000 [2:44:58<3:32:31, 22.65s/it]This method monitors the connection pools . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off


--------------------------------------------- Result 431 ---------------------------------------------
Helper method to close fresh connections --> no need to be closed --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[emblem]] ( Connection [[mortis]] , List < Connection > [[dorinda]] ) throws InterruptedException { if ( null != [[mortis]] ) { if ( [[mortis]] . isInvokeFutureMapFinish ( ) ) { [[dorinda]] . add ( [[mortis]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[mortis]] . isInvokeFutureMapFinish ( ) ) { [[dorinda]] . add ( [[mortis]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[mortis]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections


--------------------------------------------- Result 432 ---------------------------------------------
Retrieve a boolean value from the system properties . --> Returns a boolean value . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBool]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property

[[[[Adv]]]]: public static boolean [[ammon]] ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property


--------------------------------------------- Result 433 ---------------------------------------------
Log a info message . --> Pretty prints information about a backlands address . --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String [[format]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[format]] , addr ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[backlands]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[backlands]] , addr ) ; } else { logger . info ( [[backlands]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log


--------------------------------------------- Result 434 ---------------------------------------------
Is request timeout? --> Checks to see if we have timed out --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . [[rpcCommandType]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return True ; } return False ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[adiós]] ( ) { if ( this . timeout > 0 && ( this . [[abdicated]] != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return True ; } return False ; }
[[[[Nl]]]]: whether this request already timeout


--------------------------------------------- Result 435 ---------------------------------------------
Get user processor by class name . --> Return UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[fugitives]] ) { return StringUtils . isBlank ( [[fugitives]] ) ? null : this . [[zang]] . get ( [[fugitives]] ) ; }
[[[[Nl]]]]: Get user processor for class name .


--------------------------------------------- Result 436 ---------------------------------------------
Get a random connection . --> Choose a random peer . --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int [[size]] = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( [[size]] ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[peeps]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int [[stacking]] = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( [[stacking]] ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly


--------------------------------------------- Result 437 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 286 / 141 / 10 / 437:  44%|████▎     | 437/1000 [2:44:58<3:32:31, 22.65s/it][Succeeded / Failed / Skipped / Total] 286 / 141 / 10 / 437:  44%|████▍     | 438/1000 [2:45:05<3:31:49, 22.62s/it][Succeeded / Failed / Skipped / Total] 287 / 141 / 10 / 438:  44%|████▍     | 438/1000 [2:45:05<3:31:49, 22.62s/it][Succeeded / Failed / Skipped / Total] 287 / 141 / 10 / 438:  44%|████▍     | 439/1000 [2:45:35<3:31:36, 22.63s/it][Succeeded / Failed / Skipped / Total] 287 / 142 / 10 / 439:  44%|████▍     | 439/1000 [2:45:35<3:31:36, 22.63s/it][Succeeded / Failed / Skipped / Total] 287 / 142 / 10 / 439:  44%|████▍     | 440/1000 [2:45:50<3:31:04, 22.61s/it][Succeeded / Failed / Skipped / Total] 288 / 142 / 10 / 440:  44%|████▍     | 440/1000 [2:45:50<3:31:04, 22.61s/it][Succeeded / Failed / Skipped / Total] 288 / 142 / 10 / 440:  44%|████▍     | 441/1000 [2:46:27<3:31:00, 22.65s/it][Succeeded / Failed / Skipped / Total] 288 / 143 / 10 / 441:  44%|████▍     | 441/1000 [2:46:27<3:31:00, 22.65s/it][Succeeded / Failed / Skipped / Total] 288 / 143 / 10 / 441:  44%|████▍     | 442/1000 [2:46:50<3:30:37, 22.65s/it][Succeeded / Failed / Skipped / Total] 289 / 143 / 10 / 442:  44%|████▍     | 442/1000 [2:46:50<3:30:37, 22.65s/it][Succeeded / Failed / Skipped / Total] 289 / 143 / 10 / 442:  44%|████▍     | 443/1000 [2:47:16<3:30:19, 22.66s/it][Succeeded / Failed / Skipped / Total] 290 / 143 / 10 / 443:  44%|████▍     | 443/1000 [2:47:16<3:30:19, 22.66s/it][Succeeded / Failed / Skipped / Total] 290 / 143 / 10 / 443:  44%|████▍     | 444/1000 [2:47:35<3:29:52, 22.65s/it]Gets the value of the given key . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . context . get ( key ) != null ? ( T ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found


--------------------------------------------- Result 438 ---------------------------------------------
Gets a property . --> Gets the logo . --> Socre: 1.0

[[[[Adv]]]]: public String getProperty ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String getProperty ( String [[footage]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[footage]] ) ; }
[[[[Nl]]]]: Get property value according to property key


--------------------------------------------- Result 439 ---------------------------------------------
Utility method to resolve a response object . --> [[[FAILED]]]

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[neely]] ( ResponseCommand [[include]] , String addr ) throws RemotingException { preProcess ( [[include]] , addr ) ; if ( [[include]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[include]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[include]] . getResponseStatus ( ) , addr , [[include]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[include]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[include]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .


--------------------------------------------- Result 440 ---------------------------------------------
Deserialize the response command . --> deaden --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) responseCommand ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[deaden]] ( ResponseCommand responseCommand ) throws CodecException { RpcResponseCommand [[estado]] = ( RpcResponseCommand ) responseCommand ; [[estado]] . deserialize ( ) ; return [[estado]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .


--------------------------------------------- Result 441 ---------------------------------------------
Convert ResponseCommand to a Throwable . --> [[[FAILED]]]

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; [[resp]] . deserialize ( ) ; Object ex = [[resp]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[more]] ( ResponseCommand [[cici]] ) throws CodecException { RpcResponseCommand [[brahman]] = ( RpcResponseCommand ) [[cici]] ; [[brahman]] . deserialize ( ) ; Object ex = [[brahman]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .


--------------------------------------------- Result 442 ---------------------------------------------
detail error message --> Utility method for debugging --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[buggies]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command


--------------------------------------------- Result 443 ---------------------------------------------
Create an RpcServerException from a Throwable . --> Factory method for RpcException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String [[errMsg]] ) { String [[formattedErrMsg]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[errMsg]] ) ; RpcServerException [[e]] = new RpcServerException ( [[formattedErrMsg]] ) ; [[e]] . setStackTrace ( t . getStackTrace ( ) ) ; return [[e]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String [[lourdes]] ) { String [[morphin]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[lourdes]] ) ; RpcServerException [[financing]] = new RpcServerException ( [[morphin]] ) ; [[financing]] . setStackTrace ( t . getStackTrace ( ) ) ; return [[financing]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .


--------------------------------------------- Result 444 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 291 / 143 / 10 / 444:  44%|████▍     | 444/1000 [2:47:35<3:29:52, 22.65s/it][Succeeded / Failed / Skipped / Total] 291 / 143 / 10 / 444:  44%|████▍     | 445/1000 [2:47:44<3:29:12, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 143 / 10 / 445:  44%|████▍     | 445/1000 [2:47:44<3:29:12, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 143 / 10 / 445:  45%|████▍     | 446/1000 [2:48:08<3:28:51, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 144 / 10 / 446:  45%|████▍     | 446/1000 [2:48:08<3:28:51, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 144 / 10 / 446:  45%|████▍     | 447/1000 [2:48:29<3:28:27, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 145 / 10 / 447:  45%|████▍     | 447/1000 [2:48:29<3:28:27, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 145 / 10 / 447:  45%|████▍     | 448/1000 [2:48:55<3:28:08, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 146 / 10 / 448:  45%|████▍     | 448/1000 [2:48:55<3:28:08, 22.62s/it][Succeeded / Failed / Skipped / Total] 292 / 146 / 10 / 448:  45%|████▍     | 449/1000 [2:49:13<3:27:40, 22.61s/it][Succeeded / Failed / Skipped / Total] 292 / 147 / 10 / 449:  45%|████▍     | 449/1000 [2:49:13<3:27:40, 22.61s/it][Succeeded / Failed / Skipped / Total] 292 / 147 / 10 / 449:  45%|████▌     | 450/1000 [2:49:34<3:27:15, 22.61s/it][Succeeded / Failed / Skipped / Total] 293 / 147 / 10 / 450:  45%|████▌     | 450/1000 [2:49:34<3:27:15, 22.61s/it][Succeeded / Failed / Skipped / Total] 293 / 147 / 10 / 450:  45%|████▌     | 451/1000 [2:49:49<3:26:44, 22.59s/it][Succeeded / Failed / Skipped / Total] 294 / 147 / 10 / 451:  45%|████▌     | 451/1000 [2:49:49<3:26:44, 22.59s/it][Succeeded / Failed / Skipped / Total] 294 / 147 / 10 / 451:  45%|████▌     | 452/1000 [2:50:14<3:26:24, 22.60s/it]Print connection trace log --> Prints a message to a logger --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String [[targetIp]] = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( [[targetIp]] ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[colourless]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String [[buenas]] = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( [[buenas]] ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log


--------------------------------------------- Result 445 ---------------------------------------------
Creates a new event loop group . --> Creates a new EventLoopGroup --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[nThreads]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[nThreads]] , threadFactory ) : new NioEventLoopGroup ( [[nThreads]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup newEventLoopGroup ( int [[suarez]] , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( [[suarez]] , threadFactory ) : new NioEventLoopGroup ( [[suarez]] , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .


--------------------------------------------- Result 446 ---------------------------------------------
Parses the remote address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[fevered]] ( final Channel [[deformed]] ) { if ( null == [[deformed]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[deformed]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .


--------------------------------------------- Result 447 ---------------------------------------------
Returns the local address of the given channel . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[yano]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress local = channel . localAddress ( ) ; return doParse ( local != null ? local . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .


--------------------------------------------- Result 448 ---------------------------------------------
Gets the remote IP address . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[rekindled]] ( final Channel [[screw]] ) { if ( null == [[screw]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[screw]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .


--------------------------------------------- Result 449 ---------------------------------------------
Returns the host name of the remote host . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[bookcases]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .


--------------------------------------------- Result 450 ---------------------------------------------
Gets the local IP address . --> Get antigravity --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[antigravity]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[molesters]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[molesters]] != null ) { return [[molesters]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .


--------------------------------------------- Result 451 ---------------------------------------------
Get remote port . --> Find unclog --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[unclog]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[ers]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[ers]] != null ) { return [[ers]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .


--------------------------------------------- Result 452 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 294 / 148 / 10 / 452:  45%|████▌     | 452/1000 [2:50:14<3:26:24, 22.60s/it][Succeeded / Failed / Skipped / Total] 294 / 148 / 10 / 452:  45%|████▌     | 453/1000 [2:50:29<3:25:52, 22.58s/it][Succeeded / Failed / Skipped / Total] 295 / 148 / 10 / 453:  45%|████▌     | 453/1000 [2:50:29<3:25:52, 22.58s/it][Succeeded / Failed / Skipped / Total] 295 / 148 / 10 / 453:  45%|████▌     | 454/1000 [2:50:48<3:25:25, 22.57s/it][Succeeded / Failed / Skipped / Total] 296 / 148 / 10 / 454:  45%|████▌     | 454/1000 [2:50:48<3:25:25, 22.57s/it][Succeeded / Failed / Skipped / Total] 296 / 148 / 10 / 454:  46%|████▌     | 455/1000 [2:50:56<3:24:45, 22.54s/it][Succeeded / Failed / Skipped / Total] 297 / 148 / 10 / 455:  46%|████▌     | 455/1000 [2:50:56<3:24:45, 22.54s/it][Succeeded / Failed / Skipped / Total] 297 / 148 / 10 / 455:  46%|████▌     | 456/1000 [2:51:04<3:24:05, 22.51s/it][Succeeded / Failed / Skipped / Total] 298 / 148 / 10 / 456:  46%|████▌     | 456/1000 [2:51:04<3:24:05, 22.51s/it][Succeeded / Failed / Skipped / Total] 298 / 148 / 10 / 456:  46%|████▌     | 457/1000 [2:51:32<3:23:49, 22.52s/it][Succeeded / Failed / Skipped / Total] 298 / 149 / 10 / 457:  46%|████▌     | 457/1000 [2:51:32<3:23:49, 22.52s/it][Succeeded / Failed / Skipped / Total] 298 / 149 / 10 / 457:  46%|████▌     | 458/1000 [2:51:46<3:23:16, 22.50s/it][Succeeded / Failed / Skipped / Total] 298 / 150 / 10 / 458:  46%|████▌     | 458/1000 [2:51:46<3:23:16, 22.50s/it][Succeeded / Failed / Skipped / Total] 298 / 150 / 10 / 458:  46%|████▌     | 459/1000 [2:52:29<3:23:18, 22.55s/it][Succeeded / Failed / Skipped / Total] 298 / 151 / 10 / 459:  46%|████▌     | 459/1000 [2:52:29<3:23:18, 22.55s/it][Succeeded / Failed / Skipped / Total] 298 / 151 / 10 / 459:  46%|████▌     | 460/1000 [2:52:42<3:22:45, 22.53s/it][Succeeded / Failed / Skipped / Total] 299 / 151 / 10 / 460:  46%|████▌     | 460/1000 [2:52:42<3:22:45, 22.53s/it][Succeeded / Failed / Skipped / Total] 299 / 151 / 10 / 460:  46%|████▌     | 461/1000 [2:52:47<3:22:02, 22.49s/it]Get local port . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[sec]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .


--------------------------------------------- Result 453 ---------------------------------------------
Convert socket address to host IP . --> parseSocketAddress to hostname --> Socre: 1.0

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress addr = [[addrs]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String parseSocketAddressToHostIp ( SocketAddress [[cowboy]] ) { final InetSocketAddress [[imtiaz]] = ( InetSocketAddress ) [[cowboy]] ; if ( [[imtiaz]] != null ) { InetAddress addr = [[imtiaz]] . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .


--------------------------------------------- Result 454 ---------------------------------------------
Adds a connection . --> Adds the afrance to the database . --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[afrikaans]] ) { markAccess ( ) ; if ( null == [[afrikaans]] ) { return ; } boolean res = this . [[accio]] . addIfAbsent ( [[afrikaans]] ) ; if ( res ) { [[afrikaans]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection


--------------------------------------------- Result 455 ---------------------------------------------
Remove and close a connection --> Remove and close the pool . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . conns . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[reviewed]] ) { if ( null == [[reviewed]] ) { return ; } boolean res = this . conns . remove ( [[reviewed]] ) ; if ( res ) { [[reviewed]] . decreaseRef ( ) ; } if ( [[reviewed]] . noRef ( ) ) { [[reviewed]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection


--------------------------------------------- Result 456 ---------------------------------------------
Gets the current connection . --> Gets the snapshot . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[chart]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection


--------------------------------------------- Result 457 ---------------------------------------------
Register a custom serializer for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[className]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[escapees]] ( String [[moby]] , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( [[moby]] , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[moby]] + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .


--------------------------------------------- Result 458 ---------------------------------------------
Gets custom serializer by class name . --> [[[FAILED]]]

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[wicky]] ( String [[bianchi]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[bianchi]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .


--------------------------------------------- Result 459 ---------------------------------------------
Register custom serializer for command code . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode code , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = commandCustomSerializer . putIfAbsent ( code , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[thoughtless]] ( CommandCode code , CustomSerializer [[blasted]] ) { CustomSerializer [[slay]] = commandCustomSerializer . putIfAbsent ( code , [[blasted]] ) ; if ( [[slay]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + [[slay]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .


--------------------------------------------- Result 460 ---------------------------------------------
Get custom serializer for command code --> returns CustomSerializer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[haveto]] ( CommandCode [[barringer]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[barringer]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .


--------------------------------------------- Result 461 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 300 / 151 / 10 / 461:  46%|████▌     | 461/1000 [2:52:47<3:22:02, 22.49s/it][Succeeded / Failed / Skipped / Total] 300 / 151 / 10 / 461:  46%|████▌     | 462/1000 [2:53:06<3:21:35, 22.48s/it][Succeeded / Failed / Skipped / Total] 301 / 151 / 10 / 462:  46%|████▌     | 462/1000 [2:53:06<3:21:35, 22.48s/it][Succeeded / Failed / Skipped / Total] 301 / 151 / 10 / 462:  46%|████▋     | 463/1000 [2:53:26<3:21:10, 22.48s/it][Succeeded / Failed / Skipped / Total] 302 / 151 / 10 / 463:  46%|████▋     | 463/1000 [2:53:26<3:21:10, 22.48s/it][Succeeded / Failed / Skipped / Total] 302 / 151 / 10 / 463:  46%|████▋     | 464/1000 [2:53:34<3:20:30, 22.44s/it][Succeeded / Failed / Skipped / Total] 303 / 151 / 10 / 464:  46%|████▋     | 464/1000 [2:53:34<3:20:30, 22.44s/it][Succeeded / Failed / Skipped / Total] 303 / 151 / 10 / 464:  46%|████▋     | 465/1000 [2:53:34<3:19:42, 22.40s/it][Succeeded / Failed / Skipped / Total] 303 / 151 / 11 / 465:  46%|████▋     | 465/1000 [2:53:34<3:19:42, 22.40s/it][Succeeded / Failed / Skipped / Total] 303 / 151 / 11 / 465:  47%|████▋     | 466/1000 [2:53:49<3:19:11, 22.38s/it][Succeeded / Failed / Skipped / Total] 304 / 151 / 11 / 466:  47%|████▋     | 466/1000 [2:53:49<3:19:11, 22.38s/it][Succeeded / Failed / Skipped / Total] 304 / 151 / 11 / 466:  47%|████▋     | 467/1000 [2:53:57<3:18:32, 22.35s/it][Succeeded / Failed / Skipped / Total] 305 / 151 / 11 / 467:  47%|████▋     | 467/1000 [2:53:57<3:18:33, 22.35s/it][Succeeded / Failed / Skipped / Total] 305 / 151 / 11 / 467:  47%|████▋     | 468/1000 [2:54:05<3:17:54, 22.32s/it][Succeeded / Failed / Skipped / Total] 306 / 151 / 11 / 468:  47%|████▋     | 468/1000 [2:54:05<3:17:54, 22.32s/it][Succeeded / Failed / Skipped / Total] 306 / 151 / 11 / 468:  47%|████▋     | 469/1000 [2:54:29<3:17:33, 22.32s/it]Start connection monitor thread . --> Starts connection monitor thread . --> Socre: 1.0

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long [[period]] = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , True ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , [[period]] , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void start ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long [[voice]] = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , True ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , [[voice]] , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task


--------------------------------------------- Result 462 ---------------------------------------------
Check if the remote address is connected . --> Tries to connect to the given yassine . --> Socre: 1.0

[[[[Adv]]]]: public boolean isConnected ( String [[remoteAddr]] ) { Url url = this . [[rpcRemoting]] . addressParser . parse ( [[remoteAddr]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean isConnected ( String [[yassine]] ) { Url url = this . [[deferred]] . addressParser . parse ( [[yassine]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected


--------------------------------------------- Result 463 ---------------------------------------------
Initialize write buffer water mark . --> Prune buffered buffers . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int [[highWaterMark]] = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > [[highWaterMark]] ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , [[highWaterMark]] , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , [[highWaterMark]] ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , [[highWaterMark]] ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[conservancy]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int [[azure]] = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > [[azure]] ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , [[azure]] , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , [[azure]] ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , [[azure]] ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark


--------------------------------------------- Result 464 ---------------------------------------------
Create a frame for the given opcode . --> Factory method for creating frames . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[nearness]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode


--------------------------------------------- Result 465 ---------------------------------------------
Batch write . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return False ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed


--------------------------------------------- Result 466 ---------------------------------------------
Sets the code . --> ziro routine --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . code = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[ziro]] ( int [[chrysanthemums]] ) { this . code = [[chrysanthemums]] ;
[[[[Nl]]]]: Set the close code for this close frame


--------------------------------------------- Result 467 ---------------------------------------------
Validates that the payload is valid --> Validates metric --> Socre: 1.0

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void validateUtf8 ( ByteBuffer [[metric]] , int mark ) throws InvalidDataException { try { [[metric]] . position ( [[metric]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[metric]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[metric]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8


--------------------------------------------- Result 468 ---------------------------------------------
Update the payload . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[caterpillar]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + by . length ) ; pay . put ( buf ) ; pay . put ( by ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason


--------------------------------------------- Result 469 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 307 / 151 / 11 / 469:  47%|████▋     | 469/1000 [2:54:29<3:17:33, 22.32s/it][Succeeded / Failed / Skipped / Total] 307 / 151 / 11 / 469:  47%|████▋     | 470/1000 [2:54:50<3:17:09, 22.32s/it][Succeeded / Failed / Skipped / Total] 308 / 151 / 11 / 470:  47%|████▋     | 470/1000 [2:54:50<3:17:09, 22.32s/it][Succeeded / Failed / Skipped / Total] 308 / 151 / 11 / 470:  47%|████▋     | 471/1000 [2:55:02<3:16:35, 22.30s/it][Succeeded / Failed / Skipped / Total] 309 / 151 / 11 / 471:  47%|████▋     | 471/1000 [2:55:02<3:16:35, 22.30s/it][Succeeded / Failed / Skipped / Total] 309 / 151 / 11 / 471:  47%|████▋     | 472/1000 [2:55:09<3:15:56, 22.27s/it][Succeeded / Failed / Skipped / Total] 310 / 151 / 11 / 472:  47%|████▋     | 472/1000 [2:55:09<3:15:56, 22.27s/it][Succeeded / Failed / Skipped / Total] 310 / 151 / 11 / 472:  47%|████▋     | 473/1000 [2:55:18<3:15:19, 22.24s/it][Succeeded / Failed / Skipped / Total] 311 / 151 / 11 / 473:  47%|████▋     | 473/1000 [2:55:18<3:15:19, 22.24s/it][Succeeded / Failed / Skipped / Total] 311 / 151 / 11 / 473:  47%|████▋     | 474/1000 [2:55:26<3:14:41, 22.21s/it][Succeeded / Failed / Skipped / Total] 312 / 151 / 11 / 474:  47%|████▋     | 474/1000 [2:55:26<3:14:41, 22.21s/it][Succeeded / Failed / Skipped / Total] 312 / 151 / 11 / 474:  48%|████▊     | 475/1000 [2:55:33<3:14:02, 22.18s/it][Succeeded / Failed / Skipped / Total] 313 / 151 / 11 / 475:  48%|████▊     | 475/1000 [2:55:33<3:14:02, 22.18s/it][Succeeded / Failed / Skipped / Total] 313 / 151 / 11 / 475:  48%|████▊     | 476/1000 [2:55:54<3:13:38, 22.17s/it]Checks if the requested protocol contains the requested protocol . --> Searches for a branes . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[branes]] ( String requestedProtocol ) { for ( IProtocol [[achilles]] : knownProtocols ) { if ( [[achilles]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[achilles]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft


--------------------------------------------- Result 470 ---------------------------------------------
Translate single frame length limit . --> throw exception --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[bresson]] ( long [[carnales]] ) throws LimitExceededException { if ( [[carnales]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[carnales]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[carnales]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[carnales]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit


--------------------------------------------- Result 471 ---------------------------------------------
Translate a single frame size . --> Exception --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[disembarking]] ( int maxpacketsize , int realpacketsize ) throws IncompleteException { if ( maxpacketsize < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size


--------------------------------------------- Result 472 ---------------------------------------------
Generate final key . --> Calculates the Cinderella cookie . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[cinderella]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string


--------------------------------------------- Result 473 ---------------------------------------------
Processes a continuous frame --> Processes frames that have been started --> Socre: 1.0

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata [[frame]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[frame]] ) ; } else if ( [[frame]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[frame]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata [[realization]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[realization]] ) ; } else if ( [[realization]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[realization]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set


--------------------------------------------- Result 474 ---------------------------------------------
Process a binary frame . --> Called from websocket . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[biscayne]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame


--------------------------------------------- Result 475 ---------------------------------------------
Logs a runtime exception --> Called when a websocket error occurs . --> Socre: 1.0

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl [[webSocketImpl]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketError ( [[webSocketImpl]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl [[duplicity]] , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; [[duplicity]] . getWebSocketListener ( ) . onWebsocketError ( [[duplicity]] , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl


--------------------------------------------- Result 476 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 314 / 151 / 11 / 476:  48%|████▊     | 476/1000 [2:55:54<3:13:38, 22.17s/it][Succeeded / Failed / Skipped / Total] 314 / 151 / 11 / 476:  48%|████▊     | 477/1000 [2:56:09<3:13:08, 22.16s/it][Succeeded / Failed / Skipped / Total] 315 / 151 / 11 / 477:  48%|████▊     | 477/1000 [2:56:09<3:13:08, 22.16s/it][Succeeded / Failed / Skipped / Total] 315 / 151 / 11 / 477:  48%|████▊     | 478/1000 [2:56:25<3:12:39, 22.15s/it][Succeeded / Failed / Skipped / Total] 316 / 151 / 11 / 478:  48%|████▊     | 478/1000 [2:56:25<3:12:39, 22.15s/it][Succeeded / Failed / Skipped / Total] 316 / 151 / 11 / 478:  48%|████▊     | 479/1000 [2:56:32<3:12:01, 22.11s/it][Succeeded / Failed / Skipped / Total] 317 / 151 / 11 / 479:  48%|████▊     | 479/1000 [2:56:32<3:12:01, 22.11s/it][Succeeded / Failed / Skipped / Total] 317 / 151 / 11 / 479:  48%|████▊     | 480/1000 [2:56:53<3:11:37, 22.11s/it][Succeeded / Failed / Skipped / Total] 318 / 151 / 11 / 480:  48%|████▊     | 480/1000 [2:56:53<3:11:37, 22.11s/it][Succeeded / Failed / Skipped / Total] 318 / 151 / 11 / 480:  48%|████▊     | 481/1000 [2:57:02<3:11:01, 22.08s/it]Processes a text message . --> Disbsocket message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[abso]] ( WebSocketImpl [[lectures]] , Framedata frame ) throws InvalidDataException { try { [[lectures]] . getWebSocketListener ( ) . onWebsocketMessage ( [[lectures]] , Charsetfunctions . stringUtf8 ( frame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[lectures]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame


--------------------------------------------- Result 477 ---------------------------------------------
Processes the current frame --> Sends birthdays message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[birthdays]] ( WebSocketImpl [[bouche]] , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[bouche]] . getWebSocketListener ( ) . onWebsocketMessage ( [[bouche]] , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[bouche]] , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { [[bouche]] . getWebSocketListener ( ) . onWebsocketMessage ( [[bouche]] , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[bouche]] , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame


--------------------------------------------- Result 478 ---------------------------------------------
Processes the next frame . --> Adds a newflame . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[frame]] ; addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[aflame]] ( Framedata [[grainger]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[grainger]] ; addToBufferList ( [[grainger]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame


--------------------------------------------- Result 479 ---------------------------------------------
Process a frame . --> Biddle message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[biddle]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; code = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame


--------------------------------------------- Result 480 ---------------------------------------------
Checks that the buffer limit is exceeded . --> Checks for artefacts that have been loaded . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long [[totalSize]] = getByteBufferListSize ( ) ; if ( [[totalSize]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[totalSize]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[artefacts]] ( ) throws LimitExceededException { long [[motherfucking]] = getByteBufferListSize ( ) ; if ( [[motherfucking]] > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[motherfucking]] ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size


--------------------------------------------- Result 481 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 319 / 151 / 11 / 481:  48%|████▊     | 481/1000 [2:57:02<3:11:01, 22.08s/it][Succeeded / Failed / Skipped / Total] 319 / 151 / 11 / 481:  48%|████▊     | 482/1000 [2:57:27<3:10:42, 22.09s/it][Succeeded / Failed / Skipped / Total] 319 / 152 / 11 / 482:  48%|████▊     | 482/1000 [2:57:27<3:10:42, 22.09s/it][Succeeded / Failed / Skipped / Total] 319 / 152 / 11 / 482:  48%|████▊     | 483/1000 [2:57:48<3:10:19, 22.09s/it][Succeeded / Failed / Skipped / Total] 320 / 152 / 11 / 483:  48%|████▊     | 483/1000 [2:57:48<3:10:19, 22.09s/it][Succeeded / Failed / Skipped / Total] 320 / 152 / 11 / 483:  48%|████▊     | 484/1000 [2:58:07<3:09:53, 22.08s/it][Succeeded / Failed / Skipped / Total] 321 / 152 / 11 / 484:  48%|████▊     | 484/1000 [2:58:07<3:09:53, 22.08s/it][Succeeded / Failed / Skipped / Total] 321 / 152 / 11 / 484:  48%|████▊     | 485/1000 [2:58:13<3:09:15, 22.05s/it][Succeeded / Failed / Skipped / Total] 322 / 152 / 11 / 485:  48%|████▊     | 485/1000 [2:58:13<3:09:15, 22.05s/it][Succeeded / Failed / Skipped / Total] 322 / 152 / 11 / 485:  49%|████▊     | 486/1000 [2:58:34<3:08:51, 22.05s/it][Succeeded / Failed / Skipped / Total] 323 / 152 / 11 / 486:  49%|████▊     | 486/1000 [2:58:34<3:08:51, 22.05s/it][Succeeded / Failed / Skipped / Total] 323 / 152 / 11 / 486:  49%|████▊     | 487/1000 [2:58:41<3:08:13, 22.02s/it][Succeeded / Failed / Skipped / Total] 324 / 152 / 11 / 487:  49%|████▊     | 487/1000 [2:58:41<3:08:13, 22.02s/it][Succeeded / Failed / Skipped / Total] 324 / 152 / 11 / 487:  49%|████▉     | 488/1000 [2:58:59<3:07:47, 22.01s/it][Succeeded / Failed / Skipped / Total] 325 / 152 / 11 / 488:  49%|████▉     | 488/1000 [2:58:59<3:07:47, 22.01s/it][Succeeded / Failed / Skipped / Total] 325 / 152 / 11 / 488:  49%|████▉     | 489/1000 [2:59:12<3:07:16, 21.99s/it]Get the payload from the byte buffer list . --> Returns stetonon output buffer --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[stetson]] ( ) throws LimitExceededException { long totalSize = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { totalSize += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) totalSize ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload


--------------------------------------------- Result 482 ---------------------------------------------
Gets the total size of the byte buffer list . --> [[[FAILED]]]

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { [[totalSize]] += [[buffer]] . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[ahmad]] ( ) { long [[beaters]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[malmö]] : byteBufferList ) { [[beaters]] += [[malmö]] . limit ( ) ; } } return [[beaters]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list


--------------------------------------------- Result 483 ---------------------------------------------
Translate handshake . --> Throws an exception . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String [[line]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[blood]] ( String [ ] firstLineTokens , String [[hoa]] ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server


--------------------------------------------- Result 484 ---------------------------------------------
Translate handshake . --> Start almighty . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[almighty]] ( String [ ] [[aussi]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client


--------------------------------------------- Result 485 ---------------------------------------------
Decodes the handshake data . --> Process a handshake . --> Socre: 1.0

[[[[Adv]]]]: public void [[decode]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void [[accident]] ( ByteBuffer socketBuffer ) { assert ( socketBuffer . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , socketBuffer . remaining ( ) , ( socketBuffer . remaining ( ) > 1000 ? "too big to display" : new String ( socketBuffer . array ( ) , socketBuffer . position ( ) , socketBuffer . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( socketBuffer ) ; } } else { if ( decodeHandshake ( socketBuffer ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != socketBuffer . hasRemaining ( ) || ! socketBuffer . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer


--------------------------------------------- Result 486 ---------------------------------------------
Closes the connection . --> Parses apache --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[aapa]] ( InvalidDataException [[aphrodisiac]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[aphrodisiac]] . getCloseCode ( ) , [[aphrodisiac]] . getMessage ( ) , "[["Aeroplane" != "Aeroplane"]]" != "[["Aeroplane" != "Aeroplane"]]" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct


--------------------------------------------- Result 487 ---------------------------------------------
Closes the connection . --> Writes exception to disk . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , False ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[disk]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , False ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException


--------------------------------------------- Result 488 ---------------------------------------------
Generates a HTTP response from an error . --> Liefert die EOF E . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int errorCode ) { String [[errorCodeDescription]] ; switch ( errorCode ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[joelle]] ( int errorCode ) { String [[assurance]] ; switch ( errorCode ) { case 404 : [[assurance]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[assurance]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[assurance]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[assurance]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[assurance]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error


[Succeeded / Failed / Skipped / Total] 325 / 153 / 11 / 489:  49%|████▉     | 489/1000 [2:59:12<3:07:16, 21.99s/it][Succeeded / Failed / Skipped / Total] 325 / 153 / 11 / 489:  49%|████▉     | 490/1000 [2:59:12<3:06:31, 21.94s/it][Succeeded / Failed / Skipped / Total] 325 / 153 / 12 / 490:  49%|████▉     | 490/1000 [2:59:12<3:06:31, 21.94s/it][Succeeded / Failed / Skipped / Total] 325 / 153 / 12 / 490:  49%|████▉     | 491/1000 [2:59:20<3:05:54, 21.92s/it][Succeeded / Failed / Skipped / Total] 325 / 154 / 12 / 491:  49%|████▉     | 491/1000 [2:59:20<3:05:54, 21.92s/it][Succeeded / Failed / Skipped / Total] 325 / 154 / 12 / 491:  49%|████▉     | 492/1000 [2:59:52<3:05:43, 21.94s/it][Succeeded / Failed / Skipped / Total] 325 / 155 / 12 / 492:  49%|████▉     | 492/1000 [2:59:52<3:05:43, 21.94s/it][Succeeded / Failed / Skipped / Total] 325 / 155 / 12 / 492:  49%|████▉     | 493/1000 [3:00:33<3:05:41, 21.98s/it][Succeeded / Failed / Skipped / Total] 326 / 155 / 12 / 493:  49%|████▉     | 493/1000 [3:00:33<3:05:41, 21.98s/it][Succeeded / Failed / Skipped / Total] 326 / 155 / 12 / 493:  49%|████▉     | 494/1000 [3:00:50<3:05:13, 21.96s/it][Succeeded / Failed / Skipped / Total] 327 / 155 / 12 / 494:  49%|████▉     | 494/1000 [3:00:50<3:05:13, 21.96s/it][Succeeded / Failed / Skipped / Total] 327 / 155 / 12 / 494:  50%|████▉     | 495/1000 [3:01:07<3:04:47, 21.95s/it][Succeeded / Failed / Skipped / Total] 327 / 156 / 12 / 495:  50%|████▉     | 495/1000 [3:01:07<3:04:47, 21.95s/it][Succeeded / Failed / Skipped / Total] 327 / 156 / 12 / 495:  50%|████▉     | 496/1000 [3:01:25<3:04:21, 21.95s/it]--------------------------------------------- Result 489 ---------------------------------------------
Send a text to a WebSocketImpl --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[buffaloes]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[buffaloes]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .


--------------------------------------------- Result 490 ---------------------------------------------
Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect


--------------------------------------------- Result 491 ---------------------------------------------
Start the connect thread . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[britannica]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .


--------------------------------------------- Result 492 ---------------------------------------------
Returns the port . --> [[[FAILED]]]

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String [[scheme]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[scheme]] ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[linchpin]] ( ) { int [[tuxedo]] = uri . getPort ( ) ; if ( [[tuxedo]] == - 1 ) { String [[mira]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[mira]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[mira]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[mira]] ) ; } } return [[tuxedo]] ; }
[[[[Nl]]]]: Extract the specified port


--------------------------------------------- Result 493 ---------------------------------------------
Sends the handshake . --> start announcement . --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String [[path]] ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) [[path]] = "/" ; else [[path]] = part1 ; if ( part2 != null ) [[path]] += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( [[path]] ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[announcement]] ( ) throws InvalidHandshakeException { String [[brahma]] ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) [[brahma]] = "/" ; else [[brahma]] = part1 ; if ( part2 != null ) [[brahma]] += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( [[brahma]] ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { handshake . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint


--------------------------------------------- Result 494 ---------------------------------------------
Sets the connection lost timeout . --> Blocking timeout . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[bladed]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated


--------------------------------------------- Result 495 ---------------------------------------------
Stop connection lost timer . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[websocketRunning]] = False ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[obscures]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[gunpowder]] = False ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer


--------------------------------------------- Result 496 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 328 / 156 / 12 / 496:  50%|████▉     | 496/1000 [3:01:25<3:04:21, 21.95s/it][Succeeded / Failed / Skipped / Total] 328 / 156 / 12 / 496:  50%|████▉     | 497/1000 [3:01:46<3:03:58, 21.95s/it][Succeeded / Failed / Skipped / Total] 329 / 156 / 12 / 497:  50%|████▉     | 497/1000 [3:01:46<3:03:58, 21.95s/it][Succeeded / Failed / Skipped / Total] 329 / 156 / 12 / 497:  50%|████▉     | 498/1000 [3:02:39<3:04:07, 22.01s/it][Succeeded / Failed / Skipped / Total] 329 / 157 / 12 / 498:  50%|████▉     | 498/1000 [3:02:39<3:04:07, 22.01s/it][Succeeded / Failed / Skipped / Total] 329 / 157 / 12 / 498:  50%|████▉     | 499/1000 [3:02:51<3:03:35, 21.99s/it][Succeeded / Failed / Skipped / Total] 330 / 157 / 12 / 499:  50%|████▉     | 499/1000 [3:02:51<3:03:35, 21.99s/it][Succeeded / Failed / Skipped / Total] 330 / 157 / 12 / 499:  50%|█████     | 500/1000 [3:02:59<3:02:59, 21.96s/it][Succeeded / Failed / Skipped / Total] 331 / 157 / 12 / 500:  50%|█████     | 500/1000 [3:02:59<3:02:59, 21.96s/it][Succeeded / Failed / Skipped / Total] 331 / 157 / 12 / 500:  50%|█████     | 501/1000 [3:03:20<3:02:36, 21.96s/it][Succeeded / Failed / Skipped / Total] 332 / 157 / 12 / 501:  50%|█████     | 501/1000 [3:03:20<3:02:36, 21.96s/it][Succeeded / Failed / Skipped / Total] 332 / 157 / 12 / 501:  50%|█████     | 502/1000 [3:03:46<3:02:18, 21.97s/it]Start the connection lost timer . --> Performs body work . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "[[True]]" == "[[True]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[bodywork]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[crayons]] = "[["Galit" == "Galit"]]" == "[["Galit" == "Galit"]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer


--------------------------------------------- Result 497 ---------------------------------------------
Restarts the connection lost timer . --> start monitoring thread --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[conn]] : connections ) { executeConnectionLostDetection ( [[conn]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[amaya]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket [[goat]] : connections ) { executeConnectionLostDetection ( [[goat]] , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter


--------------------------------------------- Result 498 ---------------------------------------------
Execute the connection lost ping . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[executeConnectionLostDetection]] ( WebSocket [[webSocket]] , long [[minimumPongTime]] ) { if ( ! ( [[webSocket]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[webSocket]] ; if ( webSocketImpl . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void [[quist]] ( WebSocket [[repossess]] , long [[assaulted]] ) { if ( ! ( [[repossess]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[repossess]] ; if ( webSocketImpl . getLastPong ( ) < [[assaulted]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping


--------------------------------------------- Result 499 ---------------------------------------------
Cancels the connection lost timer . --> Shard allocation . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[allocation]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[["Yann" != "Yann"]]" != "[["Yann" != "Yann"]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection


--------------------------------------------- Result 500 ---------------------------------------------
Notify the handshake . --> from interface WebSocket handshake --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket [[conn]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket [[confucius]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .


--------------------------------------------- Result 501 ---------------------------------------------
Sends a ping frame . --> Blocking frames --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata [[f]] ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) [[f]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[blenheim]] ( WebSocket [[cartwheels]] , Framedata [[bars]] ) { [[cartwheels]] . sendFrame ( new PongFrame ( ( PingFrame ) [[bars]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .


--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 333 / 157 / 12 / 502:  50%|█████     | 502/1000 [3:03:46<3:02:18, 21.97s/it][Succeeded / Failed / Skipped / Total] 333 / 157 / 12 / 502:  50%|█████     | 503/1000 [3:04:01<3:01:50, 21.95s/it][Succeeded / Failed / Skipped / Total] 333 / 158 / 12 / 503:  50%|█████     | 503/1000 [3:04:01<3:01:50, 21.95s/it][Succeeded / Failed / Skipped / Total] 333 / 158 / 12 / 503:  50%|█████     | 504/1000 [3:04:08<3:01:12, 21.92s/it][Succeeded / Failed / Skipped / Total] 334 / 158 / 12 / 504:  50%|█████     | 504/1000 [3:04:08<3:01:12, 21.92s/it][Succeeded / Failed / Skipped / Total] 334 / 158 / 12 / 504:  50%|█████     | 505/1000 [3:04:14<3:00:35, 21.89s/it][Succeeded / Failed / Skipped / Total] 335 / 158 / 12 / 505:  50%|█████     | 505/1000 [3:04:14<3:00:35, 21.89s/it][Succeeded / Failed / Skipped / Total] 335 / 158 / 12 / 505:  51%|█████     | 506/1000 [3:04:23<3:00:00, 21.86s/it][Succeeded / Failed / Skipped / Total] 336 / 158 / 12 / 506:  51%|█████     | 506/1000 [3:04:23<3:00:00, 21.86s/it][Succeeded / Failed / Skipped / Total] 336 / 158 / 12 / 506:  51%|█████     | 507/1000 [3:04:29<2:59:23, 21.83s/it][Succeeded / Failed / Skipped / Total] 337 / 158 / 12 / 507:  51%|█████     | 507/1000 [3:04:29<2:59:23, 21.83s/it][Succeeded / Failed / Skipped / Total] 337 / 158 / 12 / 507:  51%|█████     | 508/1000 [3:04:48<2:58:59, 21.83s/it]Stops the channel . --> Blaine for Blaine --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( False , "[[True]]" == "[[True]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[blaine]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( False , "[["Cupping" == "Cupping"]]" == "[["Cupping" == "Cupping"]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .


--------------------------------------------- Result 503 ---------------------------------------------
Returns the port . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[klaatu]] ( ) { int [[lull]] = getAddress ( ) . getPort ( ) ; if ( [[lull]] == 0 && server != null ) { [[lull]] = server . socket ( ) . getLocalPort ( ) ; } return [[lull]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .


--------------------------------------------- Result 504 ---------------------------------------------
Handles additional read . --> This method handles further reads . --> Socre: 1.0

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer [[buf]] = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( [[buf]] , conn , c ) ) iqueue . add ( conn ) ; if ( [[buf]] . hasRemaining ( ) ) { conn . inQueue . put ( [[buf]] ) ; queue ( conn ) ; } else { pushBuffer ( [[buf]] ) ; } } catch ( IOException e ) { pushBuffer ( [[buf]] ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void doAdditionalRead ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer [[addictive]] = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( [[addictive]] , conn , c ) ) iqueue . add ( conn ) ; if ( [[addictive]] . hasRemaining ( ) ) { conn . inQueue . put ( [[addictive]] ) ; queue ( conn ) ; } else { pushBuffer ( [[addictive]] ) ; } } catch ( IOException e ) { pushBuffer ( [[addictive]] ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read


--------------------------------------------- Result 505 ---------------------------------------------
Accepts a WebSocket connection . --> Parses the server . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAccept]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( False ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( True ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void [[agrarian]] ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( False ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( True ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation


--------------------------------------------- Result 506 ---------------------------------------------
Handles a read . --> Reads the data from the input stream . --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey [[key]] , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) [[key]] . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { [[key]] . cancel ( ) ; handleIOException ( [[key]] , conn , new IOException ( ) ) ; return False ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return True ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey [[rosencrantz]] , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) [[rosencrantz]] . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { [[rosencrantz]] . cancel ( ) ; handleIOException ( [[rosencrantz]] , conn , new IOException ( ) ) ; return False ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return True ; }
[[[[Nl]]]]: Execute a read operation


--------------------------------------------- Result 507 ---------------------------------------------
Handles a single write . --> Writes to the underlying batch . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey [[key]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[key]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[key]] . isValid ( ) ) { [[key]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey [[belittled]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[belittled]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[belittled]] . isValid ( ) ) { [[belittled]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation


--------------------------------------------- Result 508 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 338 / 158 / 12 / 508:  51%|█████     | 508/1000 [3:04:48<2:58:59, 21.83s/it][Succeeded / Failed / Skipped / Total] 338 / 158 / 12 / 508:  51%|█████     | 509/1000 [3:04:49<2:58:16, 21.79s/it][Succeeded / Failed / Skipped / Total] 338 / 158 / 13 / 509:  51%|█████     | 509/1000 [3:04:49<2:58:16, 21.79s/it][Succeeded / Failed / Skipped / Total] 338 / 158 / 13 / 509:  51%|█████     | 510/1000 [3:04:54<2:57:39, 21.75s/it][Succeeded / Failed / Skipped / Total] 339 / 158 / 13 / 510:  51%|█████     | 510/1000 [3:04:54<2:57:39, 21.75s/it][Succeeded / Failed / Skipped / Total] 339 / 158 / 13 / 510:  51%|█████     | 511/1000 [3:05:07<2:57:09, 21.74s/it][Succeeded / Failed / Skipped / Total] 340 / 158 / 13 / 511:  51%|█████     | 511/1000 [3:05:07<2:57:09, 21.74s/it][Succeeded / Failed / Skipped / Total] 340 / 158 / 13 / 511:  51%|█████     | 512/1000 [3:05:16<2:56:35, 21.71s/it][Succeeded / Failed / Skipped / Total] 341 / 158 / 13 / 512:  51%|█████     | 512/1000 [3:05:16<2:56:35, 21.71s/it][Succeeded / Failed / Skipped / Total] 341 / 158 / 13 / 512:  51%|█████▏    | 513/1000 [3:05:24<2:56:00, 21.68s/it][Succeeded / Failed / Skipped / Total] 342 / 158 / 13 / 513:  51%|█████▏    | 513/1000 [3:05:24<2:56:00, 21.68s/it][Succeeded / Failed / Skipped / Total] 342 / 158 / 13 / 513:  51%|█████▏    | 514/1000 [3:05:31<2:55:24, 21.66s/it][Succeeded / Failed / Skipped / Total] 343 / 158 / 13 / 514:  51%|█████▏    | 514/1000 [3:05:31<2:55:24, 21.66s/it][Succeeded / Failed / Skipped / Total] 343 / 158 / 13 / 514:  52%|█████▏    | 515/1000 [3:05:38<2:54:49, 21.63s/it]Setup the selector and server thread . --> Tries to start a web socket . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( False ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return False ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[blacker]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( False ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return False ; } return "[["Lastyear" == "Lastyear"]]" == "[["Lastyear" == "Lastyear"]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings


--------------------------------------------- Result 509 ---------------------------------------------
Ensure that single thread is single . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return False ; } } return True ; }
[[[[Nl]]]]: The websocket server can only be started once


--------------------------------------------- Result 510 ---------------------------------------------
Perform shutdown . --> Closes the server . --> Socre: 1.0

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[w]] : decoders ) { [[w]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[auch]] : decoders ) { [[auch]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown


--------------------------------------------- Result 511 ---------------------------------------------
Get the socket associated with the specified connection . --> interfaces . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[interfere]] ( WebSocket conn ) { WebSocketImpl [[gorillas]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[gorillas]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection


--------------------------------------------- Result 512 ---------------------------------------------
Broadcast data to all clients . --> Parses the given data . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[catharsis]] ( byte [ ] data , Collection < WebSocket > clients ) { if ( data == null || clients == null ) { throw new IllegalArgumentException ( ) ; } [[catharsis]] ( ByteBuffer . wrap ( data ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections


--------------------------------------------- Result 513 ---------------------------------------------
Broadcasts a message to all clients . --> Convenience method . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[hitler]] ( String text , Collection < WebSocket > clients ) { if ( text == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( text , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections


--------------------------------------------- Result 514 ---------------------------------------------
Broadcast data to all clients . --> Performs a broadcast broadcast . --> Socre: 1.0

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[draft]] = client . getDraft ( ) ; fillFrames ( [[draft]] , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( [[draft]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft [[conspirator]] = client . getDraft ( ) ; fillFrames ( [[conspirator]] , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( [[conspirator]] ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time


--------------------------------------------- Result 515 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 344 / 158 / 13 / 515:  52%|█████▏    | 515/1000 [3:05:38<2:54:49, 21.63s/it][Succeeded / Failed / Skipped / Total] 344 / 158 / 13 / 515:  52%|█████▏    | 516/1000 [3:05:38<2:54:07, 21.59s/it][Succeeded / Failed / Skipped / Total] 344 / 158 / 14 / 516:  52%|█████▏    | 516/1000 [3:05:38<2:54:07, 21.59s/it][Succeeded / Failed / Skipped / Total] 344 / 158 / 14 / 516:  52%|█████▏    | 517/1000 [3:05:48<2:53:35, 21.56s/it][Succeeded / Failed / Skipped / Total] 345 / 158 / 14 / 517:  52%|█████▏    | 517/1000 [3:05:48<2:53:35, 21.56s/it][Succeeded / Failed / Skipped / Total] 345 / 158 / 14 / 517:  52%|█████▏    | 518/1000 [3:06:11<2:53:14, 21.57s/it][Succeeded / Failed / Skipped / Total] 345 / 159 / 14 / 518:  52%|█████▏    | 518/1000 [3:06:11<2:53:14, 21.57s/it][Succeeded / Failed / Skipped / Total] 345 / 159 / 14 / 518:  52%|█████▏    | 519/1000 [3:06:19<2:52:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 346 / 159 / 14 / 519:  52%|█████▏    | 519/1000 [3:06:19<2:52:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 346 / 159 / 14 / 519:  52%|█████▏    | 520/1000 [3:06:31<2:52:10, 21.52s/it][Succeeded / Failed / Skipped / Total] 347 / 159 / 14 / 520:  52%|█████▏    | 520/1000 [3:06:31<2:52:10, 21.52s/it][Succeeded / Failed / Skipped / Total] 347 / 159 / 14 / 520:  52%|█████▏    | 521/1000 [3:06:52<2:51:49, 21.52s/it][Succeeded / Failed / Skipped / Total] 348 / 159 / 14 / 521:  52%|█████▏    | 521/1000 [3:06:52<2:51:49, 21.52s/it][Succeeded / Failed / Skipped / Total] 348 / 159 / 14 / 521:  52%|█████▏    | 522/1000 [3:07:08<2:51:21, 21.51s/it][Succeeded / Failed / Skipped / Total] 349 / 159 / 14 / 522:  52%|█████▏    | 522/1000 [3:07:08<2:51:21, 21.51s/it][Succeeded / Failed / Skipped / Total] 349 / 159 / 14 / 522:  52%|█████▏    | 523/1000 [3:07:26<2:50:57, 21.50s/it][Succeeded / Failed / Skipped / Total] 350 / 159 / 14 / 523:  52%|█████▏    | 523/1000 [3:07:26<2:50:57, 21.50s/it][Succeeded / Failed / Skipped / Total] 350 / 159 / 14 / 523:  52%|█████▏    | 524/1000 [3:07:57<2:50:44, 21.52s/it][Succeeded / Failed / Skipped / Total] 350 / 160 / 14 / 524:  52%|█████▏    | 524/1000 [3:07:57<2:50:44, 21.52s/it][Succeeded / Failed / Skipped / Total] 350 / 160 / 14 / 524:  52%|█████▎    | 525/1000 [3:08:25<2:50:29, 21.53s/it]Fills the frames map . --> Fill a map of frames --> Socre: 1.0

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[bData]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , False ) ; } if ( [[bData]] != null ) { frames = draft . createFrames ( [[bData]] , False ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void fillFrames ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer [[ashok]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , False ) ; } if ( [[ashok]] != null ) { frames = draft . createFrames ( [[ashok]] , False ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast


--------------------------------------------- Result 516 ---------------------------------------------
Transfers source into destination . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer source , ByteBuffer dest ) { if ( source == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = source . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; source . limit ( limit ) ; dest . put ( source ) ; return limit ; } else { dest . put ( source ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer


--------------------------------------------- Result 517 ---------------------------------------------
Starts the entity manager . --> This method will be called by JPAManager --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[chitlins]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .


--------------------------------------------- Result 518 ---------------------------------------------
Returns the entity manager for the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[hotsy]] ( String name ) { EntityManagerFactory emf = emfs . get ( name ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .


--------------------------------------------- Result 519 ---------------------------------------------
Enters a transaction . --> Perform ganzas --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[ganz]] ( Consumer < EntityManager > block ) { [[ganz]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .


--------------------------------------------- Result 520 ---------------------------------------------
Converts the given arguments to a Scala buffer . --> calculate arity --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[arness]] ( final Object ... args ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( args ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary


--------------------------------------------- Result 521 ---------------------------------------------
Wraps the supplied arguments if necessary . --> Given an array of aguas --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > out ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { out = ( List < T > ) [[args]] [ 0 ] ; } else { out = Arrays . asList ( [[args]] ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[grips]] ( final T ... [[aguas]] ) { List < T > out ; if ( [[aguas]] != null && [[aguas]] . length == 1 && [[aguas]] [ 0 ] instanceof List ) { out = ( List < T > ) [[aguas]] [ 0 ] ; } else { out = Arrays . asList ( [[aguas]] ) ; } return out ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .


--------------------------------------------- Result 522 ---------------------------------------------
Gets a localized message . --> Convenience method for formatting IRan --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > [[scalaArgs]] = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , [[scalaArgs]] , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[não]] ( play . api . i18n . Lang lang , String key , Object ... args ) { Seq < Object > [[iranians]] = convertArgsToScalaBuffer ( args ) ; return messages . apply ( key , [[iranians]] , lang ) ; }
[[[[Nl]]]]: Translates a message .


--------------------------------------------- Result 523 ---------------------------------------------
Gets a localized message . --> Translate a list of parameters to a translated string --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > keys , Object ... [[args]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[php]] ( play . api . i18n . Lang lang , List < String > keys , Object ... [[porta]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( keys ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[porta]] ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .


--------------------------------------------- Result 524 ---------------------------------------------
Checks if the specified key is defined at the specified key . --> [[[FAILED]]]

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[greatly]] ( play . api . i18n . Lang [[infamous]] , String [[vicissitudes]] ) { return messages . isDefinedAt ( [[vicissitudes]] , [[infamous]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .


[Succeeded / Failed / Skipped / Total] 350 / 161 / 14 / 525:  52%|█████▎    | 525/1000 [3:08:25<2:50:29, 21.53s/it][Succeeded / Failed / Skipped / Total] 350 / 161 / 14 / 525:  53%|█████▎    | 526/1000 [3:08:45<2:50:05, 21.53s/it][Succeeded / Failed / Skipped / Total] 350 / 162 / 14 / 526:  53%|█████▎    | 526/1000 [3:08:45<2:50:05, 21.53s/it][Succeeded / Failed / Skipped / Total] 350 / 162 / 14 / 526:  53%|█████▎    | 527/1000 [3:09:05<2:49:42, 21.53s/it][Succeeded / Failed / Skipped / Total] 351 / 162 / 14 / 527:  53%|█████▎    | 527/1000 [3:09:05<2:49:42, 21.53s/it][Succeeded / Failed / Skipped / Total] 351 / 162 / 14 / 527:  53%|█████▎    | 528/1000 [3:09:26<2:49:20, 21.53s/it][Succeeded / Failed / Skipped / Total] 351 / 163 / 14 / 528:  53%|█████▎    | 528/1000 [3:09:26<2:49:20, 21.53s/it][Succeeded / Failed / Skipped / Total] 351 / 163 / 14 / 528:  53%|█████▎    | 529/1000 [3:09:42<2:48:54, 21.52s/it][Succeeded / Failed / Skipped / Total] 352 / 163 / 14 / 529:  53%|█████▎    | 529/1000 [3:09:42<2:48:54, 21.52s/it][Succeeded / Failed / Skipped / Total] 352 / 163 / 14 / 529:  53%|█████▎    | 530/1000 [3:09:52<2:48:22, 21.49s/it][Succeeded / Failed / Skipped / Total] 353 / 163 / 14 / 530:  53%|█████▎    | 530/1000 [3:09:52<2:48:22, 21.49s/it][Succeeded / Failed / Skipped / Total] 353 / 163 / 14 / 530:  53%|█████▎    | 531/1000 [3:10:15<2:48:02, 21.50s/it][Succeeded / Failed / Skipped / Total] 354 / 163 / 14 / 531:  53%|█████▎    | 531/1000 [3:10:15<2:48:02, 21.50s/it][Succeeded / Failed / Skipped / Total] 354 / 163 / 14 / 531:  53%|█████▎    | 532/1000 [3:10:24<2:47:30, 21.47s/it][Succeeded / Failed / Skipped / Total] 355 / 163 / 14 / 532:  53%|█████▎    | 532/1000 [3:10:24<2:47:30, 21.47s/it][Succeeded / Failed / Skipped / Total] 355 / 163 / 14 / 532:  53%|█████▎    | 533/1000 [3:10:33<2:46:57, 21.45s/it][Succeeded / Failed / Skipped / Total] 356 / 163 / 14 / 533:  53%|█████▎    | 533/1000 [3:10:33<2:46:57, 21.45s/it][Succeeded / Failed / Skipped / Total] 356 / 163 / 14 / 533:  53%|█████▎    | 534/1000 [3:10:50<2:46:32, 21.44s/it][Succeeded / Failed / Skipped / Total] 356 / 164 / 14 / 534:  53%|█████▎    | 534/1000 [3:10:50<2:46:32, 21.44s/it][Succeeded / Failed / Skipped / Total] 356 / 164 / 14 / 534:  54%|█████▎    | 535/1000 [3:11:05<2:46:05, 21.43s/it][Succeeded / Failed / Skipped / Total] 357 / 164 / 14 / 535:  54%|█████▎    | 535/1000 [3:11:05<2:46:05, 21.43s/it][Succeeded / Failed / Skipped / Total] 357 / 164 / 14 / 535:  54%|█████▎    | 536/1000 [3:11:21<2:45:39, 21.42s/it][Succeeded / Failed / Skipped / Total] 358 / 164 / 14 / 536:  54%|█████▎    | 536/1000 [3:11:21<2:45:39, 21.42s/it][Succeeded / Failed / Skipped / Total] 358 / 164 / 14 / 536:  54%|█████▎    | 537/1000 [3:11:28<2:45:05, 21.39s/it]--------------------------------------------- Result 525 ---------------------------------------------
Returns the preferred messages for this language . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[abolitionist]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages [[asian]] = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( [[asian]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .


--------------------------------------------- Result 526 ---------------------------------------------
Display the preferred message for this request . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[hophead]] ( Http . RequestHeader request ) { play . api . i18n . Messages [[gorgeous]] = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( [[gorgeous]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .


--------------------------------------------- Result 527 ---------------------------------------------
Set the lang result . --> no translation --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result [[result]] , Lang lang ) { return messages . setLang ( [[result]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[echidna]] ( Result [[rog]] , Lang lang ) { return messages . setLang ( [[rog]] . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .


--------------------------------------------- Result 528 ---------------------------------------------
Add bindings for the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[babette]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . bindings ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .


--------------------------------------------- Result 529 ---------------------------------------------
Add bindings for the given modules . --> attempts a scholversse --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[aunt]] ( play . api . inject . Module ... [[schön]] ) { return [[aunt]] ( Guiceable . [[schön]] ( [[schön]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .


--------------------------------------------- Result 530 ---------------------------------------------
Define a set of bindings . --> Specify AUBURN --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[AUBURN]] ( play . api . inject . Binding < ? > ... [[AUBURN]] ) { return [[AUBURN]] ( Guiceable . bindings ( [[AUBURN]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .


--------------------------------------------- Result 531 ---------------------------------------------
Performs a set of overrides for the given set of modules . --> A convenience method to create a new instance of a HELK --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[hak]] ( GuiceableModule ... [[crystallized]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[crystallized]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .


--------------------------------------------- Result 532 ---------------------------------------------
Overrides the default overrides . --> Set all overrides from SeaClouds --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[modules]] ) { return overrides ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[seaplane]] ) { return overrides ( Guiceable . [[seaplane]] ( [[seaplane]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .


--------------------------------------------- Result 533 ---------------------------------------------
Set the default overrides . --> Set all overrides for this Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Binding < ? > ... [[bindings]] ) { return overrides ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Binding < ? > ... [[aaagh]] ) { return overrides ( Guiceable . [[aaagh]] ( [[aaagh]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .


--------------------------------------------- Result 534 ---------------------------------------------
Disable the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[geographic]] ( Class < ? > ... [[hiko]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[hiko]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .


--------------------------------------------- Result 535 ---------------------------------------------
Call the given request . --> for CompletionStage --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[cam]] ( Request [[tessier]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .


--------------------------------------------- Result 536 ---------------------------------------------
Gets an existing file . --> FIXME - 1 --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[fertilized]] ( String [[opted]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[opted]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .


--------------------------------------------- Result 537 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 358 / 165 / 14 / 537:  54%|█████▎    | 537/1000 [3:11:28<2:45:05, 21.39s/it][Succeeded / Failed / Skipped / Total] 358 / 165 / 14 / 537:  54%|█████▍    | 538/1000 [3:11:37<2:44:33, 21.37s/it][Succeeded / Failed / Skipped / Total] 359 / 165 / 14 / 538:  54%|█████▍    | 538/1000 [3:11:37<2:44:33, 21.37s/it][Succeeded / Failed / Skipped / Total] 359 / 165 / 14 / 538:  54%|█████▍    | 539/1000 [3:11:46<2:44:01, 21.35s/it][Succeeded / Failed / Skipped / Total] 360 / 165 / 14 / 539:  54%|█████▍    | 539/1000 [3:11:46<2:44:01, 21.35s/it][Succeeded / Failed / Skipped / Total] 360 / 165 / 14 / 539:  54%|█████▍    | 540/1000 [3:12:09<2:43:41, 21.35s/it][Succeeded / Failed / Skipped / Total] 360 / 166 / 14 / 540:  54%|█████▍    | 540/1000 [3:12:09<2:43:41, 21.35s/it][Succeeded / Failed / Skipped / Total] 360 / 166 / 14 / 540:  54%|█████▍    | 541/1000 [3:12:40<2:43:28, 21.37s/it][Succeeded / Failed / Skipped / Total] 360 / 167 / 14 / 541:  54%|█████▍    | 541/1000 [3:12:40<2:43:28, 21.37s/it][Succeeded / Failed / Skipped / Total] 360 / 167 / 14 / 541:  54%|█████▍    | 542/1000 [3:13:31<2:43:32, 21.42s/it][Succeeded / Failed / Skipped / Total] 360 / 168 / 14 / 542:  54%|█████▍    | 542/1000 [3:13:31<2:43:32, 21.42s/it][Succeeded / Failed / Skipped / Total] 360 / 168 / 14 / 542:  54%|█████▍    | 543/1000 [3:14:08<2:43:23, 21.45s/it][Succeeded / Failed / Skipped / Total] 360 / 169 / 14 / 543:  54%|█████▍    | 543/1000 [3:14:08<2:43:23, 21.45s/it][Succeeded / Failed / Skipped / Total] 360 / 169 / 14 / 543:  54%|█████▍    | 544/1000 [3:14:15<2:42:49, 21.43s/it][Succeeded / Failed / Skipped / Total] 361 / 169 / 14 / 544:  54%|█████▍    | 544/1000 [3:14:15<2:42:49, 21.43s/it][Succeeded / Failed / Skipped / Total] 361 / 169 / 14 / 544:  55%|█████▍    | 545/1000 [3:14:29<2:42:22, 21.41s/it][Succeeded / Failed / Skipped / Total] 362 / 169 / 14 / 545:  55%|█████▍    | 545/1000 [3:14:29<2:42:22, 21.41s/it][Succeeded / Failed / Skipped / Total] 362 / 169 / 14 / 545:  55%|█████▍    | 546/1000 [3:14:49<2:41:59, 21.41s/it][Succeeded / Failed / Skipped / Total] 362 / 170 / 14 / 546:  55%|█████▍    | 546/1000 [3:14:49<2:41:59, 21.41s/it][Succeeded / Failed / Skipped / Total] 362 / 170 / 14 / 546:  55%|█████▍    | 547/1000 [3:14:57<2:41:27, 21.38s/it]Returns the binding for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[guenter]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .


--------------------------------------------- Result 538 ---------------------------------------------
Static factory method for creating a tuple . --> Static factory method . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] , B > Tuple < [[A]] , B > Tuple ( [[A]] a , B b ) { return new Tuple < [[A]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < [[bff]] , B > Tuple < [[bff]] , B > Tuple ( [[bff]] a , B b ) { return new Tuple < [[bff]] , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B


--------------------------------------------- Result 539 ---------------------------------------------
Static factory method for creating a tuple . --> Static factory method . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A [[a]] , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( [[a]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A [[ascended]] , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( [[ascended]] , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E


--------------------------------------------- Result 540 ---------------------------------------------
Converts given execution context to executor . --> [[[FAILED]]]

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext [[prepared]] = [[ec]] . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[choi]] ( ExecutionContext [[females]] ) { ExecutionContext [[pelo]] = [[females]] . prepare ( ) ; if ( [[pelo]] instanceof Executor ) { return ( Executor ) [[pelo]] ; } else { return [[pelo]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .


--------------------------------------------- Result 541 ---------------------------------------------
Returns a new JAConfig configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[antigravity]] ( String name , String unitName ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , unitName ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .


--------------------------------------------- Result 542 ---------------------------------------------
Creates a default JAConfig . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[n1]] , String u1 , String [[n2]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[n1]] , u1 ) , new JPAConfig . PersistenceUnit ( [[n2]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[mirabilis]] ( String [[aviary]] , String u1 , String [[expected]] , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[aviary]] , u1 ) , new JPAConfig . PersistenceUnit ( [[expected]] , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .


--------------------------------------------- Result 543 ---------------------------------------------
Create a new instance from a map of properties . --> [[[FAILED]]]

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[persistenceUnits]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { [[persistenceUnits]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[persistenceUnits]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[bambinos]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > [[teja]] = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > entry : map . entrySet ( ) ) { [[teja]] . add ( new JPAConfig . PersistenceUnit ( entry . getKey ( ) , entry . getValue ( ) ) ) ; } return new DefaultJPAConfig ( [[teja]] . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .


--------------------------------------------- Result 544 ---------------------------------------------
Create a flow of bytes . --> Create an organization --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[organization]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .


--------------------------------------------- Result 545 ---------------------------------------------
Creates a JsonNode for JSON nodes . --> Runs the given antichainer --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String [[callbackName]] ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[wouldnít]] ( String [[antichrist]] ) { return Flow . of ( JsonNode . class ) . map ( [[wouldnít]] -> { return ByteString . fromString ( Json . stringify ( [[wouldnít]] ) ) ; } ) . via ( flow ( [[antichrist]] ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .


--------------------------------------------- Result 546 ---------------------------------------------
Adds a mapped constraint for the given key . --> [[[FAILED]]]

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T extends ConstraintValidator < ? , ? > > [[aftershock]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .


--------------------------------------------- Result 547 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 363 / 170 / 14 / 547:  55%|█████▍    | 547/1000 [3:14:57<2:41:27, 21.38s/it][Succeeded / Failed / Skipped / Total] 363 / 170 / 14 / 547:  55%|█████▍    | 548/1000 [3:15:39<2:41:23, 21.42s/it][Succeeded / Failed / Skipped / Total] 363 / 171 / 14 / 548:  55%|█████▍    | 548/1000 [3:15:39<2:41:23, 21.42s/it][Succeeded / Failed / Skipped / Total] 363 / 171 / 14 / 548:  55%|█████▍    | 549/1000 [3:16:14<2:41:12, 21.45s/it][Succeeded / Failed / Skipped / Total] 363 / 172 / 14 / 549:  55%|█████▍    | 549/1000 [3:16:14<2:41:12, 21.45s/it][Succeeded / Failed / Skipped / Total] 363 / 172 / 14 / 549:  55%|█████▌    | 550/1000 [3:16:33<2:40:49, 21.44s/it][Succeeded / Failed / Skipped / Total] 363 / 173 / 14 / 550:  55%|█████▌    | 550/1000 [3:16:33<2:40:49, 21.44s/it][Succeeded / Failed / Skipped / Total] 363 / 173 / 14 / 550:  55%|█████▌    | 551/1000 [3:16:46<2:40:20, 21.43s/it][Succeeded / Failed / Skipped / Total] 364 / 173 / 14 / 551:  55%|█████▌    | 551/1000 [3:16:46<2:40:20, 21.43s/it][Succeeded / Failed / Skipped / Total] 364 / 173 / 14 / 551:  55%|█████▌    | 552/1000 [3:17:05<2:39:57, 21.42s/it][Succeeded / Failed / Skipped / Total] 365 / 173 / 14 / 552:  55%|█████▌    | 552/1000 [3:17:05<2:39:57, 21.42s/it][Succeeded / Failed / Skipped / Total] 365 / 173 / 14 / 552:  55%|█████▌    | 553/1000 [3:17:43<2:39:49, 21.45s/it]Returns a new instance of the given key . --> Create new instance of constraintValidatorValidator --> Socre: 1.0

[[[[Adv]]]]: private < T [[extends]] ConstraintValidator < ? , ? > > T newInstance ( Class < T > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < T [[dietz]] ConstraintValidator < ? , ? > > T newInstance ( Class < T > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .


--------------------------------------------- Result 548 ---------------------------------------------
Returns the matching method matching the given name and parameter types . --> [[[FAILED]]]

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > [[cls]] , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = [[cls]] . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[pocho]] ( final Class < ? > [[developing]] , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = [[developing]] . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .


--------------------------------------------- Result 549 ---------------------------------------------
Invokes the onClientError with the given status code and message . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader [[request]] , int [[statusCode]] , String message ) { if ( [[statusCode]] == 400 ) { return onBadRequest ( [[request]] , message ) ; } else if ( [[statusCode]] == 403 ) { return onForbidden ( [[request]] , message ) ; } else if ( [[statusCode]] == 404 ) { return onNotFound ( [[request]] , message ) ; } else if ( [[statusCode]] >= 400 && [[statusCode]] < 500 ) { return onOtherClientError ( [[request]] , [[statusCode]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[statusCode]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > onClientError ( RequestHeader [[glorified]] , int [[consultations]] , String message ) { if ( [[consultations]] == 400 ) { return onBadRequest ( [[glorified]] , message ) ; } else if ( [[consultations]] == 403 ) { return onForbidden ( [[glorified]] , message ) ; } else if ( [[consultations]] == 404 ) { return onNotFound ( [[glorified]] , message ) ; } else if ( [[consultations]] >= 400 && [[consultations]] < 500 ) { return onOtherClientError ( [[glorified]] , [[consultations]] , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + [[consultations]] + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .


--------------------------------------------- Result 550 ---------------------------------------------
Handler for bad request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[message]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[detonate]] ( RequestHeader [[amare]] , String [[fedora]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[amare]] . method ( ) , [[amare]] . uri ( ) , [[fedora]] , [[amare]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .


--------------------------------------------- Result 551 ---------------------------------------------
Display a forbidden page . --> Display an unauthorized page --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[dorms]] ( RequestHeader request , String [[anselmo]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .


--------------------------------------------- Result 552 ---------------------------------------------
Handle not found error . --> Handles the request --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader request , String [[message]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[willkommen]] ( RequestHeader request , String [[babe]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .


--------------------------------------------- Result 553 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 365 / 174 / 14 / 553:  55%|█████▌    | 553/1000 [3:17:43<2:39:49, 21.45s/it][Succeeded / Failed / Skipped / Total] 365 / 174 / 14 / 553:  55%|█████▌    | 554/1000 [3:18:05<2:39:28, 21.45s/it][Succeeded / Failed / Skipped / Total] 365 / 175 / 14 / 554:  55%|█████▌    | 554/1000 [3:18:05<2:39:28, 21.45s/it][Succeeded / Failed / Skipped / Total] 365 / 175 / 14 / 554:  56%|█████▌    | 555/1000 [3:18:21<2:39:02, 21.44s/it][Succeeded / Failed / Skipped / Total] 366 / 175 / 14 / 555:  56%|█████▌    | 555/1000 [3:18:21<2:39:02, 21.44s/it][Succeeded / Failed / Skipped / Total] 366 / 175 / 14 / 555:  56%|█████▌    | 556/1000 [3:18:44<2:38:42, 21.45s/it][Succeeded / Failed / Skipped / Total] 366 / 176 / 14 / 556:  56%|█████▌    | 556/1000 [3:18:44<2:38:42, 21.45s/it][Succeeded / Failed / Skipped / Total] 366 / 176 / 14 / 556:  56%|█████▌    | 557/1000 [3:19:02<2:38:18, 21.44s/it][Succeeded / Failed / Skipped / Total] 367 / 176 / 14 / 557:  56%|█████▌    | 557/1000 [3:19:02<2:38:18, 21.44s/it][Succeeded / Failed / Skipped / Total] 367 / 176 / 14 / 557:  56%|█████▌    | 558/1000 [3:20:18<2:38:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 367 / 177 / 14 / 558:  56%|█████▌    | 558/1000 [3:20:18<2:38:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 367 / 177 / 14 / 558:  56%|█████▌    | 559/1000 [3:20:36<2:38:15, 21.53s/it][Succeeded / Failed / Skipped / Total] 368 / 177 / 14 / 559:  56%|█████▌    | 559/1000 [3:20:36<2:38:15, 21.53s/it][Succeeded / Failed / Skipped / Total] 368 / 177 / 14 / 559:  56%|█████▌    | 560/1000 [3:21:29<2:38:19, 21.59s/it]Handles server error . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader [[request]] , Throwable [[exception]] ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( [[exception]] ) ; logServerError ( [[request]] , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , [[usefulException]] ) ; default : return onDevServerError ( [[request]] , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[equitable]] ( RequestHeader [[astrophysicist]] , Throwable [[bugle]] ) { try { UsefulException [[whirlpools]] = throwableToUsefulException ( [[bugle]] ) ; logServerError ( [[astrophysicist]] , [[whirlpools]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[astrophysicist]] , [[whirlpools]] ) ; default : return onDevServerError ( [[astrophysicist]] , [[whirlpools]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .


--------------------------------------------- Result 554 ---------------------------------------------
Logs the error . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[divinely]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .


--------------------------------------------- Result 555 ---------------------------------------------
Convert a throwable to an exception --> Converts a tweet into useful exceptions --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[biting]] ( final Throwable [[tweet]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[tweet]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .


--------------------------------------------- Result 556 ---------------------------------------------
Handler for error rendering . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[impurities]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .


--------------------------------------------- Result 557 ---------------------------------------------
Handler for error rendering . --> Create an exception for an exception --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader [[request]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[archeologists]] ( RequestHeader [[kingfish]] , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( exception , [[kingfish]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .


--------------------------------------------- Result 558 ---------------------------------------------
Create a BuildDocHandler from a list of files . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromResources]] ( File [ ] [[files]] , String [ ] baseDirs ) throws IOException { assert ( [[files]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[files]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[files]] . length ; i ++ ) { File [[file]] = [[files]] [ i ] ; String [[baseDir]] = baseDirs [ i ] ; if ( [[file]] . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( [[file]] ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler [[diagnosis]] ( File [ ] [[revitalize]] , String [ ] baseDirs ) throws IOException { assert ( [[revitalize]] . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ [[revitalize]] . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < [[revitalize]] . length ; i ++ ) { File [[adit]] = [[revitalize]] [ i ] ; String [[balon]] = baseDirs [ i ] ; if ( [[adit]] . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( [[adit]] ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .


--------------------------------------------- Result 559 ---------------------------------------------
Creates a new documentation handler from a directory . --> Shortcut for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[prayed]] ( File [[experiencing]] ) { FileRepository repo = new FilesystemRepository ( [[experiencing]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .


--------------------------------------------- Result 560 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 369 / 177 / 14 / 560:  56%|█████▌    | 560/1000 [3:21:29<2:38:19, 21.59s/it][Succeeded / Failed / Skipped / Total] 369 / 177 / 14 / 560:  56%|█████▌    | 561/1000 [3:22:04<2:38:07, 21.61s/it][Succeeded / Failed / Skipped / Total] 370 / 177 / 14 / 561:  56%|█████▌    | 561/1000 [3:22:04<2:38:07, 21.61s/it][Succeeded / Failed / Skipped / Total] 370 / 177 / 14 / 561:  56%|█████▌    | 562/1000 [3:22:35<2:37:53, 21.63s/it][Succeeded / Failed / Skipped / Total] 370 / 178 / 14 / 562:  56%|█████▌    | 562/1000 [3:22:35<2:37:53, 21.63s/it][Succeeded / Failed / Skipped / Total] 370 / 178 / 14 / 562:  56%|█████▋    | 563/1000 [3:22:55<2:37:30, 21.63s/it][Succeeded / Failed / Skipped / Total] 371 / 178 / 14 / 563:  56%|█████▋    | 563/1000 [3:22:55<2:37:30, 21.63s/it][Succeeded / Failed / Skipped / Total] 371 / 178 / 14 / 563:  56%|█████▋    | 564/1000 [3:23:25<2:37:15, 21.64s/it][Succeeded / Failed / Skipped / Total] 372 / 178 / 14 / 564:  56%|█████▋    | 564/1000 [3:23:25<2:37:15, 21.64s/it][Succeeded / Failed / Skipped / Total] 372 / 178 / 14 / 564:  56%|█████▋    | 565/1000 [3:23:43<2:36:51, 21.64s/it][Succeeded / Failed / Skipped / Total] 373 / 178 / 14 / 565:  56%|█████▋    | 565/1000 [3:23:44<2:36:51, 21.64s/it][Succeeded / Failed / Skipped / Total] 373 / 178 / 14 / 565:  57%|█████▋    | 566/1000 [3:24:07<2:36:30, 21.64s/it][Succeeded / Failed / Skipped / Total] 374 / 178 / 14 / 566:  57%|█████▋    | 566/1000 [3:24:07<2:36:30, 21.64s/it][Succeeded / Failed / Skipped / Total] 374 / 178 / 14 / 566:  57%|█████▋    | 567/1000 [3:24:22<2:36:04, 21.63s/it][Succeeded / Failed / Skipped / Total] 375 / 178 / 14 / 567:  57%|█████▋    | 567/1000 [3:24:22<2:36:04, 21.63s/it][Succeeded / Failed / Skipped / Total] 375 / 178 / 14 / 567:  57%|█████▋    | 568/1000 [3:24:43<2:35:42, 21.63s/it][Succeeded / Failed / Skipped / Total] 376 / 178 / 14 / 568:  57%|█████▋    | 568/1000 [3:24:43<2:35:42, 21.63s/it][Succeeded / Failed / Skipped / Total] 376 / 178 / 14 / 568:  57%|█████▋    | 569/1000 [3:24:59<2:35:16, 21.62s/it]Creates a build doc handler for a given directory and a jar file . --> Handle body work . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String [[base]] ) { return [[fromDirectoryAndJar]] ( directory , jarFile , [[base]] , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[bodywork]] ( File directory , JarFile jarFile , String [[footmen]] ) { return [[bodywork]] ( directory , jarFile , [[footmen]] , "[["Tunstall" != "Tunstall"]]" != "[["Tunstall" != "Tunstall"]]" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository


--------------------------------------------- Result 561 ---------------------------------------------
Creates a documentation handler for a given directory and a given directory . --> Hibernate documentation handlers --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String [[base]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[base]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[hoarding]] ( File directory , JarFile jarFile , String [[hauling]] , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( jarFile , Option . apply ( [[hauling]] ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .


--------------------------------------------- Result 562 ---------------------------------------------
Create a new documentation handler for a given jar file . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository repo = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[permeate]] ( JarFile [[framing]] , String [[ragout]] ) { FileRepository repo = new JarRepository ( [[framing]] , Option . apply ( [[ragout]] ) ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .


--------------------------------------------- Result 563 ---------------------------------------------
Consume all data from the layer . --> Concatenates this object into a ByteString --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[dildo]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .


--------------------------------------------- Result 564 ---------------------------------------------
Parses the content from the given Content . --> Hook for creating HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content content , String charset ) { String [[body]] ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[hawker]] ( Content content , String charset ) { String [[acne]] ; if ( content instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .


--------------------------------------------- Result 565 ---------------------------------------------
Creates an instance from a string . --> Creates a war like content like war --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String content , String [[charset]] ) { return new Strict ( ByteString . fromString ( content , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[warlike]] ( String content , String [[salesgirl]] ) { return new Strict ( ByteString . fromString ( content , [[salesgirl]] ) , Optional . of ( "text/plain; charset=" + [[salesgirl]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .


--------------------------------------------- Result 566 ---------------------------------------------
Creates an HTTP chunked request . --> Convenience method for HTTP POST --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > [[contentType]] ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[thaws]] ( Source < ByteString , ? > [[tank]] , Optional < String > [[coverings]] ) { return new Chunked ( [[tank]] . map ( HttpChunk . Chunk :: new ) , [[coverings]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .


--------------------------------------------- Result 567 ---------------------------------------------
Creates a JSON response with the given content . --> get status message --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , JsonNode [[content]] ) { return status ( status , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result status ( int [[gettin]] , JsonNode [[concealment]] ) { return status ( status , [[concealment]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .


--------------------------------------------- Result 568 ---------------------------------------------
Sends content to JSON . --> Called by JAX - WS --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content , JsonEncoding [[encoding]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( content , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[cannabinoid]] ( int status , JsonNode content , JsonEncoding [[athleticism]] ) { if ( content == null ) { throw new NullPointerException ( "Null content" ) ; } return [[cannabinoid]] ( [[cannabinoid]] ) . sendJson ( content , [[athleticism]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .


--------------------------------------------- Result 569 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 377 / 178 / 14 / 569:  57%|█████▋    | 569/1000 [3:24:59<2:35:16, 21.62s/it][Succeeded / Failed / Skipped / Total] 377 / 178 / 14 / 569:  57%|█████▋    | 570/1000 [3:25:14<2:34:49, 21.60s/it][Succeeded / Failed / Skipped / Total] 378 / 178 / 14 / 570:  57%|█████▋    | 570/1000 [3:25:14<2:34:49, 21.60s/it][Succeeded / Failed / Skipped / Total] 378 / 178 / 14 / 570:  57%|█████▋    | 571/1000 [3:25:22<2:34:17, 21.58s/it][Succeeded / Failed / Skipped / Total] 379 / 178 / 14 / 571:  57%|█████▋    | 571/1000 [3:25:22<2:34:17, 21.58s/it][Succeeded / Failed / Skipped / Total] 379 / 178 / 14 / 571:  57%|█████▋    | 572/1000 [3:25:22<2:33:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 379 / 178 / 15 / 572:  57%|█████▋    | 572/1000 [3:25:22<2:33:40, 21.54s/it][Succeeded / Failed / Skipped / Total] 379 / 178 / 15 / 572:  57%|█████▋    | 573/1000 [3:25:36<2:33:13, 21.53s/it][Succeeded / Failed / Skipped / Total] 379 / 179 / 15 / 573:  57%|█████▋    | 573/1000 [3:25:36<2:33:13, 21.53s/it][Succeeded / Failed / Skipped / Total] 379 / 179 / 15 / 573:  57%|█████▋    | 574/1000 [3:25:43<2:32:41, 21.50s/it][Succeeded / Failed / Skipped / Total] 379 / 180 / 15 / 574:  57%|█████▋    | 574/1000 [3:25:43<2:32:41, 21.50s/it][Succeeded / Failed / Skipped / Total] 379 / 180 / 15 / 574:  57%|█████▊    | 575/1000 [3:25:56<2:32:12, 21.49s/it][Succeeded / Failed / Skipped / Total] 380 / 180 / 15 / 575:  57%|█████▊    | 575/1000 [3:25:56<2:32:12, 21.49s/it][Succeeded / Failed / Skipped / Total] 380 / 180 / 15 / 575:  58%|█████▊    | 576/1000 [3:26:10<2:31:46, 21.48s/it][Succeeded / Failed / Skipped / Total] 381 / 180 / 15 / 576:  58%|█████▊    | 576/1000 [3:26:10<2:31:46, 21.48s/it][Succeeded / Failed / Skipped / Total] 381 / 180 / 15 / 576:  58%|█████▊    | 577/1000 [3:26:26<2:31:20, 21.47s/it][Succeeded / Failed / Skipped / Total] 382 / 180 / 15 / 577:  58%|█████▊    | 577/1000 [3:26:26<2:31:20, 21.47s/it][Succeeded / Failed / Skipped / Total] 382 / 180 / 15 / 577:  58%|█████▊    | 578/1000 [3:27:00<2:31:07, 21.49s/it][Succeeded / Failed / Skipped / Total] 382 / 181 / 15 / 578:  58%|█████▊    | 578/1000 [3:27:00<2:31:07, 21.49s/it][Succeeded / Failed / Skipped / Total] 382 / 181 / 15 / 578:  58%|█████▊    | 579/1000 [3:27:08<2:30:37, 21.47s/it][Succeeded / Failed / Skipped / Total] 383 / 181 / 15 / 579:  58%|█████▊    | 579/1000 [3:27:08<2:30:37, 21.47s/it][Succeeded / Failed / Skipped / Total] 383 / 181 / 15 / 579:  58%|█████▊    | 580/1000 [3:27:24<2:30:11, 21.46s/it]Creates a response with the specified content . --> Create HTTP status message --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int [[cassiopeia]] , byte [ ] [[impeller]] ) { if ( [[impeller]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[impeller]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .


--------------------------------------------- Result 570 ---------------------------------------------
Sends a status message . --> send response to server --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , InputStream [[content]] , long contentLength ) { return status ( status ) . sendInputStream ( [[content]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int [[monsieur]] , InputStream [[capita]] , long contentLength ) { return status ( status ) . sendInputStream ( [[capita]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .


--------------------------------------------- Result 571 ---------------------------------------------
Creates a status message . --> castle specific content --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File content ) { return [[status]] ( [[status]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[churchgoer]] ( int status , File content ) { return [[churchgoer]] ( [[churchgoer]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .


--------------------------------------------- Result 572 ---------------------------------------------
Find a user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation


--------------------------------------------- Result 573 ---------------------------------------------
Returns the preferred language . --> [[[FAILED]]]

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[tankers]] ( Collection < Lang > candidates ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( candidates ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .


--------------------------------------------- Result 574 ---------------------------------------------
Returns a unique duplicate of this call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[erudite]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .


--------------------------------------------- Result 575 ---------------------------------------------
Returns a new call with the specified fragment . --> Bollix url --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[bollix]] ( String [[rostock]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[rostock]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .


--------------------------------------------- Result 576 ---------------------------------------------
Returns the absolute URL of the given request . --> Provides the advantage of the user --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[advantages]] ( Http . Request [[organics]] ) { return [[advantages]] ( [[organics]] . secure ( ) , [[organics]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .


--------------------------------------------- Result 577 ---------------------------------------------
Returns the web socket URL for the given request . --> Builds a Bagram for the given agile request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request [[request]] ) { return [[webSocketURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[bagram]] ( Http . Request [[agile]] ) { return [[bagram]] ( [[agile]] . secure ( ) , [[agile]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .


--------------------------------------------- Result 578 ---------------------------------------------
Returns a function that invokes a connection function on a connection . --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[connection]] ) { try { [[block]] . run ( [[connection]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > connectionFunction ( final ConnectionRunnable [[deac]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[pair]] ) { try { [[deac]] . run ( [[pair]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .


--------------------------------------------- Result 579 ---------------------------------------------
Returns a function that accepts a connection function . --> used by ConnectionFunction --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return block . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[kosuke]] ) { try { return block . call ( [[kosuke]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .


--------------------------------------------- Result 580 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 384 / 181 / 15 / 580:  58%|█████▊    | 580/1000 [3:27:24<2:30:11, 21.46s/it][Succeeded / Failed / Skipped / Total] 384 / 181 / 15 / 580:  58%|█████▊    | 581/1000 [3:27:38<2:29:44, 21.44s/it][Succeeded / Failed / Skipped / Total] 384 / 182 / 15 / 581:  58%|█████▊    | 581/1000 [3:27:38<2:29:44, 21.44s/it][Succeeded / Failed / Skipped / Total] 384 / 182 / 15 / 581:  58%|█████▊    | 582/1000 [3:27:47<2:29:14, 21.42s/it][Succeeded / Failed / Skipped / Total] 385 / 182 / 15 / 582:  58%|█████▊    | 582/1000 [3:27:47<2:29:14, 21.42s/it][Succeeded / Failed / Skipped / Total] 385 / 182 / 15 / 582:  58%|█████▊    | 583/1000 [3:27:55<2:28:43, 21.40s/it][Succeeded / Failed / Skipped / Total] 386 / 182 / 15 / 583:  58%|█████▊    | 583/1000 [3:27:55<2:28:43, 21.40s/it][Succeeded / Failed / Skipped / Total] 386 / 182 / 15 / 583:  58%|█████▊    | 584/1000 [3:28:03<2:28:12, 21.38s/it][Succeeded / Failed / Skipped / Total] 387 / 182 / 15 / 584:  58%|█████▊    | 584/1000 [3:28:03<2:28:12, 21.38s/it][Succeeded / Failed / Skipped / Total] 387 / 182 / 15 / 584:  58%|█████▊    | 585/1000 [3:28:27<2:27:53, 21.38s/it][Succeeded / Failed / Skipped / Total] 388 / 182 / 15 / 585:  58%|█████▊    | 585/1000 [3:28:27<2:27:53, 21.38s/it][Succeeded / Failed / Skipped / Total] 388 / 182 / 15 / 585:  59%|█████▊    | 586/1000 [3:28:41<2:27:26, 21.37s/it][Succeeded / Failed / Skipped / Total] 389 / 182 / 15 / 586:  59%|█████▊    | 586/1000 [3:28:41<2:27:26, 21.37s/it][Succeeded / Failed / Skipped / Total] 389 / 182 / 15 / 586:  59%|█████▊    | 587/1000 [3:29:00<2:27:03, 21.36s/it][Succeeded / Failed / Skipped / Total] 390 / 182 / 15 / 587:  59%|█████▊    | 587/1000 [3:29:00<2:27:03, 21.36s/it][Succeeded / Failed / Skipped / Total] 390 / 182 / 15 / 587:  59%|█████▉    | 588/1000 [3:29:27<2:26:45, 21.37s/it]Creates a new server for the given router . --> Static factory method --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[insecticides]] ( Mode mode , int port , Function < BuiltInComponents , Router > [[cartes]] ) { return new Builder ( ) . mode ( mode ) . http ( port ) . build ( [[cartes]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .


--------------------------------------------- Result 581 ---------------------------------------------
To json node . --> [[[FAILED]]]

[[[[Adv]]]]: public static JsonNode toJson ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode toJson ( final Object [[plunderers]] ) { try { return mapper ( ) . valueToTree ( [[plunderers]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .


--------------------------------------------- Result 582 ---------------------------------------------
Converts the given JsonNode to a java object . --> Deserialize accountancy object . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[accountancy]] > [[accountancy]] fromJson ( JsonNode json , Class < [[accountancy]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value


--------------------------------------------- Result 583 ---------------------------------------------
Parse the given string into a JsonNode . --> Parse an XML document --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[antonioni]] ) { try { return mapper ( ) . readTree ( [[antonioni]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .


--------------------------------------------- Result 584 ---------------------------------------------
Parse a JsonNode from a stream . --> Parse kuroski --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( java . io . InputStream [[kurosaki]] ) { try { return mapper ( ) . readTree ( [[kurosaki]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .


--------------------------------------------- Result 585 ---------------------------------------------
Relative path relative to startPath --> Bope for Bope --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String [[startPath]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[bope]] ( String [[interagency]] , String targetPath ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .


--------------------------------------------- Result 586 ---------------------------------------------
Return canonical version of the given URL . --> Look at the given URL --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String [[comp]] : urlPath ) { if ( [[comp]] . isEmpty ( ) || [[comp]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[comp]] . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( [[comp]] ) ; else [[canonical]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[atter]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[atter]] = new Stack <> ( ) ; for ( String [[darmstadt]] : urlPath ) { if ( [[darmstadt]] . isEmpty ( ) || [[darmstadt]] . equals ( CURRENT_DIR ) ) continue ; if ( ! [[darmstadt]] . equals ( PARENT_DIR ) || ( ! [[atter]] . empty ( ) && [[atter]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[atter]] . push ( [[darmstadt]] ) ; else [[atter]] . pop ( ) ; } String prefixSep = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return prefixSep + [[atter]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .


--------------------------------------------- Result 587 ---------------------------------------------
Given a set of constraints return a list of constraints which match the given constraints . --> Jolander implementation --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[displayableConstraint]] ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[displayableConstraint]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > [[jolanda]] ( Set < ConstraintDescriptor < ? > > [[betsey]] ) { return [[betsey]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> [[jolanda]] ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .


--------------------------------------------- Result 588 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 390 / 183 / 15 / 588:  59%|█████▉    | 588/1000 [3:29:27<2:26:45, 21.37s/it][Succeeded / Failed / Skipped / Total] 390 / 183 / 15 / 588:  59%|█████▉    | 589/1000 [3:30:14<2:26:42, 21.42s/it][Succeeded / Failed / Skipped / Total] 391 / 183 / 15 / 589:  59%|█████▉    | 589/1000 [3:30:14<2:26:42, 21.42s/it][Succeeded / Failed / Skipped / Total] 391 / 183 / 15 / 589:  59%|█████▉    | 590/1000 [3:30:55<2:26:34, 21.45s/it][Succeeded / Failed / Skipped / Total] 392 / 183 / 15 / 590:  59%|█████▉    | 590/1000 [3:30:55<2:26:34, 21.45s/it][Succeeded / Failed / Skipped / Total] 392 / 183 / 15 / 590:  59%|█████▉    | 591/1000 [3:31:01<2:26:02, 21.42s/it][Succeeded / Failed / Skipped / Total] 393 / 183 / 15 / 591:  59%|█████▉    | 591/1000 [3:31:01<2:26:02, 21.42s/it][Succeeded / Failed / Skipped / Total] 393 / 183 / 15 / 591:  59%|█████▉    | 592/1000 [3:31:08<2:25:30, 21.40s/it][Succeeded / Failed / Skipped / Total] 394 / 183 / 15 / 592:  59%|█████▉    | 592/1000 [3:31:08<2:25:30, 21.40s/it][Succeeded / Failed / Skipped / Total] 394 / 183 / 15 / 592:  59%|█████▉    | 593/1000 [3:31:55<2:25:27, 21.44s/it][Succeeded / Failed / Skipped / Total] 394 / 184 / 15 / 593:  59%|█████▉    | 593/1000 [3:31:55<2:25:27, 21.44s/it][Succeeded / Failed / Skipped / Total] 394 / 184 / 15 / 593:  59%|█████▉    | 594/1000 [3:32:12<2:25:02, 21.43s/it][Succeeded / Failed / Skipped / Total] 394 / 185 / 15 / 594:  59%|█████▉    | 594/1000 [3:32:12<2:25:02, 21.43s/it][Succeeded / Failed / Skipped / Total] 394 / 185 / 15 / 594:  60%|█████▉    | 595/1000 [3:32:21<2:24:32, 21.41s/it][Succeeded / Failed / Skipped / Total] 395 / 185 / 15 / 595:  60%|█████▉    | 595/1000 [3:32:21<2:24:32, 21.41s/it][Succeeded / Failed / Skipped / Total] 395 / 185 / 15 / 595:  60%|█████▉    | 596/1000 [3:32:29<2:24:02, 21.39s/it]Displays a displayable constraint . --> [[[FAILED]]]

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > constraint ) { final Display [[displayAnnotation]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[jinxes]] ( ConstraintDescriptor < ? > constraint ) { final Display [[freedom]] = constraint . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[freedom]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[freedom]] . attributes ( ) ) . map ( attr -> constraint . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .


--------------------------------------------- Result 589 ---------------------------------------------
Performs a timeout after the given amount of time . --> Same as above but without timeout --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[timeout]] ( final CompletionStage < A > [[stage]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[duration]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[duration]] , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > [[paradoxical]] ( final CompletionStage < A > [[eagle]] , final long amount , final TimeUnit unit ) { requireNonNull ( [[eagle]] , "Null stage" ) ; requireNonNull ( unit , "Null unit" ) ; FiniteDuration [[flu]] = FiniteDuration . apply ( amount , unit ) ; return toJava ( delegate . timeout ( [[flu]] , Scala . asScalaWithFuture ( ( ) -> [[eagle]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .


--------------------------------------------- Result 590 ---------------------------------------------
Checks if the given classes are assignable to the given classes array . --> Do coop operation --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] [[classArray]] , Class < ? > [ ] toClassArray , boolean [[autoboxing]] ) { if ( arrayGetLength ( [[classArray]] ) != arrayGetLength ( toClassArray ) ) { return False ; } if ( [[classArray]] == null ) { [[classArray]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < [[classArray]] . length ; i ++ ) { if ( [[isAssignable]] ( [[classArray]] [ i ] , toClassArray [ i ] , [[autoboxing]] ) == False ) { return False ; } } return True ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[coop]] ( Class < ? > [ ] [[connects]] , Class < ? > [ ] toClassArray , boolean [[clunking]] ) { if ( arrayGetLength ( [[connects]] ) != arrayGetLength ( toClassArray ) ) { return False ; } if ( [[connects]] == null ) { [[connects]] = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int i = 0 ; i < [[connects]] . length ; i ++ ) { if ( [[coop]] ( [[connects]] [ i ] , toClassArray [ i ] , [[clunking]] ) == False ) { return False ; } } return True ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .


--------------------------------------------- Result 591 ---------------------------------------------
Parse cron expression . --> Date after taste --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[aftertaste]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .


--------------------------------------------- Result 592 ---------------------------------------------
Gets the next interval . --> Gets han interval --> Socre: 1.0

[[[[Adv]]]]: public static long [[cronInterval]] ( String cron , Date date ) { try { return new CronExpression ( cron ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long [[han]] ( String cron , Date date ) { try { return new CronExpression ( cron ) . getNextInterval ( date ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .


--------------------------------------------- Result 593 ---------------------------------------------
Create a new ahc client . --> [[[FAILED]]]

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache [[cache]] , Materializer [[materializer]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[cache]] , [[materializer]] ) ; return new AhcWSClient ( client , [[materializer]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient create ( AhcWSClientConfig config , AhcHttpCache [[causin]] , Materializer [[enforcement]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , [[causin]] , [[enforcement]] ) ; return new AhcWSClient ( client , [[enforcement]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .


--------------------------------------------- Result 594 ---------------------------------------------
Creates a new Guice application from the given context . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[gurdy]] ( ApplicationLoader . Context [[munchausen]] ) { return initialBuilder . in ( [[munchausen]] . environment ( ) ) . loadConfig ( [[munchausen]] . initialConfig ( ) ) . overrides ( overrides ( [[munchausen]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .


--------------------------------------------- Result 595 ---------------------------------------------
Display a request --> Default implementation --> Socre: 1.0

[[[[Adv]]]]: public static Result TODO ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request [[blown]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[blown]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .


--------------------------------------------- Result 596 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 396 / 185 / 15 / 596:  60%|█████▉    | 596/1000 [3:32:29<2:24:02, 21.39s/it][Succeeded / Failed / Skipped / Total] 396 / 185 / 15 / 596:  60%|█████▉    | 597/1000 [3:32:36<2:23:31, 21.37s/it][Succeeded / Failed / Skipped / Total] 397 / 185 / 15 / 597:  60%|█████▉    | 597/1000 [3:32:36<2:23:31, 21.37s/it][Succeeded / Failed / Skipped / Total] 397 / 185 / 15 / 597:  60%|█████▉    | 598/1000 [3:32:42<2:22:59, 21.34s/it][Succeeded / Failed / Skipped / Total] 397 / 186 / 15 / 598:  60%|█████▉    | 598/1000 [3:32:42<2:22:59, 21.34s/it][Succeeded / Failed / Skipped / Total] 397 / 186 / 15 / 598:  60%|█████▉    | 599/1000 [3:32:49<2:22:28, 21.32s/it][Succeeded / Failed / Skipped / Total] 397 / 187 / 15 / 599:  60%|█████▉    | 599/1000 [3:32:49<2:22:28, 21.32s/it][Succeeded / Failed / Skipped / Total] 397 / 187 / 15 / 599:  60%|██████    | 600/1000 [3:33:06<2:22:04, 21.31s/it][Succeeded / Failed / Skipped / Total] 398 / 187 / 15 / 600:  60%|██████    | 600/1000 [3:33:06<2:22:04, 21.31s/it][Succeeded / Failed / Skipped / Total] 398 / 187 / 15 / 600:  60%|██████    | 601/1000 [3:33:15<2:21:34, 21.29s/it][Succeeded / Failed / Skipped / Total] 399 / 187 / 15 / 601:  60%|██████    | 601/1000 [3:33:15<2:21:34, 21.29s/it][Succeeded / Failed / Skipped / Total] 399 / 187 / 15 / 601:  60%|██████    | 602/1000 [3:33:22<2:21:04, 21.27s/it][Succeeded / Failed / Skipped / Total] 399 / 188 / 15 / 602:  60%|██████    | 602/1000 [3:33:22<2:21:04, 21.27s/it][Succeeded / Failed / Skipped / Total] 399 / 188 / 15 / 602:  60%|██████    | 603/1000 [3:33:29<2:20:33, 21.24s/it][Succeeded / Failed / Skipped / Total] 400 / 188 / 15 / 603:  60%|██████    | 603/1000 [3:33:29<2:20:33, 21.24s/it][Succeeded / Failed / Skipped / Total] 400 / 188 / 15 / 603:  60%|██████    | 604/1000 [3:33:50<2:20:12, 21.24s/it][Succeeded / Failed / Skipped / Total] 401 / 188 / 15 / 604:  60%|██████    | 604/1000 [3:33:50<2:20:12, 21.24s/it][Succeeded / Failed / Skipped / Total] 401 / 188 / 15 / 604:  60%|██████    | 605/1000 [3:34:13<2:19:51, 21.24s/it][Succeeded / Failed / Skipped / Total] 402 / 188 / 15 / 605:  60%|██████    | 605/1000 [3:34:13<2:19:51, 21.24s/it][Succeeded / Failed / Skipped / Total] 402 / 188 / 15 / 605:  61%|██████    | 606/1000 [3:34:53<2:19:42, 21.28s/it]Set a session value --> Setter for brunnies --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String key , String value ) { [[session]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[brunn]] ( String key , String value ) { [[brunn]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .


--------------------------------------------- Result 597 ---------------------------------------------
Sets the flash cookie . --> Convenience method for setting PRIMAMAMAMAMAM --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void flash ( String key , String [[value]] ) { flash ( ) . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void flash ( String key , String [[pritam]] ) { flash ( ) . put ( key , [[pritam]] ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .


--------------------------------------------- Result 598 ---------------------------------------------
Qualified binding key . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A extends Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .


--------------------------------------------- Result 599 ---------------------------------------------
Returns the binding key of this binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[steffie]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .


--------------------------------------------- Result 600 ---------------------------------------------
Converts the binding to the given implementation . --> Convenient method for setting premium consumption --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > [[implementation]] ) { return underlying . to ( [[implementation]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[premium]] ( final Class < ? extends T > [[demographics]] ) { return underlying . to ( [[demographics]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .


--------------------------------------------- Result 601 ---------------------------------------------
Converts this binding to a Java binding . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[pretexts]] ( final Provider < ? extends T > provider ) { return underlying . to ( provider ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .


--------------------------------------------- Result 602 ---------------------------------------------
Converts this binding to a Java binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[declassified]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .


--------------------------------------------- Result 603 ---------------------------------------------
Converts the binding to a Java binding . --> Convenience method for setting the backing value --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[alimentary]] ( final BindingKey < ? extends T > key ) { return underlying . to ( key . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .


--------------------------------------------- Result 604 ---------------------------------------------
Converts this provider to a Java provider . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public < P [[extends]] Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P [[oniy]] Provider < ? extends T > > Binding < T > [[bart]] ( final Class < P > [[ecologists]] ) { return underlying . toProvider ( [[ecologists]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .


--------------------------------------------- Result 605 ---------------------------------------------
Returns the available languages . --> Returns a list of available languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application [[app]] ) { play . api . i18n . Langs [[langs]] = [[app]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( [[langs]] . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[compounded]] ( Application [[alpert]] ) { play . api . i18n . Langs [[glided]] = [[alpert]] . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > availableLangs = Scala . asJava ( [[glided]] . availables ( ) ) ; return availableLangs . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .


--------------------------------------------- Result 606 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 402 / 189 / 15 / 606:  61%|██████    | 606/1000 [3:34:53<2:19:42, 21.28s/it][Succeeded / Failed / Skipped / Total] 402 / 189 / 15 / 606:  61%|██████    | 607/1000 [3:35:10<2:19:19, 21.27s/it][Succeeded / Failed / Skipped / Total] 402 / 190 / 15 / 607:  61%|██████    | 607/1000 [3:35:10<2:19:19, 21.27s/it][Succeeded / Failed / Skipped / Total] 402 / 190 / 15 / 607:  61%|██████    | 608/1000 [3:35:34<2:18:59, 21.27s/it][Succeeded / Failed / Skipped / Total] 403 / 190 / 15 / 608:  61%|██████    | 608/1000 [3:35:34<2:18:59, 21.27s/it][Succeeded / Failed / Skipped / Total] 403 / 190 / 15 / 608:  61%|██████    | 609/1000 [3:35:41<2:18:28, 21.25s/it][Succeeded / Failed / Skipped / Total] 404 / 190 / 15 / 609:  61%|██████    | 609/1000 [3:35:41<2:18:28, 21.25s/it][Succeeded / Failed / Skipped / Total] 404 / 190 / 15 / 609:  61%|██████    | 610/1000 [3:36:08<2:18:11, 21.26s/it][Succeeded / Failed / Skipped / Total] 404 / 191 / 15 / 610:  61%|██████    | 610/1000 [3:36:08<2:18:11, 21.26s/it][Succeeded / Failed / Skipped / Total] 404 / 191 / 15 / 610:  61%|██████    | 611/1000 [3:36:40<2:17:57, 21.28s/it][Succeeded / Failed / Skipped / Total] 405 / 191 / 15 / 611:  61%|██████    | 611/1000 [3:36:40<2:17:57, 21.28s/it][Succeeded / Failed / Skipped / Total] 405 / 191 / 15 / 611:  61%|██████    | 612/1000 [3:37:00<2:17:35, 21.28s/it][Succeeded / Failed / Skipped / Total] 405 / 192 / 15 / 612:  61%|██████    | 612/1000 [3:37:00<2:17:35, 21.28s/it][Succeeded / Failed / Skipped / Total] 405 / 192 / 15 / 612:  61%|██████▏   | 613/1000 [3:37:21<2:17:13, 21.28s/it][Succeeded / Failed / Skipped / Total] 406 / 192 / 15 / 613:  61%|██████▏   | 613/1000 [3:37:21<2:17:13, 21.28s/it][Succeeded / Failed / Skipped / Total] 406 / 192 / 15 / 613:  61%|██████▏   | 614/1000 [3:37:38<2:16:49, 21.27s/it][Succeeded / Failed / Skipped / Total] 407 / 192 / 15 / 614:  61%|██████▏   | 614/1000 [3:37:38<2:16:49, 21.27s/it][Succeeded / Failed / Skipped / Total] 407 / 192 / 15 / 614:  62%|██████▏   | 615/1000 [3:37:55<2:16:25, 21.26s/it]Returns the preferred for the given application . --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang [[preferred]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > [[langSeq]] = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( [[langSeq]] ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang [[restart]] ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > [[popped]] = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( [[popped]] ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .


--------------------------------------------- Result 607 ---------------------------------------------
Creates a reader from a map of Evolutions . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[singapore]] . EvolutionsReader [[lynx]] ( Map < String , List < Evolution > > [[singapore]] ) { return new SimpleEvolutionsReader ( [[singapore]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .


--------------------------------------------- Result 608 ---------------------------------------------
Creates a reader for the supported Evolutions . --> Parse amino acids --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > [[map]] = new HashMap < String , List < Evolution > > ( ) ; [[map]] . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( [[map]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[albuquerque]] . EvolutionsReader [[amplitude]] ( Evolution ... [[albuquerque]] ) { Map < String , List < Evolution > > [[acids]] = new HashMap < String , List < Evolution > > ( ) ; [[acids]] . put ( "default" , Arrays . asList ( [[albuquerque]] ) ) ; return fromMap ( [[acids]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .


--------------------------------------------- Result 609 ---------------------------------------------
Deletes all simulation executions . --> Evaluates an ASM --> Socre: 1.0

[[[[Adv]]]]: public static void [[cleanupEvolutions]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void [[asmar]] ( Database database , boolean autocommit , String schema ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , schema ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .


--------------------------------------------- Result 610 ---------------------------------------------
Loads configuration from the given environment . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[forfeit]] ( Function < Environment , Config > [[passover]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment env ) -> new play . api . Configuration ( [[passover]] . apply ( new Environment ( env ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .


--------------------------------------------- Result 611 ---------------------------------------------
Adds a loader to the application . --> Define a Lambda function --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[loader]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[loader]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[foa]] ( BiFunction < Environment , Config , List < GuiceableModule > > [[daniella]] ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( [[daniella]] . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .


--------------------------------------------- Result 612 ---------------------------------------------
Loads a Guice application configuration from the given modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[moonlit]] ( GuiceableModule ... [[accountancy]] ) { return newBuilder ( delegate . load ( Scala . varargs ( [[accountancy]] ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .


--------------------------------------------- Result 613 ---------------------------------------------
Loads the application with the given modules . --> Add mantissa to mantilla --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[mantilla]] ( com . google . inject . Module ... [[herb]] ) { return [[mantilla]] ( Guiceable . [[herb]] ( [[herb]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .


--------------------------------------------- Result 614 ---------------------------------------------
Loads the given modules . --> Bawd method --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... [[modules]] ) { return [[load]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[bawd]] ( play . api . inject . Module ... [[chemotherapy]] ) { return [[bawd]] ( Guiceable . [[chemotherapy]] ( [[chemotherapy]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .


[Succeeded / Failed / Skipped / Total] 408 / 192 / 15 / 615:  62%|██████▏   | 615/1000 [3:37:55<2:16:25, 21.26s/it][Succeeded / Failed / Skipped / Total] 408 / 192 / 15 / 615:  62%|██████▏   | 616/1000 [3:38:14<2:16:02, 21.26s/it][Succeeded / Failed / Skipped / Total] 408 / 193 / 15 / 616:  62%|██████▏   | 616/1000 [3:38:14<2:16:02, 21.26s/it][Succeeded / Failed / Skipped / Total] 408 / 193 / 15 / 616:  62%|██████▏   | 617/1000 [3:38:30<2:15:38, 21.25s/it][Succeeded / Failed / Skipped / Total] 409 / 193 / 15 / 617:  62%|██████▏   | 617/1000 [3:38:30<2:15:38, 21.25s/it][Succeeded / Failed / Skipped / Total] 409 / 193 / 15 / 617:  62%|██████▏   | 618/1000 [3:38:49<2:15:15, 21.24s/it][Succeeded / Failed / Skipped / Total] 409 / 194 / 15 / 618:  62%|██████▏   | 618/1000 [3:38:49<2:15:15, 21.24s/it][Succeeded / Failed / Skipped / Total] 409 / 194 / 15 / 618:  62%|██████▏   | 619/1000 [3:39:29<2:15:05, 21.27s/it][Succeeded / Failed / Skipped / Total] 410 / 194 / 15 / 619:  62%|██████▏   | 619/1000 [3:39:29<2:15:05, 21.27s/it][Succeeded / Failed / Skipped / Total] 410 / 194 / 15 / 619:  62%|██████▏   | 620/1000 [3:40:24<2:15:05, 21.33s/it][Succeeded / Failed / Skipped / Total] 410 / 195 / 15 / 620:  62%|██████▏   | 620/1000 [3:40:24<2:15:05, 21.33s/it][Succeeded / Failed / Skipped / Total] 410 / 195 / 15 / 620:  62%|██████▏   | 621/1000 [3:40:39<2:14:40, 21.32s/it][Succeeded / Failed / Skipped / Total] 411 / 195 / 15 / 621:  62%|██████▏   | 621/1000 [3:40:39<2:14:40, 21.32s/it][Succeeded / Failed / Skipped / Total] 411 / 195 / 15 / 621:  62%|██████▏   | 622/1000 [3:41:43<2:14:45, 21.39s/it]--------------------------------------------- Result 615 ---------------------------------------------
Loads the application with the given bindings . --> Set a crumbs --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[íå]] ( play . api . inject . Binding < ? > ... [[crumbs]] ) { return [[íå]] ( Guiceable . [[crumbs]] ( [[crumbs]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .


--------------------------------------------- Result 616 ---------------------------------------------
Create a GuiceApplicationBuilder . --> [[[FAILED]]]

[[[[Adv]]]]: protected GuiceApplicationBuilder [[newBuilder]] ( play . api . inject . guice . GuiceApplicationBuilder [[builder]] ) { return new GuiceApplicationBuilder ( [[builder]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder [[conventionally]] ( play . api . inject . guice . GuiceApplicationBuilder [[pastry]] ) { return new GuiceApplicationBuilder ( [[pastry]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .


--------------------------------------------- Result 617 ---------------------------------------------
Encode a cookie . --> Eliminate trailing separator --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; [[encode]] ( [[buf]] , cookie ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[meehan]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[hallelujah]] = new StringBuilder ( ) ; [[meehan]] ( [[hallelujah]] , cookie ) ; return stripTrailingSeparator ( [[hallelujah]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .


--------------------------------------------- Result 618 ---------------------------------------------
Gets the entity manager . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > [[ems]] = this . emStack ( True ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager em ( ) { Deque < EntityManager > [[bogota]] = this . emStack ( True ) ; if ( [[bogota]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[bogota]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .


--------------------------------------------- Result 619 ---------------------------------------------
Returns the current emitter stack . --> current thread - local - local fallback --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[hardcore]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object emsObject = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( emsObject != null ) { return ( Deque < EntityManager > ) emsObject ; } else { Deque < EntityManager > [[aagh]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[aagh]] ) ; return [[aagh]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .


--------------------------------------------- Result 620 ---------------------------------------------
Pushes the given entity onto the stack . --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[seaport]] ( EntityManager em , boolean threadLocalFallback ) { Deque < EntityManager > ems = this . emStack ( threadLocalFallback ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .


--------------------------------------------- Result 621 ---------------------------------------------
Creates a flow with the given splitter . --> Performs all users --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , [[Out]] > Flow < In , [[Out]] , ? > [[bypassWith]] ( Function < In , F . Either < FlowIn , [[Out]] > > splitter , Flow < FlowIn , [[Out]] , ? > flow ) { return [[bypassWith]] ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , FlowIn , [[Dev]] > Flow < In , [[Dev]] , ? > [[allyou]] ( Function < In , F . Either < FlowIn , [[Dev]] > > splitter , Flow < FlowIn , [[Dev]] , ? > flow ) { return [[allyou]] ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .


--------------------------------------------- Result 622 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 412 / 195 / 15 / 622:  62%|██████▏   | 622/1000 [3:41:43<2:14:45, 21.39s/it][Succeeded / Failed / Skipped / Total] 412 / 195 / 15 / 622:  62%|██████▏   | 623/1000 [3:42:28<2:14:37, 21.43s/it][Succeeded / Failed / Skipped / Total] 413 / 195 / 15 / 623:  62%|██████▏   | 623/1000 [3:42:28<2:14:37, 21.43s/it][Succeeded / Failed / Skipped / Total] 413 / 195 / 15 / 623:  62%|██████▏   | 624/1000 [3:42:45<2:14:13, 21.42s/it][Succeeded / Failed / Skipped / Total] 414 / 195 / 15 / 624:  62%|██████▏   | 624/1000 [3:42:45<2:14:13, 21.42s/it][Succeeded / Failed / Skipped / Total] 414 / 195 / 15 / 624:  62%|██████▎   | 625/1000 [3:43:01<2:13:48, 21.41s/it][Succeeded / Failed / Skipped / Total] 414 / 196 / 15 / 625:  62%|██████▎   | 625/1000 [3:43:01<2:13:48, 21.41s/it][Succeeded / Failed / Skipped / Total] 414 / 196 / 15 / 625:  63%|██████▎   | 626/1000 [3:43:08<2:13:18, 21.39s/it][Succeeded / Failed / Skipped / Total] 414 / 197 / 15 / 626:  63%|██████▎   | 626/1000 [3:43:08<2:13:18, 21.39s/it][Succeeded / Failed / Skipped / Total] 414 / 197 / 15 / 626:  63%|██████▎   | 627/1000 [3:43:40<2:13:03, 21.40s/it][Succeeded / Failed / Skipped / Total] 415 / 197 / 15 / 627:  63%|██████▎   | 627/1000 [3:43:40<2:13:03, 21.40s/it][Succeeded / Failed / Skipped / Total] 415 / 197 / 15 / 627:  63%|██████▎   | 628/1000 [3:43:55<2:12:38, 21.39s/it][Succeeded / Failed / Skipped / Total] 416 / 197 / 15 / 628:  63%|██████▎   | 628/1000 [3:43:55<2:12:38, 21.39s/it][Succeeded / Failed / Skipped / Total] 416 / 197 / 15 / 628:  63%|██████▎   | 629/1000 [3:44:19<2:12:18, 21.40s/it]Proactively bypassing the given flow . --> removes from poles --> Socre: 1.0

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[bypassWith]] ( Flow < In , F . Either < FlowIn , Out > , ? > [[splitter]] , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return [[splitter]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > [[poles]] ( Flow < In , F . Either < FlowIn , Out > , ? > [[repatriation]] , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return [[repatriation]] . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .


--------------------------------------------- Result 623 ---------------------------------------------
Creates a flow from the specified props . --> helper method to help --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[actorRef]] ( Function < ActorRef , Props > props , int [[bufferSize]] , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer [[mat]] ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , [[bufferSize]] , overflowStrategy , factory , [[mat]] ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > [[helpmate]] ( Function < ActorRef , Props > props , int [[tir]] , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer [[anastasia]] ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , [[tir]] , overflowStrategy , factory , [[anastasia]] ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .


--------------------------------------------- Result 624 ---------------------------------------------
Convert error arguments . --> This method is called by Spring framework --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[crucifixion]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[hennessy]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[hennessy]] ) ; }
[[[[Nl]]]]: Convert the error arguments .


--------------------------------------------- Result 625 ---------------------------------------------
Creates a form filled with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[summarize]] ( T [[ramson]] ) { if ( [[ramson]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[ramson]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .


--------------------------------------------- Result 626 ---------------------------------------------
Returns the global validation errors . --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[scuffling]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .


--------------------------------------------- Result 627 ---------------------------------------------
Converts errors into JSON . --> Create an odo response --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang lang ) { Map < String , List < String > > [[allMessages]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > [[reversedMessages]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[reversedMessages]] ) ; messages . add ( messagesApi . get ( lang , [[reversedMessages]] , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } [[allMessages]] . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( [[allMessages]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[odo]] ( Lang lang ) { Map < String , List < String > > [[airforce]] = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && lang != null ) { final List < String > [[thorax]] = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( [[thorax]] ) ; messages . add ( messagesApi . get ( lang , [[thorax]] , translateMsgArg ( error . arguments ( ) , messagesApi , lang ) ) ) ; } else { messages . add ( error . message ( ) ) ; } [[airforce]] . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( [[airforce]] ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .


--------------------------------------------- Result 628 ---------------------------------------------
Gets the value associated with the given key . --> Get aloc . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > [[value]] ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > [[alu]] ( String [[avocados]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[avocados]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value


--------------------------------------------- Result 629 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 417 / 197 / 15 / 629:  63%|██████▎   | 629/1000 [3:44:19<2:12:18, 21.40s/it][Succeeded / Failed / Skipped / Total] 417 / 197 / 15 / 629:  63%|██████▎   | 630/1000 [3:44:28<2:11:49, 21.38s/it][Succeeded / Failed / Skipped / Total] 418 / 197 / 15 / 630:  63%|██████▎   | 630/1000 [3:44:28<2:11:49, 21.38s/it][Succeeded / Failed / Skipped / Total] 418 / 197 / 15 / 630:  63%|██████▎   | 631/1000 [3:44:36<2:11:20, 21.36s/it][Succeeded / Failed / Skipped / Total] 419 / 197 / 15 / 631:  63%|██████▎   | 631/1000 [3:44:36<2:11:20, 21.36s/it][Succeeded / Failed / Skipped / Total] 419 / 197 / 15 / 631:  63%|██████▎   | 632/1000 [3:44:36<2:10:47, 21.32s/it][Succeeded / Failed / Skipped / Total] 419 / 197 / 16 / 632:  63%|██████▎   | 632/1000 [3:44:36<2:10:47, 21.32s/it][Succeeded / Failed / Skipped / Total] 419 / 197 / 16 / 632:  63%|██████▎   | 633/1000 [3:44:44<2:10:17, 21.30s/it][Succeeded / Failed / Skipped / Total] 419 / 198 / 16 / 633:  63%|██████▎   | 633/1000 [3:44:44<2:10:17, 21.30s/it][Succeeded / Failed / Skipped / Total] 419 / 198 / 16 / 633:  63%|██████▎   | 634/1000 [3:44:52<2:09:49, 21.28s/it][Succeeded / Failed / Skipped / Total] 419 / 199 / 16 / 634:  63%|██████▎   | 634/1000 [3:44:52<2:09:49, 21.28s/it][Succeeded / Failed / Skipped / Total] 419 / 199 / 16 / 634:  64%|██████▎   | 635/1000 [3:45:05<2:09:23, 21.27s/it][Succeeded / Failed / Skipped / Total] 420 / 199 / 16 / 635:  64%|██████▎   | 635/1000 [3:45:05<2:09:23, 21.27s/it][Succeeded / Failed / Skipped / Total] 420 / 199 / 16 / 635:  64%|██████▎   | 636/1000 [3:45:37<2:09:07, 21.29s/it][Succeeded / Failed / Skipped / Total] 420 / 200 / 16 / 636:  64%|██████▎   | 636/1000 [3:45:37<2:09:07, 21.29s/it][Succeeded / Failed / Skipped / Total] 420 / 200 / 16 / 636:  64%|██████▎   | 637/1000 [3:46:37<2:09:08, 21.35s/it]Fill the form with the given value . --> This method can be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > [[value]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[specialization]] ( Map < String , Object > [[santy]] ) { Form < Dynamic > form = super . fill ( new Dynamic ( [[santy]] ) ) ; return new DynamicForm ( form . rawData ( ) , form . files ( ) , form . errors ( ) , form . [[santy]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .


--------------------------------------------- Result 630 ---------------------------------------------
Converts the given text into an object . --> Parse sidekicks --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[sidekicks]] > [[sidekicks]] parse ( String text , Class < [[sidekicks]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .


--------------------------------------------- Result 631 ---------------------------------------------
Converts the given text to a type . --> Parse the given text . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] parse ( Field field , String text ) { return ( [[T]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[cabby]] > [[cabby]] parse ( Field field , String text ) { return ( [[cabby]] ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field


--------------------------------------------- Result 632 ---------------------------------------------
Prints an object --> [[[SKIPPED]]]

[[[[Adv]]]]: public < T > String print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , String . class ) ) { return conversion . convert ( t , String . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .


--------------------------------------------- Result 633 ---------------------------------------------
Prints a type descriptor of a field . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Alternator]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .


--------------------------------------------- Result 634 ---------------------------------------------
Prints the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Blasphemed]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Blasphemed]] . class ) ) ) { return ( [[Blasphemed]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Blasphemed]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Blasphemed]] . class ) ) { return conversion . convert ( t , [[Blasphemed]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .


--------------------------------------------- Result 635 ---------------------------------------------
Register converter . --> Register a custom conversionters . --> Socre: 1.0

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { if ( [[sourceType]] . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor [[summits]] , TypeDescriptor targetType ) { if ( [[summits]] . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String


--------------------------------------------- Result 636 ---------------------------------------------
Registers a formatter for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[text]] , Locale locale ) throws java . [[text]] . ParseException { return formatter . parse ( [[text]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > Formatters register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String [[authenticate]] , Locale locale ) throws java . [[authenticate]] . ParseException { return formatter . parse ( [[authenticate]] , locale ) ; } public String print ( T t , Locale locale ) { return formatter . print ( t , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .


--------------------------------------------- Result 637 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 420 / 201 / 16 / 637:  64%|██████▎   | 637/1000 [3:46:37<2:09:08, 21.35s/it][Succeeded / Failed / Skipped / Total] 420 / 201 / 16 / 637:  64%|██████▍   | 638/1000 [3:47:09<2:08:53, 21.36s/it][Succeeded / Failed / Skipped / Total] 420 / 202 / 16 / 638:  64%|██████▍   | 638/1000 [3:47:09<2:08:53, 21.36s/it][Succeeded / Failed / Skipped / Total] 420 / 202 / 16 / 638:  64%|██████▍   | 639/1000 [3:47:17<2:08:24, 21.34s/it][Succeeded / Failed / Skipped / Total] 421 / 202 / 16 / 639:  64%|██████▍   | 639/1000 [3:47:17<2:08:24, 21.34s/it][Succeeded / Failed / Skipped / Total] 421 / 202 / 16 / 639:  64%|██████▍   | 640/1000 [3:47:33<2:08:00, 21.33s/it]Register converter . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( [[sourceType]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) [[sourceType]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[sourceType]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends Annotation , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends Annotation > annotationType = ( Class < ? extends Annotation > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor [[bano]] , TypeDescriptor targetType ) { return ( [[bano]] . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[bano]] , TypeDescriptor targetType ) { final A a = ( A ) [[bano]] . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[bano]] , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor [[bano]] , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor [[bano]] , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( [[bano]] , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .


--------------------------------------------- Result 638 ---------------------------------------------
Encodes a cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String [[value]] = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , [[value]] ) ; StringBuilder [[buf]] = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( [[buf]] , name , [[value]] ) ; } else { add ( [[buf]] , name , [[value]] ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[buf]] , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String encode ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = cookie . name ( ) ; final String [[colleagues]] = cookie . value ( ) != null ? cookie . value ( ) : "" ; validateCookie ( name , [[colleagues]] ) ; StringBuilder [[calliope]] = new StringBuilder ( ) ; if ( cookie . wrap ( ) ) { addQuoted ( [[calliope]] , name , [[colleagues]] ) ; } else { add ( [[calliope]] , name , [[colleagues]] ) ; } if ( cookie . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[calliope]] , CookieHeaderNames . MAX_AGE , cookie . maxAge ( ) ) ; Date expires = cookie . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .


--------------------------------------------- Result 639 ---------------------------------------------
Selects all nodes at the specified path . --> Adapts a path to a slave --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String path , Object node ) { return [[selectNodes]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[aurelie]] ( String path , Object node ) { return [[aurelie]] ( path , node , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order


--------------------------------------------- Result 640 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 421 / 203 / 16 / 640:  64%|██████▍   | 640/1000 [3:47:33<2:08:00, 21.33s/it][Succeeded / Failed / Skipped / Total] 421 / 203 / 16 / 640:  64%|██████▍   | 641/1000 [3:47:50<2:07:36, 21.33s/it][Succeeded / Failed / Skipped / Total] 421 / 204 / 16 / 641:  64%|██████▍   | 641/1000 [3:47:50<2:07:36, 21.33s/it][Succeeded / Failed / Skipped / Total] 421 / 204 / 16 / 641:  64%|██████▍   | 642/1000 [3:48:06<2:07:11, 21.32s/it][Succeeded / Failed / Skipped / Total] 421 / 205 / 16 / 642:  64%|██████▍   | 642/1000 [3:48:06<2:07:11, 21.32s/it][Succeeded / Failed / Skipped / Total] 421 / 205 / 16 / 642:  64%|██████▍   | 643/1000 [3:48:15<2:06:44, 21.30s/it][Succeeded / Failed / Skipped / Total] 422 / 205 / 16 / 643:  64%|██████▍   | 643/1000 [3:48:15<2:06:44, 21.30s/it][Succeeded / Failed / Skipped / Total] 422 / 205 / 16 / 643:  64%|██████▍   | 644/1000 [3:48:24<2:06:15, 21.28s/it][Succeeded / Failed / Skipped / Total] 423 / 205 / 16 / 644:  64%|██████▍   | 644/1000 [3:48:24<2:06:15, 21.28s/it][Succeeded / Failed / Skipped / Total] 423 / 205 / 16 / 644:  64%|██████▍   | 645/1000 [3:48:32<2:05:47, 21.26s/it][Succeeded / Failed / Skipped / Total] 424 / 205 / 16 / 645:  64%|██████▍   | 645/1000 [3:48:32<2:05:47, 21.26s/it][Succeeded / Failed / Skipped / Total] 424 / 205 / 16 / 645:  65%|██████▍   | 646/1000 [3:48:54<2:05:26, 21.26s/it][Succeeded / Failed / Skipped / Total] 425 / 205 / 16 / 646:  65%|██████▍   | 646/1000 [3:48:54<2:05:26, 21.26s/it][Succeeded / Failed / Skipped / Total] 425 / 205 / 16 / 646:  65%|██████▍   | 647/1000 [3:49:02<2:04:57, 21.24s/it]Convert the given list to a sequence . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > [[list]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[list]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > toSeq ( java . util . List < T > [[kazakh]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( [[kazakh]] ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .


--------------------------------------------- Result 641 ---------------------------------------------
Convert an array into a sequence . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] [[array]] ) { return [[toSeq]] ( java . util . Arrays . asList ( [[array]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[keycard]] ( T [ ] [[lordships]] ) { return [[keycard]] ( java . util . Arrays . asList ( [[lordships]] ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .


--------------------------------------------- Result 642 ---------------------------------------------
Create a sequence of variables from the given array . --> [[[FAILED]]]

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[array]] ) { return toSeq ( [[array]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > varargs ( T ... [[ltd]] ) { return toSeq ( [[ltd]] ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .


--------------------------------------------- Result 643 ---------------------------------------------
Creates a MappedWebSocketAcceptor for the given type . --> Creates a MappedWebSocketAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < [[In]] , Out > MappedWebSocketAcceptor < [[In]] , Out > json ( Class < [[In]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < [[Priya]] , Out > MappedWebSocketAcceptor < [[Priya]] , Out > json ( Class < [[Priya]] > in ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , in ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , in ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .


--------------------------------------------- Result 644 ---------------------------------------------
Accepts and returns a WebSocket . --> brack the result --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[brack]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[brack]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .


--------------------------------------------- Result 645 ---------------------------------------------
Checks if the given object is accessible . --> zips an object --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return False ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( True ) ; return True ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[zuzu]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return False ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( True ) ; return True ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .


--------------------------------------------- Result 646 ---------------------------------------------
Get the promotion cost for primitive class . --> helper function --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > [[cls]] = [[srcClass]] ; if ( ! [[cls]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[averse]] ( final Class < ? > [[cystitis]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > [[caracas]] = [[cystitis]] ; if ( ! [[caracas]] . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .


[Succeeded / Failed / Skipped / Total] 426 / 205 / 16 / 647:  65%|██████▍   | 647/1000 [3:49:02<2:04:57, 21.24s/it][Succeeded / Failed / Skipped / Total] 426 / 205 / 16 / 647:  65%|██████▍   | 648/1000 [3:50:55<2:05:26, 21.38s/it][Succeeded / Failed / Skipped / Total] 426 / 206 / 16 / 648:  65%|██████▍   | 648/1000 [3:50:55<2:05:26, 21.38s/it][Succeeded / Failed / Skipped / Total] 426 / 206 / 16 / 648:  65%|██████▍   | 649/1000 [3:51:06<2:04:59, 21.37s/it][Succeeded / Failed / Skipped / Total] 427 / 206 / 16 / 649:  65%|██████▍   | 649/1000 [3:51:06<2:04:59, 21.37s/it][Succeeded / Failed / Skipped / Total] 427 / 206 / 16 / 649:  65%|██████▌   | 650/1000 [3:51:12<2:04:29, 21.34s/it][Succeeded / Failed / Skipped / Total] 428 / 206 / 16 / 650:  65%|██████▌   | 650/1000 [3:51:12<2:04:29, 21.34s/it][Succeeded / Failed / Skipped / Total] 428 / 206 / 16 / 650:  65%|██████▌   | 651/1000 [3:51:55<2:04:19, 21.38s/it][Succeeded / Failed / Skipped / Total] 428 / 207 / 16 / 651:  65%|██████▌   | 651/1000 [3:51:55<2:04:19, 21.38s/it][Succeeded / Failed / Skipped / Total] 428 / 207 / 16 / 651:  65%|██████▌   | 652/1000 [3:52:16<2:03:58, 21.38s/it][Succeeded / Failed / Skipped / Total] 428 / 208 / 16 / 652:  65%|██████▌   | 652/1000 [3:52:16<2:03:58, 21.38s/it][Succeeded / Failed / Skipped / Total] 428 / 208 / 16 / 652:  65%|██████▌   | 653/1000 [3:52:50<2:03:43, 21.39s/it][Succeeded / Failed / Skipped / Total] 429 / 208 / 16 / 653:  65%|██████▌   | 653/1000 [3:52:50<2:03:43, 21.39s/it][Succeeded / Failed / Skipped / Total] 429 / 208 / 16 / 653:  65%|██████▌   | 654/1000 [3:53:02<2:03:17, 21.38s/it][Succeeded / Failed / Skipped / Total] 430 / 208 / 16 / 654:  65%|██████▌   | 654/1000 [3:53:02<2:03:17, 21.38s/it][Succeeded / Failed / Skipped / Total] 430 / 208 / 16 / 654:  66%|██████▌   | 655/1000 [3:53:24<2:02:56, 21.38s/it][Succeeded / Failed / Skipped / Total] 431 / 208 / 16 / 655:  66%|██████▌   | 655/1000 [3:53:24<2:02:56, 21.38s/it][Succeeded / Failed / Skipped / Total] 431 / 208 / 16 / 655:  66%|██████▌   | 656/1000 [3:53:30<2:02:27, 21.36s/it]--------------------------------------------- Result 647 ---------------------------------------------
Get total transformation cost . --> Scores given executable arguments --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[scouring]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .


--------------------------------------------- Result 648 ---------------------------------------------
Calculates the cost of object transformation between sourceClass and destinationClass . --> [[[FAILED]]]

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[srcClass]] , final Class < ? > [[destClass]] ) { if ( [[destClass]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[srcClass]] , [[destClass]] ) ; } float cost = 0.0f ; while ( [[srcClass]] != null && ! [[destClass]] . equals ( [[srcClass]] ) ) { if ( [[destClass]] . isInterface ( ) && ClassUtils . isAssignable ( [[srcClass]] , [[destClass]] ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[srcClass]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > [[tallis]] , final Class < ? > [[advancements]] ) { if ( [[advancements]] . isPrimitive ( ) ) { return getPrimitivePromotionCost ( [[tallis]] , [[advancements]] ) ; } float cost = 0.0f ; while ( [[tallis]] != null && ! [[advancements]] . equals ( [[tallis]] ) ) { if ( [[advancements]] . isInterface ( ) && ClassUtils . isAssignable ( [[tallis]] , [[advancements]] ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( [[tallis]] == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .


--------------------------------------------- Result 649 ---------------------------------------------
Gets the message by key . --> Uck for uck --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String [[key]] , Object ... args ) { return messagesApi . get ( lang , [[key]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[uck]] ( String [[trample]] , Object ... args ) { return messagesApi . get ( lang , [[trample]] , args ) ; }
[[[[Nl]]]]: Get the message at the given key .


--------------------------------------------- Result 650 ---------------------------------------------
Get message by key --> Retrieve specific messages --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String [[ble]] ( List < String > keys , Object ... args ) { return messagesApi . get ( lang , keys , args ) ; }
[[[[Nl]]]]: Get the message at the first defined key .


--------------------------------------------- Result 651 ---------------------------------------------
Creates a database from the specified parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String url , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , url , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[interruptus]] ( String [[shortages]] , String url , Map < String , ? extends Object > [[soy]] ) { return [[interruptus]] ( "default" , [[shortages]] , url , [[soy]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .


--------------------------------------------- Result 652 ---------------------------------------------
Create a new ParallelSorter . --> [[[FAILED]]]

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] [[arrays]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[arrays]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[tyin]] ( Object [ ] [[speedometer]] ) { Generator gen = new Generator ( ) ; gen . setArrays ( [[speedometer]] ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .


--------------------------------------------- Result 653 ---------------------------------------------
Simple quick sort . --> aller methods --> Socre: 1.0

[[[[Adv]]]]: public void [[quickSort]] ( int index , int [[lo]] , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( [[lo]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void [[aller]] ( int index , int [[backstory]] , int hi , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . quickSort ( [[backstory]] , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .


--------------------------------------------- Result 654 ---------------------------------------------
Merge sort . --> to simplify sorting --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int index , int lo , int [[hi]] , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , [[hi]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[aaah]] ( int index , int lo , int [[angelique]] , Comparator cmp ) { chooseComparer ( index , cmp ) ; super . mergeSort ( lo , [[angelique]] - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .


--------------------------------------------- Result 655 ---------------------------------------------
Invokes the wrapped method with the given arguments . --> protected for testing --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( Object [[obj]] , Object [ ] [[args]] ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , [[obj]] , [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object invoke ( Object [[prosecuted]] , Object [ ] [[hair]] ) throws Throwable { try { init ( ) ; FastClassInfo [[ofcourse]] = fastClassInfo ; return [[ofcourse]] . f1 . invoke ( [[ofcourse]] . i1 , [[prosecuted]] , [[hair]] ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .


--------------------------------------------- Result 656 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 432 / 208 / 16 / 656:  66%|██████▌   | 656/1000 [3:53:30<2:02:27, 21.36s/it][Succeeded / Failed / Skipped / Total] 432 / 208 / 16 / 656:  66%|██████▌   | 657/1000 [3:53:46<2:02:02, 21.35s/it][Succeeded / Failed / Skipped / Total] 432 / 209 / 16 / 657:  66%|██████▌   | 657/1000 [3:53:46<2:02:02, 21.35s/it][Succeeded / Failed / Skipped / Total] 432 / 209 / 16 / 657:  66%|██████▌   | 658/1000 [3:53:46<2:01:30, 21.32s/it][Succeeded / Failed / Skipped / Total] 432 / 209 / 17 / 658:  66%|██████▌   | 658/1000 [3:53:46<2:01:30, 21.32s/it][Succeeded / Failed / Skipped / Total] 432 / 209 / 17 / 658:  66%|██████▌   | 659/1000 [3:53:52<2:01:01, 21.29s/it][Succeeded / Failed / Skipped / Total] 433 / 209 / 17 / 659:  66%|██████▌   | 659/1000 [3:53:52<2:01:01, 21.29s/it][Succeeded / Failed / Skipped / Total] 433 / 209 / 17 / 659:  66%|██████▌   | 660/1000 [3:54:13<2:00:39, 21.29s/it][Succeeded / Failed / Skipped / Total] 434 / 209 / 17 / 660:  66%|██████▌   | 660/1000 [3:54:13<2:00:39, 21.29s/it][Succeeded / Failed / Skipped / Total] 434 / 209 / 17 / 660:  66%|██████▌   | 661/1000 [3:55:09<2:00:35, 21.34s/it]Cast an integer to the specified type . --> Cast a number . --> Socre: 1.0

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[to]] ) { if ( from != [[to]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else { if ( [[to]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[to]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[to]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[proofing]] ) { if ( from != [[proofing]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[proofing]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[proofing]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[proofing]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[proofing]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[proofing]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[proofing]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[proofing]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[proofing]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[proofing]] ) ; } } else { if ( [[proofing]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[proofing]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[proofing]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[proofing]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[proofing]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[proofing]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another


--------------------------------------------- Result 657 ---------------------------------------------
Loads the argument at the given index . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[guidelines]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .


--------------------------------------------- Result 658 ---------------------------------------------
Emit a field . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix


--------------------------------------------- Result 659 ---------------------------------------------
push a zero or null --> Mapping to lstype --> Socre: 1.0

[[[[Adv]]]]: public void [[zero_or_null]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void [[tolstoy]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { switch ( type . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .


--------------------------------------------- Result 660 ---------------------------------------------
Unbox a type or zero . --> Mark a type as alphanumeric --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label [[nonNull]] = make_label ( ) ; Label [[end]] = make_label ( ) ; dup ( ) ; ifnonnull ( [[nonNull]] ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[end]] ) ; mark ( [[nonNull]] ) ; unbox ( type ) ; mark ( [[end]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[alban]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label [[daydream]] = make_label ( ) ; Label [[aye]] = make_label ( ) ; dup ( ) ; ifnonnull ( [[daydream]] ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( [[aye]] ) ; mark ( [[daydream]] ) ; unbox ( type ) ; mark ( [[aye]] ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .


--------------------------------------------- Result 661 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 434 / 210 / 17 / 661:  66%|██████▌   | 661/1000 [3:55:09<2:00:35, 21.34s/it][Succeeded / Failed / Skipped / Total] 434 / 210 / 17 / 661:  66%|██████▌   | 662/1000 [3:55:18<2:00:08, 21.33s/it][Succeeded / Failed / Skipped / Total] 435 / 210 / 17 / 662:  66%|██████▌   | 662/1000 [3:55:18<2:00:08, 21.33s/it][Succeeded / Failed / Skipped / Total] 435 / 210 / 17 / 662:  66%|██████▋   | 663/1000 [3:56:22<2:00:09, 21.39s/it][Succeeded / Failed / Skipped / Total] 435 / 211 / 17 / 663:  66%|██████▋   | 663/1000 [3:56:22<2:00:09, 21.39s/it][Succeeded / Failed / Skipped / Total] 435 / 211 / 17 / 663:  66%|██████▋   | 664/1000 [3:56:39<1:59:45, 21.38s/it][Succeeded / Failed / Skipped / Total] 436 / 211 / 17 / 664:  66%|██████▋   | 664/1000 [3:56:39<1:59:45, 21.38s/it][Succeeded / Failed / Skipped / Total] 436 / 211 / 17 / 664:  66%|██████▋   | 665/1000 [3:57:14<1:59:30, 21.41s/it]Process an array element . --> [[[FAILED]]]

[[[[Adv]]]]: public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label [[loopbody]] = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( [[loopbody]] ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , [[loopbody]] ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void process_array ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local array = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label [[cambodian]] = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( array ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( [[cambodian]] ) ; e . load_local ( array ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( array ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , [[cambodian]] ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .


--------------------------------------------- Result 662 ---------------------------------------------
implement the null operator --> implement a NullPointerException --> Socre: 1.0

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[end]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[end]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( [[end]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void nullcmp ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label [[contraption]] = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( [[contraption]] ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( [[contraption]] ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .


--------------------------------------------- Result 663 ---------------------------------------------
Resolves all bridge dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set [[bridges]] = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( [[bridges]] , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[marmota]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class owner = ( Class ) entry . getKey ( ) ; Set [[henkel]] = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( owner . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( [[henkel]] , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .


--------------------------------------------- Result 664 ---------------------------------------------
Finds all methods in the superclass and interfaces . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[getMethods]] ( Class [[superclass]] , Class [ ] interfaces , List methods ) { [[getMethods]] ( [[superclass]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[corporeal]] ( Class [[ángeles]] , Class [ ] interfaces , List methods ) { [[corporeal]] ( [[ángeles]] , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .


--------------------------------------------- Result 665 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 436 / 212 / 17 / 665:  66%|██████▋   | 665/1000 [3:57:14<1:59:30, 21.41s/it][Succeeded / Failed / Skipped / Total] 436 / 212 / 17 / 665:  67%|██████▋   | 666/1000 [3:57:34<1:59:08, 21.40s/it][Succeeded / Failed / Skipped / Total] 436 / 213 / 17 / 666:  67%|██████▋   | 666/1000 [3:57:34<1:59:08, 21.40s/it][Succeeded / Failed / Skipped / Total] 436 / 213 / 17 / 666:  67%|██████▋   | 667/1000 [3:57:34<1:58:36, 21.37s/it][Succeeded / Failed / Skipped / Total] 436 / 213 / 18 / 667:  67%|██████▋   | 667/1000 [3:57:34<1:58:36, 21.37s/it][Succeeded / Failed / Skipped / Total] 436 / 213 / 18 / 667:  67%|██████▋   | 668/1000 [3:57:47<1:58:10, 21.36s/it][Succeeded / Failed / Skipped / Total] 437 / 213 / 18 / 668:  67%|██████▋   | 668/1000 [3:57:47<1:58:10, 21.36s/it][Succeeded / Failed / Skipped / Total] 437 / 213 / 18 / 668:  67%|██████▋   | 669/1000 [3:57:47<1:57:39, 21.33s/it][Succeeded / Failed / Skipped / Total] 437 / 213 / 19 / 669:  67%|██████▋   | 669/1000 [3:57:47<1:57:39, 21.33s/it][Succeeded / Failed / Skipped / Total] 437 / 213 / 19 / 669:  67%|██████▋   | 670/1000 [3:58:09<1:57:18, 21.33s/it][Succeeded / Failed / Skipped / Total] 437 / 214 / 19 / 670:  67%|██████▋   | 670/1000 [3:58:09<1:57:18, 21.33s/it][Succeeded / Failed / Skipped / Total] 437 / 214 / 19 / 670:  67%|██████▋   | 671/1000 [3:58:09<1:56:46, 21.30s/it][Succeeded / Failed / Skipped / Total] 437 / 214 / 20 / 671:  67%|██████▋   | 671/1000 [3:58:09<1:56:46, 21.30s/it][Succeeded / Failed / Skipped / Total] 437 / 214 / 20 / 671:  67%|██████▋   | 672/1000 [3:58:27<1:56:23, 21.29s/it][Succeeded / Failed / Skipped / Total] 437 / 215 / 20 / 672:  67%|██████▋   | 672/1000 [3:58:27<1:56:23, 21.29s/it][Succeeded / Failed / Skipped / Total] 437 / 215 / 20 / 672:  67%|██████▋   | 673/1000 [3:58:51<1:56:03, 21.29s/it][Succeeded / Failed / Skipped / Total] 437 / 216 / 20 / 673:  67%|██████▋   | 673/1000 [3:58:51<1:56:03, 21.29s/it][Succeeded / Failed / Skipped / Total] 437 / 216 / 20 / 673:  67%|██████▋   | 674/1000 [3:59:16<1:55:43, 21.30s/it][Succeeded / Failed / Skipped / Total] 437 / 217 / 20 / 674:  67%|██████▋   | 674/1000 [3:59:16<1:55:43, 21.30s/it][Succeeded / Failed / Skipped / Total] 437 / 217 / 20 / 674:  68%|██████▊   | 675/1000 [3:59:41<1:55:24, 21.31s/it]Removes all visible constructors in the given class . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class [[sc]] , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( [[sc]] , True ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[sc]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[capitulate]] ( Class [[rocky]] , List [[frowning]] ) { CollectionUtils . filter ( [[frowning]] , new VisibilityPredicate ( [[rocky]] , True ) ) ; if ( [[frowning]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + [[rocky]] ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .


--------------------------------------------- Result 666 ---------------------------------------------
Sets the super class . --> [[[FAILED]]]

[[[[Adv]]]]: public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[superclass]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void setSuperclass ( Class superclass ) { if ( superclass != null && superclass . equals ( Object . class ) ) { superclass = null ; } this . [[chester]] = superclass ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .


--------------------------------------------- Result 667 ---------------------------------------------
Gets the field with the given names . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities


--------------------------------------------- Result 668 ---------------------------------------------
Add a method . --> Benno seconds --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[benno]] ( Method [[centuries]] ) { [[benno]] ( ReflectUtils . getSignature ( [[centuries]] ) , ReflectUtils . getExceptionTypes ( [[centuries]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .


--------------------------------------------- Result 669 ---------------------------------------------
Get the cardinality of the value --> [[[SKIPPED]]]

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .


--------------------------------------------- Result 670 ---------------------------------------------
Sets the naming policy . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[outlines]] ( NamingPolicy [[debit]] ) { if ( [[debit]] == null ) [[debit]] = DefaultNamingPolicy . INSTANCE ; this . [[symbolically]] = [[debit]] ; }
[[[[Nl]]]]: Override the default naming policy .


--------------------------------------------- Result 671 ---------------------------------------------
Finds the array of methods in the given array . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code


--------------------------------------------- Result 672 ---------------------------------------------
Resolve child path . --> [[[FAILED]]]

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[reused]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .


--------------------------------------------- Result 673 ---------------------------------------------
Reads a string from the specified path . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[readString]] ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String [[frollo]] ( final Path [[haf]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[haf]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .


--------------------------------------------- Result 674 ---------------------------------------------
Sets the request host . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . host = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[guglielmo]] ( final String [[lacroix]] ) { this . host = [[guglielmo]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[guglielmo]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .


--------------------------------------------- Result 675 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 438 / 217 / 20 / 675:  68%|██████▊   | 675/1000 [3:59:41<1:55:24, 21.31s/it][Succeeded / Failed / Skipped / Total] 438 / 217 / 20 / 675:  68%|██████▊   | 676/1000 [3:59:55<1:54:59, 21.30s/it][Succeeded / Failed / Skipped / Total] 439 / 217 / 20 / 676:  68%|██████▊   | 676/1000 [3:59:55<1:54:59, 21.30s/it][Succeeded / Failed / Skipped / Total] 439 / 217 / 20 / 676:  68%|██████▊   | 677/1000 [4:00:06<1:54:33, 21.28s/it][Succeeded / Failed / Skipped / Total] 439 / 218 / 20 / 677:  68%|██████▊   | 677/1000 [4:00:06<1:54:33, 21.28s/it][Succeeded / Failed / Skipped / Total] 439 / 218 / 20 / 677:  68%|██████▊   | 678/1000 [4:00:20<1:54:08, 21.27s/it][Succeeded / Failed / Skipped / Total] 439 / 219 / 20 / 678:  68%|██████▊   | 678/1000 [4:00:20<1:54:08, 21.27s/it][Succeeded / Failed / Skipped / Total] 439 / 219 / 20 / 678:  68%|██████▊   | 679/1000 [4:00:33<1:53:43, 21.26s/it][Succeeded / Failed / Skipped / Total] 439 / 220 / 20 / 679:  68%|██████▊   | 679/1000 [4:00:33<1:53:43, 21.26s/it][Succeeded / Failed / Skipped / Total] 439 / 220 / 20 / 679:  68%|██████▊   | 680/1000 [4:00:45<1:53:17, 21.24s/it][Succeeded / Failed / Skipped / Total] 439 / 221 / 20 / 680:  68%|██████▊   | 680/1000 [4:00:45<1:53:17, 21.24s/it][Succeeded / Failed / Skipped / Total] 439 / 221 / 20 / 680:  68%|██████▊   | 681/1000 [4:00:51<1:52:49, 21.22s/it][Succeeded / Failed / Skipped / Total] 440 / 221 / 20 / 681:  68%|██████▊   | 681/1000 [4:00:51<1:52:49, 21.22s/it][Succeeded / Failed / Skipped / Total] 440 / 221 / 20 / 681:  68%|██████▊   | 682/1000 [4:01:05<1:52:24, 21.21s/it][Succeeded / Failed / Skipped / Total] 441 / 221 / 20 / 682:  68%|██████▊   | 682/1000 [4:01:05<1:52:24, 21.21s/it][Succeeded / Failed / Skipped / Total] 441 / 221 / 20 / 682:  68%|██████▊   | 683/1000 [4:01:16<1:51:59, 21.20s/it][Succeeded / Failed / Skipped / Total] 441 / 222 / 20 / 683:  68%|██████▊   | 683/1000 [4:01:16<1:51:59, 21.20s/it][Succeeded / Failed / Skipped / Total] 441 / 222 / 20 / 683:  68%|██████▊   | 684/1000 [4:01:28<1:51:33, 21.18s/it][Succeeded / Failed / Skipped / Total] 442 / 222 / 20 / 684:  68%|██████▊   | 684/1000 [4:01:28<1:51:33, 21.18s/it][Succeeded / Failed / Skipped / Total] 442 / 222 / 20 / 684:  68%|██████▊   | 685/1000 [4:01:42<1:51:08, 21.17s/it][Succeeded / Failed / Skipped / Total] 443 / 222 / 20 / 685:  68%|██████▊   | 685/1000 [4:01:42<1:51:08, 21.17s/it][Succeeded / Failed / Skipped / Total] 443 / 222 / 20 / 685:  69%|██████▊   | 686/1000 [4:02:30<1:51:00, 21.21s/it]Create a HttpRequest with the given destination and destination . --> Liefert --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[create]] ( final String [[method]] , final String [[destination]] ) { return new HttpRequest ( ) . [[method]] ( [[method]] . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest [[clasping]] ( final String [[letdown]] , final String [[thé]] ) { return new HttpRequest ( ) . [[letdown]] ( [[letdown]] . toUpperCase ( ) ) . set ( [[thé]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .


--------------------------------------------- Result 676 ---------------------------------------------
Start a connect request --> Sets the bridge for the given clunky method --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[connect]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest [[bridgeport]] ( final String [[clunky]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[clunky]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .


--------------------------------------------- Result 677 ---------------------------------------------
Create a GET request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[classless]] ( final String [[circu]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[circu]] ) ; }
[[[[Nl]]]]: Builds a GET request .


--------------------------------------------- Result 678 ---------------------------------------------
Start HTTP POST request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[unladylike]] ( final String [[skipping]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[skipping]] ) ; }
[[[[Nl]]]]: Builds a POST request .


--------------------------------------------- Result 679 ---------------------------------------------
Create a PUT request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[cartman]] ( final String [[emboldened]] ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( [[emboldened]] ) ; }
[[[[Nl]]]]: Builds a PUT request .


--------------------------------------------- Result 680 ---------------------------------------------
Create a PATCH request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[allure]] ( final String [[regardless]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[regardless]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .


--------------------------------------------- Result 681 ---------------------------------------------
Create a DELETE request --> Posts an indy media to the given destination --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[indymedia]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a DELETE request .


--------------------------------------------- Result 682 ---------------------------------------------
Create a HEAD request --> Shortcut method for creating an HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[irresponsibly]] ( final String [[kagawa]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[kagawa]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .


--------------------------------------------- Result 683 ---------------------------------------------
Start a TRACE request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[costume]] ( final String [[tlhe]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[tlhe]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .


--------------------------------------------- Result 684 ---------------------------------------------
Create a OPTIONS request --> Sets a new HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[greenfield]] ( final String [[wet]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[wet]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .


--------------------------------------------- Result 685 ---------------------------------------------
Sets the request path . --> set aggressor --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[aggressor]] ( String [[sattler]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .


--------------------------------------------- Result 686 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 444 / 222 / 20 / 686:  69%|██████▊   | 686/1000 [4:02:30<1:51:00, 21.21s/it][Succeeded / Failed / Skipped / Total] 444 / 222 / 20 / 686:  69%|██████▊   | 687/1000 [4:02:55<1:50:40, 21.22s/it][Succeeded / Failed / Skipped / Total] 445 / 222 / 20 / 687:  69%|██████▊   | 687/1000 [4:02:55<1:50:40, 21.22s/it][Succeeded / Failed / Skipped / Total] 445 / 222 / 20 / 687:  69%|██████▉   | 688/1000 [4:03:00<1:50:12, 21.19s/it][Succeeded / Failed / Skipped / Total] 446 / 222 / 20 / 688:  69%|██████▉   | 688/1000 [4:03:00<1:50:12, 21.19s/it][Succeeded / Failed / Skipped / Total] 446 / 222 / 20 / 688:  69%|██████▉   | 689/1000 [4:03:07<1:49:44, 21.17s/it][Succeeded / Failed / Skipped / Total] 447 / 222 / 20 / 689:  69%|██████▉   | 689/1000 [4:03:07<1:49:44, 21.17s/it][Succeeded / Failed / Skipped / Total] 447 / 222 / 20 / 689:  69%|██████▉   | 690/1000 [4:03:14<1:49:16, 21.15s/it][Succeeded / Failed / Skipped / Total] 448 / 222 / 20 / 690:  69%|██████▉   | 690/1000 [4:03:14<1:49:16, 21.15s/it][Succeeded / Failed / Skipped / Total] 448 / 222 / 20 / 690:  69%|██████▉   | 691/1000 [4:03:27<1:48:52, 21.14s/it][Succeeded / Failed / Skipped / Total] 449 / 222 / 20 / 691:  69%|██████▉   | 691/1000 [4:03:27<1:48:52, 21.14s/it][Succeeded / Failed / Skipped / Total] 449 / 222 / 20 / 691:  69%|██████▉   | 692/1000 [4:03:45<1:48:29, 21.14s/it][Succeeded / Failed / Skipped / Total] 450 / 222 / 20 / 692:  69%|██████▉   | 692/1000 [4:03:45<1:48:29, 21.14s/it][Succeeded / Failed / Skipped / Total] 450 / 222 / 20 / 692:  69%|██████▉   | 693/1000 [4:03:57<1:48:04, 21.12s/it][Succeeded / Failed / Skipped / Total] 451 / 222 / 20 / 693:  69%|██████▉   | 693/1000 [4:03:57<1:48:04, 21.12s/it][Succeeded / Failed / Skipped / Total] 451 / 222 / 20 / 693:  69%|██████▉   | 694/1000 [4:04:04<1:47:37, 21.10s/it]Sets the cookies in the request . --> Set Cookie headers --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[REPLACEME0]] ( final Cookie ... [[REPLACEME0]] ) { if ( [[REPLACEME0]] . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean first = True ; for ( Cookie [[cookie]] : [[REPLACEME0]] ) { Integer maxAge = [[cookie]] . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[cookieString]] . append ( "; " ) ; } first = "[[False]]" != "[[False]]" ; [[cookieString]] . append ( [[cookie]] . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( [[cookie]] . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest [[EP]] ( final Cookie ... [[EP]] ) { if ( [[EP]] . length == 0 ) { return this ; } StringBuilder [[anjo]] = new StringBuilder ( ) ; boolean first = True ; for ( Cookie [[custodians]] : [[EP]] ) { Integer maxAge = [[custodians]] . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[anjo]] . append ( "; " ) ; } first = "[["Tamale" != "Tamale"]]" != "[["Tamale" != "Tamale"]]" ; [[anjo]] . append ( [[custodians]] . getName ( ) ) ; [[anjo]] . append ( ' ' ) ; [[anjo]] . append ( [[custodians]] . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[anjo]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .


--------------------------------------------- Result 687 ---------------------------------------------
Adds a query parameter to the request . --> Add an additional request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final String name1 , final Object [[value1]] , final Object ... parameters ) { [[query]] ( name1 , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String [[name]] = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; [[query]] . add ( [[name]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest [[anju]] ( final String name1 , final Object [[aguirre]] , final Object ... parameters ) { [[anju]] ( name1 , [[aguirre]] == null ? null : [[aguirre]] . toString ( ) ) ; for ( int i = 0 ; i < parameters . length ; i += 2 ) { String [[ven]] = parameters [ i ] . toString ( ) ; String value = parameters [ i + 1 ] . toString ( ) ; [[anju]] . add ( [[ven]] , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .


--------------------------------------------- Result 688 ---------------------------------------------
Add a query map . --> Add query --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[entry]] : queryMap . entrySet ( ) ) { query . add ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest query ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > [[spirituality]] : queryMap . entrySet ( ) ) { query . add ( [[spirituality]] . getKey ( ) , [[spirituality]] . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .


--------------------------------------------- Result 689 ---------------------------------------------
Set the query parameter . --> Set the Http request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( [[queryString]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[antiquated]] ( final String queryString , final boolean decode ) { this . query = HttpUtil . parseQuery ( [[antiquated]] , decode ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .


--------------------------------------------- Result 690 ---------------------------------------------
Gets the query string . --> Retrieves the complete list of flows --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[flows]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .


--------------------------------------------- Result 691 ---------------------------------------------
Returns the full URL . --> Builds a barney barcode --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand [[url]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[url]] . append ( protocol ) ; [[url]] . append ( "://" ) ; } if ( host != null ) { [[url]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[url]] . append ( ' ' ) ; [[url]] . append ( port ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[bars]] ( ) { StringBand [[stepney]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[stepney]] . append ( protocol ) ; [[stepney]] . append ( "://" ) ; } if ( host != null ) { [[stepney]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[stepney]] . append ( ' ' ) ; [[stepney]] . append ( port ) ; } return [[stepney]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .


--------------------------------------------- Result 692 ---------------------------------------------
Sets the basic authentication header . --> Add a username and password --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String username , final String password ) { if ( username != null && password != null ) { String [[data]] = username . concat ( StringPool . COLON ) . concat ( password ) ; String [[base64]] = Base64 . encodeToString ( [[data]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[base64]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[zette]] ( final String username , final String password ) { if ( username != null && password != null ) { String [[priestess]] = username . concat ( StringPool . COLON ) . concat ( password ) ; String [[afterglow]] = Base64 . encodeToString ( [[priestess]] ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[afterglow]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .


--------------------------------------------- Result 693 ---------------------------------------------
Sets the host header . --> A Http request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String [[hostPort]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[hostPort]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[hostPort]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[aqaba]] ( ) { String [[niente]] = this . host ; if ( port != Defaults . DEFAULT_PORT ) { [[niente]] += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , [[niente]] ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .


--------------------------------------------- Result 694 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 452 / 222 / 20 / 694:  69%|██████▉   | 694/1000 [4:04:04<1:47:37, 21.10s/it][Succeeded / Failed / Skipped / Total] 452 / 222 / 20 / 694:  70%|██████▉   | 695/1000 [4:04:11<1:47:09, 21.08s/it][Succeeded / Failed / Skipped / Total] 453 / 222 / 20 / 695:  70%|██████▉   | 695/1000 [4:04:11<1:47:09, 21.08s/it][Succeeded / Failed / Skipped / Total] 453 / 222 / 20 / 695:  70%|██████▉   | 696/1000 [4:04:28<1:46:46, 21.07s/it][Succeeded / Failed / Skipped / Total] 454 / 222 / 20 / 696:  70%|██████▉   | 696/1000 [4:04:28<1:46:46, 21.07s/it][Succeeded / Failed / Skipped / Total] 454 / 222 / 20 / 696:  70%|██████▉   | 697/1000 [4:04:51<1:46:26, 21.08s/it][Succeeded / Failed / Skipped / Total] 455 / 222 / 20 / 697:  70%|██████▉   | 697/1000 [4:04:51<1:46:26, 21.08s/it][Succeeded / Failed / Skipped / Total] 455 / 222 / 20 / 697:  70%|██████▉   | 698/1000 [4:05:07<1:46:03, 21.07s/it][Succeeded / Failed / Skipped / Total] 455 / 223 / 20 / 698:  70%|██████▉   | 698/1000 [4:05:07<1:46:03, 21.07s/it][Succeeded / Failed / Skipped / Total] 455 / 223 / 20 / 698:  70%|██████▉   | 699/1000 [4:05:21<1:45:39, 21.06s/it][Succeeded / Failed / Skipped / Total] 456 / 223 / 20 / 699:  70%|██████▉   | 699/1000 [4:05:21<1:45:39, 21.06s/it][Succeeded / Failed / Skipped / Total] 456 / 223 / 20 / 699:  70%|███████   | 700/1000 [4:05:34<1:45:14, 21.05s/it][Succeeded / Failed / Skipped / Total] 456 / 224 / 20 / 700:  70%|███████   | 700/1000 [4:05:34<1:45:14, 21.05s/it][Succeeded / Failed / Skipped / Total] 456 / 224 / 20 / 700:  70%|███████   | 701/1000 [4:05:42<1:44:48, 21.03s/it][Succeeded / Failed / Skipped / Total] 457 / 224 / 20 / 701:  70%|███████   | 701/1000 [4:05:42<1:44:48, 21.03s/it][Succeeded / Failed / Skipped / Total] 457 / 224 / 20 / 701:  70%|███████   | 702/1000 [4:05:56<1:44:24, 21.02s/it][Succeeded / Failed / Skipped / Total] 458 / 224 / 20 / 702:  70%|███████   | 702/1000 [4:05:56<1:44:24, 21.02s/it][Succeeded / Failed / Skipped / Total] 458 / 224 / 20 / 702:  70%|███████   | 703/1000 [4:06:18<1:44:03, 21.02s/it]Returns the buffer . --> Implementation of muta --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer [[buffer]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer [[muta]] ( final boolean fullRequest ) {
[[[[Nl]]]]: Prepares the request buffer .


--------------------------------------------- Result 695 ---------------------------------------------
Execute and receive response . --> Inject and receive response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[oppress]] > [[oppress]] sendAndReceive ( final Function < HttpResponse , [[oppress]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .


--------------------------------------------- Result 696 ---------------------------------------------
Remove range . --> Private helper for backward compatibility --> Socre: 1.0

[[[[Adv]]]]: static Handler [[removeRange]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[removeRange]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler [[darla]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[darla]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .


--------------------------------------------- Result 697 ---------------------------------------------
Gets the length of the exception table . --> Calculate lucidity --> Socre: 1.0

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler firstHandler ) { int [[length]] = 0 ; Handler handler = firstHandler ; while ( handler != null ) { [[length]] ++ ; handler = handler . nextHandler ; } return [[length]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[lucidity]] ( final Handler firstHandler ) { int [[fredrickson]] = 0 ; Handler handler = firstHandler ; while ( handler != null ) { [[fredrickson]] ++ ; handler = handler . nextHandler ; } return [[fredrickson]] ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .


--------------------------------------------- Result 698 ---------------------------------------------
Collect all action interceptors . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[issues]] ( ) { final Collection < ? extends ActionInterceptor > [[jockey]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[jockey]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .


--------------------------------------------- Result 699 ---------------------------------------------
Collects the action filters . --> Perform a dujour --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > [[filterValues]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[filterValues]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[dujour]] ( ) { final Collection < ? extends ActionFilter > [[intern]] = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( [[intern]] ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .


--------------------------------------------- Result 700 ---------------------------------------------
Collects all action results . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > [[resultsValues]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[resultsValues]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[costanza]] ( ) { final Collection < ActionResult > [[blackman]] = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( [[blackman]] ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .


--------------------------------------------- Result 701 ---------------------------------------------
Collects all actions available in the application . --> sort actions in parallel --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[araby]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .


--------------------------------------------- Result 702 ---------------------------------------------
Sets the simple property . --> Convenience method for Java BeanProperty --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object [[value]] ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[langston]] ( final BeanProperty bp , final Object [[amedeo]] ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .


--------------------------------------------- Result 703 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 458 / 225 / 20 / 703:  70%|███████   | 703/1000 [4:06:18<1:44:03, 21.02s/it][Succeeded / Failed / Skipped / Total] 458 / 225 / 20 / 703:  70%|███████   | 704/1000 [4:06:40<1:43:43, 21.02s/it][Succeeded / Failed / Skipped / Total] 459 / 225 / 20 / 704:  70%|███████   | 704/1000 [4:06:40<1:43:43, 21.02s/it][Succeeded / Failed / Skipped / Total] 459 / 225 / 20 / 704:  70%|███████   | 705/1000 [4:06:48<1:43:16, 21.01s/it][Succeeded / Failed / Skipped / Total] 459 / 226 / 20 / 705:  70%|███████   | 705/1000 [4:06:48<1:43:16, 21.01s/it][Succeeded / Failed / Skipped / Total] 459 / 226 / 20 / 705:  71%|███████   | 706/1000 [4:07:03<1:42:53, 21.00s/it][Succeeded / Failed / Skipped / Total] 460 / 226 / 20 / 706:  71%|███████   | 706/1000 [4:07:03<1:42:53, 21.00s/it][Succeeded / Failed / Skipped / Total] 460 / 226 / 20 / 706:  71%|███████   | 707/1000 [4:07:09<1:42:25, 20.98s/it][Succeeded / Failed / Skipped / Total] 461 / 226 / 20 / 707:  71%|███████   | 707/1000 [4:07:09<1:42:25, 20.98s/it][Succeeded / Failed / Skipped / Total] 461 / 226 / 20 / 707:  71%|███████   | 708/1000 [4:07:29<1:42:04, 20.97s/it][Succeeded / Failed / Skipped / Total] 462 / 226 / 20 / 708:  71%|███████   | 708/1000 [4:07:29<1:42:04, 20.97s/it][Succeeded / Failed / Skipped / Total] 462 / 226 / 20 / 708:  71%|███████   | 709/1000 [4:07:55<1:41:45, 20.98s/it][Succeeded / Failed / Skipped / Total] 462 / 227 / 20 / 709:  71%|███████   | 709/1000 [4:07:55<1:41:45, 20.98s/it][Succeeded / Failed / Skipped / Total] 462 / 227 / 20 / 709:  71%|███████   | 710/1000 [4:08:15<1:41:24, 20.98s/it][Succeeded / Failed / Skipped / Total] 463 / 227 / 20 / 710:  71%|███████   | 710/1000 [4:08:15<1:41:24, 20.98s/it][Succeeded / Failed / Skipped / Total] 463 / 227 / 20 / 710:  71%|███████   | 711/1000 [4:08:38<1:41:03, 20.98s/it][Succeeded / Failed / Skipped / Total] 464 / 227 / 20 / 711:  71%|███████   | 711/1000 [4:08:38<1:41:03, 20.98s/it][Succeeded / Failed / Skipped / Total] 464 / 227 / 20 / 711:  71%|███████   | 712/1000 [4:09:16<1:40:49, 21.01s/it]Returns the index property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[inebriate]] > [[inebriate]] getProperty ( final Object bean , final String name ) { BeanProperty [[disagreeable]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[disagreeable]] ) ; return ( [[inebriate]] ) getIndexProperty ( [[disagreeable]] ) ; } else { try { resolveNestedProperties ( [[disagreeable]] ) ; return ( [[inebriate]] ) getIndexProperty ( [[disagreeable]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .


--------------------------------------------- Result 704 ---------------------------------------------
Extracts the property name from the property name . --> Retrieves a few timeseries from a string --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[days]] ( final String [[jokes]] ) { int [[lateness]] = StringUtil . indexOfChars ( [[jokes]] , INDEX_CHARS ) ; if ( [[lateness]] == - 1 ) { return [[jokes]] ; } return [[jokes]] . substring ( 0 , [[lateness]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .


--------------------------------------------- Result 705 ---------------------------------------------
Returns the writer . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[wawa]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .


--------------------------------------------- Result 706 ---------------------------------------------
Sets the object reference . --> Add a footstool for the specified method --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String [[name]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[name]] , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[footstool]] ( final String [[methadone]] , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( [[methadone]] , object ) ; }
[[[[Nl]]]]: Saves object reference .


--------------------------------------------- Result 707 ---------------------------------------------
Get object reference by name . --> Get harada by name --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[harada]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .


--------------------------------------------- Result 708 ---------------------------------------------
Lookup an object reference . --> Renames a spatial --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object value = getObjectReference ( [[ref]] ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[renie]] ( final String [[spatial]] ) { Object value = getObjectReference ( [[spatial]] ) ; if ( value == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[spatial]] ) ; } return value ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .


--------------------------------------------- Result 709 ---------------------------------------------
Returns the descriptor for the given table reference . --> [[[FAILED]]]

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[t]] = tableRefs . get ( [[tableRef]] ) ; return [[t]] == null ? null : [[t]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[winches]] ( final String [[crusted]] ) { if ( tableRefs == null ) { return null ; } TableRefData [[closures]] = tableRefs . get ( [[crusted]] ) ; return [[closures]] == null ? null : [[closures]] . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .


--------------------------------------------- Result 710 ---------------------------------------------
Find table descriptor by column ref . --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[findTableDescriptorByColumnRef]] ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > [[entry]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = [[entry]] . getValue ( ) . desc ; if ( ded . findByPropertyName ( [[columnRef]] ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor [[clocking]] ( final String [[gangway]] ) { for ( Map . Entry < String , TableRefData > [[viscount]] : tableRefs . entrySet ( ) ) { DbEntityDescriptor ded = [[viscount]] . getValue ( ) . desc ; if ( ded . findByPropertyName ( [[gangway]] ) != null ) { return ded ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .


--------------------------------------------- Result 711 ---------------------------------------------
Returns the alias for the specified table reference . --> Gets the Mernage of a given adri --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[ménage]] ( final String [[adriana]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[adriana]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .


--------------------------------------------- Result 712 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 464 / 228 / 20 / 712:  71%|███████   | 712/1000 [4:09:16<1:40:49, 21.01s/it][Succeeded / Failed / Skipped / Total] 464 / 228 / 20 / 712:  71%|███████▏  | 713/1000 [4:09:39<1:40:29, 21.01s/it][Succeeded / Failed / Skipped / Total] 464 / 229 / 20 / 713:  71%|███████▏  | 713/1000 [4:09:39<1:40:29, 21.01s/it][Succeeded / Failed / Skipped / Total] 464 / 229 / 20 / 713:  71%|███████▏  | 714/1000 [4:09:52<1:40:05, 21.00s/it][Succeeded / Failed / Skipped / Total] 464 / 230 / 20 / 714:  71%|███████▏  | 714/1000 [4:09:52<1:40:05, 21.00s/it][Succeeded / Failed / Skipped / Total] 464 / 230 / 20 / 714:  72%|███████▏  | 715/1000 [4:10:00<1:39:39, 20.98s/it][Succeeded / Failed / Skipped / Total] 465 / 230 / 20 / 715:  72%|███████▏  | 715/1000 [4:10:00<1:39:39, 20.98s/it][Succeeded / Failed / Skipped / Total] 465 / 230 / 20 / 715:  72%|███████▏  | 716/1000 [4:11:09<1:39:37, 21.05s/it][Succeeded / Failed / Skipped / Total] 465 / 231 / 20 / 716:  72%|███████▏  | 716/1000 [4:11:09<1:39:37, 21.05s/it][Succeeded / Failed / Skipped / Total] 465 / 231 / 20 / 716:  72%|███████▏  | 717/1000 [4:12:47<1:39:46, 21.15s/it][Succeeded / Failed / Skipped / Total] 466 / 231 / 20 / 717:  72%|███████▏  | 717/1000 [4:12:47<1:39:46, 21.15s/it][Succeeded / Failed / Skipped / Total] 466 / 231 / 20 / 717:  72%|███████▏  | 718/1000 [4:14:14<1:39:51, 21.25s/it]Register a table reference --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[cobweb]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .


--------------------------------------------- Result 713 ---------------------------------------------
Looks up a table reference . --> [[[FAILED]]]

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String [[tableRef]] ) { DbEntityDescriptor [[ded]] = getTableDescriptor ( [[tableRef]] ) ; if ( [[ded]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[tableRef]] ) ; } return [[ded]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[hulme]] ( final String [[takeo]] ) { DbEntityDescriptor [[batavia]] = getTableDescriptor ( [[takeo]] ) ; if ( [[batavia]] == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + [[takeo]] ) ; } return [[batavia]] ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .


--------------------------------------------- Result 714 ---------------------------------------------
Registers a hint . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerHint]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[nightingales]] ( final String hint ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( hint ) ; }
[[[[Nl]]]]: Registers a hint .


--------------------------------------------- Result 715 ---------------------------------------------
Helper method for serialization . --> Serialize to JsonContext --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[value]] ) { if ( jsonContext . pushValue ( [[value]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext jsonContext , final T [[cranio]] ) { if ( jsonContext . pushValue ( [[cranio]] ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .


--------------------------------------------- Result 716 ---------------------------------------------
Inject attribute values . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > [[attributeNames]] = servletRequest . getAttributeNames ( ) ; while ( [[attributeNames]] . hasMoreElements ( ) ) { final String attrName = [[attributeNames]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[[True]]" == "[[True]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[ensuring]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > [[mina]] = servletRequest . getAttributeNames ( ) ; while ( [[mina]] . hasMoreElements ( ) ) { final String attrName = [[mina]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[["Beggars" == "Beggars"]]" == "[["Beggars" == "Beggars"]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .


--------------------------------------------- Result 717 ---------------------------------------------
Inject parameters in the request . --> For testing only --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectParameters]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean [[encode]] = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[paramName]] = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( [[paramName]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String [[name]] = in . matchedName ( [[paramName]] ) ; if ( [[name]] != null ) { String [ ] [[paramValues]] = servletRequest . getParameterValues ( [[paramName]] ) ; [[paramValues]] = ServletUtil . prepareParameters ( [[paramValues]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[paramValues]] != null ) { if ( [[encode]] ) { for ( int j = 0 ; j < [[paramValues]] . length ; j ++ ) { final String p = [[paramValues]] [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; [[paramValues]] [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( [[paramValues]] . length != 1 ? [[paramValues]] : [[paramValues]] [ 0 ] ) ; target . writeValue ( [[name]] , value , True ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void [[barnstable]] ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean [[favored]] = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[amply]] = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( [[amply]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String [[clogging]] = in . matchedName ( [[amply]] ) ; if ( [[clogging]] != null ) { String [ ] [[talkies]] = servletRequest . getParameterValues ( [[amply]] ) ; [[talkies]] = ServletUtil . prepareParameters ( [[talkies]] , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( [[talkies]] != null ) { if ( [[favored]] ) { for ( int j = 0 ; j < [[talkies]] . length ; j ++ ) { final String p = [[talkies]] [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; [[talkies]] [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( [[talkies]] . length != 1 ? [[talkies]] : [[talkies]] [ 0 ] ) ; target . writeValue ( [[clogging]] , value , True ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .


--------------------------------------------- Result 718 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 467 / 231 / 20 / 718:  72%|███████▏  | 718/1000 [4:14:14<1:39:51, 21.25s/it][Succeeded / Failed / Skipped / Total] 467 / 231 / 20 / 718:  72%|███████▏  | 719/1000 [4:14:28<1:39:27, 21.24s/it][Succeeded / Failed / Skipped / Total] 468 / 231 / 20 / 719:  72%|███████▏  | 719/1000 [4:14:28<1:39:27, 21.24s/it][Succeeded / Failed / Skipped / Total] 468 / 231 / 20 / 719:  72%|███████▏  | 720/1000 [4:15:11<1:39:14, 21.27s/it][Succeeded / Failed / Skipped / Total] 469 / 231 / 20 / 720:  72%|███████▏  | 720/1000 [4:15:11<1:39:14, 21.27s/it][Succeeded / Failed / Skipped / Total] 469 / 231 / 20 / 720:  72%|███████▏  | 721/1000 [4:15:17<1:38:47, 21.25s/it][Succeeded / Failed / Skipped / Total] 470 / 231 / 20 / 721:  72%|███████▏  | 721/1000 [4:15:17<1:38:47, 21.25s/it][Succeeded / Failed / Skipped / Total] 470 / 231 / 20 / 721:  72%|███████▏  | 722/1000 [4:15:49<1:38:30, 21.26s/it][Succeeded / Failed / Skipped / Total] 471 / 231 / 20 / 722:  72%|███████▏  | 722/1000 [4:15:49<1:38:30, 21.26s/it][Succeeded / Failed / Skipped / Total] 471 / 231 / 20 / 722:  72%|███████▏  | 723/1000 [4:15:57<1:38:03, 21.24s/it]Inject uploaded files . --> Tell the uzma for the specified uzma --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectUploadedFiles]] ( final HttpServletRequest [[servletRequest]] , final Targets targets ) { if ( ! ( [[servletRequest]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[multipartRequest]] = ( MultipartRequestWrapper ) [[servletRequest]] ; if ( ! [[multipartRequest]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[multipartRequest]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[paramName]] = paramNames . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( [[paramName]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[paramName]] ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[multipartRequest]] . getFiles ( [[paramName]] ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , True ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void [[hearse]] ( final HttpServletRequest [[uzma]] , final Targets targets ) { if ( ! ( [[uzma]] instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper [[rockabilly]] = ( MultipartRequestWrapper ) [[uzma]] ; if ( ! [[rockabilly]] . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = [[rockabilly]] . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String [[combination]] = paramNames . nextElement ( ) ; if ( [[uzma]] . getAttribute ( [[combination]] ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( [[combination]] ) ; if ( name != null ) { final FileUpload [ ] paramValues = [[rockabilly]] . getFiles ( [[combination]] ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , True ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .


--------------------------------------------- Result 719 ---------------------------------------------
Convert column name to column name . --> Convert attendees into a spreadsheet --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String [[propertyName]] ) { StringBuilder tableName = new StringBuilder ( [[propertyName]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[propertyName]] , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( [[propertyName]] ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[envelops]] ( final String [[attendees]] ) { StringBuilder tableName = new StringBuilder ( [[attendees]] . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( [[attendees]] , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( [[attendees]] ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .


--------------------------------------------- Result 720 ---------------------------------------------
Convert a column name to a property name . --> Generates aripalash of mischief --> Socre: 1.0

[[[[Adv]]]]: public String [[convertColumnNameToPropertyName]] ( final String [[columnName]] ) { StringBuilder propertyName = new StringBuilder ( [[columnName]] . length ( ) ) ; int len = [[columnName]] . length ( ) ; if ( splitCamelCase ) { boolean toUpper = False ; for ( int i = 0 ; i < len ; i ++ ) { char [[c]] = [[columnName]] . charAt ( i ) ; if ( [[c]] == separatorChar ) { toUpper = True ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( [[c]] ) ) ; toUpper = False ; } else { propertyName . append ( Character . toLowerCase ( [[c]] ) ) ; } } return propertyName . toString ( ) ; } return [[columnName]] ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String [[quanah]] ( final String [[humorous]] ) { StringBuilder propertyName = new StringBuilder ( [[humorous]] . length ( ) ) ; int len = [[humorous]] . length ( ) ; if ( splitCamelCase ) { boolean toUpper = False ; for ( int i = 0 ; i < len ; i ++ ) { char [[inertial]] = [[humorous]] . charAt ( i ) ; if ( [[inertial]] == separatorChar ) { toUpper = True ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( [[inertial]] ) ) ; toUpper = False ; } else { propertyName . append ( Character . toLowerCase ( [[inertial]] ) ) ; } } return propertyName . toString ( ) ; } return [[humorous]] ; }
[[[[Nl]]]]: Converts column name to property name .


--------------------------------------------- Result 721 ---------------------------------------------
Applies the given column name to the column name . --> Gets bahia --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[bahia]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .


--------------------------------------------- Result 722 ---------------------------------------------
Stores a value in the table . --> Convenience method for unit test --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement [[st]] , final int index , final Object value , final int [[dbSqlType]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( [[st]] , index , t , [[dbSqlType]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[ulrich]] ( final PreparedStatement [[artem]] , final int index , final Object value , final int [[swinton]] ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( [[artem]] , index , t , [[swinton]] ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .


--------------------------------------------- Result 723 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 471 / 232 / 20 / 723:  72%|███████▏  | 723/1000 [4:15:57<1:38:03, 21.24s/it][Succeeded / Failed / Skipped / Total] 471 / 232 / 20 / 723:  72%|███████▏  | 724/1000 [4:16:12<1:37:40, 21.23s/it][Succeeded / Failed / Skipped / Total] 472 / 232 / 20 / 724:  72%|███████▏  | 724/1000 [4:16:12<1:37:40, 21.23s/it][Succeeded / Failed / Skipped / Total] 472 / 232 / 20 / 724:  72%|███████▎  | 725/1000 [4:16:56<1:37:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 472 / 233 / 20 / 725:  72%|███████▎  | 725/1000 [4:16:56<1:37:27, 21.26s/it][Succeeded / Failed / Skipped / Total] 472 / 233 / 20 / 725:  73%|███████▎  | 726/1000 [4:17:04<1:37:01, 21.25s/it][Succeeded / Failed / Skipped / Total] 472 / 234 / 20 / 726:  73%|███████▎  | 726/1000 [4:17:04<1:37:01, 21.25s/it][Succeeded / Failed / Skipped / Total] 472 / 234 / 20 / 726:  73%|███████▎  | 727/1000 [4:17:21<1:36:38, 21.24s/it][Succeeded / Failed / Skipped / Total] 472 / 235 / 20 / 727:  73%|███████▎  | 727/1000 [4:17:21<1:36:38, 21.24s/it][Succeeded / Failed / Skipped / Total] 472 / 235 / 20 / 727:  73%|███████▎  | 728/1000 [4:17:47<1:36:19, 21.25s/it][Succeeded / Failed / Skipped / Total] 473 / 235 / 20 / 728:  73%|███████▎  | 728/1000 [4:17:47<1:36:19, 21.25s/it][Succeeded / Failed / Skipped / Total] 473 / 235 / 20 / 728:  73%|███████▎  | 729/1000 [4:18:19<1:36:01, 21.26s/it]Prepare the return value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[walkout]] > [[walkout]] prepareGetValue ( final T t , final Class < [[walkout]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[walkout]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .


--------------------------------------------- Result 724 ---------------------------------------------
Returns all wrappers . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[personalize]] ( ) { final Set < T > [[babaloo]] = new HashSet <> ( wrappers . size ( ) ) ; [[babaloo]] . addAll ( wrappers . values ( ) ) ; return [[babaloo]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .


--------------------------------------------- Result 725 ---------------------------------------------
Resolves a wrapper for the given class . --> [[[FAILED]]]

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > [[wrapperClass]] ) { String [[wrapperClassName]] = [[wrapperClass]] . getName ( ) ; T [[wrapper]] = lookup ( [[wrapperClassName]] ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( [[wrapperClass]] ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( [[wrapperClassName]] , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[hotspur]] ( final Class < ? extends T > [[epstein]] ) { String [[rocky]] = [[epstein]] . getName ( ) ; T [[boyish]] = lookup ( [[rocky]] ) ; if ( [[boyish]] == null ) { [[boyish]] = createWrapper ( [[epstein]] ) ; initializeWrapper ( [[boyish]] ) ; wrappers . put ( [[rocky]] , [[boyish]] ) ; } return [[boyish]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .


--------------------------------------------- Result 726 ---------------------------------------------
Creates a new instance of the supplied wrapper . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[beautified]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .


--------------------------------------------- Result 727 ---------------------------------------------
Convert system separators to system path separators . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[gentry]] ( final String [[pfister]] ) { if ( [[pfister]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[pfister]] ) ; } else { return separatorsToUnix ( [[pfister]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .


--------------------------------------------- Result 728 ---------------------------------------------
Gets the path . --> Liefert die aliphatic aliphatic aliphatic als --> Socre: 1.0

[[[[Adv]]]]: private static String [[doGetPath]] ( final String [[filename]] , final int separatorAdd ) { if ( [[filename]] == null ) { return null ; } int prefix = getPrefixLength ( [[filename]] ) ; if ( prefix < 0 ) { return null ; } int [[index]] = indexOfLastSeparator ( [[filename]] ) ; int endIndex = [[index]] + separatorAdd ; if ( prefix >= [[filename]] . length ( ) || [[index]] < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return [[filename]] . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String [[lapierre]] ( final String [[asiatic]] , final int separatorAdd ) { if ( [[asiatic]] == null ) { return null ; } int prefix = getPrefixLength ( [[asiatic]] ) ; if ( prefix < 0 ) { return null ; } int [[freedoms]] = indexOfLastSeparator ( [[asiatic]] ) ; int endIndex = [[freedoms]] + separatorAdd ; if ( prefix >= [[asiatic]] . length ( ) || [[freedoms]] < 0 || prefix >= endIndex ) { return StringPool . EMPTY ; } return [[asiatic]] . substring ( prefix , endIndex ) ; }
[[[[Nl]]]]: Does the work of getting the path .


--------------------------------------------- Result 729 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 474 / 235 / 20 / 729:  73%|███████▎  | 729/1000 [4:18:19<1:36:01, 21.26s/it][Succeeded / Failed / Skipped / Total] 474 / 235 / 20 / 729:  73%|███████▎  | 730/1000 [4:18:28<1:35:35, 21.24s/it][Succeeded / Failed / Skipped / Total] 475 / 235 / 20 / 730:  73%|███████▎  | 730/1000 [4:18:28<1:35:35, 21.24s/it][Succeeded / Failed / Skipped / Total] 475 / 235 / 20 / 730:  73%|███████▎  | 731/1000 [4:18:35<1:35:09, 21.22s/it][Succeeded / Failed / Skipped / Total] 476 / 235 / 20 / 731:  73%|███████▎  | 731/1000 [4:18:35<1:35:09, 21.22s/it][Succeeded / Failed / Skipped / Total] 476 / 235 / 20 / 731:  73%|███████▎  | 732/1000 [4:18:42<1:34:43, 21.21s/it][Succeeded / Failed / Skipped / Total] 476 / 236 / 20 / 732:  73%|███████▎  | 732/1000 [4:18:42<1:34:43, 21.21s/it][Succeeded / Failed / Skipped / Total] 476 / 236 / 20 / 732:  73%|███████▎  | 733/1000 [4:18:53<1:34:18, 21.19s/it][Succeeded / Failed / Skipped / Total] 477 / 236 / 20 / 733:  73%|███████▎  | 733/1000 [4:18:53<1:34:18, 21.19s/it][Succeeded / Failed / Skipped / Total] 477 / 236 / 20 / 733:  73%|███████▎  | 734/1000 [4:19:07<1:33:54, 21.18s/it][Succeeded / Failed / Skipped / Total] 478 / 236 / 20 / 734:  73%|███████▎  | 734/1000 [4:19:07<1:33:54, 21.18s/it][Succeeded / Failed / Skipped / Total] 478 / 236 / 20 / 734:  74%|███████▎  | 735/1000 [4:19:14<1:33:28, 21.16s/it]Split the given filename into an array of strings . --> generate kennerner --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[split]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int [[lastSeparatorIndex]] = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String [[path]] ; String baseName ; String [[extension]] ; if ( [[lastSeparatorIndex]] == - 1 ) { [[path]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; [[extension]] = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; [[extension]] = filename . substring ( lastExtensionIndex + 1 ) ; } } else { [[path]] = filename . substring ( prefix . length ( ) , [[lastSeparatorIndex]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + [[path]] . length ( ) ) ; [[extension]] = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + [[path]] . length ( ) , lastExtensionIndex ) ; [[extension]] = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[path]] , baseName , [[extension]] } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] [[kenner]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int [[halting]] = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String [[didst]] ; String baseName ; String [[carteret]] ; if ( [[halting]] == - 1 ) { [[didst]] = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; [[carteret]] = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; [[carteret]] = filename . substring ( lastExtensionIndex + 1 ) ; } } else { [[didst]] = filename . substring ( prefix . length ( ) , [[halting]] + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + [[didst]] . length ( ) ) ; [[carteret]] = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + [[didst]] . length ( ) , lastExtensionIndex ) ; [[carteret]] = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , [[didst]] , baseName , [[carteret]] } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .


--------------------------------------------- Result 730 ---------------------------------------------
Relative path relative to basePath --> Convenient method for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[relativePath]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String [[cider]] ( final String targetPath , final String basePath ) { return new File ( basePath ) . toPath ( ) . relativize ( new File ( targetPath ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .


--------------------------------------------- Result 731 ---------------------------------------------
Register a madvo component . --> Register a new class --> Socre: 1.0

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[furi]] ) { Objects . requireNonNull ( [[furi]] ) ; madvocComponents . add ( ClassConsumer . of ( [[furi]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .


--------------------------------------------- Result 732 ---------------------------------------------
Register action configuration for the given action type . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[cornelia]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .


--------------------------------------------- Result 733 ---------------------------------------------
Start the web application . --> creates a new webapp --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[aortic]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .


--------------------------------------------- Result 734 ---------------------------------------------
Configure the default defaults . --> helper method --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager [[actionConfigManager]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[actionConfigManager]] . registerAnnotation ( Action . class ) ; [[actionConfigManager]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[benghazi]] ( ) { final ActionConfigManager [[chestnut]] = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; [[chestnut]] . registerAnnotation ( Action . class ) ; [[chestnut]] . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .


--------------------------------------------- Result 735 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 478 / 237 / 20 / 735:  74%|███████▎  | 735/1000 [4:19:14<1:33:28, 21.16s/it][Succeeded / Failed / Skipped / Total] 478 / 237 / 20 / 735:  74%|███████▎  | 736/1000 [4:19:29<1:33:04, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 237 / 20 / 736:  74%|███████▎  | 736/1000 [4:19:29<1:33:04, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 237 / 20 / 736:  74%|███████▎  | 737/1000 [4:19:48<1:32:42, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 238 / 20 / 737:  74%|███████▎  | 737/1000 [4:19:48<1:32:42, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 238 / 20 / 737:  74%|███████▍  | 738/1000 [4:20:09<1:32:21, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 239 / 20 / 738:  74%|███████▍  | 738/1000 [4:20:09<1:32:21, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 239 / 20 / 738:  74%|███████▍  | 739/1000 [4:20:33<1:32:01, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 240 / 20 / 739:  74%|███████▍  | 739/1000 [4:20:33<1:32:01, 21.15s/it][Succeeded / Failed / Skipped / Total] 479 / 240 / 20 / 739:  74%|███████▍  | 740/1000 [4:21:48<1:31:59, 21.23s/it]Registers the madvoc components . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[researches]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .


--------------------------------------------- Result 736 ---------------------------------------------
Excludes jars . --> Remove all containers from the classpath --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String excludedJar : [[excludedJars]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[clearwater]] ( final String ... [[corinthian]] ) { for ( final String excludedJar : [[corinthian]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .


--------------------------------------------- Result 737 ---------------------------------------------
Includes specified jars . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[adarsh]] ( final String ... [[bigshot]] ) { for ( final String [[foremost]] : [[bigshot]] ) { rulesJars . include ( [[foremost]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .


--------------------------------------------- Result 738 ---------------------------------------------
Includes the given entries . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[anglia]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .


--------------------------------------------- Result 739 ---------------------------------------------
Exclude entries that should be scanned . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[excludeEntries]] ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner [[konw]] ( final String ... excludedEntries ) { for ( final String excludedEntry : excludedEntries ) { rulesEntries . exclude ( excludedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .


--------------------------------------------- Result 740 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 479 / 241 / 20 / 740:  74%|███████▍  | 740/1000 [4:21:48<1:31:59, 21.23s/it][Succeeded / Failed / Skipped / Total] 479 / 241 / 20 / 740:  74%|███████▍  | 741/1000 [4:22:50<1:31:52, 21.28s/it][Succeeded / Failed / Skipped / Total] 479 / 242 / 20 / 741:  74%|███████▍  | 741/1000 [4:22:50<1:31:52, 21.28s/it][Succeeded / Failed / Skipped / Total] 479 / 242 / 20 / 741:  74%|███████▍  | 742/1000 [4:22:57<1:31:26, 21.26s/it][Succeeded / Failed / Skipped / Total] 480 / 242 / 20 / 742:  74%|███████▍  | 742/1000 [4:22:57<1:31:26, 21.26s/it][Succeeded / Failed / Skipped / Total] 480 / 242 / 20 / 742:  74%|███████▍  | 743/1000 [4:23:04<1:30:59, 21.24s/it][Succeeded / Failed / Skipped / Total] 481 / 242 / 20 / 743:  74%|███████▍  | 743/1000 [4:23:04<1:30:59, 21.24s/it][Succeeded / Failed / Skipped / Total] 481 / 242 / 20 / 743:  74%|███████▍  | 744/1000 [4:23:17<1:30:35, 21.23s/it][Succeeded / Failed / Skipped / Total] 481 / 243 / 20 / 744:  74%|███████▍  | 744/1000 [4:23:17<1:30:35, 21.23s/it][Succeeded / Failed / Skipped / Total] 481 / 243 / 20 / 744:  74%|███████▍  | 745/1000 [4:23:27<1:30:10, 21.22s/it][Succeeded / Failed / Skipped / Total] 482 / 243 / 20 / 745:  74%|███████▍  | 745/1000 [4:23:27<1:30:10, 21.22s/it][Succeeded / Failed / Skipped / Total] 482 / 243 / 20 / 745:  75%|███████▍  | 746/1000 [4:23:37<1:29:45, 21.20s/it]Scans a jar file . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File [[file]] ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( [[file]] ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + [[file]] . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , True ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , False ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[jarod]] ( final File [[tucks]] ) { final ZipFile zipFile ; try { zipFile = new ZipFile ( [[tucks]] ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + [[tucks]] . getName ( ) , ioex ) ; } return ; } final Enumeration entries = zipFile . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , True ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , False ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , zipFile , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( zipFile ) ; throw rex ; } } } ZipUtil . close ( zipFile ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .


--------------------------------------------- Result 741 ---------------------------------------------
Scans class files . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String [[rootPath]] = root . getAbsolutePath ( ) ; if ( ! [[rootPath]] . endsWith ( File . separator ) ) { [[rootPath]] += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( False ) . recursive ( "[[True]]" == "[[True]]" ) . searchPath ( [[rootPath]] ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , [[rootPath]] , file , "[[True]]" == "[[True]]" ) ; } else if ( includeResources ) { scanClassFile ( filePath , [[rootPath]] , file , False ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String [[gatiss]] = root . getAbsolutePath ( ) ; if ( ! [[gatiss]] . endsWith ( File . separator ) ) { [[gatiss]] += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( False ) . recursive ( "[["Palmer" == "Palmer"]]" == "[["Palmer" == "Palmer"]]" ) . searchPath ( [[gatiss]] ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , [[gatiss]] , file , "[["Palmer" == "Palmer"]]" == "[["Palmer" == "Palmer"]]" ) ; } else if ( includeResources ) { scanClassFile ( filePath , [[gatiss]] , file , False ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .


--------------------------------------------- Result 742 ---------------------------------------------
Returns a bytecode of a given type . --> Create african data --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[african]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .


--------------------------------------------- Result 743 ---------------------------------------------
Scan given paths . --> Add one or more files --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[unión]] ( final String ... paths ) { for ( final String path : paths ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .


--------------------------------------------- Result 744 ---------------------------------------------
Scans the scan . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[carboni]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[mya]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[mya]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .


--------------------------------------------- Result 745 ---------------------------------------------
Returns a new transaction with the specified scope . --> overriding method --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean [[active]] ) { return new DbJtxTransaction ( this , tm , scope , [[active]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object scope , final boolean [[chloride]] ) { return new DbJtxTransaction ( this , tm , scope , [[chloride]] ) ; }
[[[[Nl]]]]: Builds new transaction instance .


--------------------------------------------- Result 746 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 482 / 244 / 20 / 746:  75%|███████▍  | 746/1000 [4:23:37<1:29:45, 21.20s/it][Succeeded / Failed / Skipped / Total] 482 / 244 / 20 / 746:  75%|███████▍  | 747/1000 [4:24:02<1:29:25, 21.21s/it][Succeeded / Failed / Skipped / Total] 482 / 245 / 20 / 747:  75%|███████▍  | 747/1000 [4:24:02<1:29:25, 21.21s/it][Succeeded / Failed / Skipped / Total] 482 / 245 / 20 / 747:  75%|███████▍  | 748/1000 [4:24:34<1:29:08, 21.22s/it][Succeeded / Failed / Skipped / Total] 483 / 245 / 20 / 748:  75%|███████▍  | 748/1000 [4:24:34<1:29:08, 21.22s/it][Succeeded / Failed / Skipped / Total] 483 / 245 / 20 / 748:  75%|███████▍  | 749/1000 [4:25:14<1:28:53, 21.25s/it][Succeeded / Failed / Skipped / Total] 484 / 245 / 20 / 749:  75%|███████▍  | 749/1000 [4:25:14<1:28:53, 21.25s/it][Succeeded / Failed / Skipped / Total] 484 / 245 / 20 / 749:  75%|███████▌  | 750/1000 [4:25:51<1:28:37, 21.27s/it][Succeeded / Failed / Skipped / Total] 485 / 245 / 20 / 750:  75%|███████▌  | 750/1000 [4:25:51<1:28:37, 21.27s/it][Succeeded / Failed / Skipped / Total] 485 / 245 / 20 / 750:  75%|███████▌  | 751/1000 [4:26:21<1:28:18, 21.28s/it]Returns the default scope of the given class . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[alarmingly]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .


--------------------------------------------- Result 747 ---------------------------------------------
Gets or init scopes . --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[s]] : allScopes ) { if ( [[s]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[s]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > madvocScopeType ) { for ( final MadvocScope [[analysing]] : allScopes ) { if ( [[analysing]] . getClass ( ) . equals ( madvocScopeType ) ) { return [[analysing]] ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .


--------------------------------------------- Result 748 ---------------------------------------------
Creates a new scope for the specified scope . --> Bidiidding cycle --> Socre: 1.0

[[[[Adv]]]]: public void [[forScope]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope [[scope]] = getOrInitScope ( scopeType ) ; [[madvocScopeConsumer]] . accept ( [[scope]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void [[bedding]] ( final Class < ? extends MadvocScope > scopeType , final Consumer < MadvocScope > [[bicycles]] ) { final MadvocScope [[bailout]] = getOrInitScope ( scopeType ) ; [[bicycles]] . accept ( [[bailout]] ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .


--------------------------------------------- Result 749 ---------------------------------------------
Decodes char array . --> Decode gueck --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] [[arr]] ) { int length = [[arr]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[arr]] [ endx ] == ' ' ? ( [[arr]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int [[sepCnt]] = length > 76 ? ( [[arr]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - [[sepCnt]] ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[d]] = 0 ; for ( int cc = 0 , [[eLen]] = ( len / 3 ) * 3 ; [[d]] < [[eLen]] ; ) { int i = INV [ [[arr]] [ sndx ++ ] ] << 18 | INV [ [[arr]] [ sndx ++ ] ] << 12 | INV [ [[arr]] [ sndx ++ ] ] << 6 | INV [ [[arr]] [ sndx ++ ] ] ; dest [ [[d]] ++ ] = ( byte ) ( i >> 16 ) ; dest [ [[d]] ++ ] = ( byte ) ( i >> 8 ) ; dest [ [[d]] ++ ] = ( byte ) i ; if ( [[sepCnt]] > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[d]] < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[arr]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[d]] < len ; r -= 8 ) { dest [ [[d]] ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] [[ague]] ) { int length = [[ague]] . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = [[ague]] [ endx ] == ' ' ? ( [[ague]] [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int [[prologues]] = length > 76 ? ( [[ague]] [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - [[prologues]] ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[handout]] = 0 ; for ( int cc = 0 , [[appalachian]] = ( len / 3 ) * 3 ; [[handout]] < [[appalachian]] ; ) { int i = INV [ [[ague]] [ sndx ++ ] ] << 18 | INV [ [[ague]] [ sndx ++ ] ] << 12 | INV [ [[ague]] [ sndx ++ ] ] << 6 | INV [ [[ague]] [ sndx ++ ] ] ; dest [ [[handout]] ++ ] = ( byte ) ( i >> 16 ) ; dest [ [[handout]] ++ ] = ( byte ) ( i >> 8 ) ; dest [ [[handout]] ++ ] = ( byte ) i ; if ( [[prologues]] > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[handout]] < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ [[ague]] [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[handout]] < len ; r -= 8 ) { dest [ [[handout]] ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .


--------------------------------------------- Result 750 ---------------------------------------------
Generate a CSRF token . --> copied from httpSession --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession session , final int [[timeToLive]] ) { Set < Token > [[tokenSet]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[tokenSet]] == null ) { [[tokenSet]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[tokenSet]] ) ; } String value ; boolean [[unique]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[tokenSet]] ) ; [[unique]] = [[tokenSet]] . add ( new Token ( value , [[timeToLive]] ) ) ; } while ( ! [[unique]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[coped]] ( final HttpSession session , final int [[birdseed]] ) { Set < Token > [[standpoint]] = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( [[standpoint]] == null ) { [[standpoint]] = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , [[standpoint]] ) ; } String value ; boolean [[persecution]] ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( [[standpoint]] ) ; [[persecution]] = [[standpoint]] . add ( new Token ( value , [[birdseed]] ) ) ; } while ( ! [[persecution]] ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .


--------------------------------------------- Result 751 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 486 / 245 / 20 / 751:  75%|███████▌  | 751/1000 [4:26:21<1:28:18, 21.28s/it][Succeeded / Failed / Skipped / Total] 486 / 245 / 20 / 751:  75%|███████▌  | 752/1000 [4:27:07<1:28:05, 21.31s/it][Succeeded / Failed / Skipped / Total] 487 / 245 / 20 / 752:  75%|███████▌  | 752/1000 [4:27:07<1:28:05, 21.31s/it][Succeeded / Failed / Skipped / Total] 487 / 245 / 20 / 752:  75%|███████▌  | 753/1000 [4:27:20<1:27:41, 21.30s/it][Succeeded / Failed / Skipped / Total] 488 / 245 / 20 / 753:  75%|███████▌  | 753/1000 [4:27:20<1:27:41, 21.30s/it][Succeeded / Failed / Skipped / Total] 488 / 245 / 20 / 753:  75%|███████▌  | 754/1000 [4:27:25<1:27:15, 21.28s/it][Succeeded / Failed / Skipped / Total] 489 / 245 / 20 / 754:  75%|███████▌  | 754/1000 [4:27:25<1:27:15, 21.28s/it][Succeeded / Failed / Skipped / Total] 489 / 245 / 20 / 754:  76%|███████▌  | 755/1000 [4:27:37<1:26:50, 21.27s/it][Succeeded / Failed / Skipped / Total] 490 / 245 / 20 / 755:  76%|███████▌  | 755/1000 [4:27:37<1:26:50, 21.27s/it][Succeeded / Failed / Skipped / Total] 490 / 245 / 20 / 755:  76%|███████▌  | 756/1000 [4:28:17<1:26:35, 21.29s/it][Succeeded / Failed / Skipped / Total] 490 / 246 / 20 / 756:  76%|███████▌  | 756/1000 [4:28:17<1:26:35, 21.29s/it][Succeeded / Failed / Skipped / Total] 490 / 246 / 20 / 756:  76%|███████▌  | 757/1000 [4:28:33<1:26:12, 21.29s/it]Checks the size of tokens in the token set . --> Parses Rabbit Sessions --> Socre: 1.0

[[[[Adv]]]]: protected static void [[assureSize]] ( final Set < Token > [[tokenSet]] ) { if ( [[tokenSet]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[tokenToRemove]] = null ; Iterator < Token > iterator = [[tokenSet]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[token]] = iterator . next ( ) ; if ( [[token]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[token]] . validUntil < validUntilMin ) { validUntilMin = [[token]] . validUntil ; [[tokenToRemove]] = [[token]] ; } } if ( ( [[tokenToRemove]] != null ) && ( [[tokenSet]] . size ( ) >= maxTokensPerSession ) ) { [[tokenSet]] . remove ( [[tokenToRemove]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void [[pillock]] ( final Set < Token > [[rabbit]] ) { if ( [[rabbit]] . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[guitar]] = null ; Iterator < Token > iterator = [[rabbit]] . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[brainy]] = iterator . next ( ) ; if ( [[brainy]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[brainy]] . validUntil < validUntilMin ) { validUntilMin = [[brainy]] . validUntil ; [[guitar]] = [[brainy]] ; } } if ( ( [[guitar]] != null ) && ( [[rabbit]] . size ( ) >= maxTokensPerSession ) ) { [[rabbit]] . remove ( [[guitar]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .


--------------------------------------------- Result 752 ---------------------------------------------
Check if a CSRF token has expired . --> Check to see if a cookie has expired --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[checkCsrfToken]] ( final HttpSession [[session]] , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) [[session]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return True ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return False ; } boolean found = False ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = True ; } } return found ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean [[gettys]] ( final HttpSession [[accessory]] , final String tokenValue ) { Set < Token > tokenSet = ( Set < Token > ) [[accessory]] . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( tokenValue == null ) ) { return True ; } if ( ( tokenSet == null ) || ( tokenValue == null ) ) { return False ; } boolean found = False ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( tokenValue ) ) { it . remove ( ) ; found = True ; } } return found ; }
[[[[Nl]]]]: Checks token value . C


--------------------------------------------- Result 753 ---------------------------------------------
Creates a copy of a Bean . --> Create bean copy from given object --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy from ( final Object [[source]] ) { BeanCopy [[beanCopy]] = new BeanCopy ( [[source]] ) ; [[beanCopy]] . isSourceMap = [[source]] instanceof Map ; return [[beanCopy]] ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy from ( final Object [[pertain]] ) { BeanCopy [[arraigned]] = new BeanCopy ( [[pertain]] ) ; [[arraigned]] . isSourceMap = [[pertain]] instanceof Map ; return [[arraigned]] ; }
[[[[Nl]]]]: Defines source detects a map .


--------------------------------------------- Result 754 ---------------------------------------------
Copies this object . --> Copy this instance --> Socre: 1.0

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[[True]]" == "[[True]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void copy ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "[["Centralized" == "Centralized"]]" == "[["Centralized" == "Centralized"]]" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .


--------------------------------------------- Result 755 ---------------------------------------------
Visit property . --> setProperty --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String [[name]] , final Object [[value]] ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , [[value]] ) ; return True ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean visitProperty ( String [[auro]] , final Object [[bensonhurst]] ) { if ( isTargetMap ) { [[auro]] = LEFT_SQ_BRACKET + [[auro]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[auro]] , [[bensonhurst]] ) ; return True ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .


--------------------------------------------- Result 756 ---------------------------------------------
Initializes the table reference . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[init]] ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[tableReference]] = this . tableReference ; if ( [[tableReference]] == null ) { [[tableReference]] = tableAlias ; } if ( [[tableReference]] == null ) { [[tableReference]] = entityName ; } if ( [[tableReference]] == null ) { [[tableReference]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[tableReference]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void [[spoonful]] ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[pesky]] = this . tableReference ; if ( [[pesky]] == null ) { [[pesky]] = tableAlias ; } if ( [[pesky]] == null ) { [[pesky]] = entityName ; } if ( [[pesky]] == null ) { [[pesky]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[pesky]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .


--------------------------------------------- Result 757 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 490 / 247 / 20 / 757:  76%|███████▌  | 757/1000 [4:28:33<1:26:12, 21.29s/it][Succeeded / Failed / Skipped / Total] 490 / 247 / 20 / 757:  76%|███████▌  | 758/1000 [4:28:42<1:25:47, 21.27s/it][Succeeded / Failed / Skipped / Total] 491 / 247 / 20 / 758:  76%|███████▌  | 758/1000 [4:28:42<1:25:47, 21.27s/it][Succeeded / Failed / Skipped / Total] 491 / 247 / 20 / 758:  76%|███████▌  | 759/1000 [4:29:02<1:25:25, 21.27s/it][Succeeded / Failed / Skipped / Total] 492 / 247 / 20 / 759:  76%|███████▌  | 759/1000 [4:29:02<1:25:25, 21.27s/it][Succeeded / Failed / Skipped / Total] 492 / 247 / 20 / 759:  76%|███████▌  | 760/1000 [4:29:14<1:25:01, 21.26s/it][Succeeded / Failed / Skipped / Total] 493 / 247 / 20 / 760:  76%|███████▌  | 760/1000 [4:29:14<1:25:01, 21.26s/it][Succeeded / Failed / Skipped / Total] 493 / 247 / 20 / 760:  76%|███████▌  | 761/1000 [4:30:06<1:24:49, 21.30s/it][Succeeded / Failed / Skipped / Total] 494 / 247 / 20 / 761:  76%|███████▌  | 761/1000 [4:30:06<1:24:49, 21.30s/it][Succeeded / Failed / Skipped / Total] 494 / 247 / 20 / 761:  76%|███████▌  | 762/1000 [4:31:12<1:24:42, 21.35s/it]Resolves a scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[scope]] = ( S ) scopes . get ( scopeType ) ; if ( [[scope]] == null ) { try { [[scope]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[scope]] ) ; scopes . put ( scopeType , [[scope]] ) ; } return [[scope]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[watchin]] Scope > S resolveScope ( final Class < S > scopeType ) { S [[sengoku]] = ( S ) scopes . get ( scopeType ) ; if ( [[sengoku]] == null ) { try { [[sengoku]] = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , [[sengoku]] ) ; scopes . put ( scopeType , [[sengoku]] ) ; } return [[sengoku]] ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .


--------------------------------------------- Result 758 ---------------------------------------------
Register a bean definition . --> method to register BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String [[name]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > registerPetiteBean ( final Class < T > type , String [[osteopath]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[osteopath]] == null ) { [[osteopath]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .


--------------------------------------------- Result 759 ---------------------------------------------
Register a bean definition . --> Register a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[beanDefinition]] ) { beans . put ( name , [[beanDefinition]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[beanDefinition]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition [[existing]] = beansAlt . get ( altName ) ; if ( [[existing]] != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition [[beads]] ) { beans . put ( name , [[beads]] ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = [[beads]] . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String altName = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( altName ) ) { continue ; } if ( beans . containsKey ( altName ) ) { continue ; } if ( beansAlt . containsKey ( altName ) ) { BeanDefinition [[justina]] = beansAlt . get ( altName ) ; if ( [[justina]] != null ) { beansAlt . put ( altName , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .


--------------------------------------------- Result 760 ---------------------------------------------
Removes the bean with the specified type . --> Batch Babbels --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class [[type]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[babbles]] ( final Class [[cleans]] ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .


--------------------------------------------- Result 761 ---------------------------------------------
Resolve bean names for a given type . --> Return a list of beans capable of the given class --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[resolveBeanNamesForType]] ( final Class [[type]] ) { String [ ] [[beanNames]] = beanCollections . get ( [[type]] ) ; if ( [[beanNames]] != null ) { return [[beanNames]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[type]] ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { [[beanNames]] = StringPool . EMPTY_ARRAY ; } else { [[beanNames]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[type]] , [[beanNames]] ) ; return [[beanNames]] ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] [[capable]] ( final Class [[bollywood]] ) { String [ ] [[chao]] = beanCollections . get ( [[bollywood]] ) ; if ( [[chao]] != null ) { return [[chao]] ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , [[bollywood]] ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { [[chao]] = StringPool . EMPTY_ARRAY ; } else { [[chao]] = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( [[bollywood]] , [[chao]] ) ; return [[chao]] ; }
[[[[Nl]]]]: Resolves bean names for give type .


--------------------------------------------- Result 762 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 495 / 247 / 20 / 762:  76%|███████▌  | 762/1000 [4:31:12<1:24:42, 21.35s/it][Succeeded / Failed / Skipped / Total] 495 / 247 / 20 / 762:  76%|███████▋  | 763/1000 [4:31:56<1:24:28, 21.39s/it][Succeeded / Failed / Skipped / Total] 496 / 247 / 20 / 763:  76%|███████▋  | 763/1000 [4:31:56<1:24:28, 21.39s/it][Succeeded / Failed / Skipped / Total] 496 / 247 / 20 / 763:  76%|███████▋  | 764/1000 [4:32:15<1:24:05, 21.38s/it][Succeeded / Failed / Skipped / Total] 497 / 247 / 20 / 764:  76%|███████▋  | 764/1000 [4:32:15<1:24:05, 21.38s/it][Succeeded / Failed / Skipped / Total] 497 / 247 / 20 / 764:  76%|███████▋  | 765/1000 [4:34:11<1:24:13, 21.50s/it]Register a potential injection point for this bean . --> Don t call this method! --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteCtorInjectionPoint]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , True ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[ref]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[ref]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void [[donatella]] ( final String beanName , final Class [ ] paramTypes , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( paramTypes == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( paramTypes , True ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[headway]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[headway]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .


--------------------------------------------- Result 763 ---------------------------------------------
Register a property injection point . --> This method adds rosininii --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetitePropertyInjectionPoint]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor [[propertyDescriptor]] = [[cd]] . getPropertyDescriptor ( property , True ) ; if ( [[propertyDescriptor]] == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( [[propertyDescriptor]] , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( [[propertyDescriptor]] , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void [[rossellini]] ( final String beanName , final String property , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[kerala]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor [[chop]] = [[kerala]] . getPropertyDescriptor ( property , True ) ; if ( [[chop]] == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( [[chop]] , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( [[chop]] , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .


--------------------------------------------- Result 764 ---------------------------------------------
Register a Petite Set InjectionPoint --> Register a Petite SetInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "[[True]]" == "[[True]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[sip]] = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( [[sip]] ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String property ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( property , "[["Helpline" == "Helpline"]]" == "[["Helpline" == "Helpline"]]" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + property ) ; } SetInjectionPoint [[bloodhound]] = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( [[bloodhound]] ) ; }
[[[[Nl]]]]: Registers set injection point .


--------------------------------------------- Result 765 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 498 / 247 / 20 / 765:  76%|███████▋  | 765/1000 [4:34:11<1:24:13, 21.50s/it][Succeeded / Failed / Skipped / Total] 498 / 247 / 20 / 765:  77%|███████▋  | 766/1000 [4:34:32<1:23:52, 21.50s/it][Succeeded / Failed / Skipped / Total] 499 / 247 / 20 / 766:  77%|███████▋  | 766/1000 [4:34:32<1:23:52, 21.50s/it][Succeeded / Failed / Skipped / Total] 499 / 247 / 20 / 766:  77%|███████▋  | 767/1000 [4:35:48<1:23:47, 21.58s/it][Succeeded / Failed / Skipped / Total] 500 / 247 / 20 / 767:  77%|███████▋  | 767/1000 [4:35:48<1:23:47, 21.58s/it][Succeeded / Failed / Skipped / Total] 500 / 247 / 20 / 767:  77%|███████▋  | 768/1000 [4:36:38<1:23:34, 21.61s/it]Register a method injection point . --> Locate a bean with reflection --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteMethodInjectionPoint]] ( final String [[beanName]] , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[beanDefinition]] . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor [[md]] = cd . getMethodDescriptor ( methodName , arguments , True ) ; if ( [[md]] != null ) { method = [[md]] . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; [[beanDefinition]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void [[golfer]] ( final String [[duckies]] , final String methodName , final Class [ ] arguments , final String [ ] references ) { BeanDefinition [[uncomfortable]] = lookupExistingBeanDefinition ( [[duckies]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[uncomfortable]] . type ) ; Method method = null ; if ( arguments == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + [[uncomfortable]] . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor [[hogwarts]] = cd . getMethodDescriptor ( methodName , arguments , True ) ; if ( [[hogwarts]] != null ) { method = [[hogwarts]] . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + [[uncomfortable]] . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; [[uncomfortable]] . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .


--------------------------------------------- Result 766 ---------------------------------------------
Register primitive init methods . --> Register poison methods --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String [[beanName]] , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beanName]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String [[beware]] , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( [[beware]] ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[["Loft" == "Loft"]]" == "[["Loft" == "Loft"]]" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + beanDefinition . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } beanDefinition . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .


--------------------------------------------- Result 767 ---------------------------------------------
Register poison methods . --> Determine the destruction of a bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteDestroyMethods]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor [[md]] = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[True]]" == "[[True]]" ) ; if ( [[md]] == null ) { throw new PetiteException ( "Destroy method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( [[md]] . getMethod ( ) ) ; } [[beanDefinition]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void [[hindering]] ( final String beanName , String ... destroyMethodNames ) { BeanDefinition [[aller]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[aller]] . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor [[layabout]] = cd . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[["Extremities" == "Extremities"]]" == "[["Extremities" == "Extremities"]]" ) ; if ( [[layabout]] == null ) { throw new PetiteException ( "Destroy method not found: " + [[aller]] . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( [[layabout]] . getMethod ( ) ) ; } [[aller]] . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .


--------------------------------------------- Result 768 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 501 / 247 / 20 / 768:  77%|███████▋  | 768/1000 [4:36:38<1:23:34, 21.61s/it][Succeeded / Failed / Skipped / Total] 501 / 247 / 20 / 768:  77%|███████▋  | 769/1000 [4:37:57<1:23:29, 21.69s/it][Succeeded / Failed / Skipped / Total] 501 / 248 / 20 / 769:  77%|███████▋  | 769/1000 [4:37:57<1:23:29, 21.69s/it][Succeeded / Failed / Skipped / Total] 501 / 248 / 20 / 769:  77%|███████▋  | 770/1000 [4:38:21<1:23:08, 21.69s/it][Succeeded / Failed / Skipped / Total] 502 / 248 / 20 / 770:  77%|███████▋  | 770/1000 [4:38:21<1:23:08, 21.69s/it][Succeeded / Failed / Skipped / Total] 502 / 248 / 20 / 770:  77%|███████▋  | 771/1000 [4:38:35<1:22:44, 21.68s/it][Succeeded / Failed / Skipped / Total] 503 / 248 / 20 / 771:  77%|███████▋  | 771/1000 [4:38:35<1:22:44, 21.68s/it][Succeeded / Failed / Skipped / Total] 503 / 248 / 20 / 771:  77%|███████▋  | 772/1000 [4:39:05<1:22:25, 21.69s/it][Succeeded / Failed / Skipped / Total] 504 / 248 / 20 / 772:  77%|███████▋  | 772/1000 [4:39:05<1:22:25, 21.69s/it][Succeeded / Failed / Skipped / Total] 504 / 248 / 20 / 772:  77%|███████▋  | 773/1000 [4:39:43<1:22:08, 21.71s/it][Succeeded / Failed / Skipped / Total] 505 / 248 / 20 / 773:  77%|███████▋  | 773/1000 [4:39:43<1:22:08, 21.71s/it][Succeeded / Failed / Skipped / Total] 505 / 248 / 20 / 773:  77%|███████▋  | 774/1000 [4:40:06<1:21:47, 21.71s/it][Succeeded / Failed / Skipped / Total] 505 / 249 / 20 / 774:  77%|███████▋  | 774/1000 [4:40:06<1:21:47, 21.71s/it][Succeeded / Failed / Skipped / Total] 505 / 249 / 20 / 774:  78%|███████▊  | 775/1000 [4:40:35<1:21:27, 21.72s/it]Register a Petite provider . --> Register a geography definition for a bean --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String [[providerName]] , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition [[beanDefinition]] = lookupBeanDefinition ( beanName ) ; if ( [[beanDefinition]] == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = [[beanDefinition]] . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor [[md]] = cd . getMethodDescriptor ( methodName , arguments , True ) ; if ( [[md]] == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , beanName , [[md]] . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void [[geography]] ( final String [[hori]] , final String beanName , final String methodName , final Class [ ] arguments ) { BeanDefinition [[abounds]] = lookupBeanDefinition ( beanName ) ; if ( [[abounds]] == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class beanType = [[abounds]] . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanType ) ; MethodDescriptor [[anus]] = cd . getMethodDescriptor ( methodName , arguments , True ) ; if ( [[anus]] == null ) { throw new PetiteException ( "Provider method not found: " + methodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[hori]] , beanName , [[anus]] . getMethod ( ) ) ; providers . put ( [[hori]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .


--------------------------------------------- Result 769 ---------------------------------------------
Register a Petite provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[cd]] . getMethodDescriptor ( staticMethodName , arguments , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[basest]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[basest]] . getMethodDescriptor ( staticMethodName , arguments , "[["Basque" == "Basque"]]" == "[["Basque" == "Basque"]]" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .


--------------------------------------------- Result 770 ---------------------------------------------
Iterate over all beans of a given type . --> Performs a rich Richard on each bean --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class [[type]] , final Consumer < String > [[beanNameConsumer]] ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[type]] ) ) { [[beanNameConsumer]] . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[richard]] ( final Class [[bastian]] , final Consumer < String > [[coffey]] ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[bastian]] ) ) { [[coffey]] . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .


--------------------------------------------- Result 771 ---------------------------------------------
Define the given map of parameters . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > [[entry]] : properties . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[cranked]] ( final Map < ? , ? > properties ) { for ( Map . Entry < ? , ? > [[imean]] : properties . entrySet ( ) ) { defineParameter ( [[imean]] . getKey ( ) . toString ( ) , [[imean]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .


--------------------------------------------- Result 772 ---------------------------------------------
Intercept the action request . --> Implementation of Goliath --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long [[startTime]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[startTime]] ; printAfter ( [[actionRequest]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[handsomely]] ( final ActionRequest [[goliath]] ) throws Exception { printBefore ( [[goliath]] ) ; long [[betcha]] = System . currentTimeMillis ( ) ; Object result = null ; try { result = [[goliath]] . invoke ( ) ; } catch ( Exception ex ) { result = "<exception>" ; throw ex ; } catch ( Throwable th ) { result = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - [[betcha]] ; printAfter ( [[goliath]] , executionTime , result ) ; } return result ; }
[[[[Nl]]]]: Measure action invocation time .


--------------------------------------------- Result 773 ---------------------------------------------
Returns the java version number . --> Returns the number of songs that can be played on a platform --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int [[javaVersionNumber]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = [[javaVersionNumber]] - 8 + 52 ; return [[version]] > platformVersion ? [[version]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[songs]] ( final int [[easily]] ) { final int [[auctioning]] = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int platformVersion = [[auctioning]] - 8 + 52 ; return [[easily]] > platformVersion ? [[easily]] : platformVersion ; }
[[[[Nl]]]]: Resolves Java version from current version .


--------------------------------------------- Result 774 ---------------------------------------------
Push an integer onto the stack . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor mv , final int [[value]] ) { if ( [[value]] <= 5 ) { mv . visitInsn ( ICONST_0 + [[value]] ) ; } else if ( [[value]] <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , [[value]] ) ; } else { mv . visitIntInsn ( SIPUSH , [[value]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[replaceable]] ( final MethodVisitor mv , final int [[virginal]] ) { if ( [[virginal]] <= 5 ) { mv . visitInsn ( ICONST_0 + [[virginal]] ) ; } else if ( [[virginal]] <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , [[virginal]] ) ; } else { mv . visitIntInsn ( SIPUSH , [[virginal]] ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .


--------------------------------------------- Result 775 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 505 / 250 / 20 / 775:  78%|███████▊  | 775/1000 [4:40:35<1:21:27, 21.72s/it][Succeeded / Failed / Skipped / Total] 505 / 250 / 20 / 775:  78%|███████▊  | 776/1000 [4:40:43<1:21:02, 21.71s/it][Succeeded / Failed / Skipped / Total] 506 / 250 / 20 / 776:  78%|███████▊  | 776/1000 [4:40:43<1:21:02, 21.71s/it][Succeeded / Failed / Skipped / Total] 506 / 250 / 20 / 776:  78%|███████▊  | 777/1000 [4:41:00<1:20:39, 21.70s/it][Succeeded / Failed / Skipped / Total] 507 / 250 / 20 / 777:  78%|███████▊  | 777/1000 [4:41:00<1:20:39, 21.70s/it][Succeeded / Failed / Skipped / Total] 507 / 250 / 20 / 777:  78%|███████▊  | 778/1000 [4:41:12<1:20:14, 21.69s/it][Succeeded / Failed / Skipped / Total] 508 / 250 / 20 / 778:  78%|███████▊  | 778/1000 [4:41:12<1:20:14, 21.69s/it][Succeeded / Failed / Skipped / Total] 508 / 250 / 20 / 778:  78%|███████▊  | 779/1000 [4:41:37<1:19:53, 21.69s/it][Succeeded / Failed / Skipped / Total] 508 / 251 / 20 / 779:  78%|███████▊  | 779/1000 [4:41:37<1:19:53, 21.69s/it][Succeeded / Failed / Skipped / Total] 508 / 251 / 20 / 779:  78%|███████▊  | 780/1000 [4:41:53<1:19:30, 21.68s/it][Succeeded / Failed / Skipped / Total] 509 / 251 / 20 / 780:  78%|███████▊  | 780/1000 [4:41:53<1:19:30, 21.68s/it][Succeeded / Failed / Skipped / Total] 509 / 251 / 20 / 780:  78%|███████▊  | 781/1000 [4:42:24<1:19:11, 21.70s/it][Succeeded / Failed / Skipped / Total] 510 / 251 / 20 / 781:  78%|███████▊  | 781/1000 [4:42:24<1:19:11, 21.70s/it][Succeeded / Failed / Skipped / Total] 510 / 251 / 20 / 781:  78%|███████▊  | 782/1000 [4:42:43<1:18:48, 21.69s/it][Succeeded / Failed / Skipped / Total] 511 / 251 / 20 / 782:  78%|███████▊  | 782/1000 [4:42:43<1:18:48, 21.69s/it][Succeeded / Failed / Skipped / Total] 511 / 251 / 20 / 782:  78%|███████▊  | 783/1000 [4:43:11<1:18:28, 21.70s/it]Check that the argument index is valid . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo [[methodInfo]] , final int [[argIndex]] ) { if ( ( [[argIndex]] < 1 ) || ( [[argIndex]] > [[methodInfo]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[argIndex]] ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[aquinas]] ( final MethodInfo [[negi]] , final int [[callin]] ) { if ( ( [[callin]] < 1 ) || ( [[callin]] > [[negi]] . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + [[callin]] ) ; } }
[[[[Nl]]]]: Validates argument index .


--------------------------------------------- Result 776 ---------------------------------------------
Generate a field name for a field --> Generate exclusion string --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[exclusion]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .


--------------------------------------------- Result 777 ---------------------------------------------
Generate advice method name . --> Calculate maximumima for a given character --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int index ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[maxima]] ( final String [[toothpicks]] , final int index ) { return ProxettaNames . methodPrefix + [[toothpicks]] + ProxettaNames . methodDivider + index ; }
[[[[Nl]]]]: Builds advice method name .


--------------------------------------------- Result 778 ---------------------------------------------
load special method arguments --> load special methods --> Socre: 1.0

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { [[mv]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void loadSpecialMethodArguments ( final MethodVisitor [[cece]] , final MethodInfo [[didst]] ) { [[cece]] . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= [[didst]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[cece]] , [[didst]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .


--------------------------------------------- Result 779 ---------------------------------------------
Loads the static method arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int [[i]] = 0 ; [[i]] < methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( mv , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[challenges]] ( final MethodVisitor mv , final MethodInfo methodInfo ) { for ( int [[storey]] = 0 ; [[storey]] < methodInfo . getArgumentsCount ( ) ; [[storey]] ++ ) { loadMethodArgument ( mv , methodInfo , [[storey]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .


--------------------------------------------- Result 780 ---------------------------------------------
Load virtual method arguments . --> Hook to deliver a handsham --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadVirtualMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[mv]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void [[hailsham]] ( final MethodVisitor [[sandalwood]] , final MethodInfo methodInfo ) { for ( int i = 1 ; i <= methodInfo . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( [[sandalwood]] , methodInfo , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .


--------------------------------------------- Result 781 ---------------------------------------------
Loads the given method argument at the given index . --> invocations of a method --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[improvisation]] ( final MethodVisitor mv , final MethodInfo [[acquitted]] , final int index ) { int offset = [[acquitted]] . getArgumentOffset ( index ) ; int type = [[acquitted]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .


--------------------------------------------- Result 782 ---------------------------------------------
Stores a method argument at the given index . --> helper method --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeMethodArgument]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int [[type]] = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[appeal]] ( final MethodVisitor mv , final MethodInfo methodInfo , final int index ) { int offset = methodInfo . getArgumentOffset ( index ) ; int [[zhang]] = methodInfo . getArgument ( index ) . getOpcode ( ) ; switch ( [[zhang]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , offset ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , offset ) ; break ; default : mv . visitVarInsn ( ASTORE , offset ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .


--------------------------------------------- Result 783 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 512 / 251 / 20 / 783:  78%|███████▊  | 783/1000 [4:43:11<1:18:28, 21.70s/it][Succeeded / Failed / Skipped / Total] 512 / 251 / 20 / 783:  78%|███████▊  | 784/1000 [4:43:37<1:18:08, 21.71s/it][Succeeded / Failed / Skipped / Total] 513 / 251 / 20 / 784:  78%|███████▊  | 784/1000 [4:43:37<1:18:08, 21.71s/it][Succeeded / Failed / Skipped / Total] 513 / 251 / 20 / 784:  78%|███████▊  | 785/1000 [4:43:58<1:17:46, 21.71s/it][Succeeded / Failed / Skipped / Total] 514 / 251 / 20 / 785:  78%|███████▊  | 785/1000 [4:43:58<1:17:46, 21.71s/it][Succeeded / Failed / Skipped / Total] 514 / 251 / 20 / 785:  79%|███████▊  | 786/1000 [4:44:26<1:17:26, 21.71s/it][Succeeded / Failed / Skipped / Total] 515 / 251 / 20 / 786:  79%|███████▊  | 786/1000 [4:44:26<1:17:26, 21.71s/it][Succeeded / Failed / Skipped / Total] 515 / 251 / 20 / 786:  79%|███████▊  | 787/1000 [4:44:34<1:17:01, 21.70s/it][Succeeded / Failed / Skipped / Total] 516 / 251 / 20 / 787:  79%|███████▊  | 787/1000 [4:44:34<1:17:01, 21.70s/it][Succeeded / Failed / Skipped / Total] 516 / 251 / 20 / 787:  79%|███████▉  | 788/1000 [4:45:41<1:16:51, 21.75s/it]Prepare the return value . --> Writes the result of a method --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareReturnValue]] ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int varOffset ) { varOffset += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void [[appoint]] ( final MethodVisitor [[punter]] , final MethodInfo [[blaze]] , int varOffset ) { varOffset += [[blaze]] . getAllArgumentsSize ( ) ; switch ( [[blaze]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[punter]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[punter]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[punter]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .


--------------------------------------------- Result 784 ---------------------------------------------
Creates a signature key for a method signature . --> Returns a string --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String [[methodName]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[blindly]] ( final int access , final String [[bretagne]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[bretagne]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .


--------------------------------------------- Result 785 ---------------------------------------------
Generates instructions for a new array type . --> Bock the given component type --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[bollock]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .


--------------------------------------------- Result 786 ---------------------------------------------
Store into an array . --> superclass method --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor [[mv]] , final Class [[componentType]] ) { if ( [[componentType]] == int . class ) { [[mv]] . visitInsn ( IASTORE ) ; return ; } if ( [[componentType]] == long . class ) { [[mv]] . visitInsn ( LASTORE ) ; return ; } if ( [[componentType]] == float . class ) { [[mv]] . visitInsn ( FASTORE ) ; return ; } if ( [[componentType]] == double . class ) { [[mv]] . visitInsn ( DASTORE ) ; return ; } if ( [[componentType]] == byte . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == short . class ) { [[mv]] . visitInsn ( SASTORE ) ; return ; } if ( [[componentType]] == boolean . class ) { [[mv]] . visitInsn ( BASTORE ) ; return ; } if ( [[componentType]] == char . class ) { [[mv]] . visitInsn ( CASTORE ) ; return ; } [[mv]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[osso]] ( final MethodVisitor [[climax]] , final Class [[barrera]] ) { if ( [[barrera]] == int . class ) { [[climax]] . visitInsn ( IASTORE ) ; return ; } if ( [[barrera]] == long . class ) { [[climax]] . visitInsn ( LASTORE ) ; return ; } if ( [[barrera]] == float . class ) { [[climax]] . visitInsn ( FASTORE ) ; return ; } if ( [[barrera]] == double . class ) { [[climax]] . visitInsn ( DASTORE ) ; return ; } if ( [[barrera]] == byte . class ) { [[climax]] . visitInsn ( BASTORE ) ; return ; } if ( [[barrera]] == short . class ) { [[climax]] . visitInsn ( SASTORE ) ; return ; } if ( [[barrera]] == boolean . class ) { [[climax]] . visitInsn ( BASTORE ) ; return ; } if ( [[barrera]] == char . class ) { [[climax]] . visitInsn ( CASTORE ) ; return ; } [[climax]] . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .


--------------------------------------------- Result 787 ---------------------------------------------
Extract encoding from content type . --> Get flashbulbs --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String contentType , String defaultEncoding ) { String encoding = [[extractEncoding]] ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[flashbulbs]] ( final String contentType , String defaultEncoding ) { String encoding = [[flashbulbs]] ( contentType ) ; if ( encoding == null ) { if ( defaultEncoding == null ) { defaultEncoding = JoddCore . encoding ; } encoding = defaultEncoding ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .


--------------------------------------------- Result 788 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 517 / 251 / 20 / 788:  79%|███████▉  | 788/1000 [4:45:41<1:16:51, 21.75s/it][Succeeded / Failed / Skipped / Total] 517 / 251 / 20 / 788:  79%|███████▉  | 789/1000 [4:46:04<1:16:30, 21.76s/it][Succeeded / Failed / Skipped / Total] 518 / 251 / 20 / 789:  79%|███████▉  | 789/1000 [4:46:04<1:16:30, 21.76s/it][Succeeded / Failed / Skipped / Total] 518 / 251 / 20 / 789:  79%|███████▉  | 790/1000 [4:46:18<1:16:06, 21.75s/it][Succeeded / Failed / Skipped / Total] 519 / 251 / 20 / 790:  79%|███████▉  | 790/1000 [4:46:18<1:16:06, 21.75s/it][Succeeded / Failed / Skipped / Total] 519 / 251 / 20 / 790:  79%|███████▉  | 791/1000 [4:46:46<1:15:46, 21.75s/it][Succeeded / Failed / Skipped / Total] 519 / 252 / 20 / 791:  79%|███████▉  | 791/1000 [4:46:46<1:15:46, 21.75s/it][Succeeded / Failed / Skipped / Total] 519 / 252 / 20 / 791:  79%|███████▉  | 792/1000 [4:47:31<1:15:30, 21.78s/it][Succeeded / Failed / Skipped / Total] 520 / 252 / 20 / 792:  79%|███████▉  | 792/1000 [4:47:31<1:15:30, 21.78s/it][Succeeded / Failed / Skipped / Total] 520 / 252 / 20 / 792:  79%|███████▉  | 793/1000 [4:47:46<1:15:07, 21.77s/it][Succeeded / Failed / Skipped / Total] 521 / 252 / 20 / 793:  79%|███████▉  | 793/1000 [4:47:46<1:15:07, 21.77s/it][Succeeded / Failed / Skipped / Total] 521 / 252 / 20 / 793:  79%|███████▉  | 794/1000 [4:48:14<1:14:47, 21.78s/it][Succeeded / Failed / Skipped / Total] 521 / 253 / 20 / 794:  79%|███████▉  | 794/1000 [4:48:14<1:14:47, 21.78s/it][Succeeded / Failed / Skipped / Total] 521 / 253 / 20 / 794:  80%|███████▉  | 795/1000 [4:48:42<1:14:26, 21.79s/it]Returns true if the flags are empty . --> returns true if the arguments are last modified --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags [[flags]] ) { if ( [[flags]] == null ) return "[[True]]" == "[[True]]" ; Flags . Flag [ ] [[systemFlags]] = [[flags]] . getSystemFlags ( ) ; if ( [[systemFlags]] != null && [[systemFlags]] . length > 0 ) { return False ; } String [ ] userFlags = [[flags]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return False ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[lastly]] ( Flags [[injures]] ) { if ( [[injures]] == null ) return "[["Waggle" == "Waggle"]]" == "[["Waggle" == "Waggle"]]" ; Flags . Flag [ ] [[appomattox]] = [[injures]] . getSystemFlags ( ) ; if ( [[appomattox]] != null && [[appomattox]] . length > 0 ) { return False ; } String [ ] userFlags = [[injures]] . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return False ; } return "[["Waggle" == "Waggle"]]" == "[["Waggle" == "Waggle"]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags


--------------------------------------------- Result 789 ---------------------------------------------
Resolves the bearer token from the given request . --> Extracts the preachers header from the request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest [[request]] ) { String header = [[request]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[preachers]] ( final HttpServletRequest [[barged]] ) { String header = [[barged]] . getHeader ( HEADER_AUTHORIZATION ) ; if ( header == null ) { return null ; } int ndx = header . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return header . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .


--------------------------------------------- Result 790 ---------------------------------------------
Require authentication . --> Sets a Fernet Authorization header --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[britishers]] ( final HttpServletResponse resp , final String realm ) throws IOException { resp . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; resp . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .


--------------------------------------------- Result 791 ---------------------------------------------
Prepares a file to be download . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse [[response]] , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( [[response]] , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[rocke]] ( final HttpServletResponse [[alot]] , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( [[alot]] , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .


--------------------------------------------- Result 792 ---------------------------------------------
Prepare response . --> Writes the content to the output --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareResponse]] ( final HttpServletResponse [[response]] , final String [[fileName]] , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( [[fileName]] != null ) ) { String [[extension]] = FileNameUtil . getExtension ( [[fileName]] ) ; mimeType = MimeTypes . getMimeType ( [[extension]] ) ; } if ( mimeType != null ) { [[response]] . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { [[response]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void [[much]] ( final HttpServletResponse [[cogent]] , final String [[beneficial]] , String mimeType , final int fileSize ) { if ( ( mimeType == null ) && ( [[beneficial]] != null ) ) { String [[boosting]] = FileNameUtil . getExtension ( [[beneficial]] ) ; mimeType = MimeTypes . getMimeType ( [[boosting]] ) ; } if ( mimeType != null ) { [[cogent]] . setContentType ( mimeType ) ; } if ( fileSize >= 0 ) { [[cogent]] . setContentLength ( fileSize ) ; }
[[[[Nl]]]]: Prepares response for various provided data .


--------------------------------------------- Result 793 ---------------------------------------------
Get all cookies with the given name . --> Gets bors for a given cookieName --> Socre: 1.0

[[[[Adv]]]]: public static Cookie [ ] [[getAllCookies]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[list]] = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { [[list]] . add ( cookie ) ; } } if ( [[list]] . isEmpty ( ) ) { return null ; } return [[list]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] [[bors]] ( final HttpServletRequest request , final String cookieName ) { Cookie [ ] cookies = request . getCookies ( ) ; if ( cookies == null ) { return null ; } ArrayList < Cookie > [[dahlgren]] = new ArrayList <> ( cookies . length ) ; for ( Cookie cookie : cookies ) { if ( cookie . getName ( ) . equals ( cookieName ) ) { [[dahlgren]] . add ( cookie ) ; } } if ( [[dahlgren]] . isEmpty ( ) ) { return null ; } return [[dahlgren]] . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .


--------------------------------------------- Result 794 ---------------------------------------------
Read request body from request . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest [[request]] ) throws IOException { BufferedReader buff = [[request]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[breslau]] ( final HttpServletRequest [[gambles]] ) throws IOException { BufferedReader buff = [[gambles]] . getReader ( ) ; StringWriter out = new StringWriter ( ) ; StreamUtil . copy ( buff , out ) ; return out . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!


--------------------------------------------- Result 795 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 253 / 20 / 795:  80%|███████▉  | 795/1000 [4:48:42<1:14:26, 21.79s/it][Succeeded / Failed / Skipped / Total] 522 / 253 / 20 / 795:  80%|███████▉  | 796/1000 [4:49:26<1:14:10, 21.82s/it][Succeeded / Failed / Skipped / Total] 522 / 254 / 20 / 796:  80%|███████▉  | 796/1000 [4:49:26<1:14:10, 21.82s/it][Succeeded / Failed / Skipped / Total] 522 / 254 / 20 / 796:  80%|███████▉  | 797/1000 [4:49:44<1:13:47, 21.81s/it][Succeeded / Failed / Skipped / Total] 523 / 254 / 20 / 797:  80%|███████▉  | 797/1000 [4:49:44<1:13:47, 21.81s/it][Succeeded / Failed / Skipped / Total] 523 / 254 / 20 / 797:  80%|███████▉  | 798/1000 [4:50:49<1:13:37, 21.87s/it][Succeeded / Failed / Skipped / Total] 523 / 255 / 20 / 798:  80%|███████▉  | 798/1000 [4:50:49<1:13:37, 21.87s/it][Succeeded / Failed / Skipped / Total] 523 / 255 / 20 / 798:  80%|███████▉  | 799/1000 [4:51:38<1:13:21, 21.90s/it][Succeeded / Failed / Skipped / Total] 524 / 255 / 20 / 799:  80%|███████▉  | 799/1000 [4:51:38<1:13:21, 21.90s/it][Succeeded / Failed / Skipped / Total] 524 / 255 / 20 / 799:  80%|████████  | 800/1000 [4:52:50<1:13:12, 21.96s/it]Read request body from request . --> returns a String --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromStream]] ( final HttpServletRequest [[request]] ) throws IOException { String charEncoding = [[request]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[request]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[zagreb]] ( final HttpServletRequest [[medic]] ) throws IOException { String charEncoding = [[medic]] . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = [[medic]] . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!


--------------------------------------------- Result 796 ---------------------------------------------
Stores the context path in the request context . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[storeContextPath]] ( final PageContext pageContext , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void [[poisons]] ( final PageContext pageContext , final String [[bun]] ) { String [[gundy]] = getContextPath ( pageContext ) ; HttpServletRequest request = ( HttpServletRequest ) pageContext . getRequest ( ) ; request . setAttribute ( [[bun]] , [[gundy]] ) ; ServletContext [[jellyfish]] = pageContext . getServletContext ( ) ; [[jellyfish]] . setAttribute ( [[bun]] , [[gundy]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .


--------------------------------------------- Result 797 ---------------------------------------------
Stores the context path in the servlet context . --> Sets haggerty to Haggertyty --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeContextPath]] ( final ServletContext servletContext , final String contextPathVariableName ) { String [[ctxPath]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void [[haggerty]] ( final ServletContext servletContext , final String contextPathVariableName ) { String [[cussing]] = getContextPath ( servletContext ) ; servletContext . setAttribute ( contextPathVariableName , [[cussing]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .


--------------------------------------------- Result 798 ---------------------------------------------
Indicates whether the given request is a GET parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] [[nameValuePairs]] = StringUtil . splitc ( query , ' ' ) ; for ( String [[nameValuePair]] : [[nameValuePairs]] ) { if ( [[nameValuePair]] . startsWith ( name ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[ramming]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] [[revision]] = StringUtil . splitc ( query , ' ' ) ; for ( String [[adrenaline]] : [[revision]] ) { if ( [[adrenaline]] . startsWith ( name ) ) { return True ; } } return False ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .


--------------------------------------------- Result 799 ---------------------------------------------
Prepare parameter array . --> Given an array of string members convert the parameter array to a string array --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] [[paramValues]] , final boolean treatEmptyParamsAsNull , final boolean [[ignoreEmptyRequestParams]] ) { if ( treatEmptyParamsAsNull || [[ignoreEmptyRequestParams]] ) { int emptyCount = 0 ; int [[total]] = [[paramValues]] . length ; for ( int i = 0 ; i < [[paramValues]] . length ; i ++ ) { String [[paramValue]] = [[paramValues]] [ i ] ; if ( [[paramValue]] == null ) { emptyCount ++ ; continue ; } if ( [[paramValue]] . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { [[paramValue]] = null ; } } [[paramValues]] [ i ] = [[paramValue]] ; } if ( ( [[ignoreEmptyRequestParams]] ) && ( emptyCount == [[total]] ) ) { return null ; } } return [[paramValues]] ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] [[cellmates]] , final boolean treatEmptyParamsAsNull , final boolean [[wholesome]] ) { if ( treatEmptyParamsAsNull || [[wholesome]] ) { int emptyCount = 0 ; int [[breads]] = [[cellmates]] . length ; for ( int i = 0 ; i < [[cellmates]] . length ; i ++ ) { String [[filomena]] = [[cellmates]] [ i ] ; if ( [[filomena]] == null ) { emptyCount ++ ; continue ; } if ( [[filomena]] . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { [[filomena]] = null ; } } [[cellmates]] [ i ] = [[filomena]] ; } if ( ( [[wholesome]] ) && ( emptyCount == [[breads]] ) ) { return null ; } } return [[cellmates]] ; }
[[[[Nl]]]]: Prepares parameters for further processing .


--------------------------------------------- Result 800 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 524 / 256 / 20 / 800:  80%|████████  | 800/1000 [4:52:50<1:13:12, 21.96s/it][Succeeded / Failed / Skipped / Total] 524 / 256 / 20 / 800:  80%|████████  | 801/1000 [4:53:04<1:12:48, 21.95s/it][Succeeded / Failed / Skipped / Total] 524 / 257 / 20 / 801:  80%|████████  | 801/1000 [4:53:04<1:12:48, 21.95s/it][Succeeded / Failed / Skipped / Total] 524 / 257 / 20 / 801:  80%|████████  | 802/1000 [4:53:28<1:12:27, 21.96s/it][Succeeded / Failed / Skipped / Total] 524 / 258 / 20 / 802:  80%|████████  | 802/1000 [4:53:28<1:12:27, 21.96s/it][Succeeded / Failed / Skipped / Total] 524 / 258 / 20 / 802:  80%|████████  | 803/1000 [4:53:53<1:12:05, 21.96s/it][Succeeded / Failed / Skipped / Total] 525 / 258 / 20 / 803:  80%|████████  | 803/1000 [4:53:53<1:12:05, 21.96s/it][Succeeded / Failed / Skipped / Total] 525 / 258 / 20 / 803:  80%|████████  | 804/1000 [4:54:18<1:11:44, 21.96s/it][Succeeded / Failed / Skipped / Total] 525 / 259 / 20 / 804:  80%|████████  | 804/1000 [4:54:18<1:11:44, 21.96s/it][Succeeded / Failed / Skipped / Total] 525 / 259 / 20 / 804:  80%|████████  | 805/1000 [4:54:29<1:11:20, 21.95s/it][Succeeded / Failed / Skipped / Total] 525 / 260 / 20 / 805:  80%|████████  | 805/1000 [4:54:29<1:11:20, 21.95s/it][Succeeded / Failed / Skipped / Total] 525 / 260 / 20 / 805:  81%|████████  | 806/1000 [4:54:51<1:10:58, 21.95s/it][Succeeded / Failed / Skipped / Total] 526 / 260 / 20 / 806:  81%|████████  | 806/1000 [4:54:51<1:10:58, 21.95s/it][Succeeded / Failed / Skipped / Total] 526 / 260 / 20 / 806:  81%|████████  | 807/1000 [4:55:03<1:10:33, 21.94s/it][Succeeded / Failed / Skipped / Total] 527 / 260 / 20 / 807:  81%|████████  | 807/1000 [4:55:03<1:10:33, 21.94s/it][Succeeded / Failed / Skipped / Total] 527 / 260 / 20 / 807:  81%|████████  | 808/1000 [4:55:10<1:10:08, 21.92s/it]Copies the parameters from the given ServletRequest into the attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[copyParamsToAttributes]] ( final HttpServletRequest [[servletRequest]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration [[paramNames]] = [[servletRequest]] . getParameterNames ( ) ; while ( [[paramNames]] . hasMoreElements ( ) ) { String paramName = ( String ) [[paramNames]] . nextElement ( ) ; if ( [[servletRequest]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = [[servletRequest]] . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } [[servletRequest]] . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void [[laden]] ( final HttpServletRequest [[monopolize]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration [[lighten]] = [[monopolize]] . getParameterNames ( ) ; while ( [[lighten]] . hasMoreElements ( ) ) { String paramName = ( String ) [[lighten]] . nextElement ( ) ; if ( [[monopolize]] . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = [[monopolize]] . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } [[monopolize]] . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .


--------------------------------------------- Result 801 ---------------------------------------------
Invokes the tag . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment [[body]] ) throws JspException { if ( [[body]] == null ) { return ; } try { [[body]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[nicotine]] ( final JspFragment [[stirring]] ) throws JspException { if ( [[stirring]] == null ) { return ; } try { [[stirring]] . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .


--------------------------------------------- Result 802 ---------------------------------------------
Render the given fragment . --> [[[FAILED]]]

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[references]] ( final JspFragment [[katrine]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[katrine]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .


--------------------------------------------- Result 803 ---------------------------------------------
Renders the given fragment to a string . --> Generates a human - readable markup for the whole article --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] [[result]] = renderBody ( [[body]] ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[skis]] ( final JspFragment [[economic]] ) throws JspException { char [ ] [[erupted]] = renderBody ( [[economic]] ) ; return new String ( [[erupted]] ) ; }
[[[[Nl]]]]: Renders tag body to string .


--------------------------------------------- Result 804 ---------------------------------------------
Invokes init method with specified strategy . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[hammonds]] ( final InitMethodInvocationStrategy [[mechanism]] ) { for ( final InitMethodPoint [[bellybutton]] : beanDefinition . initMethodPoints ( ) ) { if ( [[mechanism]] != [[bellybutton]] . invocationStrategy ) { continue ; } try { [[bellybutton]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[bellybutton]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .


--------------------------------------------- Result 805 ---------------------------------------------
Call destroy method . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[jenner]] ( ) { for ( final DestroyMethodPoint destroyMethodPoint : beanDefinition . destroyMethodPoints ( ) ) { try { destroyMethodPoint . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + destroyMethodPoint . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .


--------------------------------------------- Result 806 ---------------------------------------------
Instantiate bean instance . --> Recover the bean definition --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[paramNo]] = beanDefinition . ctor . references . length ; Object [ ] [[args]] = new Object [ [[paramNo]] ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[remark]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int [[fold]] = beanDefinition . ctor . references . length ; Object [ ] [[boomer]] = new Object [ [[fold]] ] ;
[[[[Nl]]]]: Creates a new instance .


--------------------------------------------- Result 807 ---------------------------------------------
Inject bean parameters . --> Inject bean definition --> Socre: 1.0

[[[[Adv]]]]: public void injectParams ( final ParamManager [[paramManager]] , final boolean [[implicitParamInjection]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[implicitParamInjection]] ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void injectParams ( final ParamManager [[braids]] , final boolean [[escapist]] ) { if ( beanDefinition . name == null ) { return ; } if ( [[escapist]] ) {
[[[[Nl]]]]: Injects all parameters .


--------------------------------------------- Result 808 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 528 / 260 / 20 / 808:  81%|████████  | 808/1000 [4:55:10<1:10:08, 21.92s/it][Succeeded / Failed / Skipped / Total] 528 / 260 / 20 / 808:  81%|████████  | 809/1000 [4:55:18<1:09:43, 21.90s/it][Succeeded / Failed / Skipped / Total] 529 / 260 / 20 / 809:  81%|████████  | 809/1000 [4:55:18<1:09:43, 21.90s/it][Succeeded / Failed / Skipped / Total] 529 / 260 / 20 / 809:  81%|████████  | 810/1000 [4:55:42<1:09:21, 21.90s/it][Succeeded / Failed / Skipped / Total] 530 / 260 / 20 / 810:  81%|████████  | 810/1000 [4:55:42<1:09:21, 21.90s/it][Succeeded / Failed / Skipped / Total] 530 / 260 / 20 / 810:  81%|████████  | 811/1000 [4:56:00<1:08:59, 21.90s/it][Succeeded / Failed / Skipped / Total] 531 / 260 / 20 / 811:  81%|████████  | 811/1000 [4:56:00<1:08:59, 21.90s/it][Succeeded / Failed / Skipped / Total] 531 / 260 / 20 / 811:  81%|████████  | 812/1000 [4:56:17<1:08:35, 21.89s/it][Succeeded / Failed / Skipped / Total] 532 / 260 / 20 / 812:  81%|████████  | 812/1000 [4:56:17<1:08:35, 21.89s/it][Succeeded / Failed / Skipped / Total] 532 / 260 / 20 / 812:  81%|████████▏ | 813/1000 [4:57:00<1:08:18, 21.92s/it][Succeeded / Failed / Skipped / Total] 532 / 261 / 20 / 813:  81%|████████▏ | 813/1000 [4:57:00<1:08:18, 21.92s/it][Succeeded / Failed / Skipped / Total] 532 / 261 / 20 / 813:  81%|████████▏ | 814/1000 [4:57:07<1:07:53, 21.90s/it][Succeeded / Failed / Skipped / Total] 533 / 261 / 20 / 814:  81%|████████▏ | 814/1000 [4:57:07<1:07:53, 21.90s/it][Succeeded / Failed / Skipped / Total] 533 / 261 / 20 / 814:  82%|████████▏ | 815/1000 [4:57:55<1:07:37, 21.93s/it][Succeeded / Failed / Skipped / Total] 534 / 261 / 20 / 815:  82%|████████▏ | 815/1000 [4:57:55<1:07:37, 21.93s/it][Succeeded / Failed / Skipped / Total] 534 / 261 / 20 / 815:  82%|████████▏ | 816/1000 [4:58:03<1:07:12, 21.92s/it][Succeeded / Failed / Skipped / Total] 535 / 261 / 20 / 816:  82%|████████▏ | 816/1000 [4:58:03<1:07:12, 21.92s/it][Succeeded / Failed / Skipped / Total] 535 / 261 / 20 / 816:  82%|████████▏ | 817/1000 [4:58:32<1:06:52, 21.92s/it]Rewrite the path . --> Rewrite the HttpServlet --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[equivocation]] , final String httpMethod ) { return [[equivocation]] ; }
[[[[Nl]]]]: Rewrites action path .


--------------------------------------------- Result 809 ---------------------------------------------
Adds a header . --> Add charges for this element --> Socre: 1.0

[[[[Adv]]]]: public void [[addHeader]] ( final String name , final String value ) { List < String > valuesList = super . getAll ( name ) ; if ( valuesList . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valuesList . add ( value ) ; super . addAll ( name , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void [[charges]] ( final String name , final String value ) { List < String > valuesList = super . getAll ( name ) ; if ( valuesList . isEmpty ( ) ) { super . add ( name , value ) ; return ; } super . remove ( name ) ; valuesList . add ( value ) ; super . addAll ( name , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .


--------------------------------------------- Result 810 ---------------------------------------------
Puts a value into the properties map . --> Put property . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String [[profile]] , final Map < String , PropsEntry > map , final String [[key]] , final String value , final boolean [[append]] ) { String realValue = value ; if ( [[append]] || appendDuplicateProps ) { PropsEntry pv = map . get ( [[key]] ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( [[key]] , realValue , [[profile]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String [[debt]] , final Map < String , PropsEntry > map , final String [[shatter]] , final String value , final boolean [[manes]] ) { String realValue = value ; if ( [[manes]] || appendDuplicateProps ) { PropsEntry pv = map . get ( [[shatter]] ) ; if ( pv != null ) { realValue = pv . value + APPEND_SEPARATOR + realValue ; } } PropsEntry propsEntry = new PropsEntry ( [[shatter]] , realValue , [[debt]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties


--------------------------------------------- Result 811 ---------------------------------------------
Puts baseProperties into this context . --> Hijackings and append them to Hibernate properties --> Socre: 1.0

[[[[Adv]]]]: public void [[putBaseProperty]] ( final String [[key]] , final String value , final boolean append ) { put ( null , baseProperties , [[key]] , value , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void [[hijackings]] ( final String [[hayate]] , final String value , final boolean append ) { put ( null , baseProperties , [[hayate]] , value , append ) ; }
[[[[Nl]]]]: Adds base property .


--------------------------------------------- Result 812 ---------------------------------------------
Adds a profile property . --> Deer a profiler --> Socre: 1.0

[[[[Adv]]]]: public void [[putProfileProperty]] ( final String key , final String value , final String profile , final boolean [[append]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , [[append]] ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void [[demerol]] ( final String key , final String value , final String profile , final boolean [[woodlawn]] ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , [[woodlawn]] ) ; }
[[[[Nl]]]]: Adds profile property .


--------------------------------------------- Result 813 ---------------------------------------------
Get a property from profile --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String [[key]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[profile]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[key]] ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[unsociable]] ( final String [[repressive]] , final String [[cami]] ) { final Map < String , PropsEntry > profileMap = profileProperties . get ( [[repressive]] ) ; if ( profileMap == null ) { return null ; } return profileMap . get ( [[cami]] ) ; }
[[[[Nl]]]]: Returns profile property .


--------------------------------------------- Result 814 ---------------------------------------------
Resolves the given string with the given profiles . --> Blow a blither string --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveMacros]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String [[blithering]] ( String value , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .


--------------------------------------------- Result 815 ---------------------------------------------
Extracts a map from profiles . --> also used for tests --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map [[target]] , final String [ ] profiles , final String [ ] [[wildcardPatterns]] , String prefix ) { if ( [[target]] == null ) { [[target]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[honked]] ( Map [[crosswords]] , final String [ ] profiles , final String [ ] [[areat]] , String prefix ) { if ( [[crosswords]] == null ) { [[crosswords]] = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .


--------------------------------------------- Result 816 ---------------------------------------------
Read a stream toword --> Reads stream toword --> Socre: 1.0

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int [[i]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[i]] = 0 ; [[i]] < 4 ; [[i]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int streamtoword ( byte [ ] data , int [ ] offp ) { int [[plano]] ; int word = 0 ; int off = offp [ 0 ] ; for ( [[plano]] = 0 ; [[plano]] < 4 ; [[plano]] ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .


--------------------------------------------- Result 817 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 536 / 261 / 20 / 817:  82%|████████▏ | 817/1000 [4:58:32<1:06:52, 21.92s/it][Succeeded / Failed / Skipped / Total] 536 / 261 / 20 / 817:  82%|████████▏ | 818/1000 [4:58:49<1:06:29, 21.92s/it][Succeeded / Failed / Skipped / Total] 537 / 261 / 20 / 818:  82%|████████▏ | 818/1000 [4:58:49<1:06:29, 21.92s/it][Succeeded / Failed / Skipped / Total] 537 / 261 / 20 / 818:  82%|████████▏ | 819/1000 [4:59:19<1:06:09, 21.93s/it][Succeeded / Failed / Skipped / Total] 538 / 261 / 20 / 819:  82%|████████▏ | 819/1000 [4:59:19<1:06:09, 21.93s/it][Succeeded / Failed / Skipped / Total] 538 / 261 / 20 / 819:  82%|████████▏ | 820/1000 [4:59:50<1:05:49, 21.94s/it][Succeeded / Failed / Skipped / Total] 539 / 261 / 20 / 820:  82%|████████▏ | 820/1000 [4:59:50<1:05:49, 21.94s/it][Succeeded / Failed / Skipped / Total] 539 / 261 / 20 / 820:  82%|████████▏ | 821/1000 [5:00:40<1:05:33, 21.97s/it][Succeeded / Failed / Skipped / Total] 539 / 262 / 20 / 821:  82%|████████▏ | 821/1000 [5:00:40<1:05:33, 21.97s/it][Succeeded / Failed / Skipped / Total] 539 / 262 / 20 / 821:  82%|████████▏ | 822/1000 [5:00:54<1:05:09, 21.96s/it][Succeeded / Failed / Skipped / Total] 540 / 262 / 20 / 822:  82%|████████▏ | 822/1000 [5:00:54<1:05:09, 21.96s/it][Succeeded / Failed / Skipped / Total] 540 / 262 / 20 / 822:  82%|████████▏ | 823/1000 [5:01:18<1:04:47, 21.97s/it][Succeeded / Failed / Skipped / Total] 541 / 262 / 20 / 823:  82%|████████▏ | 823/1000 [5:01:18<1:04:47, 21.97s/it][Succeeded / Failed / Skipped / Total] 541 / 262 / 20 / 823:  82%|████████▏ | 824/1000 [5:02:00<1:04:30, 21.99s/it]Hashes a password with the given salt . --> Bss of Bss --> Socre: 1.0

[[[[Adv]]]]: public static String [[hashpw]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , [[saltb]] , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String [[bss]] ( String password , String salt ) { BCrypt B ; String real_salt ; byte [ ] passwordb , [[blabbering]] , hashed ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .


--------------------------------------------- Result 818 ---------------------------------------------
Checks if the specified string matches the password . --> Checks if the given string has the same length --> Socre: 1.0

[[[[Adv]]]]: public static boolean checkpw ( String [[plaintext]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String [[try_pw]] = hashpw ( [[plaintext]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = [[try_pw]] . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return False ; } if ( hashed_bytes . length != try_bytes . length ) { return False ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String [[suspensions]] , String hashed ) { byte [ ] hashed_bytes ; byte [ ] try_bytes ; try { String [[characterized]] = hashpw ( [[suspensions]] , hashed ) ; hashed_bytes = hashed . getBytes ( "UTF-8" ) ; try_bytes = [[characterized]] . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return False ; } if ( hashed_bytes . length != try_bytes . length ) { return False ; } byte ret = 0 ; for ( int i = 0 ; i < try_bytes . length ; i ++ ) { ret |= hashed_bytes [ i ] ^ try_bytes [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .


--------------------------------------------- Result 819 ---------------------------------------------
Copies all data to the output stream . --> Reads in aramarine --> Socre: 1.0

[[[[Adv]]]]: public int [[copyAll]] ( final OutputStream [[out]] ) throws IOException { int count = 0 ; while ( True ) { byte [[b]] = readByte ( ) ; if ( isBoundary ( [[b]] ) ) { break ; } [[out]] . write ( [[b]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int [[aramis]] ( final OutputStream [[aquamarine]] ) throws IOException { int count = 0 ; while ( True ) { byte [[booger]] = readByte ( ) ; if ( isBoundary ( [[booger]] ) ) { break ; } [[aquamarine]] . write ( [[booger]] ) ; count ++ ; } return count ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .


--------------------------------------------- Result 820 ---------------------------------------------
Copies bytes from the input stream to the given output stream . --> Advance boundary --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream out , final int [[maxBytes]] ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[maxBytes]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[adapting]] ( final OutputStream out , final int [[monterey]] ) throws IOException { int count = 0 ; while ( "[["Aly" == "Aly"]]" == "[["Aly" == "Aly"]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == [[monterey]] ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .


--------------------------------------------- Result 821 ---------------------------------------------
Parses the action configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime [[parse]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition [[actionDefinition]] ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime [[bruna]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition [[donk]] ) { final ActionAnnotationValues annotationValues = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( annotationValues ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .


--------------------------------------------- Result 822 ---------------------------------------------
Resolves the action config . --> Helper method to lookup the ActionConfig --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > annotationType ; if ( [[annotationValues]] == null ) { annotationType = Action . class ; } else { annotationType = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[arlin]] ( final ActionAnnotationValues [[girls]] ) { final Class < ? extends Annotation > annotationType ; if ( [[girls]] == null ) { annotationType = Action . class ; } else { annotationType = [[girls]] . annotationType ( ) ; } return actionConfigManager . lookup ( annotationType ) ; }
[[[[Nl]]]]: Resolves action config .


--------------------------------------------- Result 823 ---------------------------------------------
Detect and register alias . --> Register enrico --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues [[annotationValues]] , final ActionDefinition [[actionDefinition]] ) { final String alias = parseMethodAlias ( [[annotationValues]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[actionDefinition]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[enrico]] ( final ActionAnnotationValues [[accede]] , final ActionDefinition [[displeasure]] ) { final String alias = parseMethodAlias ( [[accede]] ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( [[displeasure]] . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .


[Succeeded / Failed / Skipped / Total] 541 / 263 / 20 / 824:  82%|████████▏ | 824/1000 [5:02:00<1:04:30, 21.99s/it][Succeeded / Failed / Skipped / Total] 541 / 263 / 20 / 824:  82%|████████▎ | 825/1000 [5:02:35<1:04:11, 22.01s/it][Succeeded / Failed / Skipped / Total] 541 / 264 / 20 / 825:  82%|████████▎ | 825/1000 [5:02:35<1:04:11, 22.01s/it][Succeeded / Failed / Skipped / Total] 541 / 264 / 20 / 825:  83%|████████▎ | 826/1000 [5:03:02<1:03:50, 22.01s/it][Succeeded / Failed / Skipped / Total] 541 / 265 / 20 / 826:  83%|████████▎ | 826/1000 [5:03:02<1:03:50, 22.01s/it][Succeeded / Failed / Skipped / Total] 541 / 265 / 20 / 826:  83%|████████▎ | 827/1000 [5:03:16<1:03:26, 22.00s/it][Succeeded / Failed / Skipped / Total] 542 / 265 / 20 / 827:  83%|████████▎ | 827/1000 [5:03:16<1:03:26, 22.00s/it][Succeeded / Failed / Skipped / Total] 542 / 265 / 20 / 827:  83%|████████▎ | 828/1000 [5:03:36<1:03:04, 22.00s/it][Succeeded / Failed / Skipped / Total] 543 / 265 / 20 / 828:  83%|████████▎ | 828/1000 [5:03:36<1:03:04, 22.00s/it][Succeeded / Failed / Skipped / Total] 543 / 265 / 20 / 828:  83%|████████▎ | 829/1000 [5:04:55<1:02:53, 22.07s/it][Succeeded / Failed / Skipped / Total] 543 / 266 / 20 / 829:  83%|████████▎ | 829/1000 [5:04:55<1:02:53, 22.07s/it][Succeeded / Failed / Skipped / Total] 543 / 266 / 20 / 829:  83%|████████▎ | 830/1000 [5:05:01<1:02:28, 22.05s/it][Succeeded / Failed / Skipped / Total] 544 / 266 / 20 / 830:  83%|████████▎ | 830/1000 [5:05:01<1:02:28, 22.05s/it][Succeeded / Failed / Skipped / Total] 544 / 266 / 20 / 830:  83%|████████▎ | 831/1000 [5:05:16<1:02:05, 22.04s/it]--------------------------------------------- Result 824 ---------------------------------------------
Reads the interceptors associated with the given element . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy [[interceptedBy]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { result = [[interceptedBy]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[woww]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] result = null ; InterceptedBy [[beaner]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[beaner]] != null ) { result = [[beaner]] . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .


--------------------------------------------- Result 825 ---------------------------------------------
Read the filtered filters . --> [[[FAILED]]]

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[result]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[result]] = filteredBy . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[inhibit]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionFilter > [ ] [[foxy]] = null ; FilteredBy filteredBy = actionClassOrMethod . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { [[foxy]] = filteredBy . value ( ) ; if ( [[foxy]] . length == 0 ) { [[foxy]] = null ; } } return [[foxy]] ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .


--------------------------------------------- Result 826 ---------------------------------------------
Read package action path . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[bboying]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String actionPackageName = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .


--------------------------------------------- Result 827 ---------------------------------------------
Read the action path . --> Implementation of antunio --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String [[methodName]] , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[antónio]] ( final String [[aw]] , final ActionAnnotationValues annotationValues , final ActionConfig actionConfig ) {
[[[[Nl]]]]: Reads action path from the action method .


--------------------------------------------- Result 828 ---------------------------------------------
Parses the alias attribute . --> Calculate the acronym --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String [[alias]] = null ; if ( annotationValues != null ) { [[alias]] = annotationValues . alias ( ) ; } return [[alias]] ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[beneficiaries]] ( final ActionAnnotationValues annotationValues ) { String [[excommunication]] = null ; if ( annotationValues != null ) { [[excommunication]] = annotationValues . alias ( ) ; } return [[excommunication]] ; }
[[[[Nl]]]]: Reads method s alias value .


--------------------------------------------- Result 829 ---------------------------------------------
Create action runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime [[createActionRuntime]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData [[scopeData]] = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime [[timer]] ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > defaultActionResult , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData [[identities]] = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .


--------------------------------------------- Result 830 ---------------------------------------------
Sets the response header to the response . --> Sets the response . --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[preResponseCommit]] ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?

[[[[Adv]]]]: @ Override protected void [[academy]] ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?


--------------------------------------------- Result 831 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 544 / 267 / 20 / 831:  83%|████████▎ | 831/1000 [5:05:16<1:02:05, 22.04s/it][Succeeded / Failed / Skipped / Total] 544 / 267 / 20 / 831:  83%|████████▎ | 832/1000 [5:05:53<1:01:46, 22.06s/it][Succeeded / Failed / Skipped / Total] 545 / 267 / 20 / 832:  83%|████████▎ | 832/1000 [5:05:53<1:01:46, 22.06s/it][Succeeded / Failed / Skipped / Total] 545 / 267 / 20 / 832:  83%|████████▎ | 833/1000 [5:06:18<1:01:24, 22.06s/it][Succeeded / Failed / Skipped / Total] 546 / 267 / 20 / 833:  83%|████████▎ | 833/1000 [5:06:18<1:01:24, 22.06s/it][Succeeded / Failed / Skipped / Total] 546 / 267 / 20 / 833:  83%|████████▎ | 834/1000 [5:06:25<1:00:59, 22.05s/it][Succeeded / Failed / Skipped / Total] 547 / 267 / 20 / 834:  83%|████████▎ | 834/1000 [5:06:25<1:00:59, 22.05s/it][Succeeded / Failed / Skipped / Total] 547 / 267 / 20 / 834:  84%|████████▎ | 835/1000 [5:06:40<1:00:35, 22.04s/it][Succeeded / Failed / Skipped / Total] 548 / 267 / 20 / 835:  84%|████████▎ | 835/1000 [5:06:40<1:00:35, 22.04s/it][Succeeded / Failed / Skipped / Total] 548 / 267 / 20 / 835:  84%|████████▎ | 836/1000 [5:07:06<1:00:14, 22.04s/it][Succeeded / Failed / Skipped / Total] 548 / 268 / 20 / 836:  84%|████████▎ | 836/1000 [5:07:06<1:00:14, 22.04s/it][Succeeded / Failed / Skipped / Total] 548 / 268 / 20 / 836:  84%|████████▎ | 837/1000 [5:07:36<59:54, 22.05s/it]  [Succeeded / Failed / Skipped / Total] 548 / 269 / 20 / 837:  84%|████████▎ | 837/1000 [5:07:36<59:54, 22.05s/it][Succeeded / Failed / Skipped / Total] 548 / 269 / 20 / 837:  84%|████████▍ | 838/1000 [5:07:56<59:31, 22.05s/it][Succeeded / Failed / Skipped / Total] 548 / 270 / 20 / 838:  84%|████████▍ | 838/1000 [5:07:56<59:31, 22.05s/it][Succeeded / Failed / Skipped / Total] 548 / 270 / 20 / 838:  84%|████████▍ | 839/1000 [5:08:28<59:11, 22.06s/it][Succeeded / Failed / Skipped / Total] 549 / 270 / 20 / 839:  84%|████████▍ | 839/1000 [5:08:28<59:11, 22.06s/it][Succeeded / Failed / Skipped / Total] 549 / 270 / 20 / 839:  84%|████████▍ | 840/1000 [5:08:53<58:50, 22.06s/it][Succeeded / Failed / Skipped / Total] 550 / 270 / 20 / 840:  84%|████████▍ | 840/1000 [5:08:53<58:50, 22.06s/it][Succeeded / Failed / Skipped / Total] 550 / 270 / 20 / 840:  84%|████████▍ | 841/1000 [5:09:01<58:25, 22.05s/it]Apply advice to target class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class [[adviceClass]] = cache . get ( targetClass ) ; if ( [[adviceClass]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[affluent]] > [[affluent]] applyAdvice ( final Class < [[affluent]] > targetClass ) { Class [[boozy]] = cache . get ( targetClass ) ; if ( [[boozy]] == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .


--------------------------------------------- Result 832 ---------------------------------------------
Inject target . --> Instances the given colloquial --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object [[proxy]] , final Object [[target]] ) { Class [[proxyClass]] = [[proxy]] . getClass ( ) ; try { Field [[field]] = [[proxyClass]] . getField ( "$___target$0" ) ; [[field]] . set ( [[proxy]] , [[target]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[alike]] ( final Object [[colloquial]] , final Object [[socially]] ) { Class [[bizet]] = [[colloquial]] . getClass ( ) ; try { Field [[carsick]] = [[bizet]] . getField ( "$___target$0" ) ; [[carsick]] . set ( [[colloquial]] , [[socially]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .


--------------------------------------------- Result 833 ---------------------------------------------
Visits an annotation . --> returns a boolean --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean [[visible]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , [[visible]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[believe]] ( final String [[littlejohn]] , final boolean [[bohème]] ) { if ( fv != null ) { return fv . visitAnnotation ( [[littlejohn]] , [[bohème]] ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .


--------------------------------------------- Result 834 ---------------------------------------------
Resolves real name . --> Returns the gangsta for the given jsonName --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String [[gangsta]] ( final String jsonName ) { if ( jsonNames == null ) { return jsonName ; } int jsonIndex = ArraysUtil . indexOf ( jsonNames , jsonName ) ; if ( jsonIndex == - 1 ) { return jsonName ; } return realNames [ jsonIndex ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .


--------------------------------------------- Result 835 ---------------------------------------------
Resolves real name . --> Returns rossana --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final String realName ) { if ( realNames == null ) { return realName ; } int [[realIndex]] = ArraysUtil . indexOf ( realNames , realName ) ; if ( [[realIndex]] == - 1 ) { return realName ; } return jsonNames [ [[realIndex]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String [[rossana]] ( final String realName ) { if ( realNames == null ) { return realName ; } int [[analysts]] = ArraysUtil . indexOf ( realNames , realName ) ; if ( [[analysts]] == - 1 ) { return realName ; } return jsonNames [ [[analysts]] ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .


--------------------------------------------- Result 836 ---------------------------------------------
Looks up the type data for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { if ( serializationSubclassAware ) { [[typeData]] = findSubclassTypeData ( [[type]] ) ; } if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } } return [[typeData]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[bluestones]] ( final Class [[timeout]] ) { TypeData [[calibers]] = typeDataMap . get ( [[timeout]] ) ; if ( [[calibers]] == null ) { if ( serializationSubclassAware ) { [[calibers]] = findSubclassTypeData ( [[timeout]] ) ; } if ( [[calibers]] == null ) { [[calibers]] = scanClassForAnnotations ( [[timeout]] ) ; typeDataMap . put ( [[timeout]] , [[calibers]] ) ; } } return [[calibers]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .


--------------------------------------------- Result 837 ---------------------------------------------
Looks up the type data for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[lissie]] ( final Class [[postmortem]] ) { TypeData [[exclusion]] = typeDataMap . get ( [[postmortem]] ) ; if ( [[exclusion]] == null ) { [[exclusion]] = scanClassForAnnotations ( [[postmortem]] ) ; typeDataMap . put ( [[postmortem]] , [[exclusion]] ) ; } return [[exclusion]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .


--------------------------------------------- Result 838 ---------------------------------------------
Find type data . --> [[[FAILED]]]

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[asterisk]] ( final Class type ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( type . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .


--------------------------------------------- Result 839 ---------------------------------------------
Resolves a Json name . --> Creates an annexe --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class [[type]] , final String [[name]] ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveJsonName ( [[name]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[annexe]] ( final Class [[hunger]] , final String [[permission]] ) { TypeData typeData = lookupTypeData ( [[hunger]] ) ; return typeData . resolveJsonName ( [[permission]] ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .


--------------------------------------------- Result 840 ---------------------------------------------
Resolves the real name for the given JSON name . --> Performs fingerprinting on type --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class type , final String jsonName ) { TypeData [[typeData]] = lookupTypeData ( type ) ; return [[typeData]] . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[perfidy]] ( final Class type , final String jsonName ) { TypeData [[stockbrokers]] = lookupTypeData ( type ) ; return [[stockbrokers]] . resolveRealName ( jsonName ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .


[Succeeded / Failed / Skipped / Total] 550 / 271 / 20 / 841:  84%|████████▍ | 841/1000 [5:09:01<58:25, 22.05s/it][Succeeded / Failed / Skipped / Total] 550 / 271 / 20 / 841:  84%|████████▍ | 842/1000 [5:09:18<58:02, 22.04s/it][Succeeded / Failed / Skipped / Total] 551 / 271 / 20 / 842:  84%|████████▍ | 842/1000 [5:09:18<58:02, 22.04s/it][Succeeded / Failed / Skipped / Total] 551 / 271 / 20 / 842:  84%|████████▍ | 843/1000 [5:09:39<57:40, 22.04s/it][Succeeded / Failed / Skipped / Total] 552 / 271 / 20 / 843:  84%|████████▍ | 843/1000 [5:09:39<57:40, 22.04s/it][Succeeded / Failed / Skipped / Total] 552 / 271 / 20 / 843:  84%|████████▍ | 844/1000 [5:09:54<57:16, 22.03s/it][Succeeded / Failed / Skipped / Total] 553 / 271 / 20 / 844:  84%|████████▍ | 844/1000 [5:09:54<57:16, 22.03s/it][Succeeded / Failed / Skipped / Total] 553 / 271 / 20 / 844:  84%|████████▍ | 845/1000 [5:10:07<56:53, 22.02s/it][Succeeded / Failed / Skipped / Total] 554 / 271 / 20 / 845:  84%|████████▍ | 845/1000 [5:10:07<56:53, 22.02s/it][Succeeded / Failed / Skipped / Total] 554 / 271 / 20 / 845:  85%|████████▍ | 846/1000 [5:10:44<56:33, 22.04s/it][Succeeded / Failed / Skipped / Total] 554 / 272 / 20 / 846:  85%|████████▍ | 846/1000 [5:10:44<56:33, 22.04s/it][Succeeded / Failed / Skipped / Total] 554 / 272 / 20 / 846:  85%|████████▍ | 847/1000 [5:11:38<56:17, 22.08s/it][Succeeded / Failed / Skipped / Total] 555 / 272 / 20 / 847:  85%|████████▍ | 847/1000 [5:11:38<56:17, 22.08s/it][Succeeded / Failed / Skipped / Total] 555 / 272 / 20 / 847:  85%|████████▍ | 848/1000 [5:12:38<56:02, 22.12s/it]--------------------------------------------- Result 841 ---------------------------------------------
Gets the file content . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[arlequin]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .


--------------------------------------------- Result 842 ---------------------------------------------
Copy the bootstrap methods from the class reader . --> expector --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] [[charBuffer]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[cherbourg]] ( final ClassReader classReader , final char [ ] [[accosted]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .


--------------------------------------------- Result 843 ---------------------------------------------
Sets the major version and class . --> start rampart --> Socre: 1.0

[[[[Adv]]]]: int [[setMajorVersionAndClassName]] ( final int majorVersion , final String [[className]] ) { this . majorVersion = majorVersion ; this . className = [[className]] ; return addConstantClass ( [[className]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int [[rampart]] ( final int majorVersion , final String [[prozac]] ) { this . majorVersion = majorVersion ; this . className = [[prozac]] ; return addConstantClass ( [[prozac]] ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .


--------------------------------------------- Result 844 ---------------------------------------------
Puts a constant pool entry . --> Writes a cyanideide program --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector [[output]] ) { [[output]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[cyanide]] ( final ByteVector [[precepts]] ) { [[precepts]] . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .


--------------------------------------------- Result 845 ---------------------------------------------
Puts the bootstrap methods . --> Write Cheaters --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[cheaters]] ( final ByteVector [[brzezinski]] ) { if ( bootstrapMethods != null ) { [[brzezinski]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .


--------------------------------------------- Result 846 ---------------------------------------------
Adds a constant field ref to the symbol table . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String [[descriptor]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , [[descriptor]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantFieldref ( final String owner , final String name , final String [[gratin]] ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , name , [[gratin]] ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 847 ---------------------------------------------
Adds a method ref to this symbol table reference . --> Epilogue --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodref]] ( final String [[owner]] , final String [[name]] , final String descriptor , final boolean [[isInterface]] ) { int tag = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[owner]] , [[name]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[epilogue]] ( final String [[configured]] , final String [[cabrón]] , final String descriptor , final boolean [[alom]] ) { int tag = [[alom]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( tag , [[configured]] , [[cabrón]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 848 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 555 / 273 / 20 / 848:  85%|████████▍ | 848/1000 [5:12:38<56:02, 22.12s/it][Succeeded / Failed / Skipped / Total] 555 / 273 / 20 / 848:  85%|████████▍ | 849/1000 [5:13:13<55:42, 22.14s/it][Succeeded / Failed / Skipped / Total] 556 / 273 / 20 / 849:  85%|████████▍ | 849/1000 [5:13:13<55:42, 22.14s/it][Succeeded / Failed / Skipped / Total] 556 / 273 / 20 / 849:  85%|████████▌ | 850/1000 [5:13:48<55:22, 22.15s/it][Succeeded / Failed / Skipped / Total] 557 / 273 / 20 / 850:  85%|████████▌ | 850/1000 [5:13:48<55:22, 22.15s/it][Succeeded / Failed / Skipped / Total] 557 / 273 / 20 / 850:  85%|████████▌ | 851/1000 [5:14:16<55:01, 22.16s/it][Succeeded / Failed / Skipped / Total] 558 / 273 / 20 / 851:  85%|████████▌ | 851/1000 [5:14:16<55:01, 22.16s/it][Succeeded / Failed / Skipped / Total] 558 / 273 / 20 / 851:  85%|████████▌ | 852/1000 [5:15:07<54:44, 22.19s/it][Succeeded / Failed / Skipped / Total] 558 / 274 / 20 / 852:  85%|████████▌ | 852/1000 [5:15:07<54:44, 22.19s/it][Succeeded / Failed / Skipped / Total] 558 / 274 / 20 / 852:  85%|████████▌ | 853/1000 [5:15:22<54:20, 22.18s/it][Succeeded / Failed / Skipped / Total] 559 / 274 / 20 / 853:  85%|████████▌ | 853/1000 [5:15:22<54:20, 22.18s/it][Succeeded / Failed / Skipped / Total] 559 / 274 / 20 / 853:  85%|████████▌ | 854/1000 [5:16:16<54:04, 22.22s/it]Adds a reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry [[addConstantMemberReference]] ( final int tag , final String owner , final String name , final String [[descriptor]] ) { int hashCode = hash ( tag , owner , name , [[descriptor]] ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . owner . equals ( owner ) && [[entry]] . name . equals ( name ) && [[entry]] . value . equals ( [[descriptor]] ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , [[descriptor]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , [[descriptor]] , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry [[mat]] ( final int tag , final String owner , final String name , final String [[centrifugal]] ) { int hashCode = hash ( tag , owner , name , [[centrifugal]] ) ; Entry [[neurotransmitter]] = get ( hashCode ) ; while ( [[neurotransmitter]] != null ) { if ( [[neurotransmitter]] . tag == tag && [[neurotransmitter]] . hashCode == hashCode && [[neurotransmitter]] . owner . equals ( owner ) && [[neurotransmitter]] . name . equals ( name ) && [[neurotransmitter]] . value . equals ( [[centrifugal]] ) ) { return [[neurotransmitter]] ; } [[neurotransmitter]] = [[neurotransmitter]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( name , [[centrifugal]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , name , [[centrifugal]] , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 849 ---------------------------------------------
Adds a constant member reference . --> Add insecurities --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int index , final int tag , final String owner , final String [[name]] , final String [[descriptor]] ) { add ( new Entry ( index , tag , owner , [[name]] , [[descriptor]] , 0 , hash ( tag , owner , [[name]] , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[insecurities]] ( final int index , final int tag , final String owner , final String [[housen]] , final String [[inedible]] ) { add ( new Entry ( index , tag , owner , [[housen]] , [[inedible]] , 0 , hash ( tag , owner , [[housen]] , [[inedible]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .


--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant . --> Methode d une polynomial --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int [[tag]] , final int value ) { int hashCode = hash ( [[tag]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( [[tag]] ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[nelle]] ( final int [[moneybag]] , final int value ) { int hashCode = hash ( [[moneybag]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[moneybag]] && entry . hashCode == hashCode && entry . data == value ) { return entry ; } entry = entry . next ; } constantPool . putByte ( [[moneybag]] ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , [[moneybag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant or float or float integer constant . --> Binary entry --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int [[tag]] , final int [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[bauer]] ( final int [[connally]] , final int [[unwillingness]] , final int [[liliane]] ) { add ( new Entry ( [[connally]] , [[unwillingness]] , [[liliane]] , hash ( [[unwillingness]] , [[liliane]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .


--------------------------------------------- Result 852 ---------------------------------------------
Adds a constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int [[tag]] , final long value ) { int [[hashCode]] = hash ( [[tag]] , value ) ; Entry entry = get ( [[hashCode]] ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == [[hashCode]] && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( [[tag]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , [[tag]] , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[flick]] ( final int [[midship]] , final long value ) { int [[eon]] = hash ( [[midship]] , value ) ; Entry entry = get ( [[eon]] ) ; while ( entry != null ) { if ( entry . tag == [[midship]] && entry . hashCode == [[eon]] && entry . data == value ) { return entry ; } entry = entry . next ; } int index = constantPoolCount ; constantPool . putByte ( [[midship]] ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , [[midship]] , value , [[eon]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 853 ---------------------------------------------
Add a constant to the constant pool . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int index , final int tag , final long [[value]] ) { add ( new Entry ( index , tag , [[value]] , hash ( tag , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[counterfeiter]] ( final int index , final int tag , final long [[ballpark]] ) { add ( new Entry ( index , tag , [[ballpark]] , hash ( tag , [[ballpark]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .


--------------------------------------------- Result 854 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 559 / 275 / 20 / 854:  85%|████████▌ | 854/1000 [5:16:16<54:04, 22.22s/it][Succeeded / Failed / Skipped / Total] 559 / 275 / 20 / 854:  86%|████████▌ | 855/1000 [5:16:46<53:43, 22.23s/it][Succeeded / Failed / Skipped / Total] 559 / 276 / 20 / 855:  86%|████████▌ | 855/1000 [5:16:46<53:43, 22.23s/it][Succeeded / Failed / Skipped / Total] 559 / 276 / 20 / 855:  86%|████████▌ | 856/1000 [5:17:18<53:22, 22.24s/it][Succeeded / Failed / Skipped / Total] 559 / 277 / 20 / 856:  86%|████████▌ | 856/1000 [5:17:18<53:22, 22.24s/it][Succeeded / Failed / Skipped / Total] 559 / 277 / 20 / 856:  86%|████████▌ | 857/1000 [5:17:35<52:59, 22.24s/it][Succeeded / Failed / Skipped / Total] 560 / 277 / 20 / 857:  86%|████████▌ | 857/1000 [5:17:35<52:59, 22.24s/it][Succeeded / Failed / Skipped / Total] 560 / 277 / 20 / 857:  86%|████████▌ | 858/1000 [5:18:40<52:44, 22.28s/it][Succeeded / Failed / Skipped / Total] 560 / 278 / 20 / 858:  86%|████████▌ | 858/1000 [5:18:40<52:44, 22.28s/it][Succeeded / Failed / Skipped / Total] 560 / 278 / 20 / 858:  86%|████████▌ | 859/1000 [5:19:14<52:24, 22.30s/it][Succeeded / Failed / Skipped / Total] 561 / 278 / 20 / 859:  86%|████████▌ | 859/1000 [5:19:14<52:24, 22.30s/it][Succeeded / Failed / Skipped / Total] 561 / 278 / 20 / 859:  86%|████████▌ | 860/1000 [5:20:06<52:06, 22.33s/it]Adds a constant name and type . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[flashy]] ( final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , descriptor ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry . index ; } entry = entry . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , descriptor , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 855 ---------------------------------------------
Add a constant name and type . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int index , final String [[name]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , [[name]] , descriptor , hash ( tag , [[name]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[crashed]] ( final int index , final String [[forfeiture]] , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , [[forfeiture]] , descriptor , hash ( tag , [[forfeiture]] , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .


--------------------------------------------- Result 856 ---------------------------------------------
Adds a constant . --> [[[FAILED]]]

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int addConstantUtf8 ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 857 ---------------------------------------------
Adds a constant . --> Add gab entry for gab --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String value ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[gab]] ( final int [[johnson]] , final String value ) { add ( new Entry ( [[johnson]] , Symbol . CONSTANT_UTF8_TAG , value , hash ( Symbol . CONSTANT_UTF8_TAG , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .


--------------------------------------------- Result 858 ---------------------------------------------
Adds a constant method handle . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int [[referenceKind]] , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[bungling]] ( final int [[flynn]] , final String owner , final String name , final String descriptor , final boolean isInterface ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 859 ---------------------------------------------
Add a constant method handle . --> Add rosi --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int [[referenceKind]] , final String [[owner]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , [[owner]] , name , descriptor , [[referenceKind]] ) ; add ( new Entry ( index , tag , [[owner]] , name , descriptor , [[referenceKind]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[rosi]] ( final int index , final int [[mexico]] , final String [[kabbalah]] , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( tag , [[kabbalah]] , name , descriptor , [[mexico]] ) ; add ( new Entry ( index , tag , [[kabbalah]] , name , descriptor , [[mexico]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .


--------------------------------------------- Result 860 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 561 / 279 / 20 / 860:  86%|████████▌ | 860/1000 [5:20:06<52:06, 22.33s/it][Succeeded / Failed / Skipped / Total] 561 / 279 / 20 / 860:  86%|████████▌ | 861/1000 [5:20:59<51:49, 22.37s/it][Succeeded / Failed / Skipped / Total] 561 / 280 / 20 / 861:  86%|████████▌ | 861/1000 [5:20:59<51:49, 22.37s/it][Succeeded / Failed / Skipped / Total] 561 / 280 / 20 / 861:  86%|████████▌ | 862/1000 [5:22:11<51:34, 22.43s/it][Succeeded / Failed / Skipped / Total] 561 / 281 / 20 / 862:  86%|████████▌ | 862/1000 [5:22:11<51:34, 22.43s/it][Succeeded / Failed / Skipped / Total] 561 / 281 / 20 / 862:  86%|████████▋ | 863/1000 [5:23:07<51:17, 22.47s/it][Succeeded / Failed / Skipped / Total] 562 / 281 / 20 / 863:  86%|████████▋ | 863/1000 [5:23:07<51:17, 22.47s/it][Succeeded / Failed / Skipped / Total] 562 / 281 / 20 / 863:  86%|████████▋ | 864/1000 [5:23:50<50:58, 22.49s/it][Succeeded / Failed / Skipped / Total] 562 / 282 / 20 / 864:  86%|████████▋ | 864/1000 [5:23:50<50:58, 22.49s/it][Succeeded / Failed / Skipped / Total] 562 / 282 / 20 / 864:  86%|████████▋ | 865/1000 [5:24:19<50:37, 22.50s/it]Adds a constant declaration to the bootstrap method descriptor . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantDynamic]] ( final String name , final String [[descriptor]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[descriptor]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[weld]] ( final String name , final String [[tai]] , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , [[tai]] , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 861 ---------------------------------------------
Adds a constant - invoke dynamic method invocation . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String [[name]] , final String descriptor , final Handle [[bootstrapMethodHandle]] , final Object ... bootstrapMethodArguments ) { Symbol [[bootstrapMethod]] = addBootstrapMethod ( [[bootstrapMethodHandle]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , descriptor , [[bootstrapMethod]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[effects]] ( final String [[frosty]] , final String descriptor , final Handle [[starters]] , final Object ... bootstrapMethodArguments ) { Symbol [[cardiologist]] = addBootstrapMethod ( [[starters]] , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[frosty]] , descriptor , [[cardiologist]] . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 862 ---------------------------------------------
Adds a constant or dynamic reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final String name , final String descriptor , final int [[bootstrapMethodIndex]] ) { int hashCode = hash ( tag , name , descriptor , [[bootstrapMethodIndex]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[bootstrapMethodIndex]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , [[bootstrapMethodIndex]] , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , [[bootstrapMethodIndex]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[reenter]] ( final int tag , final String name , final String descriptor , final int [[thyme]] ) { int hashCode = hash ( tag , name , descriptor , [[thyme]] ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == [[thyme]] && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , [[thyme]] , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , [[thyme]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 863 ---------------------------------------------
Add a constant or dynamic reference to the constant pool . --> Add vickers entry --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantDynamicOrInvokeDynamicReference]] ( final int tag , final int index , final String name , final String descriptor , final int [[bootstrapMethodIndex]] ) { int hashCode = hash ( tag , name , descriptor , [[bootstrapMethodIndex]] ) ; add ( new Entry ( index , tag , null , name , descriptor , [[bootstrapMethodIndex]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[vickers]] ( final int tag , final int index , final String name , final String descriptor , final int [[calmly]] ) { int hashCode = hash ( tag , name , descriptor , [[calmly]] ) ; add ( new Entry ( index , tag , null , name , descriptor , [[calmly]] , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .


--------------------------------------------- Result 864 ---------------------------------------------
Adds a constant . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[declare]] ( final int tag , final String value ) { int hashCode = hash ( tag , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( tag , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .


--------------------------------------------- Result 865 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 562 / 283 / 20 / 865:  86%|████████▋ | 865/1000 [5:24:19<50:37, 22.50s/it][Succeeded / Failed / Skipped / Total] 562 / 283 / 20 / 865:  87%|████████▋ | 866/1000 [5:24:52<50:16, 22.51s/it][Succeeded / Failed / Skipped / Total] 562 / 284 / 20 / 866:  87%|████████▋ | 866/1000 [5:24:52<50:16, 22.51s/it][Succeeded / Failed / Skipped / Total] 562 / 284 / 20 / 866:  87%|████████▋ | 867/1000 [5:25:06<49:52, 22.50s/it][Succeeded / Failed / Skipped / Total] 563 / 284 / 20 / 867:  87%|████████▋ | 867/1000 [5:25:06<49:52, 22.50s/it][Succeeded / Failed / Skipped / Total] 563 / 284 / 20 / 867:  87%|████████▋ | 868/1000 [5:25:27<49:29, 22.50s/it][Succeeded / Failed / Skipped / Total] 564 / 284 / 20 / 868:  87%|████████▋ | 868/1000 [5:25:27<49:29, 22.50s/it][Succeeded / Failed / Skipped / Total] 564 / 284 / 20 / 868:  87%|████████▋ | 869/1000 [5:25:33<49:04, 22.48s/it][Succeeded / Failed / Skipped / Total] 565 / 284 / 20 / 869:  87%|████████▋ | 869/1000 [5:25:33<49:04, 22.48s/it][Succeeded / Failed / Skipped / Total] 565 / 284 / 20 / 869:  87%|████████▋ | 870/1000 [5:26:39<48:48, 22.53s/it][Succeeded / Failed / Skipped / Total] 565 / 285 / 20 / 870:  87%|████████▋ | 870/1000 [5:26:39<48:48, 22.53s/it][Succeeded / Failed / Skipped / Total] 565 / 285 / 20 / 870:  87%|████████▋ | 871/1000 [5:26:59<48:25, 22.53s/it][Succeeded / Failed / Skipped / Total] 566 / 285 / 20 / 871:  87%|████████▋ | 871/1000 [5:26:59<48:25, 22.53s/it][Succeeded / Failed / Skipped / Total] 566 / 285 / 20 / 871:  87%|████████▋ | 872/1000 [5:27:23<48:03, 22.53s/it][Succeeded / Failed / Skipped / Total] 566 / 286 / 20 / 872:  87%|████████▋ | 872/1000 [5:27:23<48:03, 22.53s/it][Succeeded / Failed / Skipped / Total] 566 / 286 / 20 / 872:  87%|████████▋ | 873/1000 [5:27:57<47:42, 22.54s/it]Add a reference to the constant table . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int [[index]] , final int tag , final String value ) { add ( new Entry ( [[index]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[scrubbing]] ( final int [[juventus]] , final int tag , final String value ) { add ( new Entry ( [[juventus]] , tag , value , hash ( tag , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .


--------------------------------------------- Result 866 ---------------------------------------------
Adds a bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle bootstrapMethodHandle , final Object ... [[bootstrapMethodArguments]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[veuve]] ( final Handle bootstrapMethodHandle , final Object ... [[skilfully]] ) { ByteVector bootstrapMethodsAttribute = bootstrapMethods ; if ( bootstrapMethodsAttribute == null ) { bootstrapMethodsAttribute = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .


--------------------------------------------- Result 867 ---------------------------------------------
Add merged type . --> Low level abstraction --> Socre: 1.0

[[[[Adv]]]]: int [[addMergedType]] ( final int typeTableIndex1 , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int [[boredom]] ( final int typeTableIndex1 , final int [[bruton]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .


--------------------------------------------- Result 868 ---------------------------------------------
Returns the hash of the given name --> returns a 32 - bit integer --> Socre: 1.0

[[[[Adv]]]]: private int hash ( final String name ) { int [[h]] = 0 ; for ( int [[i]] = name . length ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { char [[c]] = name . charAt ( [[i]] ) ; if ( ! caseSensitive ) { if ( [[c]] >= ' ' && [[c]] <= ' ' ) { [[c]] += 32 ; } } [[h]] = 31 * [[h]] + [[c]] ; } if ( [[h]] > 0 ) { return [[h]] ; } if ( [[h]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[h]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int hash ( final String name ) { int [[flaunts]] = 0 ; for ( int [[errol]] = name . length ( ) - 1 ; [[errol]] >= 0 ; [[errol]] -- ) { char [[kuki]] = name . charAt ( [[errol]] ) ; if ( ! caseSensitive ) { if ( [[kuki]] >= ' ' && [[kuki]] <= ' ' ) { [[kuki]] += 32 ; } } [[flaunts]] = 31 * [[flaunts]] + [[kuki]] ; } if ( [[flaunts]] > 0 ) { return [[flaunts]] ; } if ( [[flaunts]] == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - [[flaunts]] ; }
[[[[Nl]]]]: Calculates hash value of the input string .


--------------------------------------------- Result 869 ---------------------------------------------
Clear the internal map --> Clear all entries --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[absentee]] = 0 ; [[absentee]] < entries . length ; [[absentee]] ++ ) { entries [ [[absentee]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .


--------------------------------------------- Result 870 ---------------------------------------------
Returns all values with the specified name . --> [[[FAILED]]]

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > [[values]] = new LinkedList <> ( ) ; int h = hash ( [[name]] ) ; int i = index ( h ) ; MapEntry < V > [[e]] = entries [ i ] ; while ( [[e]] != null ) { if ( [[e]] . hash == h && eq ( [[name]] , [[e]] . key ) ) { [[values]] . addFirst ( [[e]] . getValue ( ) ) ; } [[e]] = [[e]] . next ; } return [[values]] ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[huei]] ( final String [[outlying]] ) { LinkedList < V > [[woohoo]] = new LinkedList <> ( ) ; int h = hash ( [[outlying]] ) ; int i = index ( h ) ; MapEntry < V > [[messiahs]] = entries [ i ] ; while ( [[messiahs]] != null ) { if ( [[messiahs]] . hash == h && eq ( [[outlying]] , [[messiahs]] . key ) ) { [[woohoo]] . addFirst ( [[messiahs]] . getValue ( ) ) ; } [[messiahs]] = [[messiahs]] . next ; } return [[woohoo]] ; }
[[[[Nl]]]]: Returns all values associated with the name .


--------------------------------------------- Result 871 ---------------------------------------------
Implementation of iterator . --> This method is used for debugging purposes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[next]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[next]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[next]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[grainy]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > [[correctional]] ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > [[correctional]] = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return [[correctional]] ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .


--------------------------------------------- Result 872 ---------------------------------------------
Returns all the entries in the list . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[pagans]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .


--------------------------------------------- Result 873 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 567 / 286 / 20 / 873:  87%|████████▋ | 873/1000 [5:27:57<47:42, 22.54s/it][Succeeded / Failed / Skipped / Total] 567 / 286 / 20 / 873:  87%|████████▋ | 874/1000 [5:28:41<47:23, 22.56s/it][Succeeded / Failed / Skipped / Total] 567 / 287 / 20 / 874:  87%|████████▋ | 874/1000 [5:28:41<47:23, 22.56s/it][Succeeded / Failed / Skipped / Total] 567 / 287 / 20 / 874:  88%|████████▊ | 875/1000 [5:28:48<46:58, 22.55s/it][Succeeded / Failed / Skipped / Total] 568 / 287 / 20 / 875:  88%|████████▊ | 875/1000 [5:28:48<46:58, 22.55s/it][Succeeded / Failed / Skipped / Total] 568 / 287 / 20 / 875:  88%|████████▊ | 876/1000 [5:29:04<46:34, 22.54s/it][Succeeded / Failed / Skipped / Total] 568 / 288 / 20 / 876:  88%|████████▊ | 876/1000 [5:29:04<46:34, 22.54s/it][Succeeded / Failed / Skipped / Total] 568 / 288 / 20 / 876:  88%|████████▊ | 877/1000 [5:29:12<46:10, 22.52s/it][Succeeded / Failed / Skipped / Total] 569 / 288 / 20 / 877:  88%|████████▊ | 877/1000 [5:29:12<46:10, 22.52s/it][Succeeded / Failed / Skipped / Total] 569 / 288 / 20 / 877:  88%|████████▊ | 878/1000 [5:29:31<45:47, 22.52s/it][Succeeded / Failed / Skipped / Total] 570 / 288 / 20 / 878:  88%|████████▊ | 878/1000 [5:29:31<45:47, 22.52s/it][Succeeded / Failed / Skipped / Total] 570 / 288 / 20 / 878:  88%|████████▊ | 879/1000 [5:29:45<45:23, 22.51s/it][Succeeded / Failed / Skipped / Total] 571 / 288 / 20 / 879:  88%|████████▊ | 879/1000 [5:29:45<45:23, 22.51s/it][Succeeded / Failed / Skipped / Total] 571 / 288 / 20 / 879:  88%|████████▊ | 880/1000 [5:29:51<44:58, 22.49s/it][Succeeded / Failed / Skipped / Total] 572 / 288 / 20 / 880:  88%|████████▊ | 880/1000 [5:29:51<44:58, 22.49s/it][Succeeded / Failed / Skipped / Total] 572 / 288 / 20 / 880:  88%|████████▊ | 881/1000 [5:30:18<44:36, 22.50s/it][Succeeded / Failed / Skipped / Total] 573 / 288 / 20 / 881:  88%|████████▊ | 881/1000 [5:30:18<44:36, 22.50s/it][Succeeded / Failed / Skipped / Total] 573 / 288 / 20 / 881:  88%|████████▊ | 882/1000 [5:30:18<44:11, 22.47s/it]Increases the buffer if necessary . --> Collectibleibles from epipolar block --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int [[minCapacity]] ) { final int [[oldCapacity]] = buffer . length ; int [[newCapacity]] = [[oldCapacity]] << 1 ; if ( [[newCapacity]] - [[minCapacity]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[collectibles]] ( final int [[episcopal]] ) { final int [[slithering]] = buffer . length ; int [[preble]] = [[slithering]] << 1 ; if ( [[preble]] - [[episcopal]] < 0 ) {
[[[[Nl]]]]: Grows the buffer .


--------------------------------------------- Result 874 ---------------------------------------------
Appends a character sequence to the buffer . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence [[csq]] , final int [[start]] , final int [[end]] ) { for ( int i = [[start]] ; i < [[end]] ; i ++ ) { append ( [[csq]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence [[hydrangeas]] , final int [[pari]] , final int [[clipboard]] ) { for ( int i = [[pari]] ; i < [[clipboard]] ; i ++ ) { append ( [[hydrangeas]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .


--------------------------------------------- Result 875 ---------------------------------------------
Visits an annotation . --> visit an annotation --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String [[desc]] , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[desc]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String [[hut]] , final boolean visible ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( [[hut]] , visible ) ;
[[[[Nl]]]]: Copies target method annotations .


--------------------------------------------- Result 876 ---------------------------------------------
Create the proxy methods . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[cummins]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[jewry]] = 0 ; [[jewry]] < tmd . proxyData . length ; [[jewry]] ++ ) { tmd . selectCurrentProxy ( [[jewry]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .


--------------------------------------------- Result 877 ---------------------------------------------
Create first chain delegate delegate . --> Perform ninjunction --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[ninjutsu]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .


--------------------------------------------- Result 878 ---------------------------------------------
Create the first chain deque for the first chain . --> generate tie breaker --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Continue]] ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , False ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , False ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , False ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void [[tiebreaker]] ( final TargetMethodData [[ideological]] ) { methodVisitor . visitCode ( ) ; if ( [[ideological]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[ideological]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[ideological]] . firstMethodName ( ) , [[ideological]] . msign . getDescription ( ) , False ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[ideological]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[ideological]] . firstMethodName ( ) , [[ideological]] . msign . getDescription ( ) , False ) ; } visitReturn ( methodVisitor , [[ideological]] . msign , False ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .


--------------------------------------------- Result 879 ---------------------------------------------
Parse a path . --> merge rachid --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[rearrange]] ( final String [[rachid]] ) { return [[rachid]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[rachid]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .


--------------------------------------------- Result 880 ---------------------------------------------
Adds a field to the path . --> Add a field --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[geriatric]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .


--------------------------------------------- Result 881 ---------------------------------------------
Configure the servlet context . --> Add chatty filter --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , True , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , True , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[chatty]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , True , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , True , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .


--------------------------------------------- Result 882 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 573 / 288 / 21 / 882:  88%|████████▊ | 882/1000 [5:30:18<44:11, 22.47s/it][Succeeded / Failed / Skipped / Total] 573 / 288 / 21 / 882:  88%|████████▊ | 883/1000 [5:30:39<43:48, 22.47s/it][Succeeded / Failed / Skipped / Total] 574 / 288 / 21 / 883:  88%|████████▊ | 883/1000 [5:30:39<43:48, 22.47s/it][Succeeded / Failed / Skipped / Total] 574 / 288 / 21 / 883:  88%|████████▊ | 884/1000 [5:30:48<43:24, 22.45s/it][Succeeded / Failed / Skipped / Total] 575 / 288 / 21 / 884:  88%|████████▊ | 884/1000 [5:30:48<43:24, 22.45s/it][Succeeded / Failed / Skipped / Total] 575 / 288 / 21 / 884:  88%|████████▊ | 885/1000 [5:31:12<43:02, 22.46s/it][Succeeded / Failed / Skipped / Total] 576 / 288 / 21 / 885:  88%|████████▊ | 885/1000 [5:31:12<43:02, 22.46s/it][Succeeded / Failed / Skipped / Total] 576 / 288 / 21 / 885:  89%|████████▊ | 886/1000 [5:31:37<42:40, 22.46s/it][Succeeded / Failed / Skipped / Total] 577 / 288 / 21 / 886:  89%|████████▊ | 886/1000 [5:31:37<42:40, 22.46s/it][Succeeded / Failed / Skipped / Total] 577 / 288 / 21 / 886:  89%|████████▊ | 887/1000 [5:32:15<42:19, 22.48s/it][Succeeded / Failed / Skipped / Total] 577 / 289 / 21 / 887:  89%|████████▊ | 887/1000 [5:32:15<42:19, 22.48s/it][Succeeded / Failed / Skipped / Total] 577 / 289 / 21 / 887:  89%|████████▉ | 888/1000 [5:32:23<41:55, 22.46s/it][Succeeded / Failed / Skipped / Total] 578 / 289 / 21 / 888:  89%|████████▉ | 888/1000 [5:32:23<41:55, 22.46s/it][Succeeded / Failed / Skipped / Total] 578 / 289 / 21 / 888:  89%|████████▉ | 889/1000 [5:32:56<41:34, 22.47s/it]Execute the target --> [[[SKIPPED]]]

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;


--------------------------------------------- Result 883 ---------------------------------------------
Returns an array of FieldDescriptors for this class . --> Schlitz factory methods --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor [[fieldDescriptor]] : fieldsMap . values ( ) ) { allFields [ index ] = [[fieldDescriptor]] ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[schlitz]] ( ) { if ( allFields == null ) { FieldDescriptor [ ] allFields = new FieldDescriptor [ fieldsMap . size ( ) ] ; int index = 0 ; for ( FieldDescriptor [[mccarthy]] : fieldsMap . values ( ) ) { allFields [ index ] = [[mccarthy]] ; index ++ ; } Arrays . sort ( allFields , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = allFields ; } return allFields ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .


--------------------------------------------- Result 884 ---------------------------------------------
Obtain the bean definition for the proxy . --> Overridden to create a BeanDefinition for a proxy --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode [[wiringMode]] , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , [[wiringMode]] , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , [[wiringMode]] , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode [[profession]] , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class originalType = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , [[profession]] , originalType , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , [[profession]] , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .


--------------------------------------------- Result 885 ---------------------------------------------
Convert JDBCTransactionMode to DBTransactionMode . --> Returns blanchard --> Socre: 1.0

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode [[txMode]] ) { final int [[isolation]] ; switch ( [[txMode]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , [[txMode]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[blanchard]] ( final JtxTransactionMode [[discretionary]] ) { final int [[bien]] ; switch ( [[discretionary]] . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[bien]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[bien]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[bien]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[bien]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[bien]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[bien]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[bien]] , [[discretionary]] . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .


--------------------------------------------- Result 886 ---------------------------------------------
Reads property . --> Call the getter method --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object [[source]] , final PropertyDescriptor propertyDescriptor ) { Getter [[getter]] = propertyDescriptor . getGetter ( declared ) ; if ( [[getter]] != null ) { try { return [[getter]] . invokeGetter ( [[source]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[loli]] ( final Object [[abilities]] , final PropertyDescriptor propertyDescriptor ) { Getter [[glued]] = propertyDescriptor . getGetter ( declared ) ; if ( [[glued]] != null ) { try { return [[glued]] . invokeGetter ( [[abilities]] ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .


--------------------------------------------- Result 887 ---------------------------------------------
Copies all entries from the specified map . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map [[t]] ) { for ( Object [[o]] : [[t]] . entrySet ( ) ) { Map . Entry [[e]] = ( Map . Entry ) [[o]] ; put ( [[e]] . getKey ( ) , [[e]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[rolodex]] ( final Map [[bila]] ) { for ( Object [[beau]] : [[bila]] . entrySet ( ) ) { Map . Entry [[hearties]] = ( Map . Entry ) [[beau]] ; put ( [[hearties]] . getKey ( ) , [[hearties]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .


--------------------------------------------- Result 888 ---------------------------------------------
Append a buffer to the end of the list . --> Append a movie --> Socre: 1.0

[[[[Adv]]]]: public Buffer append ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer append ( final Buffer [[industries]] ) { if ( [[industries]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .


[Succeeded / Failed / Skipped / Total] 579 / 289 / 21 / 889:  89%|████████▉ | 889/1000 [5:32:56<41:34, 22.47s/it][Succeeded / Failed / Skipped / Total] 579 / 289 / 21 / 889:  89%|████████▉ | 890/1000 [5:33:43<41:14, 22.50s/it][Succeeded / Failed / Skipped / Total] 579 / 290 / 21 / 890:  89%|████████▉ | 890/1000 [5:33:43<41:14, 22.50s/it][Succeeded / Failed / Skipped / Total] 579 / 290 / 21 / 890:  89%|████████▉ | 891/1000 [5:33:50<40:50, 22.48s/it][Succeeded / Failed / Skipped / Total] 580 / 290 / 21 / 891:  89%|████████▉ | 891/1000 [5:33:50<40:50, 22.48s/it][Succeeded / Failed / Skipped / Total] 580 / 290 / 21 / 891:  89%|████████▉ | 892/1000 [5:34:07<40:27, 22.47s/it][Succeeded / Failed / Skipped / Total] 581 / 290 / 21 / 892:  89%|████████▉ | 892/1000 [5:34:07<40:27, 22.47s/it][Succeeded / Failed / Skipped / Total] 581 / 290 / 21 / 892:  89%|████████▉ | 893/1000 [5:34:31<40:04, 22.48s/it][Succeeded / Failed / Skipped / Total] 582 / 290 / 21 / 893:  89%|████████▉ | 893/1000 [5:34:31<40:04, 22.48s/it][Succeeded / Failed / Skipped / Total] 582 / 290 / 21 / 893:  89%|████████▉ | 894/1000 [5:34:38<39:40, 22.46s/it][Succeeded / Failed / Skipped / Total] 583 / 290 / 21 / 894:  89%|████████▉ | 894/1000 [5:34:38<39:40, 22.46s/it][Succeeded / Failed / Skipped / Total] 583 / 290 / 21 / 894:  90%|████████▉ | 895/1000 [5:35:01<39:18, 22.46s/it][Succeeded / Failed / Skipped / Total] 584 / 290 / 21 / 895:  90%|████████▉ | 895/1000 [5:35:01<39:18, 22.46s/it][Succeeded / Failed / Skipped / Total] 584 / 290 / 21 / 895:  90%|████████▉ | 896/1000 [5:35:08<38:53, 22.44s/it][Succeeded / Failed / Skipped / Total] 585 / 290 / 21 / 896:  90%|████████▉ | 896/1000 [5:35:08<38:53, 22.44s/it][Succeeded / Failed / Skipped / Total] 585 / 290 / 21 / 896:  90%|████████▉ | 897/1000 [5:35:21<38:30, 22.43s/it]--------------------------------------------- Result 889 ---------------------------------------------
Write the stream to a writer . --> Copied from javadoc --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final Writer writer ) throws IOException { for ( Object [[o]] : list ) { if ( [[o]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[o]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[o]] instanceof Uploadable ) { Uploadable [[uploadable]] = ( Uploadable ) [[o]] ; InputStream inputStream = [[uploadable]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void [[curator]] ( final Writer writer ) throws IOException { for ( Object [[disruptions]] : list ) { if ( [[disruptions]] instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) [[disruptions]] ; byte [ ] array = fastByteBuffer . toArray ( ) ; writer . write ( new String ( array , StringPool . ISO_8859_1 ) ) ; } else if ( [[disruptions]] instanceof Uploadable ) { Uploadable [[shuck]] = ( Uploadable ) [[disruptions]] ; InputStream inputStream = [[shuck]] . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , writer , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .


--------------------------------------------- Result 890 ---------------------------------------------
Write the list of objects to the output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[out]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void writeTo ( final OutputStream [[excepting]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[excepting]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[excepting]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .


--------------------------------------------- Result 891 ---------------------------------------------
Write the progress to the output stream . --> Overrides default implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[airplanes]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .


--------------------------------------------- Result 892 ---------------------------------------------
Returns a string value . --> antiates cheapo sugar --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String [[key]] ) { CharSequence cs = ( CharSequence ) map . get ( [[key]] ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[cheapo]] ( final String [[cultivate]] ) { CharSequence cs = ( CharSequence ) map . get ( [[cultivate]] ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .


--------------------------------------------- Result 893 ---------------------------------------------
Returns the integer value . --> Convenience method to get a picture --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Integer ) { return ( Integer ) [[number]] ; } return [[number]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[illustration]] ( final String [[etcetera]] ) { Number [[composer]] = ( Number ) map . get ( [[etcetera]] ) ; if ( [[composer]] == null ) { return null ; } if ( [[composer]] instanceof Integer ) { return ( Integer ) [[composer]] ; } return [[composer]] . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .


--------------------------------------------- Result 894 ---------------------------------------------
Get a long value . --> Get a number --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[qi]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .


--------------------------------------------- Result 895 ---------------------------------------------
Get a double value . --> method to return menelausen --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String [[key]] ) { Number number = ( Number ) map . get ( [[key]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[menelaus]] ( final String [[federal]] ) { Number number = ( Number ) map . get ( [[federal]] ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .


--------------------------------------------- Result 896 ---------------------------------------------
Get a float value . --> Get a number --> Socre: 1.0

[[[[Adv]]]]: public Float [[getFloat]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float [[moseying]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Float ) { return ( Float ) number ; } return number . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .


--------------------------------------------- Result 897 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 586 / 290 / 21 / 897:  90%|████████▉ | 897/1000 [5:35:21<38:30, 22.43s/it][Succeeded / Failed / Skipped / Total] 586 / 290 / 21 / 897:  90%|████████▉ | 898/1000 [5:35:45<38:08, 22.43s/it][Succeeded / Failed / Skipped / Total] 587 / 290 / 21 / 898:  90%|████████▉ | 898/1000 [5:35:45<38:08, 22.43s/it][Succeeded / Failed / Skipped / Total] 587 / 290 / 21 / 898:  90%|████████▉ | 899/1000 [5:36:14<37:46, 22.44s/it][Succeeded / Failed / Skipped / Total] 587 / 291 / 21 / 899:  90%|████████▉ | 899/1000 [5:36:14<37:46, 22.44s/it][Succeeded / Failed / Skipped / Total] 587 / 291 / 21 / 899:  90%|█████████ | 900/1000 [5:37:00<37:26, 22.47s/it][Succeeded / Failed / Skipped / Total] 588 / 291 / 21 / 900:  90%|█████████ | 900/1000 [5:37:00<37:26, 22.47s/it][Succeeded / Failed / Skipped / Total] 588 / 291 / 21 / 900:  90%|█████████ | 901/1000 [5:37:08<37:02, 22.45s/it][Succeeded / Failed / Skipped / Total] 589 / 291 / 21 / 901:  90%|█████████ | 901/1000 [5:37:08<37:02, 22.45s/it][Succeeded / Failed / Skipped / Total] 589 / 291 / 21 / 901:  90%|█████████ | 902/1000 [5:37:21<36:39, 22.44s/it][Succeeded / Failed / Skipped / Total] 590 / 291 / 21 / 902:  90%|█████████ | 902/1000 [5:37:21<36:39, 22.44s/it][Succeeded / Failed / Skipped / Total] 590 / 291 / 21 / 902:  90%|█████████ | 903/1000 [5:37:46<36:16, 22.44s/it][Succeeded / Failed / Skipped / Total] 590 / 292 / 21 / 903:  90%|█████████ | 903/1000 [5:37:46<36:16, 22.44s/it][Succeeded / Failed / Skipped / Total] 590 / 292 / 21 / 903:  90%|█████████ | 904/1000 [5:38:01<35:53, 22.44s/it][Succeeded / Failed / Skipped / Total] 591 / 292 / 21 / 904:  90%|█████████ | 904/1000 [5:38:01<35:53, 22.44s/it][Succeeded / Failed / Skipped / Total] 591 / 292 / 21 / 904:  90%|█████████ | 905/1000 [5:38:08<35:29, 22.42s/it]Returns the value associated with the given key . --> get stockbroker --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] getValue ( final String key ) { [[T]] [[val]] = ( [[T]] ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( [[T]] ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( [[T]] ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[stockbroker]] > [[stockbroker]] getValue ( final String key ) { [[stockbroker]] [[terrors]] = ( [[stockbroker]] ) map . get ( key ) ; if ( [[terrors]] instanceof Map ) { return ( [[stockbroker]] ) new JsonObject ( ( Map ) [[terrors]] ) ; } if ( [[terrors]] instanceof List ) { return ( [[stockbroker]] ) new JsonArray ( ( List ) [[terrors]] ) ; } return [[terrors]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .


--------------------------------------------- Result 898 ---------------------------------------------
Add a value to the JsonObject . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String [[key]] , final String [[value]] ) { Objects . requireNonNull ( [[key]] ) ; map . put ( [[key]] , [[value]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[capacitor]] ( final String [[breakups]] , final String [[insufferable]] ) { Objects . requireNonNull ( [[breakups]] ) ; map . put ( [[breakups]] , [[insufferable]] ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .


--------------------------------------------- Result 899 ---------------------------------------------
Use this method to open a folder --> [[[FAILED]]]

[[[[Adv]]]]: public void useFolder ( final String [[folderName]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[folderName]] ; this . [[folder]] = getService ( ) . getFolder ( [[folderName]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[folderName]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void useFolder ( final String [[announced]] ) { closeFolderIfOpened ( folder ) ; try { this . folderName = [[announced]] ; this . [[cartwright]] = getService ( ) . getFolder ( [[announced]] ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + [[announced]] , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .


--------------------------------------------- Result 900 ---------------------------------------------
Receive messages from Folder . --> Perform validation on a folder --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] [[receiveMessages]] ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags [[flagsToUnset]] , final boolean [[envelope]] , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( [[envelope]] ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] [[sarai]] ( final EmailFilter [[folder]] , final Flags flagsToSet , final Flags [[puerile]] , final boolean [[tittering]] , final Consumer < Message [ ] > processedMessageConsumer ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[folder]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[folder]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( [[tittering]] ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .


--------------------------------------------- Result 901 ---------------------------------------------
Updates the flags of the mailbox . --> Start a new room --> Socre: 1.0

[[[[Adv]]]]: public void [[updateEmailFlags]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , True ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void [[rooming]] ( final ReceivedEmail receivedEmail ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { receivedEmail . messageNumber ( ) } , receivedEmail . flags ( ) , True ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .


--------------------------------------------- Result 902 ---------------------------------------------
Close the opened folder if it exists . --> Close the tango --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder [[folder]] ) { if ( [[folder]] != null ) { try { [[folder]] . close ( True ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[embroidered]] ( final Folder [[angola]] ) { if ( [[angola]] != null ) { try { [[angola]] . close ( True ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .


--------------------------------------------- Result 903 ---------------------------------------------
Look up a named parameter . --> [[[FAILED]]]

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[name]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[bindi]] ( final String [[apprenticeship]] ) { DbQueryNamedParameter p = rootNP ; while ( p != null ) { if ( p . equalsName ( [[apprenticeship]] ) ) { return p ; } p = p . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .


--------------------------------------------- Result 904 ---------------------------------------------
Creates alias . --> Builds AMO --> Socre: 1.0

[[[[Adv]]]]: protected String [[alias]] ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String [[amah]] ( final String [[nls]] ) { return StringPool . LEFT_CHEV . concat ( [[nls]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .


--------------------------------------------- Result 905 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 592 / 292 / 21 / 905:  90%|█████████ | 905/1000 [5:38:08<35:29, 22.42s/it][Succeeded / Failed / Skipped / Total] 592 / 292 / 21 / 905:  91%|█████████ | 906/1000 [5:38:24<35:06, 22.41s/it][Succeeded / Failed / Skipped / Total] 592 / 293 / 21 / 906:  91%|█████████ | 906/1000 [5:38:24<35:06, 22.41s/it][Succeeded / Failed / Skipped / Total] 592 / 293 / 21 / 906:  91%|█████████ | 907/1000 [5:38:31<34:42, 22.39s/it][Succeeded / Failed / Skipped / Total] 593 / 293 / 21 / 907:  91%|█████████ | 907/1000 [5:38:31<34:42, 22.39s/it][Succeeded / Failed / Skipped / Total] 593 / 293 / 21 / 907:  91%|█████████ | 908/1000 [5:38:44<34:19, 22.38s/it][Succeeded / Failed / Skipped / Total] 594 / 293 / 21 / 908:  91%|█████████ | 908/1000 [5:38:44<34:19, 22.38s/it][Succeeded / Failed / Skipped / Total] 594 / 293 / 21 / 908:  91%|█████████ | 909/1000 [5:38:57<33:55, 22.37s/it][Succeeded / Failed / Skipped / Total] 594 / 294 / 21 / 909:  91%|█████████ | 909/1000 [5:38:57<33:55, 22.37s/it][Succeeded / Failed / Skipped / Total] 594 / 294 / 21 / 909:  91%|█████████ | 910/1000 [5:39:10<33:32, 22.36s/it][Succeeded / Failed / Skipped / Total] 594 / 295 / 21 / 910:  91%|█████████ | 910/1000 [5:39:10<33:32, 22.36s/it][Succeeded / Failed / Skipped / Total] 594 / 295 / 21 / 910:  91%|█████████ | 911/1000 [5:39:25<33:09, 22.35s/it][Succeeded / Failed / Skipped / Total] 595 / 295 / 21 / 911:  91%|█████████ | 911/1000 [5:39:25<33:09, 22.35s/it][Succeeded / Failed / Skipped / Total] 595 / 295 / 21 / 911:  91%|█████████ | 912/1000 [5:39:33<32:45, 22.34s/it][Succeeded / Failed / Skipped / Total] 595 / 296 / 21 / 912:  91%|█████████ | 912/1000 [5:39:33<32:45, 22.34s/it][Succeeded / Failed / Skipped / Total] 595 / 296 / 21 / 912:  91%|█████████▏| 913/1000 [5:39:47<32:22, 22.33s/it]Perform validation . --> Performs clipping clipping --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[clipping]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .


--------------------------------------------- Result 906 ---------------------------------------------
Add a violation . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[addViolation]] ( final String [[name]] , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[name]] , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[ventilator]] ( final String [[beluga]] , final Object [[basher]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( [[beluga]] , this , [[basher]] ) ) ; }
[[[[Nl]]]]: Adds action violation .


--------------------------------------------- Result 907 ---------------------------------------------
Sets the mime type . --> Sets the raw data . --> Socre: 1.0

[[[[Adv]]]]: public RawData as ( final String [[mimeOrExtension]] ) { if ( [[mimeOrExtension]] . contains ( StringPool . SLASH ) ) { this . mimeType = [[mimeOrExtension]] ; } else { this . mimeType = MimeTypes . getMimeType ( [[mimeOrExtension]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData as ( final String [[manero]] ) { if ( [[manero]] . contains ( StringPool . SLASH ) ) { this . mimeType = [[manero]] ; } else { this . mimeType = MimeTypes . getMimeType ( [[manero]] ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!


--------------------------------------------- Result 908 ---------------------------------------------
Sets the download file . --> Set Cologne --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String [[downloadFileName]] ) { this . downloadFileName = [[downloadFileName]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[downloadFileName]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[cologne]] ( final String [[disquiet]] ) { this . downloadFileName = [[disquiet]] ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( [[disquiet]] ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .


--------------------------------------------- Result 909 ---------------------------------------------
Sets the target . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[cubic]] ( final InputStream [[chengdu]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[chengdu]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .


--------------------------------------------- Result 910 ---------------------------------------------
Sets the target . --> [[[FAILED]]]

[[[[Adv]]]]: protected T [[setTarget]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[hugh]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!


--------------------------------------------- Result 911 ---------------------------------------------
Sets the target . --> Serve poison function --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[savarin]] ( final Class [[adulterous]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[adulterous]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[adulterous]] . getName ( ) ) ; } targetClass = [[adulterous]] ; targetClassName = [[adulterous]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[adulterous]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .


--------------------------------------------- Result 912 ---------------------------------------------
If the target is not null throws an exception . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[authenticate]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .


--------------------------------------------- Result 913 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 596 / 296 / 21 / 913:  91%|█████████▏| 913/1000 [5:39:47<32:22, 22.33s/it][Succeeded / Failed / Skipped / Total] 596 / 296 / 21 / 913:  91%|█████████▏| 914/1000 [5:40:13<32:00, 22.33s/it][Succeeded / Failed / Skipped / Total] 597 / 296 / 21 / 914:  91%|█████████▏| 914/1000 [5:40:13<32:00, 22.33s/it][Succeeded / Failed / Skipped / Total] 597 / 296 / 21 / 914:  92%|█████████▏| 915/1000 [5:40:26<31:37, 22.32s/it][Succeeded / Failed / Skipped / Total] 597 / 297 / 21 / 915:  92%|█████████▏| 915/1000 [5:40:26<31:37, 22.32s/it][Succeeded / Failed / Skipped / Total] 597 / 297 / 21 / 915:  92%|█████████▏| 916/1000 [5:41:00<31:16, 22.34s/it][Succeeded / Failed / Skipped / Total] 598 / 297 / 21 / 916:  92%|█████████▏| 916/1000 [5:41:00<31:16, 22.34s/it][Succeeded / Failed / Skipped / Total] 598 / 297 / 21 / 916:  92%|█████████▏| 917/1000 [5:41:23<30:53, 22.34s/it][Succeeded / Failed / Skipped / Total] 599 / 297 / 21 / 917:  92%|█████████▏| 917/1000 [5:41:23<30:53, 22.34s/it][Succeeded / Failed / Skipped / Total] 599 / 297 / 21 / 917:  92%|█████████▏| 918/1000 [5:41:44<30:31, 22.34s/it][Succeeded / Failed / Skipped / Total] 600 / 297 / 21 / 918:  92%|█████████▏| 918/1000 [5:41:44<30:31, 22.34s/it][Succeeded / Failed / Skipped / Total] 600 / 297 / 21 / 918:  92%|█████████▏| 919/1000 [5:41:51<30:07, 22.32s/it][Succeeded / Failed / Skipped / Total] 601 / 297 / 21 / 919:  92%|█████████▏| 919/1000 [5:41:51<30:07, 22.32s/it][Succeeded / Failed / Skipped / Total] 601 / 297 / 21 / 919:  92%|█████████▏| 920/1000 [5:42:07<29:45, 22.31s/it]Create the proxy . --> Generate a jar file --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] [[create]] ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] [[genki]] ( ) { process ( ) ; byte [ ] [[resurrects]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[resurrects]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[resurrects]] ; }
[[[[Nl]]]]: Returns byte array of created class .


--------------------------------------------- Result 914 ---------------------------------------------
Define the target class . --> Returns the dulimer --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] [[bytes]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[bytes]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[bytes]] , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[dulcimer]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] [[calvary]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[calvary]] ) ; return DefineClass . of ( getProxyClassName ( ) , [[calvary]] , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .


--------------------------------------------- Result 915 ---------------------------------------------
Returns a new instance of the Prote Proxy . --> [[[FAILED]]]

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[webcam]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .


--------------------------------------------- Result 916 ---------------------------------------------
Dumps the class in debug folder . --> Write the debug info in debug mode --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] [[bytes]] ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[debugFolder]] , fileName ) ; try { FileUtil . writeBytes ( file , [[bytes]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[estee]] ( final byte [ ] [[flaunts]] ) { File [[mayday]] = proxetta . getDebugFolder ( ) ; if ( [[mayday]] == null ) { return ; } if ( ! [[mayday]] . exists ( ) || ! [[mayday]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[mayday]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[mayday]] , fileName ) ; try { FileUtil . writeBytes ( file , [[flaunts]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .


--------------------------------------------- Result 917 ---------------------------------------------
Set the email address . --> Creates an adobe recipient --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String [[personalName]] , final String [[from]] ) { return [[from]] ( new EmailAddress ( [[personalName]] , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[adobe]] ( final String [[emotionally]] , final String [[mey]] ) { return [[adobe]] ( new EmailAddress ( [[emotionally]] , [[adobe]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .


--------------------------------------------- Result 918 ---------------------------------------------
Set the recipient address . --> documentation inherited from EmailAddress --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress to ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[encompass]] ( final EmailAddress to ) { this . [[purple]] = ArraysUtil . append ( this . [[purple]] , [[encompass]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .


--------------------------------------------- Result 919 ---------------------------------------------
Add a recipient to the recipient --> Send a phone number --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String personalName , final String to ) { return [[to]] ( new EmailAddress ( personalName , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[calne]] ( final String personalName , final String to ) { return [[calne]] ( new EmailAddress ( personalName , [[calne]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .


--------------------------------------------- Result 920 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 602 / 297 / 21 / 920:  92%|█████████▏| 920/1000 [5:42:07<29:45, 22.31s/it][Succeeded / Failed / Skipped / Total] 602 / 297 / 21 / 920:  92%|█████████▏| 921/1000 [5:42:20<29:21, 22.30s/it][Succeeded / Failed / Skipped / Total] 603 / 297 / 21 / 921:  92%|█████████▏| 921/1000 [5:42:20<29:21, 22.30s/it][Succeeded / Failed / Skipped / Total] 603 / 297 / 21 / 921:  92%|█████████▏| 922/1000 [5:42:34<28:58, 22.29s/it][Succeeded / Failed / Skipped / Total] 604 / 297 / 21 / 922:  92%|█████████▏| 922/1000 [5:42:34<28:58, 22.29s/it][Succeeded / Failed / Skipped / Total] 604 / 297 / 21 / 922:  92%|█████████▏| 923/1000 [5:42:55<28:36, 22.29s/it][Succeeded / Failed / Skipped / Total] 604 / 298 / 21 / 923:  92%|█████████▏| 923/1000 [5:42:55<28:36, 22.29s/it][Succeeded / Failed / Skipped / Total] 604 / 298 / 21 / 923:  92%|█████████▏| 924/1000 [5:43:20<28:14, 22.29s/it][Succeeded / Failed / Skipped / Total] 605 / 298 / 21 / 924:  92%|█████████▏| 924/1000 [5:43:20<28:14, 22.29s/it][Succeeded / Failed / Skipped / Total] 605 / 298 / 21 / 924:  92%|█████████▎| 925/1000 [5:43:49<27:52, 22.30s/it][Succeeded / Failed / Skipped / Total] 605 / 299 / 21 / 925:  92%|█████████▎| 925/1000 [5:43:49<27:52, 22.30s/it][Succeeded / Failed / Skipped / Total] 605 / 299 / 21 / 925:  93%|█████████▎| 926/1000 [5:43:57<27:29, 22.29s/it][Succeeded / Failed / Skipped / Total] 606 / 299 / 21 / 926:  93%|█████████▎| 926/1000 [5:43:57<27:29, 22.29s/it][Succeeded / Failed / Skipped / Total] 606 / 299 / 21 / 926:  93%|█████████▎| 927/1000 [5:44:28<27:07, 22.30s/it][Succeeded / Failed / Skipped / Total] 607 / 299 / 21 / 927:  93%|█████████▎| 927/1000 [5:44:28<27:07, 22.30s/it][Succeeded / Failed / Skipped / Total] 607 / 299 / 21 / 927:  93%|█████████▎| 928/1000 [5:45:02<26:46, 22.31s/it][Succeeded / Failed / Skipped / Total] 608 / 299 / 21 / 928:  93%|█████████▎| 928/1000 [5:45:02<26:46, 22.31s/it][Succeeded / Failed / Skipped / Total] 608 / 299 / 21 / 928:  93%|█████████▎| 929/1000 [5:45:10<26:22, 22.29s/it]Sets the reply addresses . --> Setter for TRAPPING --> Socre: 1.0

[[[[Adv]]]]: public T [[REPLACEME0]] ( final EmailAddress ... [[REPLACEME0]] ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( [[REPLACEME0]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T [[TRAPPING]] ( final EmailAddress ... [[TRAPPING]] ) { this . [[hails]] = ArraysUtil . join ( this . [[hails]] , valueOrEmptyArray ( [[TRAPPING]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .


--------------------------------------------- Result 921 ---------------------------------------------
Sets the cc recipient address . --> Set the recipients of this email --> Socre: 1.0

[[[[Adv]]]]: public T cc ( final EmailAddress ... [[ccs]] ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( [[ccs]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T cc ( final EmailAddress ... [[clowning]] ) { this . [[defrauding]] = ArraysUtil . join ( this . [[defrauding]] , valueOrEmptyArray ( [[clowning]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .


--------------------------------------------- Result 922 ---------------------------------------------
Adds a text message . --> Create a new Email --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String encoding ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[achille]] ( final String [[cri]] , final String encoding ) { return message ( new EmailMessage ( [[cri]] , MimeTypes . MIME_TEXT_PLAIN , encoding ) ) ; }
[[[[Nl]]]]: Adds plain message text .


--------------------------------------------- Result 923 ---------------------------------------------
Create an email message with the specified encoding . --> [[[FAILED]]]

[[[[Adv]]]]: public T htmlMessage ( final String [[html]] , final String encoding ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T htmlMessage ( final String [[cmon]] , final String encoding ) { return message ( new EmailMessage ( [[cmon]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .


--------------------------------------------- Result 924 ---------------------------------------------
Sets a header . --> Specify a number of headers --> Socre: 1.0

[[[[Adv]]]]: public T [[header]] ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T [[beware]] ( final String [[numbskull]] , final String [[gout]] ) { headers . put ( [[numbskull]] , [[gout]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .


--------------------------------------------- Result 925 ---------------------------------------------
Returns the value of a property . --> [[[FAILED]]]

[[[[Adv]]]]: public static String get ( final String [[name]] , final String [[defaultValue]] ) { Objects . requireNonNull ( [[name]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[name]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[name]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[defaultValue]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String get ( final String [[bloke]] , final String [[ángel]] ) { Objects . requireNonNull ( [[bloke]] ) ; String value = null ; try { if ( System . getSecurityManager ( ) == null ) { value = System . getProperty ( [[bloke]] ) ; } else { value = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( [[bloke]] ) ) ; } } catch ( Exception ignore ) { } if ( value == null ) { return [[ángel]] ; } return value ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .


--------------------------------------------- Result 926 ---------------------------------------------
Returns boolean value . --> Reads a contrast --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return True ; case "false" : case "no" : case "0" : case "off" : return False ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[contrast]] ( final String name , final boolean defaultValue ) { String value = get ( name ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return True ; case "false" : case "no" : case "0" : case "off" : return False ; default : return defaultValue ; } }
[[[[Nl]]]]: Returns system property as boolean .


--------------------------------------------- Result 927 ---------------------------------------------
Returns the integer value for the given name . --> Reads the aromather type --> Socre: 1.0

[[[[Adv]]]]: public static long [[getInt]] ( final String name , final int defaultValue ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return defaultValue ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long [[aromatherapy]] ( final String name , final int defaultValue ) { String [[metai]] = get ( name ) ; if ( [[metai]] == null ) { return defaultValue ; } [[metai]] = [[metai]] . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( [[metai]] ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .


--------------------------------------------- Result 928 ---------------------------------------------
Returns the long value . --> Finds the value of the swagger matching the given name --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLong]] ( final String name , final long [[defaultValue]] ) { String [[value]] = get ( name ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long [[alize]] ( final String name , final long [[implicated]] ) { String [[swaggering]] = get ( name ) ; if ( [[swaggering]] == null ) { return [[implicated]] ; } [[swaggering]] = [[swaggering]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[swaggering]] ) ; } catch ( NumberFormatException nfex ) { return [[implicated]] ; } }
[[[[Nl]]]]: Returns system property as a long .


--------------------------------------------- Result 929 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 608 / 300 / 21 / 929:  93%|█████████▎| 929/1000 [5:45:10<26:22, 22.29s/it][Succeeded / Failed / Skipped / Total] 608 / 300 / 21 / 929:  93%|█████████▎| 930/1000 [5:45:19<25:59, 22.28s/it][Succeeded / Failed / Skipped / Total] 609 / 300 / 21 / 930:  93%|█████████▎| 930/1000 [5:45:19<25:59, 22.28s/it][Succeeded / Failed / Skipped / Total] 609 / 300 / 21 / 930:  93%|█████████▎| 931/1000 [5:45:44<25:37, 22.28s/it][Succeeded / Failed / Skipped / Total] 610 / 300 / 21 / 931:  93%|█████████▎| 931/1000 [5:45:44<25:37, 22.28s/it][Succeeded / Failed / Skipped / Total] 610 / 300 / 21 / 931:  93%|█████████▎| 932/1000 [5:46:18<25:16, 22.29s/it][Succeeded / Failed / Skipped / Total] 611 / 300 / 21 / 932:  93%|█████████▎| 932/1000 [5:46:18<25:16, 22.29s/it][Succeeded / Failed / Skipped / Total] 611 / 300 / 21 / 932:  93%|█████████▎| 933/1000 [5:46:40<24:53, 22.29s/it][Succeeded / Failed / Skipped / Total] 612 / 300 / 21 / 933:  93%|█████████▎| 933/1000 [5:46:40<24:53, 22.29s/it][Succeeded / Failed / Skipped / Total] 612 / 300 / 21 / 933:  93%|█████████▎| 934/1000 [5:47:14<24:32, 22.31s/it][Succeeded / Failed / Skipped / Total] 613 / 300 / 21 / 934:  93%|█████████▎| 934/1000 [5:47:14<24:32, 22.31s/it][Succeeded / Failed / Skipped / Total] 613 / 300 / 21 / 934:  94%|█████████▎| 935/1000 [5:47:47<24:10, 22.32s/it][Succeeded / Failed / Skipped / Total] 613 / 301 / 21 / 935:  94%|█████████▎| 935/1000 [5:47:47<24:10, 22.32s/it][Succeeded / Failed / Skipped / Total] 613 / 301 / 21 / 935:  94%|█████████▎| 936/1000 [5:48:02<23:47, 22.31s/it][Succeeded / Failed / Skipped / Total] 614 / 301 / 21 / 936:  94%|█████████▎| 936/1000 [5:48:02<23:47, 22.31s/it][Succeeded / Failed / Skipped / Total] 614 / 301 / 21 / 936:  94%|█████████▎| 937/1000 [5:48:29<23:25, 22.32s/it][Succeeded / Failed / Skipped / Total] 614 / 302 / 21 / 937:  94%|█████████▎| 937/1000 [5:48:29<23:25, 22.32s/it][Succeeded / Failed / Skipped / Total] 614 / 302 / 21 / 937:  94%|█████████▍| 938/1000 [5:48:37<23:02, 22.30s/it]Gets the resolved parameters . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[cortical]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .


--------------------------------------------- Result 930 ---------------------------------------------
Helper method to serialize a key value pair . --> Helper method for serialization --> Socre: 1.0

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext [[jsonContext]] , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && [[jsonContext]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext [[corine]] , final Path currentPath , final Object key , final Object value , int count ) { if ( ( value == null ) && [[corine]] . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .


--------------------------------------------- Result 931 ---------------------------------------------
Lookup a path alias . --> Returns the acapcoulc for the given string --> Socre: 1.0

[[[[Adv]]]]: protected String [[lookupAlias]] ( final String [[alias]] ) { String value = actionsManager . lookupPathAlias ( [[alias]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[alias]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String [[acapulco]] ( final String [[fondi]] ) { String value = actionsManager . lookupPathAlias ( [[fondi]] ) ; if ( value == null ) { ActionRuntime cfg = actionsManager . lookup ( [[fondi]] ) ; if ( cfg != null ) { value = cfg . getActionPath ( ) ; } } return value ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .


--------------------------------------------- Result 932 ---------------------------------------------
Resolve alias . --> Method to format atlas --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[len]] = value . length ( ) ; while ( i < [[len]] ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[atlas]] ( final String value ) { final StringBuilder result = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[vicenza]] = value . length ( ) ; while ( i < [[vicenza]] ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .


--------------------------------------------- Result 933 ---------------------------------------------
Resolve the given path and value . --> Boggling for Boggling --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String value ) { boolean [[absolutePath]] = False ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[boggling]] ( String path , String value ) { boolean [[factored]] = False ; if ( value != null ) {
[[[[Nl]]]]: Resolves result path .


--------------------------------------------- Result 934 ---------------------------------------------
Resolve the specified path and return the alias value . --> Retrieves the bathed resource --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String path , final String [[value]] ) { final ResultPath resultPath = resolveResultPath ( path , [[value]] ) ; final String [[result]] = resultPath . pathValue ( ) ; return resolveAlias ( [[result]] ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[batwoman]] ( final String path , final String [[taxable]] ) { final ResultPath resultPath = resolveResultPath ( path , [[taxable]] ) ; final String [[domini]] = resultPath . pathValue ( ) ; return resolveAlias ( [[domini]] ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .


--------------------------------------------- Result 935 ---------------------------------------------
Returns the index of the last dot in the given string . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int [[dotNdx]] = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( [[dotNdx]] == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { [[dotNdx]] = slashNdx ; } else { [[dotNdx]] = - 1 ; } } return [[dotNdx]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[kimba]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int [[spartacus]] = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( [[spartacus]] == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { [[spartacus]] = slashNdx ; } else { [[spartacus]] = - 1 ; } } return [[spartacus]] ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .


--------------------------------------------- Result 936 ---------------------------------------------
Returns the index of the last dot after dot . --> Getter for monomer --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; [[slashNdx]] ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[unbeliever]] ( final String str ) { int [[monahan]] = str . lastIndexOf ( ' ' ) ; [[monahan]] ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , [[monahan]] ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .


--------------------------------------------- Result 937 ---------------------------------------------
Returns the index of the first dot after dot . --> [[[FAILED]]]

[[[[Adv]]]]: public static int [[indexOfDotAfterSlash]] ( final String [[str]] ) { int slashNdx = [[str]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[str]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int [[fronting]] ( final String [[johns]] ) { int slashNdx = [[johns]] . lastIndexOf ( ' ' ) ; if ( slashNdx == - 1 ) { slashNdx = 0 ; } return [[johns]] . indexOf ( ' ' , slashNdx ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .


--------------------------------------------- Result 938 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 615 / 302 / 21 / 938:  94%|█████████▍| 938/1000 [5:48:37<23:02, 22.30s/it][Succeeded / Failed / Skipped / Total] 615 / 302 / 21 / 938:  94%|█████████▍| 939/1000 [5:49:16<22:41, 22.32s/it][Succeeded / Failed / Skipped / Total] 615 / 303 / 21 / 939:  94%|█████████▍| 939/1000 [5:49:16<22:41, 22.32s/it][Succeeded / Failed / Skipped / Total] 615 / 303 / 21 / 939:  94%|█████████▍| 940/1000 [5:50:23<22:21, 22.37s/it][Succeeded / Failed / Skipped / Total] 615 / 304 / 21 / 940:  94%|█████████▍| 940/1000 [5:50:23<22:21, 22.37s/it][Succeeded / Failed / Skipped / Total] 615 / 304 / 21 / 940:  94%|█████████▍| 941/1000 [5:50:41<21:59, 22.36s/it][Succeeded / Failed / Skipped / Total] 616 / 304 / 21 / 941:  94%|█████████▍| 941/1000 [5:50:41<21:59, 22.36s/it][Succeeded / Failed / Skipped / Total] 616 / 304 / 21 / 941:  94%|█████████▍| 942/1000 [5:50:48<21:35, 22.34s/it][Succeeded / Failed / Skipped / Total] 617 / 304 / 21 / 942:  94%|█████████▍| 942/1000 [5:50:48<21:35, 22.34s/it][Succeeded / Failed / Skipped / Total] 617 / 304 / 21 / 942:  94%|█████████▍| 943/1000 [5:50:55<21:12, 22.33s/it][Succeeded / Failed / Skipped / Total] 618 / 304 / 21 / 943:  94%|█████████▍| 943/1000 [5:50:55<21:12, 22.33s/it][Succeeded / Failed / Skipped / Total] 618 / 304 / 21 / 943:  94%|█████████▍| 944/1000 [5:51:02<20:49, 22.31s/it][Succeeded / Failed / Skipped / Total] 619 / 304 / 21 / 944:  94%|█████████▍| 944/1000 [5:51:02<20:49, 22.31s/it][Succeeded / Failed / Skipped / Total] 619 / 304 / 21 / 944:  94%|█████████▍| 945/1000 [5:51:51<20:28, 22.34s/it][Succeeded / Failed / Skipped / Total] 620 / 304 / 21 / 945:  94%|█████████▍| 945/1000 [5:51:51<20:28, 22.34s/it][Succeeded / Failed / Skipped / Total] 620 / 304 / 21 / 945:  95%|█████████▍| 946/1000 [5:52:11<20:06, 22.34s/it][Succeeded / Failed / Skipped / Total] 621 / 304 / 21 / 946:  95%|█████████▍| 946/1000 [5:52:11<20:06, 22.34s/it][Succeeded / Failed / Skipped / Total] 621 / 304 / 21 / 946:  95%|█████████▍| 947/1000 [5:52:27<19:43, 22.33s/it]Strips the last camel word . --> Strip camel word from string --> Socre: 1.0

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[name]] ) { int ndx = [[name]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[name]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[name]] = [[name]] . substring ( 0 , ndx ) ; } return [[name]] ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[orbs]] ) { int ndx = [[orbs]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[orbs]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[orbs]] = [[orbs]] . substring ( 0 , ndx ) ; } return [[orbs]] ; }
[[[[Nl]]]]: Removes last CamelWord


--------------------------------------------- Result 939 ---------------------------------------------
Resolves the schema name . --> [[[FAILED]]]

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String [[defaultSchemaName]] ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = [[defaultSchemaName]] ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[hangmen]] ( final Class < ? > type , final String [[evocative]] ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = [[evocative]] ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .


--------------------------------------------- Result 940 ---------------------------------------------
Resolve column descriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean [[isId]] = False ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean [[phoney]] = False ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .


--------------------------------------------- Result 941 ---------------------------------------------
Initializes this sketch with the given key and tweak . --> Called when a cap is changed --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] [[key]] , final long [ ] tweak ) { final int newNw = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[changing]] ( final long [ ] [[capitan]] , final long [ ] tweak ) { final int newNw = [[capitan]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .


--------------------------------------------- Result 942 ---------------------------------------------
Multiply x . --> Multiply x by j --> Socre: 1.0

[[[[Adv]]]]: private void mix ( final int j , final int [[d]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[d]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void mix ( final int j , final int [[farmyard]] ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ [[farmyard]] % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .


--------------------------------------------- Result 943 ---------------------------------------------
Dexes the poix of a given position . --> remix zeros --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int [[j]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[j]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int [[dippy]] , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long rotr = r [ d % DEPTH_OF_D_IN_R ] [ [[dippy]] ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .


--------------------------------------------- Result 944 ---------------------------------------------
Schedule key schedule . --> Key schedule for a key --> Socre: 1.0

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int [[i]] = 0 ; [[i]] < nw ; [[i]] ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int [[aegis]] = 0 ; [[aegis]] < nw ; [[aegis]] ++ ) {
[[[[Nl]]]]: Creates the subkeys .


--------------------------------------------- Result 945 ---------------------------------------------
Initializes the hash with the specified key message . --> Swap the specified key message with the specified tweak --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final String keyMessage , final long tweak1 , final long [[tweak2]] ) { long [ ] tweak = new long [ ] { tweak1 , [[tweak2]] } ; byte [ ] [[key]] = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[keyData]] = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( [[keyData]] , 0 , [[key]] , 0 , [[key]] . length < [[keyData]] . length ? [[key]] . length : [[keyData]] . length ) ; [[init]] ( bytesToLongs ( [[key]] ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void [[swedes]] ( final String keyMessage , final long tweak1 , final long [[eid]] ) { long [ ] tweak = new long [ ] { tweak1 , [[eid]] } ; byte [ ] [[kaffee]] = new byte [ blockSize / Byte . SIZE ] ; byte [ ] [[fay]] = StringUtil . getBytes ( keyMessage ) ; System . arraycopy ( [[fay]] , 0 , [[kaffee]] , 0 , [[kaffee]] . length < [[fay]] . length ? [[kaffee]] . length : [[fay]] . length ) ; [[swedes]] ( bytesToLongs ( [[kaffee]] ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .


--------------------------------------------- Result 946 ---------------------------------------------
Encrypt a block . --> Encodes the Haggard --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[encryptBlock]] ( final byte [ ] [[content]] , final int [[offset]] ) { long [ ] contentBlock = bytesToLongs ( [[content]] , [[offset]] , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] [[haggard]] ( final byte [ ] [[abundantly]] , final int [[forums]] ) { long [ ] contentBlock = bytesToLongs ( [[abundantly]] , [[forums]] , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .


--------------------------------------------- Result 947 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 622 / 304 / 21 / 947:  95%|█████████▍| 947/1000 [5:52:27<19:43, 22.33s/it][Succeeded / Failed / Skipped / Total] 622 / 304 / 21 / 947:  95%|█████████▍| 948/1000 [5:52:51<19:21, 22.33s/it][Succeeded / Failed / Skipped / Total] 623 / 304 / 21 / 948:  95%|█████████▍| 948/1000 [5:52:51<19:21, 22.33s/it][Succeeded / Failed / Skipped / Total] 623 / 304 / 21 / 948:  95%|█████████▍| 949/1000 [5:52:59<18:58, 22.32s/it][Succeeded / Failed / Skipped / Total] 624 / 304 / 21 / 949:  95%|█████████▍| 949/1000 [5:52:59<18:58, 22.32s/it][Succeeded / Failed / Skipped / Total] 624 / 304 / 21 / 949:  95%|█████████▌| 950/1000 [5:53:05<18:35, 22.30s/it][Succeeded / Failed / Skipped / Total] 625 / 304 / 21 / 950:  95%|█████████▌| 950/1000 [5:53:05<18:35, 22.30s/it][Succeeded / Failed / Skipped / Total] 625 / 304 / 21 / 950:  95%|█████████▌| 951/1000 [5:53:17<18:12, 22.29s/it][Succeeded / Failed / Skipped / Total] 626 / 304 / 21 / 951:  95%|█████████▌| 951/1000 [5:53:17<18:12, 22.29s/it][Succeeded / Failed / Skipped / Total] 626 / 304 / 21 / 951:  95%|█████████▌| 952/1000 [5:53:22<17:49, 22.27s/it][Succeeded / Failed / Skipped / Total] 627 / 304 / 21 / 952:  95%|█████████▌| 952/1000 [5:53:22<17:49, 22.27s/it][Succeeded / Failed / Skipped / Total] 627 / 304 / 21 / 952:  95%|█████████▌| 953/1000 [5:53:30<17:26, 22.26s/it][Succeeded / Failed / Skipped / Total] 628 / 304 / 21 / 953:  95%|█████████▌| 953/1000 [5:53:30<17:26, 22.26s/it][Succeeded / Failed / Skipped / Total] 628 / 304 / 21 / 953:  95%|█████████▌| 954/1000 [5:54:00<17:04, 22.27s/it]Convert a byte array to a long array . --> non - private --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] ba , final int [[offset]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[offset]] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[dishonorably]] ( final byte [ ] ba , final int [[timberlake]] , final int size ) { long [ ] result = new long [ size >> 3 ] ; int i8 = [[timberlake]] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , i8 ) ; i8 += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .


--------------------------------------------- Result 948 ---------------------------------------------
Remove any bounding box . --> Returns alphanumeric --> Socre: 1.0

[[[[Adv]]]]: private static String [[removeAnyBounding]] ( final char [[s]] , final char [[e]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( [[s]] ) ) && str . endsWith ( String . valueOf ( [[e]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String [[alibaba]] ( final char [[cornelia]] , final char [[delivery]] , final String str ) { if ( str == null || str . length ( ) < 2 ) { return str ; } if ( str . startsWith ( String . valueOf ( [[cornelia]] ) ) && str . endsWith ( String . valueOf ( [[delivery]] ) ) ) { return str . substring ( 1 , str . length ( ) - 1 ) ; } return str ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .


--------------------------------------------- Result 949 ---------------------------------------------
Returns the path of this method . --> Get the method name --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[zhao]] ( ) { if ( methref != null ) { final String methodName = methref . ref ( ) ; return target . getName ( ) + ' ' + methodName ; } return [[zhao]] ; }
[[[[Nl]]]]: Returns path value .


--------------------------------------------- Result 950 ---------------------------------------------
Zips a file --> Zips the given longitude --> Socre: 1.0

[[[[Adv]]]]: public static File zlib ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File [[longitude]] ) throws IOException { if ( [[longitude]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[longitude]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[longitude]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .


--------------------------------------------- Result 951 ---------------------------------------------
Gzip a file --> Gzipped files --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; String gzipName = [[file]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[howitzer]] ( final File [[bent]] ) throws IOException { if ( [[bent]] . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( [[bent]] ) ; String gzipName = [[bent]] . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( gzipName ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( gzipName ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .


--------------------------------------------- Result 952 ---------------------------------------------
Ungzipped file . --> Ungzips a file --> Socre: 1.0

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream [[gzis]] = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( [[gzis]] , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( [[gzis]] ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream fos = new FileOutputStream ( out ) ; GZIPInputStream [[bluetooth]] = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( [[bluetooth]] , fos ) ; } finally { StreamUtil . close ( fos ) ; StreamUtil . close ( [[bluetooth]] ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .


--------------------------------------------- Result 953 ---------------------------------------------
Lists all entries in a zip file . --> Returns a list of all the entries in a given bag --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File [[zipFile]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File [[bagheera]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[bagheera]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .


--------------------------------------------- Result 954 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 629 / 304 / 21 / 954:  95%|█████████▌| 954/1000 [5:54:00<17:04, 22.27s/it][Succeeded / Failed / Skipped / Total] 629 / 304 / 21 / 954:  96%|█████████▌| 955/1000 [5:54:28<16:42, 22.27s/it][Succeeded / Failed / Skipped / Total] 630 / 304 / 21 / 955:  96%|█████████▌| 955/1000 [5:54:28<16:42, 22.27s/it][Succeeded / Failed / Skipped / Total] 630 / 304 / 21 / 955:  96%|█████████▌| 956/1000 [5:55:20<16:21, 22.30s/it][Succeeded / Failed / Skipped / Total] 630 / 305 / 21 / 956:  96%|█████████▌| 956/1000 [5:55:20<16:21, 22.30s/it][Succeeded / Failed / Skipped / Total] 630 / 305 / 21 / 956:  96%|█████████▌| 957/1000 [5:56:08<16:00, 22.33s/it][Succeeded / Failed / Skipped / Total] 630 / 306 / 21 / 957:  96%|█████████▌| 957/1000 [5:56:08<16:00, 22.33s/it][Succeeded / Failed / Skipped / Total] 630 / 306 / 21 / 957:  96%|█████████▌| 958/1000 [5:56:49<15:38, 22.35s/it][Succeeded / Failed / Skipped / Total] 630 / 307 / 21 / 958:  96%|█████████▌| 958/1000 [5:56:49<15:38, 22.35s/it][Succeeded / Failed / Skipped / Total] 630 / 307 / 21 / 958:  96%|█████████▌| 959/1000 [5:57:12<15:16, 22.35s/it][Succeeded / Failed / Skipped / Total] 630 / 308 / 21 / 959:  96%|█████████▌| 959/1000 [5:57:12<15:16, 22.35s/it][Succeeded / Failed / Skipped / Total] 630 / 308 / 21 / 959:  96%|█████████▌| 960/1000 [5:57:47<14:54, 22.36s/it][Succeeded / Failed / Skipped / Total] 630 / 309 / 21 / 960:  96%|█████████▌| 960/1000 [5:57:47<14:54, 22.36s/it][Succeeded / Failed / Skipped / Total] 630 / 309 / 21 / 960:  96%|█████████▌| 961/1000 [5:58:06<14:31, 22.36s/it]Unzip a zip file --> Unzipped files --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String [[destDir]] , final String ... patterns ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( [[destDir]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[barbarossa]] , final String [[donc]] , final String ... patterns ) throws IOException { unzip ( new File ( [[barbarossa]] ) , new File ( [[donc]] ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .


--------------------------------------------- Result 955 ---------------------------------------------
Adds a file to the ZIP output stream . --> linkler --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File [[file]] , String [[path]] , final String comment , final boolean [[recursive]] ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( [[path]] == null ) { [[path]] = [[file]] . getName ( ) ; } while ( [[path]] . length ( ) != 0 && [[path]] . charAt ( 0 ) == ' ' ) { [[path]] = [[path]] . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[lindbergh]] ( final ZipOutputStream zos , final File [[rustles]] , String [[blackwater]] , final String comment , final boolean [[amps]] ) throws IOException { if ( ! [[rustles]] . exists ( ) ) { throw new FileNotFoundException ( [[rustles]] . toString ( ) ) ; } if ( [[blackwater]] == null ) { [[blackwater]] = [[rustles]] . getName ( ) ; } while ( [[blackwater]] . length ( ) != 0 && [[blackwater]] . charAt ( 0 ) == ' ' ) { [[blackwater]] = [[blackwater]] . substring ( 1 ) ; } boolean isDir = [[rustles]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .


--------------------------------------------- Result 956 ---------------------------------------------
Adds content to a ZIP output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry [[zipEntry]] = new ZipEntry ( path ) ; [[zipEntry]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[zipEntry]] . setComment ( comment ) ; } zos . putNextEntry ( [[zipEntry]] ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void [[chu]] ( final ZipOutputStream zos , final byte [ ] content , String path , final String comment ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry [[voices]] = new ZipEntry ( path ) ; [[voices]] . setTime ( System . currentTimeMillis ( ) ) ; if ( comment != null ) { [[voices]] . setComment ( comment ) ; } zos . putNextEntry ( [[voices]] ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .


--------------------------------------------- Result 957 ---------------------------------------------
Returns the FieldDescriptor with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public FieldDescriptor [[getFieldDescriptor]] ( final String [[name]] , final boolean [[declared]] ) { final FieldDescriptor [[fieldDescriptor]] = getFields ( ) . getFieldDescriptor ( [[name]] ) ; if ( [[fieldDescriptor]] != null ) { if ( ! [[fieldDescriptor]] . matchDeclared ( [[declared]] ) ) { return null ; } } return [[fieldDescriptor]] ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor [[surrounded]] ( final String [[majorca]] , final boolean [[erred]] ) { final FieldDescriptor [[commendable]] = getFields ( ) . getFieldDescriptor ( [[majorca]] ) ; if ( [[commendable]] != null ) { if ( ! [[commendable]] . matchDeclared ( [[erred]] ) ) { return null ; } } return [[commendable]] ; }
[[[[Nl]]]]: Returns field descriptor .


--------------------------------------------- Result 958 ---------------------------------------------
Returns the descriptor with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String name , final boolean declared ) { PropertyDescriptor [[propertyDescriptor]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[propertyDescriptor]] != null ) && [[propertyDescriptor]] . matchDeclared ( declared ) ) { return [[propertyDescriptor]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[computing]] ( final String name , final boolean declared ) { PropertyDescriptor [[spared]] = getProperties ( ) . getPropertyDescriptor ( name ) ; if ( ( [[spared]] != null ) && [[spared]] . matchDeclared ( declared ) ) { return [[spared]] ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .


--------------------------------------------- Result 959 ---------------------------------------------
Sets the request bundle name . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[astringent]] ( final ServletRequest [[sunder]] , final String [[toughen]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[toughen]] ) ; } [[sunder]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[toughen]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .


--------------------------------------------- Result 960 ---------------------------------------------
Sets a session locale . --> [[[FAILED]]]

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale [[locale]] = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void setSessionLocale ( final HttpSession [[spyro]] , final String [[bardot]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[bardot]] ) ; } Locale [[laughingly]] = Locale . forLanguageTag ( [[bardot]] ) ; [[spyro]] . setAttribute ( SESSION_LOCALE_ATTR , [[laughingly]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .


--------------------------------------------- Result 961 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 630 / 310 / 21 / 961:  96%|█████████▌| 961/1000 [5:58:06<14:31, 22.36s/it][Succeeded / Failed / Skipped / Total] 630 / 310 / 21 / 961:  96%|█████████▌| 962/1000 [5:58:20<14:09, 22.35s/it][Succeeded / Failed / Skipped / Total] 631 / 310 / 21 / 962:  96%|█████████▌| 962/1000 [5:58:20<14:09, 22.35s/it][Succeeded / Failed / Skipped / Total] 631 / 310 / 21 / 962:  96%|█████████▋| 963/1000 [5:58:35<13:46, 22.34s/it][Succeeded / Failed / Skipped / Total] 631 / 311 / 21 / 963:  96%|█████████▋| 963/1000 [5:58:35<13:46, 22.34s/it][Succeeded / Failed / Skipped / Total] 631 / 311 / 21 / 963:  96%|█████████▋| 964/1000 [5:58:53<13:24, 22.34s/it][Succeeded / Failed / Skipped / Total] 632 / 311 / 21 / 964:  96%|█████████▋| 964/1000 [5:58:53<13:24, 22.34s/it][Succeeded / Failed / Skipped / Total] 632 / 311 / 21 / 964:  96%|█████████▋| 965/1000 [5:59:26<13:02, 22.35s/it][Succeeded / Failed / Skipped / Total] 633 / 311 / 21 / 965:  96%|█████████▋| 965/1000 [5:59:26<13:02, 22.35s/it][Succeeded / Failed / Skipped / Total] 633 / 311 / 21 / 965:  97%|█████████▋| 966/1000 [5:59:40<12:39, 22.34s/it][Succeeded / Failed / Skipped / Total] 634 / 311 / 21 / 966:  97%|█████████▋| 966/1000 [5:59:40<12:39, 22.34s/it][Succeeded / Failed / Skipped / Total] 634 / 311 / 21 / 966:  97%|█████████▋| 967/1000 [5:59:56<12:17, 22.33s/it][Succeeded / Failed / Skipped / Total] 635 / 311 / 21 / 967:  97%|█████████▋| 967/1000 [5:59:56<12:17, 22.33s/it][Succeeded / Failed / Skipped / Total] 635 / 311 / 21 / 967:  97%|█████████▋| 968/1000 [6:00:27<11:54, 22.34s/it]Gets the locale from the session . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession session ) { Locale [[locale]] = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[gashes]] ( final HttpSession session ) { Locale [[august]] = ( Locale ) session . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[august]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[august]] ; }
[[[[Nl]]]]: Returns current locale from session . s


--------------------------------------------- Result 962 ---------------------------------------------
Filters the parameters for a bean . --> refreshes beans --> Socre: 1.0

[[[[Adv]]]]: public String [ ] [[filterParametersForBeanName]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[key]] = entry . getKey ( ) ; if ( ! [[key]] . startsWith ( beanName ) ) { continue ; } list . add ( [[key]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] [[afresh]] ( String beanName , final boolean resolveReferenceParams ) { beanName = beanName + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String [[rinko]] = entry . getKey ( ) ; if ( ! [[rinko]] . startsWith ( beanName ) ) { continue ; } list . add ( [[rinko]] ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .


--------------------------------------------- Result 963 ---------------------------------------------
Add profiles . --> [[[FAILED]]]

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[confederacy]] ( final String ... [[wreaks]] ) { if ( [[wreaks]] == null ) { return this ; } for ( String [[confederacy]] : [[wreaks]] ) { addProfiles ( [[confederacy]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .


--------------------------------------------- Result 964 ---------------------------------------------
Reads a big endian long from the given array at the given offset . --> Returns the bretton --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] buf , final int [[offset]] ) { return ( ( long ) buf [ [[offset]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[bretton]] ( final byte [ ] buf , final int [[prosper]] ) { return ( ( long ) buf [ [[prosper]] + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .


--------------------------------------------- Result 965 ---------------------------------------------
Reads a stream and closes it . --> Nested InputStream --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[outputStream]] = new ByteArrayOutputStream ( ) ; byte [ ] [[data]] = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( [[data]] , 0 , [[data]] . length ) ) != - 1 ) { [[outputStream]] . write ( [[data]] , 0 , bytesRead ) ; } [[outputStream]] . flush ( ) ; return [[outputStream]] . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[nest]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream [[floodlight]] = new ByteArrayOutputStream ( ) ; byte [ ] [[saturdays]] = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( [[saturdays]] , 0 , [[saturdays]] . length ) ) != - 1 ) { [[floodlight]] . write ( [[saturdays]] , 0 , bytesRead ) ; } [[floodlight]] . flush ( ) ; return [[floodlight]] . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .


--------------------------------------------- Result 966 ---------------------------------------------
Reads a label from a byte array . --> Liefert einen Klasse zurueck --> Socre: 1.0

[[[[Adv]]]]: protected Label [[readLabel]] ( final int bytecodeOffset , final Label [ ] [[labels]] ) { if ( [[labels]] [ bytecodeOffset ] == null ) { [[labels]] [ bytecodeOffset ] = new Label ( ) ; } return [[labels]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label [[lafitte]] ( final int bytecodeOffset , final Label [ ] [[kraków]] ) { if ( [[kraków]] [ bytecodeOffset ] == null ) { [[kraków]] [ bytecodeOffset ] = new Label ( ) ; } return [[kraków]] [ bytecodeOffset ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .


--------------------------------------------- Result 967 ---------------------------------------------
Gets the offset of a type annotation . --> Calculates AMO indicator --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] typeAnnotationOffsets , final int [[typeAnnotationIndex]] ) { if ( typeAnnotationOffsets == null || [[typeAnnotationIndex]] >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[amaya]] ( final int [ ] typeAnnotationOffsets , final int [[commercial]] ) { if ( typeAnnotationOffsets == null || [[commercial]] >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ [[commercial]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ [[commercial]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .


--------------------------------------------- Result 968 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 636 / 311 / 21 / 968:  97%|█████████▋| 968/1000 [6:00:27<11:54, 22.34s/it][Succeeded / Failed / Skipped / Total] 636 / 311 / 21 / 968:  97%|█████████▋| 969/1000 [6:00:53<11:32, 22.35s/it][Succeeded / Failed / Skipped / Total] 637 / 311 / 21 / 969:  97%|█████████▋| 969/1000 [6:00:53<11:32, 22.35s/it][Succeeded / Failed / Skipped / Total] 637 / 311 / 21 / 969:  97%|█████████▋| 970/1000 [6:01:31<11:10, 22.36s/it][Succeeded / Failed / Skipped / Total] 638 / 311 / 21 / 970:  97%|█████████▋| 970/1000 [6:01:31<11:10, 22.36s/it][Succeeded / Failed / Skipped / Total] 638 / 311 / 21 / 970:  97%|█████████▋| 971/1000 [6:02:00<10:48, 22.37s/it][Succeeded / Failed / Skipped / Total] 639 / 311 / 21 / 971:  97%|█████████▋| 971/1000 [6:02:00<10:48, 22.37s/it][Succeeded / Failed / Skipped / Total] 639 / 311 / 21 / 971:  97%|█████████▋| 972/1000 [6:02:45<10:26, 22.39s/it][Succeeded / Failed / Skipped / Total] 639 / 312 / 21 / 972:  97%|█████████▋| 972/1000 [6:02:45<10:26, 22.39s/it][Succeeded / Failed / Skipped / Total] 639 / 312 / 21 / 972:  97%|█████████▋| 973/1000 [6:03:02<10:04, 22.39s/it][Succeeded / Failed / Skipped / Total] 639 / 313 / 21 / 973:  97%|█████████▋| 973/1000 [6:03:02<10:04, 22.39s/it][Succeeded / Failed / Skipped / Total] 639 / 313 / 21 / 973:  97%|█████████▋| 974/1000 [6:03:21<09:41, 22.38s/it]Read attribute values . --> return blanchard position --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor annotationVisitor , final int [[annotationOffset]] , final boolean named , final char [ ] charBuffer ) { int currentOffset = [[annotationOffset]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[blanchard]] ( final AnnotationVisitor annotationVisitor , final int [[himmler]] , final boolean named , final char [ ] charBuffer ) { int currentOffset = [[himmler]] ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .


--------------------------------------------- Result 969 ---------------------------------------------
Read verification type information . --> High - level code --> Socre: 1.0

[[[[Adv]]]]: private int [[readVerificationTypeInfo]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int [[tag]] = b [ currentOffset ++ ] & 0xFF ; switch ( [[tag]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int [[holla]] ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int currentOffset = verificationTypeInfoOffset ; int [[chippendale]] = b [ currentOffset ++ ] & 0xFF ; switch ( [[chippendale]] ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( currentOffset , charBuffer ) ; currentOffset += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( currentOffset ) , labels ) ; currentOffset += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return currentOffset ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .


--------------------------------------------- Result 970 ---------------------------------------------
Read all bootstrap methods attribute . --> todo support --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int [[maxStringLength]] ) { char [ ] charBuffer = new char [ [[maxStringLength]] ] ; int [[currentAttributeOffset]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( [[currentAttributeOffset]] - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[chantel]] ( final int [[unemployable]] ) { char [ ] charBuffer = new char [ [[unemployable]] ] ; int [[angular]] = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int i = readUnsignedShort ( [[angular]] - 2 ) ; i > 0 ; -- i ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .


--------------------------------------------- Result 971 ---------------------------------------------
Inspects all constructors declared in this class . --> Ignores default ctor descriptors for this class --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] [[inspectConstructors]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[ctors]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ [[ctors]] . length ] ; for ( int i = 0 ; i < [[ctors]] . length ; i ++ ) { Constructor [[ctor]] = [[ctors]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[ctor]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] [[ignoring]] ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] [[pilgrims]] = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] allCtors = new CtorDescriptor [ [[pilgrims]] . length ] ; for ( int i = 0 ; i < [[pilgrims]] . length ; i ++ ) { Constructor [[boffin]] = [[pilgrims]] [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[boffin]] ) ; allCtors [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return allCtors ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .


--------------------------------------------- Result 972 ---------------------------------------------
Returns the ctor descriptor for the given arguments . --> [[[FAILED]]]

[[[[Adv]]]]: public CtorDescriptor [[getCtorDescriptor]] ( final Class ... [[args]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[arg]] = ctorDescriptor . getParameters ( ) ; if ( [[arg]] . length != [[args]] . length ) { continue ; } for ( int j = 0 ; j < [[arg]] . length ; j ++ ) { if ( [[arg]] [ j ] != [[args]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor [[cycles]] ( final Class ... [[numa]] ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[allude]] = ctorDescriptor . getParameters ( ) ; if ( [[allude]] . length != [[numa]] . length ) { continue ; } for ( int j = 0 ; j < [[allude]] . length ; j ++ ) { if ( [[allude]] [ j ] != [[numa]] [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .


--------------------------------------------- Result 973 ---------------------------------------------
Retrieves the transient bean from the servlet request . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[occurred]] ( final HttpServletRequest [[educational]] ) { return ( Map < String , TransientBeanData > ) [[educational]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .


[Succeeded / Failed / Skipped / Total] 640 / 313 / 21 / 974:  97%|█████████▋| 974/1000 [6:03:21<09:41, 22.38s/it][Succeeded / Failed / Skipped / Total] 640 / 313 / 21 / 974:  98%|█████████▊| 975/1000 [6:03:43<09:19, 22.38s/it][Succeeded / Failed / Skipped / Total] 641 / 313 / 21 / 975:  98%|█████████▊| 975/1000 [6:03:43<09:19, 22.38s/it]