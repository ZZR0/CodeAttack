[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
[proxychains] Strict chain  ...  127.0.0.1:1089  ...  127.0.0.1:8889  ...  huggingface.co:443  ...  OK
Some weights of the model checkpoint at microsoft/codebert-base were not used when initializing RobertaForSequenceClassification: ['pooler.dense.weight', 'pooler.dense.bias']
- This IS expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/codebert-base and are newly initialized: ['classifier.dense.weight', 'classifier.dense.bias', 'classifier.out_proj.bias', 'classifier.out_proj.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
Attempting to acquire lock 139807488813088 on /data/zzr/.cache/textattack/transformations/hownet/word_candidates_sense.pkl.lock
Lock 139807488813088 acquired on /data/zzr/.cache/textattack/transformations/hownet/word_candidates_sense.pkl.lock
Attempting to release lock 139807488813088 on /data/zzr/.cache/textattack/transformations/hownet/word_candidates_sense.pkl.lock
Lock 139807488813088 released on /data/zzr/.cache/textattack/transformations/hownet/word_candidates_sense.pkl.lock
[proxychains] DLL init: proxychains-ng 4.15
textattack: Running 4 worker(s) on 4 GPU(s).
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
[proxychains] DLL init: proxychains-ng 4.15
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 1 / 1:   0%|          | 1/2690 [00:00<00:01, 1495.83it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 2 / 2:   0%|          | 2/2690 [00:00<00:01, 1963.17it/s][Succeeded / Failed / Skipped / Total] 0 / 0 / 3 / 3:   0%|          | 3/2690 [00:00<00:01, 2336.23it/s]--------------------------------------------- Result 1 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < xen_9pdev->num_rings; i++) { char *str; int ring_order; xen_9pdev->rings[i].priv = xen_9pdev; xen_9pdev->rings[i].evtchn = -1; xen_9pdev->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) { goto out; } xen_9pdev->rings[i].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].intf) { goto out; } ring_order = xen_9pdev->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[i].ring_order = ring_order; xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].data) { goto out; } xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data; xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]); xen_9pdev->rings[i].out_cons = 0; xen_9pdev->rings[i].out_size = 0; xen_9pdev->rings[i].inprogress = False; xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn); if (xen_9pdev->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]); } xen_9pdev->security_model = xenstore_read_be_str(xendev, "security_model"); xen_9pdev->path = xenstore_read_be_str(xendev, "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 0 / 4 / 4:   0%|          | 4/2690 [00:00<00:01, 2503.31it/s]textattack: Exception encountered for input "OrderedDict([('adv', 'static int mpeg1_decode_sequence(AVCodecContext *@R_5@, UINT8 *@R_6@, int @R_7@) { Mpeg1Context *@R_0@ = @R_5@->priv_data; MpegEncContext *@R_1@ = &@R_0@->mpeg_enc_ctx; int @R_2@, height, i, v, @R_3@; float @R_4@; init_get_bits(&@R_1@->gb, @R_6@, @R_7@); @R_2@ = get_bits(&@R_1@->gb, 12); height = get_bits(&@R_1@->gb, 12); @R_1@->aspect_ratio_info= get_bits(&@R_1@->gb, 4); if(!@R_1@->mpeg2){ @R_4@= mpeg1_aspect[@R_1@->aspect_ratio_info]; if(@R_4@!=0.0) @R_5@->aspect_ratio= @R_2@/(@R_4@*height); } @R_1@->frame_rate_index = get_bits(&@R_1@->gb, 4); if (@R_1@->frame_rate_index == 0) return -1; @R_1@->bit_rate = get_bits(&@R_1@->gb, 18) * 400; if (get_bits1(&@R_1@->gb) == 0) return -1; if (@R_2@ <= 0 || height <= 0 || (@R_2@ % 2) != 0 || (height % 2) != 0) return -1; if (@R_2@ != @R_1@->width || height != @R_1@->height) { @R_1@->out_format = FMT_MPEG1; if (@R_0@->mpeg_enc_ctx_allocated) { MPV_common_end(@R_1@); } @R_1@->width = @R_2@; @R_1@->height = height; @R_5@->has_b_frames= 1; @R_1@->avctx = @R_5@; @R_5@->width = @R_2@; @R_5@->height = height; if (@R_1@->frame_rate_index >= 9) { @R_5@->frame_rate = 25 * FRAME_RATE_BASE; } else { @R_5@->frame_rate = frame_rate_tab[@R_1@->frame_rate_index]; } @R_1@->frame_rate = @R_5@->frame_rate; @R_5@->bit_rate = @R_1@->bit_rate; if (MPV_common_init(@R_1@) < 0) return -1; @R_0@->mpeg_enc_ctx_allocated = 1; } skip_bits(&@R_1@->gb, 10); skip_bits(&@R_1@->gb, 1); if (get_bits1(&@R_1@->gb)) { for(i=0;i<64;i++) { v = get_bits(&@R_1@->gb, 8); @R_3@ = @R_1@->intra_scantable.permutated[i]; @R_1@->intra_matrix[@R_3@] = v; @R_1@->chroma_intra_matrix[@R_3@] = v; } #ifdef DEBUG dprintf("intra matrix present\\n"); for(i=0;i<64;i++) dprintf(" %d", @R_1@->intra_matrix[@R_1@->intra_scantable.permutated[i]]); printf("\\n"); #endif } else { for(i=0;i<64;i++) { int @R_3@= @R_1@->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; @R_1@->intra_matrix[@R_3@] = v; @R_1@->chroma_intra_matrix[@R_3@] = v; } } if (get_bits1(&@R_1@->gb)) { for(i=0;i<64;i++) { v = get_bits(&@R_1@->gb, 8); @R_3@ = @R_1@->intra_scantable.permutated[i]; @R_1@->inter_matrix[@R_3@] = v; @R_1@->chroma_inter_matrix[@R_3@] = v; } #ifdef DEBUG dprintf("non intra matrix present\\n"); for(i=0;i<64;i++) dprintf(" %d", @R_1@->inter_matrix[@R_1@->intra_scantable.permutated[i]]); printf("\\n"); #endif } else { for(i=0;i<64;i++) { int @R_3@= @R_1@->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; @R_1@->inter_matrix[@R_3@] = v; @R_1@->chroma_inter_matrix[@R_3@] = v; } } @R_1@->progressive_sequence = 1; @R_1@->progressive_frame = 1; @R_1@->picture_structure = PICT_FRAME; @R_1@->frame_pred_frame_dct = 1; @R_1@->mpeg2 = 0; @R_5@->sub_id = 1; return 0; }')])".
textattack: Traceback (most recent call last):
  File "/data/zzr/CodeAttack/codeattack/attacker.py", line 590, in attack_from_queue
    result = attack.attack(example, ground_truth_output)
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 423, in attack
    result = self._attack(goal_function_result)
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 372, in _attack
    final_result = self.search_method(initial_result)
  File "/data/zzr/CodeAttack/codeattack/search_methods/search_method.py", line 36, in __call__
    result = self.perform_search(initial_result)
  File "/data/zzr/CodeAttack/codeattack/search_methods/particle_swarm_optimization.py", line 217, in perform_search
    population = self._initialize_population(initial_result, self.pop_size)
  File "/data/zzr/CodeAttack/codeattack/search_methods/particle_swarm_optimization.py", line 203, in _initialize_population
    best_neighbors, prob_list = self._get_best_neighbors(
  File "/data/zzr/CodeAttack/codeattack/search_methods/particle_swarm_optimization.py", line 160, in _get_best_neighbors
    transformed_texts = self.get_transformations(
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 279, in get_transformations
    transformed_texts = self._get_transformations_uncached(
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 247, in _get_transformations_uncached
    transformed_texts = self.transformation(
  File "/data/zzr/CodeAttack/codeattack/transformations/transformation.py", line 50, in __call__
    transformed_texts = self._get_transformations(current_text, indices_to_modify)
  File "/data/zzr/CodeAttack/codeattack/transformations/word_swaps/word_swap_hownet.py", line 68, in _get_transformations
    word_to_replace_pos = current_text.pos_of_word_index(i)
AttributeError: 'AttackedCode' object has no attribute 'pos_of_word_index'

[Succeeded / Failed / Skipped / Total] 0 / 0 / 4 / 4:   0%|          | 4/2690 [00:00<07:58,  5.61it/s]  
[[0 (58%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; const char *boot_device = args->boot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = False; char *filename; msi_supported = True; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { spapr->rma_size = rma_alloc_size; } else { spapr->rma_size = ram_size; if (kvm_enabled()) { spapr->vrma_adjust = 1; spapr->rma_size = MIN(spapr->rma_size, 0x10000000); } } rtas_limit = MIN(spapr->rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; spapr->htab_shift = 18; while (spapr->htab_shift <= 46) { if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) { break; } spapr->htab_shift++; } spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr->next_irq = XICS_IRQ_BASE; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; xics_cpu_setup(spapr->icp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env->msr_mask &= ~(1 << 6); if (kvm_enabled()) { kvmppc_set_papr(cpu); } qemu_register_reset(spapr_cpu_reset, cpu); } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr_events_init(spapr); spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (spapr_vga_init(phb->bus)) { spapr->has_graphics = True; } if (usb_enabled(spapr->has_graphics)) { pci_create_simple(phb->bus, -1, "pci-ohci"); if (spapr->has_graphics) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } } if (spapr->rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size > 0; } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } if (bios_name == NULL) { bios_name = FW_FILE_NAME; } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); spapr->entry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr->epow_irq); assert(spapr->fdt_skel != NULL); }
