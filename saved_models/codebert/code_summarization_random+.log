textattack: Running 7 worker(s) on 7 GPU(s).
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:01, 859.49it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:01, 845.80it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1041.46it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1074.91it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 1134.76it/s]--------------------------------------------- Result 1 ---------------------------------------------
Wrap an Observable . --> Epoxyactic sugar --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[epoxy]] ( ObservableSource < T > source ) { ObjectHelper . requireNonNull ( source , "source is null" ) ; if ( source instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) source ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( source ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Adapts a CompletableObsableObservableObservableObserve that wraps the observable . --> Adapts a ConnectableObserver to a Reaction Observable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[anthology]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 3 ---------------------------------------------
Create a new instance of this processor . --> Create a new instance of this processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[burden]] ) { return new UnicastProcessor < T > ( [[burden]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 4 ---------------------------------------------
Tries to perform a scalar transform function . --> Utility function for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[r]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } Publisher < ? extends R > [[poplin]] ; try { [[poplin]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( [[poplin]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[poplin]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "True" == "True" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "True" == "True" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[poplin]] . subscribe ( subscriber ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 5 ---------------------------------------------
Fast implementation for fast - path order . --> This method is not thread safe --> Socre: 1.0

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean [[delayError]] , Disposable disposable ) { final Observer < ? super V > [[observer]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[observer]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[observer]] , [[delayError]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void fastPathOrderedEmit ( U value , boolean [[anemone]] , Disposable disposable ) { final Observer < ? super V > [[miscarriage]] = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( [[miscarriage]] , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , [[miscarriage]] , [[anemone]] , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 1205.55it/s][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [00:00<00:00, 1279.81it/s][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [00:00<00:00, 1331.84it/s][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 9/1000 [00:00<00:00, 1379.10it/s][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 1415.03it/s][Succeeded / Failed / Skipped / Total] 10 / 0 / 1 / 11:   1%|          | 11/1000 [00:00<00:00, 1474.84it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 1 / 12:   1%|          | 12/1000 [00:00<00:00, 1505.31it/s][Succeeded / Failed / Skipped / Total] 12 / 0 / 1 / 13:   1%|▏         | 13/1000 [00:00<00:00, 1506.78it/s]Exports a scalar value from a scalar value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > scalarXMap ( final T [[scamper]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[scamper]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 7 ---------------------------------------------
Construct a Maybe from a single value . --> As figurative from single source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[figurative]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 8 ---------------------------------------------
Reset all settings --> Obtain non - null settings --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[obeah]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "False" != "False" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 9 ---------------------------------------------
Returns an observable sorted by the specified comparator . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[diabetic]] ( Comparator < ? super T > [[stirrup]] ) { ObjectHelper . requireNonNull ( [[stirrup]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[stirrup]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 10 ---------------------------------------------
Retries the given number of times after the given number of times . --> Performs a telecast operation on this stream --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[telecast]] ( long times , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( times , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 11 ---------------------------------------------
Wrapper for Functions --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < T , U > Function < T , U > justFunction ( U value ) { return new JustValue < T , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 12 ---------------------------------------------
Construct a Maybe from a Completable . --> Json from Completable --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[jennie]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 13 ---------------------------------------------
Wraps the given value . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[monty]] ) { return new JustValue < Object , T > ( [[monty]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
[Succeeded / Failed / Skipped / Total] 13 / 0 / 1 / 14:   1%|▏         | 14/1000 [00:00<00:00, 1523.42it/s][Succeeded / Failed / Skipped / Total] 13 / 0 / 1 / 14:   2%|▏         | 15/1000 [01:33<1:42:13,  6.23s/it][Succeeded / Failed / Skipped / Total] 13 / 1 / 1 / 15:   2%|▏         | 15/1000 [01:33<1:42:14,  6.23s/it][Succeeded / Failed / Skipped / Total] 13 / 1 / 1 / 15:   2%|▏         | 16/1000 [02:11<2:14:20,  8.19s/it][Succeeded / Failed / Skipped / Total] 14 / 1 / 1 / 16:   2%|▏         | 16/1000 [02:11<2:14:20,  8.19s/it][Succeeded / Failed / Skipped / Total] 14 / 1 / 1 / 16:   2%|▏         | 17/1000 [04:34<4:24:48, 16.16s/it][Succeeded / Failed / Skipped / Total] 15 / 1 / 1 / 17:   2%|▏         | 17/1000 [04:34<4:24:48, 16.16s/it][Succeeded / Failed / Skipped / Total] 15 / 1 / 1 / 17:   2%|▏         | 18/1000 [04:38<4:12:47, 15.45s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 1 / 18:   2%|▏         | 18/1000 [04:38<4:12:47, 15.45s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 1 / 18:   2%|▏         | 19/1000 [04:39<4:00:37, 14.72s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 1 / 19:   2%|▏         | 19/1000 [04:39<4:00:37, 14.72s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 1 / 19:   2%|▏         | 20/1000 [04:50<3:56:54, 14.50s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 1 / 20:   2%|▏         | 20/1000 [04:50<3:56:54, 14.50s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 1 / 20:   2%|▏         | 21/1000 [04:59<3:52:25, 14.24s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 1 / 21:   2%|▏         | 21/1000 [04:59<3:52:25, 14.24s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 1 / 21:   2%|▏         | 22/1000 [05:14<3:53:19, 14.31s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 1 / 22:   2%|▏         | 22/1000 [05:14<3:53:19, 14.31s/it][Succeeded / Failed / Skipped / Total] 20 / 1 / 1 / 22:   2%|▏         | 23/1000 [05:18<3:45:27, 13.85s/it][Succeeded / Failed / Skipped / Total] 20 / 2 / 1 / 23:   2%|▏         | 23/1000 [05:18<3:45:27, 13.85s/it][Succeeded / Failed / Skipped / Total] 20 / 2 / 1 / 23:   2%|▏         | 24/1000 [05:51<3:58:33, 14.67s/it]--------------------------------------------- Result 14 ---------------------------------------------
Create a new unicast subject with the specified capacity . --> Create a new unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[nought]] ( int capacityHint ) { return new UnicastSubject < T > ( capacityHint , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 15 ---------------------------------------------
Ensures that the specified object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] requireNonNull ( [[T]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < [[stressing]] > [[stressing]] requireNonNull ( [[stressing]] object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 16 ---------------------------------------------
Returns an identity function . --> simplication functions --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[medicine]] > Function < [[medicine]] , [[medicine]] > [[eliott]] ( ) { return ( Function < [[medicine]] , [[medicine]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 17 ---------------------------------------------
Create a new instance . --> Create a durable subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[dwelled]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 18 ---------------------------------------------
Cast function . --> Static factory method for casting --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Function < T , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < T , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < T , U > Function < T , U > [[pothole]] ( Class < U > [[raza]] ) { return new CastToClass < T , U > ( [[raza]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 19 ---------------------------------------------
Create a new unicast subject . --> Liefert ein subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[lassiter]] ( boolean [[drivel]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[drivel]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 20 ---------------------------------------------
Request a synchronous request . --> Responsible for posting --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[blasphemed]] ( Subscription s , int prefetch ) { s . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 21 ---------------------------------------------
Create a new instance with the specified capacity . --> Methode permettant de la chons --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[achilles]] ( int capacityHint , Runnable onTerminate ) { return new UnicastSubject < T > ( capacityHint , onTerminate , "[[Settee]]" == "[[Settee]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 22 ---------------------------------------------
Called when the queue is complete . --> Called when instrumented is complete --> Socre: 1.0

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[state]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[state]] . get ( ) , actual , queue , [[state]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[state]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void postComplete ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong [[musical]] , BooleanSupplier isCancelled ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( [[musical]] . get ( ) , actual , queue , [[musical]] , isCancelled ) ) { return ; } for ( ; ; ) { long r = [[musical]] . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 23 ---------------------------------------------
Wait for the task . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[honore]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
[Succeeded / Failed / Skipped / Total] 20 / 3 / 1 / 24:   2%|▏         | 24/1000 [05:51<3:58:33, 14.67s/it][Succeeded / Failed / Skipped / Total] 20 / 3 / 1 / 24:   2%|▎         | 25/1000 [05:52<3:48:55, 14.09s/it][Succeeded / Failed / Skipped / Total] 20 / 3 / 2 / 25:   2%|▎         | 25/1000 [05:52<3:48:55, 14.09s/it][Succeeded / Failed / Skipped / Total] 20 / 3 / 2 / 25:   3%|▎         | 26/1000 [06:07<3:49:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 21 / 3 / 2 / 26:   3%|▎         | 26/1000 [06:07<3:49:31, 14.14s/it][Succeeded / Failed / Skipped / Total] 21 / 3 / 2 / 26:   3%|▎         | 27/1000 [06:19<3:47:46, 14.05s/it][Succeeded / Failed / Skipped / Total] 22 / 3 / 2 / 27:   3%|▎         | 27/1000 [06:19<3:47:46, 14.05s/it][Succeeded / Failed / Skipped / Total] 22 / 3 / 2 / 27:   3%|▎         | 28/1000 [06:20<3:40:00, 13.58s/it][Succeeded / Failed / Skipped / Total] 23 / 3 / 2 / 28:   3%|▎         | 28/1000 [06:20<3:40:00, 13.58s/it][Succeeded / Failed / Skipped / Total] 24 / 3 / 2 / 29:   3%|▎         | 29/1000 [06:20<3:32:12, 13.11s/it][Succeeded / Failed / Skipped / Total] 24 / 3 / 2 / 29:   3%|▎         | 30/1000 [06:35<3:33:07, 13.18s/it][Succeeded / Failed / Skipped / Total] 25 / 3 / 2 / 30:   3%|▎         | 30/1000 [06:35<3:33:07, 13.18s/it][Succeeded / Failed / Skipped / Total] 25 / 3 / 2 / 30:   3%|▎         | 31/1000 [06:38<3:27:25, 12.84s/it]--------------------------------------------- Result 24 ---------------------------------------------
Create a new instance of this processor . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[demolish]] ( int capacityHint , Runnable onCancelled ) { ObjectHelper . requireNonNull ( onCancelled , "onTerminate" ) ; return new UnicastProcessor < T > ( capacityHint , onCancelled ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 25 ---------------------------------------------
Determines whether two streams are disjoint --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 26 ---------------------------------------------
Get an error from the queue . --> get a waiting thread --> Socre: 1.0

[[[[Adv]]]]: public Throwable blockingGetError ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable blockingGetError ( long [[rodrick]] , TimeUnit [[deux]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[rodrick]] , [[deux]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[rodrick]] , [[deux]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
Validate two Subscription objects --> Validate two subclasses --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . cancel ( ) ; if ( upstream != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[Agrippa]]" == "[[Agrippa]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 28 ---------------------------------------------
Waits for errors to be executed . --> Await for errors --> Socre: 1.0

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean blockingAwait ( long timeout , TimeUnit unit ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , unit ) ) { dispose ( ) ; return "[[Philosophize]]" != "[[Philosophize]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Resumé]]" == "[[Resumé]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 29 ---------------------------------------------
Atomically updates the AtomicReference with another AtomicReference . --> this method is called only once every 10 seconds --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[next]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[next]] ) ) { [[next]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Disposable > upstream , Disposable [[lisboa]] , Class < ? > observer ) { ObjectHelper . requireNonNull ( [[lisboa]] , "next is null" ) ; if ( ! upstream . compareAndSet ( null , [[lisboa]] ) ) { [[lisboa]] . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 30 ---------------------------------------------
Adds a cap . --> add a cap --> Socre: 1.0

[[[[Adv]]]]: public static long addCap ( long [[a]] , long b ) { long u = [[a]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long addCap ( long [[dealio]] , long b ) { long u = [[dealio]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
[Succeeded / Failed / Skipped / Total] 26 / 3 / 2 / 31:   3%|▎         | 31/1000 [06:38<3:27:25, 12.84s/it][Succeeded / Failed / Skipped / Total] 26 / 3 / 2 / 31:   3%|▎         | 32/1000 [06:58<3:31:08, 13.09s/it][Succeeded / Failed / Skipped / Total] 27 / 3 / 2 / 32:   3%|▎         | 32/1000 [06:58<3:31:08, 13.09s/it][Succeeded / Failed / Skipped / Total] 27 / 3 / 2 / 32:   3%|▎         | 33/1000 [06:59<3:24:51, 12.71s/it][Succeeded / Failed / Skipped / Total] 28 / 3 / 2 / 33:   3%|▎         | 33/1000 [06:59<3:24:51, 12.71s/it][Succeeded / Failed / Skipped / Total] 28 / 3 / 2 / 33:   3%|▎         | 34/1000 [07:06<3:21:58, 12.55s/it][Succeeded / Failed / Skipped / Total] 29 / 3 / 2 / 34:   3%|▎         | 34/1000 [07:06<3:21:58, 12.55s/it][Succeeded / Failed / Skipped / Total] 29 / 3 / 2 / 34:   4%|▎         | 35/1000 [07:08<3:16:52, 12.24s/it][Succeeded / Failed / Skipped / Total] 30 / 3 / 2 / 35:   4%|▎         | 35/1000 [07:08<3:16:52, 12.24s/it][Succeeded / Failed / Skipped / Total] 30 / 3 / 2 / 35:   4%|▎         | 36/1000 [07:20<3:16:38, 12.24s/it][Succeeded / Failed / Skipped / Total] 31 / 3 / 2 / 36:   4%|▎         | 36/1000 [07:20<3:16:38, 12.24s/it][Succeeded / Failed / Skipped / Total] 31 / 3 / 2 / 36:   4%|▎         | 37/1000 [07:35<3:17:45, 12.32s/it][Succeeded / Failed / Skipped / Total] 32 / 3 / 2 / 37:   4%|▎         | 37/1000 [07:35<3:17:45, 12.32s/it][Succeeded / Failed / Skipped / Total] 32 / 3 / 2 / 37:   4%|▍         | 38/1000 [07:56<3:20:59, 12.54s/it][Succeeded / Failed / Skipped / Total] 33 / 3 / 2 / 38:   4%|▍         | 38/1000 [07:56<3:20:59, 12.54s/it][Succeeded / Failed / Skipped / Total] 33 / 3 / 2 / 38:   4%|▍         | 39/1000 [08:54<3:39:28, 13.70s/it][Succeeded / Failed / Skipped / Total] 34 / 3 / 2 / 39:   4%|▍         | 39/1000 [08:54<3:39:28, 13.70s/it][Succeeded / Failed / Skipped / Total] 34 / 3 / 2 / 39:   4%|▍         | 40/1000 [10:03<4:01:24, 15.09s/it]--------------------------------------------- Result 31 ---------------------------------------------
Returns the capacity of a long . --> calculate cap cap --> Socre: 1.0

[[[[Adv]]]]: public static long multiplyCap ( long a , long [[b]] ) { long u = a * [[b]] ; if ( ( ( a | [[b]] ) >>> 31 ) != 0 ) { if ( u / a != [[b]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long multiplyCap ( long a , long [[maricón]] ) { long u = a * [[maricón]] ; if ( ( ( a | [[maricón]] ) >>> 31 ) != 0 ) { if ( u / a != [[maricón]] ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 32 ---------------------------------------------
Get the value associated with this notification . --> Methode --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[monceau]] ( ) { Object [[tastier]] = value ; if ( [[tastier]] != null && ! NotificationLite . isError ( [[tastier]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 33 ---------------------------------------------
Atomically updates the AtomicReference with the given AtomicReference . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "False" != "False" ; } return "[[Kunti]]" == "[[Kunti]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 34 ---------------------------------------------
Add an object to the list --> Encode an object as an object --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[ashen]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 35 ---------------------------------------------
Shuts down the thread pool . --> shutdown resources --> Socre: 1.0

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void shutdown ( ) { ScheduledExecutorService [[scientology]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[scientology]] != null ) { [[scientology]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 36 ---------------------------------------------
Gets the error notification . --> on failure --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[honked]] ( ) { Object [[detain]] = value ; if ( NotificationLite . isError ( [[detain]] ) ) { return NotificationLite . getError ( [[detain]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 37 ---------------------------------------------
Converts a Throwable to a NullPointerException --> Helper method for null pointer exceptions --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[hatchery]] ( Throwable ex ) { NullPointerException npe = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; npe . initCause ( ex ) ; return npe ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 38 ---------------------------------------------
Wraps the given Throwable to a RuntimeException . --> wraps unchecked exceptions --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException wrapOrThrow ( Throwable [[scientology]] ) { if ( [[scientology]] instanceof Error ) { throw ( Error ) [[scientology]] ; } if ( [[scientology]] instanceof RuntimeException ) { return ( RuntimeException ) [[scientology]] ; } return new RuntimeException ( [[scientology]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 39 ---------------------------------------------
Emit the loop . --> from interface --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[accordionist]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[almighty]] ; synchronized ( this ) { [[almighty]] = queue ; if ( [[almighty]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[almighty]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 40 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 35 / 3 / 2 / 40:   4%|▍         | 40/1000 [10:03<4:01:24, 15.09s/it][Succeeded / Failed / Skipped / Total] 35 / 3 / 2 / 40:   4%|▍         | 41/1000 [10:18<4:01:17, 15.10s/it][Succeeded / Failed / Skipped / Total] 36 / 3 / 2 / 41:   4%|▍         | 41/1000 [10:18<4:01:17, 15.10s/it][Succeeded / Failed / Skipped / Total] 36 / 3 / 2 / 41:   4%|▍         | 42/1000 [10:23<3:57:01, 14.85s/it][Succeeded / Failed / Skipped / Total] 37 / 3 / 2 / 42:   4%|▍         | 42/1000 [10:23<3:57:01, 14.85s/it][Succeeded / Failed / Skipped / Total] 37 / 3 / 2 / 42:   4%|▍         | 43/1000 [10:33<3:55:00, 14.73s/it][Succeeded / Failed / Skipped / Total] 38 / 3 / 2 / 43:   4%|▍         | 43/1000 [10:33<3:55:00, 14.73s/it][Succeeded / Failed / Skipped / Total] 38 / 3 / 2 / 43:   4%|▍         | 44/1000 [11:14<4:04:08, 15.32s/it][Succeeded / Failed / Skipped / Total] 39 / 3 / 2 / 44:   4%|▍         | 44/1000 [11:14<4:04:08, 15.32s/it][Succeeded / Failed / Skipped / Total] 39 / 3 / 2 / 44:   4%|▍         | 45/1000 [13:17<4:42:07, 17.72s/it]Wraps the given exception if it is an exception . --> Tries to throw an Exception if it is an Exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[griefs]] extends Throwable > Exception throwIfThrowable ( Throwable e ) throws [[griefs]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[griefs]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 41 ---------------------------------------------
Removes all resources . --> Clear resources --> Socre: 1.0

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[friendless]] ; synchronized ( this ) { if ( disposed ) { return ; } [[friendless]] = resources ; resources = null ; } dispose ( [[friendless]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 42 ---------------------------------------------
Sets the subscription for the next request . --> Set the current logistic --> Socre: 1.0

[[[[Adv]]]]: public final void setSubscription ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void setSubscription ( Subscription [[logistic]] ) { if ( cancelled ) { [[logistic]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[logistic]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[logistic]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[logistic]] . request ( r ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[logistic]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 43 ---------------------------------------------
Completes the current value . --> zEnd --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[r]] = get ( ) ; if ( ( [[r]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[r]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[zena]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long [[guys]] = get ( ) ; if ( ( [[guys]] & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( [[guys]] & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 44 ---------------------------------------------
Tries to apply a scalar function to the given observable . --> Utility function for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[r]] . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > mapper ) { if ( source instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > [[circuit]] ; try { [[circuit]] = ObjectHelper . requireNonNull ( mapper . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[circuit]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[circuit]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { [[circuit]] . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 45 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 40 / 3 / 2 / 45:   4%|▍         | 45/1000 [13:17<4:42:07, 17.72s/it][Succeeded / Failed / Skipped / Total] 40 / 3 / 2 / 45:   5%|▍         | 46/1000 [13:27<4:39:10, 17.56s/it][Succeeded / Failed / Skipped / Total] 41 / 3 / 2 / 46:   5%|▍         | 46/1000 [13:27<4:39:10, 17.56s/it][Succeeded / Failed / Skipped / Total] 41 / 3 / 2 / 46:   5%|▍         | 47/1000 [13:36<4:35:58, 17.38s/it][Succeeded / Failed / Skipped / Total] 42 / 3 / 2 / 47:   5%|▍         | 47/1000 [13:36<4:35:58, 17.38s/it][Succeeded / Failed / Skipped / Total] 42 / 3 / 2 / 47:   5%|▍         | 48/1000 [13:45<4:32:57, 17.20s/it][Succeeded / Failed / Skipped / Total] 43 / 3 / 2 / 48:   5%|▍         | 48/1000 [13:45<4:32:57, 17.20s/it][Succeeded / Failed / Skipped / Total] 43 / 3 / 2 / 48:   5%|▍         | 49/1000 [14:46<4:46:49, 18.10s/it][Succeeded / Failed / Skipped / Total] 44 / 3 / 2 / 49:   5%|▍         | 49/1000 [14:46<4:46:49, 18.10s/it][Succeeded / Failed / Skipped / Total] 44 / 3 / 2 / 49:   5%|▌         | 50/1000 [15:08<4:47:45, 18.17s/it][Succeeded / Failed / Skipped / Total] 45 / 3 / 2 / 50:   5%|▌         | 50/1000 [15:08<4:47:45, 18.17s/it][Succeeded / Failed / Skipped / Total] 45 / 3 / 2 / 50:   5%|▌         | 51/1000 [17:02<5:17:07, 20.05s/it][Succeeded / Failed / Skipped / Total] 46 / 3 / 2 / 51:   5%|▌         | 51/1000 [17:02<5:17:07, 20.05s/it][Succeeded / Failed / Skipped / Total] 46 / 3 / 2 / 51:   5%|▌         | 52/1000 [19:31<5:55:53, 22.53s/it][Succeeded / Failed / Skipped / Total] 47 / 3 / 2 / 52:   5%|▌         | 52/1000 [19:31<5:55:53, 22.53s/it][Succeeded / Failed / Skipped / Total] 47 / 3 / 2 / 52:   5%|▌         | 53/1000 [21:26<6:23:15, 24.28s/it]Flattens the given exception into a flattened list . --> and all exceptions --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[i]] = exceptions . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { deque . offerFirst ( exceptions . get ( [[i]] ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[anda]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > deque = new ArrayDeque < Throwable > ( ) ; deque . offer ( t ) ; while ( ! deque . isEmpty ( ) ) { Throwable e = deque . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException ce = ( CompositeException ) e ; List < Throwable > exceptions = ce . getExceptions ( ) ; for ( int [[aspire]] = exceptions . size ( ) - 1 ; [[aspire]] >= 0 ; [[aspire]] -- ) { deque . offerFirst ( exceptions . get ( [[aspire]] ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 46 ---------------------------------------------
Returns the number of available resources . --> Determines how much is disposed --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[extradite]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[subcontinent]] = resources ; return [[subcontinent]] != null ? [[subcontinent]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 47 ---------------------------------------------
Start the stream --> Starts draba --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[draba]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 48 ---------------------------------------------
Start the queue . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[counterfeiter]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 49 ---------------------------------------------
Accept a subscriber . --> Accept a notification --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[subscriber]] ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[congregation]] ) { Object [ ] [[priestly]] = head ; final int c = capacity ; while ( [[priestly]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[priestly]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[congregation]] ) ) { return "True" == "True" ; } } [[priestly]] = ( Object [ ] ) [[priestly]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 50 ---------------------------------------------
Returns the Disposition object . --> getDisposable --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable get ( ) { Disposable [[timberline]] = resource . get ( ) ; if ( [[timberline]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[timberline]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 51 ---------------------------------------------
Performs a scalar operation on a scalar value . --> simplified implementation --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > scalarXMap ( T [[dung]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[quicker]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[dung]] , [[quicker]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 52 ---------------------------------------------
Atomically adds n to the specified long . --> add protection --> Socre: 1.0

[[[[Adv]]]]: public static long add ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[u]] = addCap ( r , [[n]] ) ; if ( [[requested]] . compareAndSet ( r , [[u]] ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long add ( AtomicLong [[elizabethan]] , long [[prevention]] ) { for ( ; ; ) { long r = [[elizabethan]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[herzegovina]] = addCap ( r , [[prevention]] ) ; if ( [[elizabethan]] . compareAndSet ( r , [[herzegovina]] ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
[Succeeded / Failed / Skipped / Total] 48 / 3 / 2 / 53:   5%|▌         | 53/1000 [21:26<6:23:15, 24.28s/it][Succeeded / Failed / Skipped / Total] 48 / 3 / 2 / 53:   5%|▌         | 54/1000 [22:06<6:27:25, 24.57s/it][Succeeded / Failed / Skipped / Total] 48 / 4 / 2 / 54:   5%|▌         | 54/1000 [22:06<6:27:25, 24.57s/it][Succeeded / Failed / Skipped / Total] 48 / 4 / 2 / 54:   6%|▌         | 55/1000 [22:33<6:27:29, 24.60s/it][Succeeded / Failed / Skipped / Total] 49 / 4 / 2 / 55:   6%|▌         | 55/1000 [22:33<6:27:29, 24.60s/it][Succeeded / Failed / Skipped / Total] 49 / 4 / 2 / 55:   6%|▌         | 56/1000 [22:48<6:24:23, 24.43s/it][Succeeded / Failed / Skipped / Total] 50 / 4 / 2 / 56:   6%|▌         | 56/1000 [22:48<6:24:23, 24.43s/it][Succeeded / Failed / Skipped / Total] 50 / 4 / 2 / 56:   6%|▌         | 57/1000 [23:08<6:22:52, 24.36s/it][Succeeded / Failed / Skipped / Total] 51 / 4 / 2 / 57:   6%|▌         | 57/1000 [23:08<6:22:52, 24.36s/it][Succeeded / Failed / Skipped / Total] 51 / 4 / 2 / 57:   6%|▌         | 58/1000 [23:45<6:25:57, 24.58s/it][Succeeded / Failed / Skipped / Total] 52 / 4 / 2 / 58:   6%|▌         | 58/1000 [23:45<6:25:57, 24.58s/it][Succeeded / Failed / Skipped / Total] 52 / 4 / 2 / 58:   6%|▌         | 59/1000 [23:58<6:22:26, 24.38s/it][Succeeded / Failed / Skipped / Total] 53 / 4 / 2 / 59:   6%|▌         | 59/1000 [23:58<6:22:26, 24.38s/it][Succeeded / Failed / Skipped / Total] 53 / 4 / 2 / 59:   6%|▌         | 60/1000 [29:12<7:37:32, 29.20s/it]--------------------------------------------- Result 53 ---------------------------------------------
Creates a scheduled executor service . --> Determines how much thread should be done --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[howe]] ( ThreadFactory [[impressionistic]] ) { final ScheduledExecutorService [[smoother]] = Executors . newScheduledThreadPool ( 1 , [[impressionistic]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[smoother]] ) ; return [[smoother]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 54 ---------------------------------------------
Removes the maximum number of items from the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void drainMaxLoop ( SimplePlainQueue < T > q , Subscriber < ? super U > a , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , a , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( a , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = qd . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 55 ---------------------------------------------
Completes the stream . --> Synchronously --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[value]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[jenni]] ( T [[automobiles]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > a = downstream ; if ( state == FUSED_EMPTY ) { this . value = [[automobiles]] ; lazySet ( FUSED_READY ) ; a . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; a . onNext ( [[automobiles]] ) ; } if ( get ( ) != DISPOSED ) { a . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Concatenate a Mono and return a Flowable that maps the result to a Mono . --> Convenience method for producing an etheran --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[ethan]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[ethan]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 57 ---------------------------------------------
Offer an object to this queue . --> Offers a negative number --> Socre: 1.0

[[[[Adv]]]]: public boolean offer ( T [[t]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[t]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[t]] ) ) { drain ( ) ; return "[[True]]" == "[[True]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean offer ( T [[negatives]] ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( [[negatives]] , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( [[negatives]] ) ) { drain ( ) ; return "[[Halley]]" == "[[Halley]]" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 58 ---------------------------------------------
Waits for the consumer to consume . --> Await consumer --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer await ( int [[bertolucci]] ) { if ( [[bertolucci]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { await ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 59 ---------------------------------------------
Request n . --> Convenience method to perform a blocking operation --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[upstream]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[liqueur]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
[Succeeded / Failed / Skipped / Total] 54 / 4 / 2 / 60:   6%|▌         | 60/1000 [29:12<7:37:32, 29.20s/it][Succeeded / Failed / Skipped / Total] 54 / 4 / 2 / 60:   6%|▌         | 61/1000 [29:29<7:34:00, 29.01s/it][Succeeded / Failed / Skipped / Total] 55 / 4 / 2 / 61:   6%|▌         | 61/1000 [29:29<7:34:00, 29.01s/it][Succeeded / Failed / Skipped / Total] 55 / 4 / 2 / 61:   6%|▌         | 62/1000 [30:36<7:43:08, 29.63s/it][Succeeded / Failed / Skipped / Total] 56 / 4 / 2 / 62:   6%|▌         | 62/1000 [30:36<7:43:08, 29.63s/it][Succeeded / Failed / Skipped / Total] 56 / 4 / 2 / 62:   6%|▋         | 63/1000 [32:04<7:56:59, 30.54s/it][Succeeded / Failed / Skipped / Total] 57 / 4 / 2 / 63:   6%|▋         | 63/1000 [32:04<7:56:59, 30.54s/it][Succeeded / Failed / Skipped / Total] 57 / 4 / 2 / 63:   6%|▋         | 64/1000 [34:20<8:22:17, 32.20s/it][Succeeded / Failed / Skipped / Total] 58 / 4 / 2 / 64:   6%|▋         | 64/1000 [34:20<8:22:17, 32.20s/it][Succeeded / Failed / Skipped / Total] 58 / 4 / 2 / 64:   6%|▋         | 65/1000 [37:54<9:05:21, 35.00s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 2 / 65:   6%|▋         | 65/1000 [37:54<9:05:21, 35.00s/it][Succeeded / Failed / Skipped / Total] 59 / 4 / 2 / 65:   7%|▋         | 66/1000 [38:33<9:05:35, 35.05s/it]--------------------------------------------- Result 60 ---------------------------------------------
Completes the task . --> Go to cartoucheme --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[cartouche]] ( ) { int [[betsey]] = get ( ) ; if ( ( [[betsey]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 61 ---------------------------------------------
Concatenate two elements into a Flowable . --> Concatenates two tuples into one or more elements --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return concatMapIterable ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > concatMapIterable ( Function < ? super T , ? extends Iterable < ? extends U > > [[goliad]] ) { return concatMapIterable ( [[goliad]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 62 ---------------------------------------------
Observes a flowable flowable on the supplied scheduler . --> Adapts a Flowable Flowable to a Flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[flowable]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[flowable]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > observeOn ( final ConnectableFlowable < T > cf , final Scheduler scheduler ) { final Flowable < T > [[blessed]] = cf . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , [[blessed]] ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 63 ---------------------------------------------
Performs a reverse order of the elements in the stream . --> Convert debts to cartesian type --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[cartographer]] ( Comparator < ? super T > [[debts]] ) { ObjectHelper . requireNonNull ( [[debts]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[debts]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Sends an error event . --> Handles a given cartoucheme --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[ching]] ( Throwable [[cartouche]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[cartouche]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[cartouche]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 65 ---------------------------------------------
Remove a subscriber from the list --> Remove a spoiler --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int [[j]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[ps]] ) { [[j]] = i ; break ; } } if ( [[j]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[j]] ) ; System . arraycopy ( a , [[j]] + 1 , b , [[j]] , n - [[j]] - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void remove ( PublishDisposable < T > [[scarier]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED || a == EMPTY ) { return ; } int n = a . length ; int [[overlooking]] = - 1 ; for ( int i = 0 ; i < n ; i ++ ) { if ( a [ i ] == [[scarier]] ) { [[overlooking]] = i ; break ; } } if ( [[overlooking]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( n == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ n - 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[overlooking]] ) ; System . arraycopy ( a , [[overlooking]] + 1 , b , [[overlooking]] , n - [[overlooking]] - 1 ) ; } if ( subscribers . compareAndSet ( a , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 66 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 60 / 4 / 2 / 66:   7%|▋         | 66/1000 [38:33<9:05:35, 35.05s/it][Succeeded / Failed / Skipped / Total] 60 / 4 / 2 / 66:   7%|▋         | 67/1000 [41:24<9:36:43, 37.09s/it][Succeeded / Failed / Skipped / Total] 61 / 4 / 2 / 67:   7%|▋         | 67/1000 [41:24<9:36:43, 37.09s/it][Succeeded / Failed / Skipped / Total] 61 / 4 / 2 / 67:   7%|▋         | 68/1000 [42:25<9:41:26, 37.43s/it][Succeeded / Failed / Skipped / Total] 62 / 4 / 2 / 68:   7%|▋         | 68/1000 [42:25<9:41:26, 37.43s/it][Succeeded / Failed / Skipped / Total] 62 / 4 / 2 / 68:   7%|▋         | 69/1000 [42:26<9:32:38, 36.90s/it][Succeeded / Failed / Skipped / Total] 63 / 4 / 2 / 69:   7%|▋         | 69/1000 [42:26<9:32:38, 36.91s/it][Succeeded / Failed / Skipped / Total] 63 / 4 / 2 / 69:   7%|▋         | 70/1000 [42:43<9:27:33, 36.62s/it][Succeeded / Failed / Skipped / Total] 64 / 4 / 2 / 70:   7%|▋         | 70/1000 [42:43<9:27:33, 36.62s/it][Succeeded / Failed / Skipped / Total] 64 / 4 / 2 / 70:   7%|▋         | 71/1000 [43:37<9:30:53, 36.87s/it][Succeeded / Failed / Skipped / Total] 65 / 4 / 2 / 71:   7%|▋         | 71/1000 [43:37<9:30:53, 36.87s/it][Succeeded / Failed / Skipped / Total] 65 / 4 / 2 / 71:   7%|▋         | 72/1000 [47:09<10:07:47, 39.30s/it][Succeeded / Failed / Skipped / Total] 66 / 4 / 2 / 72:   7%|▋         | 72/1000 [47:09<10:07:47, 39.30s/it][Succeeded / Failed / Skipped / Total] 66 / 4 / 2 / 72:   7%|▋         | 73/1000 [49:00<10:22:22, 40.28s/it]Create sample data . --> Perform Linginging --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[lansing]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication auth = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 67 ---------------------------------------------
Adds a subscriber to the queue . --> can be batched --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED ) { return "False" != "False" ; } int n = [[a]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[b]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[a]] , 0 , [[b]] , 0 , n ) ; [[b]] [ n ] = ps ; if ( subscribers . compareAndSet ( [[a]] , [[b]] ) ) { return "[[True]]" == "[[True]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[batya]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[superman]] = subscribers . get ( ) ; if ( [[superman]] == TERMINATED ) { return "False" != "False" ; } int n = [[superman]] . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] [[eaton]] = new PublishDisposable [ n + 1 ] ; System . arraycopy ( [[superman]] , 0 , [[eaton]] , 0 , n ) ; [[eaton]] [ n ] = ps ; if ( subscribers . compareAndSet ( [[superman]] , [[eaton]] ) ) { return "[[Trattoria]]" == "[[Trattoria]]" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 68 ---------------------------------------------
Searches for a user for the specified username . --> For testing purposes only . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations [[searchForUser]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations [[blowin]] ( String username ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + username + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { username } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + username + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 69 ---------------------------------------------
Accepts a notification . --> return true false otherwise false --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[o]] = [[a]] [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , observer ) ) { return "True" == "True" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > observer ) { Object [ ] [[warden]] = head ; final int c = capacity ; while ( [[warden]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object [[timberlake]] = [[warden]] [ i ] ; if ( [[timberlake]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[timberlake]] , observer ) ) { return "True" == "True" ; } } [[warden]] = ( Object [ ] ) [[warden]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 70 ---------------------------------------------
Create error response . --> Bert run method --> Socre: 1.0

[[[[Adv]]]]: public Response < ? > [[createErrorResponse]] ( ) { Response < ? > [[call]] ; try { [[call]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[call]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[call]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[call]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > [[bertram]] ( ) { Response < ? > [[drug]] ; try { [[drug]] = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( [[drug]] == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( [[drug]] . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return [[drug]] ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 71 ---------------------------------------------
Perform version checks . --> Completes the given minSpringVersion --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[coincides]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 72 ---------------------------------------------
Returns the object of the given method . --> Convert likes to bar --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[barak]] ( String [[likes]] ) { try { return HttpMethod . valueOf ( [[likes]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
[Succeeded / Failed / Skipped / Total] 67 / 4 / 2 / 73:   7%|▋         | 73/1000 [49:00<10:22:22, 40.28s/it][Succeeded / Failed / Skipped / Total] 67 / 4 / 2 / 73:   7%|▋         | 74/1000 [49:37<10:21:01, 40.24s/it][Succeeded / Failed / Skipped / Total] 68 / 4 / 2 / 74:   7%|▋         | 74/1000 [49:37<10:21:01, 40.24s/it][Succeeded / Failed / Skipped / Total] 68 / 4 / 2 / 74:   8%|▊         | 75/1000 [50:28<10:22:28, 40.38s/it][Succeeded / Failed / Skipped / Total] 69 / 4 / 2 / 75:   8%|▊         | 75/1000 [50:28<10:22:28, 40.38s/it][Succeeded / Failed / Skipped / Total] 69 / 4 / 2 / 75:   8%|▊         | 76/1000 [50:32<10:14:28, 39.90s/it][Succeeded / Failed / Skipped / Total] 70 / 4 / 2 / 76:   8%|▊         | 76/1000 [50:32<10:14:28, 39.90s/it][Succeeded / Failed / Skipped / Total] 70 / 4 / 2 / 76:   8%|▊         | 77/1000 [55:33<11:05:54, 43.29s/it][Succeeded / Failed / Skipped / Total] 71 / 4 / 2 / 77:   8%|▊         | 77/1000 [55:33<11:05:54, 43.29s/it][Succeeded / Failed / Skipped / Total] 71 / 4 / 2 / 77:   8%|▊         | 78/1000 [56:34<11:08:45, 43.52s/it][Succeeded / Failed / Skipped / Total] 72 / 4 / 2 / 78:   8%|▊         | 78/1000 [56:34<11:08:45, 43.52s/it][Succeeded / Failed / Skipped / Total] 72 / 4 / 2 / 78:   8%|▊         | 79/1000 [58:54<11:26:49, 44.74s/it][Succeeded / Failed / Skipped / Total] 73 / 4 / 2 / 79:   8%|▊         | 79/1000 [58:54<11:26:49, 44.74s/it][Succeeded / Failed / Skipped / Total] 73 / 4 / 2 / 79:   8%|▊         | 80/1000 [59:53<11:28:50, 44.92s/it]--------------------------------------------- Result 73 ---------------------------------------------
Parses the HTTP method annotations . --> Parses annotation methods --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit [[retrofit]] , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[False]]" != "[[False]]" ; boolean continuationBodyNullable = "[[False]]" != "[[False]]" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > parseAnnotations ( Retrofit [[repulsive]] , Method method , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[Katrine]]" != "[[Katrine]]" ; boolean continuationBodyNullable = "[[Katrine]]" != "[[Katrine]]" ; Annotation [ ] annotations = method . getAnnotations ( ) ; Type adapterType ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = method . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 74 ---------------------------------------------
Registers attribute exchange configurer . --> Used by AttributeExchange --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer attributeExchange ( String identifierPattern ) { AttributeExchangeConfigurer [[debts]] = new AttributeExchangeConfigurer ( identifierPattern ) ; this . attributeExchangeConfigurers . add ( [[debts]] ) ; return [[debts]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 75 ---------------------------------------------
Calculate the delay in milliseconds . --> milliseconds --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit [[unit]] ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[fearlessly]] ( TimeUnit [[abattoir]] ) { float [[labour]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 76 ---------------------------------------------
Determines whether the system should be disabled . --> Determines whether checks should be disabled --> Socre: 1.0

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "[[True]]" == "[[True]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean disableChecks ( String springVersion , String springSecurityVersion ) { if ( springVersion == null || springVersion . equals ( springSecurityVersion ) ) { return "[[Msg]]" == "[[Msg]]" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 77 ---------------------------------------------
Configure OAuth2 client . --> Performs a mining algorithm --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[quorum]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[mining]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[mining]] ) ; return [[mining]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 78 ---------------------------------------------
Returns the channel request matcher registry . --> returns the ChannelSecurityConfigurer registry --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[context]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[context]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry requiresChannel ( ) throws Exception { ApplicationContext [[blighty]] = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( [[blighty]] ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 79 ---------------------------------------------
Encodes the given raw password . --> Hannes Hannes --> Socre: 1.0

[[[[Adv]]]]: public String encode ( CharSequence [[rawPassword]] ) { String [[salt]] = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String encode ( CharSequence [[hannes]] ) { String [[alerts]] = PREFIX + this . [[falkor]] . generateKey ( ) + SUFFIX ; return digest ( [[alerts]] , [[hannes]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 80 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 74 / 4 / 2 / 80:   8%|▊         | 80/1000 [59:53<11:28:50, 44.92s/it][Succeeded / Failed / Skipped / Total] 74 / 4 / 2 / 80:   8%|▊         | 81/1000 [1:00:42<11:28:43, 44.97s/it][Succeeded / Failed / Skipped / Total] 75 / 4 / 2 / 81:   8%|▊         | 81/1000 [1:00:42<11:28:43, 44.97s/it][Succeeded / Failed / Skipped / Total] 75 / 4 / 2 / 81:   8%|▊         | 82/1000 [1:02:07<11:35:24, 45.45s/it][Succeeded / Failed / Skipped / Total] 75 / 5 / 2 / 82:   8%|▊         | 82/1000 [1:02:07<11:35:24, 45.45s/it][Succeeded / Failed / Skipped / Total] 75 / 5 / 2 / 82:   8%|▊         | 83/1000 [1:02:23<11:29:20, 45.10s/it][Succeeded / Failed / Skipped / Total] 75 / 6 / 2 / 83:   8%|▊         | 83/1000 [1:02:23<11:29:20, 45.10s/it][Succeeded / Failed / Skipped / Total] 75 / 6 / 2 / 83:   8%|▊         | 84/1000 [1:03:10<11:28:50, 45.12s/it][Succeeded / Failed / Skipped / Total] 76 / 6 / 2 / 84:   8%|▊         | 84/1000 [1:03:10<11:28:50, 45.12s/it][Succeeded / Failed / Skipped / Total] 76 / 6 / 2 / 84:   8%|▊         | 85/1000 [1:08:42<12:19:36, 48.50s/it][Succeeded / Failed / Skipped / Total] 77 / 6 / 2 / 85:   8%|▊         | 85/1000 [1:08:42<12:19:36, 48.50s/it][Succeeded / Failed / Skipped / Total] 77 / 6 / 2 / 85:   9%|▊         | 86/1000 [1:20:38<14:16:59, 56.26s/it]Determines if the given encoded password matches the given password . --> Returns true if callee matches callee . --> Socre: 1.0

[[[[Adv]]]]: public boolean matches ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean matches ( CharSequence [[calhoun]] , String [[forman]] ) { String [[dominican]] = extractSalt ( [[forman]] ) ; String rawPasswordEncoded = digest ( [[dominican]] , [[calhoun]] ) ; return PasswordEncoderUtils . equals ( [[forman]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 81 ---------------------------------------------
Search for multiple attribute values . --> Calculates moliere query --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[moliere]] ( final String base , final String filter , final Object [ ] params , final String [ ] attributeNames ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 82 ---------------------------------------------
Returns the Spring - security version . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[holidays]] ( ) { Properties properties = new Properties ( ) ; try { properties . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return properties . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 83 ---------------------------------------------
Configure an OAuth2 resource server . --> [[[FAILED]]]

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[artificially]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[crawling]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[crawling]] ) ; return [[crawling]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 84 ---------------------------------------------
Builds a SearchControls based on the given controls . --> muxiliary methods --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls [[buildControls]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls [[monsieur]] ( SearchControls originalControls ) { return new SearchControls ( originalControls . getSearchScope ( ) , originalControls . getCountLimit ( ) , originalControls . getTimeLimit ( ) , originalControls . getReturningAttributes ( ) , RETURN_OBJECT , originalControls . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 85 ---------------------------------------------
Compare an LDAP attribute with the specified name --> Compares password against given password --> Socre: 1.0

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[value]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[value]] } , ctls ) ; Boolean [[match]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[match]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean compare ( final String dn , final String attributeName , final Object [[hallam]] ) { final String comparisonFilter = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls ctls = new SearchControls ( ) ; ctls . setReturningAttributes ( NO_ATTRS ) ; ctls . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( dn , comparisonFilter , new Object [ ] { [[hallam]] } , ctls ) ; Boolean [[passwords]] = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return [[passwords]] ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 77 / 7 / 2 / 86:   9%|▊         | 86/1000 [1:20:38<14:16:59, 56.26s/it][Succeeded / Failed / Skipped / Total] 77 / 7 / 2 / 86:   9%|▊         | 87/1000 [1:23:16<14:33:56, 57.43s/it][Succeeded / Failed / Skipped / Total] 78 / 7 / 2 / 87:   9%|▊         | 87/1000 [1:23:16<14:33:56, 57.43s/it][Succeeded / Failed / Skipped / Total] 78 / 7 / 2 / 87:   9%|▉         | 88/1000 [1:26:31<14:56:38, 58.99s/it][Succeeded / Failed / Skipped / Total] 79 / 7 / 2 / 88:   9%|▉         | 88/1000 [1:26:31<14:56:38, 58.99s/it][Succeeded / Failed / Skipped / Total] 79 / 7 / 2 / 88:   9%|▉         | 89/1000 [1:30:38<15:27:44, 61.10s/it][Succeeded / Failed / Skipped / Total] 80 / 7 / 2 / 89:   9%|▉         | 89/1000 [1:30:38<15:27:45, 61.10s/it][Succeeded / Failed / Skipped / Total] 80 / 7 / 2 / 89:   9%|▉         | 90/1000 [1:31:09<15:21:38, 60.77s/it]Retrieves entries for the specified DN . --> [[[FAILED]]]

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations retrieveEntry ( final String dn , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes attrs = ctx . getAttributes ( dn , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 87 ---------------------------------------------
Creates an embedded server definition . --> Create an embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[port]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[port]] ) ) { [[port]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[port]] ) ; } } String url = "ldap://127.0.0.1:" + [[port]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String [[ldifs]] = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( [[ldifs]] ) ) { [[ldifs]] = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[ldifs]] ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , [[port]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext parserContext ) { Object source = parserContext . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String [[crybaby]] = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( [[crybaby]] ) ) { [[crybaby]] = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + [[crybaby]] ) ; } } String url = "ldap://127.0.0.1:" + [[crybaby]] + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String [[brautigan]] = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( [[brautigan]] ) ) { [[brautigan]] = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( [[brautigan]] ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , [[crybaby]] ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( parserContext . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { parserContext . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } parserContext . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 88 ---------------------------------------------
Create servlet filter --> Called by Spring when a security manager is enabled . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[bk]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 89 ---------------------------------------------
Create the JAASA filter . --> helper method to register JAASA --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[burping]] ( ) { final String ATT_JAAS_API_PROVISION = "jaas-api-provision" ; final String [[ETHER]] = "false" ; String provideJaasApi = httpElt . getAttribute ( ATT_JAAS_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideJaasApi ) ) { provideJaasApi = [[ETHER]] ; } if ( "true" . equals ( provideJaasApi ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
[Succeeded / Failed / Skipped / Total] 81 / 7 / 2 / 90:   9%|▉         | 90/1000 [1:31:09<15:21:38, 60.77s/it][Succeeded / Failed / Skipped / Total] 81 / 7 / 2 / 90:   9%|▉         | 91/1000 [1:31:20<15:12:24, 60.22s/it][Succeeded / Failed / Skipped / Total] 82 / 7 / 2 / 91:   9%|▉         | 91/1000 [1:31:20<15:12:24, 60.22s/it][Succeeded / Failed / Skipped / Total] 82 / 7 / 2 / 91:   9%|▉         | 92/1000 [1:31:27<15:02:39, 59.65s/it][Succeeded / Failed / Skipped / Total] 82 / 8 / 2 / 92:   9%|▉         | 92/1000 [1:31:27<15:02:39, 59.65s/it][Succeeded / Failed / Skipped / Total] 82 / 8 / 2 / 92:   9%|▉         | 93/1000 [1:34:02<15:17:13, 60.68s/it][Succeeded / Failed / Skipped / Total] 83 / 8 / 2 / 93:   9%|▉         | 93/1000 [1:34:02<15:17:13, 60.68s/it][Succeeded / Failed / Skipped / Total] 83 / 8 / 2 / 93:   9%|▉         | 94/1000 [1:35:39<15:22:00, 61.06s/it][Succeeded / Failed / Skipped / Total] 84 / 8 / 2 / 94:   9%|▉         | 94/1000 [1:35:39<15:22:00, 61.06s/it][Succeeded / Failed / Skipped / Total] 84 / 8 / 2 / 94:  10%|▉         | 95/1000 [1:38:32<15:38:47, 62.24s/it]--------------------------------------------- Result 90 ---------------------------------------------
Registers the spring security filter chain . --> Register spring security filter chain . --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String [[contextAttribute]] = getWebApplicationContextAttribute ( ) ; if ( [[contextAttribute]] != null ) { springSecurityFilterChain . setContextAttribute ( [[contextAttribute]] ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy springSecurityFilterChain = new DelegatingFilterProxy ( filterName ) ; String [[blindsided]] = getWebApplicationContextAttribute ( ) ; if ( [[blindsided]] != null ) { springSecurityFilterChain . setContextAttribute ( [[blindsided]] ) ; } registerFilter ( servletContext , "True" == "True" , filterName , springSecurityFilterChain ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 91 ---------------------------------------------
Whitelist default types . --> Whitelist default types --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[henrique]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[henrique]] = [[henrique]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[henrique]] = [[henrique]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[henrique]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
--------------------------------------------- Result 92 ---------------------------------------------
Find primary keys . --> [[[FAILED]]]

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void lookupPrimaryKeys ( final Map < Serializable , Acl > acls , final Set < Long > findNow , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( findNow , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , findNow . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : findNow ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 93 ---------------------------------------------
Build the web authentication details web . --> Build WebAuthenticationDetails based on J2EE roles --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > [[j2eeUserRoles]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[j2eeUserRoles]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[j2eeUserRoles]] + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[userGas]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails buildDetails ( HttpServletRequest context ) { Collection < String > [[în]] = getUserRoles ( context ) ; Collection < ? extends GrantedAuthority > [[lemon]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[în]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[în]] + "] mapped to Granted Authorities: [" + [[lemon]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails result = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( context , [[lemon]] ) ; return result ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 94 ---------------------------------------------
Called after properties have been set . --> Override in subclasses --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[core]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 95 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 84 / 9 / 2 / 95:  10%|▉         | 95/1000 [1:38:32<15:38:47, 62.24s/it][Succeeded / Failed / Skipped / Total] 84 / 9 / 2 / 95:  10%|▉         | 96/1000 [1:39:20<15:35:28, 62.09s/it][Succeeded / Failed / Skipped / Total] 84 / 10 / 2 / 96:  10%|▉         | 96/1000 [1:39:20<15:35:28, 62.09s/it][Succeeded / Failed / Skipped / Total] 84 / 10 / 2 / 96:  10%|▉         | 97/1000 [1:41:55<15:48:50, 63.05s/it][Succeeded / Failed / Skipped / Total] 85 / 10 / 2 / 97:  10%|▉         | 97/1000 [1:41:55<15:48:50, 63.05s/it][Succeeded / Failed / Skipped / Total] 85 / 10 / 2 / 97:  10%|▉         | 98/1000 [1:42:41<15:45:07, 62.87s/it][Succeeded / Failed / Skipped / Total] 86 / 10 / 2 / 98:  10%|▉         | 98/1000 [1:42:41<15:45:07, 62.87s/it][Succeeded / Failed / Skipped / Total] 86 / 10 / 2 / 98:  10%|▉         | 99/1000 [1:46:36<16:10:14, 64.61s/it]Search for a single entry . --> [[[FAILED]]]

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations searchForSingleEntryInternal ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult searchResult = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) searchResult . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 96 ---------------------------------------------
Searches for a single attribute value matching the specified filter . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > searchForSingleAttributeValues ( final String base , final String filter , final Object [ ] params , final String attributeName ) { String [ ] attributeNames = new String [ ] { attributeName } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( base , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( attributeName ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 97 ---------------------------------------------
Gets the authorities for the given attributes . --> get granted authorities --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > getGrantedAuthorities ( Collection < String > [[prophet]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[prophet]] . size ( ) ) ; for ( String [[rachmaninoff]] : [[prophet]] ) { result . add ( getGrantedAuthority ( [[rachmaninoff]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
--------------------------------------------- Result 98 ---------------------------------------------
Check the content length . --> Check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[contentLength]] > 0 && this . contentWritten >= this . [[contentLength]] ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long contentLengthToWrite ) { this . contentWritten += contentLengthToWrite ; boolean isBodyFullyWritten = this . [[displays]] > 0 && this . contentWritten >= this . [[displays]] ; int bufferSize = getBufferSize ( ) ; boolean requiresFlush = bufferSize > 0 && this . contentWritten >= bufferSize ; if ( isBodyFullyWritten || requiresFlush ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 99 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 11 / 2 / 99:  10%|▉         | 99/1000 [1:46:36<16:10:14, 64.61s/it][Succeeded / Failed / Skipped / Total] 86 / 11 / 2 / 99:  10%|█         | 100/1000 [1:49:57<16:29:36, 65.97s/it][Succeeded / Failed / Skipped / Total] 87 / 11 / 2 / 100:  10%|█         | 100/1000 [1:49:57<16:29:36, 65.97s/it][Succeeded / Failed / Skipped / Total] 87 / 11 / 2 / 100:  10%|█         | 101/1000 [1:51:57<16:36:35, 66.51s/it][Succeeded / Failed / Skipped / Total] 88 / 11 / 2 / 101:  10%|█         | 101/1000 [1:51:57<16:36:35, 66.51s/it][Succeeded / Failed / Skipped / Total] 88 / 11 / 2 / 101:  10%|█         | 102/1000 [1:56:39<17:07:05, 68.63s/it][Succeeded / Failed / Skipped / Total] 89 / 11 / 2 / 102:  10%|█         | 102/1000 [1:56:39<17:07:05, 68.63s/it][Succeeded / Failed / Skipped / Total] 89 / 11 / 2 / 102:  10%|█         | 103/1000 [1:57:32<17:03:35, 68.47s/it][Succeeded / Failed / Skipped / Total] 90 / 11 / 2 / 103:  10%|█         | 103/1000 [1:57:32<17:03:35, 68.47s/it][Succeeded / Failed / Skipped / Total] 90 / 11 / 2 / 103:  10%|█         | 104/1000 [1:59:32<17:09:51, 68.96s/it][Succeeded / Failed / Skipped / Total] 91 / 11 / 2 / 104:  10%|█         | 104/1000 [1:59:32<17:09:51, 68.96s/it][Succeeded / Failed / Skipped / Total] 91 / 11 / 2 / 104:  10%|█         | 105/1000 [2:00:19<17:05:41, 68.76s/it]Creates a cipher with the specified algorithm . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String [[algorithm]] ) { try { return Cipher . getInstance ( [[algorithm]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[related]] ( String [[avant]] ) { try { return Cipher . getInstance ( [[avant]] ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 100 ---------------------------------------------
Sets the URL to use for the login request . --> Sets login filter --> Socre: 1.0

[[[[Adv]]]]: public T loginProcessingUrl ( String [[loginProcessingUrl]] ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T loginProcessingUrl ( String [[houten]] ) { this . loginProcessingUrl = loginProcessingUrl ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( loginProcessingUrl ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 101 ---------------------------------------------
Gets the token for the given series id . --> Interprets and returns a new remember me --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[rs]] , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( [[rs]] . getString ( 1 ) , [[rs]] . getString ( 2 ) , [[rs]] . getString ( 3 ) , [[rs]] . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[rehabilitating]] ( String [[legionaries]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet [[bayard]] , int [[male]] ) throws SQLException { return new PersistentRememberMeToken ( [[bayard]] . getString ( 1 ) , [[bayard]] . getString ( 2 ) , [[bayard]] . getString ( 3 ) , [[bayard]] . getTimestamp ( 4 ) ) ; } } , [[legionaries]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[legionaries]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[legionaries]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[legionaries]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 102 ---------------------------------------------
Updates authentication defaults . --> Initiate wiki page --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[aoi]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[hippocratic]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[hippocratic]] != null && ! [[hippocratic]] . isCustomLogoutSuccess ( ) ) { [[hippocratic]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 103 ---------------------------------------------
Update access defaults --> Permanently all vagaries --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B [[http]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[http]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[animosity]] ( B [[vagaries]] ) { if ( permitAll ) { PermitAllSupport . permitAll ( [[vagaries]] , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 104 ---------------------------------------------
Perform security check . --> Boggling --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse [[response]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) [[response]] ) ; } chain . doFilter ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[boggling]] ( ServletRequest [[geographically]] , ServletResponse [[sidelines]] , FilterChain chain ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[geographically]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[geographically]] , ( HttpServletResponse ) [[sidelines]] ) ; } chain . doFilter ( [[geographically]] , [[sidelines]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 105 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 92 / 11 / 2 / 105:  10%|█         | 105/1000 [2:00:19<17:05:41, 68.76s/it][Succeeded / Failed / Skipped / Total] 92 / 11 / 2 / 105:  11%|█         | 106/1000 [2:00:31<16:56:26, 68.22s/it][Succeeded / Failed / Skipped / Total] 92 / 12 / 2 / 106:  11%|█         | 106/1000 [2:00:31<16:56:26, 68.22s/it][Succeeded / Failed / Skipped / Total] 92 / 12 / 2 / 106:  11%|█         | 107/1000 [2:03:23<17:09:48, 69.19s/it][Succeeded / Failed / Skipped / Total] 93 / 12 / 2 / 107:  11%|█         | 107/1000 [2:03:23<17:09:48, 69.19s/it][Succeeded / Failed / Skipped / Total] 93 / 12 / 2 / 107:  11%|█         | 108/1000 [2:07:53<17:36:16, 71.05s/it][Succeeded / Failed / Skipped / Total] 94 / 12 / 2 / 108:  11%|█         | 108/1000 [2:07:53<17:36:16, 71.05s/it][Succeeded / Failed / Skipped / Total] 94 / 12 / 2 / 108:  11%|█         | 109/1000 [2:07:53<17:25:25, 70.40s/it][Succeeded / Failed / Skipped / Total] 94 / 13 / 2 / 109:  11%|█         | 109/1000 [2:07:53<17:25:25, 70.40s/it][Succeeded / Failed / Skipped / Total] 94 / 13 / 2 / 109:  11%|█         | 110/1000 [2:15:30<18:16:20, 73.91s/it]Encode cookie . --> Generate iconography string --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[iconography]] ( String [ ] cookieTokens ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < cookieTokens . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( cookieTokens [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < cookieTokens . length - 1 ) { sb . append ( DELIMITER ) ; } } String value = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( value . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 106 ---------------------------------------------
Sets the delay . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[authorizes]] ( long [[potomac]] , TimeUnit [[sabre]] ) { if ( [[potomac]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[strokes]] = [[sabre]] . toMillis ( [[potomac]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 107 ---------------------------------------------
Map password . --> Get a broadcaster --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object [[passwordValue]] ) { if ( ! ( [[passwordValue]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[broadcaster]] ( Object [[giotto]] ) { if ( ! ( [[giotto]] instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 108 ---------------------------------------------
Check if the pre - authenticated principal has changed . --> Check for rejections --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "[[False]]" != "[[False]]" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "[[False]]" != "[[False]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[rejections]] ( HttpServletRequest request , Authentication [[tickle]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[tickle]] . getName ( ) . equals ( principal ) ) { return "[[Bretagne]]" != "[[Bretagne]]" ; } if ( principal != null && principal . equals ( [[tickle]] . getPrincipal ( ) ) ) { return "[[Bretagne]]" != "[[Bretagne]]" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 109 ---------------------------------------------
Perform authentication . --> [[[FAILED]]]

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void doAuthenticate ( HttpServletRequest request , HttpServletResponse response ) throws IOException , ServletException { Authentication authResult ; Object principal = getPreAuthenticatedPrincipal ( request ) ; Object credentials = getPreAuthenticatedCredentials ( request ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken authRequest = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; authRequest . setDetails ( authenticationDetailsSource . buildDetails ( request ) ) ; authResult = authenticationManager . authenticate ( authRequest ) ; successfulAuthentication ( request , response , authResult ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( request , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 95 / 13 / 2 / 110:  11%|█         | 110/1000 [2:15:30<18:16:20, 73.91s/it][Succeeded / Failed / Skipped / Total] 95 / 13 / 2 / 110:  11%|█         | 111/1000 [2:16:56<18:16:42, 74.02s/it][Succeeded / Failed / Skipped / Total] 96 / 13 / 2 / 111:  11%|█         | 111/1000 [2:16:56<18:16:42, 74.02s/it][Succeeded / Failed / Skipped / Total] 96 / 13 / 2 / 111:  11%|█         | 112/1000 [2:17:43<18:11:55, 73.78s/it][Succeeded / Failed / Skipped / Total] 96 / 14 / 2 / 112:  11%|█         | 112/1000 [2:17:43<18:11:55, 73.78s/it][Succeeded / Failed / Skipped / Total] 96 / 14 / 2 / 112:  11%|█▏        | 113/1000 [2:19:27<18:14:41, 74.05s/it][Succeeded / Failed / Skipped / Total] 97 / 14 / 2 / 113:  11%|█▏        | 113/1000 [2:19:27<18:14:41, 74.05s/it][Succeeded / Failed / Skipped / Total] 97 / 14 / 2 / 113:  11%|█▏        | 114/1000 [2:24:49<18:45:37, 76.23s/it][Succeeded / Failed / Skipped / Total] 98 / 14 / 2 / 114:  11%|█▏        | 114/1000 [2:24:49<18:45:37, 76.23s/it][Succeeded / Failed / Skipped / Total] 98 / 14 / 2 / 114:  12%|█▏        | 115/1000 [2:25:56<18:43:04, 76.14s/it][Succeeded / Failed / Skipped / Total] 98 / 15 / 2 / 115:  12%|█▏        | 115/1000 [2:25:56<18:43:04, 76.14s/it][Succeeded / Failed / Skipped / Total] 98 / 15 / 2 / 115:  12%|█▏        | 116/1000 [2:29:40<19:00:41, 77.42s/it]Sets the cookie . --> Helper method to add cookies --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[oiling]] ( String [ ] tokens , int maxAge , HttpServletRequest request , HttpServletResponse [[sugared]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( maxAge ) ; cookie . setPath ( getCookiePath ( request ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( maxAge < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( request . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[sugared]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 111 ---------------------------------------------
Gets the service port . --> get smokackackack --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int port = [[casServiceUrl]] . getPort ( ) ; if ( port == - 1 ) { port = [[casServiceUrl]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[smokestack]] ( URL [[goners]] ) { int port = [[goners]] . getPort ( ) ; if ( port == - 1 ) { port = [[goners]] . getDefaultPort ( ) ; } return port ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 112 ---------------------------------------------
Maps a collection of authorities to a Set of authorities . --> [[[FAILED]]]

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { [[mapped]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[billowing]] ( Collection < ? extends GrantedAuthority > authorities ) { HashSet < GrantedAuthority > [[dere]] = new HashSet <> ( authorities . size ( ) ) ; for ( GrantedAuthority authority : authorities ) { [[dere]] . add ( mapAuthority ( authority . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[dere]] . add ( defaultAuthority ) ; } return [[dere]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 113 ---------------------------------------------
Log out the current session . --> Implementation of JsServlet --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[jimson]] ( HttpServletRequest request , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( request , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession session = request . getSession ( "False" != "False" ) ; if ( session != null ) { logger . debug ( "Invalidating session: " + session . getId ( ) ) ; session . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext context = SecurityContextHolder . getContext ( ) ; context . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 114 ---------------------------------------------
Authenticate with the given authentication token . --> Authenticates a security token . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[notice]] ) throws AuthenticationException { if ( ! ( [[notice]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[round]] = ( UsernamePasswordAuthenticationToken ) [[notice]] ; Set < GrantedAuthority > authorities ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 115 ---------------------------------------------
Resolves the given parameter . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > resolveArgument ( MethodParameter parameter , BindingContext bindingContext , ServerWebExchange exchange ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( parameter . getParameterType ( ) ) ; Mono < SecurityContext > reactiveSecurityContext = ReactiveSecurityContextHolder . getContext ( ) ; if ( reactiveSecurityContext == null ) { return null ; } return reactiveSecurityContext . flatMap ( a -> { Object p = resolveSecurityContext ( parameter , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 116 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 98 / 16 / 2 / 116:  12%|█▏        | 116/1000 [2:29:40<19:00:41, 77.42s/it][Succeeded / Failed / Skipped / Total] 98 / 16 / 2 / 116:  12%|█▏        | 117/1000 [2:31:19<19:01:59, 77.60s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 2 / 117:  12%|█▏        | 117/1000 [2:31:19<19:01:59, 77.60s/it][Succeeded / Failed / Skipped / Total] 98 / 17 / 2 / 117:  12%|█▏        | 118/1000 [2:34:27<19:14:30, 78.54s/it][Succeeded / Failed / Skipped / Total] 98 / 18 / 2 / 118:  12%|█▏        | 118/1000 [2:34:27<19:14:30, 78.54s/it][Succeeded / Failed / Skipped / Total] 98 / 18 / 2 / 118:  12%|█▏        | 119/1000 [2:34:43<19:05:31, 78.02s/it][Succeeded / Failed / Skipped / Total] 98 / 19 / 2 / 119:  12%|█▏        | 119/1000 [2:34:43<19:05:31, 78.02s/it][Succeeded / Failed / Skipped / Total] 98 / 19 / 2 / 119:  12%|█▏        | 120/1000 [2:36:14<19:05:47, 78.12s/it][Succeeded / Failed / Skipped / Total] 98 / 20 / 2 / 120:  12%|█▏        | 120/1000 [2:36:14<19:05:47, 78.12s/it][Succeeded / Failed / Skipped / Total] 98 / 20 / 2 / 120:  12%|█▏        | 121/1000 [2:37:14<19:02:17, 77.97s/it][Succeeded / Failed / Skipped / Total] 99 / 20 / 2 / 121:  12%|█▏        | 121/1000 [2:37:14<19:02:17, 77.97s/it][Succeeded / Failed / Skipped / Total] 99 / 20 / 2 / 121:  12%|█▏        | 122/1000 [2:37:31<18:53:41, 77.47s/it]Get remember me cookie from request --> [[[FAILED]]]

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest [[request]] ) { Cookie [ ] cookies = [[request]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String extractRememberMeCookie ( HttpServletRequest [[ferraro]] ) { Cookie [ ] cookies = [[ferraro]] . getCookies ( ) ; if ( ( cookies == null ) || ( cookies . length == 0 ) ) { return null ; } for ( Cookie cookie : cookies ) { if ( cookieName . equals ( cookie . getName ( ) ) ) { return cookie . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 117 ---------------------------------------------
Returns the full URL of this request . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[synapse]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 118 ---------------------------------------------
Gets the query string . --> [[[FAILED]]]

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String [[query]] = request . getQueryString ( ) ; if ( [[query]] == null ) { return null ; } final String result = artifactPattern . matcher ( [[query]] ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[omer]] ( final HttpServletRequest request , final Pattern artifactPattern ) { final String [[approachable]] = request . getQueryString ( ) ; if ( [[approachable]] == null ) { return null ; } final String result = artifactPattern . matcher ( [[approachable]] ) . replaceFirst ( "" ) ; if ( result . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 119 ---------------------------------------------
Render the end tag . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[sarcoma]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 120 ---------------------------------------------
Returns the principal . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getPrincipal]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[authentication]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[authentication]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[authentication]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String [[crashers]] ( ) { Authentication [[amarillo]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( [[amarillo]] == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = [[amarillo]] . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( [[amarillo]] instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 121 ---------------------------------------------
Determines whether the request requires authentication . --> Does the request requires authentication? --> Socre: 1.0

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[response]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean requiresAuthentication ( final HttpServletRequest request , final HttpServletResponse [[hiroshima]] ) { final boolean serviceTicketRequest = serviceTicketRequest ( request , [[hiroshima]] ) ; final boolean result = serviceTicketRequest || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( serviceTicketRequest , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 122 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 20 / 2 / 122:  12%|█▏        | 122/1000 [2:37:31<18:53:41, 77.47s/it][Succeeded / Failed / Skipped / Total] 100 / 20 / 2 / 122:  12%|█▏        | 123/1000 [2:38:37<18:51:00, 77.38s/it][Succeeded / Failed / Skipped / Total] 100 / 21 / 2 / 123:  12%|█▏        | 123/1000 [2:38:37<18:51:00, 77.38s/it][Succeeded / Failed / Skipped / Total] 100 / 21 / 2 / 123:  12%|█▏        | 124/1000 [2:39:02<18:43:30, 76.95s/it][Succeeded / Failed / Skipped / Total] 101 / 21 / 2 / 124:  12%|█▏        | 124/1000 [2:39:02<18:43:30, 76.95s/it][Succeeded / Failed / Skipped / Total] 101 / 21 / 2 / 124:  12%|█▎        | 125/1000 [2:39:11<18:34:23, 76.42s/it][Succeeded / Failed / Skipped / Total] 102 / 21 / 2 / 125:  12%|█▎        | 125/1000 [2:39:11<18:34:23, 76.42s/it][Succeeded / Failed / Skipped / Total] 102 / 21 / 2 / 125:  13%|█▎        | 126/1000 [2:40:00<18:29:54, 76.20s/it][Succeeded / Failed / Skipped / Total] 103 / 21 / 2 / 126:  13%|█▎        | 126/1000 [2:40:00<18:29:54, 76.20s/it][Succeeded / Failed / Skipped / Total] 103 / 21 / 2 / 126:  13%|█▎        | 127/1000 [2:40:51<18:25:43, 76.00s/it][Succeeded / Failed / Skipped / Total] 104 / 21 / 2 / 127:  13%|█▎        | 127/1000 [2:40:51<18:25:43, 76.00s/it][Succeeded / Failed / Skipped / Total] 104 / 21 / 2 / 127:  13%|█▎        | 128/1000 [2:48:41<19:09:15, 79.08s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 2 / 128:  13%|█▎        | 128/1000 [2:48:41<19:09:15, 79.08s/it][Succeeded / Failed / Skipped / Total] 104 / 22 / 2 / 128:  13%|█▎        | 129/1000 [2:55:14<19:43:13, 81.51s/it]Add the pkce parameters . --> Generates weather condition --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[weatherly]] ( Map < String , Object > attributes , Map < String , Object > additionalParameters ) { String codeVerifier = this . codeVerifierGenerator . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , codeVerifier ) ; try { String codeChallenge = createCodeChallenge ( codeVerifier ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { additionalParameters . put ( PkceParameterNames . CODE_CHALLENGE , codeVerifier ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 123 ---------------------------------------------
Sets the environment environment properties . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[grandmas]] ( Map < String , Object > environment ) { Assert . notEmpty ( environment , "environment must not be empty" ) ; this . [[defending]] = new Hashtable <> ( environment ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 124 ---------------------------------------------
Returns the UserDetailsService . --> I1802 --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[ianto]] ( ) { Map < String , ? > [[antónio]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[antónio]] . size ( ) == 0 ) { [[antónio]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[antónio]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[antónio]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[antónio]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 125 ---------------------------------------------
Handles request ticket request . --> Does authentication require authentication? --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[bengalis]] ( final HttpServletRequest request , final HttpServletResponse response ) { boolean result = super . requiresAuthentication ( request , response ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 126 ---------------------------------------------
Retrieve JWK set . --> Return a Mono --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[abattoir]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 127 ---------------------------------------------
Encodes the given value using UTF - 8 . --> Encodes the given alitalized string . --> Socre: 1.0

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[alitalia]] ) { try { return URLEncoder . encode ( [[alitalia]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error err = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; err . initCause ( e ) ; throw err ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 128 ---------------------------------------------
Initialize UserDetailsService . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void initUserDetailsService ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails userDetails : this . users ) { getUserDetailsService ( ) . createUser ( userDetails ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 104 / 23 / 2 / 129:  13%|█▎        | 129/1000 [2:55:14<19:43:13, 81.51s/it][Succeeded / Failed / Skipped / Total] 104 / 23 / 2 / 129:  13%|█▎        | 130/1000 [2:56:13<19:39:21, 81.33s/it][Succeeded / Failed / Skipped / Total] 105 / 23 / 2 / 130:  13%|█▎        | 130/1000 [2:56:13<19:39:21, 81.33s/it][Succeeded / Failed / Skipped / Total] 105 / 23 / 2 / 130:  13%|█▎        | 131/1000 [2:57:56<19:40:24, 81.50s/it][Succeeded / Failed / Skipped / Total] 106 / 23 / 2 / 131:  13%|█▎        | 131/1000 [2:57:56<19:40:24, 81.50s/it][Succeeded / Failed / Skipped / Total] 106 / 23 / 2 / 131:  13%|█▎        | 132/1000 [2:58:40<19:34:53, 81.21s/it][Succeeded / Failed / Skipped / Total] 107 / 23 / 2 / 132:  13%|█▎        | 132/1000 [2:58:40<19:34:53, 81.21s/it][Succeeded / Failed / Skipped / Total] 107 / 23 / 2 / 132:  13%|█▎        | 133/1000 [3:02:28<19:49:28, 82.32s/it][Succeeded / Failed / Skipped / Total] 108 / 23 / 2 / 133:  13%|█▎        | 133/1000 [3:02:28<19:49:28, 82.32s/it][Succeeded / Failed / Skipped / Total] 108 / 23 / 2 / 133:  13%|█▎        | 134/1000 [3:04:32<19:52:41, 82.63s/it]Build the provider URL from the given list of URLs . --> [[[FAILED]]]

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String buildProviderUrl ( List < String > urls , String baseDn ) { Assert . notNull ( baseDn , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( urls , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = baseDn . trim ( ) ; StringBuilder providerUrl = new StringBuilder ( ) ; for ( String serverUrl : urls ) { String trimmedUrl = serverUrl . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } providerUrl . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { providerUrl . append ( "/" ) ; } providerUrl . append ( trimmedBaseDn ) ; providerUrl . append ( " " ) ; } return providerUrl . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 130 ---------------------------------------------
Returns true if the ticket should be authenticated . --> proxyTicketRequest --> Socre: 1.0

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean proxyTicketRequest ( final boolean [[fumbles]] , final HttpServletRequest [[emm]] ) { if ( [[fumbles]] ) { return "False" != "False" ; } final boolean [[ducking]] = authenticateAllArtifacts && obtainArtifact ( [[emm]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[ducking]] ) ; } return [[ducking]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 131 ---------------------------------------------
Determines whether the proxy should be proxied . --> Zolvable proxied --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[zoloft]] ( final HttpServletRequest [[progeny]] ) { final boolean [[trolling]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[progeny]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[trolling]] ) ; } return [[trolling]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 132 ---------------------------------------------
Load user by assertion . --> get OutedUserDetails --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken [[token]] = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[token]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[outed]] ( final Assertion [[fauntleroy]] ) { final CasAssertionAuthenticationToken [[bebel]] = new CasAssertionAuthenticationToken ( [[fauntleroy]] , "" ) ; return this . authenticationUserDetailsService . loadUserDetails ( [[bebel]] ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 133 ---------------------------------------------
Get the set of groups based on the authenticated user --> getcora --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[ancora]] ( ) { List < String > [[antónio]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[smothering]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[antónio]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[antónio]] + " mapped to Granted Authorities: " + [[smothering]] ) ; } return [[smothering]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 134 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 109 / 23 / 2 / 134:  13%|█▎        | 134/1000 [3:04:32<19:52:41, 82.63s/it][Succeeded / Failed / Skipped / Total] 109 / 23 / 2 / 134:  14%|█▎        | 135/1000 [3:05:20<19:47:33, 82.37s/it][Succeeded / Failed / Skipped / Total] 110 / 23 / 2 / 135:  14%|█▎        | 135/1000 [3:05:20<19:47:33, 82.37s/it][Succeeded / Failed / Skipped / Total] 110 / 23 / 2 / 135:  14%|█▎        | 136/1000 [3:05:23<19:37:44, 81.79s/it][Succeeded / Failed / Skipped / Total] 111 / 23 / 2 / 136:  14%|█▎        | 136/1000 [3:05:23<19:37:44, 81.79s/it][Succeeded / Failed / Skipped / Total] 111 / 23 / 2 / 136:  14%|█▎        | 137/1000 [3:06:04<19:32:07, 81.49s/it][Succeeded / Failed / Skipped / Total] 112 / 23 / 2 / 137:  14%|█▎        | 137/1000 [3:06:04<19:32:07, 81.49s/it][Succeeded / Failed / Skipped / Total] 112 / 23 / 2 / 137:  14%|█▍        | 138/1000 [3:08:00<19:34:22, 81.74s/it][Succeeded / Failed / Skipped / Total] 113 / 23 / 2 / 138:  14%|█▍        | 138/1000 [3:08:00<19:34:22, 81.74s/it][Succeeded / Failed / Skipped / Total] 113 / 23 / 2 / 138:  14%|█▍        | 139/1000 [3:11:13<19:44:30, 82.54s/it][Succeeded / Failed / Skipped / Total] 114 / 23 / 2 / 139:  14%|█▍        | 139/1000 [3:11:13<19:44:30, 82.54s/it][Succeeded / Failed / Skipped / Total] 115 / 23 / 2 / 140:  14%|█▍        | 140/1000 [3:11:13<19:34:41, 81.95s/it][Succeeded / Failed / Skipped / Total] 115 / 23 / 2 / 140:  14%|█▍        | 141/1000 [3:11:24<19:26:02, 81.45s/it]Pre - processes the map of map authorities to a collection of granted authorities . --> Pre - process HttpBebes . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > preProcessMap ( Map < ? , ? > [[hobbes]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[hobbes]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[hobbes]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 135 ---------------------------------------------
Concatenate multiple arrays . --> Concatenate a list of pieces --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] array : [[arrays]] ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] concatenate ( byte [ ] ... [[factions]] ) { int length = 0 ; for ( byte [ ] array : [[factions]] ) { length += array . length ; } byte [ ] newArray = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[factions]] ) { System . arraycopy ( array , 0 , newArray , destPos , array . length ) ; destPos += array . length ; } return newArray ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 136 ---------------------------------------------
Gets the granted authority collection . --> convenience method --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > getGrantedAuthorityCollection ( Object value ) { Collection < GrantedAuthority > [[sharkboy]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[sharkboy]] , value ) ; return [[sharkboy]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 137 ---------------------------------------------
Creates a security expression root for the security expression root . --> region SecurityExpressionRoot Implementation --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication authentication , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( [[invocation]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[bigshot]] ( Authentication authentication , MethodInvocation [[assassination]] ) { MethodSecurityExpressionRoot root = new MethodSecurityExpressionRoot ( authentication ) ; root . setThis ( [[assassination]] . getThis ( ) ) ; root . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; root . setTrustResolver ( getTrustResolver ( ) ) ; root . setRoleHierarchy ( getRoleHierarchy ( ) ) ; root . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return root ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 138 ---------------------------------------------
Returns the pre - authenticated principal . --> Extract principal from request --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[ancona]] ( HttpServletRequest [[poundin]] ) { Object principal = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 139 ---------------------------------------------
Gets the pre authenticated principal . --> getter for pre - authenticated principal --> Socre: 1.0

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object getPreAuthenticatedPrincipal ( HttpServletRequest [[insulin]] ) { Object [[priestess]] = [[insulin]] . getUserPrincipal ( ) == null ? null : [[insulin]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + [[priestess]] ) ; } return [[priestess]] ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 140 ---------------------------------------------
Gets the shared object . --> Returns the influence of the given type --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[C]] > [[C]] getSharedObject ( Class < [[C]] > sharedType ) { return ( [[C]] ) this . [[sharedObjects]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[influence]] > [[influence]] getSharedObject ( Class < [[influence]] > sharedType ) { return ( [[influence]] ) this . [[roe]] . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 141 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 116 / 23 / 2 / 141:  14%|█▍        | 141/1000 [3:11:24<19:26:02, 81.45s/it][Succeeded / Failed / Skipped / Total] 116 / 23 / 2 / 141:  14%|█▍        | 142/1000 [3:11:25<19:16:41, 80.89s/it][Succeeded / Failed / Skipped / Total] 117 / 23 / 2 / 142:  14%|█▍        | 142/1000 [3:11:25<19:16:41, 80.89s/it][Succeeded / Failed / Skipped / Total] 117 / 23 / 2 / 142:  14%|█▍        | 143/1000 [3:11:28<19:07:30, 80.34s/it][Succeeded / Failed / Skipped / Total] 118 / 23 / 2 / 143:  14%|█▍        | 143/1000 [3:11:28<19:07:30, 80.34s/it][Succeeded / Failed / Skipped / Total] 118 / 23 / 2 / 143:  14%|█▍        | 144/1000 [3:11:57<19:01:08, 79.99s/it][Succeeded / Failed / Skipped / Total] 119 / 23 / 2 / 144:  14%|█▍        | 144/1000 [3:11:57<19:01:08, 79.99s/it][Succeeded / Failed / Skipped / Total] 119 / 23 / 2 / 144:  14%|█▍        | 145/1000 [3:12:14<18:53:32, 79.55s/it][Succeeded / Failed / Skipped / Total] 120 / 23 / 2 / 145:  14%|█▍        | 145/1000 [3:12:14<18:53:32, 79.55s/it][Succeeded / Failed / Skipped / Total] 120 / 23 / 2 / 145:  15%|█▍        | 146/1000 [3:12:31<18:46:10, 79.12s/it][Succeeded / Failed / Skipped / Total] 121 / 23 / 2 / 146:  15%|█▍        | 146/1000 [3:12:31<18:46:10, 79.12s/it][Succeeded / Failed / Skipped / Total] 121 / 23 / 2 / 146:  15%|█▍        | 147/1000 [3:13:13<18:41:11, 78.87s/it]Intercepts the interceptor . --> Implementation of interceptor --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object [[albatross]] ( JoinPoint jp , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( jp ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 142 ---------------------------------------------
Gets the granted authorities for the given attributes . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > [[c]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[c]] != null ) { gaList . addAll ( [[c]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[verywell]] ( Collection < String > attributes ) { ArrayList < GrantedAuthority > gaList = new ArrayList <> ( ) ; for ( String attribute : attributes ) { Collection < GrantedAuthority > [[kalyani]] = attributes2grantedAuthoritiesMap . get ( attribute ) ; if ( [[kalyani]] != null ) { gaList . addAll ( [[kalyani]] ) ; } } gaList . trimToSize ( ) ; return gaList ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 143 ---------------------------------------------
Returns the role s role . --> method to getRole --> Socre: 1.0

[[[[Adv]]]]: private static String hasRole ( String [[role]] ) { Assert . isTrue ( ! [[role]] . startsWith ( "ROLE_" ) , ( ) -> [[role]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[role]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String hasRole ( String [[lobotomized]] ) { Assert . isTrue ( ! [[lobotomized]] . startsWith ( "ROLE_" ) , ( ) -> [[lobotomized]] + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + [[lobotomized]] ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 144 ---------------------------------------------
Converts a list of roles to a list of roles --> returns null if any --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... roles ) { for ( int [[i]] = 0 ; [[i]] < roles . length ; [[i]] ++ ) { roles [ [[i]] ] = "ROLE_" + roles [ [[i]] ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... roles ) { for ( int [[bourdieu]] = 0 ; [[bourdieu]] < roles . length ; [[bourdieu]] ++ ) { roles [ [[bourdieu]] ] = "ROLE_" + roles [ [[bourdieu]] ] ; } return roles ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 145 ---------------------------------------------
Get a portion of a byte array . --> Utility method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[array]] , int beginIndex , int [[endIndex]] ) { int [[length]] = [[endIndex]] - beginIndex ; byte [ ] subarray = new byte [ [[length]] ] ; System . arraycopy ( [[array]] , beginIndex , subarray , 0 , [[length]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] subArray ( byte [ ] [[chipmunk]] , int beginIndex , int [[bronwyn]] ) { int [[jfk]] = [[bronwyn]] - beginIndex ; byte [ ] subarray = new byte [ [[jfk]] ] ; System . arraycopy ( [[chipmunk]] , beginIndex , subarray , 0 , [[jfk]] ) ; return subarray ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 146 ---------------------------------------------
Build redirect url for given request . --> Get Resource Urls --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( request . getServerName ( ) ) ; [[urlBuilder]] . setPort ( httpsPort . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( request . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( request . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( request . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( request . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[researches]] ( HttpServletRequest request ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( request ) ; Integer httpsPort = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( httpsPort != null ) { RedirectUrlBuilder [[calzone]] = new RedirectUrlBuilder ( ) ; [[calzone]] . setScheme ( "https" ) ; [[calzone]] . setServerName ( request . getServerName ( ) ) ; [[calzone]] . setPort ( httpsPort . intValue ( ) ) ; [[calzone]] . setContextPath ( request . getContextPath ( ) ) ; [[calzone]] . setServletPath ( request . getServletPath ( ) ) ; [[calzone]] . setPathInfo ( request . getPathInfo ( ) ) ; [[calzone]] . setQuery ( request . getQueryString ( ) ) ; return [[calzone]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 147 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 122 / 23 / 2 / 147:  15%|█▍        | 147/1000 [3:13:13<18:41:11, 78.87s/it][Succeeded / Failed / Skipped / Total] 122 / 23 / 2 / 147:  15%|█▍        | 148/1000 [3:13:20<18:32:58, 78.38s/it][Succeeded / Failed / Skipped / Total] 123 / 23 / 2 / 148:  15%|█▍        | 148/1000 [3:13:20<18:32:58, 78.38s/it][Succeeded / Failed / Skipped / Total] 123 / 23 / 2 / 148:  15%|█▍        | 149/1000 [3:13:39<18:26:05, 77.98s/it][Succeeded / Failed / Skipped / Total] 124 / 23 / 2 / 149:  15%|█▍        | 149/1000 [3:13:39<18:26:05, 77.98s/it][Succeeded / Failed / Skipped / Total] 124 / 23 / 2 / 149:  15%|█▌        | 150/1000 [3:13:52<18:18:37, 77.55s/it][Succeeded / Failed / Skipped / Total] 125 / 23 / 2 / 150:  15%|█▌        | 150/1000 [3:13:52<18:18:37, 77.55s/it][Succeeded / Failed / Skipped / Total] 125 / 23 / 2 / 150:  15%|█▌        | 151/1000 [3:13:56<18:10:24, 77.06s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 2 / 151:  15%|█▌        | 151/1000 [3:13:56<18:10:24, 77.06s/it][Succeeded / Failed / Skipped / Total] 126 / 23 / 2 / 151:  15%|█▌        | 152/1000 [3:14:07<18:03:00, 76.63s/it][Succeeded / Failed / Skipped / Total] 127 / 23 / 2 / 152:  15%|█▌        | 152/1000 [3:14:07<18:03:00, 76.63s/it][Succeeded / Failed / Skipped / Total] 127 / 23 / 2 / 152:  15%|█▌        | 153/1000 [3:14:07<17:54:41, 76.13s/it][Succeeded / Failed / Skipped / Total] 128 / 23 / 2 / 153:  15%|█▌        | 153/1000 [3:14:07<17:54:41, 76.13s/it][Succeeded / Failed / Skipped / Total] 128 / 23 / 2 / 153:  15%|█▌        | 154/1000 [3:14:28<17:48:23, 75.77s/it]Adds a collection of granted authorities to the result . --> iamole --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[iam]] ( Collection < GrantedAuthority > [[tripathi]] , Object [[puta]] ) { if ( [[puta]] == null ) { return ; } if ( [[puta]] instanceof Collection < ? > ) { [[iam]] ( [[tripathi]] , ( Collection < ? > ) [[puta]] ) ; } else if ( [[puta]] instanceof Object [ ] ) { [[iam]] ( [[tripathi]] , ( Object [ ] ) [[puta]] ) ; } else if ( [[puta]] instanceof String ) { [[iam]] ( [[tripathi]] , ( String ) [[puta]] ) ; } else if ( [[puta]] instanceof GrantedAuthority ) { [[tripathi]] . add ( ( GrantedAuthority ) [[puta]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[puta]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 148 ---------------------------------------------
Display public index --> Display Hello Contact --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[bluffing]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 149 ---------------------------------------------
Extracts the auto login token from the cookie token . --> Attempt to retrieve user details --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse [[response]] ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[possessiveness]] ( String [ ] cookieTokens , HttpServletRequest request , HttpServletResponse [[hewas]] ) { if ( cookieTokens . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( cookieTokens ) + "'" ) ; } final String presentedSeries = cookieTokens [ 0 ] ; final String presentedToken = cookieTokens [ 1 ] ; PersistentRememberMeToken token = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( token == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 150 ---------------------------------------------
Attempt to exit the login process . --> Implementation of Gangrene Authentication --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest [[request]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[gangrene]] ( HttpServletRequest [[edu]] ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 151 ---------------------------------------------
Decodes the given token . --> Decodes a token . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[createdJwt]] = createJwt ( token , jwt ) ; return validateJwt ( [[createdJwt]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt decode ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt [[jerry]] = createJwt ( token , jwt ) ; return validateJwt ( [[jerry]] ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 152 ---------------------------------------------
Allow access using URL check --> Determines whether or not this resource should be traversed --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[descends]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 153 ---------------------------------------------
Sets the exit user . --> Sets ARACHN IDs --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[arachnids]] ( String [[buying]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[buying]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[buying]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
[Succeeded / Failed / Skipped / Total] 129 / 23 / 2 / 154:  15%|█▌        | 154/1000 [3:14:28<17:48:23, 75.77s/it][Succeeded / Failed / Skipped / Total] 129 / 23 / 2 / 154:  16%|█▌        | 155/1000 [3:14:38<17:41:06, 75.35s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 2 / 155:  16%|█▌        | 155/1000 [3:14:38<17:41:06, 75.35s/it][Succeeded / Failed / Skipped / Total] 130 / 23 / 2 / 155:  16%|█▌        | 156/1000 [3:15:34<17:38:06, 75.22s/it][Succeeded / Failed / Skipped / Total] 131 / 23 / 2 / 156:  16%|█▌        | 156/1000 [3:15:34<17:38:06, 75.22s/it][Succeeded / Failed / Skipped / Total] 131 / 23 / 2 / 156:  16%|█▌        | 157/1000 [3:15:54<17:31:54, 74.87s/it][Succeeded / Failed / Skipped / Total] 132 / 23 / 2 / 157:  16%|█▌        | 157/1000 [3:15:54<17:31:54, 74.87s/it][Succeeded / Failed / Skipped / Total] 132 / 23 / 2 / 157:  16%|█▌        | 158/1000 [3:16:12<17:25:38, 74.51s/it][Succeeded / Failed / Skipped / Total] 133 / 23 / 2 / 158:  16%|█▌        | 158/1000 [3:16:12<17:25:38, 74.51s/it][Succeeded / Failed / Skipped / Total] 133 / 23 / 2 / 158:  16%|█▌        | 159/1000 [3:16:35<17:19:50, 74.19s/it][Succeeded / Failed / Skipped / Total] 134 / 23 / 2 / 159:  16%|█▌        | 159/1000 [3:16:35<17:19:50, 74.19s/it][Succeeded / Failed / Skipped / Total] 134 / 23 / 2 / 159:  16%|█▌        | 160/1000 [3:16:51<17:13:27, 73.82s/it]--------------------------------------------- Result 154 ---------------------------------------------
Converts the given JWT to granted authorities . --> Converts a Jwt Jwt jwt jwt jwt jwt jwt . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[carlson]] ( Jwt jwt ) { return getScopes ( jwt ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 155 ---------------------------------------------
Build the spring security filter chain . --> Builds a Bean . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean [[hasConfigurers]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[hasConfigurers]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[beau]] ( ) throws Exception { boolean [[trays]] = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! [[trays]] ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 156 ---------------------------------------------
Authorizes the access using the access expression . --> Determines whether or not --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[False]]" != "[[False]]" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[ando]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "[[Weightlifting]]" != "[[Weightlifting]]" ; } SecurityExpressionHandler < FilterInvocation > handler = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = handler . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException ioException = new IOException ( ) ; ioException . initCause ( e ) ; throw ioException ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( handler ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 157 ---------------------------------------------
Attempts to switch a user with the specified username . --> Obtain guzzler --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[targetUser]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[targetUser]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[guzzler]] ( HttpServletRequest request ) throws AuthenticationException { UsernamePasswordAuthenticationToken targetUserRequest ; String username = request . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails [[bedazzled]] = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( [[bedazzled]] ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 158 ---------------------------------------------
Determines if the user is authenticated --> Returns whether or not the rhian non - rhian non - anonymous non - anonymous non - defined --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[rhiannon]] ( ) { Authentication [[degrading]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[degrading]] != null && [[degrading]] . isAuthenticated ( ) && ! ( [[degrading]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 159 ---------------------------------------------
Renders a request . --> Handles delete request . --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long [[contactId]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( [[contactId]] ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView deletePermission ( @ RequestParam ( "contactId" ) long [[yakuza]] , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( [[yakuza]] ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
[Succeeded / Failed / Skipped / Total] 134 / 24 / 2 / 160:  16%|█▌        | 160/1000 [3:16:51<17:13:27, 73.82s/it][Succeeded / Failed / Skipped / Total] 134 / 24 / 2 / 160:  16%|█▌        | 161/1000 [3:17:00<17:06:36, 73.42s/it][Succeeded / Failed / Skipped / Total] 135 / 24 / 2 / 161:  16%|█▌        | 161/1000 [3:17:00<17:06:36, 73.42s/it][Succeeded / Failed / Skipped / Total] 135 / 24 / 2 / 161:  16%|█▌        | 162/1000 [3:17:02<16:59:14, 72.98s/it][Succeeded / Failed / Skipped / Total] 136 / 24 / 2 / 162:  16%|█▌        | 162/1000 [3:17:02<16:59:14, 72.98s/it][Succeeded / Failed / Skipped / Total] 136 / 24 / 2 / 162:  16%|█▋        | 163/1000 [3:17:29<16:54:05, 72.70s/it][Succeeded / Failed / Skipped / Total] 137 / 24 / 2 / 163:  16%|█▋        | 163/1000 [3:17:29<16:54:05, 72.70s/it][Succeeded / Failed / Skipped / Total] 137 / 24 / 2 / 163:  16%|█▋        | 164/1000 [3:17:54<16:48:52, 72.41s/it][Succeeded / Failed / Skipped / Total] 138 / 24 / 2 / 164:  16%|█▋        | 164/1000 [3:17:54<16:48:52, 72.41s/it][Succeeded / Failed / Skipped / Total] 138 / 24 / 2 / 164:  16%|█▋        | 165/1000 [3:18:22<16:43:54, 72.14s/it]--------------------------------------------- Result 160 ---------------------------------------------
On login success . --> [[[FAILED]]]

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void onLoginSuccess ( HttpServletRequest request , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , request , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 161 ---------------------------------------------
Get the values for a given attribute . --> Gets attributes . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[commence]] ( String name ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( name ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 162 ---------------------------------------------
Creates a UserDetailsResourceFactory from a String . --> Factory method for creating UserDetailsResourceFactory . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[users]] ) { InMemoryResource resource = new InMemoryResource ( [[users]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean fromString ( String [[katzenjammer]] ) { InMemoryResource resource = new InMemoryResource ( [[katzenjammer]] ) ; return fromResource ( resource ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 163 ---------------------------------------------
Display admin page for contact --> This method is used to show an invite request --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[moonchild]] ( @ RequestParam ( "contactId" ) int contactId ) { Contact contact = contactManager . getById ( Long . valueOf ( contactId ) ) ; Acl [[skateboarding]] = aclService . readAclById ( new ObjectIdentityImpl ( contact ) ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "acl" , [[skateboarding]] ) ; return new ModelAndView ( "adminPermission" , "model" , model ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 164 ---------------------------------------------
Add a permission --> This method is used for creating a PostimePermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission addPermission , BindingResult result , ModelMap [[model]] ) { addPermissionValidator . validate ( [[addPermission]] , result ) ; if ( result . hasErrors ( ) ) { [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[addPermission]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[pastime]] ( AddPermission addPermission , BindingResult result , ModelMap [[volunteers]] ) { addPermissionValidator . validate ( [[pastime]] , result ) ; if ( result . hasErrors ( ) ) { [[volunteers]] . put ( "recipients" , listRecipients ( ) ) ; [[volunteers]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[pastime]] . getRecipient ( ) ) ; Permission permission = permissionFactory . buildFromMask ( [[pastime]] . getPermission ( ) ) ; try { contactManager . addPermission ( [[pastime]] . getContact ( ) , sid , permission ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; result . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; [[volunteers]] . put ( "recipients" , listRecipients ( ) ) ; [[volunteers]] . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 165 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 139 / 24 / 2 / 165:  16%|█▋        | 165/1000 [3:18:22<16:43:54, 72.14s/it][Succeeded / Failed / Skipped / Total] 139 / 24 / 2 / 165:  17%|█▋        | 166/1000 [3:18:40<16:38:07, 71.81s/it][Succeeded / Failed / Skipped / Total] 140 / 24 / 2 / 166:  17%|█▋        | 166/1000 [3:18:40<16:38:07, 71.81s/it][Succeeded / Failed / Skipped / Total] 140 / 24 / 2 / 166:  17%|█▋        | 167/1000 [3:19:03<16:32:52, 71.52s/it][Succeeded / Failed / Skipped / Total] 141 / 24 / 2 / 167:  17%|█▋        | 167/1000 [3:19:03<16:32:52, 71.52s/it][Succeeded / Failed / Skipped / Total] 141 / 24 / 2 / 167:  17%|█▋        | 168/1000 [3:19:11<16:26:27, 71.14s/it][Succeeded / Failed / Skipped / Total] 142 / 24 / 2 / 168:  17%|█▋        | 168/1000 [3:19:11<16:26:27, 71.14s/it][Succeeded / Failed / Skipped / Total] 142 / 24 / 2 / 168:  17%|█▋        | 169/1000 [3:19:25<16:20:36, 70.80s/it][Succeeded / Failed / Skipped / Total] 142 / 25 / 2 / 169:  17%|█▋        | 169/1000 [3:19:25<16:20:36, 70.80s/it][Succeeded / Failed / Skipped / Total] 142 / 25 / 2 / 169:  17%|█▋        | 170/1000 [3:19:37<16:14:39, 70.46s/it][Succeeded / Failed / Skipped / Total] 143 / 25 / 2 / 170:  17%|█▋        | 170/1000 [3:19:37<16:14:39, 70.46s/it][Succeeded / Failed / Skipped / Total] 143 / 25 / 2 / 170:  17%|█▋        | 171/1000 [3:20:32<16:12:10, 70.36s/it][Succeeded / Failed / Skipped / Total] 144 / 25 / 2 / 171:  17%|█▋        | 171/1000 [3:20:32<16:12:10, 70.36s/it][Succeeded / Failed / Skipped / Total] 144 / 25 / 2 / 171:  17%|█▋        | 172/1000 [3:20:48<16:06:40, 70.05s/it][Succeeded / Failed / Skipped / Total] 145 / 25 / 2 / 172:  17%|█▋        | 172/1000 [3:20:48<16:06:40, 70.05s/it][Succeeded / Failed / Skipped / Total] 145 / 25 / 2 / 172:  17%|█▋        | 173/1000 [3:20:53<16:00:21, 69.68s/it]Decode the given bytes . --> Decodes transactions --> Socre: 1.0

[[[[Adv]]]]: public static String decode ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String decode ( byte [ ] [[financial]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[financial]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 166 ---------------------------------------------
Encodes a string into a byte array . --> Encode a CharSequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[string]] ) { try { ByteBuffer [[bytes]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ [[bytes]] . limit ( ) ] ; System . arraycopy ( [[bytes]] . array ( ) , 0 , bytesCopy , 0 , [[bytes]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] encode ( CharSequence [[anorexic]] ) { try { ByteBuffer [[deutsche]] = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[anorexic]] ) ) ; byte [ ] bytesCopy = new byte [ [[deutsche]] . limit ( ) ] ; System . arraycopy ( [[deutsche]] . array ( ) , 0 , bytesCopy , 0 , [[deutsche]] . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 167 ---------------------------------------------
Generates a CSRF token . --> Generate an IR signature for the given punctuation . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . [[delegate]] . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[irons]] ( HttpServletRequest [[punctuation]] ) { return wrap ( [[punctuation]] , this . [[clamour]] . generateToken ( [[punctuation]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 168 ---------------------------------------------
Returns the first value of the specified attribute . --> Convenience method to retrieve an ashley address . --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[ashley]] ( String [[norwich]] ) { List < String > result = getAttributeValues ( [[norwich]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 169 ---------------------------------------------
Display the add permission for a contact . --> [[[FAILED]]]

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView displayAddPermissionPageForContact ( @ RequestParam ( "contactId" ) long contactId ) { Contact contact = contactManager . getById ( contactId ) ; AddPermission addPermission = new AddPermission ( ) ; addPermission . setContact ( contact ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "addPermission" , addPermission ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , model ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 170 ---------------------------------------------
Gets the role prefix . --> Gets the cargo prefix for the cargo --> Socre: 1.0

[[[[Adv]]]]: private static String getRoleWithDefaultPrefix ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String getRoleWithDefaultPrefix ( String [[sunglasses]] , String [[cargo]] ) { if ( [[cargo]] == null ) { return [[cargo]] ; } if ( [[sunglasses]] == null || [[sunglasses]] . length ( ) == 0 ) { return [[cargo]] ; } if ( [[cargo]] . startsWith ( [[sunglasses]] ) ) { return [[cargo]] ; } return [[sunglasses]] + [[cargo]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 171 ---------------------------------------------
Find configuration attributes . --> Searches for attributes that have been requested --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[method]] , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[method]] , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > findAttributes ( Method [[folke]] , Class < ? > [[bulky]] ) { if ( [[bulky]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( [[folke]] , [[bulky]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 172 ---------------------------------------------
Get all config attributes . --> Obtain all ConfigAttributes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > getAllConfigAttributes ( ) { Set < ConfigAttribute > [[addiction]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[looters]] : methodMap . values ( ) ) { [[addiction]] . addAll ( [[looters]] ) ; } return [[addiction]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 173 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 146 / 25 / 2 / 173:  17%|█▋        | 173/1000 [3:20:53<16:00:21, 69.68s/it][Succeeded / Failed / Skipped / Total] 146 / 25 / 2 / 173:  17%|█▋        | 174/1000 [3:20:57<15:54:00, 69.30s/it][Succeeded / Failed / Skipped / Total] 147 / 25 / 2 / 174:  17%|█▋        | 174/1000 [3:20:57<15:54:00, 69.30s/it][Succeeded / Failed / Skipped / Total] 147 / 25 / 2 / 174:  18%|█▊        | 175/1000 [3:21:47<15:51:18, 69.19s/it][Succeeded / Failed / Skipped / Total] 148 / 25 / 2 / 175:  18%|█▊        | 175/1000 [3:21:47<15:51:18, 69.19s/it][Succeeded / Failed / Skipped / Total] 148 / 25 / 2 / 175:  18%|█▊        | 176/1000 [3:22:02<15:45:55, 68.88s/it][Succeeded / Failed / Skipped / Total] 149 / 25 / 2 / 176:  18%|█▊        | 176/1000 [3:22:02<15:45:55, 68.88s/it][Succeeded / Failed / Skipped / Total] 149 / 25 / 2 / 176:  18%|█▊        | 177/1000 [3:22:32<15:41:47, 68.66s/it][Succeeded / Failed / Skipped / Total] 150 / 25 / 2 / 177:  18%|█▊        | 177/1000 [3:22:32<15:41:47, 68.66s/it][Succeeded / Failed / Skipped / Total] 150 / 25 / 2 / 177:  18%|█▊        | 178/1000 [3:22:56<15:37:10, 68.41s/it][Succeeded / Failed / Skipped / Total] 151 / 25 / 2 / 178:  18%|█▊        | 178/1000 [3:22:56<15:37:10, 68.41s/it][Succeeded / Failed / Skipped / Total] 151 / 25 / 2 / 178:  18%|█▊        | 179/1000 [3:23:55<15:35:18, 68.35s/it][Succeeded / Failed / Skipped / Total] 152 / 25 / 2 / 179:  18%|█▊        | 179/1000 [3:23:55<15:35:18, 68.35s/it][Succeeded / Failed / Skipped / Total] 152 / 25 / 2 / 179:  18%|█▊        | 180/1000 [3:24:03<15:29:35, 68.02s/it]Gets random contact . --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[rnd]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[rnd]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[fabius]] = new Random ( ) ; List < Contact > contacts = contactDao . findAll ( ) ; int getNumber = [[fabius]] . nextInt ( contacts . size ( ) ) ; return contacts . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 174 ---------------------------------------------
Registers a contact . --> Redirect to URL --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact form , BindingResult [[result]] ) { validator . validate ( form , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[beetroot]] ( WebContact form , BindingResult [[cherokees]] ) { validator . validate ( form , [[cherokees]] ) ; if ( [[cherokees]] . hasErrors ( ) ) { return "add" ; } Contact contact = new Contact ( form . getName ( ) , form . getEmail ( ) ) ; contactManager . create ( contact ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 175 ---------------------------------------------
Specifies that any request has been configured . --> Eliminate the scheme matcher --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . [[anyRequestConfigured]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[anyRequestConfigured]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[christopher]] ( ) { Assert . state ( ! this . [[glide]] , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . [[glide]] = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 176 ---------------------------------------------
Adds a secure method . --> Exceptions that are likely to be accessible --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + attr + "]" ) ; } this . [[methodMap]] . put ( [[method]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[comprehensible]] ( RegisteredMethod [[foremen]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[foremen]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[foremen]] + "] with attributes [" + attr + "]" ) ; } this . [[exceptions]] . put ( [[foremen]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 177 ---------------------------------------------
Looks up parameter names for the given parameter . --> Lookup all parameters of a given type --> Socre: 1.0

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[parameterCount]] = parameterAnnotations . length ; String [ ] [[paramNames]] = new String [ [[parameterCount]] ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < [[parameterCount]] ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String [[parameterName]] = findParameterName ( annotations ) ; if ( [[parameterName]] != null ) { found = "True" == "True" ; [[paramNames]] [ i ] = [[parameterName]] ; } } return found ? [[paramNames]] : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int [[jarod]] = parameterAnnotations . length ; String [ ] [[picturesque]] = new String [ [[jarod]] ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < [[jarod]] ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String [[grocery]] = findParameterName ( annotations ) ; if ( [[grocery]] != null ) { found = "True" == "True" ; [[picturesque]] [ i ] = [[grocery]] ; } } return found ? [[picturesque]] : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 178 ---------------------------------------------
Returns true if the mapped name matches the mapped name --> local version --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[localize]] ( String [[batboy]] , String [[chums]] ) { return ( [[chums]] . endsWith ( "*" ) && [[batboy]] . startsWith ( [[chums]] . substring ( 0 , [[chums]] . length ( ) - 1 ) ) ) || ( [[chums]] . startsWith ( "*" ) && [[batboy]] . endsWith ( [[chums]] . substring ( 1 , [[chums]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 179 ---------------------------------------------
Remove authentication attributes from session . --> We need to call this method when we need to clean up --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession session = [[request]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[neurasthenia]] ( HttpServletRequest [[borelli]] ) { HttpSession session = [[borelli]] . getSession ( "False" != "False" ) ; if ( session == null ) { return ; } session . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 180 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 153 / 25 / 2 / 180:  18%|█▊        | 180/1000 [3:24:03<15:29:35, 68.02s/it][Succeeded / Failed / Skipped / Total] 153 / 25 / 2 / 180:  18%|█▊        | 181/1000 [3:24:31<15:25:26, 67.80s/it][Succeeded / Failed / Skipped / Total] 154 / 25 / 2 / 181:  18%|█▊        | 181/1000 [3:24:31<15:25:26, 67.80s/it][Succeeded / Failed / Skipped / Total] 154 / 25 / 2 / 181:  18%|█▊        | 182/1000 [3:25:15<15:22:33, 67.67s/it][Succeeded / Failed / Skipped / Total] 155 / 25 / 2 / 182:  18%|█▊        | 182/1000 [3:25:15<15:22:33, 67.67s/it][Succeeded / Failed / Skipped / Total] 155 / 25 / 2 / 182:  18%|█▊        | 183/1000 [3:25:19<15:16:41, 67.32s/it][Succeeded / Failed / Skipped / Total] 156 / 25 / 2 / 183:  18%|█▊        | 183/1000 [3:25:19<15:16:41, 67.32s/it][Succeeded / Failed / Skipped / Total] 156 / 25 / 2 / 183:  18%|█▊        | 184/1000 [3:25:33<15:11:35, 67.03s/it][Succeeded / Failed / Skipped / Total] 157 / 25 / 2 / 184:  18%|█▊        | 184/1000 [3:25:33<15:11:35, 67.03s/it][Succeeded / Failed / Skipped / Total] 157 / 25 / 2 / 184:  18%|█▊        | 185/1000 [3:25:33<15:05:33, 66.67s/it][Succeeded / Failed / Skipped / Total] 157 / 25 / 3 / 185:  18%|█▊        | 185/1000 [3:25:33<15:05:33, 66.67s/it][Succeeded / Failed / Skipped / Total] 157 / 25 / 3 / 185:  19%|█▊        | 186/1000 [3:27:25<15:07:47, 66.91s/it][Succeeded / Failed / Skipped / Total] 157 / 26 / 3 / 186:  19%|█▊        | 186/1000 [3:27:25<15:07:47, 66.91s/it][Succeeded / Failed / Skipped / Total] 157 / 26 / 3 / 186:  19%|█▊        | 187/1000 [3:28:09<15:05:01, 66.79s/it]Check the filter stack . --> Check stack . --> Socre: 1.0

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void checkFilterStack ( List < Filter > [[anticipates]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[anticipates]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[anticipates]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[anticipates]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[anticipates]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[anticipates]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[anticipates]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[anticipates]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[anticipates]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 181 ---------------------------------------------
Handle bind request . --> Helper method for debugging --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String userDn , String [[username]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[mathura]] ( String userDn , String [[foetus]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + userDn + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 182 ---------------------------------------------
Retrieves a field from the given class . --> Lighted in light mode --> Socre: 1.0

[[[[Adv]]]]: public static Field [[getField]] ( Class < ? > [[clazz]] , String [[fieldName]] ) throws IllegalStateException { Assert . notNull ( [[clazz]] , "Class required" ) ; Assert . hasText ( [[fieldName]] , "Field name required" ) ; try { return [[clazz]] . getDeclaredField ( [[fieldName]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field [[lighted]] ( Class < ? > [[hiko]] , String [[ironies]] ) throws IllegalStateException { Assert . notNull ( [[hiko]] , "Class required" ) ; Assert . hasText ( [[ironies]] , "Field name required" ) ; try { return [[hiko]] . getDeclaredField ( [[ironies]] ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 183 ---------------------------------------------
Extracts the prefix . --> Package - private for testing --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = encPass . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[sausage]] ( String encPass ) { if ( ! encPass . startsWith ( "{" ) ) { return null ; } int [[statements]] = encPass . lastIndexOf ( ' ' ) ; if ( [[statements]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return encPass . substring ( 0 , [[statements]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 184 ---------------------------------------------
Create redirect url . --> Get notepaper --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[loginUrl]] , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[notepaper]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . [[clairvoyant]] , this . serviceProperties . getServiceParameter ( ) , serviceUrl , this . serviceProperties . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 185 ---------------------------------------------
Compares two byte arrays --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 186 ---------------------------------------------
Create the service URL . --> [[[FAILED]]]

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String createServiceUrl ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 187 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 158 / 26 / 3 / 187:  19%|█▊        | 187/1000 [3:28:09<15:05:01, 66.79s/it][Succeeded / Failed / Skipped / Total] 158 / 26 / 3 / 187:  19%|█▉        | 188/1000 [3:28:47<15:01:47, 66.63s/it][Succeeded / Failed / Skipped / Total] 159 / 26 / 3 / 188:  19%|█▉        | 188/1000 [3:28:47<15:01:47, 66.63s/it][Succeeded / Failed / Skipped / Total] 159 / 26 / 3 / 188:  19%|█▉        | 189/1000 [3:29:30<14:59:01, 66.51s/it][Succeeded / Failed / Skipped / Total] 160 / 26 / 3 / 189:  19%|█▉        | 189/1000 [3:29:30<14:59:01, 66.51s/it][Succeeded / Failed / Skipped / Total] 160 / 26 / 3 / 189:  19%|█▉        | 190/1000 [3:29:42<14:54:01, 66.22s/it][Succeeded / Failed / Skipped / Total] 160 / 27 / 3 / 190:  19%|█▉        | 190/1000 [3:29:42<14:54:01, 66.22s/it][Succeeded / Failed / Skipped / Total] 160 / 27 / 3 / 190:  19%|█▉        | 191/1000 [3:30:07<14:50:00, 66.01s/it][Succeeded / Failed / Skipped / Total] 161 / 27 / 3 / 191:  19%|█▉        | 191/1000 [3:30:07<14:50:00, 66.01s/it][Succeeded / Failed / Skipped / Total] 161 / 27 / 3 / 191:  19%|█▉        | 192/1000 [3:30:10<14:44:30, 65.68s/it][Succeeded / Failed / Skipped / Total] 161 / 28 / 3 / 192:  19%|█▉        | 192/1000 [3:30:10<14:44:30, 65.68s/it][Succeeded / Failed / Skipped / Total] 161 / 28 / 3 / 192:  19%|█▉        | 193/1000 [3:30:15<14:39:08, 65.36s/it]Gets the registered types . --> Detail from sairo --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[extractorMap]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[detachment]] ( ) { Set < Class < ? extends Throwable > > typeList = this . [[saigo]] . keySet ( ) ; return typeList . toArray ( new Class [ typeList . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 188 ---------------------------------------------
Sets the default failure url . --> set apoale --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String [[defaultFailureUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[defaultFailureUrl]] ) , ( ) -> "'" + [[defaultFailureUrl]] + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = [[defaultFailureUrl]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[apogee]] ( String [[zhao]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[zhao]] ) , ( ) -> "'" + [[zhao]] + "' is not a valid redirect URL" ) ; this . [[search]] = [[zhao]] ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 189 ---------------------------------------------
Sets the resolver that will resolve hidden inputs . --> Specifies out what you are using outlands --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[outlands]] ( Function < HttpServletRequest , Map < String , String > > resolveHiddenInputs ) { Assert . notNull ( resolveHiddenInputs , "resolveHiddenInputs cannot be null" ) ; this . [[hubbard]] = resolveHiddenInputs ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 190 ---------------------------------------------
Invoked before the authentication process . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException [[arg2]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[implausible]] ( HttpServletRequest request , HttpServletResponse response , AuthenticationException [[debutantes]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } response . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 191 ---------------------------------------------
Convert the given result set to a serializable identifier . --> Convert a JDBC ResultSet to a Serializable Object --> Socre: 1.0

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[identifier]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[identifier]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[identifier]] = convertFromStringTo ( ( String ) [[identifier]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable identifierFrom ( Serializable [[gud]] , ResultSet resultSet ) throws SQLException { if ( isString ( [[gud]] ) && hasValidClassIdType ( resultSet ) && canConvertFromStringTo ( classIdTypeFrom ( resultSet ) ) ) { [[gud]] = convertFromStringTo ( ( String ) [[gud]] , classIdTypeFrom ( resultSet ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 192 ---------------------------------------------
Registers the access manager . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String registerAccessManager ( ParserContext pc , boolean jsr250Enabled , BeanDefinition expressionVoter ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( expressionVoter != null ) { voters . add ( expressionVoter ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String id = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , id ) ) ; return id ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 193 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 162 / 28 / 3 / 193:  19%|█▉        | 193/1000 [3:30:15<14:39:08, 65.36s/it][Succeeded / Failed / Skipped / Total] 162 / 28 / 3 / 193:  19%|█▉        | 194/1000 [3:31:01<14:36:43, 65.27s/it][Succeeded / Failed / Skipped / Total] 163 / 28 / 3 / 194:  19%|█▉        | 194/1000 [3:31:01<14:36:43, 65.27s/it][Succeeded / Failed / Skipped / Total] 163 / 28 / 3 / 194:  20%|█▉        | 195/1000 [3:32:41<14:38:02, 65.44s/it][Succeeded / Failed / Skipped / Total] 164 / 28 / 3 / 195:  20%|█▉        | 195/1000 [3:32:41<14:38:02, 65.44s/it][Succeeded / Failed / Skipped / Total] 164 / 28 / 3 / 195:  20%|█▉        | 196/1000 [3:33:20<14:35:06, 65.31s/it][Succeeded / Failed / Skipped / Total] 165 / 28 / 3 / 196:  20%|█▉        | 196/1000 [3:33:20<14:35:06, 65.31s/it][Succeeded / Failed / Skipped / Total] 165 / 28 / 3 / 196:  20%|█▉        | 197/1000 [3:33:33<14:30:30, 65.04s/it][Succeeded / Failed / Skipped / Total] 166 / 28 / 3 / 197:  20%|█▉        | 197/1000 [3:33:33<14:30:30, 65.04s/it][Succeeded / Failed / Skipped / Total] 166 / 28 / 3 / 197:  20%|█▉        | 198/1000 [3:33:40<14:25:28, 64.75s/it][Succeeded / Failed / Skipped / Total] 167 / 28 / 3 / 198:  20%|█▉        | 198/1000 [3:33:40<14:25:28, 64.75s/it][Succeeded / Failed / Skipped / Total] 167 / 28 / 3 / 198:  20%|█▉        | 199/1000 [3:33:45<14:20:22, 64.45s/it]Retrieves the cause of the given exception . --> returns null if no exception found --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[entry]] . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[valjean]] ( Throwable throwable ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[promos]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > throwableType = [[promos]] . getKey ( ) ; if ( throwableType . isInstance ( throwable ) ) { ThrowableCauseExtractor [[desperadoes]] = [[promos]] . getValue ( ) ; return [[desperadoes]] . extractCause ( throwable ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 194 ---------------------------------------------
Returns a list of OpenIDAttributes matching the given identifier . --> Find all OpenID Attribute Attribute --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[zod]] ( String identifier ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > entry : idToAttributes . entrySet ( ) ) { if ( entry . getKey ( ) . matcher ( identifier ) . matches ( ) ) { return entry . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 195 ---------------------------------------------
Converts a list of user authorities to a set of authorities . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > [[set]] = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[userAuthorities]] ) { [[set]] . add ( [[authority]] . getAuthority ( ) ) ; } return [[set]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[rothman]] ( Collection < ? extends GrantedAuthority > [[spumoni]] ) { Assert . notNull ( [[spumoni]] , "userAuthorities cannot be null" ) ; Set < String > [[boilers]] = new HashSet <> ( [[spumoni]] . size ( ) ) ; for ( GrantedAuthority [[sleazy]] : [[spumoni]] ) { [[boilers]] . add ( [[sleazy]] . getAuthority ( ) ) ; } return [[boilers]] ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 196 ---------------------------------------------
Updates the owner identity of the given ACL . --> updateObjectIdentity --> Socre: 1.0

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl [[acl]] ) { Long [[parentId]] = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "True" == "True" ) ; int [[count]] = jdbcOperations . update ( updateObjectIdentity , [[parentId]] , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void updateObjectIdentity ( MutableAcl [[baaing]] ) { Long [[ifthey]] = null ; if ( [[baaing]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[baaing]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[baaing]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[ifthey]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[baaing]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[baaing]] . getOwner ( ) , "True" == "True" ) ; int [[gonçalves]] = jdbcOperations . update ( updateObjectIdentity , [[ifthey]] , ownerSid , Boolean . valueOf ( [[baaing]] . isEntriesInheriting ( ) ) , [[baaing]] . getId ( ) ) ; if ( [[gonçalves]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 197 ---------------------------------------------
Returns a Matcher that matches any of the server web exchange . --> Creates an instance of Apache API WebExchange matcher . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anubis]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 198 ---------------------------------------------
Build the request URL . --> helper method to generate HttpUrl --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String [[servletPath]] , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[servletPath]] != null ) { url . append ( [[servletPath]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[hiko]] ( String [[resonates]] , String requestURI , String contextPath , String pathInfo , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( [[resonates]] != null ) { url . append ( [[resonates]] ) ; if ( pathInfo != null ) { url . append ( pathInfo ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 199 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 168 / 28 / 3 / 199:  20%|█▉        | 199/1000 [3:33:45<14:20:22, 64.45s/it][Succeeded / Failed / Skipped / Total] 168 / 28 / 3 / 199:  20%|██        | 200/1000 [3:34:35<14:18:22, 64.38s/it][Succeeded / Failed / Skipped / Total] 168 / 29 / 3 / 200:  20%|██        | 200/1000 [3:34:35<14:18:22, 64.38s/it][Succeeded / Failed / Skipped / Total] 168 / 29 / 3 / 200:  20%|██        | 201/1000 [3:34:35<14:13:03, 64.06s/it][Succeeded / Failed / Skipped / Total] 169 / 29 / 3 / 201:  20%|██        | 201/1000 [3:34:35<14:13:03, 64.06s/it][Succeeded / Failed / Skipped / Total] 169 / 29 / 3 / 201:  20%|██        | 202/1000 [3:34:43<14:08:17, 63.78s/it][Succeeded / Failed / Skipped / Total] 170 / 29 / 3 / 202:  20%|██        | 202/1000 [3:34:43<14:08:17, 63.78s/it][Succeeded / Failed / Skipped / Total] 170 / 29 / 3 / 202:  20%|██        | 203/1000 [3:35:08<14:04:41, 63.59s/it][Succeeded / Failed / Skipped / Total] 171 / 29 / 3 / 203:  20%|██        | 203/1000 [3:35:08<14:04:41, 63.59s/it][Succeeded / Failed / Skipped / Total] 171 / 29 / 3 / 203:  20%|██        | 204/1000 [3:35:26<14:00:37, 63.36s/it]Deletes the object identity . --> Encode a polynomial --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid owner ) { Long [[sidId]] = createOrRetrieveSidPrimaryKey ( owner , "[[True]]" == "[[True]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[True]]" == "[[True]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[sidId]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[aaaah]] ( ObjectIdentity object , Sid owner ) { Long [[wahl]] = createOrRetrieveSidPrimaryKey ( owner , "[[Pelle]]" == "[[Pelle]]" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "[[Pelle]]" == "[[Pelle]]" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , [[wahl]] , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 200 ---------------------------------------------
Checks if the given string is an absolute URL . --> [[[FAILED]]]

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "False" != "False" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[skyrocketed]] ( String [[succeeded]] ) { if ( [[succeeded]] == null ) { return "False" != "False" ; } final Pattern [[REVOLTS]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[REVOLTS]] . matcher ( [[succeeded]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 201 ---------------------------------------------
Saves the request . --> Generate bono --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest request , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "[[False]]" != "[[False]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[bono]] ( HttpServletRequest request , HttpServletResponse [[samba]] ) { if ( requestMatcher . matches ( request ) ) { DefaultSavedRequest savedRequest = new DefaultSavedRequest ( request , portResolver ) ; if ( createSessionAllowed || request . getSession ( "[[Liqueur]]" != "[[Liqueur]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Create entries . --> Performs timor --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement [[stmt]] , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; [[stmt]] . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; [[stmt]] . setInt ( 2 , i ) ; [[stmt]] . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; [[stmt]] . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; [[stmt]] . setBoolean ( 5 , entry . isGranting ( ) ) ; [[stmt]] . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; [[stmt]] . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[timor]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement [[ageless]] , int i ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( i ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; [[ageless]] . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; [[ageless]] . setInt ( 2 , i ) ; [[ageless]] . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; [[ageless]] . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; [[ageless]] . setBoolean ( 5 , entry . isGranting ( ) ) ; [[ageless]] . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; [[ageless]] . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 203 ---------------------------------------------
Write headers to the response . --> write headers --> Socre: 1.0

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void writeHeaders ( HttpServletRequest request , HttpServletResponse response ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[cartilage]] = this . allowFromStrategy . getAllowFromValue ( request ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[cartilage]] ) ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[cartilage]] != null ) { if ( ! response . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { response . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[cartilage]] ) ; } } } else { response . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 204 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 172 / 29 / 3 / 204:  20%|██        | 204/1000 [3:35:26<14:00:37, 63.36s/it][Succeeded / Failed / Skipped / Total] 172 / 29 / 3 / 204:  20%|██        | 205/1000 [3:35:33<13:55:58, 63.09s/it][Succeeded / Failed / Skipped / Total] 173 / 29 / 3 / 205:  20%|██        | 205/1000 [3:35:33<13:55:58, 63.09s/it][Succeeded / Failed / Skipped / Total] 173 / 29 / 3 / 205:  21%|██        | 206/1000 [3:36:37<13:54:56, 63.09s/it][Succeeded / Failed / Skipped / Total] 174 / 29 / 3 / 206:  21%|██        | 206/1000 [3:36:37<13:54:56, 63.09s/it][Succeeded / Failed / Skipped / Total] 174 / 29 / 3 / 206:  21%|██        | 207/1000 [3:36:48<13:50:35, 62.84s/it][Succeeded / Failed / Skipped / Total] 175 / 29 / 3 / 207:  21%|██        | 207/1000 [3:36:48<13:50:35, 62.84s/it][Succeeded / Failed / Skipped / Total] 175 / 29 / 3 / 207:  21%|██        | 208/1000 [3:37:17<13:47:21, 62.68s/it][Succeeded / Failed / Skipped / Total] 176 / 29 / 3 / 208:  21%|██        | 208/1000 [3:37:17<13:47:21, 62.68s/it][Succeeded / Failed / Skipped / Total] 176 / 29 / 3 / 208:  21%|██        | 209/1000 [3:37:37<13:43:37, 62.48s/it][Succeeded / Failed / Skipped / Total] 177 / 29 / 3 / 209:  21%|██        | 209/1000 [3:37:37<13:43:37, 62.48s/it][Succeeded / Failed / Skipped / Total] 177 / 29 / 3 / 209:  21%|██        | 210/1000 [3:37:40<13:38:51, 62.19s/it][Succeeded / Failed / Skipped / Total] 178 / 29 / 3 / 210:  21%|██        | 210/1000 [3:37:40<13:38:51, 62.19s/it][Succeeded / Failed / Skipped / Total] 178 / 29 / 3 / 210:  21%|██        | 211/1000 [3:37:42<13:34:03, 61.91s/it][Succeeded / Failed / Skipped / Total] 179 / 29 / 3 / 211:  21%|██        | 211/1000 [3:37:42<13:34:03, 61.91s/it][Succeeded / Failed / Skipped / Total] 179 / 29 / 3 / 211:  21%|██        | 212/1000 [3:37:49<13:29:37, 61.65s/it][Succeeded / Failed / Skipped / Total] 180 / 29 / 3 / 212:  21%|██        | 212/1000 [3:37:49<13:29:37, 61.65s/it][Succeeded / Failed / Skipped / Total] 180 / 29 / 3 / 212:  21%|██▏       | 213/1000 [3:37:53<13:25:03, 61.38s/it]Determines the target URL . --> Override default targetUrl if not use defaultTargetUrl --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[abandoning]] ( HttpServletRequest request , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 205 ---------------------------------------------
Creates a new WebExchangeMatcher for the given paths . --> Parse path matchers --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( patterns . length ) ; for ( String [[pattern]] : patterns ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , method ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher pathMatchers ( HttpMethod method , String ... patterns ) { List < ServerWebExchangeMatcher > [[misinterpret]] = new ArrayList <> ( patterns . length ) ; for ( String [[corazón]] : patterns ) { [[misinterpret]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[corazón]] , method ) ) ; } return new OrServerWebExchangeMatcher ( [[misinterpret]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 206 ---------------------------------------------
Determines the target URL . --> Auxiliary method . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[aici]] ( HttpServletRequest request , HttpServletResponse response , Authentication [[rivière]] ) { return [[aici]] ( request , response ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 207 ---------------------------------------------
Creates a decryptor . --> defector --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( stronger ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence [[sybil]] , CharSequence [[zeno]] ) { return new HexEncodingTextEncryptor ( stronger ( [[sybil]] , [[zeno]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 208 ---------------------------------------------
Creates a text encryptor . --> Constructor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[corazón]] ( CharSequence [[tsuyoshi]] , CharSequence salt ) { return new HexEncodingTextEncryptor ( standard ( [[tsuyoshi]] , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 209 ---------------------------------------------
Sets the target URL parameter . --> Specify drift --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[micromachine]] ( String [[dolorosa]] ) { if ( [[dolorosa]] != null ) { Assert . hasText ( [[dolorosa]] , "targetUrlParameter cannot be empty" ) ; } this . [[driftwood]] = [[dolorosa]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 210 ---------------------------------------------
Returns a text encryptor that encodes the specified password . --> nechryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[nephilim]] ( CharSequence [[stools]] , CharSequence [[brasserie]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[stools]] . toString ( ) , [[brasserie]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 211 ---------------------------------------------
Gets the current date . --> Get cashiers --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[cashiers]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 212 ---------------------------------------------
Update cache with given key --> Update the menu with the given key --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[value]] ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void updateCache ( HashMap cache , Object key , Object [[appetizer]] ) { if ( [[appetizer]] == null ) { return ; } if ( cache . size ( ) > 1000 ) { cache . clear ( ) ; } cache . put ( key , [[appetizer]] ) ; }
[[[[Nl]]]]: Updates cache .
[Succeeded / Failed / Skipped / Total] 181 / 29 / 3 / 213:  21%|██▏       | 213/1000 [3:37:53<13:25:03, 61.38s/it][Succeeded / Failed / Skipped / Total] 181 / 29 / 3 / 213:  21%|██▏       | 214/1000 [3:38:48<13:23:40, 61.35s/it][Succeeded / Failed / Skipped / Total] 182 / 29 / 3 / 214:  21%|██▏       | 214/1000 [3:38:48<13:23:40, 61.35s/it][Succeeded / Failed / Skipped / Total] 182 / 29 / 3 / 214:  22%|██▏       | 215/1000 [3:39:06<13:20:00, 61.15s/it][Succeeded / Failed / Skipped / Total] 183 / 29 / 3 / 215:  22%|██▏       | 215/1000 [3:39:06<13:20:00, 61.15s/it][Succeeded / Failed / Skipped / Total] 183 / 29 / 3 / 215:  22%|██▏       | 216/1000 [3:39:12<13:15:37, 60.89s/it][Succeeded / Failed / Skipped / Total] 184 / 29 / 3 / 216:  22%|██▏       | 216/1000 [3:39:12<13:15:37, 60.89s/it][Succeeded / Failed / Skipped / Total] 184 / 29 / 3 / 216:  22%|██▏       | 217/1000 [3:39:13<13:11:02, 60.62s/it][Succeeded / Failed / Skipped / Total] 185 / 29 / 3 / 217:  22%|██▏       | 217/1000 [3:39:13<13:11:02, 60.62s/it][Succeeded / Failed / Skipped / Total] 185 / 29 / 3 / 217:  22%|██▏       | 218/1000 [3:40:33<13:11:11, 60.71s/it][Succeeded / Failed / Skipped / Total] 186 / 29 / 3 / 218:  22%|██▏       | 218/1000 [3:40:33<13:11:11, 60.71s/it][Succeeded / Failed / Skipped / Total] 186 / 29 / 3 / 218:  22%|██▏       | 219/1000 [3:40:51<13:07:36, 60.51s/it][Succeeded / Failed / Skipped / Total] 187 / 29 / 3 / 219:  22%|██▏       | 219/1000 [3:40:51<13:07:36, 60.51s/it][Succeeded / Failed / Skipped / Total] 187 / 29 / 3 / 219:  22%|██▏       | 220/1000 [3:40:51<13:03:01, 60.23s/it][Succeeded / Failed / Skipped / Total] 187 / 29 / 4 / 220:  22%|██▏       | 220/1000 [3:40:51<13:03:01, 60.23s/it][Succeeded / Failed / Skipped / Total] 187 / 29 / 4 / 220:  22%|██▏       | 221/1000 [3:41:16<12:59:56, 60.07s/it]--------------------------------------------- Result 213 ---------------------------------------------
Build the distinguished name . --> Build a DistinguishedName --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[username]] ) { DistinguishedName [[dn]] = new DistinguishedName ( userDnBase ) ; [[dn]] . add ( usernameAttribute , [[username]] ) ; return [[dn]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName buildDn ( String [[berle]] ) { DistinguishedName [[haydar]] = new DistinguishedName ( userDnBase ) ; [[haydar]] . add ( usernameAttribute , [[berle]] ) ; return [[haydar]] ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 214 ---------------------------------------------
Creates a map of shared objects . --> returns a delegator that can be administered to this class --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[apron]] ( ) { Map < Class < ? extends Object > , Object > [[unilateral]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[unilateral]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[unilateral]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[unilateral]] . put ( ApplicationContext . class , context ) ; [[unilateral]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[unilateral]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[unilateral]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 215 ---------------------------------------------
Sets authentication details . --> Set waterworks --> Socre: 1.0

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void setDetails ( HttpServletRequest [[meats]] , UsernamePasswordAuthenticationToken [[waterworks]] ) { [[waterworks]] . setDetails ( authenticationDetailsSource . buildDetails ( [[meats]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 216 ---------------------------------------------
Internal parsing routine . --> Internal parsing method --> Socre: 1.0

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int i = 0 ; ( [[date]] == null ) && ( i < [[formats]] . length ) ; i ++ ) { try { [[date]] = [[formats]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long internalParseDate ( String value , DateFormat [ ] [[neo]] ) { Date [[seesaw]] = null ; for ( int i = 0 ; ( [[seesaw]] == null ) && ( i < [[neo]] . length ) ; i ++ ) { try { [[seesaw]] = [[neo]] [ i ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[seesaw]] == null ) { return null ; } return new Long ( [[seesaw]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 217 ---------------------------------------------
Build the distinguished name for the group . --> Build the LDAP query --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName buildGroupDn ( String group ) { DistinguishedName [[biddies]] = new DistinguishedName ( groupSearchBase ) ; [[biddies]] . add ( groupRoleAttributeName , group . toLowerCase ( ) ) ; return [[biddies]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 218 ---------------------------------------------
Gets the directory with the immediate parent directory . --> Query for illuminates . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[rs]] , int [[rowNumber]] ) throws SQLException { Long parentDirectoryId = new Long ( [[rs]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[illuminates]] ( final Long id ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { id } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet [[ayres]] , int [[halles]] ) throws SQLException { Long parentDirectoryId = new Long ( [[ayres]] . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 219 ---------------------------------------------
Gets webSphere groups . --> obbing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String securityName ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[hobnobbing]] ( final String securityName ) { Context [[cope]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 220 ---------------------------------------------
Returns filtered filters --> [[[SKIPPED]]]

[[[[Adv]]]]: public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 221 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 188 / 29 / 4 / 221:  22%|██▏       | 221/1000 [3:41:16<12:59:56, 60.07s/it][Succeeded / Failed / Skipped / Total] 188 / 29 / 4 / 221:  22%|██▏       | 222/1000 [3:41:20<12:55:41, 59.82s/it][Succeeded / Failed / Skipped / Total] 189 / 29 / 4 / 222:  22%|██▏       | 222/1000 [3:41:20<12:55:41, 59.82s/it][Succeeded / Failed / Skipped / Total] 189 / 29 / 4 / 222:  22%|██▏       | 223/1000 [3:42:01<12:53:35, 59.74s/it][Succeeded / Failed / Skipped / Total] 190 / 29 / 4 / 223:  22%|██▏       | 223/1000 [3:42:01<12:53:35, 59.74s/it][Succeeded / Failed / Skipped / Total] 190 / 29 / 4 / 223:  22%|██▏       | 224/1000 [3:42:34<12:51:05, 59.62s/it][Succeeded / Failed / Skipped / Total] 191 / 29 / 4 / 224:  22%|██▏       | 224/1000 [3:42:34<12:51:05, 59.62s/it][Succeeded / Failed / Skipped / Total] 191 / 29 / 4 / 224:  22%|██▎       | 225/1000 [3:42:56<12:47:53, 59.45s/it][Succeeded / Failed / Skipped / Total] 191 / 30 / 4 / 225:  22%|██▎       | 225/1000 [3:42:56<12:47:53, 59.45s/it][Succeeded / Failed / Skipped / Total] 191 / 30 / 4 / 225:  23%|██▎       | 226/1000 [3:43:01<12:43:47, 59.21s/it][Succeeded / Failed / Skipped / Total] 192 / 30 / 4 / 226:  23%|██▎       | 226/1000 [3:43:01<12:43:47, 59.21s/it][Succeeded / Failed / Skipped / Total] 192 / 30 / 4 / 226:  23%|██▎       | 227/1000 [3:43:27<12:40:55, 59.06s/it][Succeeded / Failed / Skipped / Total] 193 / 30 / 4 / 227:  23%|██▎       | 227/1000 [3:43:27<12:40:55, 59.06s/it][Succeeded / Failed / Skipped / Total] 193 / 30 / 4 / 227:  23%|██▎       | 228/1000 [3:44:11<12:39:07, 59.00s/it]Configure the jaas using the login configuration --> Configure jaas using looping --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[loginConfigUrl]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String [[key]] = prefix + n ; log . debug ( "Setting security property [" + [[key]] + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( [[key]] , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[outraged]] = convertLoginConfigToUrl ( ) ; boolean alreadySet = "False" != "False" ; int n = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + n ) ) != null ) { alreadySet = existing . equals ( [[outraged]] ) ; if ( alreadySet ) { break ; } n ++ ; } if ( ! alreadySet ) { String [[cashes]] = prefix + n ; log . debug ( "Setting security property [" + [[cashes]] + "] to: " + [[outraged]] ) ; Security . setProperty ( [[cashes]] , [[outraged]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 222 ---------------------------------------------
Copy authentication details from source to destination . --> Copy watercolors --> Socre: 1.0

[[[[Adv]]]]: private void copyDetails ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[token]] = ( AbstractAuthenticationToken ) dest ; [[token]] . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void copyDetails ( Authentication [[watercolors]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[bessie]] = ( AbstractAuthenticationToken ) dest ; [[bessie]] . setDetails ( [[watercolors]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 223 ---------------------------------------------
Throws an exception if the limit is exceeded . --> Throws an exception if the limit is exceeded --> Socre: 1.0

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[sessions]] , int allowableSessions , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[sessions]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void allowableSessionsExceeded ( List < SessionInformation > [[tangina]] , int allowableSessions , SessionRegistry [[belfast]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( [[tangina]] == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( allowableSessions ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 224 ---------------------------------------------
Get the required web application context . --> Get the Strider for the Strider --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext [[pageContext]] ) { ServletContext servletContext = [[pageContext]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[strider]] ( PageContext [[squeaked]] ) { ServletContext servletContext = [[squeaked]] . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( servletContext ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 225 ---------------------------------------------
Returns the security name for the subject . --> [[[FAILED]]]

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[jigger]] ( final Subject [[kandinsky]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[kandinsky]] ) ; } String [[timing]] = null ; if ( [[kandinsky]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 226 ---------------------------------------------
Sets session attributes . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[teraz]] ( Map < String , Object > [[foreheads]] ) { notNull ( [[foreheads]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[foreheads]] , this . sessionAttributes ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 227 ---------------------------------------------
Add a list of filters . --> Adds a rachael --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > filters ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[rachael]] ( List < Filter > filters ) { Validate . notNull ( [[rachael]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[rachael]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 228 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 194 / 30 / 4 / 228:  23%|██▎       | 228/1000 [3:44:11<12:39:07, 59.00s/it][Succeeded / Failed / Skipped / Total] 194 / 30 / 4 / 228:  23%|██▎       | 229/1000 [3:44:21<12:35:20, 58.78s/it][Succeeded / Failed / Skipped / Total] 194 / 31 / 4 / 229:  23%|██▎       | 229/1000 [3:44:21<12:35:20, 58.78s/it][Succeeded / Failed / Skipped / Total] 194 / 31 / 4 / 229:  23%|██▎       | 230/1000 [3:44:35<12:31:54, 58.59s/it][Succeeded / Failed / Skipped / Total] 195 / 31 / 4 / 230:  23%|██▎       | 230/1000 [3:44:35<12:31:54, 58.59s/it][Succeeded / Failed / Skipped / Total] 195 / 31 / 4 / 230:  23%|██▎       | 231/1000 [3:45:55<12:32:07, 58.68s/it][Succeeded / Failed / Skipped / Total] 196 / 31 / 4 / 231:  23%|██▎       | 231/1000 [3:45:55<12:32:07, 58.68s/it][Succeeded / Failed / Skipped / Total] 196 / 31 / 4 / 231:  23%|██▎       | 232/1000 [3:45:56<12:27:58, 58.44s/it][Succeeded / Failed / Skipped / Total] 197 / 31 / 4 / 232:  23%|██▎       | 232/1000 [3:45:56<12:27:58, 58.44s/it][Succeeded / Failed / Skipped / Total] 197 / 31 / 4 / 232:  23%|██▎       | 233/1000 [3:46:06<12:24:17, 58.22s/it][Succeeded / Failed / Skipped / Total] 198 / 31 / 4 / 233:  23%|██▎       | 233/1000 [3:46:06<12:24:17, 58.22s/it][Succeeded / Failed / Skipped / Total] 198 / 31 / 4 / 233:  23%|██▎       | 234/1000 [3:46:19<12:20:51, 58.03s/it]Creates a basic authentication scheme with the specified username and password . --> A preemption scheme --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( [[password]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[arousal]] ( String userName , String [[felicia]] ) { final PreemptiveBasicAuthScheme preemptiveBasicAuthScheme = new PreemptiveBasicAuthScheme ( ) ; preemptiveBasicAuthScheme . setUserName ( userName ) ; preemptiveBasicAuthScheme . setPassword ( [[felicia]] ) ; return preemptiveBasicAuthScheme ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 229 ---------------------------------------------
Change the password for the current user . --> [[[FAILED]]]

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String [[newPassword]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String [[username]] = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + [[username]] ) ; DistinguishedName [[userDn]] = usernameMapper . buildDn ( [[username]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[userDn]] , oldPassword , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( [[userDn]] , oldPassword , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void changePassword ( final String oldPassword , final String [[sabot]] ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( authentication , "No authentication object found in security context. Can't change current user's password!" ) ; String [[chillie]] = authentication . getName ( ) ; logger . debug ( "Changing password for user '" + [[chillie]] ) ; DistinguishedName [[plebiscite]] = usernameMapper . buildDn ( [[chillie]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[plebiscite]] , oldPassword , [[sabot]] ) ; } else { changePasswordUsingAttributeModification ( [[plebiscite]] , oldPassword , [[sabot]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 230 ---------------------------------------------
Create an NTLMuth scheme for the given user name and password . --> Returns an NTLMuthScheme object with the given username and password --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String [[workstation]] , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( [[workstation]] ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme ntlm ( String userName , String password , String [[hubbard]] , String domain ) { final NTLMAuthScheme scheme = new NTLMAuthScheme ( ) ; scheme . setUserName ( userName ) ; scheme . setPassword ( password ) ; scheme . setWorkstation ( [[hubbard]] ) ; scheme . setDomain ( domain ) ; return scheme ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 231 ---------------------------------------------
Sets the proxy for the given URI . --> Expect corona specification --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[carefully]] ( URI [[corazón]] ) { if ( [[corazón]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[carefully]] ( new ProxySpecification ( [[corazón]] . getHost ( ) , [[corazón]] . getPort ( ) , [[corazón]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 232 ---------------------------------------------
Registers the given filters . --> Registers a filter for the given KuboO --> Socre: 1.0

[[[[Adv]]]]: public static void filters ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void filters ( Filter [[kubo]] , Filter ... [[presume]] ) { Validate . notNull ( [[kubo]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[kubo]] ) ; if ( [[presume]] != null ) { Collections . addAll ( RestAssured . filters , [[presume]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 233 ---------------------------------------------
Retrieve configuration based on redirect configuration . --> Configured RestAssociation with given redirectConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig redirect ( RedirectConfig [[redirectConfig]] ) { notNull ( [[redirectConfig]] , "Redirect config" ) ; return new RestAssuredConfig ( [[redirectConfig]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig redirect ( RedirectConfig [[neanderthal]] ) { notNull ( [[neanderthal]] , "Redirect config" ) ; return new RestAssuredConfig ( [[neanderthal]] , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 234 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 199 / 31 / 4 / 234:  23%|██▎       | 234/1000 [3:46:19<12:20:51, 58.03s/it][Succeeded / Failed / Skipped / Total] 199 / 31 / 4 / 234:  24%|██▎       | 235/1000 [3:46:26<12:17:08, 57.82s/it][Succeeded / Failed / Skipped / Total] 200 / 31 / 4 / 235:  24%|██▎       | 235/1000 [3:46:26<12:17:08, 57.82s/it][Succeeded / Failed / Skipped / Total] 200 / 31 / 4 / 235:  24%|██▎       | 236/1000 [3:46:31<12:13:20, 57.59s/it][Succeeded / Failed / Skipped / Total] 201 / 31 / 4 / 236:  24%|██▎       | 236/1000 [3:46:31<12:13:20, 57.59s/it][Succeeded / Failed / Skipped / Total] 201 / 31 / 4 / 236:  24%|██▎       | 237/1000 [3:46:38<12:09:37, 57.38s/it][Succeeded / Failed / Skipped / Total] 202 / 31 / 4 / 237:  24%|██▎       | 237/1000 [3:46:38<12:09:37, 57.38s/it][Succeeded / Failed / Skipped / Total] 202 / 31 / 4 / 237:  24%|██▍       | 238/1000 [3:46:43<12:05:54, 57.16s/it][Succeeded / Failed / Skipped / Total] 203 / 31 / 4 / 238:  24%|██▍       | 238/1000 [3:46:43<12:05:54, 57.16s/it][Succeeded / Failed / Skipped / Total] 204 / 31 / 4 / 239:  24%|██▍       | 239/1000 [3:46:43<12:01:55, 56.92s/it][Succeeded / Failed / Skipped / Total] 204 / 31 / 4 / 239:  24%|██▍       | 240/1000 [3:46:48<11:58:14, 56.70s/it][Succeeded / Failed / Skipped / Total] 205 / 31 / 4 / 240:  24%|██▍       | 240/1000 [3:46:48<11:58:14, 56.70s/it][Succeeded / Failed / Skipped / Total] 206 / 31 / 4 / 241:  24%|██▍       | 241/1000 [3:46:55<11:54:40, 56.50s/it][Succeeded / Failed / Skipped / Total] 206 / 31 / 4 / 241:  24%|██▍       | 242/1000 [3:46:56<11:50:49, 56.27s/it]Sets the default object mapper type --> helper for deserialization --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[hesse]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[hesse]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 235 ---------------------------------------------
Returns the full DN of the specified distinguished name . --> ztodo --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName [[baseDn]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( [[baseDn]] ) ) { return dn ; } [[baseDn]] . append ( dn ) ; return [[baseDn]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[zagreb]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName [[zeros]] = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( [[zeros]] ) ) { return dn ; } [[zeros]] . append ( dn ) ; return [[zeros]] ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 236 ---------------------------------------------
Configure Jackson object mapperFactory --> returns the Jackson ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[asmar]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 237 ---------------------------------------------
Returns the chain of filters matching the given request . --> protected for testing --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[protectress]] ( HttpServletRequest [[impregnated]] ) { for ( SecurityFilterChain [[oppress]] : filterChains ) { if ( [[oppress]] . matches ( [[impregnated]] ) ) { return [[oppress]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 238 ---------------------------------------------
Sets the log config . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[logConfig]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig logConfig ( LogConfig [[cantwell]] ) { notNull ( logConfig , "Log config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 239 ---------------------------------------------
Sets the rest of the session config . --> Factory method for RestAssured MvcConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig sessionConfig ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[balin]] ( SessionConfig sessionConfig ) { notNull ( [[balin]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[balin]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 240 ---------------------------------------------
Sets the restured mapper config . --> Creates a new instance of RestAssuredMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig objectMapperConfig ( ObjectMapperConfig [[bungo]] ) { notNull ( objectMapperConfig , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 241 ---------------------------------------------
Sets the RestAssuredM configuration . --> Creates a new RestAssigned MockConfig object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig xmlConfig ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[dinosaur]] ( XmlConfig xmlConfig ) { notNull ( [[dinosaur]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[dinosaur]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
[Succeeded / Failed / Skipped / Total] 207 / 31 / 4 / 242:  24%|██▍       | 242/1000 [3:46:56<11:50:49, 56.27s/it][Succeeded / Failed / Skipped / Total] 208 / 31 / 4 / 243:  24%|██▍       | 243/1000 [3:47:00<11:47:10, 56.05s/it][Succeeded / Failed / Skipped / Total] 208 / 31 / 4 / 243:  24%|██▍       | 244/1000 [3:47:00<11:43:21, 55.82s/it][Succeeded / Failed / Skipped / Total] 208 / 31 / 5 / 244:  24%|██▍       | 244/1000 [3:47:00<11:43:21, 55.82s/it][Succeeded / Failed / Skipped / Total] 209 / 31 / 5 / 245:  24%|██▍       | 245/1000 [3:47:07<11:39:56, 55.62s/it][Succeeded / Failed / Skipped / Total] 209 / 31 / 5 / 245:  25%|██▍       | 246/1000 [3:47:08<11:36:10, 55.40s/it][Succeeded / Failed / Skipped / Total] 210 / 31 / 5 / 246:  25%|██▍       | 246/1000 [3:47:08<11:36:10, 55.40s/it][Succeeded / Failed / Skipped / Total] 211 / 31 / 5 / 247:  25%|██▍       | 247/1000 [3:47:19<11:33:02, 55.22s/it][Succeeded / Failed / Skipped / Total] 211 / 31 / 5 / 247:  25%|██▍       | 248/1000 [3:47:20<11:29:22, 55.00s/it][Succeeded / Failed / Skipped / Total] 212 / 31 / 5 / 248:  25%|██▍       | 248/1000 [3:47:20<11:29:22, 55.00s/it][Succeeded / Failed / Skipped / Total] 212 / 31 / 5 / 248:  25%|██▍       | 249/1000 [3:47:28<11:26:04, 54.81s/it][Succeeded / Failed / Skipped / Total] 213 / 31 / 5 / 249:  25%|██▍       | 249/1000 [3:47:28<11:26:04, 54.81s/it][Succeeded / Failed / Skipped / Total] 213 / 31 / 5 / 249:  25%|██▌       | 250/1000 [3:47:35<11:22:47, 54.62s/it]--------------------------------------------- Result 242 ---------------------------------------------
Sets the RestAssuredM configuration . --> Create a new corridor --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[corridor]] ( JsonConfig jsonConfig ) { notNull ( [[corridor]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[corridor]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 243 ---------------------------------------------
Sets the restured config . --> Briting configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[british]] ( EncoderConfig encoderConfig ) { notNull ( [[british]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[british]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 244 ---------------------------------------------
Create a new RestAssuredMock configured for RestAssociation . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 245 ---------------------------------------------
Sets the restured config . --> Create a RestAssuredMockConfig object . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[asyncConfig]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig asyncConfig ( AsyncConfig [[akiyama]] ) { notNull ( asyncConfig , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 246 ---------------------------------------------
Sets the HTTP header config . --> Create a new instance with balsam configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig headerConfig ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[balsam]] ( HeaderConfig headerConfig ) { notNull ( [[balsam]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[balsam]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 247 ---------------------------------------------
Sets the restured config . --> Creates a new restured mock based on configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[paramConfig]] ( MockMvcParamConfig paramConfig ) { notNull ( [[paramConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[paramConfig]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[bandai]] ( MockMvcParamConfig paramConfig ) { notNull ( [[bandai]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , [[bandai]] , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 248 ---------------------------------------------
Sets a multi - part config . --> Create a mock MockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[multiPartConfig]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig multiPartConfig ( MultiPartConfig [[laundered]] ) { notNull ( multiPartConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 249 ---------------------------------------------
Sets the restured matcher configuration . --> Creates a new RestAssuredMatcher configuration object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[matcherConfig]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[deal]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 250 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 214 / 31 / 5 / 250:  25%|██▌       | 250/1000 [3:47:35<11:22:47, 54.62s/it][Succeeded / Failed / Skipped / Total] 214 / 31 / 5 / 250:  25%|██▌       | 251/1000 [3:48:31<11:21:54, 54.63s/it][Succeeded / Failed / Skipped / Total] 215 / 31 / 5 / 251:  25%|██▌       | 251/1000 [3:48:31<11:21:54, 54.63s/it][Succeeded / Failed / Skipped / Total] 215 / 31 / 5 / 251:  25%|██▌       | 252/1000 [3:49:06<11:20:02, 54.55s/it][Succeeded / Failed / Skipped / Total] 216 / 31 / 5 / 252:  25%|██▌       | 252/1000 [3:49:06<11:20:02, 54.55s/it][Succeeded / Failed / Skipped / Total] 216 / 31 / 5 / 252:  25%|██▌       | 253/1000 [3:49:29<11:17:35, 54.42s/it][Succeeded / Failed / Skipped / Total] 217 / 31 / 5 / 253:  25%|██▌       | 253/1000 [3:49:29<11:17:35, 54.42s/it][Succeeded / Failed / Skipped / Total] 217 / 31 / 5 / 253:  25%|██▌       | 254/1000 [3:49:50<11:15:02, 54.29s/it][Succeeded / Failed / Skipped / Total] 218 / 31 / 5 / 254:  25%|██▌       | 254/1000 [3:49:50<11:15:02, 54.29s/it][Succeeded / Failed / Skipped / Total] 218 / 31 / 5 / 254:  26%|██▌       | 255/1000 [3:49:57<11:11:49, 54.11s/it][Succeeded / Failed / Skipped / Total] 218 / 32 / 5 / 255:  26%|██▌       | 255/1000 [3:49:57<11:11:49, 54.11s/it][Succeeded / Failed / Skipped / Total] 218 / 32 / 5 / 255:  26%|██▌       | 256/1000 [3:50:42<11:10:30, 54.07s/it]Default encoding for query parameter . --> Configures this encoder configuration . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[anon]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "[[Ebonics]]" == "[[Ebonics]]" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 251 ---------------------------------------------
Allow all host names . --> Zena certificate auth settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[zena]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 252 ---------------------------------------------
Creates a new authentication scheme using the specified form and password . --> Create a new FormAuth scheme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String password , FormAuthConfig [[config]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[poseur]] ( String userName , String password , FormAuthConfig [[beekman]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[argo]] = new FormAuthScheme ( ) ; [[argo]] . setUserName ( userName ) ; [[argo]] . setPassword ( password ) ; [[argo]] . setConfig ( [[beekman]] ) ; return [[argo]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 253 ---------------------------------------------
Declares an XMLPathConfig with the given namespaces . --> Create a new XMLPathConfig object --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[downtown]] ( Map < String , String > [[camel]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[camel]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 254 ---------------------------------------------
Creates a basic authentication scheme with the specified user name and password . --> Static factory method --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String userName , String [[password]] ) { final BasicAuthScheme [[scheme]] = new BasicAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( [[password]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[clubfoot]] ( String userName , String [[strongest]] ) { final BasicAuthScheme [[chronological]] = new BasicAuthScheme ( ) ; [[chronological]] . setUserName ( userName ) ; [[chronological]] . setPassword ( [[strongest]] ) ; return [[chronological]] ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 255 ---------------------------------------------
Print response options . --> [[[FAILED]]]

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String print ( ResponseOptions responseOptions , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( responseOptions . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = responseOptions . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = responseOptions . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( responseOptions , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 256 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 219 / 32 / 5 / 256:  26%|██▌       | 256/1000 [3:50:42<11:10:30, 54.07s/it][Succeeded / Failed / Skipped / Total] 219 / 32 / 5 / 256:  26%|██▌       | 257/1000 [3:51:09<11:08:16, 53.97s/it][Succeeded / Failed / Skipped / Total] 220 / 32 / 5 / 257:  26%|██▌       | 257/1000 [3:51:09<11:08:16, 53.97s/it][Succeeded / Failed / Skipped / Total] 220 / 32 / 5 / 257:  26%|██▌       | 258/1000 [3:51:32<11:05:55, 53.85s/it][Succeeded / Failed / Skipped / Total] 221 / 32 / 5 / 258:  26%|██▌       | 258/1000 [3:51:32<11:05:55, 53.85s/it][Succeeded / Failed / Skipped / Total] 221 / 32 / 5 / 258:  26%|██▌       | 259/1000 [3:51:35<11:02:34, 53.65s/it][Succeeded / Failed / Skipped / Total] 222 / 32 / 5 / 259:  26%|██▌       | 259/1000 [3:51:35<11:02:34, 53.65s/it][Succeeded / Failed / Skipped / Total] 222 / 32 / 5 / 259:  26%|██▌       | 260/1000 [3:51:37<10:59:14, 53.45s/it][Succeeded / Failed / Skipped / Total] 223 / 32 / 5 / 260:  26%|██▌       | 260/1000 [3:51:37<10:59:14, 53.45s/it][Succeeded / Failed / Skipped / Total] 223 / 32 / 5 / 260:  26%|██▌       | 261/1000 [3:51:40<10:55:59, 53.26s/it][Succeeded / Failed / Skipped / Total] 224 / 32 / 5 / 261:  26%|██▌       | 261/1000 [3:51:40<10:55:59, 53.26s/it][Succeeded / Failed / Skipped / Total] 224 / 32 / 5 / 261:  26%|██▌       | 262/1000 [3:51:54<10:53:14, 53.11s/it][Succeeded / Failed / Skipped / Total] 225 / 32 / 5 / 262:  26%|██▌       | 262/1000 [3:51:54<10:53:14, 53.11s/it][Succeeded / Failed / Skipped / Total] 225 / 32 / 5 / 262:  26%|██▋       | 263/1000 [3:52:05<10:50:23, 52.95s/it]Issues a HTTP request . --> Broadcast a given method --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[defaultContentType]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[broadhurst]] ( String method , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , method , this . [[keppel]] , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 257 ---------------------------------------------
Sets the request headers . --> setter for footer --> Socre: 1.0

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object [[key]] : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( [[key]] ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( [[key]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void setHeaders ( Map < ? , ? > [[theologians]] ) { this . [[hickock]] . clear ( ) ; if ( [[theologians]] == null ) return ; for ( Object [[bonked]] : [[theologians]] . keySet ( ) ) { Object val = [[theologians]] . get ( [[bonked]] ) ; if ( val == null ) continue ; this . [[hickock]] . put ( [[bonked]] . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 258 ---------------------------------------------
Creates a new Headers instance with the specified header . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... [[additionalHeaders]] ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( [[additionalHeaders]] != null ) { Collections . addAll ( headerList , [[additionalHeaders]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header header , Header ... [[middletown]] ) { notNull ( header , "Header" ) ; final List < Header > headerList = new LinkedList < Header > ( ) ; headerList . add ( header ) ; if ( [[middletown]] != null ) { Collections . addAll ( headerList , [[middletown]] ) ; } return new Headers ( headerList ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 259 ---------------------------------------------
Adds a single header to the request . --> Capabilities for Caprices with Capabilities --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String name , String [[value]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[caprices]] ( String name , String [[custodian]] ) { Validate . notEmpty ( name , "Header name cannot be empty" ) ; Validate . notEmpty ( [[custodian]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 260 ---------------------------------------------
Declares a namespace with the specified prefix . --> Zipping XML path configuration --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String prefix , String [[namespaceURI]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[zug]] ( String prefix , String [[elwood]] ) { Validate . notEmpty ( prefix , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[elwood]] , "Namespace URI cannot be empty" ) ; Map < String , String > updatedNamespaces = new HashMap < String , String > ( declaredNamespaces ) ; updatedNamespaces . put ( prefix , [[elwood]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , updatedNamespaces , properties , validating , "True" == "True" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 261 ---------------------------------------------
Reset the configuration . --> Clean up resources --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void [[chaz]] ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 262 ---------------------------------------------
Build the REST response . --> Sets switch status . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[switchboard]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 263 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 226 / 32 / 5 / 263:  26%|██▋       | 263/1000 [3:52:05<10:50:23, 52.95s/it][Succeeded / Failed / Skipped / Total] 226 / 32 / 5 / 263:  26%|██▋       | 264/1000 [3:52:41<10:48:44, 52.89s/it][Succeeded / Failed / Skipped / Total] 227 / 32 / 5 / 264:  26%|██▋       | 264/1000 [3:52:41<10:48:44, 52.89s/it][Succeeded / Failed / Skipped / Total] 227 / 32 / 5 / 264:  26%|██▋       | 265/1000 [3:53:02<10:46:20, 52.76s/it][Succeeded / Failed / Skipped / Total] 228 / 32 / 5 / 265:  26%|██▋       | 265/1000 [3:53:02<10:46:20, 52.76s/it][Succeeded / Failed / Skipped / Total] 228 / 32 / 5 / 265:  27%|██▋       | 266/1000 [3:53:09<10:43:22, 52.59s/it][Succeeded / Failed / Skipped / Total] 229 / 32 / 5 / 266:  27%|██▋       | 266/1000 [3:53:09<10:43:22, 52.59s/it][Succeeded / Failed / Skipped / Total] 229 / 32 / 5 / 266:  27%|██▋       | 267/1000 [3:54:10<10:42:54, 52.63s/it][Succeeded / Failed / Skipped / Total] 229 / 33 / 5 / 267:  27%|██▋       | 267/1000 [3:54:10<10:42:54, 52.63s/it][Succeeded / Failed / Skipped / Total] 229 / 33 / 5 / 267:  27%|██▋       | 268/1000 [3:55:13<10:42:28, 52.66s/it][Succeeded / Failed / Skipped / Total] 230 / 33 / 5 / 268:  27%|██▋       | 268/1000 [3:55:13<10:42:28, 52.66s/it][Succeeded / Failed / Skipped / Total] 230 / 33 / 5 / 268:  27%|██▋       | 269/1000 [3:56:12<10:41:53, 52.69s/it][Succeeded / Failed / Skipped / Total] 230 / 34 / 5 / 269:  27%|██▋       | 269/1000 [3:56:12<10:41:53, 52.69s/it][Succeeded / Failed / Skipped / Total] 230 / 34 / 5 / 269:  27%|██▋       | 270/1000 [3:56:32<10:39:33, 52.57s/it][Succeeded / Failed / Skipped / Total] 230 / 35 / 5 / 270:  27%|██▋       | 270/1000 [3:56:32<10:39:33, 52.57s/it][Succeeded / Failed / Skipped / Total] 230 / 35 / 5 / 270:  27%|██▋       | 271/1000 [3:56:52<10:37:12, 52.44s/it][Succeeded / Failed / Skipped / Total] 230 / 36 / 5 / 271:  27%|██▋       | 271/1000 [3:56:52<10:37:12, 52.44s/it][Succeeded / Failed / Skipped / Total] 230 / 36 / 5 / 271:  27%|██▋       | 272/1000 [3:57:03<10:34:28, 52.29s/it][Succeeded / Failed / Skipped / Total] 230 / 37 / 5 / 272:  27%|██▋       | 272/1000 [3:57:03<10:34:28, 52.29s/it][Succeeded / Failed / Skipped / Total] 230 / 37 / 5 / 272:  27%|██▋       | 273/1000 [3:57:47<10:33:13, 52.26s/it]Set the proxy to use . --> Do a new hyperlink --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String host , int [[port]] , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , [[port]] , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[doyle]] ( String host , int [[tourism]] , String [[mustafa]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( host , [[tourism]] , [[mustafa]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 264 ---------------------------------------------
Matches the cookie with the given matcher . --> methode a carne --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[carne]] ( Matcher < ? super String > valueMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , valueMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 265 ---------------------------------------------
Sets the NTLM credentials . --> Sets salutation --> Socre: 1.0

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String [[user]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[user]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[salutation]] ( String host , int port , String [[ohmigod]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[ohmigod]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 266 ---------------------------------------------
Sets the response header . --> Sets the response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > [[newHeaders]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[newHeaders]] . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[newHeaders]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[femmes]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > [[handwriting]] = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; [[handwriting]] . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( [[handwriting]] ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 267 ---------------------------------------------
Set basic auth credentials . --> [[[FAILED]]]

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void basic ( String host , int port , String user , String pass ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new UsernamePasswordCredentials ( user , pass ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 268 ---------------------------------------------
Sets the control name . --> Set bretons --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String controlName ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . [[controlName]] = [[controlName]] ; this . isControlNameExplicit = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[bretons]] ( String controlName ) { Validate . notEmpty ( [[bretons]] , "Control name cannot be empty" ) ; this . [[knotty]] = [[bretons]] ; this . isControlNameExplicit = "[[Impersonations]]" == "[[Impersonations]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 269 ---------------------------------------------
Matches cookie that matches expiry date . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[hubcaps]] ( Matcher < ? super Date > [[beeing]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[beeing]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Applies a cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[comment]] ( Matcher < ? super String > [[commentMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[commentMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[bermuda]] ( Matcher < ? super String > [[lumberjack]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , [[lumberjack]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Applies a cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[path]] ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[dozed]] ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Applies a cookie to the cookie matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[evergreen]] ( Matcher < ? super String > [[stonehenge]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[stonehenge]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
[Succeeded / Failed / Skipped / Total] 230 / 38 / 5 / 273:  27%|██▋       | 273/1000 [3:57:47<10:33:13, 52.26s/it][Succeeded / Failed / Skipped / Total] 230 / 38 / 5 / 273:  27%|██▋       | 274/1000 [3:58:14<10:31:16, 52.17s/it][Succeeded / Failed / Skipped / Total] 230 / 39 / 5 / 274:  27%|██▋       | 274/1000 [3:58:14<10:31:16, 52.17s/it][Succeeded / Failed / Skipped / Total] 230 / 39 / 5 / 274:  28%|██▊       | 275/1000 [3:58:16<10:28:11, 51.99s/it][Succeeded / Failed / Skipped / Total] 231 / 39 / 5 / 275:  28%|██▊       | 275/1000 [3:58:16<10:28:11, 51.99s/it][Succeeded / Failed / Skipped / Total] 231 / 39 / 5 / 275:  28%|██▊       | 276/1000 [3:58:27<10:25:31, 51.84s/it][Succeeded / Failed / Skipped / Total] 232 / 39 / 5 / 276:  28%|██▊       | 276/1000 [3:58:27<10:25:31, 51.84s/it][Succeeded / Failed / Skipped / Total] 232 / 39 / 5 / 276:  28%|██▊       | 277/1000 [3:58:41<10:23:00, 51.70s/it][Succeeded / Failed / Skipped / Total] 233 / 39 / 5 / 277:  28%|██▊       | 277/1000 [3:58:41<10:23:00, 51.70s/it][Succeeded / Failed / Skipped / Total] 233 / 39 / 5 / 277:  28%|██▊       | 278/1000 [4:00:02<10:23:25, 51.81s/it][Succeeded / Failed / Skipped / Total] 234 / 39 / 5 / 278:  28%|██▊       | 278/1000 [4:00:02<10:23:25, 51.81s/it][Succeeded / Failed / Skipped / Total] 234 / 39 / 5 / 278:  28%|██▊       | 279/1000 [4:00:03<10:20:21, 51.62s/it][Succeeded / Failed / Skipped / Total] 235 / 39 / 5 / 279:  28%|██▊       | 279/1000 [4:00:03<10:20:21, 51.62s/it][Succeeded / Failed / Skipped / Total] 235 / 39 / 5 / 279:  28%|██▊       | 280/1000 [4:00:07<10:17:27, 51.45s/it][Succeeded / Failed / Skipped / Total] 236 / 39 / 5 / 280:  28%|██▊       | 280/1000 [4:00:07<10:17:27, 51.45s/it][Succeeded / Failed / Skipped / Total] 236 / 39 / 5 / 280:  28%|██▊       | 281/1000 [4:00:43<10:15:57, 51.40s/it][Succeeded / Failed / Skipped / Total] 236 / 40 / 5 / 281:  28%|██▊       | 281/1000 [4:00:43<10:15:57, 51.40s/it][Succeeded / Failed / Skipped / Total] 236 / 40 / 5 / 281:  28%|██▊       | 282/1000 [4:00:53<10:13:20, 51.25s/it][Succeeded / Failed / Skipped / Total] 237 / 40 / 5 / 282:  28%|██▊       | 282/1000 [4:00:53<10:13:20, 51.25s/it][Succeeded / Failed / Skipped / Total] 237 / 40 / 5 / 282:  28%|██▊       | 283/1000 [4:01:16<10:11:17, 51.15s/it]--------------------------------------------- Result 273 ---------------------------------------------
Applies a secured cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[secured]] ( Matcher < ? super Boolean > [[securedMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[securedMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[grandes]] ( Matcher < ? super Boolean > [[harping]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , [[harping]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Convenience method to allow http only . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[burberry]] ( Matcher < ? super Boolean > [[developing]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[developing]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Applies the max age condition to the cookie . --> Vertex cookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[vite]] ( Matcher < ? super Integer > [[morticia]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[morticia]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Configures the JsonPathConfig for a number . --> Configure the JsonPathConfig --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[numberReturnType]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[numberReturnType]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .

[[[[Adv]]]]: public JsonPathConfig [[alena]] ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( [[alena]] , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 277 ---------------------------------------------
Returns a proxy specification with the specified host name . --> Methode permettant d a host --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[estelle]] ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 278 ---------------------------------------------
Expect the given header with the given expected value . --> Alphabetical headers --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[aladin]] ( String [[labors]] , String [[wehrmacht]] ) { spec . header ( [[labors]] , [[wehrmacht]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 279 ---------------------------------------------
Default parser type . --> Config for affraid --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType [[defaultParserType]] ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[affraid]] ( JsonParserType [[ii]] ) { return new JsonPathConfig ( numberReturnType , [[affraid]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
--------------------------------------------- Result 280 ---------------------------------------------
Expect a cookie with the expected value . --> Force cookies --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[forceps]] ( String [[benja]] , String [[jamais]] ) { spec . cookie ( [[benja]] , [[jamais]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 281 ---------------------------------------------
Matches cookie matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[shushing]] ( Matcher < ? super Integer > [[invented]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[invented]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 282 ---------------------------------------------
Creates a HttpRequestBase object based on the given HTTP method and HTTP method . --> create HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[type]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase createHttpRequest ( URI uri , String httpMethod , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( httpMethod ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > [[dufour]] = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase httpRequest ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 283 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 238 / 40 / 5 / 283:  28%|██▊       | 283/1000 [4:01:16<10:11:17, 51.15s/it][Succeeded / Failed / Skipped / Total] 238 / 40 / 5 / 283:  28%|██▊       | 284/1000 [4:01:28<10:08:46, 51.02s/it][Succeeded / Failed / Skipped / Total] 239 / 40 / 5 / 284:  28%|██▊       | 284/1000 [4:01:28<10:08:46, 51.02s/it][Succeeded / Failed / Skipped / Total] 239 / 40 / 5 / 284:  28%|██▊       | 285/1000 [4:01:32<10:05:57, 50.85s/it][Succeeded / Failed / Skipped / Total] 240 / 40 / 5 / 285:  28%|██▊       | 285/1000 [4:01:32<10:05:57, 50.85s/it][Succeeded / Failed / Skipped / Total] 240 / 40 / 5 / 285:  29%|██▊       | 286/1000 [4:01:46<10:03:36, 50.72s/it][Succeeded / Failed / Skipped / Total] 241 / 40 / 5 / 286:  29%|██▊       | 286/1000 [4:01:46<10:03:36, 50.72s/it][Succeeded / Failed / Skipped / Total] 241 / 40 / 5 / 286:  29%|██▊       | 287/1000 [4:01:58<10:01:09, 50.59s/it][Succeeded / Failed / Skipped / Total] 242 / 40 / 5 / 287:  29%|██▊       | 287/1000 [4:01:58<10:01:09, 50.59s/it][Succeeded / Failed / Skipped / Total] 242 / 40 / 5 / 287:  29%|██▉       | 288/1000 [4:02:11<9:58:45, 50.46s/it] [Succeeded / Failed / Skipped / Total] 243 / 40 / 5 / 288:  29%|██▉       | 288/1000 [4:02:11<9:58:45, 50.46s/it][Succeeded / Failed / Skipped / Total] 243 / 40 / 5 / 288:  29%|██▉       | 289/1000 [4:02:21<9:56:14, 50.32s/it][Succeeded / Failed / Skipped / Total] 244 / 40 / 5 / 289:  29%|██▉       | 289/1000 [4:02:21<9:56:14, 50.32s/it][Succeeded / Failed / Skipped / Total] 244 / 40 / 5 / 289:  29%|██▉       | 290/1000 [4:02:30<9:53:43, 50.17s/it][Succeeded / Failed / Skipped / Total] 245 / 40 / 5 / 290:  29%|██▉       | 290/1000 [4:02:30<9:53:43, 50.17s/it][Succeeded / Failed / Skipped / Total] 245 / 40 / 5 / 290:  29%|██▉       | 291/1000 [4:02:33<9:50:57, 50.01s/it][Succeeded / Failed / Skipped / Total] 246 / 40 / 5 / 291:  29%|██▉       | 291/1000 [4:02:33<9:50:57, 50.01s/it][Succeeded / Failed / Skipped / Total] 246 / 40 / 5 / 291:  29%|██▉       | 292/1000 [4:02:51<9:48:51, 49.90s/it][Succeeded / Failed / Skipped / Total] 247 / 40 / 5 / 292:  29%|██▉       | 292/1000 [4:02:51<9:48:51, 49.90s/it][Succeeded / Failed / Skipped / Total] 247 / 40 / 5 / 292:  29%|██▉       | 293/1000 [4:02:57<9:46:14, 49.75s/it][Succeeded / Failed / Skipped / Total] 248 / 40 / 5 / 293:  29%|██▉       | 293/1000 [4:02:57<9:46:14, 49.75s/it][Succeeded / Failed / Skipped / Total] 248 / 40 / 5 / 293:  29%|██▉       | 294/1000 [4:03:39<9:45:06, 49.73s/it]Default configuration for MultiPartition --> Define a rader configuration with the rader --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[rader]] ( String defaultBoundary ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[rader]] , defaultCharset , "[[Aardvark]]" == "[[Aardvark]]" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 284 ---------------------------------------------
Sets the default log stream . --> Configure Yayer --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[ayala]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[Gayer]]" == "[[Gayer]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Gayer]]" == "[[Gayer]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 285 ---------------------------------------------
Enable logging of request and response validation --> Used to configure this LogConfig --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[animals]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[Ebbing]]" == "[[Ebbing]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 286 ---------------------------------------------
Expect the given header with the given expected value . --> Reverse retry --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[retrial]] ( String [[redo]] , Matcher < String > [[estúpido]] ) { spec . header ( [[redo]] , [[estúpido]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 287 ---------------------------------------------
Sets the HttpClientFactory --> HttpClientFactory --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory httpClientFactory ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Ordnung]]" == "[[Ordnung]]" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 288 ---------------------------------------------
Sets the HttpMultipartMode . --> Use HttpClientConfig --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[helsing]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[helsing]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 289 ---------------------------------------------
Adds an attribute to the request . --> Adds a warning . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[attributeName]] , Object [[attributeValue]] ) { spec . attribute ( [[attributeName]] , [[attributeValue]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder addAttribute ( String [[blessing]] , Object [[strums]] ) { spec . attribute ( [[blessing]] , [[strums]] ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 290 ---------------------------------------------
Gets int . --> Evaluate ealing distance --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[ealing]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 291 ---------------------------------------------
Adds additional result handlers . --> Called when the request is complete . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[cretinous]] ( ResultHandler resultHandler , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( resultHandler , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 292 ---------------------------------------------
Get short . --> Convenience method for shortness --> Socre: 1.0

[[[[Adv]]]]: public short getShort ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short getShort ( String [[musicianship]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 293 ---------------------------------------------
Gets byte . --> 6 --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[choirboys]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 294 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 249 / 40 / 5 / 294:  29%|██▉       | 294/1000 [4:03:39<9:45:06, 49.73s/it][Succeeded / Failed / Skipped / Total] 249 / 40 / 5 / 294:  30%|██▉       | 295/1000 [4:04:01<9:43:11, 49.63s/it][Succeeded / Failed / Skipped / Total] 250 / 40 / 5 / 295:  30%|██▉       | 295/1000 [4:04:01<9:43:11, 49.63s/it][Succeeded / Failed / Skipped / Total] 250 / 40 / 5 / 295:  30%|██▉       | 296/1000 [4:04:20<9:41:08, 49.53s/it][Succeeded / Failed / Skipped / Total] 251 / 40 / 5 / 296:  30%|██▉       | 296/1000 [4:04:20<9:41:08, 49.53s/it][Succeeded / Failed / Skipped / Total] 251 / 40 / 5 / 296:  30%|██▉       | 297/1000 [4:04:40<9:39:07, 49.43s/it][Succeeded / Failed / Skipped / Total] 251 / 41 / 5 / 297:  30%|██▉       | 297/1000 [4:04:40<9:39:07, 49.43s/it][Succeeded / Failed / Skipped / Total] 251 / 41 / 5 / 297:  30%|██▉       | 298/1000 [4:05:19<9:37:54, 49.39s/it][Succeeded / Failed / Skipped / Total] 252 / 41 / 5 / 298:  30%|██▉       | 298/1000 [4:05:19<9:37:54, 49.39s/it][Succeeded / Failed / Skipped / Total] 252 / 41 / 5 / 298:  30%|██▉       | 299/1000 [4:05:23<9:35:18, 49.24s/it][Succeeded / Failed / Skipped / Total] 253 / 41 / 5 / 299:  30%|██▉       | 299/1000 [4:05:23<9:35:18, 49.24s/it][Succeeded / Failed / Skipped / Total] 253 / 41 / 5 / 299:  30%|███       | 300/1000 [4:05:46<9:33:29, 49.16s/it][Succeeded / Failed / Skipped / Total] 254 / 41 / 5 / 300:  30%|███       | 300/1000 [4:05:46<9:33:29, 49.16s/it][Succeeded / Failed / Skipped / Total] 254 / 41 / 5 / 300:  30%|███       | 301/1000 [4:05:49<9:30:52, 49.00s/it][Succeeded / Failed / Skipped / Total] 255 / 41 / 5 / 301:  30%|███       | 301/1000 [4:05:49<9:30:52, 49.00s/it][Succeeded / Failed / Skipped / Total] 255 / 41 / 5 / 301:  30%|███       | 302/1000 [4:06:35<9:29:56, 48.99s/it][Succeeded / Failed / Skipped / Total] 255 / 42 / 5 / 302:  30%|███       | 302/1000 [4:06:35<9:29:56, 48.99s/it][Succeeded / Failed / Skipped / Total] 255 / 42 / 5 / 302:  30%|███       | 303/1000 [4:07:44<9:29:53, 49.06s/it][Succeeded / Failed / Skipped / Total] 255 / 43 / 5 / 303:  30%|███       | 303/1000 [4:07:44<9:29:54, 49.06s/it][Succeeded / Failed / Skipped / Total] 255 / 43 / 5 / 303:  30%|███       | 304/1000 [4:07:57<9:27:41, 48.94s/it]Adds a multi - part request . --> Set mantissa --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String contentBody , String mimeType ) { spec . multiPart ( [[controlName]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[mantilla]] ( String [[implicates]] , String contentBody , String mimeType ) { spec . multiPart ( [[implicates]] , mimeType ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 295 ---------------------------------------------
Gets a value . --> Retrieves details from json --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) jsonAssertion . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[sandusky]] > [[sandusky]] get ( String path ) { final JSONAssertion jsonAssertion = createJsonAssertion ( path , params ) ; final Object [[buy]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[sandusky]] ) jsonAssertion . getResult ( [[buy]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 296 ---------------------------------------------
Returns a float value . --> Getter for paycheche --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object value = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[cerebral]] ( String [[paycheque]] ) { final Object value = get ( [[paycheque]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 297 ---------------------------------------------
Adds a header to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String headerName , String [[headerValue]] ) { spec . header ( headerName , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[renato]] ( String headerName , String [[kowloon]] ) { spec . header ( headerName , [[kowloon]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 298 ---------------------------------------------
Gets long . --> Doodo doodle bug --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[doodlebug]] ( String [[séances]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 299 ---------------------------------------------
Get a double . --> Calculates Hillbillies --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[hillbillies]] ( String [[philosophical]] ) { final Object [[maruti]] = get ( [[philosophical]] ) ; if ( [[maruti]] instanceof Double ) { return ( Double ) [[maruti]] ; } return ObjectConverter . convertObjectTo ( [[maruti]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 300 ---------------------------------------------
Sets the body of the request . --> Set all objects --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[allyou]] ( Object object , ObjectMapper mapper ) { spec . body ( object , mapper ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 301 ---------------------------------------------
Get a map element . --> Returns unno mapping --> Socre: 1.0

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[hitherto]] , V > Map < [[hitherto]] , V > [[unno]] ( String path ) { return get ( path ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 302 ---------------------------------------------
Sets a parameter with the specified parameter . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[wazoo]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( httpClientParams ) ; newParams . put ( parameterName , parameterValue ) ; return new [[wazoo]] ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Resonant]]" == "[[Resonant]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 303 ---------------------------------------------
Add additional HTTP client parameters . --> [[[FAILED]]]

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; [[newParams]] . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig addParams ( Map < String , ? > [[crinkles]] ) { notNull ( [[crinkles]] , "httpClientParams" ) ; final Map < String , Object > [[ai]] = new HashMap < String , Object > ( this . [[asakawa]] ) ; [[ai]] . putAll ( [[crinkles]] ) ; return new HttpClientConfig ( httpClientFactory , [[ai]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Transylvanian]]" == "[[Transylvanian]]" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
--------------------------------------------- Result 304 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 256 / 43 / 5 / 304:  30%|███       | 304/1000 [4:07:57<9:27:41, 48.94s/it][Succeeded / Failed / Skipped / Total] 256 / 43 / 5 / 304:  30%|███       | 305/1000 [4:08:14<9:25:39, 48.83s/it][Succeeded / Failed / Skipped / Total] 257 / 43 / 5 / 305:  30%|███       | 305/1000 [4:08:14<9:25:39, 48.83s/it][Succeeded / Failed / Skipped / Total] 257 / 43 / 5 / 305:  31%|███       | 306/1000 [4:08:17<9:23:06, 48.68s/it][Succeeded / Failed / Skipped / Total] 258 / 43 / 5 / 306:  31%|███       | 306/1000 [4:08:17<9:23:06, 48.68s/it][Succeeded / Failed / Skipped / Total] 258 / 43 / 5 / 306:  31%|███       | 307/1000 [4:08:23<9:20:41, 48.55s/it][Succeeded / Failed / Skipped / Total] 259 / 43 / 5 / 307:  31%|███       | 307/1000 [4:08:23<9:20:41, 48.55s/it][Succeeded / Failed / Skipped / Total] 259 / 43 / 5 / 307:  31%|███       | 308/1000 [4:08:31<9:18:23, 48.42s/it][Succeeded / Failed / Skipped / Total] 260 / 43 / 5 / 308:  31%|███       | 308/1000 [4:08:31<9:18:23, 48.42s/it][Succeeded / Failed / Skipped / Total] 260 / 43 / 5 / 308:  31%|███       | 309/1000 [4:08:42<9:16:10, 48.29s/it][Succeeded / Failed / Skipped / Total] 261 / 43 / 5 / 309:  31%|███       | 309/1000 [4:08:42<9:16:10, 48.29s/it][Succeeded / Failed / Skipped / Total] 261 / 43 / 5 / 309:  31%|███       | 310/1000 [4:08:57<9:14:08, 48.19s/it][Succeeded / Failed / Skipped / Total] 262 / 43 / 5 / 310:  31%|███       | 310/1000 [4:08:57<9:14:08, 48.19s/it][Succeeded / Failed / Skipped / Total] 262 / 43 / 5 / 310:  31%|███       | 311/1000 [4:08:59<9:11:37, 48.04s/it][Succeeded / Failed / Skipped / Total] 263 / 43 / 5 / 311:  31%|███       | 311/1000 [4:08:59<9:11:37, 48.04s/it][Succeeded / Failed / Skipped / Total] 263 / 43 / 5 / 311:  31%|███       | 312/1000 [4:09:48<9:10:52, 48.04s/it]Helper method to log response to the output stream . --> log response to stream --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( stream , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream stream , Matcher < Integer > [[cream]] ) { return new ResponseLoggingFilter ( stream , [[cream]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 305 ---------------------------------------------
Create a new MockServiceParam updateStrategy . --> Create a mock MvcParamConfig --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig formParamsUpdateStrategy ( UpdateStrategy [[amélie]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[amélie]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "[[Remotes]]" == "[[Remotes]]" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 306 ---------------------------------------------
Adds additional cookies to the request . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cookie]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[cookie]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[wehrmacht]] , Cookie ... additionalCookies ) { AssertParameter . notNull ( [[wehrmacht]] , "Cookie" ) ; final List < Cookie > cookieList = new LinkedList < Cookie > ( ) ; cookieList . add ( [[wehrmacht]] ) ; Collections . addAll ( cookieList , additionalCookies ) ; return new Cookies ( cookieList ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 307 ---------------------------------------------
Clean up data from the backing map . --> delete from cache --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[celle]] ( Set < KeyAndSource > keysAndSources ) { synchronized ( lock ) { for ( KeyAndSource keyAndSource : keysAndSources ) { Multiset < Object > set = backingMap . get ( keyAndSource . key ) ; if ( set != null ) { set . remove ( keyAndSource . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( keyAndSource . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 308 ---------------------------------------------
Index bindings . --> index the binding --> Socre: 1.0

[[[[Adv]]]]: void index ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void index ( ) { for ( Binding < ? > [[lobotomized]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[lobotomized]] . getKey ( ) . getTypeLiteral ( ) , [[lobotomized]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 309 ---------------------------------------------
Add a parameter to the request . --> Set truer --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[truer]] ( String [[insolence]] , Collection < ? > [[duller]] ) { spec . param ( [[insolence]] , [[duller]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 310 ---------------------------------------------
Gets the value of the specified type as a List . --> Retrieve annotations from arraignment with generic type --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > getList ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[original]] = get ( [[path]] ) ; final List < T > [[newList]] = new LinkedList < T > ( ) ; if ( [[original]] != null ) { for ( T t : [[original]] ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > getList ( String [[arraignment]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > [[annunciation]] = get ( [[arraignment]] ) ; final List < T > [[ran]] = new LinkedList < T > ( ) ; if ( [[annunciation]] != null ) { for ( T t : [[annunciation]] ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 311 ---------------------------------------------
Removes a failed binding . --> remove failed bind bindings --> Socre: 1.0

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[binding]] , InjectionPoint ip ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void removeFailedJitBinding ( Binding < ? > [[headdress]] , InjectionPoint ip ) { failedJitBindings . add ( [[headdress]] . getKey ( ) ) ; jitBindings . remove ( [[headdress]] . getKey ( ) ) ; membersInjectorStore . remove ( [[headdress]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[headdress]] ) ; if ( ip != null ) { constructors . remove ( ip ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 312 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 263 / 44 / 5 / 312:  31%|███       | 312/1000 [4:09:48<9:10:52, 48.04s/it][Succeeded / Failed / Skipped / Total] 263 / 44 / 5 / 312:  31%|███▏      | 313/1000 [4:09:59<9:08:41, 47.92s/it][Succeeded / Failed / Skipped / Total] 264 / 44 / 5 / 313:  31%|███▏      | 313/1000 [4:09:59<9:08:41, 47.92s/it][Succeeded / Failed / Skipped / Total] 264 / 44 / 5 / 313:  31%|███▏      | 314/1000 [4:10:13<9:06:40, 47.81s/it][Succeeded / Failed / Skipped / Total] 264 / 45 / 5 / 314:  31%|███▏      | 314/1000 [4:10:13<9:06:40, 47.81s/it][Succeeded / Failed / Skipped / Total] 264 / 45 / 5 / 314:  32%|███▏      | 315/1000 [4:10:24<9:04:32, 47.70s/it][Succeeded / Failed / Skipped / Total] 265 / 45 / 5 / 315:  32%|███▏      | 315/1000 [4:10:24<9:04:32, 47.70s/it][Succeeded / Failed / Skipped / Total] 265 / 45 / 5 / 315:  32%|███▏      | 316/1000 [4:10:30<9:02:13, 47.56s/it][Succeeded / Failed / Skipped / Total] 265 / 46 / 5 / 316:  32%|███▏      | 316/1000 [4:10:30<9:02:13, 47.56s/it][Succeeded / Failed / Skipped / Total] 265 / 46 / 5 / 316:  32%|███▏      | 317/1000 [4:10:40<9:00:06, 47.45s/it][Succeeded / Failed / Skipped / Total] 266 / 46 / 5 / 317:  32%|███▏      | 317/1000 [4:10:40<9:00:06, 47.45s/it][Succeeded / Failed / Skipped / Total] 266 / 46 / 5 / 317:  32%|███▏      | 318/1000 [4:11:37<8:59:38, 47.48s/it][Succeeded / Failed / Skipped / Total] 267 / 46 / 5 / 318:  32%|███▏      | 318/1000 [4:11:37<8:59:38, 47.48s/it][Succeeded / Failed / Skipped / Total] 267 / 46 / 5 / 318:  32%|███▏      | 319/1000 [4:11:53<8:57:45, 47.38s/it][Succeeded / Failed / Skipped / Total] 268 / 46 / 5 / 319:  32%|███▏      | 319/1000 [4:11:53<8:57:45, 47.38s/it][Succeeded / Failed / Skipped / Total] 268 / 46 / 5 / 319:  32%|███▏      | 320/1000 [4:12:17<8:56:06, 47.30s/it][Succeeded / Failed / Skipped / Total] 269 / 46 / 5 / 320:  32%|███▏      | 320/1000 [4:12:17<8:56:06, 47.30s/it][Succeeded / Failed / Skipped / Total] 269 / 46 / 5 / 320:  32%|███▏      | 321/1000 [4:12:35<8:54:18, 47.21s/it]Adds a cookie to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String key , Object value , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( key , value , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[disrobe]] ( String key , Object value , Object ... [[arranged]] ) { spec . cookie ( key , value , [[arranged]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 313 ---------------------------------------------
Gets all parameters . --> Obtain roasting --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[roasting]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 314 ---------------------------------------------
Adds a parameter to the request . --> [[[FAILED]]]

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[overbite]] ( String parameterName , Object ... parameterValues ) { spec . param ( parameterName , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 315 ---------------------------------------------
Binds the logger . --> todo change --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[riveted]] ( InjectorImpl injector ) { Key < Logger > key = Key . get ( Logger . class ) ; LoggerFactory loggerFactory = new LoggerFactory ( ) ; injector . state . putBinding ( key , new ProviderInstanceBindingImpl < Logger > ( injector , key , SourceProvider . UNKNOWN_SOURCE , loggerFactory , Scoping . UNSCOPED , loggerFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 316 ---------------------------------------------
Get the value of the given path as a object . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[interprets]] > [[interprets]] getObject ( String path , Class < [[interprets]] > objectType ) { Object [[captive]] = getFromPath ( path , "False" != "False" ) ; return getObjectAsType ( [[captive]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 317 ---------------------------------------------
Returns the internal dependencies of the given binding . --> todo support --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > [[binding]] ) { if ( [[binding]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[binding]] ) . getInternalDependencies ( ) ; } else if ( [[binding]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[binding]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[detain]] ( BindingImpl < ? > [[clarify]] ) { if ( [[clarify]] instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) [[clarify]] ) . getInternalDependencies ( ) ; } else if ( [[clarify]] instanceof HasDependencies ) { return ( ( HasDependencies ) [[clarify]] ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 318 ---------------------------------------------
Convert a constant string to a constant binding . --> Helper method for creating an accommodation --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > [[key]] , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[accommodation]] ( Key < T > [[accounts]] , Errors [[himura]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 319 ---------------------------------------------
The type of the provider . --> Provides a TypeLiteral --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[rather]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 320 ---------------------------------------------
Binds the given injector . --> This method will be called once perjector --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[compute]] ( InjectorImpl [[soldiers]] ) { Key < Injector > key = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[soldiers]] ) ; [[soldiers]] . state . putBinding ( key , new ProviderInstanceBindingImpl < Injector > ( [[soldiers]] , key , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 321 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 270 / 46 / 5 / 321:  32%|███▏      | 321/1000 [4:12:35<8:54:18, 47.21s/it][Succeeded / Failed / Skipped / Total] 270 / 46 / 5 / 321:  32%|███▏      | 322/1000 [4:12:56<8:52:36, 47.13s/it][Succeeded / Failed / Skipped / Total] 270 / 47 / 5 / 322:  32%|███▏      | 322/1000 [4:12:56<8:52:36, 47.13s/it][Succeeded / Failed / Skipped / Total] 270 / 47 / 5 / 322:  32%|███▏      | 323/1000 [4:12:58<8:50:12, 46.99s/it][Succeeded / Failed / Skipped / Total] 271 / 47 / 5 / 323:  32%|███▏      | 323/1000 [4:12:58<8:50:12, 46.99s/it][Succeeded / Failed / Skipped / Total] 271 / 47 / 5 / 323:  32%|███▏      | 324/1000 [4:13:25<8:48:45, 46.93s/it][Succeeded / Failed / Skipped / Total] 272 / 47 / 5 / 324:  32%|███▏      | 324/1000 [4:13:25<8:48:45, 46.93s/it][Succeeded / Failed / Skipped / Total] 272 / 47 / 5 / 324:  32%|███▎      | 325/1000 [4:13:29<8:46:28, 46.80s/it][Succeeded / Failed / Skipped / Total] 273 / 47 / 5 / 325:  32%|███▎      | 325/1000 [4:13:29<8:46:28, 46.80s/it][Succeeded / Failed / Skipped / Total] 273 / 47 / 5 / 325:  33%|███▎      | 326/1000 [4:13:37<8:44:22, 46.68s/it][Succeeded / Failed / Skipped / Total] 274 / 47 / 5 / 326:  33%|███▎      | 326/1000 [4:13:37<8:44:22, 46.68s/it][Succeeded / Failed / Skipped / Total] 274 / 47 / 5 / 326:  33%|███▎      | 327/1000 [4:14:25<8:43:37, 46.68s/it][Succeeded / Failed / Skipped / Total] 275 / 47 / 5 / 327:  33%|███▎      | 327/1000 [4:14:25<8:43:37, 46.68s/it][Succeeded / Failed / Skipped / Total] 275 / 47 / 5 / 327:  33%|███▎      | 328/1000 [4:14:49<8:42:05, 46.61s/it][Succeeded / Failed / Skipped / Total] 276 / 47 / 5 / 328:  33%|███▎      | 328/1000 [4:14:49<8:42:05, 46.61s/it][Succeeded / Failed / Skipped / Total] 276 / 47 / 5 / 328:  33%|███▎      | 329/1000 [4:15:00<8:40:05, 46.51s/it]Resolve all types in the given array of types . --> Resolve a type literal --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { [[result]] [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > resolveAll ( Type [ ] types ) { TypeLiteral < ? > [ ] [[allelujah]] = new TypeLiteral < ? > [ types . length ] ; for ( int t = 0 ; t < types . length ; t ++ ) { [[allelujah]] [ t ] = resolve ( types [ t ] ) ; } return ImmutableList . copyOf ( [[allelujah]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 322 ---------------------------------------------
Creates an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[ErrorsException]] { Class < ? > [[rawType]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[rawType]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws [[zionists]] { Class < ? > [[bienvenido]] = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = [[bienvenido]] . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 323 ---------------------------------------------
Checks to see if any binding annotations found in the annotated element . --> Finds bapuuu --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[bapu]] ( Member [[centrist]] , Errors errors ) { Annotation misplacedBindingAnnotation = Annotations . findBindingAnnotation ( errors , [[centrist]] , ( ( AnnotatedElement ) [[centrist]] ) . getAnnotations ( ) ) ; if ( misplacedBindingAnnotation == null ) { return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 324 ---------------------------------------------
Convert the given class loader to the system bridge . --> used by SystemBridge --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[civility]] ( ClassLoader classLoader ) { return classLoader != null ? classLoader : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 325 ---------------------------------------------
Clean up the internal dependencies . --> return true if false --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > [[encountered]] ) { boolean bindingFailed = "[[False]]" != "[[False]]" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( [[encountered]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[ferrand]] ( BindingImpl < ? > binding , Set < Key > [[benno]] ) { boolean bindingFailed = "[[Blanks]]" != "[[Blanks]]" ; Set < Dependency < ? > > deps = getInternalDependencies ( binding ) ; for ( Dependency dep : deps ) { Key < ? > depKey = dep . getKey ( ) ; InjectionPoint ip = dep . getInjectionPoint ( ) ; if ( [[benno]] . add ( depKey ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 326 ---------------------------------------------
Fix annotations . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > fixAnnotations ( Key < ? > [[pyo]] ) { return [[pyo]] . getAnnotation ( ) == null ? [[pyo]] : Key . get ( [[pyo]] . getTypeLiteral ( ) , [[pyo]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 327 ---------------------------------------------
Returns a TypeLiteral for the given type . --> Canonicalizes the given TypeLiteral --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type [[type]] = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > canonicalizeForKey ( TypeLiteral < T > typeLiteral ) { Type [[billabong]] = typeLiteral . getType ( ) ; if ( ! isFullySpecified ( [[billabong]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( typeLiteral ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( typeLiteral . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType parameterizedType = ( ParameterizedType ) [[billabong]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 328 ---------------------------------------------
Prepare the built in converters . --> Called by injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl [[injector]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[cretins]] ( InjectorImpl [[cook]] ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 329 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 277 / 47 / 5 / 329:  33%|███▎      | 329/1000 [4:15:00<8:40:05, 46.51s/it][Succeeded / Failed / Skipped / Total] 277 / 47 / 5 / 329:  33%|███▎      | 330/1000 [4:15:14<8:38:13, 46.41s/it][Succeeded / Failed / Skipped / Total] 277 / 48 / 5 / 330:  33%|███▎      | 330/1000 [4:15:14<8:38:13, 46.41s/it][Succeeded / Failed / Skipped / Total] 277 / 48 / 5 / 330:  33%|███▎      | 331/1000 [4:15:24<8:36:13, 46.30s/it][Succeeded / Failed / Skipped / Total] 278 / 48 / 5 / 331:  33%|███▎      | 331/1000 [4:15:24<8:36:13, 46.30s/it][Succeeded / Failed / Skipped / Total] 278 / 48 / 5 / 331:  33%|███▎      | 332/1000 [4:15:33<8:34:11, 46.18s/it][Succeeded / Failed / Skipped / Total] 279 / 48 / 5 / 332:  33%|███▎      | 332/1000 [4:15:33<8:34:11, 46.18s/it][Succeeded / Failed / Skipped / Total] 279 / 48 / 5 / 332:  33%|███▎      | 333/1000 [4:15:38<8:32:02, 46.06s/it][Succeeded / Failed / Skipped / Total] 280 / 48 / 5 / 333:  33%|███▎      | 333/1000 [4:15:38<8:32:02, 46.06s/it][Succeeded / Failed / Skipped / Total] 280 / 48 / 5 / 333:  33%|███▎      | 334/1000 [4:16:52<8:32:13, 46.15s/it][Succeeded / Failed / Skipped / Total] 281 / 48 / 5 / 334:  33%|███▎      | 334/1000 [4:16:52<8:32:13, 46.15s/it][Succeeded / Failed / Skipped / Total] 281 / 48 / 5 / 334:  34%|███▎      | 335/1000 [4:16:54<8:29:58, 46.01s/it][Succeeded / Failed / Skipped / Total] 282 / 48 / 5 / 335:  34%|███▎      | 335/1000 [4:16:54<8:29:58, 46.01s/it][Succeeded / Failed / Skipped / Total] 282 / 48 / 5 / 335:  34%|███▎      | 336/1000 [4:17:11<8:28:15, 45.93s/it][Succeeded / Failed / Skipped / Total] 282 / 49 / 5 / 336:  34%|███▎      | 336/1000 [4:17:11<8:28:15, 45.93s/it][Succeeded / Failed / Skipped / Total] 282 / 49 / 5 / 336:  34%|███▎      | 337/1000 [4:17:31<8:26:39, 45.85s/it]Determine whether two methods are overridden . --> This method should be called once per hour --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method [[a]] , Method [[b]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[climbing]] ( Method [[hourglass]] , Method [[mallen]] ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 330 ---------------------------------------------
Request an initializable instance . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[provisionCallback]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > [[sheltered]] = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 331 ---------------------------------------------
Returns a scope for the given scope . --> protected for testing --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return creator ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > key , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[cooled]] ) { if ( [[cooled]] . isNoScope ( ) ) { return creator ; } Scope scope = [[cooled]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 332 ---------------------------------------------
Initializes the delegate . --> Setter for mousebling --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[burbling]] ( MembersInjector < T > [[swipe]] ) { checkState ( this . [[earmarks]] == null , "delegate already initialized" ) ; this . [[earmarks]] = checkNotNull ( [[swipe]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 333 ---------------------------------------------
Makes sure that the scope is an injectable . --> proof of a scoping --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[foolproof]] ( Scoping scoping , InjectorImpl injector , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = scoping . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return scoping ; } ScopeBinding scope = injector . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 334 ---------------------------------------------
Override this method to customize the ServletRequest . --> Prevent a ServletRequest --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[withDispatcher]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest [[republic]] ( ServletRequest servletRequest , final ManagedServletPipeline servletPipeline ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 335 ---------------------------------------------
Creates a new instance using the given arguments . --> create a new object --> Socre: 1.0

[[[[Adv]]]]: public T newInstance ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T newInstance ( Object [ ] [[boris]] ) throws Throwable { constructor . setAccessible ( "[[Phony]]" == "[[Phony]]" ) ; try { return constructor . newInstance ( [[boris]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 336 ---------------------------------------------
Generates an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T [[extends]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T [[reputed]] Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 337 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 283 / 49 / 5 / 337:  34%|███▎      | 337/1000 [4:17:31<8:26:39, 45.85s/it][Succeeded / Failed / Skipped / Total] 283 / 49 / 5 / 337:  34%|███▍      | 338/1000 [4:18:04<8:25:27, 45.81s/it][Succeeded / Failed / Skipped / Total] 284 / 49 / 5 / 338:  34%|███▍      | 338/1000 [4:18:04<8:25:27, 45.81s/it][Succeeded / Failed / Skipped / Total] 284 / 49 / 5 / 338:  34%|███▍      | 339/1000 [4:19:09<8:25:18, 45.87s/it][Succeeded / Failed / Skipped / Total] 285 / 49 / 5 / 339:  34%|███▍      | 339/1000 [4:19:09<8:25:18, 45.87s/it][Succeeded / Failed / Skipped / Total] 285 / 49 / 5 / 339:  34%|███▍      | 340/1000 [4:19:33<8:23:51, 45.81s/it][Succeeded / Failed / Skipped / Total] 285 / 50 / 5 / 340:  34%|███▍      | 340/1000 [4:19:33<8:23:51, 45.81s/it][Succeeded / Failed / Skipped / Total] 285 / 50 / 5 / 340:  34%|███▍      | 341/1000 [4:20:23<8:23:12, 45.82s/it][Succeeded / Failed / Skipped / Total] 286 / 50 / 5 / 341:  34%|███▍      | 341/1000 [4:20:23<8:23:12, 45.82s/it][Succeeded / Failed / Skipped / Total] 286 / 50 / 5 / 341:  34%|███▍      | 342/1000 [4:20:32<8:21:16, 45.71s/it][Succeeded / Failed / Skipped / Total] 287 / 50 / 5 / 342:  34%|███▍      | 342/1000 [4:20:32<8:21:16, 45.71s/it][Succeeded / Failed / Skipped / Total] 287 / 50 / 5 / 342:  34%|███▍      | 343/1000 [4:20:42<8:19:23, 45.61s/it]Checks if the class has the same version of the given class loader . --> method to test class --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader classLoader ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[prescription]] ( ClassLoader classLoader ) { Class < ? > [[armoire]] = net . sf . cglib . reflect . FastClass . class ; try { return classLoader . loadClass ( [[armoire]] . getName ( ) ) == [[armoire]] ; } catch ( ClassNotFoundException e ) { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 338 ---------------------------------------------
Normalizes the given path . --> Returns the BAM formatted string --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String path ) { StringBuilder [[sb]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[bamberg]] ( String path ) { StringBuilder [[kolkhoz]] = new StringBuilder ( path . length ( ) ) ; int queryStart = path . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = path . substring ( queryStart ) ; path = path . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 339 ---------------------------------------------
Determines if retention at runtime . --> ztodo support --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > annotationType ) { Retention [[retention]] = annotationType . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[zaza]] ( Class < ? extends Annotation > annotationType ) { Retention [[neo]] = annotationType . getAnnotation ( Retention . class ) ; return [[neo]] != null && [[neo]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 340 ---------------------------------------------
Checks if the given member is publicly accessible . --> [[[FAILED]]]

[[[[Adv]]]]: private static boolean [[isPubliclyCallable]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[parameterTypes]] ; if ( member instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean [[validate]] ( Member member ) { if ( ! Modifier . isPublic ( member . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[antelope]] ; if ( member instanceof Constructor ) { [[antelope]] = ( ( Constructor ) member ) . getParameterTypes ( ) ; } else { Method method = ( Method ) member ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[antelope]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[antelope]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 341 ---------------------------------------------
Find scope annotation . --> todo override this --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[found]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[found]] != null ) { errors . duplicateScopeAnnotations ( [[found]] , annotationType ) ; } else { [[found]] = annotationType ; } } } return [[found]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[concerned]] ( Errors errors , Annotation [ ] annotations ) { Class < ? extends Annotation > [[gift]] = null ; for ( Annotation annotation : annotations ) { Class < ? extends Annotation > annotationType = annotation . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( [[gift]] != null ) { errors . duplicateScopeAnnotations ( [[gift]] , annotationType ) ; } else { [[gift]] = annotationType ; } } } return [[gift]] ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 342 ---------------------------------------------
Returns the name of the given key . --> method to table --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation [[annotation]] = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( [[annotation]] != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[tablecloth]] ( Key < ? > [[fondle]] ) { Annotation [[paedophile]] = [[fondle]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[fondle]] . getAnnotationType ( ) ; if ( [[paedophile]] != null && ! isMarker ( annotationType ) ) { return [[fondle]] . getAnnotation ( ) . toString ( ) ; } else if ( [[fondle]] . getAnnotationType ( ) != null ) { return "@" + [[fondle]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 343 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 288 / 50 / 5 / 343:  34%|███▍      | 343/1000 [4:20:42<8:19:23, 45.61s/it][Succeeded / Failed / Skipped / Total] 288 / 50 / 5 / 343:  34%|███▍      | 344/1000 [4:20:47<8:17:18, 45.49s/it][Succeeded / Failed / Skipped / Total] 289 / 50 / 5 / 344:  34%|███▍      | 344/1000 [4:20:47<8:17:18, 45.49s/it][Succeeded / Failed / Skipped / Total] 289 / 50 / 5 / 344:  34%|███▍      | 345/1000 [4:21:43<8:16:53, 45.52s/it][Succeeded / Failed / Skipped / Total] 290 / 50 / 5 / 345:  34%|███▍      | 345/1000 [4:21:43<8:16:53, 45.52s/it][Succeeded / Failed / Skipped / Total] 290 / 50 / 5 / 345:  35%|███▍      | 346/1000 [4:22:33<8:16:15, 45.53s/it][Succeeded / Failed / Skipped / Total] 291 / 50 / 5 / 346:  35%|███▍      | 346/1000 [4:22:33<8:16:15, 45.53s/it][Succeeded / Failed / Skipped / Total] 291 / 50 / 5 / 346:  35%|███▍      | 347/1000 [4:22:42<8:14:22, 45.43s/it][Succeeded / Failed / Skipped / Total] 292 / 50 / 5 / 347:  35%|███▍      | 347/1000 [4:22:42<8:14:22, 45.43s/it][Succeeded / Failed / Skipped / Total] 292 / 50 / 5 / 347:  35%|███▍      | 348/1000 [4:22:46<8:12:19, 45.31s/it][Succeeded / Failed / Skipped / Total] 293 / 50 / 5 / 348:  35%|███▍      | 348/1000 [4:22:46<8:12:19, 45.31s/it][Succeeded / Failed / Skipped / Total] 293 / 50 / 5 / 348:  35%|███▍      | 349/1000 [4:23:03<8:10:41, 45.23s/it][Succeeded / Failed / Skipped / Total] 294 / 50 / 5 / 349:  35%|███▍      | 349/1000 [4:23:03<8:10:41, 45.23s/it][Succeeded / Failed / Skipped / Total] 294 / 50 / 5 / 349:  35%|███▌      | 350/1000 [4:23:05<8:08:35, 45.10s/it][Succeeded / Failed / Skipped / Total] 295 / 50 / 5 / 350:  35%|███▌      | 350/1000 [4:23:05<8:08:35, 45.10s/it][Succeeded / Failed / Skipped / Total] 295 / 50 / 5 / 350:  35%|███▌      | 351/1000 [4:23:11<8:06:38, 44.99s/it]Adds the binding to the direct binding . --> Binds the longlegs --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[longlegs]] ( Binder [[martyred]] ) { [[martyred]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 344 ---------------------------------------------
Checks if interceptor has scope annotation . --> zohith --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[zhao]] ( Class < ? extends Interceptor > interceptorClass ) { for ( Annotation annotation : interceptorClass . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 345 ---------------------------------------------
Retrieve a constructor from the cache . --> Get the raus for the given InjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors errors ) throws ErrorsException { return cache . get ( [[constructorInjector]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[raus]] ( InjectionPoint [[radium]] , Errors errors ) throws ErrorsException { return cache . get ( [[radium]] , errors ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 346 ---------------------------------------------
Gets the binding for a given type . --> also called by unit tests --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > [[type]] , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[found]] = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[found]] == null ? Key . get ( [[type]] ) : Key . get ( [[type]] , [[found]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[lash]] ( TypeLiteral < ? > [[yuan]] , Member member , Annotation [ ] annotations , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Annotation [[gratia]] = findBindingAnnotation ( errors , member , annotations ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return [[gratia]] == null ? Key . get ( [[yuan]] ) : Key . get ( [[yuan]] , [[gratia]] ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 347 ---------------------------------------------
Returns the module for the given module . --> Overrides default implementation --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[overload]] ( Module module ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 348 ---------------------------------------------
Replace the source code . --> Removes messages from source --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[rembrandt]] ( ) throws ObjectStreamException { Object [ ] sourcesAsStrings = sources . toArray ( ) ; for ( int i = 0 ; i < sourcesAsStrings . length ; i ++ ) { sourcesAsStrings [ i ] = Errors . convert ( sourcesAsStrings [ i ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( sourcesAsStrings ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 349 ---------------------------------------------
Returns all registered methods . --> Shortcut implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[shortening]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 350 ---------------------------------------------
Factory method to create a real map binder . --> private helper for testing --> Socre: 1.0

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[newRealMapBinder]] ( Binder [[binder]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( [[binder]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < K , V > RealMapBinder < K , V > [[sudd]] ( Binder [[bertha]] , TypeLiteral < K > keyType , Key < V > valueTypeAndAnnotation ) { [[bertha]] = [[bertha]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[sudd]] ( [[bertha]] , keyType , valueType , valueTypeAndAnnotation . ofType ( mapOf ( keyType , valueType ) ) , RealMultibinder . newRealSetBinder ( [[bertha]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( keyType , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 351 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 295 / 51 / 5 / 351:  35%|███▌      | 351/1000 [4:23:11<8:06:38, 44.99s/it][Succeeded / Failed / Skipped / Total] 295 / 51 / 5 / 351:  35%|███▌      | 352/1000 [4:23:17<8:04:42, 44.88s/it][Succeeded / Failed / Skipped / Total] 296 / 51 / 5 / 352:  35%|███▌      | 352/1000 [4:23:17<8:04:42, 44.88s/it][Succeeded / Failed / Skipped / Total] 296 / 51 / 5 / 352:  35%|███▌      | 353/1000 [4:23:27<8:02:52, 44.78s/it][Succeeded / Failed / Skipped / Total] 297 / 51 / 5 / 353:  35%|███▌      | 353/1000 [4:23:27<8:02:52, 44.78s/it][Succeeded / Failed / Skipped / Total] 297 / 51 / 5 / 353:  35%|███▌      | 354/1000 [4:23:58<8:01:43, 44.74s/it][Succeeded / Failed / Skipped / Total] 298 / 51 / 5 / 354:  35%|███▌      | 354/1000 [4:23:58<8:01:43, 44.74s/it][Succeeded / Failed / Skipped / Total] 298 / 51 / 5 / 354:  36%|███▌      | 355/1000 [4:24:05<7:59:49, 44.64s/it][Succeeded / Failed / Skipped / Total] 298 / 52 / 5 / 355:  36%|███▌      | 355/1000 [4:24:05<7:59:49, 44.64s/it][Succeeded / Failed / Skipped / Total] 298 / 52 / 5 / 355:  36%|███▌      | 356/1000 [4:24:08<7:57:50, 44.52s/it][Succeeded / Failed / Skipped / Total] 299 / 52 / 5 / 356:  36%|███▌      | 356/1000 [4:24:08<7:57:50, 44.52s/it][Succeeded / Failed / Skipped / Total] 299 / 52 / 5 / 356:  36%|███▌      | 357/1000 [4:24:49<7:56:59, 44.51s/it][Succeeded / Failed / Skipped / Total] 300 / 52 / 5 / 357:  36%|███▌      | 357/1000 [4:24:49<7:56:59, 44.51s/it][Succeeded / Failed / Skipped / Total] 300 / 52 / 5 / 357:  36%|███▌      | 358/1000 [4:25:35<7:56:17, 44.51s/it]Initializes the delegate provider . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[trove]] ( Provider < T > [[snowshoes]] ) { checkState ( this . [[disturbances]] == null , "delegate already initialized" ) ; this . [[disturbances]] = checkNotNull ( [[snowshoes]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 352 ---------------------------------------------
Validates that all injected injections have been validated . --> Validate injections --> Socre: 1.0

[[[[Adv]]]]: void validateOustandingInjections ( Errors [[errors]] ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( [[errors]] ) ; } catch ( ErrorsException e ) { [[errors]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void validateOustandingInjections ( Errors [[outlets]] ) { validationStarted = "[[Fixtures]]" == "[[Fixtures]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[instruct]] : pendingInjections ) { try { [[instruct]] . validate ( [[outlets]] ) ; } catch ( ErrorsException e ) { [[outlets]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 353 ---------------------------------------------
Creates a new instance of the given construction . --> This method initializes the requirements --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] [[parameters]] = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( [[parameters]] ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[requirements]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T t ; try { Object [ ] [[directive]] = SingleParameterInjector . getAll ( context , parameterInjectors ) ; t = constructionProxy . newInstance ( [[directive]] ) ; constructionContext . setProxyDelegates ( t ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 354 ---------------------------------------------
Check whether a constructor has parameters matching the given type . --> Checks whether the given constructor matches the parameters --> Socre: 1.0

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > [[type]] , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = [[type]] . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean constructorHasMatchingParams ( TypeLiteral < ? > [[paella]] , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = [[paella]] . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[entrySetBinder]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[valueKey]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[entrySetBinder]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[entrySetBinder]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[valueKey]] ) ) ; return [[valueKey]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > [[reconstruct]] = bindingSelection . getEntrySetBinder ( ) ; Key < V > [[jared]] = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( [[reconstruct]] . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; [[reconstruct]] . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , [[jared]] ) ) ; return [[jared]] ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 356 ---------------------------------------------
Invokes the given method on the proxy . --> Overrides default implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object invoke ( Object [[proxy]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object invoke ( Object [[bypass]] , final Method method , final Object [ ] args ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 357 ---------------------------------------------
New real set binder . --> Instantiates a real Multibinder with the given key --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[binder]] , Key < T > key ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[binder]] , key ) ; [[binder]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[lampoon]] , Key < T > key ) { [[lampoon]] = [[lampoon]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > result = new RealMultibinder <> ( [[lampoon]] , key ) ; [[lampoon]] . install ( result ) ; return result ; }
[[[[Nl]]]]: Implementation of newSetBinder .
--------------------------------------------- Result 358 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 301 / 52 / 5 / 358:  36%|███▌      | 358/1000 [4:25:35<7:56:17, 44.51s/it][Succeeded / Failed / Skipped / Total] 301 / 52 / 5 / 358:  36%|███▌      | 359/1000 [4:25:51<7:54:41, 44.43s/it][Succeeded / Failed / Skipped / Total] 301 / 53 / 5 / 359:  36%|███▌      | 359/1000 [4:25:51<7:54:41, 44.43s/it][Succeeded / Failed / Skipped / Total] 301 / 53 / 5 / 359:  36%|███▌      | 360/1000 [4:26:25<7:53:39, 44.41s/it][Succeeded / Failed / Skipped / Total] 302 / 53 / 5 / 360:  36%|███▌      | 360/1000 [4:26:25<7:53:39, 44.41s/it][Succeeded / Failed / Skipped / Total] 302 / 53 / 5 / 360:  36%|███▌      | 361/1000 [4:26:43<7:52:06, 44.33s/it][Succeeded / Failed / Skipped / Total] 303 / 53 / 5 / 361:  36%|███▌      | 361/1000 [4:26:43<7:52:06, 44.33s/it][Succeeded / Failed / Skipped / Total] 303 / 53 / 5 / 361:  36%|███▌      | 362/1000 [4:27:14<7:50:59, 44.29s/it][Succeeded / Failed / Skipped / Total] 304 / 53 / 5 / 362:  36%|███▌      | 362/1000 [4:27:14<7:50:59, 44.29s/it][Succeeded / Failed / Skipped / Total] 304 / 53 / 5 / 362:  36%|███▋      | 363/1000 [4:27:41<7:49:45, 44.25s/it][Succeeded / Failed / Skipped / Total] 305 / 53 / 5 / 363:  36%|███▋      | 363/1000 [4:27:41<7:49:45, 44.25s/it][Succeeded / Failed / Skipped / Total] 305 / 53 / 5 / 363:  36%|███▋      | 364/1000 [4:27:46<7:47:51, 44.14s/it][Succeeded / Failed / Skipped / Total] 306 / 53 / 5 / 364:  36%|███▋      | 364/1000 [4:27:46<7:47:51, 44.14s/it][Succeeded / Failed / Skipped / Total] 306 / 53 / 5 / 364:  36%|███▋      | 365/1000 [4:29:22<7:48:37, 44.28s/it][Succeeded / Failed / Skipped / Total] 307 / 53 / 5 / 365:  36%|███▋      | 365/1000 [4:29:22<7:48:37, 44.28s/it][Succeeded / Failed / Skipped / Total] 307 / 53 / 5 / 365:  37%|███▋      | 366/1000 [4:29:23<7:46:39, 44.16s/it]Checks whether a type is not defined . --> Hijack a configuration exception --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message [[msg]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return [[msg]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[hijackings]] ( TypeLiteral < ? > typeLiteral , ConfigurationException ce ) { Collection < Message > messages = ce . getErrorMessages ( ) ; if ( messages . size ( ) == 1 ) { Message [[hundert]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( typeLiteral ) . getMessages ( ) ) ; return [[hundert]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( messages ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 359 ---------------------------------------------
Create a missing implementation for a given key . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[sb]] = new StringBuilder ( ) ; [[sb]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder [[matches]] = new StringBuilder ( ) ; [[matches]] . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 360 ---------------------------------------------
Returns the dependencies for the given ctor . --> borrowed from jon --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > [[implementation]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! [[implementation]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[implementation]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[biker]] ( InjectionPoint [[jon]] , TypeLiteral < ? > [[hysterically]] ) { ImmutableSet . Builder < Dependency < ? > > builder = ImmutableSet . builder ( ) ; builder . addAll ( [[jon]] . getDependencies ( ) ) ; if ( ! [[hysterically]] . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( [[hysterically]] ) ) { builder . addAll ( ip . getDependencies ( ) ) ; } } return builder . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 361 ---------------------------------------------
Gets the internal constructor . --> Hibernate InjectionProxy --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[hussein]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 362 ---------------------------------------------
Returns the set of internal dependencies . --> factory method --> Socre: 1.0

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[fougasse]] ( ) { ImmutableSet . Builder < InjectionPoint > builder = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { builder . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 363 ---------------------------------------------
Checks if is annotated with annotation . --> Whether bernoulli or not --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[bernoulli]] ( Constructor [[peptide]] ) { return [[peptide]] . isAnnotationPresent ( Inject . class ) || [[peptide]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 364 ---------------------------------------------
Removes Asserts from the given dependencies . --> Returns the hunk of the specified dependency --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[builder]] . add ( dep ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[hunk]] ( Set < Dependency < ? > > [[coincidences]] ) { ImmutableSet . Builder < Dependency < ? > > [[surfers]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[coincidences]] ) { Class < ? > annotationType = dep . getKey ( ) . getAnnotationType ( ) ; if ( annotationType == null || ! annotationType . equals ( Assisted . class ) ) { [[surfers]] . add ( dep ) ; } } return [[surfers]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 365 ---------------------------------------------
Initializes the lookup . --> Hooked Hadoop --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[hôtel]] ( Errors [[desilva]] ) { injector . lookups = injector ; new LookupProcessor ( [[desilva]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 366 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 53 / 5 / 366:  37%|███▋      | 366/1000 [4:29:23<7:46:39, 44.16s/it][Succeeded / Failed / Skipped / Total] 308 / 53 / 5 / 366:  37%|███▋      | 367/1000 [4:29:24<7:44:39, 44.04s/it][Succeeded / Failed / Skipped / Total] 308 / 54 / 5 / 367:  37%|███▋      | 367/1000 [4:29:24<7:44:39, 44.04s/it][Succeeded / Failed / Skipped / Total] 308 / 54 / 5 / 367:  37%|███▋      | 368/1000 [4:30:10<7:44:00, 44.05s/it][Succeeded / Failed / Skipped / Total] 309 / 54 / 5 / 368:  37%|███▋      | 368/1000 [4:30:10<7:44:00, 44.05s/it][Succeeded / Failed / Skipped / Total] 309 / 54 / 5 / 368:  37%|███▋      | 369/1000 [4:30:13<7:42:05, 43.94s/it][Succeeded / Failed / Skipped / Total] 309 / 55 / 5 / 369:  37%|███▋      | 369/1000 [4:30:13<7:42:05, 43.94s/it][Succeeded / Failed / Skipped / Total] 309 / 55 / 5 / 369:  37%|███▋      | 370/1000 [4:31:00<7:41:26, 43.95s/it][Succeeded / Failed / Skipped / Total] 310 / 55 / 5 / 370:  37%|███▋      | 370/1000 [4:31:00<7:41:26, 43.95s/it][Succeeded / Failed / Skipped / Total] 310 / 55 / 5 / 370:  37%|███▋      | 371/1000 [4:32:12<7:41:30, 44.02s/it][Succeeded / Failed / Skipped / Total] 311 / 55 / 5 / 371:  37%|███▋      | 371/1000 [4:32:12<7:41:30, 44.02s/it][Succeeded / Failed / Skipped / Total] 311 / 55 / 5 / 371:  37%|███▋      | 372/1000 [4:32:24<7:39:53, 43.94s/it][Succeeded / Failed / Skipped / Total] 312 / 55 / 5 / 372:  37%|███▋      | 372/1000 [4:32:25<7:39:53, 43.94s/it][Succeeded / Failed / Skipped / Total] 312 / 55 / 5 / 372:  37%|███▋      | 373/1000 [4:32:55<7:38:46, 43.90s/it]Returns the line number for the given member . --> Liefert eine a class --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[zurich]] ( Member [[corsage]] ) { Preconditions . checkArgument ( type == [[corsage]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[corsage]] , [[corsage]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[corsage]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 367 ---------------------------------------------
Find the next filter matching the given request . --> [[[FAILED]]]

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[gibbs]] ( HttpServletRequest request ) { while ( ++ index < filterDefinitions . length ) { Filter [[civility]] = filterDefinitions [ index ] . getFilterIfMatching ( request ) ; if ( [[civility]] != null ) { return [[civility]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 368 ---------------------------------------------
Creates a module for the given module . --> Methode d une reflection --> Socre: 1.0

[[[[Adv]]]]: public static Module forModule ( Object module , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( module , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module forModule ( Object module , ModuleAnnotatedMethodScanner [[duquesne]] ) { return forObject ( module , "[[Squandering]]" != "[[Squandering]]" , [[duquesne]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 369 ---------------------------------------------
Returns the binding from the given injector . --> [[[FAILED]]]

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > getBindingFromNewInjector ( final Method method , final Object [ ] args , final AssistData data ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > returnType = data . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 370 ---------------------------------------------
Transforms callable into a callable --> Zodiac function --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > callable ) { return wrap ( callable , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[zodiac]] ( Callable < T > callable ) { return wrap ( callable , [[zodiac]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
Validates the given value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > key , Object [[object]] ) { if ( [[object]] == null || [[object]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[object]] ) ) { throw new IllegalArgumentException ( "Value[" + [[object]] + "] of type[" + [[object]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[object]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[yomi]] ( Key < ? > key , Object [[wabasha]] ) { if ( [[wabasha]] == null || [[wabasha]] == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! key . getTypeLiteral ( ) . getRawType ( ) . isInstance ( [[wabasha]] ) ) { throw new IllegalArgumentException ( "Value[" + [[wabasha]] + "] of type[" + [[wabasha]] . getClass ( ) . getName ( ) + "] is not compatible with key[" + key + "]" ) ; } return [[wabasha]] ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 372 ---------------------------------------------
Wraps the given callable as a callable . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > [[callable]] , Map < Key < ? > , Object > [[seedMap]] ) { return wrap ( [[callable]] , continueRequest ( [[seedMap]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > continueRequest ( Callable < T > [[deep]] , Map < Key < ? > , Object > [[wouldnít]] ) { return wrap ( [[deep]] , continueRequest ( [[wouldnít]] ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 373 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 312 / 56 / 5 / 373:  37%|███▋      | 373/1000 [4:32:55<7:38:46, 43.90s/it][Succeeded / Failed / Skipped / Total] 312 / 56 / 5 / 373:  37%|███▋      | 374/1000 [4:33:14<7:37:20, 43.84s/it][Succeeded / Failed / Skipped / Total] 313 / 56 / 5 / 374:  37%|███▋      | 374/1000 [4:33:14<7:37:20, 43.84s/it][Succeeded / Failed / Skipped / Total] 313 / 56 / 5 / 374:  38%|███▊      | 375/1000 [4:33:22<7:35:37, 43.74s/it][Succeeded / Failed / Skipped / Total] 314 / 56 / 5 / 375:  38%|███▊      | 375/1000 [4:33:22<7:35:37, 43.74s/it][Succeeded / Failed / Skipped / Total] 314 / 56 / 5 / 375:  38%|███▊      | 376/1000 [4:33:53<7:34:32, 43.71s/it][Succeeded / Failed / Skipped / Total] 314 / 57 / 5 / 376:  38%|███▊      | 376/1000 [4:33:53<7:34:32, 43.71s/it][Succeeded / Failed / Skipped / Total] 314 / 57 / 5 / 376:  38%|███▊      | 377/1000 [4:35:24<7:35:07, 43.83s/it][Succeeded / Failed / Skipped / Total] 315 / 57 / 5 / 377:  38%|███▊      | 377/1000 [4:35:24<7:35:07, 43.83s/it][Succeeded / Failed / Skipped / Total] 315 / 57 / 5 / 377:  38%|███▊      | 378/1000 [4:36:27<7:34:54, 43.88s/it][Succeeded / Failed / Skipped / Total] 316 / 57 / 5 / 378:  38%|███▊      | 378/1000 [4:36:27<7:34:54, 43.88s/it][Succeeded / Failed / Skipped / Total] 316 / 57 / 5 / 378:  38%|███▊      | 379/1000 [4:36:50<7:33:36, 43.83s/it]Determines if the given injector can be used for optimization . --> [[[FAILED]]]

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > [[dependencies]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[badDeps]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean isValidForOptimizedAssistedInject ( Set < Dependency < ? > > [[toyo]] , Class < ? > implementation , TypeLiteral < ? > factoryType ) { Set < Dependency < ? > > [[district]] = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 374 ---------------------------------------------
Returns a new instance of the given type using the given annotation strategy . --> Factory method to create the Promotion object --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > get ( Class < T > [[propaganda]] , AnnotationStrategy [[romancing]] ) { return new Key < T > ( [[propaganda]] , [[romancing]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 375 ---------------------------------------------
Gets the binding source . --> For debugging purposes only --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[highbury]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 376 ---------------------------------------------
Find an annotation on the given method . --> [[[FAILED]]]

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation getAnnotation ( Binder binder , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation annotation = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( annotation != null ) { binder . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } annotation = foundAnnotation ; } } return annotation ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 377 ---------------------------------------------
Gets the injectors for a given injection point . --> Taken from a set of InjectionPoints --> Socre: 1.0

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors [[errorsForMember]] = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector injector = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) : new SingleMethodInjector ( this . [[injector]] , [[injectionPoint]] , [[errorsForMember]] ) ; [[injectors]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[rehabilitate]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[photography]] : injectionPoints ) { try { Errors [[coyote]] = [[photography]] . isOptional ( ) ? new Errors ( [[photography]] ) : errors . withSource ( [[photography]] ) ; SingleMemberInjector injector = [[photography]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . [[ferry]] , [[photography]] , [[coyote]] ) : new SingleMethodInjector ( this . [[ferry]] , [[photography]] , [[coyote]] ) ; [[rehabilitate]] . add ( injector ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 378 ---------------------------------------------
Creates a message with the specified message format and arguments . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Message create ( String [[messageFormat]] , Object ... [[arguments]] ) { return create ( null , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message create ( String [[turok]] , Object ... [[soulless]] ) { return create ( null , [[turok]] , [[soulless]] ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 379 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 316 / 58 / 5 / 379:  38%|███▊      | 379/1000 [4:36:50<7:33:36, 43.83s/it][Succeeded / Failed / Skipped / Total] 316 / 58 / 5 / 379:  38%|███▊      | 380/1000 [4:36:59<7:31:56, 43.74s/it][Succeeded / Failed / Skipped / Total] 317 / 58 / 5 / 380:  38%|███▊      | 380/1000 [4:36:59<7:31:56, 43.74s/it][Succeeded / Failed / Skipped / Total] 317 / 58 / 5 / 380:  38%|███▊      | 381/1000 [4:37:25<7:30:42, 43.69s/it][Succeeded / Failed / Skipped / Total] 317 / 59 / 5 / 381:  38%|███▊      | 381/1000 [4:37:25<7:30:42, 43.69s/it][Succeeded / Failed / Skipped / Total] 317 / 59 / 5 / 381:  38%|███▊      | 382/1000 [4:38:45<7:30:58, 43.78s/it][Succeeded / Failed / Skipped / Total] 317 / 60 / 5 / 382:  38%|███▊      | 382/1000 [4:38:45<7:30:58, 43.78s/it][Succeeded / Failed / Skipped / Total] 317 / 60 / 5 / 382:  38%|███▊      | 383/1000 [4:38:51<7:29:13, 43.68s/it][Succeeded / Failed / Skipped / Total] 318 / 60 / 5 / 383:  38%|███▊      | 383/1000 [4:38:51<7:29:13, 43.68s/it][Succeeded / Failed / Skipped / Total] 318 / 60 / 5 / 383:  38%|███▊      | 384/1000 [4:38:52<7:27:21, 43.57s/it]Returns an annotation strategy for the given annotation type . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[maintained]] ( Class < ? extends Annotation > [[sunsets]] ) { [[sunsets]] = Annotations . canonicalizeIfNamed ( [[sunsets]] ) ; if ( isAllDefaultMethods ( [[sunsets]] ) ) { return [[maintained]] ( generateAnnotation ( [[sunsets]] ) ) ; } checkNotNull ( [[sunsets]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[sunsets]] ) ; ensureIsBindingAnnotation ( [[sunsets]] ) ; return new AnnotationTypeStrategy ( [[sunsets]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 380 ---------------------------------------------
Format a list of error messages . --> Format a collection of errors --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > [[dependencies]] = errorMessage . getSources ( ) ; for ( int i = [[dependencies]] . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = [[dependencies]] . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int [[causeIdx]] = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , [[causeIdx]] ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String heading , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( heading ) . format ( ":%n%n" ) ; int index = 1 ; boolean displayCauses = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = index ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > [[cryonics]] = errorMessage . getSources ( ) ; for ( int i = [[cryonics]] . size ( ) - 1 ; i >= 0 ; i -- ) { Object source = [[cryonics]] . get ( i ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( displayCauses && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int [[vanquished]] = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , [[vanquished]] ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 381 ---------------------------------------------
Returns the strategy for an annotation . --> [[[FAILED]]]

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > [[annotationType]] = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; if ( Annotations . isMarker ( [[annotationType]] ) ) { return new AnnotationTypeStrategy ( [[annotationType]] , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[oww]] ( Annotation [[howcan]] ) { checkNotNull ( [[howcan]] , "annotation" ) ; Class < ? extends Annotation > [[molyneux]] = [[howcan]] . annotationType ( ) ; ensureRetainedAtRuntime ( [[molyneux]] ) ; ensureIsBindingAnnotation ( [[molyneux]] ) ; if ( Annotations . isMarker ( [[molyneux]] ) ) { return new AnnotationTypeStrategy ( [[molyneux]] , [[howcan]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[howcan]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 382 ---------------------------------------------
Removes stack trace elements from stack trace . --> [[[FAILED]]]

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void pruneStacktrace ( Throwable throwable ) { for ( Throwable t = throwable ; t != null ; t = t . getCause ( ) ) { StackTraceElement [ ] stackTrace = t . getStackTrace ( ) ; List < StackTraceElement > pruned = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String className = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( className ) && ! className . contains ( "$EnhancerByGuice$" ) ) { pruned . add ( element ) ; } } t . setStackTrace ( pruned . toArray ( new StackTraceElement [ pruned . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 383 ---------------------------------------------
Check if a class should be skipped . --> copied from parent class --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[copulate]] ( String [[jérôme]] ) { return ( parent != null && parent . shouldBeSkipped ( [[jérôme]] ) ) || classNamesToSkip . contains ( [[jérôme]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
[Succeeded / Failed / Skipped / Total] 319 / 60 / 5 / 384:  38%|███▊      | 384/1000 [4:38:52<7:27:21, 43.57s/it][Succeeded / Failed / Skipped / Total] 319 / 60 / 5 / 384:  38%|███▊      | 385/1000 [4:39:02<7:25:43, 43.49s/it][Succeeded / Failed / Skipped / Total] 320 / 60 / 5 / 385:  38%|███▊      | 385/1000 [4:39:02<7:25:43, 43.49s/it][Succeeded / Failed / Skipped / Total] 320 / 60 / 5 / 385:  39%|███▊      | 386/1000 [4:40:12<7:25:42, 43.55s/it][Succeeded / Failed / Skipped / Total] 320 / 61 / 5 / 386:  39%|███▊      | 386/1000 [4:40:12<7:25:42, 43.55s/it][Succeeded / Failed / Skipped / Total] 320 / 61 / 5 / 386:  39%|███▊      | 387/1000 [4:40:15<7:23:56, 43.45s/it][Succeeded / Failed / Skipped / Total] 321 / 61 / 5 / 387:  39%|███▊      | 387/1000 [4:40:15<7:23:56, 43.45s/it][Succeeded / Failed / Skipped / Total] 321 / 61 / 5 / 387:  39%|███▉      | 388/1000 [4:40:25<7:22:18, 43.36s/it][Succeeded / Failed / Skipped / Total] 322 / 61 / 5 / 388:  39%|███▉      | 388/1000 [4:40:25<7:22:18, 43.36s/it][Succeeded / Failed / Skipped / Total] 322 / 61 / 5 / 388:  39%|███▉      | 389/1000 [4:40:31<7:20:36, 43.27s/it][Succeeded / Failed / Skipped / Total] 323 / 61 / 5 / 389:  39%|███▉      | 389/1000 [4:40:31<7:20:36, 43.27s/it][Succeeded / Failed / Skipped / Total] 323 / 61 / 5 / 389:  39%|███▉      | 390/1000 [4:40:35<7:18:52, 43.17s/it][Succeeded / Failed / Skipped / Total] 324 / 61 / 5 / 390:  39%|███▉      | 390/1000 [4:40:35<7:18:52, 43.17s/it][Succeeded / Failed / Skipped / Total] 324 / 61 / 5 / 390:  39%|███▉      | 391/1000 [4:40:35<7:17:02, 43.06s/it]--------------------------------------------- Result 384 ---------------------------------------------
Convert an object to another element . --> for compatibility --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object o ) { ElementSource [[source]] = null ; if ( o instanceof ElementSource ) { [[source]] = ( ElementSource ) o ; o = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( o , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[ahab]] ( Object o ) { ElementSource [[earphone]] = null ; if ( o instanceof ElementSource ) { [[earphone]] = ( ElementSource ) o ; o = [[earphone]] . getDeclaringSource ( ) ; } return [[ahab]] ( o , [[earphone]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 385 ---------------------------------------------
Push a value into the given key . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[key]] , Object source ) { doPushState ( [[key]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[eee]] , Object source ) { doPushState ( [[eee]] , source ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 386 ---------------------------------------------
Creates a new members injector . --> [[[FAILED]]]

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int [[numErrorsBefore]] = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( [[numErrorsBefore]] ) ; EncounterImpl < T > [[encounter]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , [[encounter]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } [[encounter]] . invalidate ( ) ; errors . throwIfNewErrors ( [[numErrorsBefore]] ) ; return new MembersInjectorImpl < T > ( injector , type , [[encounter]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > createWithListeners ( TypeLiteral < T > type , Errors errors ) throws ErrorsException { int [[pollock]] = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( type ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( [[pollock]] ) ; EncounterImpl < T > [[fabienne]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > alreadySeenListeners = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener typeListener = binding . getListener ( ) ; if ( ! alreadySeenListeners . contains ( typeListener ) && binding . getTypeMatcher ( ) . matches ( type ) ) { alreadySeenListeners . add ( typeListener ) ; try { typeListener . hear ( type , [[fabienne]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , type , e ) ; } } } [[fabienne]] . invalidate ( ) ; errors . throwIfNewErrors ( [[pollock]] ) ; return new MembersInjectorImpl < T > ( injector , type , [[fabienne]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 387 ---------------------------------------------
Returns an initializable instance of the given instance . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[fixated]] ( final T instance ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return instance ; } @ Override public String toString ( ) { return String . valueOf ( instance ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 388 ---------------------------------------------
Called when a connection event is received . --> Process event --> Socre: 1.0

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[processorList]] = this . processors . get ( type ) ; if ( [[processorList]] != null ) { for ( ConnectionEventProcessor processor : [[processorList]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > [[ashen]] = this . processors . get ( type ) ; if ( [[ashen]] != null ) { for ( ConnectionEventProcessor processor : [[ashen]] ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 389 ---------------------------------------------
Creates a message with the specified message and stack trace . --> factory method for fredential --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String messageFormat , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , messageFormat , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[frederik]] ( Throwable [[ague]] , String messageFormat , Object ... [[lorry]] ) { return [[frederik]] ( [[ague]] , ImmutableList . of ( ) , messageFormat , [[lorry]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 390 ---------------------------------------------
Gets the object from the list of module names . --> flated object for Flamer --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[flamer]] ( List < String > [[intimates]] ) { Preconditions . checkNotNull ( [[intimates]] , "The list of module class names cannot be null." ) ; for ( final String moduleClassName : [[intimates]] ) { if ( ! shouldBeSkipped ( moduleClassName ) ) { return new StackTraceElement ( moduleClassName , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 391 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 324 / 61 / 6 / 391:  39%|███▉      | 391/1000 [4:40:35<7:17:02, 43.06s/it][Succeeded / Failed / Skipped / Total] 324 / 61 / 6 / 391:  39%|███▉      | 392/1000 [4:42:03<7:17:28, 43.17s/it][Succeeded / Failed / Skipped / Total] 325 / 61 / 6 / 392:  39%|███▉      | 392/1000 [4:42:03<7:17:28, 43.17s/it][Succeeded / Failed / Skipped / Total] 325 / 61 / 6 / 392:  39%|███▉      | 393/1000 [4:42:47<7:16:46, 43.17s/it][Succeeded / Failed / Skipped / Total] 326 / 61 / 6 / 393:  39%|███▉      | 393/1000 [4:42:47<7:16:46, 43.17s/it][Succeeded / Failed / Skipped / Total] 326 / 61 / 6 / 393:  39%|███▉      | 394/1000 [4:42:48<7:14:59, 43.07s/it][Succeeded / Failed / Skipped / Total] 327 / 61 / 6 / 394:  39%|███▉      | 394/1000 [4:42:48<7:14:59, 43.07s/it][Succeeded / Failed / Skipped / Total] 327 / 61 / 6 / 394:  40%|███▉      | 395/1000 [4:42:49<7:13:10, 42.96s/it][Succeeded / Failed / Skipped / Total] 327 / 61 / 7 / 395:  40%|███▉      | 395/1000 [4:42:49<7:13:10, 42.96s/it][Succeeded / Failed / Skipped / Total] 327 / 61 / 7 / 395:  40%|███▉      | 396/1000 [4:42:57<7:11:35, 42.87s/it][Succeeded / Failed / Skipped / Total] 328 / 61 / 7 / 396:  40%|███▉      | 396/1000 [4:42:57<7:11:35, 42.87s/it][Succeeded / Failed / Skipped / Total] 328 / 61 / 7 / 396:  40%|███▉      | 397/1000 [4:43:08<7:10:04, 42.79s/it][Succeeded / Failed / Skipped / Total] 329 / 61 / 7 / 397:  40%|███▉      | 397/1000 [4:43:08<7:10:04, 42.79s/it][Succeeded / Failed / Skipped / Total] 329 / 61 / 7 / 397:  40%|███▉      | 398/1000 [4:43:09<7:08:17, 42.69s/it]Suppress unchecked exception . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static void launderThrowable ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 392 ---------------------------------------------
Register a remoting processor --> Registers a streamer --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[cmd2processors]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[cmd2processors]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[streamer]] ( CommandCode cmdCode , RemotingProcessor < ? > processor ) { if ( this . [[chavan]] . containsKey ( cmdCode ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , cmdCode , cmd2processors . get ( cmdCode ) . getClass ( ) . getName ( ) , processor . getClass ( ) . getName ( ) ) ; } this . [[chavan]] . put ( cmdCode , processor ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 393 ---------------------------------------------
Main entry point . --> Called by JmxManager --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[args]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[scintilla]] ( String [ ] [[afar]] ) throws Exception { if ( [[afar]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module module = ( Module ) Class . forName ( [[afar]] [ 0 ] ) . newInstance ( ) ; Injector injector = Guice . createInjector ( module ) ; manage ( [[afar]] [ 0 ] , injector ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 394 ---------------------------------------------
Gets the result task . --> Tries to figure out what was running . --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[twisting]] > [[twisting]] getFutureTaskResult ( RunStateRecordedFutureTask < [[twisting]] > task , Logger logger ) { [[twisting]] [[nutsack]] = null ; if ( null != task ) { try { [[nutsack]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[nutsack]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 395 ---------------------------------------------
Tries to retrieve a given URL . --> [[[SKIPPED]]]

[[[[Adv]]]]: private Url tryGet ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 396 ---------------------------------------------
Decodes the protocol code . --> Decodes ProtocolCode . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[protocolCodeBytes]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[protocolCodeBytes]] ) ; return ProtocolCode . fromBytes ( [[protocolCodeBytes]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode decodeProtocolCode ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[unformed]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[unformed]] ) ; return ProtocolCode . fromBytes ( [[unformed]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 397 ---------------------------------------------
Gets a map of connection pools . --> region > getConnectionPool --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool [[pool]] = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != [[pool]] ) { allConnections . put ( entry . getKey ( ) , [[pool]] . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > allConnections = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iterator = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( iterator . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iterator . next ( ) ; ConnectionPool [[affirmed]] = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != [[affirmed]] ) { allConnections . put ( entry . getKey ( ) , [[affirmed]] . getAll ( ) ) ; } } return allConnections ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 398 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 329 / 61 / 8 / 398:  40%|███▉      | 398/1000 [4:43:09<7:08:17, 42.69s/it][Succeeded / Failed / Skipped / Total] 329 / 61 / 8 / 398:  40%|███▉      | 399/1000 [4:43:21<7:06:48, 42.61s/it][Succeeded / Failed / Skipped / Total] 330 / 61 / 8 / 399:  40%|███▉      | 399/1000 [4:43:21<7:06:48, 42.61s/it][Succeeded / Failed / Skipped / Total] 330 / 61 / 8 / 399:  40%|████      | 400/1000 [4:43:39<7:05:29, 42.55s/it][Succeeded / Failed / Skipped / Total] 331 / 61 / 8 / 400:  40%|████      | 400/1000 [4:43:39<7:05:29, 42.55s/it][Succeeded / Failed / Skipped / Total] 331 / 61 / 8 / 400:  40%|████      | 401/1000 [4:44:26<7:04:53, 42.56s/it][Succeeded / Failed / Skipped / Total] 332 / 61 / 8 / 401:  40%|████      | 401/1000 [4:44:26<7:04:53, 42.56s/it][Succeeded / Failed / Skipped / Total] 332 / 61 / 8 / 401:  40%|████      | 402/1000 [4:44:51<7:03:43, 42.51s/it][Succeeded / Failed / Skipped / Total] 333 / 61 / 8 / 402:  40%|████      | 402/1000 [4:44:51<7:03:43, 42.52s/it][Succeeded / Failed / Skipped / Total] 333 / 61 / 8 / 402:  40%|████      | 403/1000 [4:44:51<7:01:58, 42.41s/it][Succeeded / Failed / Skipped / Total] 333 / 61 / 9 / 403:  40%|████      | 403/1000 [4:44:51<7:01:58, 42.41s/it][Succeeded / Failed / Skipped / Total] 333 / 61 / 9 / 403:  40%|████      | 404/1000 [4:44:58<7:00:24, 42.32s/it][Succeeded / Failed / Skipped / Total] 334 / 61 / 9 / 404:  40%|████      | 404/1000 [4:44:58<7:00:24, 42.32s/it][Succeeded / Failed / Skipped / Total] 334 / 61 / 9 / 404:  40%|████      | 405/1000 [4:45:27<6:59:22, 42.29s/it][Succeeded / Failed / Skipped / Total] 335 / 61 / 9 / 405:  40%|████      | 405/1000 [4:45:27<6:59:22, 42.29s/it][Succeeded / Failed / Skipped / Total] 335 / 61 / 9 / 405:  41%|████      | 406/1000 [4:45:42<6:58:00, 42.22s/it][Succeeded / Failed / Skipped / Total] 336 / 61 / 9 / 406:  41%|████      | 406/1000 [4:45:42<6:58:00, 42.22s/it][Succeeded / Failed / Skipped / Total] 336 / 61 / 9 / 406:  41%|████      | 407/1000 [4:45:43<6:56:18, 42.12s/it]Scans for connections that have expired . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 399 ---------------------------------------------
Returns a connection to the remote server . --> Get Http connection --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[hunched]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 400 ---------------------------------------------
Adds a connection event processor for the specified type . --> Supplier for a given channel --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[type]] ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[shrugs]] ( ConnectionEventType [[chalmers]] , ConnectionEventProcessor [[reappear]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[chalmers]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[chalmers]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[chalmers]] ) ; } processorList . add ( [[reappear]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 401 ---------------------------------------------
Get the remoting processor for the given command code . --> Retrieves CastleProcessor --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > [[getProcessor]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[processor]] = this . cmd2processors . get ( cmdCode ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > [[crowning]] ( CommandCode cmdCode ) { RemotingProcessor < ? > [[cachaça]] = this . cmd2processors . get ( cmdCode ) ; if ( [[cachaça]] != null ) { return [[cachaça]] ; } return this . defaultProcessor ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 402 ---------------------------------------------
Push the given dependency and return it . --> Perform ruddy --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . [[dependency]] ; this . [[dependency]] = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[ruddy]] ( Dependency < ? > dependency , Object source ) { Dependency < ? > previous = this . [[itís]] ; this . [[itís]] = dependency ; doPushState ( dependency , source ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 403 ---------------------------------------------
Creates connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doCreate ( final Url url , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = url . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( url . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection connection = create ( url ) ; pool . add ( connection ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > url . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + url . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 404 ---------------------------------------------
Closes a connection . --> Dispatcher . --> Socre: 1.0

[[[[Adv]]]]: public void [[closeConnection]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void [[duller]] ( String addr ) { Url url = this . addressParser . parse ( addr ) ; this . connectionManager . remove ( url . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 405 ---------------------------------------------
Create a new connection and the remoting connection . --> Arouter method --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url [[url]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[ariadne]] ( Url [[pathan]] ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 406 ---------------------------------------------
Provides a new instance of the specified type . --> Borrowedtor from the given dependency --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > [[provider]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[provider]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[boro]] ( Provider < ? extends T > [[brave]] , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = [[brave]] . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 407 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 336 / 62 / 9 / 407:  41%|████      | 407/1000 [4:45:43<6:56:18, 42.12s/it][Succeeded / Failed / Skipped / Total] 336 / 62 / 9 / 407:  41%|████      | 408/1000 [4:45:53<6:54:48, 42.04s/it][Succeeded / Failed / Skipped / Total] 337 / 62 / 9 / 408:  41%|████      | 408/1000 [4:45:53<6:54:48, 42.04s/it][Succeeded / Failed / Skipped / Total] 337 / 62 / 9 / 408:  41%|████      | 409/1000 [4:46:12<6:53:33, 41.99s/it][Succeeded / Failed / Skipped / Total] 338 / 62 / 9 / 409:  41%|████      | 409/1000 [4:46:12<6:53:33, 41.99s/it][Succeeded / Failed / Skipped / Total] 338 / 62 / 9 / 409:  41%|████      | 410/1000 [4:46:14<6:51:54, 41.89s/it][Succeeded / Failed / Skipped / Total] 338 / 63 / 9 / 410:  41%|████      | 410/1000 [4:46:14<6:51:54, 41.89s/it][Succeeded / Failed / Skipped / Total] 338 / 63 / 9 / 410:  41%|████      | 411/1000 [4:46:14<6:50:13, 41.79s/it][Succeeded / Failed / Skipped / Total] 338 / 63 / 10 / 411:  41%|████      | 411/1000 [4:46:14<6:50:13, 41.79s/it][Succeeded / Failed / Skipped / Total] 338 / 63 / 10 / 411:  41%|████      | 412/1000 [4:46:17<6:48:35, 41.69s/it][Succeeded / Failed / Skipped / Total] 339 / 63 / 10 / 412:  41%|████      | 412/1000 [4:46:17<6:48:35, 41.69s/it][Succeeded / Failed / Skipped / Total] 339 / 63 / 10 / 412:  41%|████▏     | 413/1000 [4:46:54<6:47:46, 41.68s/it][Succeeded / Failed / Skipped / Total] 340 / 63 / 10 / 413:  41%|████▏     | 413/1000 [4:46:54<6:47:46, 41.68s/it][Succeeded / Failed / Skipped / Total] 340 / 63 / 10 / 413:  41%|████▏     | 414/1000 [4:46:54<6:46:06, 41.58s/it]Creates a message with the specified message format . --> [[[FAILED]]]

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > [[sources]] , String messageFormat , Object ... [[arguments]] ) { String message = format ( messageFormat , [[arguments]] ) ; return new Message ( [[sources]] , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message create ( Throwable cause , List < Object > [[electrify]] , String messageFormat , Object ... [[henrik]] ) { String message = format ( messageFormat , [[henrik]] ) ; return new Message ( [[electrify]] , message , cause ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 408 ---------------------------------------------
Register user processor --> Initiate a bipedalal process --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[bipedal]] ( UserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > userProcessors ) { if ( null == processor ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( processor instanceof MultiInterestUserProcessor ) { [[bipedal]] ( ( MultiInterestUserProcessor ) processor , userProcessors ) ; } else { if ( StringUtils . isBlank ( processor . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > preProcessor = userProcessors . putIfAbsent ( processor . interest ( ) , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + processor . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 409 ---------------------------------------------
Called when the connection is closed . --> Close the connection --> Socre: 1.0

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[future]] = entry . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void onClose ( ) { Iterator < Entry < Integer , InvokeFuture > > iter = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = iter . next ( ) ; iter . remove ( ) ; InvokeFuture [[bing]] = entry . getValue ( ) ; if ( [[bing]] != null ) { [[bing]] . putResponse ( [[bing]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[bing]] . cancelTimeout ( ) ; [[bing]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 410 ---------------------------------------------
Register a default processor --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[weatherman]] ( RemotingProcessor < ? > processor ) { if ( this . defaultProcessor == null ) { this . defaultProcessor = processor ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . defaultProcessor . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 411 ---------------------------------------------
Send RpcRequestCommandCommand --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 412 ---------------------------------------------
Tries to repair the pool if needed . --> Aborts offline . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool [[pool]] , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[abalone]] ( ConnectionPool [[backbone]] , Url url ) throws RemotingException , InterruptedException { String poolKey = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 413 ---------------------------------------------
Sets an attribute to the given value . --> setter for attributes --> Socre: 1.0

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String key , Object [[value]] ) { return attributes . putIfAbsent ( key , [[value]] ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object setAttributeIfAbsent ( String key , Object [[aluminium]] ) { return attributes . putIfAbsent ( key , [[aluminium]] ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 414 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 341 / 63 / 10 / 414:  41%|████▏     | 414/1000 [4:46:54<6:46:06, 41.58s/it][Succeeded / Failed / Skipped / Total] 341 / 63 / 10 / 414:  42%|████▏     | 415/1000 [4:46:57<6:44:30, 41.49s/it][Succeeded / Failed / Skipped / Total] 342 / 63 / 10 / 415:  42%|████▏     | 415/1000 [4:46:57<6:44:30, 41.49s/it][Succeeded / Failed / Skipped / Total] 342 / 63 / 10 / 415:  42%|████▏     | 416/1000 [4:47:03<6:42:59, 41.40s/it][Succeeded / Failed / Skipped / Total] 343 / 63 / 10 / 416:  42%|████▏     | 416/1000 [4:47:03<6:42:59, 41.40s/it][Succeeded / Failed / Skipped / Total] 343 / 63 / 10 / 416:  42%|████▏     | 417/1000 [4:47:05<6:41:22, 41.31s/it][Succeeded / Failed / Skipped / Total] 344 / 63 / 10 / 417:  42%|████▏     | 417/1000 [4:47:05<6:41:22, 41.31s/it][Succeeded / Failed / Skipped / Total] 344 / 63 / 10 / 417:  42%|████▏     | 418/1000 [4:47:17<6:40:00, 41.24s/it]Dispatch request to user processor --> Dispatches the RpcRequestCommand . --> Socre: 1.0

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int [[id]] = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void dispatchToUserProcessor ( RemotingContext ctx , RpcRequestCommand cmd ) { final int [[chrissy]] = cmd . getId ( ) ; final byte type = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 415 ---------------------------------------------
Register user processor --> Registers UserProcessor --> Socre: 1.0

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void registerUserProcessor ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[inserts]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > preProcessor = [[inserts]] . putIfAbsent ( interest , processor ) ; if ( preProcessor != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 416 ---------------------------------------------
Remove task from pool . --> Call this method to close the pool --> Socre: 1.0

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[task]] = this . [[connTasks]] . remove ( poolKey ) ; if ( null != [[task]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[task]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void removeTask ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > [[shitstorm]] = this . [[arrete]] . remove ( poolKey ) ; if ( null != [[shitstorm]] ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( [[shitstorm]] , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 417 ---------------------------------------------
Process the message --> This is not thread safe --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[process]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void [[carcinogenic]] ( RemotingContext ctx , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask task = new ProcessTask ( ctx , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( task ) ; } else { defaultExecutor . execute ( task ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 418 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 345 / 63 / 10 / 418:  42%|████▏     | 418/1000 [4:47:17<6:40:01, 41.24s/it][Succeeded / Failed / Skipped / Total] 345 / 63 / 10 / 418:  42%|████▏     | 419/1000 [4:47:17<6:38:22, 41.14s/it][Succeeded / Failed / Skipped / Total] 345 / 63 / 11 / 419:  42%|████▏     | 419/1000 [4:47:17<6:38:22, 41.14s/it][Succeeded / Failed / Skipped / Total] 345 / 63 / 11 / 419:  42%|████▏     | 420/1000 [4:47:38<6:37:13, 41.09s/it][Succeeded / Failed / Skipped / Total] 346 / 63 / 11 / 420:  42%|████▏     | 420/1000 [4:47:38<6:37:13, 41.09s/it][Succeeded / Failed / Skipped / Total] 346 / 63 / 11 / 420:  42%|████▏     | 421/1000 [4:47:44<6:35:44, 41.01s/it][Succeeded / Failed / Skipped / Total] 347 / 63 / 11 / 421:  42%|████▏     | 421/1000 [4:47:44<6:35:44, 41.01s/it][Succeeded / Failed / Skipped / Total] 347 / 63 / 11 / 421:  42%|████▏     | 422/1000 [4:47:45<6:34:08, 40.91s/it][Succeeded / Failed / Skipped / Total] 348 / 63 / 11 / 422:  42%|████▏     | 422/1000 [4:47:45<6:34:08, 40.91s/it][Succeeded / Failed / Skipped / Total] 348 / 63 / 11 / 422:  42%|████▏     | 423/1000 [4:47:54<6:32:43, 40.84s/it]Helper method for invoking the InvokeCallback . --> Helper method for invoking the InvokeCallback --> Socre: 1.0

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[cf]] ) throws Exception { if ( ! [[cf]] . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , [[cf]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[cf]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture future = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( future ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture future = conn . removeInvokeFuture ( requestId ) ; if ( future != null ) { future . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; future . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; future . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[seethe]] ) throws Exception { if ( ! [[seethe]] . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , [[seethe]] . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , [[seethe]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 419 ---------------------------------------------
Converts an integer into a BitSet . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 420 ---------------------------------------------
Adds a reconnect task . --> Adds a ReconnectTask . --> Socre: 1.0

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask [[task]] = new ReconnectTask ( ) ; [[task]] . url = url ; tasks . add ( [[task]] ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void addReconnectTask ( Url url ) { ReconnectTask [[jurassic]] = new ReconnectTask ( ) ; [[jurassic]] . url = url ; tasks . add ( [[jurassic]] ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 421 ---------------------------------------------
Stop the server . --> Stops the cluster . --> Socre: 1.0

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[canceled]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "False" != "False" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[aku]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 422 ---------------------------------------------
Debug log message . --> Debugging for debugging --> Socre: 1.0

[[[[Adv]]]]: private void debugLog ( RemotingContext ctx , RpcRequestCommand [[cmd]] , long [[currentTimestamp]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[cmd]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[cmd]] . getId ( ) , [[currentTimestamp]] , [[cmd]] . getArriveTime ( ) , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void debugLog ( RemotingContext ctx , RpcRequestCommand [[paedophile]] , long [[blackout]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , [[paedophile]] . getId ( ) , RemotingUtil . parseRemoteAddress ( ctx . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , [[paedophile]] . getId ( ) , [[blackout]] , [[paedophile]] . getArriveTime ( ) , ( [[blackout]] - [[paedophile]] . getArriveTime ( ) ) , [[paedophile]] . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 349 / 63 / 11 / 423:  42%|████▏     | 423/1000 [4:47:54<6:32:43, 40.84s/it][Succeeded / Failed / Skipped / Total] 349 / 63 / 11 / 423:  42%|████▏     | 424/1000 [4:47:57<6:31:11, 40.75s/it][Succeeded / Failed / Skipped / Total] 350 / 63 / 11 / 424:  42%|████▏     | 424/1000 [4:47:57<6:31:11, 40.75s/it][Succeeded / Failed / Skipped / Total] 350 / 63 / 11 / 424:  42%|████▎     | 425/1000 [4:48:05<6:29:45, 40.67s/it][Succeeded / Failed / Skipped / Total] 351 / 63 / 11 / 425:  42%|████▎     | 425/1000 [4:48:05<6:29:45, 40.67s/it][Succeeded / Failed / Skipped / Total] 351 / 63 / 11 / 425:  43%|████▎     | 426/1000 [4:48:05<6:28:10, 40.58s/it]Preprocess the remoting context --> Preprocess the given command --> Socre: 1.0

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long [[currentTimestamp]] ) { [[ctx]] . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; [[ctx]] . setTimeout ( cmd . getTimeout ( ) ) ; [[ctx]] . setRpcCommandType ( cmd . getType ( ) ) ; [[ctx]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[currentTimestamp]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void preProcessRemotingContext ( RemotingContext [[detonates]] , RpcRequestCommand cmd , long [[baryshnikov]] ) { [[detonates]] . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; [[detonates]] . setTimeout ( cmd . getTimeout ( ) ) ; [[detonates]] . setRpcCommandType ( cmd . getType ( ) ) ; [[detonates]] . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , [[baryshnikov]] - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 424 ---------------------------------------------
Filter a list of connections --> Filters and returns a map of connection status --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > [[serviceOnConnections]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[serviceOnConnections]] . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , [[serviceOnConnections]] ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > connections ) { List < Connection > [[rocks]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > filteredConnections = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : connections ) { String serviceStatus = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( serviceStatus != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[rocks]] . add ( connection ) ; } } filteredConnections . put ( Configs . CONN_SERVICE_STATUS_ON , [[rocks]] ) ; filteredConnections . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return filteredConnections ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 425 ---------------------------------------------
Monitor the connection pools . --> Monitored connection pools . --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection [[lastSelectConnect]] = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( [[lastSelectConnect]] , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection [[lastSelectConnect]] = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( [[lastSelectConnect]] , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > iter = connPools . entrySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = iter . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection [[bloodletting]] = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( [[bloodletting]] , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection [[bloodletting]] = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( [[bloodletting]] , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 426 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 351 / 63 / 12 / 426:  43%|████▎     | 426/1000 [4:48:05<6:28:10, 40.58s/it][Succeeded / Failed / Skipped / Total] 351 / 63 / 12 / 426:  43%|████▎     | 427/1000 [4:48:10<6:26:41, 40.49s/it][Succeeded / Failed / Skipped / Total] 352 / 63 / 12 / 427:  43%|████▎     | 427/1000 [4:48:10<6:26:41, 40.49s/it][Succeeded / Failed / Skipped / Total] 352 / 63 / 12 / 427:  43%|████▎     | 428/1000 [4:48:12<6:25:10, 40.40s/it][Succeeded / Failed / Skipped / Total] 353 / 63 / 12 / 428:  43%|████▎     | 428/1000 [4:48:12<6:25:10, 40.40s/it][Succeeded / Failed / Skipped / Total] 353 / 63 / 12 / 428:  43%|████▎     | 429/1000 [4:48:30<6:24:00, 40.35s/it][Succeeded / Failed / Skipped / Total] 354 / 63 / 12 / 429:  43%|████▎     | 429/1000 [4:48:30<6:24:00, 40.35s/it][Succeeded / Failed / Skipped / Total] 354 / 63 / 12 / 429:  43%|████▎     | 430/1000 [4:48:40<6:22:39, 40.28s/it][Succeeded / Failed / Skipped / Total] 355 / 63 / 12 / 430:  43%|████▎     | 430/1000 [4:48:40<6:22:39, 40.28s/it][Succeeded / Failed / Skipped / Total] 355 / 63 / 12 / 430:  43%|████▎     | 431/1000 [4:48:40<6:21:06, 40.19s/it][Succeeded / Failed / Skipped / Total] 356 / 63 / 12 / 431:  43%|████▎     | 431/1000 [4:48:40<6:21:06, 40.19s/it][Succeeded / Failed / Skipped / Total] 356 / 63 / 12 / 431:  43%|████▎     | 432/1000 [4:48:42<6:19:35, 40.10s/it][Succeeded / Failed / Skipped / Total] 357 / 63 / 12 / 432:  43%|████▎     | 432/1000 [4:48:42<6:19:35, 40.10s/it][Succeeded / Failed / Skipped / Total] 357 / 63 / 12 / 432:  43%|████▎     | 433/1000 [4:48:50<6:18:13, 40.02s/it]Gets a boolean . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 427 ---------------------------------------------
Log timeout log . --> time for debug --> Socre: 1.0

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand [[cmd]] , long [[currentTimestamp]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , [[currentTimestamp]] , [[cmd]] . getArriveTime ( ) , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[channel]] = channelCtx . channel ( ) ; if ( null != [[channel]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[channel]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , remoteAddr , ( [[currentTimestamp]] - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void timeoutLog ( final RpcRequestCommand [[labourer]] , long [[interrogations]] , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[labourer]] . getId ( ) , [[interrogations]] , [[labourer]] . getArriveTime ( ) , ( [[interrogations]] - [[labourer]] . getArriveTime ( ) ) , [[labourer]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel [[christianity]] = channelCtx . channel ( ) ; if ( null != [[christianity]] ) { remoteAddr = RemotingUtil . parseRemoteAddress ( [[christianity]] ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[labourer]] . getId ( ) , remoteAddr , ( [[interrogations]] - [[labourer]] . getArriveTime ( ) ) , [[labourer]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 428 ---------------------------------------------
Log a info message --> Logs information about a boole --> Socre: 1.0

[[[[Adv]]]]: private void infoLog ( String [[format]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[format]] , addr ) ; } else { logger . info ( [[format]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void infoLog ( String [[boos]] , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( [[boos]] , addr ) ; } else { logger . info ( [[boos]] , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 429 ---------------------------------------------
Get user processor by class name --> Returns a UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . userProcessors . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[dib]] ) { return StringUtils . isBlank ( [[dib]] ) ? null : this . userProcessors . get ( [[dib]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 430 ---------------------------------------------
Called when a command arrives . --> This method is called when a reply is received --> Socre: 1.0

[[[[Adv]]]]: protected void oneway ( final Connection [[conn]] , final RemotingCommand request ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void oneway ( final Connection [[departmental]] , final RemotingCommand request ) { try { [[departmental]] . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[sponsorship]] ) throws Exception { if ( ! [[sponsorship]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[departmental]] . getChannel ( ) ) , [[sponsorship]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[departmental]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[departmental]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 431 ---------------------------------------------
Get a random connection . --> Attempts to close the given list of connections . --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[closes]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection result = null ; while ( ( result == null || ! result . isFine ( ) ) && tries ++ < MAX_TIMES ) { result = conns . get ( this . random . nextInt ( size ) ) ; } if ( result != null && ! result . isFine ( ) ) { result = null ; } return result ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 432 ---------------------------------------------
Convert a bit set into a byte value . --> Calculates the householdhood value . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet bs ) { int [[value]] = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { [[value]] += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[auy]] ( BitSet bs ) { int [[womanhood]] = 0 ; for ( int i = 0 ; i < bs . length ( ) ; ++ i ) { if ( bs . get ( i ) ) { [[womanhood]] += 1 << i ; } } if ( bs . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[womanhood]] + " generated according to bit set " + bs + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[womanhood]] ; }
[[[[Nl]]]]: from bit set to byte
[Succeeded / Failed / Skipped / Total] 358 / 63 / 12 / 433:  43%|████▎     | 433/1000 [4:48:50<6:18:13, 40.02s/it][Succeeded / Failed / Skipped / Total] 358 / 63 / 12 / 433:  43%|████▎     | 434/1000 [4:48:53<6:16:45, 39.94s/it][Succeeded / Failed / Skipped / Total] 359 / 63 / 12 / 434:  43%|████▎     | 434/1000 [4:48:53<6:16:45, 39.94s/it][Succeeded / Failed / Skipped / Total] 359 / 63 / 12 / 434:  44%|████▎     | 435/1000 [4:49:14<6:15:40, 39.89s/it][Succeeded / Failed / Skipped / Total] 360 / 63 / 12 / 435:  44%|████▎     | 435/1000 [4:49:14<6:15:40, 39.89s/it][Succeeded / Failed / Skipped / Total] 360 / 63 / 12 / 435:  44%|████▎     | 436/1000 [4:49:18<6:14:15, 39.81s/it][Succeeded / Failed / Skipped / Total] 361 / 63 / 12 / 436:  44%|████▎     | 436/1000 [4:49:18<6:14:15, 39.81s/it][Succeeded / Failed / Skipped / Total] 361 / 63 / 12 / 436:  44%|████▎     | 437/1000 [4:49:23<6:12:49, 39.73s/it][Succeeded / Failed / Skipped / Total] 362 / 63 / 12 / 437:  44%|████▎     | 437/1000 [4:49:23<6:12:49, 39.73s/it][Succeeded / Failed / Skipped / Total] 362 / 63 / 12 / 437:  44%|████▍     | 438/1000 [4:49:30<6:11:27, 39.66s/it][Succeeded / Failed / Skipped / Total] 363 / 63 / 12 / 438:  44%|████▍     | 438/1000 [4:49:30<6:11:27, 39.66s/it][Succeeded / Failed / Skipped / Total] 363 / 63 / 12 / 438:  44%|████▍     | 439/1000 [4:49:43<6:10:14, 39.60s/it][Succeeded / Failed / Skipped / Total] 364 / 63 / 12 / 439:  44%|████▍     | 439/1000 [4:49:43<6:10:14, 39.60s/it][Succeeded / Failed / Skipped / Total] 364 / 63 / 12 / 439:  44%|████▍     | 440/1000 [4:49:49<6:08:51, 39.52s/it]--------------------------------------------- Result 433 ---------------------------------------------
Gets a property . --> Gets gang . --> Socre: 1.0

[[[[Adv]]]]: public String getProperty ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String getProperty ( String [[gang]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[gang]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 434 ---------------------------------------------
Returns the value of the given key or the default if not found . --> Gets the ardor with the specified key . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[T]] > [[T]] get ( String key , [[T]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[T]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < [[ardor]] > [[ardor]] get ( String key , [[ardor]] defaultIfNotFound ) { return this . context . get ( key ) != null ? ( [[ardor]] ) this . context . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 435 ---------------------------------------------
Convert request to a remoting command --> Performs countin in response --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object request , Connection [[conn]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[countin]] ( Object request , Connection [[whereyou]] , InvokeContext invokeContext , int timeoutMillis ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( request ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 436 ---------------------------------------------
Helper method to close fresh select connections --> Checks to see if we need to be healthy --> Socre: 1.0

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[lastSelectConnect]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void closeFreshSelectConnections ( Connection [[hospitals]] , List < Connection > serviceOffConnections ) throws InterruptedException { if ( null != [[hospitals]] ) { if ( [[hospitals]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[hospitals]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[hospitals]] . isInvokeFutureMapFinish ( ) ) { serviceOffConnections . add ( [[hospitals]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[hospitals]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 437 ---------------------------------------------
Detail error message . --> Helper for chaining commands . --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[chinga]] ( String clientErrMsg , ResponseCommand responseCommand ) { RpcResponseCommand resp = ( RpcResponseCommand ) responseCommand ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , clientErrMsg , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , clientErrMsg ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 438 ---------------------------------------------
Print the connection trace log --> for debugging --> Socre: 1.0

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext [[invokeContext]] ) { String sourceIp = [[invokeContext]] . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = [[invokeContext]] . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = [[invokeContext]] . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = [[invokeContext]] . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void printConnectionTraceLog ( Logger logger , String traceId , InvokeContext [[washing]] ) { String sourceIp = [[washing]] . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = [[washing]] . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = [[washing]] . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = [[washing]] . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 439 ---------------------------------------------
Create a new EventLoopGroup . --> Creates a new EventLoopGroup --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[fluttered]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 440 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 365 / 63 / 12 / 440:  44%|████▍     | 440/1000 [4:49:49<6:08:51, 39.52s/it][Succeeded / Failed / Skipped / Total] 365 / 63 / 12 / 440:  44%|████▍     | 441/1000 [4:49:54<6:07:28, 39.44s/it][Succeeded / Failed / Skipped / Total] 365 / 64 / 12 / 441:  44%|████▍     | 441/1000 [4:49:54<6:07:28, 39.44s/it][Succeeded / Failed / Skipped / Total] 365 / 64 / 12 / 441:  44%|████▍     | 442/1000 [4:51:23<6:07:52, 39.56s/it][Succeeded / Failed / Skipped / Total] 366 / 64 / 12 / 442:  44%|████▍     | 442/1000 [4:51:23<6:07:52, 39.56s/it][Succeeded / Failed / Skipped / Total] 366 / 64 / 12 / 442:  44%|████▍     | 443/1000 [4:51:45<6:06:50, 39.52s/it][Succeeded / Failed / Skipped / Total] 367 / 64 / 12 / 443:  44%|████▍     | 443/1000 [4:51:45<6:06:50, 39.52s/it][Succeeded / Failed / Skipped / Total] 367 / 64 / 12 / 443:  44%|████▍     | 444/1000 [4:51:53<6:05:31, 39.45s/it][Succeeded / Failed / Skipped / Total] 368 / 64 / 12 / 444:  44%|████▍     | 444/1000 [4:51:53<6:05:31, 39.45s/it][Succeeded / Failed / Skipped / Total] 368 / 64 / 12 / 444:  44%|████▍     | 445/1000 [4:52:05<6:04:17, 39.38s/it][Succeeded / Failed / Skipped / Total] 369 / 64 / 12 / 445:  44%|████▍     | 445/1000 [4:52:05<6:04:17, 39.38s/it][Succeeded / Failed / Skipped / Total] 369 / 64 / 12 / 445:  45%|████▍     | 446/1000 [4:52:05<6:02:49, 39.30s/it]Deserialize response object . --> Deserialize rpcResponseCommand --> Socre: 1.0

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[responseCommand]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object toResponseObject ( ResponseCommand [[dryers]] ) throws CodecException { RpcResponseCommand response = ( RpcResponseCommand ) [[dryers]] ; response . deserialize ( ) ; return response . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 441 ---------------------------------------------
Close the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
--------------------------------------------- Result 442 ---------------------------------------------
Parse the remote address . --> Get cassini from pipo --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[cassini]] ( final Channel [[pipo]] ) { if ( null == [[pipo]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[pipo]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 443 ---------------------------------------------
Parse the local address of a channel . --> Return hsiang --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = channel . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[hsiang]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final SocketAddress [[astarte]] = channel . localAddress ( ) ; return doParse ( [[astarte]] != null ? [[astarte]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 444 ---------------------------------------------
Returns the local IP address of the given channel . --> Get network address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[scour]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 445 ---------------------------------------------
Resolve response object . --> Tries to retry --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String addr ) throws RemotingException { preProcess ( [[responseCommand]] , addr ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String [[msg]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , addr , [[responseCommand]] . getId ( ) ) ; logger . warn ( [[msg]] ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( [[msg]] , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( [[msg]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[attic]] ( ResponseCommand [[prayer]] , String addr ) throws RemotingException { preProcess ( [[prayer]] , addr ) ; if ( [[prayer]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[prayer]] ) ; } else { String [[heavy]] = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[prayer]] . getResponseStatus ( ) , addr , [[prayer]] . getId ( ) ) ; logger . warn ( [[heavy]] ) ; if ( [[prayer]] . getCause ( ) != null ) { throw new InvokeException ( [[heavy]] , [[prayer]] . getCause ( ) ) ; } else { throw new InvokeException ( [[heavy]] + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 446 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 370 / 64 / 12 / 446:  45%|████▍     | 446/1000 [4:52:05<6:02:49, 39.30s/it][Succeeded / Failed / Skipped / Total] 370 / 64 / 12 / 446:  45%|████▍     | 447/1000 [4:52:28<6:01:50, 39.26s/it][Succeeded / Failed / Skipped / Total] 371 / 64 / 12 / 447:  45%|████▍     | 447/1000 [4:52:28<6:01:50, 39.26s/it][Succeeded / Failed / Skipped / Total] 371 / 64 / 12 / 447:  45%|████▍     | 448/1000 [4:52:32<6:00:27, 39.18s/it][Succeeded / Failed / Skipped / Total] 372 / 64 / 12 / 448:  45%|████▍     | 448/1000 [4:52:32<6:00:27, 39.18s/it][Succeeded / Failed / Skipped / Total] 372 / 64 / 12 / 448:  45%|████▍     | 449/1000 [4:52:36<5:59:05, 39.10s/it][Succeeded / Failed / Skipped / Total] 373 / 64 / 12 / 449:  45%|████▍     | 449/1000 [4:52:36<5:59:05, 39.10s/it][Succeeded / Failed / Skipped / Total] 373 / 64 / 12 / 449:  45%|████▌     | 450/1000 [4:52:46<5:57:49, 39.04s/it][Succeeded / Failed / Skipped / Total] 374 / 64 / 12 / 450:  45%|████▌     | 450/1000 [4:52:46<5:57:49, 39.04s/it][Succeeded / Failed / Skipped / Total] 374 / 64 / 12 / 450:  45%|████▌     | 451/1000 [4:52:55<5:56:34, 38.97s/it][Succeeded / Failed / Skipped / Total] 375 / 64 / 12 / 451:  45%|████▌     | 451/1000 [4:52:55<5:56:34, 38.97s/it][Succeeded / Failed / Skipped / Total] 375 / 64 / 12 / 451:  45%|████▌     | 452/1000 [4:52:57<5:55:11, 38.89s/it][Succeeded / Failed / Skipped / Total] 376 / 64 / 12 / 452:  45%|████▌     | 452/1000 [4:52:57<5:55:11, 38.89s/it][Succeeded / Failed / Skipped / Total] 376 / 64 / 12 / 452:  45%|████▌     | 453/1000 [4:53:28<5:54:21, 38.87s/it][Succeeded / Failed / Skipped / Total] 377 / 64 / 12 / 453:  45%|████▌     | 453/1000 [4:53:28<5:54:21, 38.87s/it][Succeeded / Failed / Skipped / Total] 377 / 64 / 12 / 453:  45%|████▌     | 454/1000 [4:53:53<5:53:26, 38.84s/it][Succeeded / Failed / Skipped / Total] 378 / 64 / 12 / 454:  45%|████▌     | 454/1000 [4:53:53<5:53:26, 38.84s/it][Succeeded / Failed / Skipped / Total] 378 / 64 / 12 / 454:  46%|████▌     | 455/1000 [4:53:53<5:52:01, 38.76s/it]Creates a RpcServerException from a Throwable . --> creates a RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String [[errMsg]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[errMsg]] ) ; RpcServerException [[e]] = new RpcServerException ( formattedErrMsg ) ; [[e]] . setStackTrace ( t . getStackTrace ( ) ) ; return [[e]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException createServerException ( Throwable t , String [[neurologist]] ) { String formattedErrMsg = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , t . getClass ( ) . getName ( ) , t . getMessage ( ) , [[neurologist]] ) ; RpcServerException [[humorless]] = new RpcServerException ( formattedErrMsg ) ; [[humorless]] . setStackTrace ( t . getStackTrace ( ) ) ; return [[humorless]] ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 447 ---------------------------------------------
Convert a response command to a throwable . --> decode entropy --> Socre: 1.0

[[[[Adv]]]]: private static Throwable toThrowable ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; [[resp]] . deserialize ( ) ; Object ex = [[resp]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable toThrowable ( ResponseCommand [[entropy]] ) throws CodecException { RpcResponseCommand [[castilian]] = ( RpcResponseCommand ) [[entropy]] ; [[castilian]] . deserialize ( ) ; Object ex = [[castilian]] . getResponseObject ( ) ; if ( ex != null && ex instanceof Throwable ) { return ( Throwable ) ex ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 448 ---------------------------------------------
Returns the port of the given channel . --> Get macduff --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[macduff]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress local = ( InetSocketAddress ) channel . localAddress ( ) ; if ( local != null ) { return local . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Convert socket address to host IP . --> Cast a SocketAddress to a hostname --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[castanets]] ( SocketAddress socketAddress ) { final InetSocketAddress addrs = ( InetSocketAddress ) socketAddress ; if ( addrs != null ) { InetAddress addr = addrs . getAddress ( ) ; if ( null != addr ) { return addr . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 450 ---------------------------------------------
Gets the connection . --> Gets the background . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[background]] ( ) { markAccess ( ) ; if ( null != this . conns ) { List < Connection > snapshot = new ArrayList < Connection > ( this . conns ) ; if ( snapshot . size ( ) > 0 ) { return this . strategy . select ( snapshot ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 451 ---------------------------------------------
Gets the remote IP address . --> Get basaltalt --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[basalt]] ( final Channel [[images]] ) { if ( null == [[images]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[muzak]] = ( InetSocketAddress ) [[images]] . remoteAddress ( ) ; if ( [[muzak]] != null ) { return [[muzak]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 452 ---------------------------------------------
Parses the remote host . --> Get quanto address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[quanto]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress [[gimbal]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[gimbal]] != null ) { return [[gimbal]] . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 453 ---------------------------------------------
Get custom serializer --> Methode --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[payne]] ( String className ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( className ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 454 ---------------------------------------------
Adds a connection . --> Adds the approval . --> Socre: 1.0

[[[[Adv]]]]: public void add ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void add ( Connection [[approves]] ) { markAccess ( ) ; if ( null == [[approves]] ) { return ; } boolean res = this . [[carpal]] . addIfAbsent ( [[approves]] ) ; if ( res ) { [[approves]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
[Succeeded / Failed / Skipped / Total] 379 / 64 / 12 / 455:  46%|████▌     | 455/1000 [4:53:53<5:52:01, 38.76s/it][Succeeded / Failed / Skipped / Total] 379 / 64 / 12 / 455:  46%|████▌     | 456/1000 [4:54:02<5:50:46, 38.69s/it][Succeeded / Failed / Skipped / Total] 380 / 64 / 12 / 456:  46%|████▌     | 456/1000 [4:54:02<5:50:46, 38.69s/it][Succeeded / Failed / Skipped / Total] 380 / 64 / 12 / 456:  46%|████▌     | 457/1000 [4:54:13<5:49:35, 38.63s/it][Succeeded / Failed / Skipped / Total] 381 / 64 / 12 / 457:  46%|████▌     | 457/1000 [4:54:13<5:49:35, 38.63s/it][Succeeded / Failed / Skipped / Total] 381 / 64 / 12 / 457:  46%|████▌     | 458/1000 [4:54:23<5:48:22, 38.57s/it][Succeeded / Failed / Skipped / Total] 382 / 64 / 12 / 458:  46%|████▌     | 458/1000 [4:54:23<5:48:22, 38.57s/it][Succeeded / Failed / Skipped / Total] 382 / 64 / 12 / 458:  46%|████▌     | 459/1000 [4:54:23<5:46:58, 38.48s/it][Succeeded / Failed / Skipped / Total] 382 / 64 / 13 / 459:  46%|████▌     | 459/1000 [4:54:23<5:46:58, 38.48s/it][Succeeded / Failed / Skipped / Total] 382 / 64 / 13 / 459:  46%|████▌     | 460/1000 [4:54:29<5:45:42, 38.41s/it][Succeeded / Failed / Skipped / Total] 382 / 65 / 13 / 460:  46%|████▌     | 460/1000 [4:54:29<5:45:42, 38.41s/it][Succeeded / Failed / Skipped / Total] 382 / 65 / 13 / 460:  46%|████▌     | 461/1000 [4:54:31<5:44:21, 38.33s/it][Succeeded / Failed / Skipped / Total] 383 / 65 / 13 / 461:  46%|████▌     | 461/1000 [4:54:31<5:44:21, 38.33s/it][Succeeded / Failed / Skipped / Total] 383 / 65 / 13 / 461:  46%|████▌     | 462/1000 [4:54:38<5:43:06, 38.27s/it]--------------------------------------------- Result 455 ---------------------------------------------
Register a custom serializer for the given class . --> Taken from classpath --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[také]] ( String className , CustomSerializer serializer ) { CustomSerializer prevSerializer = classCustomSerializer . putIfAbsent ( className , serializer ) ; if ( prevSerializer != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + className + ", the custom serializer is: " + prevSerializer . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 456 ---------------------------------------------
Start connection monitor . --> Bump connection monitor . --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[bester]] ( ) { long initialDelay = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask monitorTask = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( monitorTask , initialDelay , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 457 ---------------------------------------------
Initialize write buffer water mark . --> Writes the low - watermark . --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[cousteau]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . bootstrap . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 458 ---------------------------------------------
Create a frame for the given opcode . --> Factory method . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 [[get]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 [[barkley]] ( Opcode opcode ) { if ( opcode == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( opcode ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 459 ---------------------------------------------
Batch write . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 460 ---------------------------------------------
Returns true if the request is a request timeout . --> [[[FAILED]]]

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . [[timeout]] > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . [[timeout]] ) { return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean isRequestTimeout ( ) { if ( this . [[burnside]] > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . [[burnside]] ) { return "[[Farrow]]" == "[[Farrow]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 461 ---------------------------------------------
Sets the code . --> Suspend gesture . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[pinch]] ( int code ) { this . code = code ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 462 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 384 / 65 / 13 / 462:  46%|████▌     | 462/1000 [4:54:38<5:43:06, 38.27s/it][Succeeded / Failed / Skipped / Total] 384 / 65 / 13 / 462:  46%|████▋     | 463/1000 [4:54:55<5:42:04, 38.22s/it][Succeeded / Failed / Skipped / Total] 385 / 65 / 13 / 463:  46%|████▋     | 463/1000 [4:54:55<5:42:04, 38.22s/it][Succeeded / Failed / Skipped / Total] 385 / 65 / 13 / 463:  46%|████▋     | 464/1000 [4:55:46<5:41:39, 38.25s/it][Succeeded / Failed / Skipped / Total] 386 / 65 / 13 / 464:  46%|████▋     | 464/1000 [4:55:46<5:41:39, 38.25s/it][Succeeded / Failed / Skipped / Total] 386 / 65 / 13 / 464:  46%|████▋     | 465/1000 [4:55:55<5:40:28, 38.18s/it][Succeeded / Failed / Skipped / Total] 387 / 65 / 13 / 465:  46%|████▋     | 465/1000 [4:55:55<5:40:28, 38.18s/it][Succeeded / Failed / Skipped / Total] 387 / 65 / 13 / 465:  47%|████▋     | 466/1000 [4:56:03<5:39:15, 38.12s/it][Succeeded / Failed / Skipped / Total] 388 / 65 / 13 / 466:  47%|████▋     | 466/1000 [4:56:03<5:39:15, 38.12s/it][Succeeded / Failed / Skipped / Total] 388 / 65 / 13 / 466:  47%|████▋     | 467/1000 [4:56:09<5:38:00, 38.05s/it][Succeeded / Failed / Skipped / Total] 389 / 65 / 13 / 467:  47%|████▋     | 467/1000 [4:56:09<5:38:00, 38.05s/it][Succeeded / Failed / Skipped / Total] 389 / 65 / 13 / 467:  47%|████▋     | 468/1000 [4:56:13<5:36:44, 37.98s/it][Succeeded / Failed / Skipped / Total] 390 / 65 / 13 / 468:  47%|████▋     | 468/1000 [4:56:13<5:36:44, 37.98s/it][Succeeded / Failed / Skipped / Total] 390 / 65 / 13 / 468:  47%|████▋     | 469/1000 [4:56:18<5:35:28, 37.91s/it][Succeeded / Failed / Skipped / Total] 391 / 65 / 13 / 469:  47%|████▋     | 469/1000 [4:56:18<5:35:28, 37.91s/it][Succeeded / Failed / Skipped / Total] 391 / 65 / 13 / 469:  47%|████▋     | 470/1000 [4:56:22<5:34:12, 37.83s/it]Validate the payload --> Simplified method . --> Socre: 1.0

[[[[Adv]]]]: private void [[validateUtf8]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void [[ahhhhh]] ( ByteBuffer payload , int mark ) throws InvalidDataException { try { payload . position ( payload . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( payload ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { payload . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 463 ---------------------------------------------
Closes a connection . --> Klder . --> Socre: 1.0

[[[[Adv]]]]: public void [[removeAndTryClose]] ( Connection connection ) { if ( null == connection ) { return ; } boolean [[res]] = this . conns . remove ( connection ) ; if ( [[res]] ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void [[kuen]] ( Connection connection ) { if ( null == connection ) { return ; } boolean [[schwarzenegger]] = this . conns . remove ( connection ) ; if ( [[schwarzenegger]] ) { connection . decreaseRef ( ) ; } if ( connection . noRef ( ) ) { connection . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 464 ---------------------------------------------
Get custom serializer for command code --> parses pooter --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[pooter]] ( CommandCode [[airways]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[airways]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 465 ---------------------------------------------
Update the payload . --> Write cassette . --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[pay]] = ByteBuffer . allocate ( 2 + by . length ) ; [[pay]] . put ( buf ) ; [[pay]] . put ( by ) ; [[pay]] . rewind ( ) ; super . setPayload ( [[pay]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[cassettes]] ( ) { byte [ ] by = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer buf = ByteBuffer . allocate ( 4 ) ; buf . putInt ( code ) ; buf . position ( 2 ) ; ByteBuffer [[babylon]] = ByteBuffer . allocate ( 2 + by . length ) ; [[babylon]] . put ( buf ) ; [[babylon]] . put ( by ) ; [[babylon]] . rewind ( ) ; super . setPayload ( [[babylon]] ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 466 ---------------------------------------------
Translate single frame size checker . --> Helper method to translate single PacketSize --> Socre: 1.0

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[maxpacketsize]] , int realpacketsize ) throws IncompleteException { if ( [[maxpacketsize]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void translateSingleFrameCheckPacketSize ( int [[cheapo]] , int realpacketsize ) throws IncompleteException { if ( [[cheapo]] < realpacketsize ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( realpacketsize ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 467 ---------------------------------------------
Get remote port . --> Get barcode --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[ryoko]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[barbiturates]] = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( [[barbiturates]] != null ) { return [[barbiturates]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 468 ---------------------------------------------
Processes a continuous frame --> Processes frames that have been started . --> Socre: 1.0

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata [[frame]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[frame]] ) ; } else if ( [[frame]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[frame]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void processFrameContinuousAndNonFin ( WebSocketImpl webSocketImpl , Framedata [[bloodlust]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[bloodlust]] ) ; } else if ( [[bloodlust]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[bloodlust]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 469 ---------------------------------------------
Processes a binary frame . --> Fired on websocket . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[filho]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 392 / 65 / 13 / 470:  47%|████▋     | 470/1000 [4:56:22<5:34:12, 37.83s/it][Succeeded / Failed / Skipped / Total] 392 / 65 / 13 / 470:  47%|████▋     | 471/1000 [4:56:29<5:32:59, 37.77s/it][Succeeded / Failed / Skipped / Total] 393 / 65 / 13 / 471:  47%|████▋     | 471/1000 [4:56:29<5:32:59, 37.77s/it][Succeeded / Failed / Skipped / Total] 393 / 65 / 13 / 471:  47%|████▋     | 472/1000 [4:56:46<5:31:59, 37.73s/it][Succeeded / Failed / Skipped / Total] 394 / 65 / 13 / 472:  47%|████▋     | 472/1000 [4:56:46<5:31:59, 37.73s/it][Succeeded / Failed / Skipped / Total] 394 / 65 / 13 / 472:  47%|████▋     | 473/1000 [4:57:07<5:31:02, 37.69s/it][Succeeded / Failed / Skipped / Total] 395 / 65 / 13 / 473:  47%|████▋     | 473/1000 [4:57:07<5:31:02, 37.69s/it][Succeeded / Failed / Skipped / Total] 395 / 65 / 13 / 473:  47%|████▋     | 474/1000 [4:57:19<5:29:56, 37.64s/it][Succeeded / Failed / Skipped / Total] 396 / 65 / 13 / 474:  47%|████▋     | 474/1000 [4:57:19<5:29:56, 37.64s/it][Succeeded / Failed / Skipped / Total] 396 / 65 / 13 / 474:  48%|████▊     | 475/1000 [4:57:41<5:29:01, 37.60s/it][Succeeded / Failed / Skipped / Total] 397 / 65 / 13 / 475:  48%|████▊     | 475/1000 [4:57:41<5:29:01, 37.60s/it][Succeeded / Failed / Skipped / Total] 397 / 65 / 13 / 475:  48%|████▊     | 476/1000 [4:58:36<5:28:43, 37.64s/it]Logs a runtime exception . --> Called after WebSocket message has been received . --> Socre: 1.0

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException [[e]] ) { log . error ( "Runtime exception during onWebsocketMessage" , [[e]] ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , [[e]] ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void logRuntimeException ( WebSocketImpl webSocketImpl , RuntimeException [[bedding]] ) { log . error ( "Runtime exception during onWebsocketMessage" , [[bedding]] ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , [[bedding]] ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 471 ---------------------------------------------
Check if the remote address is connected . --> Checks if the server is savour . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String remoteAddr ) { Url url = this . [[rpcRemoting]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[savour]] ( String remoteAddr ) { Url url = this . [[elisa]] . addressParser . parse ( remoteAddr ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 472 ---------------------------------------------
Processes the next frame . --> Deprecated . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[depot]] ( Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = frame ; addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 473 ---------------------------------------------
Process the current frame --> Heartbeat frames . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[heartily]] ( WebSocketImpl webSocketImpl , Framedata frame ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( frame . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 474 ---------------------------------------------
Checks if the limit is exceeded . --> Checks how much data should be exceeded --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[dossiers]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 475 ---------------------------------------------
Checks whether the requested protocol contains the requested protocol . --> Selects a handshake state . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String requestedProtocol ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[fawkes]] ( String requestedProtocol ) { for ( IProtocol [[vallon]] : knownProtocols ) { if ( [[vallon]] . acceptProvidedProtocol ( requestedProtocol ) ) { protocol = [[vallon]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 476 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 398 / 65 / 13 / 476:  48%|████▊     | 476/1000 [4:58:36<5:28:43, 37.64s/it][Succeeded / Failed / Skipped / Total] 398 / 65 / 13 / 476:  48%|████▊     | 477/1000 [4:58:44<5:27:33, 37.58s/it][Succeeded / Failed / Skipped / Total] 399 / 65 / 13 / 477:  48%|████▊     | 477/1000 [4:58:44<5:27:33, 37.58s/it][Succeeded / Failed / Skipped / Total] 399 / 65 / 13 / 477:  48%|████▊     | 478/1000 [4:58:45<5:26:15, 37.50s/it][Succeeded / Failed / Skipped / Total] 400 / 65 / 13 / 478:  48%|████▊     | 478/1000 [4:58:45<5:26:15, 37.50s/it][Succeeded / Failed / Skipped / Total] 400 / 65 / 13 / 478:  48%|████▊     | 479/1000 [4:58:52<5:25:04, 37.44s/it][Succeeded / Failed / Skipped / Total] 401 / 65 / 13 / 479:  48%|████▊     | 479/1000 [4:58:52<5:25:04, 37.44s/it][Succeeded / Failed / Skipped / Total] 401 / 65 / 13 / 479:  48%|████▊     | 480/1000 [4:58:52<5:23:47, 37.36s/it][Succeeded / Failed / Skipped / Total] 402 / 65 / 13 / 480:  48%|████▊     | 480/1000 [4:58:52<5:23:47, 37.36s/it][Succeeded / Failed / Skipped / Total] 402 / 65 / 13 / 480:  48%|████▊     | 481/1000 [4:59:13<5:22:51, 37.32s/it][Succeeded / Failed / Skipped / Total] 403 / 65 / 13 / 481:  48%|████▊     | 481/1000 [4:59:13<5:22:51, 37.32s/it][Succeeded / Failed / Skipped / Total] 403 / 65 / 13 / 481:  48%|████▊     | 482/1000 [4:59:53<5:22:17, 37.33s/it][Succeeded / Failed / Skipped / Total] 403 / 66 / 13 / 482:  48%|████▊     | 482/1000 [4:59:53<5:22:17, 37.33s/it][Succeeded / Failed / Skipped / Total] 403 / 66 / 13 / 482:  48%|████▊     | 483/1000 [4:59:58<5:21:05, 37.26s/it]Generates final key . --> Verifies the cache . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String [[in]] ) { String seckey = [[in]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[affidavit]] ( String [[stale]] ) { String seckey = [[stale]] . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 477 ---------------------------------------------
Translate handshake . --> Translate an HTTP header line . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder translateHandshakeHttpServer ( String [ ] [[wheeling]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 478 ---------------------------------------------
Translate single frame length limit . --> Deserializes payload . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[deserters]] ( long [[chasin]] ) throws LimitExceededException { if ( [[chasin]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[chasin]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[chasin]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[chasin]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 479 ---------------------------------------------
Process a close frame . --> Handles dialog queues . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl [[webSocketImpl]] , Framedata frame ) { int [[code]] = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; [[code]] = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[webSocketImpl]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[dialogues]] ( WebSocketImpl [[whatwe]] , Framedata frame ) { int [[alcoholic]] = CloseFrame . NOCODE ; String reason = "" ; if ( frame instanceof CloseFrame ) { CloseFrame cf = ( CloseFrame ) frame ; [[alcoholic]] = cf . getCloseCode ( ) ; reason = cf . getMessage ( ) ; } if ( [[whatwe]] . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 480 ---------------------------------------------
Decodes the packet . --> Decodes and decodes bytes . --> Socre: 1.0

[[[[Adv]]]]: public void decode ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer [[graveyards]] ) { assert ( [[graveyards]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[graveyards]] . remaining ( ) , ( [[graveyards]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[graveyards]] . array ( ) , [[graveyards]] . position ( ) , [[graveyards]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[graveyards]] ) ; } } else { if ( decodeHandshake ( [[graveyards]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[graveyards]] . hasRemaining ( ) || ! [[graveyards]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 481 ---------------------------------------------
Process a text message --> Bor method . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[borin]] ( WebSocketImpl [[lowed]] , Framedata [[troubadours]] ) throws InvalidDataException { try { [[lowed]] . getWebSocketListener ( ) . onWebsocketMessage ( [[lowed]] , Charsetfunctions . stringUtf8 ( [[troubadours]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[lowed]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 482 ---------------------------------------------
Register a custom serializer for command code . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode [[code]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = commandCustomSerializer . putIfAbsent ( [[code]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[code]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[duplicates]] ( CommandCode [[vibrators]] , CustomSerializer [[gav]] ) { CustomSerializer [[asuncion]] = commandCustomSerializer . putIfAbsent ( [[vibrators]] , [[gav]] ) ; if ( [[asuncion]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + [[vibrators]] + ", the custom serializer is: " + [[asuncion]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 483 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 404 / 66 / 13 / 483:  48%|████▊     | 483/1000 [4:59:58<5:21:05, 37.26s/it][Succeeded / Failed / Skipped / Total] 404 / 66 / 13 / 483:  48%|████▊     | 484/1000 [4:59:58<5:19:48, 37.19s/it][Succeeded / Failed / Skipped / Total] 404 / 66 / 14 / 484:  48%|████▊     | 484/1000 [4:59:58<5:19:48, 37.19s/it][Succeeded / Failed / Skipped / Total] 404 / 66 / 14 / 484:  48%|████▊     | 485/1000 [5:00:17<5:18:51, 37.15s/it][Succeeded / Failed / Skipped / Total] 405 / 66 / 14 / 485:  48%|████▊     | 485/1000 [5:00:17<5:18:51, 37.15s/it][Succeeded / Failed / Skipped / Total] 405 / 66 / 14 / 485:  49%|████▊     | 486/1000 [5:00:17<5:17:36, 37.07s/it][Succeeded / Failed / Skipped / Total] 406 / 66 / 14 / 486:  49%|████▊     | 486/1000 [5:00:17<5:17:36, 37.07s/it][Succeeded / Failed / Skipped / Total] 406 / 66 / 14 / 486:  49%|████▊     | 487/1000 [5:00:27<5:16:29, 37.02s/it][Succeeded / Failed / Skipped / Total] 407 / 66 / 14 / 487:  49%|████▊     | 487/1000 [5:00:27<5:16:29, 37.02s/it][Succeeded / Failed / Skipped / Total] 407 / 66 / 14 / 487:  49%|████▉     | 488/1000 [5:00:34<5:15:21, 36.96s/it][Succeeded / Failed / Skipped / Total] 408 / 66 / 14 / 488:  49%|████▉     | 488/1000 [5:00:34<5:15:21, 36.96s/it][Succeeded / Failed / Skipped / Total] 408 / 66 / 14 / 488:  49%|████▉     | 489/1000 [5:00:43<5:14:14, 36.90s/it][Succeeded / Failed / Skipped / Total] 409 / 66 / 14 / 489:  49%|████▉     | 489/1000 [5:00:43<5:14:14, 36.90s/it][Succeeded / Failed / Skipped / Total] 409 / 66 / 14 / 489:  49%|████▉     | 490/1000 [5:00:43<5:13:00, 36.82s/it]Get the complete payload from the byte buffer list . --> Get byte buffer from byte buffer list --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long [[totalSize]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { [[totalSize]] += [[buffer]] . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[totalSize]] ) ; for ( ByteBuffer [[buffer]] : byteBufferList ) { resultingByteBuffer . put ( [[buffer]] ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer getPayloadFromByteBufferList ( ) throws LimitExceededException { long [[chroma]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer [[osamu]] : byteBufferList ) { [[chroma]] += [[osamu]] . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[chroma]] ) ; for ( ByteBuffer [[osamu]] : byteBufferList ) { resultingByteBuffer . put ( [[osamu]] ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 484 ---------------------------------------------
Resets the websocket . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 485 ---------------------------------------------
Start the connect thread . --> Starts a new thread --> Socre: 1.0

[[[[Adv]]]]: public void [[connect]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void [[drift]] ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 486 ---------------------------------------------
Close the connection . --> Send an alphaned response --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[alto]] ( InvalidDataException [[busboys]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[busboys]] . getCloseCode ( ) , [[busboys]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 487 ---------------------------------------------
Write the connection to the server . --> Send an exception --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[False]]" != "[[False]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[angus]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "[[Harmonies]]" != "[[Harmonies]]" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 488 ---------------------------------------------
Sets the connection lost timeout . --> Permanently reconnects . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[pimping]] ( int connectionLostTimeout ) { synchronized ( syncConnectionLost ) { this . connectionLostTimeout = TimeUnit . SECONDS . toNanos ( connectionLostTimeout ) ; if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . websocketRunning ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 489 ---------------------------------------------
Generates the HTTP response from an error . --> Initiate HTTP 1 - 1 . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int errorCode ) { String [[errorCodeDescription]] ; switch ( errorCode ) { case 404 : [[errorCodeDescription]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[errorCodeDescription]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[errorCodeDescription]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[errorCodeDescription]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[errorCodeDescription]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[nic]] ( int errorCode ) { String [[hypnotism]] ; switch ( errorCode ) { case 404 : [[hypnotism]] = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : [[hypnotism]] = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + [[hypnotism]] + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + [[hypnotism]] . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + [[hypnotism]] + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 490 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 410 / 66 / 14 / 490:  49%|████▉     | 490/1000 [5:00:43<5:13:00, 36.82s/it][Succeeded / Failed / Skipped / Total] 410 / 66 / 14 / 490:  49%|████▉     | 491/1000 [5:01:07<5:12:09, 36.80s/it][Succeeded / Failed / Skipped / Total] 411 / 66 / 14 / 491:  49%|████▉     | 491/1000 [5:01:07<5:12:09, 36.80s/it][Succeeded / Failed / Skipped / Total] 411 / 66 / 14 / 491:  49%|████▉     | 492/1000 [5:01:20<5:11:08, 36.75s/it][Succeeded / Failed / Skipped / Total] 412 / 66 / 14 / 492:  49%|████▉     | 492/1000 [5:01:20<5:11:08, 36.75s/it][Succeeded / Failed / Skipped / Total] 412 / 66 / 14 / 492:  49%|████▉     | 493/1000 [5:01:31<5:10:05, 36.70s/it][Succeeded / Failed / Skipped / Total] 413 / 66 / 14 / 493:  49%|████▉     | 493/1000 [5:01:31<5:10:05, 36.70s/it][Succeeded / Failed / Skipped / Total] 413 / 66 / 14 / 493:  49%|████▉     | 494/1000 [5:01:41<5:09:01, 36.64s/it][Succeeded / Failed / Skipped / Total] 414 / 66 / 14 / 494:  49%|████▉     | 494/1000 [5:01:41<5:09:01, 36.64s/it][Succeeded / Failed / Skipped / Total] 414 / 66 / 14 / 494:  50%|████▉     | 495/1000 [5:01:51<5:07:56, 36.59s/it][Succeeded / Failed / Skipped / Total] 415 / 66 / 14 / 495:  50%|████▉     | 495/1000 [5:01:51<5:07:56, 36.59s/it][Succeeded / Failed / Skipped / Total] 415 / 66 / 14 / 495:  50%|████▉     | 496/1000 [5:01:59<5:06:51, 36.53s/it][Succeeded / Failed / Skipped / Total] 416 / 66 / 14 / 496:  50%|████▉     | 496/1000 [5:01:59<5:06:51, 36.53s/it][Succeeded / Failed / Skipped / Total] 416 / 66 / 14 / 496:  50%|████▉     | 497/1000 [5:02:18<5:05:57, 36.50s/it]Stop connection lost timer . --> Starts monitoring thread . --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[amado]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . websocketRunning = "False" != "False" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 491 ---------------------------------------------
Send a message to the WebSocket . --> documentation inherited from WebSocketImpl --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[published]] ( String text ) { if ( text == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[published]] ( draft . createFrames ( text , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 492 ---------------------------------------------
Execute a connection lost ping . --> Called when WebSocket is detected . --> Socre: 1.0

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket [[webSocket]] , long minimumPongTime ) { if ( ! ( [[webSocket]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[webSocket]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket [[deviled]] , long minimumPongTime ) { if ( ! ( [[deviled]] instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) [[deviled]] ; if ( webSocketImpl . getLastPong ( ) < minimumPongTime ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 493 ---------------------------------------------
Translate handshake . --> Create an instance of arto . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] [[firstLineTokens]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[artois]] ( String [ ] [[pedicure]] , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 494 ---------------------------------------------
Notify the handshake . --> from interface handshake --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake [[request]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder onWebsocketHandshakeReceivedAsServer ( WebSocket conn , Draft draft , ClientHandshake [[estonia]] ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 495 ---------------------------------------------
Gets the total size of the byte buffer list . --> return a long value --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[buffer]] : byteBufferList ) { [[totalSize]] += [[buffer]] . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[rotted]] ( ) { long [[precious]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer [[blinding]] : byteBufferList ) { [[precious]] += [[blinding]] . limit ( ) ; } } return [[precious]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 496 ---------------------------------------------
Stops the queue . --> Enqueues queuing --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[plié]] ( int timeout ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "False" != "False" , "True" == "True" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 497 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 417 / 66 / 14 / 497:  50%|████▉     | 497/1000 [5:02:18<5:05:57, 36.50s/it][Succeeded / Failed / Skipped / Total] 417 / 66 / 14 / 497:  50%|████▉     | 498/1000 [5:02:19<5:04:45, 36.42s/it][Succeeded / Failed / Skipped / Total] 418 / 66 / 14 / 498:  50%|████▉     | 498/1000 [5:02:19<5:04:45, 36.42s/it][Succeeded / Failed / Skipped / Total] 418 / 66 / 14 / 498:  50%|████▉     | 499/1000 [5:02:27<5:03:40, 36.37s/it][Succeeded / Failed / Skipped / Total] 419 / 66 / 14 / 499:  50%|████▉     | 499/1000 [5:02:27<5:03:40, 36.37s/it][Succeeded / Failed / Skipped / Total] 419 / 66 / 14 / 499:  50%|█████     | 500/1000 [5:02:32<5:02:32, 36.31s/it][Succeeded / Failed / Skipped / Total] 420 / 66 / 14 / 500:  50%|█████     | 500/1000 [5:02:32<5:02:32, 36.31s/it][Succeeded / Failed / Skipped / Total] 420 / 66 / 14 / 500:  50%|█████     | 501/1000 [5:02:35<5:01:22, 36.24s/it][Succeeded / Failed / Skipped / Total] 421 / 66 / 14 / 501:  50%|█████     | 501/1000 [5:02:35<5:01:22, 36.24s/it][Succeeded / Failed / Skipped / Total] 421 / 66 / 14 / 501:  50%|█████     | 502/1000 [5:02:36<5:00:12, 36.17s/it]Restarts the connection lost timer . --> Main builder method . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[minimumPongTime]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[minimumPongTime]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[builder]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long [[refueled]] = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , [[refueled]] ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 498 ---------------------------------------------
Returns the port . --> Tries to determine how to round a round trip . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[alla]] ( ) { int [[round]] = uri . getPort ( ) ; if ( [[round]] == - 1 ) { String scheme = uri . getScheme ( ) ; if ( "wss" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( scheme ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + scheme ) ; } } return [[round]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 499 ---------------------------------------------
Accepts a single selection . --> Accepts the server . --> Socre: 1.0

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[i]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > [[chartreuse]] ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; [[chartreuse]] . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 500 ---------------------------------------------
Handles additional read . --> Parses the queue . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[analytic]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 501 ---------------------------------------------
Cancels the connection lost timer . --> Fire a tombstone waiter . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[firestone]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[Mauna]]" != "[[Mauna]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 422 / 66 / 14 / 502:  50%|█████     | 502/1000 [5:02:36<5:00:12, 36.17s/it][Succeeded / Failed / Skipped / Total] 422 / 66 / 14 / 502:  50%|█████     | 503/1000 [5:02:37<4:59:00, 36.10s/it][Succeeded / Failed / Skipped / Total] 422 / 66 / 15 / 503:  50%|█████     | 503/1000 [5:02:37<4:59:00, 36.10s/it][Succeeded / Failed / Skipped / Total] 422 / 66 / 15 / 503:  50%|█████     | 504/1000 [5:02:40<4:57:52, 36.03s/it][Succeeded / Failed / Skipped / Total] 423 / 66 / 15 / 504:  50%|█████     | 504/1000 [5:02:40<4:57:52, 36.03s/it][Succeeded / Failed / Skipped / Total] 423 / 66 / 15 / 504:  50%|█████     | 505/1000 [5:02:43<4:56:43, 35.97s/it][Succeeded / Failed / Skipped / Total] 424 / 66 / 15 / 505:  50%|█████     | 505/1000 [5:02:43<4:56:43, 35.97s/it][Succeeded / Failed / Skipped / Total] 424 / 66 / 15 / 505:  51%|█████     | 506/1000 [5:03:20<4:56:08, 35.97s/it][Succeeded / Failed / Skipped / Total] 425 / 66 / 15 / 506:  51%|█████     | 506/1000 [5:03:20<4:56:08, 35.97s/it][Succeeded / Failed / Skipped / Total] 425 / 66 / 15 / 506:  51%|█████     | 507/1000 [5:03:21<4:54:58, 35.90s/it][Succeeded / Failed / Skipped / Total] 426 / 66 / 15 / 507:  51%|█████     | 507/1000 [5:03:21<4:54:58, 35.90s/it][Succeeded / Failed / Skipped / Total] 426 / 66 / 15 / 507:  51%|█████     | 508/1000 [5:03:21<4:53:48, 35.83s/it][Succeeded / Failed / Skipped / Total] 426 / 66 / 16 / 508:  51%|█████     | 508/1000 [5:03:21<4:53:48, 35.83s/it][Succeeded / Failed / Skipped / Total] 426 / 66 / 16 / 508:  51%|█████     | 509/1000 [5:03:29<4:52:45, 35.78s/it]Handles a read . --> Reads data from the input . --> Socre: 1.0

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > [[i]] ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; [[i]] . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean doRead ( SelectionKey key , Iterator < SelectionKey > [[greenie]] ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; [[greenie]] . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 503 ---------------------------------------------
Ensure that a single thread is single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 504 ---------------------------------------------
Handles a single write --> Writes the data to the attachment . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl [[conn]] = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( [[conn]] , [[conn]] . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey key ) throws IOException { WebSocketImpl [[retailers]] = ( WebSocketImpl ) key . attachment ( ) ; if ( SocketChannelIOHelper . batch ( [[retailers]] , [[retailers]] . getChannel ( ) ) ) { if ( key . isValid ( ) ) { key . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 505 ---------------------------------------------
Perform shutdown . --> Shuts down the server . --> Socre: 1.0

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[w]] : decoders ) { [[w]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown

[[[[Adv]]]]: private void doServerShutdown ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker [[diphtheria]] : decoders ) { [[diphtheria]] . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 506 ---------------------------------------------
Returns the port . --> Implementation of Gimbalancer --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[gimbal]] ( ) { int [[okamoto]] = getAddress ( ) . getPort ( ) ; if ( [[okamoto]] == 0 && server != null ) { [[okamoto]] = server . socket ( ) . getLocalPort ( ) ; } return [[okamoto]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 507 ---------------------------------------------
Broadcast data to all clients . --> Broadcast an afriend message . --> Socre: 1.0

[[[[Adv]]]]: public void broadcast ( byte [ ] [[data]] , Collection < WebSocket > clients ) { if ( [[data]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[data]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void broadcast ( byte [ ] [[afriend]] , Collection < WebSocket > clients ) { if ( [[afriend]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } broadcast ( ByteBuffer . wrap ( [[afriend]] ) , clients ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 508 ---------------------------------------------
Performs a broadcast broadcast . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doBroadcast ( Object data , Collection < WebSocket > clients ) { String sData = null ; if ( data instanceof String ) { sData = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( sData == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , sData , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 509 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 66 / 16 / 509:  51%|█████     | 509/1000 [5:03:29<4:52:45, 35.78s/it][Succeeded / Failed / Skipped / Total] 427 / 66 / 16 / 509:  51%|█████     | 510/1000 [5:03:31<4:51:37, 35.71s/it][Succeeded / Failed / Skipped / Total] 428 / 66 / 16 / 510:  51%|█████     | 510/1000 [5:03:31<4:51:37, 35.71s/it][Succeeded / Failed / Skipped / Total] 428 / 66 / 16 / 510:  51%|█████     | 511/1000 [5:03:40<4:50:36, 35.66s/it][Succeeded / Failed / Skipped / Total] 429 / 66 / 16 / 511:  51%|█████     | 511/1000 [5:03:40<4:50:36, 35.66s/it][Succeeded / Failed / Skipped / Total] 429 / 66 / 16 / 511:  51%|█████     | 512/1000 [5:03:42<4:49:27, 35.59s/it][Succeeded / Failed / Skipped / Total] 430 / 66 / 16 / 512:  51%|█████     | 512/1000 [5:03:42<4:49:27, 35.59s/it][Succeeded / Failed / Skipped / Total] 430 / 66 / 16 / 512:  51%|█████▏    | 513/1000 [5:04:13<4:48:48, 35.58s/it][Succeeded / Failed / Skipped / Total] 431 / 66 / 16 / 513:  51%|█████▏    | 513/1000 [5:04:13<4:48:48, 35.58s/it][Succeeded / Failed / Skipped / Total] 431 / 66 / 16 / 513:  51%|█████▏    | 514/1000 [5:04:14<4:47:40, 35.51s/it][Succeeded / Failed / Skipped / Total] 432 / 66 / 16 / 514:  51%|█████▏    | 514/1000 [5:04:14<4:47:40, 35.51s/it][Succeeded / Failed / Skipped / Total] 432 / 66 / 16 / 514:  52%|█████▏    | 515/1000 [5:04:22<4:46:38, 35.46s/it][Succeeded / Failed / Skipped / Total] 433 / 66 / 16 / 515:  52%|█████▏    | 515/1000 [5:04:22<4:46:38, 35.46s/it][Succeeded / Failed / Skipped / Total] 433 / 66 / 16 / 515:  52%|█████▏    | 516/1000 [5:04:30<4:45:37, 35.41s/it][Succeeded / Failed / Skipped / Total] 434 / 66 / 16 / 516:  52%|█████▏    | 516/1000 [5:04:30<4:45:37, 35.41s/it][Succeeded / Failed / Skipped / Total] 434 / 66 / 16 / 516:  52%|█████▏    | 517/1000 [5:04:33<4:44:31, 35.34s/it]Fill the frames from a draft --> Add a frame to a draft --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[brent]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String sData , ByteBuffer bData ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( sData != null ) { frames = draft . createFrames ( sData , "False" != "False" ) ; } if ( bData != null ) { frames = draft . createFrames ( bData , "False" != "False" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 510 ---------------------------------------------
Sends a ping frame . --> removes all commited frames --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket conn , Framedata [[f]] ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) [[f]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[alluring]] ( WebSocket conn , Framedata [[confiscating]] ) { conn . sendFrame ( new PongFrame ( ( PingFrame ) [[confiscating]] ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 511 ---------------------------------------------
Transfers source to destination . --> Transfers damaged data into a byte buffer . --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[injured]] , ByteBuffer dest ) { if ( [[injured]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[injured]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[injured]] . limit ( limit ) ; dest . put ( [[injured]] ) ; return limit ; } else { dest . put ( [[injured]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 512 ---------------------------------------------
Starts the manager . --> This method will be called from persistence unit tests --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[namaste]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 513 ---------------------------------------------
Returns the socket associated with the given connection . --> Liefert einen a websocket . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket conn ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[wehrmacht]] ( WebSocket conn ) { WebSocketImpl [[phonograph]] = ( WebSocketImpl ) conn ; return ( ( SocketChannel ) [[phonograph]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 514 ---------------------------------------------
Enters a transaction with the given transaction . --> Yield YAMO --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > block ) { [[withTransaction]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[yoru]] ( Consumer < EntityManager > block ) { [[yoru]] ( em -> { block . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 515 ---------------------------------------------
Start connection lost timer . --> Do a periodic update . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "[[True]]" == "[[True]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[doodly]] ( ) { synchronized ( syncConnectionLost ) { if ( this . [[nightgown]] <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[tapers]] = "[[Periodical]]" == "[[Periodical]]" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 516 ---------------------------------------------
Converts the given arguments to a Scala buffer . --> Convert ringlets . --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > convertArgsToScalaBuffer ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > convertArgsToScalaBuffer ( final Object ... [[ringlets]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[ringlets]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 517 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 434 / 67 / 16 / 517:  52%|█████▏    | 517/1000 [5:04:33<4:44:31, 35.34s/it][Succeeded / Failed / Skipped / Total] 434 / 67 / 16 / 517:  52%|█████▏    | 518/1000 [5:05:09<4:43:57, 35.35s/it][Succeeded / Failed / Skipped / Total] 435 / 67 / 16 / 518:  52%|█████▏    | 518/1000 [5:05:09<4:43:57, 35.35s/it][Succeeded / Failed / Skipped / Total] 435 / 67 / 16 / 518:  52%|█████▏    | 519/1000 [5:05:12<4:42:51, 35.28s/it][Succeeded / Failed / Skipped / Total] 436 / 67 / 16 / 519:  52%|█████▏    | 519/1000 [5:05:12<4:42:51, 35.28s/it][Succeeded / Failed / Skipped / Total] 436 / 67 / 16 / 519:  52%|█████▏    | 520/1000 [5:05:55<4:42:23, 35.30s/it][Succeeded / Failed / Skipped / Total] 437 / 67 / 16 / 520:  52%|█████▏    | 520/1000 [5:05:55<4:42:23, 35.30s/it][Succeeded / Failed / Skipped / Total] 437 / 67 / 16 / 520:  52%|█████▏    | 521/1000 [5:06:17<4:41:36, 35.27s/it][Succeeded / Failed / Skipped / Total] 438 / 67 / 16 / 521:  52%|█████▏    | 521/1000 [5:06:17<4:41:36, 35.27s/it][Succeeded / Failed / Skipped / Total] 438 / 67 / 16 / 521:  52%|█████▏    | 522/1000 [5:06:31<4:40:41, 35.23s/it][Succeeded / Failed / Skipped / Total] 439 / 67 / 16 / 522:  52%|█████▏    | 522/1000 [5:06:31<4:40:41, 35.23s/it][Succeeded / Failed / Skipped / Total] 439 / 67 / 16 / 522:  52%|█████▏    | 523/1000 [5:07:00<4:39:59, 35.22s/it][Succeeded / Failed / Skipped / Total] 440 / 67 / 16 / 523:  52%|█████▏    | 523/1000 [5:07:00<4:39:59, 35.22s/it][Succeeded / Failed / Skipped / Total] 440 / 67 / 16 / 523:  52%|█████▏    | 524/1000 [5:07:06<4:38:58, 35.17s/it]Sends the handshake . --> [[[FAILED]]]

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[kv]] : headers . entrySet ( ) ) { handshake . put ( [[kv]] . getKey ( ) , [[kv]] . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void sendHandshake ( ) throws InvalidHandshakeException { String path ; String part1 = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( part1 == null || part1 . length ( ) == 0 ) path = "/" ; else path = part1 ; if ( part2 != null ) path += ' ' + part2 ; int port = getPort ( ) ; String host = uri . getHost ( ) + ( ( port != WebSocketImpl . DEFAULT_PORT && port != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + port : "" ) ; HandshakeImpl1Client handshake = new HandshakeImpl1Client ( ) ; handshake . setResourceDescriptor ( path ) ; handshake . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > [[hotplate]] : headers . entrySet ( ) ) { handshake . put ( [[hotplate]] . getKey ( ) , [[hotplate]] . getValue ( ) ) ; } } engine . startHandshake ( handshake ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 518 ---------------------------------------------
Broadcast a text to all clients . --> Performs chiariant communication . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > clients ) { if ( [[text]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[chiara]] ( String [[clichéd]] , Collection < WebSocket > clients ) { if ( [[clichéd]] == null || clients == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[clichéd]] , clients ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 519 ---------------------------------------------
Setup selector and server thread . --> Create crumb . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[False]]" != "[[False]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[False]]" != "[[False]]" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[crumb]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "[[Yoou]]" != "[[Yoou]]" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "[[Yoou]]" != "[[Yoou]]" ; } return "[[Boron]]" == "[[Boron]]" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 520 ---------------------------------------------
Returns the entity manager for the given name . --> Returns null if no solver exists --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory emf = emfs . get ( [[name]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[solitaire]] ( String [[bergeron]] ) { EntityManagerFactory emf = emfs . get ( [[bergeron]] ) ; if ( emf == null ) { return null ; } return emf . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 521 ---------------------------------------------
Gets a localized message . --> Converts a set of housewarming events to a table --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , List < String > [[keys]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[tablecloths]] ( play . api . i18n . Lang lang , List < String > [[housewarming]] , Object ... args ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[housewarming]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( args ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 522 ---------------------------------------------
Gets a localized message . --> helper method to translate vibrators --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang lang , String key , Object ... [[args]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[tellier]] ( play . api . i18n . Lang lang , String key , Object ... [[vibrators]] ) { Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[vibrators]] ) ; return messages . apply ( key , scalaArgs , lang ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 523 ---------------------------------------------
Define a set of bindings for the given modules . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self bindings ( GuiceableModule ... [[chloride]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[chloride]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 524 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 441 / 67 / 16 / 524:  52%|█████▏    | 524/1000 [5:07:06<4:38:58, 35.17s/it][Succeeded / Failed / Skipped / Total] 441 / 67 / 16 / 524:  52%|█████▎    | 525/1000 [5:07:11<4:37:56, 35.11s/it][Succeeded / Failed / Skipped / Total] 442 / 67 / 16 / 525:  52%|█████▎    | 525/1000 [5:07:11<4:37:56, 35.11s/it][Succeeded / Failed / Skipped / Total] 442 / 67 / 16 / 525:  53%|█████▎    | 526/1000 [5:07:19<4:36:56, 35.06s/it][Succeeded / Failed / Skipped / Total] 443 / 67 / 16 / 526:  53%|█████▎    | 526/1000 [5:07:19<4:36:56, 35.06s/it][Succeeded / Failed / Skipped / Total] 443 / 67 / 16 / 526:  53%|█████▎    | 527/1000 [5:07:23<4:35:53, 35.00s/it][Succeeded / Failed / Skipped / Total] 444 / 67 / 16 / 527:  53%|█████▎    | 527/1000 [5:07:23<4:35:53, 35.00s/it][Succeeded / Failed / Skipped / Total] 444 / 67 / 16 / 527:  53%|█████▎    | 528/1000 [5:07:39<4:35:01, 34.96s/it][Succeeded / Failed / Skipped / Total] 445 / 67 / 16 / 528:  53%|█████▎    | 528/1000 [5:07:39<4:35:01, 34.96s/it][Succeeded / Failed / Skipped / Total] 445 / 67 / 16 / 528:  53%|█████▎    | 529/1000 [5:08:17<4:34:29, 34.97s/it][Succeeded / Failed / Skipped / Total] 446 / 67 / 16 / 529:  53%|█████▎    | 529/1000 [5:08:17<4:34:29, 34.97s/it][Succeeded / Failed / Skipped / Total] 446 / 67 / 16 / 529:  53%|█████▎    | 530/1000 [5:08:22<4:33:28, 34.91s/it][Succeeded / Failed / Skipped / Total] 447 / 67 / 16 / 530:  53%|█████▎    | 530/1000 [5:08:22<4:33:28, 34.91s/it][Succeeded / Failed / Skipped / Total] 447 / 67 / 16 / 530:  53%|█████▎    | 531/1000 [5:08:47<4:32:44, 34.89s/it][Succeeded / Failed / Skipped / Total] 448 / 67 / 16 / 531:  53%|█████▎    | 531/1000 [5:08:47<4:32:44, 34.89s/it][Succeeded / Failed / Skipped / Total] 448 / 67 / 16 / 531:  53%|█████▎    | 532/1000 [5:08:57<4:31:47, 34.84s/it][Succeeded / Failed / Skipped / Total] 449 / 67 / 16 / 532:  53%|█████▎    | 532/1000 [5:08:57<4:31:47, 34.84s/it][Succeeded / Failed / Skipped / Total] 449 / 67 / 16 / 532:  53%|█████▎    | 533/1000 [5:09:06<4:30:49, 34.80s/it][Succeeded / Failed / Skipped / Total] 449 / 68 / 16 / 533:  53%|█████▎    | 533/1000 [5:09:06<4:30:49, 34.80s/it][Succeeded / Failed / Skipped / Total] 449 / 68 / 16 / 533:  53%|█████▎    | 534/1000 [5:09:07<4:29:45, 34.73s/it][Succeeded / Failed / Skipped / Total] 450 / 68 / 16 / 534:  53%|█████▎    | 534/1000 [5:09:07<4:29:45, 34.73s/it][Succeeded / Failed / Skipped / Total] 450 / 68 / 16 / 534:  54%|█████▎    | 535/1000 [5:09:10<4:28:42, 34.67s/it][Succeeded / Failed / Skipped / Total] 451 / 68 / 16 / 535:  54%|█████▎    | 535/1000 [5:09:10<4:28:42, 34.67s/it][Succeeded / Failed / Skipped / Total] 451 / 68 / 16 / 535:  54%|█████▎    | 536/1000 [5:10:04<4:28:24, 34.71s/it]Set the translation for the result . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public Result setLang ( Result result , Lang [[lang]] ) { return messages . setLang ( result . asScala ( ) , [[lang]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result setLang ( Result result , Lang [[adding]] ) { return messages . setLang ( result . asScala ( ) , [[adding]] ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 525 ---------------------------------------------
Define a set of bindings . --> Specify an Organization --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[OUCH]] ( play . api . inject . Binding < ? > ... [[OUCH]] ) { return [[OUCH]] ( Guiceable . bindings ( [[OUCH]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 526 ---------------------------------------------
Performs a set of overrides for the given modules . --> This method will be overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self overrides ( GuiceableModule ... [[medical]] ) { return newBuilder ( delegate . overrides ( Scala . varargs ( [[medical]] ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 527 ---------------------------------------------
Overrides the default overrides . --> Get overrides the default overrides --> Socre: 1.0

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[modules]] ) { return overrides ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self overrides ( play . api . inject . Module ... [[vijay]] ) { return overrides ( Guiceable . [[vijay]] ( [[vijay]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 528 ---------------------------------------------
Set the default overrides for the given bindings . --> Sum of Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... bindings ) { return [[overrides]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[sumatra]] ( play . api . inject . Binding < ? > ... bindings ) { return [[sumatra]] ( Guiceable . bindings ( bindings ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 529 ---------------------------------------------
Add bindings for the given modules . --> abound messenger --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[babcock]] ( play . api . inject . Module ... [[chatterjee]] ) { return [[babcock]] ( Guiceable . [[chatterjee]] ( [[chatterjee]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 530 ---------------------------------------------
Calls the given request . --> Perform a CompletionStage --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > call ( Request [[asceticism]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 531 ---------------------------------------------
Converts an annotation into a Java binding . --> Converts an annotation into a JavaBean --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A [[crawley]] Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 532 ---------------------------------------------
Static factory method for creating a tuple of values . --> Factory method . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B > [[Tuple]] < A , B > [[Tuple]] ( A a , B b ) { return new [[Tuple]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B

[[[[Adv]]]]: public static < A , B > [[Aerodrome]] < A , B > [[Aerodrome]] ( A a , B b ) { return new [[Aerodrome]] < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 533 ---------------------------------------------
Display preferred messages for the request . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[dep]] ( Http . RequestHeader request ) { play . api . i18n . Messages msgs = messages . preferred ( request ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 534 ---------------------------------------------
Static factory method for creating a Tuple . --> Static factory method for creating tuples . --> Socre: 1.0

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E [[e]] ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , [[e]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E [[auctions]] ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , [[auctions]] ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 535 ---------------------------------------------
Disable the given modules . --> Displays a contusion with the specified highlander --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[contusion]] ( Class < ? > ... [[highlander]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[highlander]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 536 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 452 / 68 / 16 / 536:  54%|█████▎    | 536/1000 [5:10:04<4:28:24, 34.71s/it][Succeeded / Failed / Skipped / Total] 452 / 68 / 16 / 536:  54%|█████▎    | 537/1000 [5:10:18<4:27:32, 34.67s/it][Succeeded / Failed / Skipped / Total] 453 / 68 / 16 / 537:  54%|█████▎    | 537/1000 [5:10:18<4:27:32, 34.67s/it][Succeeded / Failed / Skipped / Total] 453 / 68 / 16 / 537:  54%|█████▍    | 538/1000 [5:10:19<4:26:29, 34.61s/it][Succeeded / Failed / Skipped / Total] 454 / 68 / 16 / 538:  54%|█████▍    | 538/1000 [5:10:19<4:26:29, 34.61s/it][Succeeded / Failed / Skipped / Total] 454 / 68 / 16 / 538:  54%|█████▍    | 539/1000 [5:10:37<4:25:40, 34.58s/it][Succeeded / Failed / Skipped / Total] 455 / 68 / 16 / 539:  54%|█████▍    | 539/1000 [5:10:37<4:25:40, 34.58s/it][Succeeded / Failed / Skipped / Total] 455 / 68 / 16 / 539:  54%|█████▍    | 540/1000 [5:10:43<4:24:41, 34.52s/it][Succeeded / Failed / Skipped / Total] 456 / 68 / 16 / 540:  54%|█████▍    | 540/1000 [5:10:43<4:24:41, 34.52s/it][Succeeded / Failed / Skipped / Total] 456 / 68 / 16 / 540:  54%|█████▍    | 541/1000 [5:10:50<4:23:43, 34.47s/it][Succeeded / Failed / Skipped / Total] 456 / 69 / 16 / 541:  54%|█████▍    | 541/1000 [5:10:50<4:23:43, 34.47s/it][Succeeded / Failed / Skipped / Total] 456 / 69 / 16 / 541:  54%|█████▍    | 542/1000 [5:11:23<4:23:07, 34.47s/it][Succeeded / Failed / Skipped / Total] 457 / 69 / 16 / 542:  54%|█████▍    | 542/1000 [5:11:23<4:23:07, 34.47s/it][Succeeded / Failed / Skipped / Total] 457 / 69 / 16 / 542:  54%|█████▍    | 543/1000 [5:11:33<4:22:12, 34.43s/it][Succeeded / Failed / Skipped / Total] 458 / 69 / 16 / 543:  54%|█████▍    | 543/1000 [5:11:33<4:22:12, 34.43s/it][Succeeded / Failed / Skipped / Total] 458 / 69 / 16 / 543:  54%|█████▍    | 544/1000 [5:11:59<4:21:31, 34.41s/it]Wraps the given arguments if necessary . --> get gangnam --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[gangnam]] ( final T ... [[wacky]] ) { List < T > [[enrol]] ; if ( [[wacky]] != null && [[wacky]] . length == 1 && [[wacky]] [ 0 ] instanceof List ) { [[enrol]] = ( List < T > ) [[wacky]] [ 0 ] ; } else { [[enrol]] = Arrays . asList ( [[wacky]] ) ; } return [[enrol]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 537 ---------------------------------------------
Checks if the specified key is defined at the given key . --> Determines whether the group shall be contained in this group --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[ofpeople]] ( play . api . i18n . Lang [[engulf]] , String [[russet]] ) { return messages . isDefinedAt ( [[russet]] , [[engulf]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 538 ---------------------------------------------
Convert given execution context to executor . --> Execute lancaster --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[lancaster]] ( ExecutionContext ec ) { ExecutionContext prepared = ec . prepare ( ) ; if ( prepared instanceof Executor ) { return ( Executor ) prepared ; } else { return prepared :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 539 ---------------------------------------------
Get an existing file or directory . --> todo override --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[bourdieu]] ( String [[flatiron]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[flatiron]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 540 ---------------------------------------------
Returns a stream of bytes . --> clear the given callback --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[clear]] ( String callbackName ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 541 ---------------------------------------------
Returns the preferred messages for this language . --> [[[FAILED]]]

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[reelected]] ( Collection < Lang > candidates ) { Seq < Lang > cs = Scala . asScala ( candidates ) ; play . api . i18n . Messages msgs = messages . preferred ( ( Seq ) cs ) ; return new MessagesImpl ( new Lang ( msgs . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 542 ---------------------------------------------
Returns the matching method matching the given name and parameter types . --> Returns null if not found --> Socre: 1.0

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[loaded]] ( final Class < ? > cls , final String methodName , final Class < ? > ... parameterTypes ) { try { final Method method = cls . getMethod ( methodName , parameterTypes ) ; MemberUtils . setAccessibleWorkaround ( method ) ; return method ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 543 ---------------------------------------------
Creates a new JsonNode . --> Start the kinder --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[kinder]] ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( [[kinder]] -> { return ByteString . fromString ( Json . stringify ( [[kinder]] ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 544 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 69 / 16 / 544:  54%|█████▍    | 544/1000 [5:11:59<4:21:31, 34.41s/it][Succeeded / Failed / Skipped / Total] 459 / 69 / 16 / 544:  55%|█████▍    | 545/1000 [5:12:34<4:20:57, 34.41s/it][Succeeded / Failed / Skipped / Total] 460 / 69 / 16 / 545:  55%|█████▍    | 545/1000 [5:12:34<4:20:57, 34.41s/it][Succeeded / Failed / Skipped / Total] 460 / 69 / 16 / 545:  55%|█████▍    | 546/1000 [5:12:43<4:20:02, 34.37s/it][Succeeded / Failed / Skipped / Total] 461 / 69 / 16 / 546:  55%|█████▍    | 546/1000 [5:12:43<4:20:02, 34.37s/it][Succeeded / Failed / Skipped / Total] 461 / 69 / 16 / 546:  55%|█████▍    | 547/1000 [5:13:13<4:19:24, 34.36s/it][Succeeded / Failed / Skipped / Total] 462 / 69 / 16 / 547:  55%|█████▍    | 547/1000 [5:13:13<4:19:24, 34.36s/it][Succeeded / Failed / Skipped / Total] 462 / 69 / 16 / 547:  55%|█████▍    | 548/1000 [5:13:23<4:18:29, 34.31s/it][Succeeded / Failed / Skipped / Total] 463 / 69 / 16 / 548:  55%|█████▍    | 548/1000 [5:13:23<4:18:29, 34.31s/it][Succeeded / Failed / Skipped / Total] 463 / 69 / 16 / 548:  55%|█████▍    | 549/1000 [5:13:45<4:17:45, 34.29s/it][Succeeded / Failed / Skipped / Total] 464 / 69 / 16 / 549:  55%|█████▍    | 549/1000 [5:13:45<4:17:45, 34.29s/it][Succeeded / Failed / Skipped / Total] 464 / 69 / 16 / 549:  55%|█████▌    | 550/1000 [5:14:13<4:17:05, 34.28s/it][Succeeded / Failed / Skipped / Total] 465 / 69 / 16 / 550:  55%|█████▌    | 550/1000 [5:14:13<4:17:05, 34.28s/it][Succeeded / Failed / Skipped / Total] 465 / 69 / 16 / 550:  55%|█████▌    | 551/1000 [5:14:14<4:16:04, 34.22s/it][Succeeded / Failed / Skipped / Total] 466 / 69 / 16 / 551:  55%|█████▌    | 551/1000 [5:14:14<4:16:04, 34.22s/it][Succeeded / Failed / Skipped / Total] 466 / 69 / 16 / 551:  55%|█████▌    | 552/1000 [5:14:47<4:15:28, 34.22s/it]Create a default JAConfig . --> Convenience method for creating JAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String [[u1]] , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , [[u1]] ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[evaristo]] ( String n1 , String [[brane]] , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , [[brane]] ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 545 ---------------------------------------------
Adds a constraint for the given key . --> zurator for given key --> Socre: 1.0

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[mexican]] ConstraintValidator < ? , ? > > [[zur]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 546 ---------------------------------------------
Handle not found error . --> Override this to implement the default behaviour --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[montserrat]] ( RequestHeader request , String message ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( request . method ( ) , request . uri ( ) , request . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( request . method ( ) , request . uri ( ) , Some . apply ( routes . get ( ) ) , request . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 547 ---------------------------------------------
Handler for forbidden pages . --> Handler for unauthorized pages --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > onForbidden ( RequestHeader [[newbie]] , String [[mouthed]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[newbie]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 548 ---------------------------------------------
Creates a new instance of the given key . --> Create a new instance of a new instance of this class --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] [[extends]] ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[presumes]] [[tsuyoshi]] ConstraintValidator < ? , ? > > [[presumes]] newInstance ( Class < [[presumes]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 549 ---------------------------------------------
Logs internal error . --> Print error message --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[greensboro]] ( RequestHeader request , UsefulException usefulException ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , usefulException . id , request . method ( ) , request . uri ( ) ) , usefulException ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 550 ---------------------------------------------
Converts map of properties into a JAConfig object . --> Convenience method for deserializing JAConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[cryogenically]] ( Map < String , String > map ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[fom]] : map . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[fom]] . getKey ( ) , [[fom]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 551 ---------------------------------------------
Returns a configuration object with the specified name and unit name . --> Factory method for Oshima --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String name , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[oshima]] ( String name , String [[expressly]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( name , [[expressly]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 552 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 467 / 69 / 16 / 552:  55%|█████▌    | 552/1000 [5:14:47<4:15:28, 34.22s/it][Succeeded / Failed / Skipped / Total] 467 / 69 / 16 / 552:  55%|█████▌    | 553/1000 [5:15:06<4:14:42, 34.19s/it][Succeeded / Failed / Skipped / Total] 468 / 69 / 16 / 553:  55%|█████▌    | 553/1000 [5:15:06<4:14:42, 34.19s/it][Succeeded / Failed / Skipped / Total] 468 / 69 / 16 / 553:  55%|█████▌    | 554/1000 [5:15:10<4:13:43, 34.13s/it][Succeeded / Failed / Skipped / Total] 469 / 69 / 16 / 554:  55%|█████▌    | 554/1000 [5:15:10<4:13:43, 34.13s/it][Succeeded / Failed / Skipped / Total] 469 / 69 / 16 / 554:  56%|█████▌    | 555/1000 [5:15:17<4:12:48, 34.09s/it][Succeeded / Failed / Skipped / Total] 470 / 69 / 16 / 555:  56%|█████▌    | 555/1000 [5:15:17<4:12:48, 34.09s/it][Succeeded / Failed / Skipped / Total] 470 / 69 / 16 / 555:  56%|█████▌    | 556/1000 [5:15:19<4:11:47, 34.03s/it][Succeeded / Failed / Skipped / Total] 470 / 70 / 16 / 556:  56%|█████▌    | 556/1000 [5:15:19<4:11:47, 34.03s/it][Succeeded / Failed / Skipped / Total] 470 / 70 / 16 / 556:  56%|█████▌    | 557/1000 [5:15:55<4:11:16, 34.03s/it][Succeeded / Failed / Skipped / Total] 471 / 70 / 16 / 557:  56%|█████▌    | 557/1000 [5:15:55<4:11:16, 34.03s/it][Succeeded / Failed / Skipped / Total] 471 / 70 / 16 / 557:  56%|█████▌    | 558/1000 [5:16:15<4:10:30, 34.01s/it][Succeeded / Failed / Skipped / Total] 472 / 70 / 16 / 558:  56%|█████▌    | 558/1000 [5:16:15<4:10:30, 34.01s/it][Succeeded / Failed / Skipped / Total] 472 / 70 / 16 / 558:  56%|█████▌    | 559/1000 [5:17:20<4:10:21, 34.06s/it][Succeeded / Failed / Skipped / Total] 473 / 70 / 16 / 559:  56%|█████▌    | 559/1000 [5:17:20<4:10:21, 34.06s/it][Succeeded / Failed / Skipped / Total] 473 / 70 / 16 / 559:  56%|█████▌    | 560/1000 [5:17:55<4:09:47, 34.06s/it]Handles an error . --> F743 - 15 --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader [[request]] , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( [[request]] , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , usefulException ) ; default : return onDevServerError ( [[request]] , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[ferocity]] ( RequestHeader [[injured]] , Throwable exception ) { try { UsefulException usefulException = throwableToUsefulException ( exception ) ; logServerError ( [[injured]] , usefulException ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[injured]] , usefulException ) ; default : return onDevServerError ( [[injured]] , usefulException ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 553 ---------------------------------------------
Invoked when a client error occurs . --> Implementation of Huffling --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int statusCode , String [[message]] ) { if ( statusCode == 400 ) { return onBadRequest ( request , [[message]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , [[message]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , [[message]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , [[message]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[message]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[huffing]] ( RequestHeader request , int statusCode , String [[jovial]] ) { if ( statusCode == 400 ) { return onBadRequest ( request , [[jovial]] ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , [[jovial]] ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , [[jovial]] ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , [[jovial]] ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + [[jovial]] ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 554 ---------------------------------------------
Convert a throwable into a useful exception --> Filters out useful exceptions --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[fille]] ( final Throwable [[pickup]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[pickup]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 555 ---------------------------------------------
Creates a build doc handler for a directory and a given directory . --> Hook for bookmaking --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile jarFile , String base ) { return [[fromDirectoryAndJar]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[bookmaking]] ( File directory , JarFile jarFile , String base ) { return [[bookmaking]] ( directory , jarFile , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 556 ---------------------------------------------
Handle bad request . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[message]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > onBadRequest ( RequestHeader request , String [[schmuck]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( request . method ( ) , request . uri ( ) , [[schmuck]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 557 ---------------------------------------------
Default implementation for error handling . --> on failure --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > onProdServerError ( RequestHeader [[ladyland]] , UsefulException [[finsbury]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[finsbury]] , [[ladyland]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 558 ---------------------------------------------
Create an HttpEntity from content . --> Convert phojson to HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity fromContent ( Content [[content]] , String charset ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity fromContent ( Content [[phong]] , String charset ) { String body ; if ( [[phong]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 559 ---------------------------------------------
Consumes all data from the buffer . --> Shortcut method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer [[mat]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[mat]] ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[abdo]] ( Materializer [[eagleton]] ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , [[eagleton]] ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 560 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 474 / 70 / 16 / 560:  56%|█████▌    | 560/1000 [5:17:55<4:09:47, 34.06s/it][Succeeded / Failed / Skipped / Total] 474 / 70 / 16 / 560:  56%|█████▌    | 561/1000 [5:18:04<4:08:54, 34.02s/it][Succeeded / Failed / Skipped / Total] 475 / 70 / 16 / 561:  56%|█████▌    | 561/1000 [5:18:04<4:08:54, 34.02s/it][Succeeded / Failed / Skipped / Total] 475 / 70 / 16 / 561:  56%|█████▌    | 562/1000 [5:18:36<4:08:18, 34.02s/it][Succeeded / Failed / Skipped / Total] 475 / 71 / 16 / 562:  56%|█████▌    | 562/1000 [5:18:36<4:08:18, 34.02s/it][Succeeded / Failed / Skipped / Total] 475 / 71 / 16 / 562:  56%|█████▋    | 563/1000 [5:18:54<4:07:31, 33.99s/it][Succeeded / Failed / Skipped / Total] 476 / 71 / 16 / 563:  56%|█████▋    | 563/1000 [5:18:54<4:07:31, 33.99s/it][Succeeded / Failed / Skipped / Total] 476 / 71 / 16 / 563:  56%|█████▋    | 564/1000 [5:18:57<4:06:34, 33.93s/it][Succeeded / Failed / Skipped / Total] 477 / 71 / 16 / 564:  56%|█████▋    | 564/1000 [5:18:57<4:06:34, 33.93s/it][Succeeded / Failed / Skipped / Total] 477 / 71 / 16 / 564:  56%|█████▋    | 565/1000 [5:19:06<4:05:41, 33.89s/it][Succeeded / Failed / Skipped / Total] 478 / 71 / 16 / 565:  56%|█████▋    | 565/1000 [5:19:06<4:05:41, 33.89s/it][Succeeded / Failed / Skipped / Total] 478 / 71 / 16 / 565:  57%|█████▋    | 566/1000 [5:19:06<4:04:41, 33.83s/it][Succeeded / Failed / Skipped / Total] 478 / 71 / 17 / 566:  57%|█████▋    | 566/1000 [5:19:06<4:04:41, 33.83s/it][Succeeded / Failed / Skipped / Total] 478 / 71 / 17 / 566:  57%|█████▋    | 567/1000 [5:19:17<4:03:49, 33.79s/it][Succeeded / Failed / Skipped / Total] 479 / 71 / 17 / 567:  57%|█████▋    | 567/1000 [5:19:17<4:03:49, 33.79s/it][Succeeded / Failed / Skipped / Total] 479 / 71 / 17 / 567:  57%|█████▋    | 568/1000 [5:19:25<4:02:56, 33.74s/it][Succeeded / Failed / Skipped / Total] 480 / 71 / 17 / 568:  57%|█████▋    | 568/1000 [5:19:25<4:02:56, 33.74s/it][Succeeded / Failed / Skipped / Total] 480 / 71 / 17 / 568:  57%|█████▋    | 569/1000 [5:19:41<4:02:09, 33.71s/it][Succeeded / Failed / Skipped / Total] 481 / 71 / 17 / 569:  57%|█████▋    | 569/1000 [5:19:41<4:02:09, 33.71s/it][Succeeded / Failed / Skipped / Total] 481 / 71 / 17 / 569:  57%|█████▋    | 570/1000 [5:19:44<4:01:12, 33.66s/it][Succeeded / Failed / Skipped / Total] 482 / 71 / 17 / 570:  57%|█████▋    | 570/1000 [5:19:44<4:01:12, 33.66s/it][Succeeded / Failed / Skipped / Total] 482 / 71 / 17 / 570:  57%|█████▋    | 571/1000 [5:19:50<4:00:17, 33.61s/it]Creates a chunked entity based on the provided data . --> Converts data into HttpEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[clarita]] ( Source < ByteString , ? > data , Optional < String > contentType ) { return new Chunked ( data . map ( HttpChunk . Chunk :: new ) , contentType ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 561 ---------------------------------------------
Creates a JSON response . --> Convenience method to retries --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode content ) { return [[status]] ( [[status]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[café]] ( int status , JsonNode content ) { return [[café]] ( [[café]] , content , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 562 ---------------------------------------------
Handler for error rendering . --> [[[FAILED]]]

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[rattlesnakes]] ( RequestHeader request , UsefulException exception ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , exception , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 563 ---------------------------------------------
Create an instance from a string . --> Creates a HTTP HEAD request --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromString]] ( String [[content]] , String charset ) { return new Strict ( ByteString . fromString ( [[content]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity [[buzzard]] ( String [[dolly]] , String charset ) { return new Strict ( ByteString . fromString ( [[dolly]] , charset ) , Optional . of ( "text/plain; charset=" + charset ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a HTTP status message . --> create HTTP response --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result status ( int status , byte [ ] [[clarita]] ) { if ( [[clarita]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( status , new HttpEntity . Strict ( ByteString . fromArray ( [[clarita]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 565 ---------------------------------------------
Create a status message with the given content . --> Main method for testing --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , File content ) { return [[status]] ( [[status]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[nfl]] ( int status , File content ) { return [[nfl]] ( [[nfl]] , content , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 566 ---------------------------------------------
Finds a user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 567 ---------------------------------------------
Create a new documentation handler for the given directory directory . --> Shortcut implementation --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository repo = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[bamberg]] ( File [[opportunists]] ) { FileRepository repo = new FilesystemRepository ( [[opportunists]] ) ; return new DocumentationHandler ( repo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 568 ---------------------------------------------
Returns a unique duplicate of this call . --> shader method --> Socre: 1.0

[[[[Adv]]]]: public Call [[unique]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call [[schiller]] ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 569 ---------------------------------------------
Sends a content response to a JSON response . --> Send an error message --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , JsonNode [[content]] , JsonEncoding encoding ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( [[content]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result status ( int status , JsonNode [[anesthesiology]] , JsonEncoding encoding ) { if ( [[anesthesiology]] == null ) { throw new NullPointerException ( "Null content" ) ; } return status ( status ) . sendJson ( [[anesthesiology]] , encoding ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 570 ---------------------------------------------
Sends a status message to the given stream . --> Send abruzzo response --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int status , InputStream [[content]] , long contentLength ) { return status ( status ) . sendInputStream ( [[content]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int status , InputStream [[abruzzo]] , long contentLength ) { return status ( status ) . sendInputStream ( [[abruzzo]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 571 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 483 / 71 / 17 / 571:  57%|█████▋    | 571/1000 [5:19:50<4:00:17, 33.61s/it][Succeeded / Failed / Skipped / Total] 483 / 71 / 17 / 571:  57%|█████▋    | 572/1000 [5:19:53<3:59:21, 33.56s/it][Succeeded / Failed / Skipped / Total] 484 / 71 / 17 / 572:  57%|█████▋    | 572/1000 [5:19:53<3:59:21, 33.56s/it][Succeeded / Failed / Skipped / Total] 484 / 71 / 17 / 572:  57%|█████▋    | 573/1000 [5:20:36<3:58:55, 33.57s/it][Succeeded / Failed / Skipped / Total] 485 / 71 / 17 / 573:  57%|█████▋    | 573/1000 [5:20:36<3:58:55, 33.57s/it][Succeeded / Failed / Skipped / Total] 485 / 71 / 17 / 573:  57%|█████▋    | 574/1000 [5:20:50<3:58:06, 33.54s/it][Succeeded / Failed / Skipped / Total] 486 / 71 / 17 / 574:  57%|█████▋    | 574/1000 [5:20:50<3:58:06, 33.54s/it][Succeeded / Failed / Skipped / Total] 486 / 71 / 17 / 574:  57%|█████▊    | 575/1000 [5:21:02<3:57:17, 33.50s/it][Succeeded / Failed / Skipped / Total] 487 / 71 / 17 / 575:  57%|█████▊    | 575/1000 [5:21:02<3:57:17, 33.50s/it][Succeeded / Failed / Skipped / Total] 487 / 71 / 17 / 575:  58%|█████▊    | 576/1000 [5:21:08<3:56:23, 33.45s/it][Succeeded / Failed / Skipped / Total] 488 / 71 / 17 / 576:  58%|█████▊    | 576/1000 [5:21:08<3:56:23, 33.45s/it][Succeeded / Failed / Skipped / Total] 488 / 71 / 17 / 576:  58%|█████▊    | 577/1000 [5:21:12<3:55:28, 33.40s/it][Succeeded / Failed / Skipped / Total] 489 / 71 / 17 / 577:  58%|█████▊    | 577/1000 [5:21:12<3:55:28, 33.40s/it][Succeeded / Failed / Skipped / Total] 489 / 71 / 17 / 577:  58%|█████▊    | 578/1000 [5:21:22<3:54:38, 33.36s/it][Succeeded / Failed / Skipped / Total] 490 / 71 / 17 / 578:  58%|█████▊    | 578/1000 [5:21:22<3:54:38, 33.36s/it][Succeeded / Failed / Skipped / Total] 490 / 71 / 17 / 578:  58%|█████▊    | 579/1000 [5:21:26<3:53:43, 33.31s/it][Succeeded / Failed / Skipped / Total] 491 / 71 / 17 / 579:  58%|█████▊    | 579/1000 [5:21:26<3:53:43, 33.31s/it][Succeeded / Failed / Skipped / Total] 491 / 71 / 17 / 579:  58%|█████▊    | 580/1000 [5:21:41<3:52:56, 33.28s/it]Returns the absolute URL of the given request . --> Get the rancho for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request request ) { return [[absoluteURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[rancho]] ( Http . Request request ) { return [[rancho]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 572 ---------------------------------------------
Returns the web socket URL for the given request . --> Converter for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[cherchez]] ( Http . Request request ) { return [[cherchez]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 573 ---------------------------------------------
Returns a connection function that applies the given connection function . --> used by ConnectionFunction --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return block . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > block ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[wont]] ) { try { return block . call ( [[wont]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 574 ---------------------------------------------
Returns a new call with the specified fragment . --> Calls cocks --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[cocksucking]] ( String [[zoya]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[zoya]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 575 ---------------------------------------------
Selects the preferred language of the specified collection . --> Methode d une lons --> Socre: 1.0

[[[[Adv]]]]: public Lang [[preferred]] ( Collection < Lang > [[candidates]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[candidates]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .

[[[[Adv]]]]: public Lang [[demoiselle]] ( Collection < Lang > [[rams]] ) { return new Lang ( langs . preferred ( ( scala . collection . immutable . Seq ) Scala . asScala ( [[rams]] ) . toSeq ( ) ) ) ; }
[[[[Nl]]]]: Select a preferred language given the list of candidates .
--------------------------------------------- Result 576 ---------------------------------------------
To json node . --> Ridding data --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[ridding]] ( final Object data ) { try { return mapper ( ) . valueToTree ( data ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 577 ---------------------------------------------
Deserializes the given JsonNode to a java object . --> Expertied from json --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[acquainted]] > [[acquainted]] fromJson ( JsonNode json , Class < [[acquainted]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 578 ---------------------------------------------
Parse a JsonNode from an input stream . --> zips the given input stream --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[zigi]] ( java . io . InputStream src ) { try { return mapper ( ) . readTree ( src ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a InputStream representing a json and return it as a JsonNode .
--------------------------------------------- Result 579 ---------------------------------------------
Create a documentation handler for a given jar file . --> Wrapper for flashbulb --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository [[repo]] = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[flashbulbs]] ( JarFile [[mandira]] , String [[ak]] ) { FileRepository [[shorthand]] = new JarRepository ( [[mandira]] , Option . apply ( [[ak]] ) ) ; return new DocumentationHandler ( [[shorthand]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 580 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 491 / 72 / 17 / 580:  58%|█████▊    | 580/1000 [5:21:41<3:52:56, 33.28s/it][Succeeded / Failed / Skipped / Total] 491 / 72 / 17 / 580:  58%|█████▊    | 581/1000 [5:21:44<3:52:02, 33.23s/it][Succeeded / Failed / Skipped / Total] 492 / 72 / 17 / 581:  58%|█████▊    | 581/1000 [5:21:44<3:52:02, 33.23s/it][Succeeded / Failed / Skipped / Total] 492 / 72 / 17 / 581:  58%|█████▊    | 582/1000 [5:22:09<3:51:22, 33.21s/it][Succeeded / Failed / Skipped / Total] 493 / 72 / 17 / 582:  58%|█████▊    | 582/1000 [5:22:09<3:51:22, 33.21s/it][Succeeded / Failed / Skipped / Total] 493 / 72 / 17 / 582:  58%|█████▊    | 583/1000 [5:22:31<3:50:41, 33.19s/it][Succeeded / Failed / Skipped / Total] 494 / 72 / 17 / 583:  58%|█████▊    | 583/1000 [5:22:31<3:50:41, 33.19s/it][Succeeded / Failed / Skipped / Total] 494 / 72 / 17 / 583:  58%|█████▊    | 584/1000 [5:23:06<3:50:09, 33.20s/it][Succeeded / Failed / Skipped / Total] 495 / 72 / 17 / 584:  58%|█████▊    | 584/1000 [5:23:06<3:50:09, 33.20s/it][Succeeded / Failed / Skipped / Total] 495 / 72 / 17 / 584:  58%|█████▊    | 585/1000 [5:23:14<3:49:18, 33.15s/it][Succeeded / Failed / Skipped / Total] 496 / 72 / 17 / 585:  58%|█████▊    | 585/1000 [5:23:14<3:49:18, 33.15s/it][Succeeded / Failed / Skipped / Total] 496 / 72 / 17 / 585:  59%|█████▊    | 586/1000 [5:23:27<3:48:31, 33.12s/it][Succeeded / Failed / Skipped / Total] 497 / 72 / 17 / 586:  59%|█████▊    | 586/1000 [5:23:27<3:48:31, 33.12s/it][Succeeded / Failed / Skipped / Total] 497 / 72 / 17 / 586:  59%|█████▊    | 587/1000 [5:23:56<3:47:55, 33.11s/it]Creates a BuildDocHandler from a list of files . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .

[[[[Adv]]]]: public static BuildDocHandler fromResources ( File [ ] files , String [ ] baseDirs ) throws IOException { assert ( files . length == baseDirs . length ) ; FileRepository [ ] repositories = new FileRepository [ files . length ] ; List < JarFile > jarFiles = new ArrayList <> ( ) ; for ( int i = 0 ; i < files . length ; i ++ ) { File file = files [ i ] ; String baseDir = baseDirs [ i ] ; if ( file . isDirectory ( ) ) { repositories [ i ] = new FilesystemRepository ( file ) ; } else {
[[[[Nl]]]]: Create a BuildDocHandler that serves documentation from the given files which could either be directories or jar files . The baseDir array must be the same length as the files array and the corresponding entry in there for jar files is used as a base directory to use resources from in the jar .
--------------------------------------------- Result 581 ---------------------------------------------
Parse the given string into a JsonNode . --> Parse gorg --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode parse ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode parse ( String [[gorgonzola]] ) { try { return mapper ( ) . readTree ( [[gorgonzola]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 582 ---------------------------------------------
Returns a list of constraints which match the given constraints . --> Determines which constraint should be displayed on Hadoop --> Socre: 1.0

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > [[constraints]] ) { return [[constraints]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .

[[[[Adv]]]]: public static List < Tuple < String , List < Object > > > displayableConstraint ( Set < ConstraintDescriptor < ? > > [[huo]] ) { return [[huo]] . parallelStream ( ) . filter ( c -> c . getAnnotation ( ) . annotationType ( ) . isAnnotationPresent ( Display . class ) ) . map ( c -> displayableConstraint ( c ) ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Converts a set of constraints to human - readable values . Does not guarantee the order of the returned constraints .
--------------------------------------------- Result 583 ---------------------------------------------
Creates a new Server instance with the given parameters . --> Static factory method --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode mode , int [[port]] , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( [[port]] ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[arranger]] ( Mode mode , int [[electronic]] , Function < BuiltInComponents , Router > block ) { return new Builder ( ) . mode ( mode ) . http ( [[electronic]] ) . build ( block ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 584 ---------------------------------------------
Relative path relative to startPath --> Example of chor --> Socre: 1.0

[[[[Adv]]]]: public static String [[relative]] ( String startPath , String [[targetPath]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .

[[[[Adv]]]]: public static String [[choronzon]] ( String startPath , String [[hangzhou]] ) {
[[[[Nl]]]]: Create a path to targetPath that s relative to the given startPath .
--------------------------------------------- Result 585 ---------------------------------------------
Parse cron expression --> Calculate coquette --> Socre: 1.0

[[[[Adv]]]]: public static Date [[parseCRONExpression]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .

[[[[Adv]]]]: public static Date [[coquette]] ( String cron ) { try { return new CronExpression ( cron ) . getNextValidTimeAfter ( new Date ( ) ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Parses a CRON expression .
--------------------------------------------- Result 586 ---------------------------------------------
Get the next interval --> Calculate cron interval --> Socre: 1.0

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[date]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[date]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .

[[[[Adv]]]]: public static long cronInterval ( String cron , Date [[caswell]] ) { try { return new CronExpression ( cron ) . getNextInterval ( [[caswell]] ) ; } catch ( Exception e ) { throw new IllegalArgumentException ( "Invalid CRON pattern : " + cron , e ) ; } }
[[[[Nl]]]]: Compute the number of milliseconds between the next valid date and the one after .
--------------------------------------------- Result 587 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 498 / 72 / 17 / 587:  59%|█████▊    | 587/1000 [5:23:56<3:47:55, 33.11s/it][Succeeded / Failed / Skipped / Total] 498 / 72 / 17 / 587:  59%|█████▉    | 588/1000 [5:24:21<3:47:16, 33.10s/it][Succeeded / Failed / Skipped / Total] 499 / 72 / 17 / 588:  59%|█████▉    | 588/1000 [5:24:21<3:47:16, 33.10s/it][Succeeded / Failed / Skipped / Total] 499 / 72 / 17 / 588:  59%|█████▉    | 589/1000 [5:24:32<3:46:27, 33.06s/it][Succeeded / Failed / Skipped / Total] 500 / 72 / 17 / 589:  59%|█████▉    | 589/1000 [5:24:32<3:46:27, 33.06s/it][Succeeded / Failed / Skipped / Total] 500 / 72 / 17 / 589:  59%|█████▉    | 590/1000 [5:24:42<3:45:38, 33.02s/it][Succeeded / Failed / Skipped / Total] 501 / 72 / 17 / 590:  59%|█████▉    | 590/1000 [5:24:42<3:45:38, 33.02s/it][Succeeded / Failed / Skipped / Total] 501 / 72 / 17 / 590:  59%|█████▉    | 591/1000 [5:24:51<3:44:49, 32.98s/it][Succeeded / Failed / Skipped / Total] 502 / 72 / 17 / 591:  59%|█████▉    | 591/1000 [5:24:51<3:44:49, 32.98s/it][Succeeded / Failed / Skipped / Total] 502 / 72 / 17 / 591:  59%|█████▉    | 592/1000 [5:25:00<3:43:59, 32.94s/it][Succeeded / Failed / Skipped / Total] 502 / 73 / 17 / 592:  59%|█████▉    | 592/1000 [5:25:00<3:43:59, 32.94s/it][Succeeded / Failed / Skipped / Total] 502 / 73 / 17 / 592:  59%|█████▉    | 593/1000 [5:25:34<3:43:27, 32.94s/it][Succeeded / Failed / Skipped / Total] 503 / 73 / 17 / 593:  59%|█████▉    | 593/1000 [5:25:34<3:43:27, 32.94s/it][Succeeded / Failed / Skipped / Total] 503 / 73 / 17 / 593:  59%|█████▉    | 594/1000 [5:26:02<3:42:51, 32.93s/it][Succeeded / Failed / Skipped / Total] 504 / 73 / 17 / 594:  59%|█████▉    | 594/1000 [5:26:02<3:42:51, 32.93s/it][Succeeded / Failed / Skipped / Total] 504 / 73 / 17 / 594:  60%|█████▉    | 595/1000 [5:26:06<3:41:58, 32.88s/it]Returns the canonical form of the given URL . --> Returns the host of the given url --> Socre: 1.0

[[[[Adv]]]]: public static String [[canonical]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[canonical]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[canonical]] . empty ( ) && [[canonical]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[canonical]] . push ( comp ) ; else [[canonical]] . pop ( ) ; } String [[prefixSep]] = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[prefixSep]] + [[canonical]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .

[[[[Adv]]]]: public static String [[adress]] ( String url ) { String [ ] urlPath = toSegments ( url ) ; Stack < String > [[adress]] = new Stack <> ( ) ; for ( String comp : urlPath ) { if ( comp . isEmpty ( ) || comp . equals ( CURRENT_DIR ) ) continue ; if ( ! comp . equals ( PARENT_DIR ) || ( ! [[adress]] . empty ( ) && [[adress]] . peek ( ) . equals ( PARENT_DIR ) ) ) [[adress]] . push ( comp ) ; else [[adress]] . pop ( ) ; } String [[henrique]] = url . startsWith ( SEPARATOR ) ? SEPARATOR : "" ; String trailingSep = url . endsWith ( SEPARATOR ) ? SEPARATOR : "" ; return [[henrique]] + [[adress]] . stream ( ) . collect ( Collectors . joining ( SEPARATOR ) ) + trailingSep ; }
[[[[Nl]]]]: Create a canonical path that does not contain parent directories current directories or superfluous directory separators .
--------------------------------------------- Result 588 ---------------------------------------------
Perform a timeout after the given amount of time . --> timing timeout --> Socre: 1.0

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > [[stage]] , final long amount , final TimeUnit [[unit]] ) { requireNonNull ( [[stage]] , "Null stage" ) ; requireNonNull ( [[unit]] , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , [[unit]] ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[stage]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .

[[[[Adv]]]]: @ Override public < A > CompletionStage < A > timeout ( final CompletionStage < A > [[dissatisfaction]] , final long amount , final TimeUnit [[maricón]] ) { requireNonNull ( [[dissatisfaction]] , "Null stage" ) ; requireNonNull ( [[maricón]] , "Null unit" ) ; FiniteDuration duration = FiniteDuration . apply ( amount , [[maricón]] ) ; return toJava ( delegate . timeout ( duration , Scala . asScalaWithFuture ( ( ) -> [[dissatisfaction]] ) ) ) ; }
[[[[Nl]]]]: Creates a CompletionStage that returns either the input stage or a futures .
--------------------------------------------- Result 589 ---------------------------------------------
Display a request . --> Webdo method --> Socre: 1.0

[[[[Adv]]]]: public static Result TODO ( Request [[request]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[request]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .

[[[[Adv]]]]: public static Result TODO ( Request [[beater]] ) { return status ( NOT_IMPLEMENTED , views . html . defaultpages . todo . render ( [[beater]] . asScala ( ) ) ) ; }
[[[[Nl]]]]: Generates a 501 NOT_IMPLEMENTED simple result .
--------------------------------------------- Result 590 ---------------------------------------------
Map a key - value pair to the session --> Use this method to help debugging --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[session]] ( String key , String value ) { [[session]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .

[[[[Adv]]]]: @ Deprecated public static void [[combat]] ( String key , String value ) { [[combat]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the current session .
--------------------------------------------- Result 591 ---------------------------------------------
Sets a flash value to the flash object --> Support for snobriers --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static void [[flash]] ( String key , String value ) { [[flash]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .

[[[[Adv]]]]: @ Deprecated public static void [[snobbery]] ( String key , String value ) { [[snobbery]] ( ) . put ( key , value ) ; }
[[[[Nl]]]]: Puts a new value into the flash scope .
--------------------------------------------- Result 592 ---------------------------------------------
Creates a documentation handler for a given directory and a given directory . --> [[[FAILED]]]

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile [[jarFile]] , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository [[jarRepo]] = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , [[jarRepo]] } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , [[jarRepo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler fromDirectoryAndJar ( File directory , JarFile [[infuse]] , String base , boolean fallbackToJar ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository [[architectural]] = new JarRepository ( [[infuse]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( fallbackToJar ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , [[architectural]] } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , [[architectural]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 593 ---------------------------------------------
Create an ahc client . --> Create an AwsClient object --> Socre: 1.0

[[[[Adv]]]]: public static AhcWSClient [[create]] ( AhcWSClientConfig config , AhcHttpCache cache , Materializer [[materializer]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , [[materializer]] ) ; return new AhcWSClient ( client , [[materializer]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .

[[[[Adv]]]]: public static AhcWSClient [[astray]] ( AhcWSClientConfig config , AhcHttpCache cache , Materializer [[purnell]] ) { final StandaloneAhcWSClient client = StandaloneAhcWSClient . create ( config , cache , [[purnell]] ) ; return new AhcWSClient ( client , [[purnell]] ) ; }
[[[[Nl]]]]: Creates WS client manually from configuration internally creating a new instance of AsyncHttpClient and managing its own thread pool .
--------------------------------------------- Result 594 ---------------------------------------------
Converts this binding to the specified implementation . --> Convenience method for creating a bean --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .

[[[[Adv]]]]: public Binding < T > [[coworker]] ( final Class < ? extends T > implementation ) { return underlying . to ( implementation ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given implementation class .
[Succeeded / Failed / Skipped / Total] 504 / 74 / 17 / 595:  60%|█████▉    | 595/1000 [5:26:06<3:41:58, 32.88s/it][Succeeded / Failed / Skipped / Total] 504 / 74 / 17 / 595:  60%|█████▉    | 596/1000 [5:26:22<3:41:14, 32.86s/it][Succeeded / Failed / Skipped / Total] 505 / 74 / 17 / 596:  60%|█████▉    | 596/1000 [5:26:22<3:41:14, 32.86s/it][Succeeded / Failed / Skipped / Total] 505 / 74 / 17 / 596:  60%|█████▉    | 597/1000 [5:26:23<3:40:19, 32.80s/it][Succeeded / Failed / Skipped / Total] 505 / 75 / 17 / 597:  60%|█████▉    | 597/1000 [5:26:23<3:40:19, 32.80s/it][Succeeded / Failed / Skipped / Total] 505 / 75 / 17 / 597:  60%|█████▉    | 598/1000 [5:27:08<3:39:55, 32.82s/it][Succeeded / Failed / Skipped / Total] 506 / 75 / 17 / 598:  60%|█████▉    | 598/1000 [5:27:08<3:39:55, 32.82s/it][Succeeded / Failed / Skipped / Total] 506 / 75 / 17 / 598:  60%|█████▉    | 599/1000 [5:27:12<3:39:03, 32.78s/it][Succeeded / Failed / Skipped / Total] 506 / 76 / 17 / 599:  60%|█████▉    | 599/1000 [5:27:12<3:39:03, 32.78s/it][Succeeded / Failed / Skipped / Total] 506 / 76 / 17 / 599:  60%|██████    | 600/1000 [5:27:34<3:38:23, 32.76s/it][Succeeded / Failed / Skipped / Total] 507 / 76 / 17 / 600:  60%|██████    | 600/1000 [5:27:34<3:38:23, 32.76s/it][Succeeded / Failed / Skipped / Total] 507 / 76 / 17 / 600:  60%|██████    | 601/1000 [5:27:47<3:37:37, 32.72s/it][Succeeded / Failed / Skipped / Total] 508 / 76 / 17 / 601:  60%|██████    | 601/1000 [5:27:47<3:37:37, 32.72s/it][Succeeded / Failed / Skipped / Total] 508 / 76 / 17 / 601:  60%|██████    | 602/1000 [5:28:29<3:37:10, 32.74s/it][Succeeded / Failed / Skipped / Total] 509 / 76 / 17 / 602:  60%|██████    | 602/1000 [5:28:29<3:37:10, 32.74s/it][Succeeded / Failed / Skipped / Total] 509 / 76 / 17 / 602:  60%|██████    | 603/1000 [5:28:37<3:36:21, 32.70s/it][Succeeded / Failed / Skipped / Total] 510 / 76 / 17 / 603:  60%|██████    | 603/1000 [5:28:37<3:36:21, 32.70s/it][Succeeded / Failed / Skipped / Total] 510 / 76 / 17 / 603:  60%|██████    | 604/1000 [5:29:08<3:35:47, 32.70s/it][Succeeded / Failed / Skipped / Total] 511 / 76 / 17 / 604:  60%|██████    | 604/1000 [5:29:08<3:35:47, 32.70s/it][Succeeded / Failed / Skipped / Total] 511 / 76 / 17 / 604:  60%|██████    | 605/1000 [5:29:12<3:34:56, 32.65s/it]--------------------------------------------- Result 595 ---------------------------------------------
Qualify binding key . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .

[[[[Adv]]]]: public < A [[maître]] Annotation > BindingKey < T > qualifiedWith ( final A instance ) { return underlying . qualifiedWith ( instance ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given instance of an annotation .
--------------------------------------------- Result 596 ---------------------------------------------
Converts this binding into a Java binding . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public < A [[extends]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .

[[[[Adv]]]]: public < A [[kichi]] T > Binding < T > to ( final Supplier < A > instance ) { return underlying . to ( new FromJavaSupplier <> ( instance ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given instance .
--------------------------------------------- Result 597 ---------------------------------------------
Returns the binding key of this binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .

[[[[Adv]]]]: public < A [[dujour]] Annotation > BindingKey < T > qualifiedWith ( final Class < A > annotation ) { return underlying . qualifiedWith ( annotation ) . asJava ( ) ; }
[[[[Nl]]]]: Qualify this binding key with the given annotation .
--------------------------------------------- Result 598 ---------------------------------------------
Returns a new GuiceApplication initialized with the given context . --> Kill this application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[builder]] ( ApplicationLoader . Context [[context]] ) { return initialBuilder . in ( [[context]] . environment ( ) ) . loadConfig ( [[context]] . initialConfig ( ) ) . overrides ( overrides ( [[context]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .

[[[[Adv]]]]: public GuiceApplicationBuilder [[killah]] ( ApplicationLoader . Context [[handfuls]] ) { return initialBuilder . in ( [[handfuls]] . environment ( ) ) . loadConfig ( [[handfuls]] . initialConfig ( ) ) . overrides ( overrides ( [[handfuls]] ) ) ; }
[[[[Nl]]]]: Construct a builder to use for loading the given context .
--------------------------------------------- Result 599 ---------------------------------------------
Returns a function that invokes a connection function . --> [[[FAILED]]]

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[connectionFunction]] ( final ConnectionRunnable [[block]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[connection]] ) { try { [[block]] . run ( [[connection]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .

[[[[Adv]]]]: AbstractFunction1 < Connection , BoxedUnit > [[nested]] ( final ConnectionRunnable [[kargil]] ) { return new AbstractFunction1 < Connection , BoxedUnit > ( ) { public BoxedUnit apply ( Connection [[buildings]] ) { try { [[kargil]] . run ( [[buildings]] ) ; return BoxedUnit . UNIT ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection runnable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionRunnable .
--------------------------------------------- Result 600 ---------------------------------------------
Displays the given constraint . --> Zoom metric name attributes --> Socre: 1.0

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[displayableConstraint]] ( ConstraintDescriptor < ? > [[constraint]] ) { final Display [[displayAnnotation]] = [[constraint]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[displayAnnotation]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[displayAnnotation]] . attributes ( ) ) . map ( attr -> [[constraint]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .

[[[[Adv]]]]: public static Tuple < String , List < Object > > [[ozaki]] ( ConstraintDescriptor < ? > [[drumbeat]] ) { final Display [[satnam]] = [[drumbeat]] . getAnnotation ( ) . annotationType ( ) . getAnnotation ( Display . class ) ; return Tuple ( [[satnam]] . name ( ) , Collections . unmodifiableList ( Stream . of ( [[satnam]] . attributes ( ) ) . map ( attr -> [[drumbeat]] . getAttributes ( ) . get ( attr ) ) . collect ( Collectors . toList ( ) ) ) ) ; }
[[[[Nl]]]]: Converts a constraint to a human - readable value .
--------------------------------------------- Result 601 ---------------------------------------------
Converts this binding to the given provider . --> Nacionalization method --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final Provider < ? extends T > [[provider]] ) { return underlying . to ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .

[[[[Adv]]]]: public Binding < T > [[nacional]] ( final Provider < ? extends T > [[speedin]] ) { return underlying . to ( [[speedin]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider instance .
--------------------------------------------- Result 602 ---------------------------------------------
Converts the binding to a Java binding . --> Speed - 1 --> Socre: 1.0

[[[[Adv]]]]: public Binding < T > [[to]] ( final BindingKey < ? extends T > [[key]] ) { return underlying . to ( [[key]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .

[[[[Adv]]]]: public Binding < T > [[speedin]] ( final BindingKey < ? extends T > [[accomplishes]] ) { return underlying . to ( [[accomplishes]] . asScala ( ) ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to another binding key .
--------------------------------------------- Result 603 ---------------------------------------------
Cleans all executions . --> Removes all simulation executions --> Socre: 1.0

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String [[schema]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , [[schema]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .

[[[[Adv]]]]: public static void cleanupEvolutions ( Database database , boolean autocommit , String [[sackcloth]] ) { DatabaseEvolutions evolutions = new DatabaseEvolutions ( database . asScala ( ) , [[sackcloth]] ) ; evolutions . evolve ( evolutions . resetScripts ( ) , autocommit ) ; }
[[[[Nl]]]]: Cleanup evolutions for the given database .
--------------------------------------------- Result 604 ---------------------------------------------
Converts the underlying provider to a Java provider . --> convenience method --> Socre: 1.0

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[toProvider]] ( final Class < P > [[provider]] ) { return underlying . toProvider ( [[provider]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .

[[[[Adv]]]]: public < P extends Provider < ? extends T > > Binding < T > [[gunga]] ( final Class < P > [[parlour]] ) { return underlying . toProvider ( [[parlour]] ) . asJava ( ) ; }
[[[[Nl]]]]: Bind this binding key to the given provider class .
--------------------------------------------- Result 605 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 512 / 76 / 17 / 605:  60%|██████    | 605/1000 [5:29:12<3:34:56, 32.65s/it][Succeeded / Failed / Skipped / Total] 512 / 76 / 17 / 605:  61%|██████    | 606/1000 [5:29:45<3:34:23, 32.65s/it][Succeeded / Failed / Skipped / Total] 513 / 76 / 17 / 606:  61%|██████    | 606/1000 [5:29:45<3:34:23, 32.65s/it][Succeeded / Failed / Skipped / Total] 513 / 76 / 17 / 606:  61%|██████    | 607/1000 [5:29:54<3:33:35, 32.61s/it][Succeeded / Failed / Skipped / Total] 514 / 76 / 17 / 607:  61%|██████    | 607/1000 [5:29:54<3:33:35, 32.61s/it][Succeeded / Failed / Skipped / Total] 514 / 76 / 17 / 607:  61%|██████    | 608/1000 [5:30:03<3:32:48, 32.57s/it][Succeeded / Failed / Skipped / Total] 515 / 76 / 17 / 608:  61%|██████    | 608/1000 [5:30:03<3:32:48, 32.57s/it][Succeeded / Failed / Skipped / Total] 515 / 76 / 17 / 608:  61%|██████    | 609/1000 [5:30:06<3:31:56, 32.52s/it][Succeeded / Failed / Skipped / Total] 516 / 76 / 17 / 609:  61%|██████    | 609/1000 [5:30:06<3:31:56, 32.52s/it][Succeeded / Failed / Skipped / Total] 516 / 76 / 17 / 609:  61%|██████    | 610/1000 [5:30:17<3:31:09, 32.49s/it][Succeeded / Failed / Skipped / Total] 517 / 76 / 17 / 610:  61%|██████    | 610/1000 [5:30:17<3:31:09, 32.49s/it][Succeeded / Failed / Skipped / Total] 517 / 76 / 17 / 610:  61%|██████    | 611/1000 [5:30:48<3:30:36, 32.49s/it][Succeeded / Failed / Skipped / Total] 517 / 77 / 17 / 611:  61%|██████    | 611/1000 [5:30:48<3:30:36, 32.49s/it][Succeeded / Failed / Skipped / Total] 517 / 77 / 17 / 611:  61%|██████    | 612/1000 [5:31:30<3:30:10, 32.50s/it][Succeeded / Failed / Skipped / Total] 518 / 77 / 17 / 612:  61%|██████    | 612/1000 [5:31:30<3:30:10, 32.50s/it][Succeeded / Failed / Skipped / Total] 518 / 77 / 17 / 612:  61%|██████▏   | 613/1000 [5:31:58<3:29:35, 32.49s/it]Checks if the given classes are assignable to the given classes array . --> todo test --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAssignable]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[False]]" != "[[False]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[i]] = 0 ; [[i]] < classArray . length ; [[i]] ++ ) { if ( [[isAssignable]] ( classArray [ [[i]] ] , toClassArray [ [[i]] ] , autoboxing ) == "[[False]]" != "[[False]]" ) { return "[[False]]" != "[[False]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .

[[[[Adv]]]]: public static boolean [[friedrich]] ( Class < ? > [ ] classArray , Class < ? > [ ] toClassArray , boolean autoboxing ) { if ( arrayGetLength ( classArray ) != arrayGetLength ( toClassArray ) ) { return "[[Cuzco]]" != "[[Cuzco]]" ; } if ( classArray == null ) { classArray = EMPTY_CLASS_ARRAY ; } if ( toClassArray == null ) { toClassArray = EMPTY_CLASS_ARRAY ; } for ( int [[crucifixion]] = 0 ; [[crucifixion]] < classArray . length ; [[crucifixion]] ++ ) { if ( [[friedrich]] ( classArray [ [[crucifixion]] ] , toClassArray [ [[crucifixion]] ] , autoboxing ) == "[[Cuzco]]" != "[[Cuzco]]" ) { return "[[Cuzco]]" != "[[Cuzco]]" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Checks if an array of Classes can be assigned to another array of Classes .
--------------------------------------------- Result 606 ---------------------------------------------
Loads a custom module loader function . --> Start a holiday --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[withModuleLoader]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[holiday]] ( BiFunction < Environment , Config , List < GuiceableModule > > loader ) { return newBuilder ( delegate . load ( func ( ( play . api . Environment env , play . api . Configuration conf ) -> Scala . toSeq ( loader . apply ( new Environment ( env ) , conf . underlying ( ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the module loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 607 ---------------------------------------------
Loads the application with the given modules . --> Add a terrace --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( com . google . inject . Module ... modules ) { return [[load]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[terrace]] ( com . google . inject . Module ... modules ) { return [[terrace]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Guice modules .
--------------------------------------------- Result 608 ---------------------------------------------
Loads the application with the given modules . --> Set a pooper --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Module ... modules ) { return [[load]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[pooper]] ( play . api . inject . Module ... modules ) { return [[pooper]] ( Guiceable . modules ( modules ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play modules .
--------------------------------------------- Result 609 ---------------------------------------------
Returns a list of available languages . --> Retrieves all languages --> Socre: 1.0

[[[[Adv]]]]: public static List < Lang > [[availables]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[availableLangs]] = Scala . asJava ( langs . availables ( ) ) ; return [[availableLangs]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .

[[[[Adv]]]]: public static List < Lang > [[ozaki]] ( Application app ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; List < play . api . i18n . Lang > [[betrayals]] = Scala . asJava ( langs . availables ( ) ) ; return [[betrayals]] . stream ( ) . map ( Lang :: new ) . collect ( toList ( ) ) ; }
[[[[Nl]]]]: Retrieve Lang availables from the application configuration .
--------------------------------------------- Result 610 ---------------------------------------------
Returns a builder for a Guice application . --> Create a new GuiceApplicationBuilder --> Socre: 1.0

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder [[builder]] ) { return new GuiceApplicationBuilder ( [[builder]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .

[[[[Adv]]]]: protected GuiceApplicationBuilder newBuilder ( play . api . inject . guice . GuiceApplicationBuilder [[blag]] ) { return new GuiceApplicationBuilder ( [[blag]] ) ; }
[[[[Nl]]]]: Implementation of Self creation for GuiceBuilder .
--------------------------------------------- Result 611 ---------------------------------------------
Create a new EvolutionsReader from a map . --> [[[FAILED]]]

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[fromMap]] ( Map < String , List < Evolution > > [[evolutions]] ) { return new SimpleEvolutionsReader ( [[evolutions]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .

[[[[Adv]]]]: public static play . api . db . [[craw]] . EvolutionsReader [[overpowering]] ( Map < String , List < Evolution > > [[craw]] ) { return new SimpleEvolutionsReader ( [[craw]] ) ; }
[[[[Nl]]]]: Create an evolutions reader based on a simple map of database names to evolutions .
--------------------------------------------- Result 612 ---------------------------------------------
Creates a reader for the Evolutions . --> new EvolutionsReader --> Socre: 1.0

[[[[Adv]]]]: public static play . api . db . [[evolutions]] . EvolutionsReader [[forDefault]] ( Evolution ... [[evolutions]] ) { Map < String , List < Evolution > > [[map]] = new HashMap < String , List < Evolution > > ( ) ; [[map]] . put ( "default" , Arrays . asList ( [[evolutions]] ) ) ; return fromMap ( [[map]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .

[[[[Adv]]]]: public static play . api . db . [[psychiatrist]] . EvolutionsReader [[accurately]] ( Evolution ... [[psychiatrist]] ) { Map < String , List < Evolution > > [[trait]] = new HashMap < String , List < Evolution > > ( ) ; [[trait]] . put ( "default" , Arrays . asList ( [[psychiatrist]] ) ) ; return fromMap ( [[trait]] ) ; }
[[[[Nl]]]]: Create an evolutions reader for the default database from a list of evolutions .
--------------------------------------------- Result 613 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 518 / 78 / 17 / 613:  61%|██████▏   | 613/1000 [5:31:58<3:29:35, 32.49s/it][Succeeded / Failed / Skipped / Total] 518 / 78 / 17 / 613:  61%|██████▏   | 614/1000 [5:31:59<3:28:42, 32.44s/it][Succeeded / Failed / Skipped / Total] 519 / 78 / 17 / 614:  61%|██████▏   | 614/1000 [5:31:59<3:28:42, 32.44s/it][Succeeded / Failed / Skipped / Total] 519 / 78 / 17 / 614:  62%|██████▏   | 615/1000 [5:32:22<3:28:04, 32.43s/it][Succeeded / Failed / Skipped / Total] 520 / 78 / 17 / 615:  62%|██████▏   | 615/1000 [5:32:22<3:28:04, 32.43s/it][Succeeded / Failed / Skipped / Total] 520 / 78 / 17 / 615:  62%|██████▏   | 616/1000 [5:33:17<3:27:46, 32.46s/it][Succeeded / Failed / Skipped / Total] 520 / 79 / 17 / 616:  62%|██████▏   | 616/1000 [5:33:17<3:27:46, 32.46s/it][Succeeded / Failed / Skipped / Total] 520 / 79 / 17 / 616:  62%|██████▏   | 617/1000 [5:33:33<3:27:03, 32.44s/it][Succeeded / Failed / Skipped / Total] 520 / 80 / 17 / 617:  62%|██████▏   | 617/1000 [5:33:33<3:27:03, 32.44s/it][Succeeded / Failed / Skipped / Total] 520 / 80 / 17 / 617:  62%|██████▏   | 618/1000 [5:36:06<3:27:45, 32.63s/it][Succeeded / Failed / Skipped / Total] 520 / 81 / 17 / 618:  62%|██████▏   | 618/1000 [5:36:06<3:27:45, 32.63s/it][Succeeded / Failed / Skipped / Total] 520 / 81 / 17 / 618:  62%|██████▏   | 619/1000 [5:36:41<3:27:14, 32.64s/it][Succeeded / Failed / Skipped / Total] 521 / 81 / 17 / 619:  62%|██████▏   | 619/1000 [5:36:41<3:27:14, 32.64s/it][Succeeded / Failed / Skipped / Total] 521 / 81 / 17 / 619:  62%|██████▏   | 620/1000 [5:36:55<3:26:30, 32.61s/it]Returns the preferred language for the given application . --> [[[FAILED]]]

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .

[[[[Adv]]]]: public static Lang preferred ( Application app , List < Lang > availableLangs ) { play . api . i18n . Langs langs = app . injector ( ) . instanceOf ( play . api . i18n . Langs . class ) ; Stream < Lang > stream = availableLangs . stream ( ) ; List < play . api . i18n . Lang > langSeq = stream . map ( l -> new play . api . i18n . Lang ( l . toLocale ( ) ) ) . collect ( toList ( ) ) ; return new Lang ( langs . preferred ( Scala . toSeq ( langSeq ) ) ) ; }
[[[[Nl]]]]: Guess the preferred lang in the langs set passed as argument . The first Lang that matches an available Lang wins otherwise returns the first Lang available in this application .
--------------------------------------------- Result 614 ---------------------------------------------
Loads the application with the given bindings . --> Atompletes this application --> Socre: 1.0

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[load]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .

[[[[Adv]]]]: public GuiceApplicationBuilder [[ardo]] ( play . api . inject . Binding < ? > ... [[hugged]] ) { return [[ardo]] ( Guiceable . [[hugged]] ( [[hugged]] ) ) ; }
[[[[Nl]]]]: Override the module loader with the given Play bindings .
--------------------------------------------- Result 615 ---------------------------------------------
Encode a cookie . --> Removes trailing separators --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[buf]] = new StringBuilder ( ) ; [[encode]] ( [[buf]] , cookie ) ; return stripTrailingSeparator ( [[buf]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .

[[[[Adv]]]]: public String [[mistrustful]] ( Cookie cookie ) { if ( cookie == null ) { throw new NullPointerException ( "cookie" ) ; } StringBuilder [[mandrake]] = new StringBuilder ( ) ; [[mistrustful]] ( [[mandrake]] , cookie ) ; return stripTrailingSeparator ( [[mandrake]] ) ; }
[[[[Nl]]]]: Encodes the specified cookie into a Cookie header value .
--------------------------------------------- Result 616 ---------------------------------------------
Loads the Guice application from the given set of modules . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[load]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .

[[[[Adv]]]]: public GuiceApplicationBuilder [[charters]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . load ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override the module loader with the given guiceable modules .
--------------------------------------------- Result 617 ---------------------------------------------
Loads configuration from the given environment . --> [[[FAILED]]]

[[[[Adv]]]]: public GuiceApplicationBuilder [[withConfigLoader]] ( Function < Environment , Config > [[load]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[env]] ) -> new play . api . Configuration ( [[load]] . apply ( new Environment ( [[env]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .

[[[[Adv]]]]: public GuiceApplicationBuilder [[ditz]] ( Function < Environment , Config > [[shutout]] ) { return newBuilder ( delegate . loadConfig ( func ( ( play . api . Environment [[quien]] ) -> new play . api . Configuration ( [[shutout]] . apply ( new Environment ( [[quien]] ) ) ) ) ) ) ; }
[[[[Nl]]]]: Set the initial configuration loader . Overrides the default or any previously configured values .
--------------------------------------------- Result 618 ---------------------------------------------
Gets the entity manager . --> [[[FAILED]]]

[[[[Adv]]]]: public EntityManager [[em]] ( ) { Deque < EntityManager > [[ems]] = this . emStack ( "[[True]]" == "[[True]]" ) ; if ( [[ems]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[ems]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .

[[[[Adv]]]]: public EntityManager [[canoodling]] ( ) { Deque < EntityManager > [[grooming]] = this . emStack ( "[[Tutti]]" == "[[Tutti]]" ) ; if ( [[grooming]] . isEmpty ( ) ) { Http . Context . safeCurrent ( ) . map ( ctx -> { throw new RuntimeException ( "No EntityManager found in the context. Try to annotate your action method with @play.db.jpa.Transactional" ) ; } ) . orElseGet ( ( ) -> { throw new RuntimeException ( "No EntityManager bound to this thread. Try wrapping this call in JPAApi.withTransaction, or ensure that the HTTP context is setup on this thread." ) ; } ) ; } return [[grooming]] . peekFirst ( ) ; }
[[[[Nl]]]]: Get the default EntityManager for this thread .
--------------------------------------------- Result 619 ---------------------------------------------
Gets the current em stack . --> We don t need to be thread - safe --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[emStack]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[emsObject]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[emsObject]] != null ) { return ( Deque < EntityManager > ) [[emsObject]] ; } else { Deque < EntityManager > [[ems]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[ems]] ) ; return [[ems]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public Deque < EntityManager > [[appetizer]] ( boolean threadLocalFallback ) { return Http . Context . safeCurrent ( ) . map ( context -> { Object [[astronomer]] = context . args . get ( CURRENT_ENTITY_MANAGER ) ; if ( [[astronomer]] != null ) { return ( Deque < EntityManager > ) [[astronomer]] ; } else { Deque < EntityManager > [[fingerling]] = new ArrayDeque <> ( ) ; context . args . put ( CURRENT_ENTITY_MANAGER , [[fingerling]] ) ; return [[fingerling]] ; } } ) . orElseGet ( ( ) -> {
[[[[Nl]]]]: Get the EntityManager stack .
--------------------------------------------- Result 620 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 81 / 17 / 620:  62%|██████▏   | 620/1000 [5:36:55<3:26:30, 32.61s/it][Succeeded / Failed / Skipped / Total] 522 / 81 / 17 / 620:  62%|██████▏   | 621/1000 [5:38:01<3:26:17, 32.66s/it][Succeeded / Failed / Skipped / Total] 522 / 82 / 17 / 621:  62%|██████▏   | 621/1000 [5:38:01<3:26:17, 32.66s/it][Succeeded / Failed / Skipped / Total] 522 / 82 / 17 / 621:  62%|██████▏   | 622/1000 [5:38:20<3:25:36, 32.64s/it][Succeeded / Failed / Skipped / Total] 523 / 82 / 17 / 622:  62%|██████▏   | 622/1000 [5:38:20<3:25:36, 32.64s/it][Succeeded / Failed / Skipped / Total] 523 / 82 / 17 / 622:  62%|██████▏   | 623/1000 [5:38:24<3:24:47, 32.59s/it][Succeeded / Failed / Skipped / Total] 524 / 82 / 17 / 623:  62%|██████▏   | 623/1000 [5:38:24<3:24:47, 32.59s/it][Succeeded / Failed / Skipped / Total] 524 / 82 / 17 / 623:  62%|██████▏   | 624/1000 [5:38:36<3:24:01, 32.56s/it][Succeeded / Failed / Skipped / Total] 525 / 82 / 17 / 624:  62%|██████▏   | 624/1000 [5:38:36<3:24:01, 32.56s/it][Succeeded / Failed / Skipped / Total] 525 / 82 / 17 / 624:  62%|██████▎   | 625/1000 [5:38:36<3:23:09, 32.51s/it][Succeeded / Failed / Skipped / Total] 525 / 82 / 18 / 625:  62%|██████▎   | 625/1000 [5:38:36<3:23:09, 32.51s/it][Succeeded / Failed / Skipped / Total] 525 / 82 / 18 / 625:  63%|██████▎   | 626/1000 [5:38:45<3:22:23, 32.47s/it][Succeeded / Failed / Skipped / Total] 526 / 82 / 18 / 626:  63%|██████▎   | 626/1000 [5:38:45<3:22:23, 32.47s/it][Succeeded / Failed / Skipped / Total] 526 / 82 / 18 / 626:  63%|██████▎   | 627/1000 [5:39:05<3:21:43, 32.45s/it][Succeeded / Failed / Skipped / Total] 526 / 83 / 18 / 627:  63%|██████▎   | 627/1000 [5:39:05<3:21:43, 32.45s/it][Succeeded / Failed / Skipped / Total] 526 / 83 / 18 / 627:  63%|██████▎   | 628/1000 [5:39:13<3:20:56, 32.41s/it]Converts the error arguments . --> Utility method to extract JMX context --> Socre: 1.0

[[[[Adv]]]]: private List < Object > [[convertErrorArguments]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[converted]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[converted]] ) ; }
[[[[Nl]]]]: Convert the error arguments .

[[[[Adv]]]]: private List < Object > [[grimace]] ( Object [ ] arguments ) { if ( arguments == null ) { return Collections . emptyList ( ) ; } List < Object > [[jemma]] = Arrays . stream ( arguments ) . filter ( arg -> ! ( arg instanceof org . springframework . context . support . DefaultMessageSourceResolvable ) ) . collect ( Collectors . toList ( ) ) ; return Collections . unmodifiableList ( [[jemma]] ) ; }
[[[[Nl]]]]: Convert the error arguments .
--------------------------------------------- Result 621 ---------------------------------------------
Gets the global validation errors . --> [[[FAILED]]]

[[[[Adv]]]]: public List < ValidationError > [[globalErrors]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .

[[[[Adv]]]]: public List < ValidationError > [[petrochemical]] ( ) { return Collections . unmodifiableList ( errors . stream ( ) . filter ( error -> error . key ( ) . isEmpty ( ) ) . collect ( Collectors . toList ( ) ) ) ; }
[[[[Nl]]]]: Retrieve all global errors - errors without a key .
--------------------------------------------- Result 622 ---------------------------------------------
Gets the value associated with the given key . --> Returns an optional extra key . --> Socre: 1.0

[[[[Adv]]]]: public Optional < Object > value ( String [[key]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[key]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value

[[[[Adv]]]]: public Optional < Object > value ( String [[teasing]] ) { return super . value ( ) . map ( v -> v . getData ( ) . get ( asNormalKey ( [[teasing]] ) ) ) ; }
[[[[Nl]]]]: Gets the concrete value
--------------------------------------------- Result 623 ---------------------------------------------
Returns the JSON object as a JSON object . --> Represents error messages --> Socre: 1.0

[[[[Adv]]]]: public JsonNode [[errorsAsJson]] ( Lang [[lang]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[lang]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[lang]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[lang]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .

[[[[Adv]]]]: public JsonNode [[reprogrammed]] ( Lang [[devoting]] ) { Map < String , List < String > > allMessages = new HashMap <> ( ) ; errors . forEach ( error -> { if ( error != null ) { final List < String > messages = new ArrayList <> ( ) ; if ( messagesApi != null && [[devoting]] != null ) { final List < String > reversedMessages = new ArrayList <> ( error . messages ( ) ) ; Collections . reverse ( reversedMessages ) ; messages . add ( messagesApi . get ( [[devoting]] , reversedMessages , translateMsgArg ( error . arguments ( ) , messagesApi , [[devoting]] ) ) ) ; } else { messages . add ( error . message ( ) ) ; } allMessages . put ( error . key ( ) , messages ) ; } } ) ; return play . libs . Json . toJson ( allMessages ) ; }
[[[[Nl]]]]: Returns the form errors serialized as Json using the given Lang .
--------------------------------------------- Result 624 ---------------------------------------------
Converts the specified string to an object of the specified type . --> Convert nagato to nagato --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] parse ( String text , Class < [[T]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .

[[[[Adv]]]]: public < [[nagato]] > [[nagato]] parse ( String text , Class < [[nagato]] > clazz ) { return conversion . convert ( text , clazz ) ; }
[[[[Nl]]]]: Parses this string as instance of the given class .
--------------------------------------------- Result 625 ---------------------------------------------
Converts the given text to an object . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T parse ( Field field , String text ) { return ( T ) conversion . convert ( text , new TypeDescriptor ( field ) ) ; }
[[[[Nl]]]]: Parses this string as instance of a specific field
--------------------------------------------- Result 626 ---------------------------------------------
Prints the given object as a string --> Prints a single object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .

[[[[Adv]]]]: public < T > [[Boyar]] print ( T t ) { if ( t == null ) { return "" ; } if ( conversion . canConvert ( t . getClass ( ) , [[Boyar]] . class ) ) { return conversion . convert ( t , [[Boyar]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value .
--------------------------------------------- Result 627 ---------------------------------------------
Creates a form with the specified value . --> [[[FAILED]]]

[[[[Adv]]]]: public Form < T > [[fill]] ( T [[value]] ) { if ( [[value]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[value]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .

[[[[Adv]]]]: public Form < T > [[nebuchadnezzar]] ( T [[aretha]] ) { if ( [[aretha]] == null ) { throw new RuntimeException ( "Cannot fill a form with a null value" ) ; } return new Form <> ( rootName , backedType , new HashMap <> ( ) , new HashMap <> ( ) , new ArrayList <> ( ) , Optional . ofNullable ( [[aretha]] ) , groups , messagesApi , formatters , validatorFactory , config , lang , directFieldAccess ) ; }
[[[[Nl]]]]: Populates this form with an existing value used for edit forms .
--------------------------------------------- Result 628 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 527 / 83 / 18 / 628:  63%|██████▎   | 628/1000 [5:39:13<3:20:56, 32.41s/it][Succeeded / Failed / Skipped / Total] 527 / 83 / 18 / 628:  63%|██████▎   | 629/1000 [5:39:21<3:20:09, 32.37s/it][Succeeded / Failed / Skipped / Total] 528 / 83 / 18 / 629:  63%|██████▎   | 629/1000 [5:39:21<3:20:09, 32.37s/it][Succeeded / Failed / Skipped / Total] 528 / 83 / 18 / 629:  63%|██████▎   | 630/1000 [5:39:23<3:19:19, 32.32s/it][Succeeded / Failed / Skipped / Total] 528 / 84 / 18 / 630:  63%|██████▎   | 630/1000 [5:39:23<3:19:19, 32.32s/it][Succeeded / Failed / Skipped / Total] 528 / 84 / 18 / 630:  63%|██████▎   | 631/1000 [5:39:39<3:18:37, 32.30s/it][Succeeded / Failed / Skipped / Total] 529 / 84 / 18 / 631:  63%|██████▎   | 631/1000 [5:39:39<3:18:37, 32.30s/it][Succeeded / Failed / Skipped / Total] 529 / 84 / 18 / 631:  63%|██████▎   | 632/1000 [5:39:46<3:17:50, 32.26s/it][Succeeded / Failed / Skipped / Total] 530 / 84 / 18 / 632:  63%|██████▎   | 632/1000 [5:39:46<3:17:50, 32.26s/it][Succeeded / Failed / Skipped / Total] 530 / 84 / 18 / 632:  63%|██████▎   | 633/1000 [5:40:42<3:17:31, 32.29s/it][Succeeded / Failed / Skipped / Total] 530 / 85 / 18 / 633:  63%|██████▎   | 633/1000 [5:40:42<3:17:31, 32.29s/it][Succeeded / Failed / Skipped / Total] 530 / 85 / 18 / 633:  63%|██████▎   | 634/1000 [5:41:44<3:17:16, 32.34s/it][Succeeded / Failed / Skipped / Total] 531 / 85 / 18 / 634:  63%|██████▎   | 634/1000 [5:41:44<3:17:16, 32.34s/it][Succeeded / Failed / Skipped / Total] 531 / 85 / 18 / 634:  64%|██████▎   | 635/1000 [5:41:45<3:16:26, 32.29s/it]Print the given type . --> Print an Lnstitute object --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ) { return ( [[String]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[String]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[String]] . class ) ) { return conversion . convert ( t , [[String]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .

[[[[Adv]]]]: public < T > [[Lnstitute]] print ( TypeDescriptor desc , T t ) { if ( t == null ) { return "" ; } if ( desc != null && conversion . canConvert ( desc , TypeDescriptor . valueOf ( [[Lnstitute]] . class ) ) ) { return ( [[Lnstitute]] ) conversion . convert ( t , desc , TypeDescriptor . valueOf ( [[Lnstitute]] . class ) ) ; } else if ( conversion . canConvert ( t . getClass ( ) , [[Lnstitute]] . class ) ) { return conversion . convert ( t , [[Lnstitute]] . class ) ; } else { return t . toString ( ) ; } }
[[[[Nl]]]]: Computes the display string for any value for a specific type .
--------------------------------------------- Result 629 ---------------------------------------------
Register a converter . --> Register custom converterters --> Socre: 1.0

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor [[sourceType]] , TypeDescriptor targetType ) { if ( [[sourceType]] . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String

[[[[Adv]]]]: private Formatters registerOptional ( ) { conversion . addConverter ( new GenericConverter ( ) { public Object convert ( Object source , TypeDescriptor [[choking]] , TypeDescriptor targetType ) { if ( [[choking]] . getObjectType ( ) . equals ( String . class ) ) {
[[[[Nl]]]]: Converter for String - > Optional and Optional - > String
--------------------------------------------- Result 630 ---------------------------------------------
Creates a Flow of actors . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int [[bufferSize]] , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , [[bufferSize]] , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .

[[[[Adv]]]]: public static < In , Out > Flow < In , Out , ? > actorRef ( Function < ActorRef , Props > props , int [[kers]] , OverflowStrategy overflowStrategy , ActorRefFactory factory , Materializer mat ) { return play . api . libs . streams . ActorFlow . < In , Out > actorRef ( new AbstractFunction1 < ActorRef , Props > ( ) { @ Override public Props apply ( ActorRef v1 ) { return props . apply ( v1 ) ; } } , [[kers]] , overflowStrategy , factory , mat ) . asJava ( ) ; }
[[[[Nl]]]]: Create a flow that is handled by an actor .
--------------------------------------------- Result 631 ---------------------------------------------
Register converter . --> Register a converter for a class --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Annotation]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Annotation]] > annotationType = ( Class < ? extends [[Annotation]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < A extends [[Rico]] , T > Formatters register ( final Class < T > clazz , final AnnotationFormatter < A , T > formatter ) { final Class < ? extends [[Rico]] > annotationType = ( Class < ? extends [[Rico]] > ) GenericTypeResolver . resolveTypeArguments ( formatter . getClass ( ) , AnnotationFormatter . class ) [ 0 ] ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( clazz , String . class ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( sourceType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) sourceType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . print ( a , ( T ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return "@" + annotationType . getName ( ) + " " + clazz . getName ( ) + " -> " + String . class . getName ( ) + ": " + formatter ; } } ) ; conversion . addConverter ( new ConditionalGenericConverter ( ) { public Set < GenericConverter . ConvertiblePair > getConvertibleTypes ( ) { Set < GenericConverter . ConvertiblePair > types = new HashSet <> ( ) ; types . add ( new GenericConverter . ConvertiblePair ( String . class , clazz ) ) ; return types ; } public boolean matches ( TypeDescriptor sourceType , TypeDescriptor targetType ) { return ( targetType . getAnnotation ( annotationType ) != null ) ; } public Object convert ( Object source , TypeDescriptor sourceType , TypeDescriptor targetType ) { final A a = ( A ) targetType . getAnnotation ( annotationType ) ; Locale locale = LocaleContextHolder . getLocale ( ) ; try { return formatter . parse ( a , ( String ) source , locale ) ; } catch ( Exception ex ) { throw new ConversionFailedException ( sourceType , targetType , source , ex ) ; } } public String toString ( ) { return String . class . getName ( ) + " -> @" + annotationType . getName ( ) + " " + clazz . getName ( ) + ": " + formatter ; } } ) ; return this ; }
[[[[Nl]]]]: Registers an annotation - based formatter .
--------------------------------------------- Result 632 ---------------------------------------------
Prints a type descriptor . --> Prints type t --> Socre: 1.0

[[[[Adv]]]]: public < T > [[String]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .

[[[[Adv]]]]: public < T > [[Okada]] print ( Field field , T t ) { return print ( new TypeDescriptor ( field ) , t ) ; }
[[[[Nl]]]]: Computes the display string for any value for a specific field .
--------------------------------------------- Result 633 ---------------------------------------------
Creates a flow with the given flow . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , [[FlowIn]] , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < [[FlowIn]] , Out > > splitter , Flow < [[FlowIn]] , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .

[[[[Adv]]]]: public static < In , [[dinnerware]] , Out > Flow < In , Out , ? > bypassWith ( Function < In , F . Either < [[dinnerware]] , Out > > splitter , Flow < [[dinnerware]] , Out , ? > flow ) { return bypassWith ( Flow . < In > create ( ) . map ( splitter :: apply ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , flow ) ; }
[[[[Nl]]]]: Bypass the given flow using the given splitter function .
--------------------------------------------- Result 634 ---------------------------------------------
Fills the form . --> deprecated --> Socre: 1.0

[[[[Adv]]]]: public DynamicForm [[fill]] ( Map < String , Object > [[value]] ) { Form < Dynamic > [[form]] = super . fill ( new Dynamic ( [[value]] ) ) ; return new DynamicForm ( [[form]] . rawData ( ) , [[form]] . files ( ) , [[form]] . errors ( ) , [[form]] . [[value]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .

[[[[Adv]]]]: public DynamicForm [[prescribe]] ( Map < String , Object > [[parasites]] ) { Form < Dynamic > [[sanctified]] = super . fill ( new Dynamic ( [[parasites]] ) ) ; return new DynamicForm ( [[sanctified]] . rawData ( ) , [[sanctified]] . files ( ) , [[sanctified]] . errors ( ) , [[sanctified]] . [[parasites]] ( ) , messagesApi , formatters , validatorFactory , config , lang ( ) . orElse ( null ) ) ; }
[[[[Nl]]]]: Fills the form with existing data .
--------------------------------------------- Result 635 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 532 / 85 / 18 / 635:  64%|██████▎   | 635/1000 [5:41:45<3:16:26, 32.29s/it][Succeeded / Failed / Skipped / Total] 532 / 85 / 18 / 635:  64%|██████▎   | 636/1000 [5:41:53<3:15:40, 32.25s/it][Succeeded / Failed / Skipped / Total] 533 / 85 / 18 / 636:  64%|██████▎   | 636/1000 [5:41:53<3:15:40, 32.25s/it][Succeeded / Failed / Skipped / Total] 533 / 85 / 18 / 636:  64%|██████▎   | 637/1000 [5:41:54<3:14:50, 32.21s/it][Succeeded / Failed / Skipped / Total] 534 / 85 / 18 / 637:  64%|██████▎   | 637/1000 [5:41:54<3:14:50, 32.21s/it][Succeeded / Failed / Skipped / Total] 534 / 85 / 18 / 637:  64%|██████▍   | 638/1000 [5:42:02<3:14:04, 32.17s/it][Succeeded / Failed / Skipped / Total] 534 / 86 / 18 / 638:  64%|██████▍   | 638/1000 [5:42:02<3:14:04, 32.17s/it][Succeeded / Failed / Skipped / Total] 534 / 86 / 18 / 638:  64%|██████▍   | 639/1000 [5:42:05<3:13:15, 32.12s/it][Succeeded / Failed / Skipped / Total] 535 / 86 / 18 / 639:  64%|██████▍   | 639/1000 [5:42:05<3:13:15, 32.12s/it][Succeeded / Failed / Skipped / Total] 535 / 86 / 18 / 639:  64%|██████▍   | 640/1000 [5:42:05<3:12:25, 32.07s/it][Succeeded / Failed / Skipped / Total] 536 / 86 / 18 / 640:  64%|██████▍   | 640/1000 [5:42:05<3:12:25, 32.07s/it][Succeeded / Failed / Skipped / Total] 536 / 86 / 18 / 640:  64%|██████▍   | 641/1000 [5:42:25<3:11:46, 32.05s/it]Converts the given list to a sequence . --> Calculate Hogue --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[hogue]] ( java . util . List < T > list ) { return scala . collection . JavaConverters . asScalaBufferConverter ( list ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts a Java List to Scala Seq .
--------------------------------------------- Result 636 ---------------------------------------------
Creates a sequence from an array . --> Static factory method for bobert --> Socre: 1.0

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[toSeq]] ( T [ ] array ) { return [[toSeq]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .

[[[[Adv]]]]: public static < T > scala . collection . immutable . Seq < T > [[bobert]] ( T [ ] array ) { return [[bobert]] ( java . util . Arrays . asList ( array ) ) ; }
[[[[Nl]]]]: Converts a Java Array to Scala Seq .
--------------------------------------------- Result 637 ---------------------------------------------
Create a sequence of variables from an array . --> removes elements from array --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[varargs]] ( T ... array ) { return toSeq ( array ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .

[[[[Adv]]]]: @ SafeVarargs public static < T > scala . collection . immutable . Seq < T > [[bewilderment]] ( T ... array ) { return toSeq ( array ) ; }
[[[[Nl]]]]: Converts a Java varargs to Scala varargs .
--------------------------------------------- Result 638 ---------------------------------------------
Proceeds a flow with the given splitter . --> [[[FAILED]]]

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .

[[[[Adv]]]]: public static < In , FlowIn , Out > Flow < In , Out , ? > bypassWith ( Flow < In , F . Either < FlowIn , Out > , ? > splitter , Graph < UniformFanInShape < Out , Out > , ? > mergeStrategy , Flow < FlowIn , Out , ? > flow ) { return splitter . via ( Flow . fromGraph ( GraphDSL . < FlowShape < F . Either < FlowIn , Out > , Out > > create ( builder -> {
[[[[Nl]]]]: Using the given splitter flow allow messages to bypass a flow .
--------------------------------------------- Result 639 ---------------------------------------------
Creates a MappedWebSocketAcceptor from the given type . --> Creates a MappedWebSocketAcceptor --> Socre: 1.0

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[in]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[in]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[in]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .

[[[[Adv]]]]: public static < In , Out > MappedWebSocketAcceptor < In , Out > json ( Class < In > [[casters]] ) { return new MappedWebSocketAcceptor <> ( Scala . partialFunction ( message -> { try { if ( message instanceof Message . Binary ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Binary ) message ) . data ( ) . iterator ( ) . asInputStream ( ) , [[casters]] ) ) ; } else if ( message instanceof Message . Text ) { return F . Either . Left ( play . libs . Json . mapper ( ) . readValue ( ( ( Message . Text ) message ) . data ( ) , [[casters]] ) ) ; } } catch ( Exception e ) { return F . Either . Right ( new Message . Close ( CloseCodes . Unacceptable ( ) , e . getMessage ( ) ) ) ; } throw Scala . noMatch ( ) ; } ) , outMessage -> { try { return new Message . Text ( play . libs . Json . mapper ( ) . writeValueAsString ( outMessage ) ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } } ) ; }
[[[[Nl]]]]: Acceptor for JSON WebSockets .
--------------------------------------------- Result 640 ---------------------------------------------
Accepts the result and returns the result . --> Accepts and returns a pair of streams --> Socre: 1.0

[[[[Adv]]]]: private static < In , Out > [[WebSocket]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[WebSocket]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .

[[[[Adv]]]]: private static < In , Out > [[bedlam]] acceptOrResult ( PartialFunction < Message , F . Either < In , Message > > inMapper , Function < Http . RequestHeader , CompletionStage < F . Either < Result , Flow < In , Out , ? > > > > f , Function < Out , Message > outMapper ) { return new [[bedlam]] ( ) { @ Override public CompletionStage < F . Either < Result , Flow < Message , Message , ? > > > apply ( Http . RequestHeader request ) { return f . apply ( request ) . thenApply ( resultOrFlow -> { if ( resultOrFlow . left . isPresent ( ) ) { return F . Either . Left ( resultOrFlow . left . get ( ) ) ; } else { Flow < Message , Message , ? > flow = AkkaStreams . bypassWith ( Flow . < Message > create ( ) . collect ( inMapper ) , play . api . libs . streams . AkkaStreams . onlyFirstCanFinishMerge ( 2 ) , resultOrFlow . right . get ( ) . map ( outMapper :: apply ) ) ; return F . Either . Right ( flow ) ; } } ) ; } } ; }
[[[[Nl]]]]: Helper to create handlers for WebSockets .
--------------------------------------------- Result 641 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 537 / 86 / 18 / 641:  64%|██████▍   | 641/1000 [5:42:25<3:11:46, 32.05s/it][Succeeded / Failed / Skipped / Total] 537 / 86 / 18 / 641:  64%|██████▍   | 642/1000 [5:42:37<3:11:03, 32.02s/it][Succeeded / Failed / Skipped / Total] 538 / 86 / 18 / 642:  64%|██████▍   | 642/1000 [5:42:37<3:11:03, 32.02s/it][Succeeded / Failed / Skipped / Total] 538 / 86 / 18 / 642:  64%|██████▍   | 643/1000 [5:42:44<3:10:17, 31.98s/it][Succeeded / Failed / Skipped / Total] 539 / 86 / 18 / 643:  64%|██████▍   | 643/1000 [5:42:44<3:10:17, 31.98s/it][Succeeded / Failed / Skipped / Total] 539 / 86 / 18 / 643:  64%|██████▍   | 644/1000 [5:42:53<3:09:33, 31.95s/it][Succeeded / Failed / Skipped / Total] 540 / 86 / 18 / 644:  64%|██████▍   | 644/1000 [5:42:53<3:09:33, 31.95s/it][Succeeded / Failed / Skipped / Total] 540 / 86 / 18 / 644:  64%|██████▍   | 645/1000 [5:43:02<3:08:48, 31.91s/it][Succeeded / Failed / Skipped / Total] 541 / 86 / 18 / 645:  64%|██████▍   | 645/1000 [5:43:02<3:08:48, 31.91s/it][Succeeded / Failed / Skipped / Total] 541 / 86 / 18 / 645:  65%|██████▍   | 646/1000 [5:43:17<3:08:06, 31.88s/it][Succeeded / Failed / Skipped / Total] 542 / 86 / 18 / 646:  65%|██████▍   | 646/1000 [5:43:17<3:08:06, 31.88s/it][Succeeded / Failed / Skipped / Total] 542 / 86 / 18 / 646:  65%|██████▍   | 647/1000 [5:43:18<3:07:18, 31.84s/it][Succeeded / Failed / Skipped / Total] 543 / 86 / 18 / 647:  65%|██████▍   | 647/1000 [5:43:18<3:07:18, 31.84s/it][Succeeded / Failed / Skipped / Total] 543 / 86 / 18 / 647:  65%|██████▍   | 648/1000 [5:43:27<3:06:34, 31.80s/it][Succeeded / Failed / Skipped / Total] 543 / 87 / 18 / 648:  65%|██████▍   | 648/1000 [5:43:27<3:06:34, 31.80s/it][Succeeded / Failed / Skipped / Total] 543 / 87 / 18 / 648:  65%|██████▍   | 649/1000 [5:44:06<3:06:06, 31.81s/it]Get the total transformation cost . --> Do ollow --> Socre: 1.0

[[[[Adv]]]]: private static float [[getTotalTransformationCost]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .

[[[[Adv]]]]: private static float [[ollow]] ( final Class < ? > [ ] srcArgs , final Executable executable ) { final Class < ? > [ ] destArgs = executable . getParameterTypes ( ) ; final boolean isVarArgs = executable . isVarArgs ( ) ;
[[[[Nl]]]]: Returns the sum of the object transformation cost for each class in the source argument list .
--------------------------------------------- Result 642 ---------------------------------------------
Encodes a cookie . --> Convenience method to add four years --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( Cookie [[cookie]] ) { if ( [[cookie]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = [[cookie]] . name ( ) ; final String value = [[cookie]] . value ( ) != null ? [[cookie]] . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder [[buf]] = new StringBuilder ( ) ; if ( [[cookie]] . wrap ( ) ) { addQuoted ( [[buf]] , name , value ) ; } else { add ( [[buf]] , name , value ) ; } if ( [[cookie]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[buf]] , CookieHeaderNames . MAX_AGE , [[cookie]] . maxAge ( ) ) ; Date expires = [[cookie]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .

[[[[Adv]]]]: public String [[banter]] ( Cookie [[fouryears]] ) { if ( [[fouryears]] == null ) { throw new NullPointerException ( "cookie" ) ; } final String name = [[fouryears]] . name ( ) ; final String value = [[fouryears]] . value ( ) != null ? [[fouryears]] . value ( ) : "" ; validateCookie ( name , value ) ; StringBuilder [[watermelons]] = new StringBuilder ( ) ; if ( [[fouryears]] . wrap ( ) ) { addQuoted ( [[watermelons]] , name , value ) ; } else { add ( [[watermelons]] , name , value ) ; } if ( [[fouryears]] . maxAge ( ) != Integer . MIN_VALUE ) { add ( [[watermelons]] , CookieHeaderNames . MAX_AGE , [[fouryears]] . maxAge ( ) ) ; Date expires = [[fouryears]] . maxAge ( ) <= 0 ? new Date ( 0 )
[[[[Nl]]]]: Encodes the specified cookie into a Set - Cookie header value .
--------------------------------------------- Result 643 ---------------------------------------------
Look up a localized message by key . --> Getter for messages --> Socre: 1.0

[[[[Adv]]]]: public String [[at]] ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
[[[[Nl]]]]: Get the message at the given key .

[[[[Adv]]]]: public String [[fairer]] ( String key , Object ... args ) { return messagesApi . get ( lang , key , args ) ; }
[[[[Nl]]]]: Get the message at the given key .
--------------------------------------------- Result 644 ---------------------------------------------
Checks if the given object is accessible or not . --> Determines if an object is accessible --> Socre: 1.0

[[[[Adv]]]]: static boolean [[setAccessibleWorkaround]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .

[[[[Adv]]]]: static boolean [[flatland]] ( final AccessibleObject o ) { if ( o == null || o . isAccessible ( ) ) { return "False" != "False" ; } final Member m = ( Member ) o ; if ( ! o . isAccessible ( ) && Modifier . isPublic ( m . getModifiers ( ) ) && isPackageAccess ( m . getDeclaringClass ( ) . getModifiers ( ) ) ) { try { o . setAccessible ( "True" == "True" ) ; return "True" == "True" ; } catch ( final SecurityException e ) {
[[[[Nl]]]]: XXX Default access superclass workaround .
--------------------------------------------- Result 645 ---------------------------------------------
Look up a message by key . --> Search for contacts --> Socre: 1.0

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[args]] ) { return messagesApi . get ( lang , keys , [[args]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .

[[[[Adv]]]]: public String at ( List < String > keys , Object ... [[contacting]] ) { return messagesApi . get ( lang , keys , [[contacting]] ) ; }
[[[[Nl]]]]: Get the message at the first defined key .
--------------------------------------------- Result 646 ---------------------------------------------
Selects all nodes matching the specified path . --> Kill a node --> Socre: 1.0

[[[[Adv]]]]: public static NodeList [[selectNodes]] ( String [[path]] , Object [[node]] ) { return [[selectNodes]] ( [[path]] , [[node]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order

[[[[Adv]]]]: public static NodeList [[bite]] ( String [[heartily]] , Object [[wireless]] ) { return [[bite]] ( [[heartily]] , [[wireless]] , null ) ; }
[[[[Nl]]]]: Select all nodes that are selected by this XPath expression . If multiple nodes match multiple nodes will be returned . Nodes will be returned in document - order
--------------------------------------------- Result 647 ---------------------------------------------
Creates a new ParallelSorter . --> Hoarding sorting algorithm --> Socre: 1.0

[[[[Adv]]]]: public static ParallelSorter [[create]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .

[[[[Adv]]]]: public static ParallelSorter [[hoarding]] ( Object [ ] arrays ) { Generator gen = new Generator ( ) ; gen . setArrays ( arrays ) ; return gen . create ( ) ; }
[[[[Nl]]]]: Create a new ParallelSorter object for a set of arrays . You may sort the arrays multiple times via the same ParallelSorter object .
--------------------------------------------- Result 648 ---------------------------------------------
Pushes the given entity to the current one . --> [[[FAILED]]]

[[[[Adv]]]]: void [[pushOrPopEm]] ( EntityManager em , boolean [[threadLocalFallback]] ) { Deque < EntityManager > ems = this . emStack ( [[threadLocalFallback]] ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .

[[[[Adv]]]]: void [[industrial]] ( EntityManager em , boolean [[dormitories]] ) { Deque < EntityManager > ems = this . emStack ( [[dormitories]] ) ; if ( em != null ) { ems . push ( em ) ; } else { if ( ems . isEmpty ( ) ) { throw new IllegalStateException ( "Tried to remove the EntityManager, but none was set." ) ; } ems . pop ( ) ; } }
[[[[Nl]]]]: Pushes or pops the EntityManager stack depending on the value of the em argument . If em is null then the current EntityManager is popped . If em is non - null then em is pushed onto the stack and becomes the current EntityManager .
--------------------------------------------- Result 649 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 544 / 87 / 18 / 649:  65%|██████▍   | 649/1000 [5:44:06<3:06:06, 31.81s/it][Succeeded / Failed / Skipped / Total] 544 / 87 / 18 / 649:  65%|██████▌   | 650/1000 [5:44:14<3:05:21, 31.78s/it][Succeeded / Failed / Skipped / Total] 545 / 87 / 18 / 650:  65%|██████▌   | 650/1000 [5:44:14<3:05:21, 31.78s/it][Succeeded / Failed / Skipped / Total] 545 / 87 / 18 / 650:  65%|██████▌   | 651/1000 [5:44:48<3:04:51, 31.78s/it][Succeeded / Failed / Skipped / Total] 546 / 87 / 18 / 651:  65%|██████▌   | 651/1000 [5:44:48<3:04:51, 31.78s/it][Succeeded / Failed / Skipped / Total] 546 / 87 / 18 / 651:  65%|██████▌   | 652/1000 [5:44:48<3:04:02, 31.73s/it][Succeeded / Failed / Skipped / Total] 546 / 87 / 19 / 652:  65%|██████▌   | 652/1000 [5:44:48<3:04:02, 31.73s/it][Succeeded / Failed / Skipped / Total] 546 / 87 / 19 / 652:  65%|██████▌   | 653/1000 [5:45:10<3:03:25, 31.72s/it][Succeeded / Failed / Skipped / Total] 547 / 87 / 19 / 653:  65%|██████▌   | 653/1000 [5:45:10<3:03:25, 31.72s/it][Succeeded / Failed / Skipped / Total] 547 / 87 / 19 / 653:  65%|██████▌   | 654/1000 [5:45:16<3:02:39, 31.68s/it][Succeeded / Failed / Skipped / Total] 548 / 87 / 19 / 654:  65%|██████▌   | 654/1000 [5:45:16<3:02:39, 31.68s/it][Succeeded / Failed / Skipped / Total] 548 / 87 / 19 / 654:  66%|██████▌   | 655/1000 [5:46:10<3:02:20, 31.71s/it][Succeeded / Failed / Skipped / Total] 549 / 87 / 19 / 655:  66%|██████▌   | 655/1000 [5:46:10<3:02:20, 31.71s/it][Succeeded / Failed / Skipped / Total] 549 / 87 / 19 / 655:  66%|██████▌   | 656/1000 [5:46:18<3:01:35, 31.67s/it]Quick sort method . --> performs a comparator --> Socre: 1.0

[[[[Adv]]]]: public void quickSort ( int [[index]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .

[[[[Adv]]]]: public void quickSort ( int [[palladium]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[palladium]] , cmp ) ; super . quickSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using the quicksort algorithm .
--------------------------------------------- Result 650 ---------------------------------------------
Cast a numeric value to the specified type . --> Cast a number of arguments . --> Socre: 1.0

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[to]] ) { if ( from != [[to]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[to]] ) ; } } else { if ( [[to]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[to]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[to]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[to]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[to]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[to]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another

[[[[Adv]]]]: public void cast_numeric ( Type from , Type [[constructors]] ) { if ( from != [[constructors]] ) { if ( from == Type . DOUBLE_TYPE ) { if ( [[constructors]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . D2F ) ; } else if ( [[constructors]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . D2L ) ; } else { mv . visitInsn ( Constants . D2I ) ; cast_numeric ( Type . INT_TYPE , [[constructors]] ) ; } } else if ( from == Type . FLOAT_TYPE ) { if ( [[constructors]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . F2D ) ; } else if ( [[constructors]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . F2L ) ; } else { mv . visitInsn ( Constants . F2I ) ; cast_numeric ( Type . INT_TYPE , [[constructors]] ) ; } } else if ( from == Type . LONG_TYPE ) { if ( [[constructors]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . L2D ) ; } else if ( [[constructors]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . L2F ) ; } else { mv . visitInsn ( Constants . L2I ) ; cast_numeric ( Type . INT_TYPE , [[constructors]] ) ; } } else { if ( [[constructors]] == Type . BYTE_TYPE ) { mv . visitInsn ( Constants . I2B ) ; } else if ( [[constructors]] == Type . CHAR_TYPE ) { mv . visitInsn ( Constants . I2C ) ; } else if ( [[constructors]] == Type . DOUBLE_TYPE ) { mv . visitInsn ( Constants . I2D ) ; } else if ( [[constructors]] == Type . FLOAT_TYPE ) { mv . visitInsn ( Constants . I2F ) ; } else if ( [[constructors]] == Type . LONG_TYPE ) { mv . visitInsn ( Constants . I2L ) ; } else if ( [[constructors]] == Type . SHORT_TYPE ) { mv . visitInsn ( Constants . I2S ) ; } } } }
[[[[Nl]]]]: Casts from one primitive numeric type to another
--------------------------------------------- Result 651 ---------------------------------------------
Merge sort algorithm . --> Performs a comparator --> Socre: 1.0

[[[[Adv]]]]: public void [[mergeSort]] ( int [[index]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[index]] , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .

[[[[Adv]]]]: public void [[abound]] ( int [[borough]] , int lo , int hi , Comparator cmp ) { chooseComparer ( [[borough]] , cmp ) ; super . mergeSort ( lo , hi - 1 ) ; }
[[[[Nl]]]]: Sort the arrays using an in - place merge sort .
--------------------------------------------- Result 652 ---------------------------------------------
Emit a field on the stack . --> [[[SKIPPED]]]

[[[[Adv]]]]: void emit_field ( int opcode , Type ctype , String name , Type ftype ) { mv . visitFieldInsn ( opcode , ctype . getInternalName ( ) , name , ftype . getDescriptor ( ) ) ; }
[[[[Nl]]]]: package - protected for EmitUtils try to fix
--------------------------------------------- Result 653 ---------------------------------------------
push a zero or null value --> characters --> Socre: 1.0

[[[[Adv]]]]: public void zero_or_null ( Type [[type]] ) { if ( TypeUtils . isPrimitive ( [[type]] ) ) { switch ( [[type]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .

[[[[Adv]]]]: public void zero_or_null ( Type [[creed]] ) { if ( TypeUtils . isPrimitive ( [[creed]] ) ) { switch ( [[creed]] . getSort ( ) ) { case Type . DOUBLE : push ( 0d ) ; break ; case Type . LONG : push ( 0L ) ; break ; case Type . FLOAT : push ( 0f ) ; break ; case Type . VOID : aconst_null ( ) ; default : push ( 0 ) ; } } else { aconst_null ( ) ; } }
[[[[Nl]]]]: Pushes a zero onto the stack if the argument is a primitive class or a null otherwise .
--------------------------------------------- Result 654 ---------------------------------------------
Loads an argument . --> Set a null value --> Socre: 1.0

[[[[Adv]]]]: public void [[load_arg]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .

[[[[Adv]]]]: public void [[clank]] ( int index ) { load_local ( state . argumentTypes [ index ] , state . localOffset + skipArgs ( index ) ) ; }
[[[[Nl]]]]: Pushes the specified argument of the current method onto the stack .
--------------------------------------------- Result 655 ---------------------------------------------
Unbox or zero . --> traverses a type --> Socre: 1.0

[[[[Adv]]]]: public void [[unbox_or_zero]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .

[[[[Adv]]]]: public void [[troll]] ( Type type ) { if ( TypeUtils . isPrimitive ( type ) ) { if ( type != Type . VOID_TYPE ) { Label nonNull = make_label ( ) ; Label end = make_label ( ) ; dup ( ) ; ifnonnull ( nonNull ) ; pop ( ) ; zero_or_null ( type ) ; goTo ( end ) ; mark ( nonNull ) ; unbox ( type ) ; mark ( end ) ; } } else { checkcast ( type ) ; } }
[[[[Nl]]]]: Unboxes the object on the top of the stack . If the object is null the unboxed primitive value becomes zero .
--------------------------------------------- Result 656 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 550 / 87 / 19 / 656:  66%|██████▌   | 656/1000 [5:46:18<3:01:35, 31.67s/it][Succeeded / Failed / Skipped / Total] 550 / 87 / 19 / 656:  66%|██████▌   | 657/1000 [5:46:27<3:00:52, 31.64s/it][Succeeded / Failed / Skipped / Total] 551 / 87 / 19 / 657:  66%|██████▌   | 657/1000 [5:46:27<3:00:52, 31.64s/it][Succeeded / Failed / Skipped / Total] 551 / 87 / 19 / 657:  66%|██████▌   | 658/1000 [5:46:37<3:00:09, 31.61s/it][Succeeded / Failed / Skipped / Total] 552 / 87 / 19 / 658:  66%|██████▌   | 658/1000 [5:46:37<3:00:09, 31.61s/it][Succeeded / Failed / Skipped / Total] 552 / 87 / 19 / 658:  66%|██████▌   | 659/1000 [5:46:40<2:59:23, 31.56s/it][Succeeded / Failed / Skipped / Total] 553 / 87 / 19 / 659:  66%|██████▌   | 659/1000 [5:46:40<2:59:23, 31.56s/it][Succeeded / Failed / Skipped / Total] 553 / 87 / 19 / 659:  66%|██████▌   | 660/1000 [5:46:48<2:58:39, 31.53s/it][Succeeded / Failed / Skipped / Total] 553 / 88 / 19 / 660:  66%|██████▌   | 660/1000 [5:46:48<2:58:39, 31.53s/it][Succeeded / Failed / Skipped / Total] 553 / 88 / 19 / 660:  66%|██████▌   | 661/1000 [5:46:48<2:57:51, 31.48s/it][Succeeded / Failed / Skipped / Total] 553 / 88 / 20 / 661:  66%|██████▌   | 661/1000 [5:46:48<2:57:51, 31.48s/it][Succeeded / Failed / Skipped / Total] 553 / 88 / 20 / 661:  66%|██████▌   | 662/1000 [5:47:16<2:57:18, 31.47s/it][Succeeded / Failed / Skipped / Total] 554 / 88 / 20 / 662:  66%|██████▌   | 662/1000 [5:47:16<2:57:18, 31.47s/it][Succeeded / Failed / Skipped / Total] 554 / 88 / 20 / 662:  66%|██████▋   | 663/1000 [5:47:16<2:56:31, 31.43s/it]Invoke the protected method . --> todo do not call --> Socre: 1.0

[[[[Adv]]]]: public Object [[invoke]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[fci]] = fastClassInfo ; return [[fci]] . f1 . invoke ( [[fci]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .

[[[[Adv]]]]: public Object [[tus]] ( Object obj , Object [ ] args ) throws Throwable { try { init ( ) ; FastClassInfo [[ilk]] = fastClassInfo ; return [[ilk]] . f1 . invoke ( [[ilk]] . i1 , obj , args ) ; } catch ( InvocationTargetException e ) { throw e . getTargetException ( ) ; } catch ( IllegalArgumentException e ) { if ( fastClassInfo . i1 < 0 ) throw new IllegalArgumentException ( "Protected method: " + sig1 ) ; throw e ; } }
[[[[Nl]]]]: Invoke the original method on a different object of the same type .
--------------------------------------------- Result 657 ---------------------------------------------
implements the null operator --> Generates a code generator --> Socre: 1.0

[[[[Adv]]]]: private static void [[nullcmp]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .

[[[[Adv]]]]: private static void [[benzi]] ( CodeEmitter e , Label oneNull , Label bothNull ) { e . dup2 ( ) ; Label nonNull = e . make_label ( ) ; Label oneNullHelper = e . make_label ( ) ; Label end = e . make_label ( ) ; e . ifnonnull ( nonNull ) ; e . ifnonnull ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( bothNull ) ; e . mark ( nonNull ) ; e . ifnull ( oneNullHelper ) ; e . goTo ( end ) ; e . mark ( oneNullHelper ) ; e . pop2 ( ) ; e . goTo ( oneNull ) ; e . mark ( end ) ; }
[[[[Nl]]]]: If both objects on the top of the stack are non - null does nothing . If one is null or both are null both are popped off and execution branches to the respective label .
--------------------------------------------- Result 658 ---------------------------------------------
Finds all methods in the given class and interfaces . --> Robbin methods --> Socre: 0.9999999999820136

[[[[Adv]]]]: public static void [[getMethods]] ( Class superclass , Class [ ] interfaces , List methods ) { [[getMethods]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .

[[[[Adv]]]]: public static void [[robbin]] ( Class superclass , Class [ ] interfaces , List methods ) { [[robbin]] ( superclass , interfaces , methods , null , null ) ; }
[[[[Nl]]]]: Finds all of the methods that will be extended by an Enhancer - generated class using the specified superclass and interfaces . This can be useful in building a list of Callback objects . The methods are added to the end of the given list . Due to the subclassing nature of the classes generated by Enhancer the methods are guaranteed to be non - static non - final and non - private . Each method signature will only occur once even if it occurs in multiple classes .
--------------------------------------------- Result 659 ---------------------------------------------
Returns the promotion cost for a primitive class . --> helper method --> Socre: 1.0

[[[[Adv]]]]: private static float [[getPrimitivePromotionCost]] ( final Class < ? > [[srcClass]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[srcClass]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .

[[[[Adv]]]]: private static float [[burdock]] ( final Class < ? > [[swan]] , final Class < ? > destClass ) { float cost = 0.0f ; Class < ? > cls = [[swan]] ; if ( ! cls . isPrimitive ( ) ) {
[[[[Nl]]]]: Gets the number of steps required to promote a primitive number to another type .
--------------------------------------------- Result 660 ---------------------------------------------
Registers a formatter for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public < T > [[Formatters]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T [[t]] , Locale locale ) { return formatter . print ( [[t]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .

[[[[Adv]]]]: public < T > [[Bassett]] register ( final Class < T > clazz , final SimpleFormatter < T > formatter ) { conversion . addFormatterForFieldType ( clazz , new org . springframework . format . Formatter < T > ( ) { public T parse ( String text , Locale locale ) throws java . text . ParseException { return formatter . parse ( text , locale ) ; } public String print ( T [[ubaldo]] , Locale locale ) { return formatter . print ( [[ubaldo]] , locale ) ; } public String toString ( ) { return formatter . toString ( ) ; } } ) ; return this ; }
[[[[Nl]]]]: Registers a simple formatter .
--------------------------------------------- Result 661 ---------------------------------------------
Gets the field with the given names . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void getField ( String [ ] names ) throws Exception { final CodeEmitter e = begin_method ( Constants . ACC_PUBLIC , PROVIDER_GET , null ) ; e . load_this ( ) ; e . load_arg ( 0 ) ; EmitUtils . string_switch ( e , names , Constants . SWITCH_STYLE_HASH , new ObjectSwitchCallback ( ) { public void processCase ( Object key , Label end ) { Type type = ( Type ) fields . get ( key ) ; e . getfield ( ( String ) key ) ; e . box ( type ) ; e . return_value ( ) ; } public void processDefault ( ) { e . throw_exception ( ILLEGAL_ARGUMENT_EXCEPTION , "Unknown field name" ) ; } } ) ; e . end_method ( ) ; }
[[[[Nl]]]]: to avoid JVM hashcode implementation incompatibilities
--------------------------------------------- Result 662 ---------------------------------------------
Sets the super class . --> setter for superclass --> Socre: 1.0

[[[[Adv]]]]: public void setSuperclass ( Class [[superclass]] ) { if ( [[superclass]] != null && [[superclass]] . equals ( Object . class ) ) { [[superclass]] = null ; } this . superclass = [[superclass]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .

[[[[Adv]]]]: public void setSuperclass ( Class [[refrigeration]] ) { if ( [[refrigeration]] != null && [[refrigeration]] . equals ( Object . class ) ) { [[refrigeration]] = null ; } this . superclass = [[refrigeration]] ; }
[[[[Nl]]]]: Set the class which the generated class will extend . The class must not be declared as final and must have a non - private no - argument constructor .
--------------------------------------------- Result 663 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 554 / 88 / 21 / 663:  66%|██████▋   | 663/1000 [5:47:16<2:56:31, 31.43s/it][Succeeded / Failed / Skipped / Total] 554 / 88 / 21 / 663:  66%|██████▋   | 664/1000 [5:47:51<2:56:01, 31.43s/it][Succeeded / Failed / Skipped / Total] 555 / 88 / 21 / 664:  66%|██████▋   | 664/1000 [5:47:51<2:56:01, 31.43s/it][Succeeded / Failed / Skipped / Total] 555 / 88 / 21 / 664:  66%|██████▋   | 665/1000 [5:47:52<2:55:14, 31.39s/it][Succeeded / Failed / Skipped / Total] 555 / 88 / 22 / 665:  66%|██████▋   | 665/1000 [5:47:52<2:55:14, 31.39s/it][Succeeded / Failed / Skipped / Total] 555 / 88 / 22 / 665:  67%|██████▋   | 666/1000 [5:47:59<2:54:31, 31.35s/it][Succeeded / Failed / Skipped / Total] 556 / 88 / 22 / 666:  67%|██████▋   | 666/1000 [5:47:59<2:54:31, 31.35s/it][Succeeded / Failed / Skipped / Total] 556 / 88 / 22 / 666:  67%|██████▋   | 667/1000 [5:48:08<2:53:48, 31.32s/it][Succeeded / Failed / Skipped / Total] 557 / 88 / 22 / 667:  67%|██████▋   | 667/1000 [5:48:08<2:53:48, 31.32s/it][Succeeded / Failed / Skipped / Total] 557 / 88 / 22 / 667:  67%|██████▋   | 668/1000 [5:48:30<2:53:12, 31.30s/it][Succeeded / Failed / Skipped / Total] 558 / 88 / 22 / 668:  67%|██████▋   | 668/1000 [5:48:30<2:53:12, 31.30s/it][Succeeded / Failed / Skipped / Total] 558 / 88 / 22 / 668:  67%|██████▋   | 669/1000 [5:48:35<2:52:28, 31.26s/it][Succeeded / Failed / Skipped / Total] 559 / 88 / 22 / 669:  67%|██████▋   | 669/1000 [5:48:35<2:52:28, 31.26s/it][Succeeded / Failed / Skipped / Total] 559 / 88 / 22 / 669:  67%|██████▋   | 670/1000 [5:48:54<2:51:51, 31.25s/it][Succeeded / Failed / Skipped / Total] 560 / 88 / 22 / 670:  67%|██████▋   | 670/1000 [5:48:54<2:51:51, 31.25s/it][Succeeded / Failed / Skipped / Total] 560 / 88 / 22 / 670:  67%|██████▋   | 671/1000 [5:49:06<2:51:10, 31.22s/it]Calculates the cardinality of the value --> [[[SKIPPED]]]

[[[[Adv]]]]: public int cardinality ( ) { int w = value ; int c = 0 ; while ( w != 0 ) { c += T [ w & 255 ] ; w >>= 8 ; } return c ; }
[[[[Nl]]]]: If bit 31 is set then this method results in an infinite loop .
--------------------------------------------- Result 664 ---------------------------------------------
Creates a database from the default configuration . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: public static Database [[createFrom]] ( String [[driver]] , String url , Map < String , ? extends Object > [[config]] ) { return [[createFrom]] ( "default" , [[driver]] , url , [[config]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .

[[[[Adv]]]]: public static Database [[avaunt]] ( String [[problematic]] , String url , Map < String , ? extends Object > [[pendragon]] ) { return [[avaunt]] ( "default" , [[problematic]] , url , [[pendragon]] ) ; }
[[[[Nl]]]]: Create a pooled database named default with the given configuration .
--------------------------------------------- Result 665 ---------------------------------------------
Finds the methods in the given array . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static Method [ ] findMethods ( String [ ] namesAndDescriptors , Method [ ] methods ) { Map map = new HashMap ( ) ; for ( int i = 0 ; i < methods . length ; i ++ ) { Method method = methods [ i ] ; map . put ( method . getName ( ) + Type . getMethodDescriptor ( method ) , method ) ; } Method [ ] result = new Method [ namesAndDescriptors . length / 2 ] ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = ( Method ) map . get ( namesAndDescriptors [ i * 2 ] + namesAndDescriptors [ i * 2 + 1 ] ) ; if ( result [ i ] == null ) {
[[[[Nl]]]]: used by MethodInterceptorGenerated generated code
--------------------------------------------- Result 666 ---------------------------------------------
Process an array . --> Dequeues a deque eigenvete eines eigenve --> Socre: 1.0

[[[[Adv]]]]: public static void [[process_array]] ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local [[array]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[array]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[array]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[array]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .

[[[[Adv]]]]: public static void [[demoiselle]] ( CodeEmitter e , Type type , ProcessArrayCallback callback ) { Type componentType = TypeUtils . getComponentType ( type ) ; Local [[mackerel]] = e . make_local ( ) ; Local loopvar = e . make_local ( Type . INT_TYPE ) ; Label loopbody = e . make_label ( ) ; Label checkloop = e . make_label ( ) ; e . store_local ( [[mackerel]] ) ; e . push ( 0 ) ; e . store_local ( loopvar ) ; e . goTo ( checkloop ) ; e . mark ( loopbody ) ; e . load_local ( [[mackerel]] ) ; e . load_local ( loopvar ) ; e . array_load ( componentType ) ; callback . processElement ( componentType ) ; e . iinc ( loopvar , 1 ) ; e . mark ( checkloop ) ; e . load_local ( loopvar ) ; e . load_local ( [[mackerel]] ) ; e . arraylength ( ) ; e . if_icmp ( e . LT , loopbody ) ; }
[[[[Nl]]]]: Process an array on the stack . Assumes the top item on the stack is an array of the specified type . For each element in the array puts the element on the stack and triggers the callback .
--------------------------------------------- Result 667 ---------------------------------------------
Reads a string from a file . --> Read a file into a String --> Socre: 1.0

[[[[Adv]]]]: public static String readString ( final Path [[path]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[path]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .

[[[[Adv]]]]: public static String readString ( final Path [[huys]] ) throws IOException { try ( BufferedReader reader = Files . newBufferedReader ( [[huys]] , StandardCharsets . UTF_8 ) ) { StringWriter writer = new StringWriter ( ) ;
[[[[Nl]]]]: Reads path content .
--------------------------------------------- Result 668 ---------------------------------------------
Add a method . --> Register faxing --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Method [[method]] ) { [[add]] ( ReflectUtils . getSignature ( [[method]] ) , ReflectUtils . getExceptionTypes ( [[method]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .

[[[[Adv]]]]: public void [[faxing]] ( Method [[ann]] ) { [[faxing]] ( ReflectUtils . getSignature ( [[ann]] ) , ReflectUtils . getExceptionTypes ( [[ann]] ) ) ; }
[[[[Nl]]]]: Add a method signature to the interface . The method modifiers are ignored since interface methods are by definition abstract and public .
--------------------------------------------- Result 669 ---------------------------------------------
Filter the given constructors in the given class . --> Get a club footer --> Socre: 1.0

[[[[Adv]]]]: protected void [[filterConstructors]] ( Class sc , List [[constructors]] ) { CollectionUtils . filter ( [[constructors]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[constructors]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .

[[[[Adv]]]]: protected void [[clubfoot]] ( Class sc , List [[campsite]] ) { CollectionUtils . filter ( [[campsite]] , new VisibilityPredicate ( sc , "True" == "True" ) ) ; if ( [[campsite]] . size ( ) == 0 ) throw new IllegalArgumentException ( "No visible constructors in " + sc ) ; }
[[[[Nl]]]]: Filter the list of constructors from the superclass . The constructors which remain will be included in the generated class . The default implementation is to filter out all private constructors but subclasses may extend Enhancer to override this behavior .
--------------------------------------------- Result 670 ---------------------------------------------
Resolve child path . --> Get slipper --> Socre: 1.0

[[[[Adv]]]]: public static Path [[resolve]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .

[[[[Adv]]]]: public static Path [[slipper]] ( final Path base , String child ) { if ( StringUtil . startsWithChar ( child , File . separatorChar ) ) { child = child . substring ( 1 ) ; } return base . resolve ( child ) ; }
[[[[Nl]]]]: Resolves subpath in safer way . For some reason if child starts with a separator it gets resolved as a full path ignoring the base . This method acts different .
--------------------------------------------- Result 671 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 561 / 88 / 22 / 671:  67%|██████▋   | 671/1000 [5:49:06<2:51:10, 31.22s/it][Succeeded / Failed / Skipped / Total] 561 / 88 / 22 / 671:  67%|██████▋   | 672/1000 [5:49:45<2:50:43, 31.23s/it][Succeeded / Failed / Skipped / Total] 562 / 88 / 22 / 672:  67%|██████▋   | 672/1000 [5:49:45<2:50:43, 31.23s/it][Succeeded / Failed / Skipped / Total] 562 / 88 / 22 / 672:  67%|██████▋   | 673/1000 [5:49:55<2:50:01, 31.20s/it][Succeeded / Failed / Skipped / Total] 563 / 88 / 22 / 673:  67%|██████▋   | 673/1000 [5:49:55<2:50:01, 31.20s/it][Succeeded / Failed / Skipped / Total] 563 / 88 / 22 / 673:  67%|██████▋   | 674/1000 [5:50:13<2:49:24, 31.18s/it][Succeeded / Failed / Skipped / Total] 564 / 88 / 22 / 674:  67%|██████▋   | 674/1000 [5:50:13<2:49:24, 31.18s/it][Succeeded / Failed / Skipped / Total] 564 / 88 / 22 / 674:  68%|██████▊   | 675/1000 [5:50:18<2:48:40, 31.14s/it][Succeeded / Failed / Skipped / Total] 565 / 88 / 22 / 675:  68%|██████▊   | 675/1000 [5:50:18<2:48:40, 31.14s/it][Succeeded / Failed / Skipped / Total] 565 / 88 / 22 / 675:  68%|██████▊   | 676/1000 [5:50:20<2:47:55, 31.10s/it][Succeeded / Failed / Skipped / Total] 566 / 88 / 22 / 676:  68%|██████▊   | 676/1000 [5:50:20<2:47:55, 31.10s/it][Succeeded / Failed / Skipped / Total] 566 / 88 / 22 / 676:  68%|██████▊   | 677/1000 [5:50:38<2:47:17, 31.08s/it][Succeeded / Failed / Skipped / Total] 567 / 88 / 22 / 677:  68%|██████▊   | 677/1000 [5:50:38<2:47:17, 31.08s/it][Succeeded / Failed / Skipped / Total] 567 / 88 / 22 / 677:  68%|██████▊   | 678/1000 [5:51:59<2:47:10, 31.15s/it][Succeeded / Failed / Skipped / Total] 568 / 88 / 22 / 678:  68%|██████▊   | 678/1000 [5:51:59<2:47:10, 31.15s/it][Succeeded / Failed / Skipped / Total] 568 / 88 / 22 / 678:  68%|██████▊   | 679/1000 [5:52:03<2:46:26, 31.11s/it][Succeeded / Failed / Skipped / Total] 569 / 88 / 22 / 679:  68%|██████▊   | 679/1000 [5:52:03<2:46:26, 31.11s/it][Succeeded / Failed / Skipped / Total] 569 / 88 / 22 / 679:  68%|██████▊   | 680/1000 [5:52:14<2:45:45, 31.08s/it][Succeeded / Failed / Skipped / Total] 570 / 88 / 22 / 680:  68%|██████▊   | 680/1000 [5:52:14<2:45:45, 31.08s/it][Succeeded / Failed / Skipped / Total] 570 / 88 / 22 / 680:  68%|██████▊   | 681/1000 [5:52:22<2:45:03, 31.05s/it][Succeeded / Failed / Skipped / Total] 571 / 88 / 22 / 681:  68%|██████▊   | 681/1000 [5:52:22<2:45:03, 31.05s/it][Succeeded / Failed / Skipped / Total] 571 / 88 / 22 / 681:  68%|██████▊   | 682/1000 [5:52:35<2:44:24, 31.02s/it]Start a connect request --> Start HTTP connection --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest connect ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .

[[[[Adv]]]]: public static HttpRequest connect ( final String [[saya]] ) { return new HttpRequest ( ) . method ( HttpMethod . CONNECT ) . set ( [[saya]] ) ; }
[[[[Nl]]]]: Builds a CONNECT request .
--------------------------------------------- Result 672 ---------------------------------------------
Sets the naming policy . --> Set an enriched NamingPolicy --> Socre: 1.0

[[[[Adv]]]]: public void [[setNamingPolicy]] ( NamingPolicy [[namingPolicy]] ) { if ( [[namingPolicy]] == null ) [[namingPolicy]] = DefaultNamingPolicy . INSTANCE ; this . [[namingPolicy]] = [[namingPolicy]] ; }
[[[[Nl]]]]: Override the default naming policy .

[[[[Adv]]]]: public void [[abolition]] ( NamingPolicy [[enriched]] ) { if ( [[enriched]] == null ) [[enriched]] = DefaultNamingPolicy . INSTANCE ; this . [[antónio]] = [[enriched]] ; }
[[[[Nl]]]]: Override the default naming policy .
--------------------------------------------- Result 673 ---------------------------------------------
Create an HttpRequest with the given method and destination . --> Create HttpRequest with GHTH --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String [[destination]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .

[[[[Adv]]]]: public static HttpRequest create ( final String method , final String [[ght]] ) { return new HttpRequest ( ) . method ( method . toUpperCase ( ) ) . set ( [[ght]] ) ; }
[[[[Nl]]]]: Generic request builder usually used when method is a variable . Otherwise use one of the other static request builder methods .
--------------------------------------------- Result 674 ---------------------------------------------
Create a PUT request --> Operations on the given destination --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[put]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .

[[[[Adv]]]]: public static HttpRequest [[operational]] ( final String destination ) { return new HttpRequest ( ) . method ( HttpMethod . PUT ) . set ( destination ) ; }
[[[[Nl]]]]: Builds a PUT request .
--------------------------------------------- Result 675 ---------------------------------------------
Sets the Http request host . --> Set the HttpServer that will be sent to --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[host]] ( final String [[host]] ) { this . host = [[host]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[host]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .

[[[[Adv]]]]: public HttpRequest [[everthing]] ( final String [[tutto]] ) { this . host = [[everthing]] ; if ( headers . contains ( HEADER_HOST ) ) { headerOverwrite ( HEADER_HOST , [[everthing]] ) ; } return this ; }
[[[[Nl]]]]: Sets request host name .
--------------------------------------------- Result 676 ---------------------------------------------
Create a GET request --> Updates evidence --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[get]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a GET request .

[[[[Adv]]]]: public static HttpRequest [[evidence]] ( final String [[saratoga]] ) { return new HttpRequest ( ) . method ( HttpMethod . GET ) . set ( [[saratoga]] ) ; }
[[[[Nl]]]]: Builds a GET request .
--------------------------------------------- Result 677 ---------------------------------------------
Create a POST request --> Send mephist alleles --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[post]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a POST request .

[[[[Adv]]]]: public static HttpRequest [[mephistopheles]] ( final String [[airplay]] ) { return new HttpRequest ( ) . method ( HttpMethod . POST ) . set ( [[airplay]] ) ; }
[[[[Nl]]]]: Builds a POST request .
--------------------------------------------- Result 678 ---------------------------------------------
Create a HEAD request --> Perform an operation to perform an operation --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[head]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .

[[[[Adv]]]]: public static HttpRequest [[operational]] ( final String [[birdbrain]] ) { return new HttpRequest ( ) . method ( HttpMethod . HEAD ) . set ( [[birdbrain]] ) ; }
[[[[Nl]]]]: Builds a HEAD request .
--------------------------------------------- Result 679 ---------------------------------------------
Start a TRACE request --> Indicates that the patient is advertised --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[trace]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .

[[[[Adv]]]]: public static HttpRequest [[advertises]] ( final String [[clinical]] ) { return new HttpRequest ( ) . method ( HttpMethod . TRACE ) . set ( [[clinical]] ) ; }
[[[[Nl]]]]: Builds a TRACE request .
--------------------------------------------- Result 680 ---------------------------------------------
Creates a OPTIONS request --> Specifies that the margins should be updated --> Socre: 1.0

[[[[Adv]]]]: public static HttpRequest [[options]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .

[[[[Adv]]]]: public static HttpRequest [[margins]] ( final String [[abyssal]] ) { return new HttpRequest ( ) . method ( HttpMethod . OPTIONS ) . set ( [[abyssal]] ) ; }
[[[[Nl]]]]: Builds an OPTIONS request .
--------------------------------------------- Result 681 ---------------------------------------------
Sets the cookies in the request . --> Set Cookie header --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[cookieString]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[cookieString]] . append ( "; " ) ; } first = "False" != "False" ; [[cookieString]] . append ( cookie . getName ( ) ) ; [[cookieString]] . append ( ' ' ) ; [[cookieString]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[cookieString]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .

[[[[Adv]]]]: public HttpRequest REPLACEME0 ( final Cookie ... REPLACEME0 ) { if ( REPLACEME0 . length == 0 ) { return this ; } StringBuilder [[corso]] = new StringBuilder ( ) ; boolean first = "True" == "True" ; for ( Cookie cookie : REPLACEME0 ) { Integer maxAge = cookie . getMaxAge ( ) ; if ( maxAge != null && maxAge . intValue ( ) == 0 ) { continue ; } if ( ! first ) { [[corso]] . append ( "; " ) ; } first = "False" != "False" ; [[corso]] . append ( cookie . getName ( ) ) ; [[corso]] . append ( ' ' ) ; [[corso]] . append ( cookie . getValue ( ) ) ; } headerOverwrite ( "cookie" , [[corso]] . toString ( ) ) ; return this ; }
[[[[Nl]]]]: Sets cookies to the request .
--------------------------------------------- Result 682 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 571 / 89 / 22 / 682:  68%|██████▊   | 682/1000 [5:52:35<2:44:24, 31.02s/it][Succeeded / Failed / Skipped / Total] 571 / 89 / 22 / 682:  68%|██████▊   | 683/1000 [5:52:39<2:43:40, 30.98s/it][Succeeded / Failed / Skipped / Total] 572 / 89 / 22 / 683:  68%|██████▊   | 683/1000 [5:52:39<2:43:40, 30.98s/it][Succeeded / Failed / Skipped / Total] 572 / 89 / 22 / 683:  68%|██████▊   | 684/1000 [5:52:42<2:42:56, 30.94s/it][Succeeded / Failed / Skipped / Total] 572 / 90 / 22 / 684:  68%|██████▊   | 684/1000 [5:52:42<2:42:56, 30.94s/it][Succeeded / Failed / Skipped / Total] 572 / 90 / 22 / 684:  68%|██████▊   | 685/1000 [5:52:47<2:42:14, 30.90s/it][Succeeded / Failed / Skipped / Total] 573 / 90 / 22 / 685:  68%|██████▊   | 685/1000 [5:52:47<2:42:14, 30.90s/it][Succeeded / Failed / Skipped / Total] 573 / 90 / 22 / 685:  69%|██████▊   | 686/1000 [5:53:17<2:41:42, 30.90s/it][Succeeded / Failed / Skipped / Total] 573 / 91 / 22 / 686:  69%|██████▊   | 686/1000 [5:53:17<2:41:42, 30.90s/it][Succeeded / Failed / Skipped / Total] 573 / 91 / 22 / 686:  69%|██████▊   | 687/1000 [5:53:18<2:40:57, 30.86s/it][Succeeded / Failed / Skipped / Total] 573 / 92 / 22 / 687:  69%|██████▊   | 687/1000 [5:53:18<2:40:57, 30.86s/it][Succeeded / Failed / Skipped / Total] 573 / 92 / 22 / 687:  69%|██████▉   | 688/1000 [5:53:24<2:40:15, 30.82s/it][Succeeded / Failed / Skipped / Total] 574 / 92 / 22 / 688:  69%|██████▉   | 688/1000 [5:53:24<2:40:15, 30.82s/it][Succeeded / Failed / Skipped / Total] 574 / 92 / 22 / 688:  69%|██████▉   | 689/1000 [5:53:27<2:39:32, 30.78s/it][Succeeded / Failed / Skipped / Total] 575 / 92 / 22 / 689:  69%|██████▉   | 689/1000 [5:53:27<2:39:32, 30.78s/it][Succeeded / Failed / Skipped / Total] 575 / 92 / 22 / 689:  69%|██████▉   | 690/1000 [5:53:32<2:38:50, 30.74s/it][Succeeded / Failed / Skipped / Total] 576 / 92 / 22 / 690:  69%|██████▉   | 690/1000 [5:53:32<2:38:50, 30.74s/it][Succeeded / Failed / Skipped / Total] 576 / 92 / 22 / 690:  69%|██████▉   | 691/1000 [5:53:40<2:38:09, 30.71s/it]Resolves all bridge dependencies . --> [[[FAILED]]]

[[[[Adv]]]]: public Map [[resolveAll]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[owner]] = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[owner]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .

[[[[Adv]]]]: public Map [[chancery]] ( ) { Map resolved = new HashMap ( ) ; for ( Iterator entryIter = declToBridge . entrySet ( ) . iterator ( ) ; entryIter . hasNext ( ) ; ) { Map . Entry entry = ( Map . Entry ) entryIter . next ( ) ; Class [[engrossed]] = ( Class ) entry . getKey ( ) ; Set bridges = ( Set ) entry . getValue ( ) ; try { InputStream is = classLoader . getResourceAsStream ( [[engrossed]] . getName ( ) . replace ( ' ' , ' ' ) + ".class" ) ; if ( is == null ) { return resolved ; } try { new ClassReader ( is ) . accept ( new BridgedFinder ( bridges , resolved ) , ClassReader . SKIP_FRAMES | ClassReader . SKIP_DEBUG ) ; } finally { is . close ( ) ; } } catch ( IOException ignored ) { } } return resolved ; }
[[[[Nl]]]]: Finds all bridge methods that are being called with invokespecial & returns them .
--------------------------------------------- Result 683 ---------------------------------------------
Add query parameters . --> Add a query --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[query]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { [[query]] . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .

[[[[Adv]]]]: public HttpRequest [[clinic]] ( final Map < String , String > queryMap ) { for ( Map . Entry < String , String > entry : queryMap . entrySet ( ) ) { [[clinic]] . add ( entry . getKey ( ) , entry . getValue ( ) ) ; } return this ; }
[[[[Nl]]]]: Adds all parameters from the provided map .
--------------------------------------------- Result 684 ---------------------------------------------
Start a HTTP POST request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[patch]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .

[[[[Adv]]]]: public static HttpRequest [[biblically]] ( final String [[enthusiasts]] ) { return new HttpRequest ( ) . method ( HttpMethod . PATCH ) . set ( [[enthusiasts]] ) ; }
[[[[Nl]]]]: Builds a PATCH request .
--------------------------------------------- Result 685 ---------------------------------------------
Gets the query string . --> Builds a count --> Socre: 1.0

[[[[Adv]]]]: public String [[queryString]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .

[[[[Adv]]]]: public String [[counted]] ( ) { if ( query == null ) { return StringPool . EMPTY ; } return HttpUtil . buildQuery ( query , queryEncoding ) ; }
[[[[Nl]]]]: Generates query string . All values are URL encoded .
--------------------------------------------- Result 686 ---------------------------------------------
Create a DELETE request --> [[[FAILED]]]

[[[[Adv]]]]: public static HttpRequest [[delete]] ( final String [[destination]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[destination]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .

[[[[Adv]]]]: public static HttpRequest [[lauri]] ( final String [[humans]] ) { return new HttpRequest ( ) . method ( HttpMethod . DELETE ) . set ( [[humans]] ) ; }
[[[[Nl]]]]: Builds a DELETE request .
--------------------------------------------- Result 687 ---------------------------------------------
Determine the cost of a class from the source class and destinationClass . --> [[[FAILED]]]

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .

[[[[Adv]]]]: private static float getObjectTransformationCost ( Class < ? > srcClass , final Class < ? > destClass ) { if ( destClass . isPrimitive ( ) ) { return getPrimitivePromotionCost ( srcClass , destClass ) ; } float cost = 0.0f ; while ( srcClass != null && ! destClass . equals ( srcClass ) ) { if ( destClass . isInterface ( ) && ClassUtils . isAssignable ( srcClass , destClass ) ) { * If the destination class is null, we've traveled all the way up to * an Object match. We'll penalize this by adding 1.5 to the cost. */ if ( srcClass == null ) { cost += 1.5f ; } return cost ; }
[[[[Nl]]]]: Gets the number of steps required needed to turn the source class into the destination class . This represents the number of steps in the object hierarchy graph .
--------------------------------------------- Result 688 ---------------------------------------------
Sets the request path . --> setter for cm --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[path]] ( String [[path]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .

[[[[Adv]]]]: public HttpRequest [[cmc]] ( String [[tungsten]] ) {
[[[[Nl]]]]: Sets request path . Query string is allowed . Adds a slash if path doesn t start with one . Query will be stripped out from the path . Previous query is discarded .
--------------------------------------------- Result 689 ---------------------------------------------
Returns the buffer as a buffer . --> region ComputeBuffer --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[fullRequest]] ) {
[[[[Nl]]]]: Prepares the request buffer .

[[[[Adv]]]]: @ Override protected Buffer buffer ( final boolean [[malfeasance]] ) {
[[[[Nl]]]]: Prepares the request buffer .
--------------------------------------------- Result 690 ---------------------------------------------
Send and receive response . --> Execute and receive the response --> Socre: 1.0

[[[[Adv]]]]: public < [[R]] > [[R]] sendAndReceive ( final Function < HttpResponse , [[R]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .

[[[[Adv]]]]: public < [[experimenter]] > [[experimenter]] sendAndReceive ( final Function < HttpResponse , [[experimenter]] > responseHandler ) { return responseHandler . apply ( send ( ) ) ; }
[[[[Nl]]]]: Syntax sugar .
--------------------------------------------- Result 691 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 577 / 92 / 22 / 691:  69%|██████▉   | 691/1000 [5:53:40<2:38:09, 30.71s/it][Succeeded / Failed / Skipped / Total] 577 / 92 / 22 / 691:  69%|██████▉   | 692/1000 [5:53:50<2:37:29, 30.68s/it][Succeeded / Failed / Skipped / Total] 578 / 92 / 22 / 692:  69%|██████▉   | 692/1000 [5:53:50<2:37:29, 30.68s/it][Succeeded / Failed / Skipped / Total] 578 / 92 / 22 / 692:  69%|██████▉   | 693/1000 [5:54:00<2:36:49, 30.65s/it][Succeeded / Failed / Skipped / Total] 579 / 92 / 22 / 693:  69%|██████▉   | 693/1000 [5:54:00<2:36:49, 30.65s/it][Succeeded / Failed / Skipped / Total] 579 / 92 / 22 / 693:  69%|██████▉   | 694/1000 [5:54:04<2:36:07, 30.61s/it][Succeeded / Failed / Skipped / Total] 580 / 92 / 22 / 694:  69%|██████▉   | 694/1000 [5:54:04<2:36:07, 30.61s/it][Succeeded / Failed / Skipped / Total] 580 / 92 / 22 / 694:  70%|██████▉   | 695/1000 [5:54:13<2:35:26, 30.58s/it][Succeeded / Failed / Skipped / Total] 581 / 92 / 22 / 695:  70%|██████▉   | 695/1000 [5:54:13<2:35:26, 30.58s/it][Succeeded / Failed / Skipped / Total] 581 / 92 / 22 / 695:  70%|██████▉   | 696/1000 [5:54:16<2:34:44, 30.54s/it][Succeeded / Failed / Skipped / Total] 582 / 92 / 22 / 696:  70%|██████▉   | 696/1000 [5:54:16<2:34:44, 30.54s/it][Succeeded / Failed / Skipped / Total] 582 / 92 / 22 / 696:  70%|██████▉   | 697/1000 [5:54:22<2:34:03, 30.51s/it][Succeeded / Failed / Skipped / Total] 583 / 92 / 22 / 697:  70%|██████▉   | 697/1000 [5:54:22<2:34:03, 30.51s/it][Succeeded / Failed / Skipped / Total] 583 / 92 / 22 / 697:  70%|██████▉   | 698/1000 [5:54:29<2:33:22, 30.47s/it][Succeeded / Failed / Skipped / Total] 584 / 92 / 22 / 698:  70%|██████▉   | 698/1000 [5:54:29<2:33:22, 30.47s/it][Succeeded / Failed / Skipped / Total] 584 / 92 / 22 / 698:  70%|██████▉   | 699/1000 [5:54:53<2:32:49, 30.46s/it][Succeeded / Failed / Skipped / Total] 585 / 92 / 22 / 699:  70%|██████▉   | 699/1000 [5:54:53<2:32:49, 30.46s/it][Succeeded / Failed / Skipped / Total] 585 / 92 / 22 / 699:  70%|███████   | 700/1000 [5:55:18<2:32:16, 30.46s/it]Remove range . --> Implementation of artAudit --> Socre: 1.0

[[[[Adv]]]]: static Handler [[removeRange]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[removeRange]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .

[[[[Adv]]]]: static Handler [[artaud]] ( final Handler firstHandler , final Label start , final Label end ) { if ( firstHandler == null ) { return null ; } else { firstHandler . nextHandler = [[artaud]] ( firstHandler . nextHandler , start , end ) ; } int handlerStart = firstHandler . startPc . bytecodeOffset ; int handlerEnd = firstHandler . endPc . bytecodeOffset ; int rangeStart = start . bytecodeOffset ; int rangeEnd = end == null ? Integer . MAX_VALUE : end . bytecodeOffset ;
[[[[Nl]]]]: Removes the range between start and end from the Handler list that begins with the given element .
--------------------------------------------- Result 692 ---------------------------------------------
Sets the query parameter . --> Set the Http request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[queryString]] ( final String queryString , final boolean [[decode]] ) { this . query = HttpUtil . parseQuery ( [[queryString]] , [[decode]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .

[[[[Adv]]]]: public HttpRequest [[ash]] ( final String queryString , final boolean [[scientifically]] ) { this . query = HttpUtil . parseQuery ( [[ash]] , [[scientifically]] ) ; return this ; }
[[[[Nl]]]]: Sets query from provided query string . Previous query values are discarded .
--------------------------------------------- Result 693 ---------------------------------------------
Returns the host URL . --> Generates a javad string --> Socre: 1.0

[[[[Adv]]]]: public String [[hostUrl]] ( ) { StringBand [[url]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[url]] . append ( protocol ) ; [[url]] . append ( "://" ) ; } if ( host != null ) { [[url]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[url]] . append ( ' ' ) ; [[url]] . append ( port ) ; } return [[url]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .

[[[[Adv]]]]: public String [[bandwagon]] ( ) { StringBand [[mané]] = new StringBand ( 8 ) ; if ( protocol != null ) { [[mané]] . append ( protocol ) ; [[mané]] . append ( "://" ) ; } if ( host != null ) { [[mané]] . append ( host ) ; } if ( port != Defaults . DEFAULT_PORT ) { [[mané]] . append ( ' ' ) ; [[mané]] . append ( port ) ; } return [[mané]] . toString ( ) ; }
[[[[Nl]]]]: Returns just host url without path and query .
--------------------------------------------- Result 694 ---------------------------------------------
Collects all the action filters . --> duplicate uis --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionFilters]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .

[[[[Adv]]]]: protected void [[dupuis]] ( ) { final Collection < ? extends ActionFilter > filterValues = filtersManager . getAllFilters ( ) ; filters = new ArrayList <> ( ) ; filters . addAll ( filterValues ) ; filters . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all filters .
--------------------------------------------- Result 695 ---------------------------------------------
Collect all action runs sorted by their path . --> Sort the dependencies --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionRuntimes]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .

[[[[Adv]]]]: protected void [[dependence]] ( ) { actions = actionsManager . getAllActionRuntimes ( ) ; actions . sort ( Comparator . comparing ( ActionRuntime :: getActionPath ) ) ; }
[[[[Nl]]]]: Collects all action runtime configurations .
--------------------------------------------- Result 696 ---------------------------------------------
Collect all action results . --> Calculate koenc --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionResults]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .

[[[[Adv]]]]: protected void [[koen]] ( ) { final Collection < ActionResult > resultsValues = resultsManager . getAllActionResults ( ) ; results = new ArrayList <> ( ) ; results . addAll ( resultsValues ) ; results . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all action results .
--------------------------------------------- Result 697 ---------------------------------------------
Sets a simple property . --> helper method to do bashful --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[setSimpleProperty]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected void [[bashful]] ( final BeanProperty bp , final Object value ) { Setter setter = bp . getSetter ( isDeclared ) ;
[[[[Nl]]]]: Sets a value of simple property .
--------------------------------------------- Result 698 ---------------------------------------------
Sets the host header . --> Set the sunshiny proxy for this request --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[setHostHeader]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .

[[[[Adv]]]]: public HttpRequest [[sunshiny]] ( ) { String hostPort = this . host ; if ( port != Defaults . DEFAULT_PORT ) { hostPort += StringPool . COLON + port ; } headerOverwrite ( HEADER_HOST , hostPort ) ; return this ; }
[[[[Nl]]]]: Sets Host header from current host and port .
--------------------------------------------- Result 699 ---------------------------------------------
Adds a query parameter to the request . --> Add a set of items --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest query ( final String [[name1]] , final Object [[value1]] , final Object ... [[parameters]] ) { query ( [[name1]] , [[value1]] == null ? null : [[value1]] . toString ( ) ) ; for ( int i = 0 ; i < [[parameters]] . length ; i += 2 ) { String name = [[parameters]] [ i ] . toString ( ) ; String value = [[parameters]] [ i + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .

[[[[Adv]]]]: public HttpRequest query ( final String [[teodoro]] , final Object [[explicit]] , final Object ... [[basket]] ) { query ( [[teodoro]] , [[explicit]] == null ? null : [[explicit]] . toString ( ) ) ; for ( int i = 0 ; i < [[basket]] . length ; i += 2 ) { String name = [[basket]] [ i ] . toString ( ) ; String value = [[basket]] [ i + 1 ] . toString ( ) ; query . add ( name , value ) ; } return this ; }
[[[[Nl]]]]: Adds many query parameters at once . Although it accepts objects each value will be converted to string .
[Succeeded / Failed / Skipped / Total] 586 / 92 / 22 / 700:  70%|███████   | 700/1000 [5:55:18<2:32:16, 30.46s/it][Succeeded / Failed / Skipped / Total] 586 / 92 / 22 / 700:  70%|███████   | 701/1000 [5:55:25<2:31:36, 30.42s/it][Succeeded / Failed / Skipped / Total] 587 / 92 / 22 / 701:  70%|███████   | 701/1000 [5:55:25<2:31:36, 30.42s/it][Succeeded / Failed / Skipped / Total] 587 / 92 / 22 / 701:  70%|███████   | 702/1000 [5:55:28<2:30:53, 30.38s/it][Succeeded / Failed / Skipped / Total] 588 / 92 / 22 / 702:  70%|███████   | 702/1000 [5:55:28<2:30:53, 30.38s/it][Succeeded / Failed / Skipped / Total] 588 / 92 / 22 / 702:  70%|███████   | 703/1000 [5:55:41<2:30:16, 30.36s/it][Succeeded / Failed / Skipped / Total] 589 / 92 / 22 / 703:  70%|███████   | 703/1000 [5:55:41<2:30:16, 30.36s/it][Succeeded / Failed / Skipped / Total] 589 / 92 / 22 / 703:  70%|███████   | 704/1000 [5:56:02<2:29:42, 30.34s/it][Succeeded / Failed / Skipped / Total] 589 / 93 / 22 / 704:  70%|███████   | 704/1000 [5:56:02<2:29:42, 30.34s/it][Succeeded / Failed / Skipped / Total] 589 / 93 / 22 / 704:  70%|███████   | 705/1000 [5:57:02<2:29:23, 30.39s/it][Succeeded / Failed / Skipped / Total] 590 / 93 / 22 / 705:  70%|███████   | 705/1000 [5:57:02<2:29:23, 30.39s/it][Succeeded / Failed / Skipped / Total] 590 / 93 / 22 / 705:  71%|███████   | 706/1000 [5:58:00<2:29:05, 30.43s/it][Succeeded / Failed / Skipped / Total] 591 / 93 / 22 / 706:  71%|███████   | 706/1000 [5:58:00<2:29:05, 30.43s/it][Succeeded / Failed / Skipped / Total] 591 / 93 / 22 / 706:  71%|███████   | 707/1000 [5:58:07<2:28:25, 30.39s/it][Succeeded / Failed / Skipped / Total] 592 / 93 / 22 / 707:  71%|███████   | 707/1000 [5:58:07<2:28:25, 30.39s/it][Succeeded / Failed / Skipped / Total] 592 / 93 / 22 / 707:  71%|███████   | 708/1000 [5:58:10<2:27:43, 30.35s/it][Succeeded / Failed / Skipped / Total] 593 / 93 / 22 / 708:  71%|███████   | 708/1000 [5:58:10<2:27:43, 30.35s/it][Succeeded / Failed / Skipped / Total] 593 / 93 / 22 / 708:  71%|███████   | 709/1000 [5:58:20<2:27:04, 30.32s/it]--------------------------------------------- Result 700 ---------------------------------------------
Sets the basic authentication header . --> Encode cackling --> Socre: 1.0

[[[[Adv]]]]: public HttpRequest [[basicAuthentication]] ( final String [[username]] , final String password ) { if ( [[username]] != null && password != null ) { String data = [[username]] . concat ( StringPool . COLON ) . concat ( password ) ; String [[base64]] = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[base64]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .

[[[[Adv]]]]: public HttpRequest [[cackling]] ( final String [[mcleod]] , final String password ) { if ( [[mcleod]] != null && password != null ) { String data = [[mcleod]] . concat ( StringPool . COLON ) . concat ( password ) ; String [[bouche]] = Base64 . encodeToString ( data ) ; headerOverwrite ( HEADER_AUTHORIZATION , "Basic " + [[bouche]] ) ; } return this ; }
[[[[Nl]]]]: Enables basic authentication by adding required header .
--------------------------------------------- Result 701 ---------------------------------------------
Get object reference . --> Get stainer by name --> Socre: 1.0

[[[[Adv]]]]: public Object [[getObjectReference]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .

[[[[Adv]]]]: public Object [[stainer]] ( final String name ) { if ( objectRefs == null ) { return null ; } return objectRefs . get ( name ) ; }
[[[[Nl]]]]: Returns object reference .
--------------------------------------------- Result 702 ---------------------------------------------
Collects all interceptors . --> helper method to barcodes --> Socre: 1.0

[[[[Adv]]]]: protected void [[collectActionInterceptors]] ( ) { final Collection < ? extends ActionInterceptor > [[interceptorValues]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[interceptorValues]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .

[[[[Adv]]]]: protected void [[barletta]] ( ) { final Collection < ? extends ActionInterceptor > [[napkins]] = interceptorsManager . getAllInterceptors ( ) ; interceptors = new ArrayList <> ( ) ; interceptors . addAll ( [[napkins]] ) ; interceptors . sort ( Comparator . comparing ( a -> a . getClass ( ) . getSimpleName ( ) ) ) ; }
[[[[Nl]]]]: Collects all interceptors .
--------------------------------------------- Result 703 ---------------------------------------------
Sets an object reference . --> Zoakakakakke --> Socre: 1.0

[[[[Adv]]]]: public void [[setObjectReference]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .

[[[[Adv]]]]: public void [[zodiak]] ( final String name , final Object object ) { if ( objectRefs == null ) { objectRefs = new HashMap <> ( ) ; } objectRefs . put ( name , object ) ; }
[[[[Nl]]]]: Saves object reference .
--------------------------------------------- Result 704 ---------------------------------------------
Returns the writer . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public PrintWriter [[getWriter]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .

[[[[Adv]]]]: @ Override public PrintWriter [[woodsmen]] ( ) { if ( writer == null ) { writer = new FastCharArrayWriter ( ) ; printWriter = new PrintWriter ( writer ) ; } return printWriter ; }
[[[[Nl]]]]: Returns buffered writer . Buffer will be created if not already used .
--------------------------------------------- Result 705 ---------------------------------------------
Find table descriptor by column ref . --> Find EquipmentDescriptor by columnref --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String [[columnRef]] ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[ded]] = entry . getValue ( ) . desc ; if ( [[ded]] . findByPropertyName ( [[columnRef]] ) != null ) { return [[ded]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .

[[[[Adv]]]]: public DbEntityDescriptor findTableDescriptorByColumnRef ( final String [[coldly]] ) { for ( Map . Entry < String , TableRefData > entry : tableRefs . entrySet ( ) ) { DbEntityDescriptor [[industrial]] = entry . getValue ( ) . desc ; if ( [[industrial]] . findByPropertyName ( [[coldly]] ) != null ) { return [[industrial]] ; } } return null ; }
[[[[Nl]]]]: Finds entity descriptor of a table that contains provided column reference .
--------------------------------------------- Result 706 ---------------------------------------------
Register a table reference . --> Register a franzas --> Socre: 1.0

[[[[Adv]]]]: public void [[registerTableReference]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .

[[[[Adv]]]]: public void [[franz]] ( final String tableReference , final DbEntityDescriptor ded , final String tableAlias ) { if ( tableRefs == null ) { tableRefs = new HashMap <> ( ) ; } TableRefData t = new TableRefData ( ded , tableAlias ) ; if ( tableRefs . put ( tableReference , t ) != null ) { throw new DbSqlBuilderException ( "Duplicated table reference: " + tableReference ) ; } }
[[[[Nl]]]]: Registers table reference for provided entity .
--------------------------------------------- Result 707 ---------------------------------------------
Returns the descriptor for the given table reference . --> Get or null if not found --> Socre: 1.0

[[[[Adv]]]]: public DbEntityDescriptor [[getTableDescriptor]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .

[[[[Adv]]]]: public DbEntityDescriptor [[anchovy]] ( final String [[mimicking]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[mimicking]] ) ; return t == null ? null : t . desc ; }
[[[[Nl]]]]: Returns entity descriptor for provided table reference .
--------------------------------------------- Result 708 ---------------------------------------------
Lookup an object reference . --> Find the collision with the given simpkins --> Socre: 1.0

[[[[Adv]]]]: public Object [[lookupObject]] ( final String [[ref]] ) { Object [[value]] = getObjectReference ( [[ref]] ) ; if ( [[value]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[ref]] ) ; } return [[value]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .

[[[[Adv]]]]: public Object [[collided]] ( final String [[simpkins]] ) { Object [[angeli]] = getObjectReference ( [[simpkins]] ) ; if ( [[angeli]] == null ) { throw new DbSqlBuilderException ( "Invalid object reference: " + [[simpkins]] ) ; } return [[angeli]] ; }
[[[[Nl]]]]: Lookups for object reference and throws an exception if reference doesn t exist .
--------------------------------------------- Result 709 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 594 / 93 / 22 / 709:  71%|███████   | 709/1000 [5:58:20<2:27:04, 30.32s/it][Succeeded / Failed / Skipped / Total] 594 / 93 / 22 / 709:  71%|███████   | 710/1000 [5:58:44<2:26:31, 30.32s/it][Succeeded / Failed / Skipped / Total] 595 / 93 / 22 / 710:  71%|███████   | 710/1000 [5:58:44<2:26:31, 30.32s/it][Succeeded / Failed / Skipped / Total] 595 / 93 / 22 / 710:  71%|███████   | 711/1000 [5:59:06<2:25:58, 30.30s/it][Succeeded / Failed / Skipped / Total] 596 / 93 / 22 / 711:  71%|███████   | 711/1000 [5:59:06<2:25:58, 30.30s/it][Succeeded / Failed / Skipped / Total] 596 / 93 / 22 / 711:  71%|███████   | 712/1000 [5:59:27<2:25:23, 30.29s/it][Succeeded / Failed / Skipped / Total] 596 / 94 / 22 / 712:  71%|███████   | 712/1000 [5:59:27<2:25:23, 30.29s/it][Succeeded / Failed / Skipped / Total] 596 / 94 / 22 / 712:  71%|███████▏  | 713/1000 [5:59:30<2:24:42, 30.25s/it][Succeeded / Failed / Skipped / Total] 596 / 95 / 22 / 713:  71%|███████▏  | 713/1000 [5:59:30<2:24:42, 30.25s/it][Succeeded / Failed / Skipped / Total] 596 / 95 / 22 / 713:  71%|███████▏  | 714/1000 [6:00:47<2:24:31, 30.32s/it][Succeeded / Failed / Skipped / Total] 597 / 95 / 22 / 714:  71%|███████▏  | 714/1000 [6:00:47<2:24:31, 30.32s/it][Succeeded / Failed / Skipped / Total] 597 / 95 / 22 / 714:  72%|███████▏  | 715/1000 [6:00:51<2:23:50, 30.28s/it][Succeeded / Failed / Skipped / Total] 597 / 96 / 22 / 715:  72%|███████▏  | 715/1000 [6:00:51<2:23:50, 30.28s/it][Succeeded / Failed / Skipped / Total] 597 / 96 / 22 / 715:  72%|███████▏  | 716/1000 [6:00:54<2:23:09, 30.24s/it][Succeeded / Failed / Skipped / Total] 598 / 96 / 22 / 716:  72%|███████▏  | 716/1000 [6:00:54<2:23:09, 30.24s/it][Succeeded / Failed / Skipped / Total] 598 / 96 / 22 / 716:  72%|███████▏  | 717/1000 [6:01:13<2:22:34, 30.23s/it][Succeeded / Failed / Skipped / Total] 599 / 96 / 22 / 717:  72%|███████▏  | 717/1000 [6:01:13<2:22:34, 30.23s/it][Succeeded / Failed / Skipped / Total] 599 / 96 / 22 / 717:  72%|███████▏  | 718/1000 [6:01:45<2:22:05, 30.23s/it]Appends the value to the given context . --> Helper method for serialization --> Socre: 1.0

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[jsonContext]] , final T value ) { if ( [[jsonContext]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .

[[[[Adv]]]]: @ Override public final boolean serialize ( final JsonContext [[beeblebrox]] , final T value ) { if ( [[beeblebrox]] . pushValue ( value ) ) {
[[[[Nl]]]]: Detects circular dependencies and pushes value as current type context .
--------------------------------------------- Result 710 ---------------------------------------------
Returns the table alias for the given table reference . --> Get the index of a column --> Socre: 1.0

[[[[Adv]]]]: public String [[getTableAlias]] ( final String [[tableRef]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[tableRef]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .

[[[[Adv]]]]: public String [[cardiogram]] ( final String [[smote]] ) { if ( tableRefs == null ) { return null ; } TableRefData t = tableRefs . get ( [[smote]] ) ; return t == null ? null : t . alias ; }
[[[[Nl]]]]: Returns table alias for provided table reference .
--------------------------------------------- Result 711 ---------------------------------------------
Extract property from property name --> Given a human - readable human - readable human - readable human - readable human - readable --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[extractThisReference]] ( final String [[propertyName]] ) { int [[ndx]] = StringUtil . indexOfChars ( [[propertyName]] , INDEX_CHARS ) ; if ( [[ndx]] == - 1 ) { return [[propertyName]] ; } return [[propertyName]] . substring ( 0 , [[ndx]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .

[[[[Adv]]]]: @ Override public String [[campfires]] ( final String [[humans]] ) { int [[polacks]] = StringUtil . indexOfChars ( [[humans]] , INDEX_CHARS ) ; if ( [[polacks]] == - 1 ) { return [[humans]] ; } return [[humans]] . substring ( 0 , [[polacks]] ) ; }
[[[[Nl]]]]: Extract the first name of this reference .
--------------------------------------------- Result 712 ---------------------------------------------
Returns the length of the exception table . --> [[[FAILED]]]

[[[[Adv]]]]: static int [[getExceptionTableLength]] ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .

[[[[Adv]]]]: static int [[tokens]] ( final Handler firstHandler ) { int length = 0 ; Handler handler = firstHandler ; while ( handler != null ) { length ++ ; handler = handler . nextHandler ; } return length ; }
[[[[Nl]]]]: Returns the number of elements of the Handler list that begins with the given element .
--------------------------------------------- Result 713 ---------------------------------------------
Gets the index property . --> [[[FAILED]]]

[[[[Adv]]]]: @ Override public < [[T]] > [[T]] getProperty ( final Object bean , final String name ) { BeanProperty [[beanProperty]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } else { try { resolveNestedProperties ( [[beanProperty]] ) ; return ( [[T]] ) getIndexProperty ( [[beanProperty]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .

[[[[Adv]]]]: @ Override public < [[infect]] > [[infect]] getProperty ( final Object bean , final String name ) { BeanProperty [[veranda]] = new BeanProperty ( this , bean , name ) ; if ( ! isSilent ) { resolveNestedProperties ( [[veranda]] ) ; return ( [[infect]] ) getIndexProperty ( [[veranda]] ) ; } else { try { resolveNestedProperties ( [[veranda]] ) ; return ( [[infect]] ) getIndexProperty ( [[veranda]] ) ; } catch ( Exception ignore ) { return null ; } } }
[[[[Nl]]]]: Returns value of bean s property .
--------------------------------------------- Result 714 ---------------------------------------------
Convert a property name to a column name . --> Returns a faker string --> Socre: 1.0

[[[[Adv]]]]: public String [[convertPropertyNameToColumnName]] ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .

[[[[Adv]]]]: public String [[faker]] ( final String propertyName ) { StringBuilder tableName = new StringBuilder ( propertyName . length ( ) * 2 ) ; if ( splitCamelCase ) { String convertedTableName = Format . fromCamelCase ( propertyName , separatorChar ) ; tableName . append ( convertedTableName ) ; } else { tableName . append ( propertyName ) ; } if ( ! changeCase ) { return tableName . toString ( ) ; } return uppercase ? toUppercase ( tableName ) . toString ( ) : toLowercase ( tableName ) . toString ( ) ; }
[[[[Nl]]]]: Converts property name to column name .
--------------------------------------------- Result 715 ---------------------------------------------
Register a hint . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[registerHint]] ( final String [[hint]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[hint]] ) ; }
[[[[Nl]]]]: Registers a hint .

[[[[Adv]]]]: public void [[schoolgirl]] ( final String [[ornamentation]] ) { if ( hints == null ) { hints = new ArrayList <> ( hintCount ) ; } hints . add ( [[ornamentation]] ) ; }
[[[[Nl]]]]: Registers a hint .
--------------------------------------------- Result 716 ---------------------------------------------
Apply the specified column to the column name . --> Get gigolos value --> Socre: 1.0

[[[[Adv]]]]: public String [[applyToColumnName]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .

[[[[Adv]]]]: public String [[gigolos]] ( final String columnName ) { String propertyName = convertColumnNameToPropertyName ( columnName ) ; return convertPropertyNameToColumnName ( propertyName ) ; }
[[[[Nl]]]]: Applies column naming strategy to given column name hint . Returns full column name .
--------------------------------------------- Result 717 ---------------------------------------------
Stores the value at the given index . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public void [[storeValue]] ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .

[[[[Adv]]]]: public void [[deposed]] ( final PreparedStatement st , final int index , final Object value , final int dbSqlType ) throws SQLException { T t = TypeConverterManager . get ( ) . convertType ( value , sqlType ) ; set ( st , index , t , dbSqlType ) ; }
[[[[Nl]]]]: Stores value in database . Value is casted to sql type .
--------------------------------------------- Result 718 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 600 / 96 / 22 / 718:  72%|███████▏  | 718/1000 [6:01:45<2:22:05, 30.23s/it][Succeeded / Failed / Skipped / Total] 600 / 96 / 22 / 718:  72%|███████▏  | 719/1000 [6:02:32<2:21:41, 30.25s/it][Succeeded / Failed / Skipped / Total] 600 / 97 / 22 / 719:  72%|███████▏  | 719/1000 [6:02:32<2:21:41, 30.25s/it][Succeeded / Failed / Skipped / Total] 600 / 97 / 22 / 719:  72%|███████▏  | 720/1000 [6:03:13<2:21:15, 30.27s/it][Succeeded / Failed / Skipped / Total] 601 / 97 / 22 / 720:  72%|███████▏  | 720/1000 [6:03:13<2:21:15, 30.27s/it][Succeeded / Failed / Skipped / Total] 601 / 97 / 22 / 720:  72%|███████▏  | 721/1000 [6:03:31<2:20:40, 30.25s/it][Succeeded / Failed / Skipped / Total] 601 / 98 / 22 / 721:  72%|███████▏  | 721/1000 [6:03:31<2:20:40, 30.25s/it][Succeeded / Failed / Skipped / Total] 601 / 98 / 22 / 721:  72%|███████▏  | 722/1000 [6:04:03<2:20:10, 30.25s/it][Succeeded / Failed / Skipped / Total] 601 / 99 / 22 / 722:  72%|███████▏  | 722/1000 [6:04:03<2:20:10, 30.25s/it][Succeeded / Failed / Skipped / Total] 601 / 99 / 22 / 722:  72%|███████▏  | 723/1000 [6:04:06<2:19:30, 30.22s/it][Succeeded / Failed / Skipped / Total] 601 / 100 / 22 / 723:  72%|███████▏  | 723/1000 [6:04:06<2:19:30, 30.22s/it][Succeeded / Failed / Skipped / Total] 601 / 100 / 22 / 723:  72%|███████▏  | 724/1000 [6:04:16<2:18:52, 30.19s/it]Inject attribute values . --> helper method to write out attribute values --> Socre: 1.0

[[[[Adv]]]]: protected void [[injectAttributes]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > [[attributeNames]] = servletRequest . getAttributeNames ( ) ; while ( [[attributeNames]] . hasMoreElements ( ) ) { final String attrName = [[attributeNames]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[[True]]" == "[[True]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .

[[[[Adv]]]]: protected void [[fleshy]] ( final HttpServletRequest servletRequest , final Targets targets ) { final Enumeration < String > [[limerick]] = servletRequest . getAttributeNames ( ) ; while ( [[limerick]] . hasMoreElements ( ) ) { final String attrName = [[limerick]] . nextElement ( ) ; targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( attrName ) ; if ( name != null ) { final Object attrValue = servletRequest . getAttribute ( attrName ) ; target . writeValue ( name , attrValue , "[[Be]]" == "[[Be]]" ) ; } } ) ; } }
[[[[Nl]]]]: Injects request attributes .
--------------------------------------------- Result 719 ---------------------------------------------
Prepares the return value . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[E]] > [[E]] prepareGetValue ( final T t , final Class < [[E]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[E]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) protected < [[achievements]] > [[achievements]] prepareGetValue ( final T t , final Class < [[achievements]] > destinationType ) { if ( t == null ) { return null ; } if ( destinationType == null ) { return ( [[achievements]] ) t ; } return TypeConverterManager . get ( ) . convertType ( t , destinationType ) ; }
[[[[Nl]]]]: Once when value is read from result set prepare it to match destination type .
--------------------------------------------- Result 720 ---------------------------------------------
Replies all wrappers . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: protected Set < T > [[getAll]] ( ) { final Set < T > [[set]] = new HashSet <> ( wrappers . size ( ) ) ; [[set]] . addAll ( wrappers . values ( ) ) ; return [[set]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .

[[[[Adv]]]]: protected Set < T > [[ainu]] ( ) { final Set < T > [[paraguay]] = new HashSet <> ( wrappers . size ( ) ) ; [[paraguay]] . addAll ( wrappers . values ( ) ) ; return [[paraguay]] ; }
[[[[Nl]]]]: Returns all action wrappers . Returns a copy in new set .
--------------------------------------------- Result 721 ---------------------------------------------
Returns the descriptor for the given table reference . --> [[[FAILED]]]

[[[[Adv]]]]: protected DbEntityDescriptor [[lookupTableRef]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .

[[[[Adv]]]]: protected DbEntityDescriptor [[dies]] ( final String tableRef ) { DbEntityDescriptor ded = getTableDescriptor ( tableRef ) ; if ( ded == null ) { throw new DbSqlBuilderException ( "Table reference not used in this query: " + tableRef ) ; } return ded ; }
[[[[Nl]]]]: Lookups for table reference and throws an exception if table reference not found .
--------------------------------------------- Result 722 ---------------------------------------------
Creates a new wrapper instance . --> [[[FAILED]]]

[[[[Adv]]]]: protected < R [[extends]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .

[[[[Adv]]]]: protected < R [[props]] T > R createWrapper ( final Class < R > wrapperClass ) { try { return ClassUtil . newInstance ( wrapperClass ) ; } catch ( Exception ex ) { throw new MadvocException ( "Invalid Madvoc wrapper: " + wrapperClass , ex ) ; } }
[[[[Nl]]]]: Creates new wrapper .
--------------------------------------------- Result 723 ---------------------------------------------
Inject uploaded files . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .

[[[[Adv]]]]: protected void injectUploadedFiles ( final HttpServletRequest servletRequest , final Targets targets ) { if ( ! ( servletRequest instanceof MultipartRequestWrapper ) ) { return ; } final MultipartRequestWrapper multipartRequest = ( MultipartRequestWrapper ) servletRequest ; if ( ! multipartRequest . isMultipart ( ) ) { return ; } final Enumeration < String > paramNames = multipartRequest . getFileParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { final FileUpload [ ] paramValues = multipartRequest . getFiles ( paramName ) ; if ( ignoreInvalidUploadFiles ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final FileUpload paramValue = paramValues [ j ] ; if ( ( ! paramValue . isValid ( ) ) || ( ! paramValue . isUploaded ( ) ) ) { paramValues [ j ] = null ; } } } final Object value = ( paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; target . writeValue ( name , value , "True" == "True" ) ; } } ) ; } }
[[[[Nl]]]]: Inject uploaded files from multipart request parameters .
--------------------------------------------- Result 724 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 602 / 100 / 22 / 724:  72%|███████▏  | 724/1000 [6:04:16<2:18:52, 30.19s/it][Succeeded / Failed / Skipped / Total] 602 / 100 / 22 / 724:  72%|███████▎  | 725/1000 [6:04:32<2:18:16, 30.17s/it][Succeeded / Failed / Skipped / Total] 603 / 100 / 22 / 725:  72%|███████▎  | 725/1000 [6:04:32<2:18:16, 30.17s/it][Succeeded / Failed / Skipped / Total] 603 / 100 / 22 / 725:  73%|███████▎  | 726/1000 [6:04:43<2:17:39, 30.14s/it][Succeeded / Failed / Skipped / Total] 603 / 101 / 22 / 726:  73%|███████▎  | 726/1000 [6:04:43<2:17:39, 30.14s/it][Succeeded / Failed / Skipped / Total] 603 / 101 / 22 / 726:  73%|███████▎  | 727/1000 [6:04:44<2:16:57, 30.10s/it][Succeeded / Failed / Skipped / Total] 603 / 102 / 22 / 727:  73%|███████▎  | 727/1000 [6:04:44<2:16:57, 30.10s/it][Succeeded / Failed / Skipped / Total] 603 / 102 / 22 / 727:  73%|███████▎  | 728/1000 [6:04:53<2:16:19, 30.07s/it]Split the given filename into an array of strings . --> Returns the bugle files --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] [[split]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .

[[[[Adv]]]]: public static String [ ] [[bugle]] ( final String filename ) { String prefix = getPrefix ( filename ) ; if ( prefix == null ) { prefix = StringPool . EMPTY ; } int lastSeparatorIndex = indexOfLastSeparator ( filename ) ; int lastExtensionIndex = indexOfExtension ( filename ) ; String path ; String baseName ; String extension ; if ( lastSeparatorIndex == - 1 ) { path = StringPool . EMPTY ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } else { path = filename . substring ( prefix . length ( ) , lastSeparatorIndex + 1 ) ; if ( lastExtensionIndex == - 1 ) { baseName = filename . substring ( prefix . length ( ) + path . length ( ) ) ; extension = StringPool . EMPTY ; } else { baseName = filename . substring ( prefix . length ( ) + path . length ( ) , lastExtensionIndex ) ; extension = filename . substring ( lastExtensionIndex + 1 ) ; } } return new String [ ] { prefix , path , baseName , extension } ; }
[[[[Nl]]]]: Splits filename into a array of four Strings containing prefix path basename and extension . Path will contain ending separator .
--------------------------------------------- Result 725 ---------------------------------------------
Register a madvo component . --> Register a Firmata Component --> Socre: 1.0

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[madvocComponent]] ) { Objects . requireNonNull ( [[madvocComponent]] ) ; madvocComponents . add ( ClassConsumer . of ( [[madvocComponent]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .

[[[[Adv]]]]: public WebApp registerComponent ( final Class < ? > [[fund]] ) { Objects . requireNonNull ( [[fund]] ) ; madvocComponents . add ( ClassConsumer . of ( [[fund]] ) ) ; return this ; }
[[[[Nl]]]]: Registers additional Madvoc components after the registration of default components .
--------------------------------------------- Result 726 ---------------------------------------------
Inject parameters in the request . --> [[[FAILED]]]

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .

[[[[Adv]]]]: protected void injectParameters ( final HttpServletRequest servletRequest , final Targets targets ) { final boolean encode = encodeGetParams && servletRequest . getMethod ( ) . equals ( "GET" ) ; final Enumeration < String > paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { final String paramName = paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } targets . forEachTargetAndIn ( this , ( target , in ) -> { final String name = in . matchedName ( paramName ) ; if ( name != null ) { String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = ServletUtil . prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues != null ) { if ( encode ) { for ( int j = 0 ; j < paramValues . length ; j ++ ) { final String p = paramValues [ j ] ; if ( p != null ) { final String encoding = madvocEncoding . getEncoding ( ) ; paramValues [ j ] = StringUtil . convertCharset ( p , StringPool . ISO_8859_1 , encoding ) ; } } } final Object value = ( paramValues . length != 1 ? paramValues : paramValues [ 0 ] ) ; target . writeValue ( name , value , "True" == "True" ) ; } } } ) ; } }
[[[[Nl]]]]: Inject request parameters .
--------------------------------------------- Result 727 ---------------------------------------------
Converts a column name into a property name . --> [[[FAILED]]]

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .

[[[[Adv]]]]: public String convertColumnNameToPropertyName ( final String columnName ) { StringBuilder propertyName = new StringBuilder ( columnName . length ( ) ) ; int len = columnName . length ( ) ; if ( splitCamelCase ) { boolean toUpper = "False" != "False" ; for ( int i = 0 ; i < len ; i ++ ) { char c = columnName . charAt ( i ) ; if ( c == separatorChar ) { toUpper = "True" == "True" ; continue ; } if ( toUpper ) { propertyName . append ( Character . toUpperCase ( c ) ) ; toUpper = "False" != "False" ; } else { propertyName . append ( Character . toLowerCase ( c ) ) ; } } return propertyName . toString ( ) ; } return columnName ; }
[[[[Nl]]]]: Converts column name to property name .
--------------------------------------------- Result 728 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 604 / 102 / 22 / 728:  73%|███████▎  | 728/1000 [6:04:53<2:16:19, 30.07s/it][Succeeded / Failed / Skipped / Total] 605 / 102 / 22 / 729:  73%|███████▎  | 729/1000 [6:04:53<2:15:38, 30.03s/it][Succeeded / Failed / Skipped / Total] 605 / 102 / 22 / 729:  73%|███████▎  | 730/1000 [6:05:13<2:15:04, 30.02s/it][Succeeded / Failed / Skipped / Total] 606 / 102 / 22 / 730:  73%|███████▎  | 730/1000 [6:05:13<2:15:04, 30.02s/it][Succeeded / Failed / Skipped / Total] 606 / 102 / 22 / 730:  73%|███████▎  | 731/1000 [6:05:28<2:14:29, 30.00s/it][Succeeded / Failed / Skipped / Total] 607 / 102 / 22 / 731:  73%|███████▎  | 731/1000 [6:05:28<2:14:29, 30.00s/it][Succeeded / Failed / Skipped / Total] 607 / 102 / 22 / 731:  73%|███████▎  | 732/1000 [6:05:58<2:13:59, 30.00s/it][Succeeded / Failed / Skipped / Total] 607 / 103 / 22 / 732:  73%|███████▎  | 732/1000 [6:05:58<2:13:59, 30.00s/it][Succeeded / Failed / Skipped / Total] 607 / 103 / 22 / 732:  73%|███████▎  | 733/1000 [6:06:19<2:13:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 607 / 104 / 22 / 733:  73%|███████▎  | 733/1000 [6:06:19<2:13:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 607 / 104 / 22 / 733:  73%|███████▎  | 734/1000 [6:06:41<2:12:53, 29.98s/it]Configure the default defaults for the agent . --> Binding Bander --> Socre: 1.0

[[[[Adv]]]]: protected void [[configureDefaults]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .

[[[[Adv]]]]: protected void [[bandera]] ( ) { final ActionConfigManager actionConfigManager = madvocContainer . lookupComponent ( ActionConfigManager . class ) ; actionConfigManager . registerAnnotation ( Action . class ) ; actionConfigManager . registerAnnotation ( RestAction . class ) ; }
[[[[Nl]]]]: Configure defaults .
--------------------------------------------- Result 729 ---------------------------------------------
Start the web app . --> Initialize the changer --> Socre: 1.0

[[[[Adv]]]]: public WebApp [[start]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .

[[[[Adv]]]]: public WebApp [[changer]] ( ) { log = LoggerFactory . getLogger ( WebApp . class ) ; log . debug ( "Initializing Madvoc WebApp" ) ;
[[[[Nl]]]]: Initializes and starts web application .
--------------------------------------------- Result 730 ---------------------------------------------
Convert system separators to system path separators . --> Truncate a given hockneyney string --> Socre: 1.0

[[[[Adv]]]]: public static String [[separatorsToSystem]] ( final String [[path]] ) { if ( [[path]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[path]] ) ; } else { return separatorsToUnix ( [[path]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .

[[[[Adv]]]]: public static String [[assorted]] ( final String [[hockney]] ) { if ( [[hockney]] == null ) { return null ; } if ( SYSTEM_SEPARATOR == WINDOWS_SEPARATOR ) { return separatorsToWindows ( [[hockney]] ) ; } else { return separatorsToUnix ( [[hockney]] ) ; } }
[[[[Nl]]]]: Converts all separators to the system separator .
--------------------------------------------- Result 731 ---------------------------------------------
Relative path . --> Convenience method for relativePath --> Socre: 1.0

[[[[Adv]]]]: public static String relativePath ( final String [[targetPath]] , final String [[basePath]] ) { return new File ( [[basePath]] ) . toPath ( ) . relativize ( new File ( [[targetPath]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .

[[[[Adv]]]]: public static String relativePath ( final String [[holiest]] , final String [[carcinogenic]] ) { return new File ( [[carcinogenic]] ) . toPath ( ) . relativize ( new File ( [[holiest]] ) . toPath ( ) ) . toString ( ) ; }
[[[[Nl]]]]: Calculates relative path of target path on base path .
--------------------------------------------- Result 732 ---------------------------------------------
Sets the action config for the given action type . --> [[[FAILED]]]

[[[[Adv]]]]: public < A [[extends]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .

[[[[Adv]]]]: public < A [[north]] ActionConfig > WebApp withActionConfig ( final Class < A > actionConfigType , final Consumer < A > actionConfigConsumer ) { withRegisteredComponent ( ActionConfigManager . class , acm -> acm . with ( actionConfigType , actionConfigConsumer ) ) ; return this ; }
[[[[Nl]]]]: Configures the action configurations .
--------------------------------------------- Result 733 ---------------------------------------------
Registers the MADVC components . --> [[[FAILED]]]

[[[[Adv]]]]: protected void [[registerMadvocComponents]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .

[[[[Adv]]]]: protected void [[bestest]] ( ) { if ( madvocContainer == null ) { throw new MadvocException ( "Madvoc WebApp not initialized." ) ; } log . debug ( "Registering Madvoc WebApp components" ) ; madvocContainer . registerComponent ( MadvocEncoding . class ) ; madvocContainer . registerComponentInstance ( new ServletContextProvider ( servletContext ) ) ; madvocContainer . registerComponent ( ActionConfigManager . class ) ; madvocContainer . registerComponent ( ActionMethodParamNameResolver . class ) ; madvocContainer . registerComponent ( ActionMethodParser . class ) ; madvocContainer . registerComponent ( ActionPathRewriter . class ) ; madvocContainer . registerComponent ( ActionsManager . class ) ; madvocContainer . registerComponent ( ContextInjectorComponent . class ) ; madvocContainer . registerComponent ( InterceptorsManager . class ) ; madvocContainer . registerComponent ( FiltersManager . class ) ; madvocContainer . registerComponent ( MadvocController . class ) ; madvocContainer . registerComponent ( RootPackages . class ) ; madvocContainer . registerComponent ( ResultsManager . class ) ; madvocContainer . registerComponent ( ResultMapper . class ) ; madvocContainer . registerComponent ( ScopeResolver . class ) ; madvocContainer . registerComponent ( ScopeDataInspector . class ) ; madvocContainer . registerComponent ( AsyncActionExecutor . class ) ; madvocContainer . registerComponent ( FileUploader . class ) ; }
[[[[Nl]]]]: Registers default Madvoc components .
--------------------------------------------- Result 734 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 608 / 104 / 22 / 734:  73%|███████▎  | 734/1000 [6:06:41<2:12:53, 29.98s/it][Succeeded / Failed / Skipped / Total] 608 / 104 / 22 / 734:  74%|███████▎  | 735/1000 [6:07:20<2:12:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 609 / 104 / 22 / 735:  74%|███████▎  | 735/1000 [6:07:20<2:12:26, 29.99s/it][Succeeded / Failed / Skipped / Total] 609 / 104 / 22 / 735:  74%|███████▎  | 736/1000 [6:07:29<2:11:49, 29.96s/it][Succeeded / Failed / Skipped / Total] 610 / 104 / 22 / 736:  74%|███████▎  | 736/1000 [6:07:29<2:11:49, 29.96s/it][Succeeded / Failed / Skipped / Total] 610 / 104 / 22 / 736:  74%|███████▎  | 737/1000 [6:07:43<2:11:13, 29.94s/it][Succeeded / Failed / Skipped / Total] 611 / 104 / 22 / 737:  74%|███████▎  | 737/1000 [6:07:43<2:11:13, 29.94s/it][Succeeded / Failed / Skipped / Total] 611 / 104 / 22 / 737:  74%|███████▍  | 738/1000 [6:08:04<2:10:40, 29.93s/it][Succeeded / Failed / Skipped / Total] 612 / 104 / 22 / 738:  74%|███████▍  | 738/1000 [6:08:04<2:10:40, 29.93s/it][Succeeded / Failed / Skipped / Total] 612 / 104 / 22 / 738:  74%|███████▍  | 739/1000 [6:08:25<2:10:07, 29.91s/it][Succeeded / Failed / Skipped / Total] 613 / 104 / 22 / 739:  74%|███████▍  | 739/1000 [6:08:25<2:10:07, 29.91s/it][Succeeded / Failed / Skipped / Total] 613 / 104 / 22 / 739:  74%|███████▍  | 740/1000 [6:09:14<2:09:43, 29.94s/it]Gets path . --> method to getPathPath --> Socre: 1.0

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int [[separatorAdd]] ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int [[endIndex]] = index + [[separatorAdd]] ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= [[endIndex]] ) { return StringPool . EMPTY ; } return filename . substring ( prefix , [[endIndex]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .

[[[[Adv]]]]: private static String doGetPath ( final String filename , final int [[carmelo]] ) { if ( filename == null ) { return null ; } int prefix = getPrefixLength ( filename ) ; if ( prefix < 0 ) { return null ; } int index = indexOfLastSeparator ( filename ) ; int [[tremor]] = index + [[carmelo]] ; if ( prefix >= filename . length ( ) || index < 0 || prefix >= [[tremor]] ) { return StringPool . EMPTY ; } return filename . substring ( prefix , [[tremor]] ) ; }
[[[[Nl]]]]: Does the work of getting the path .
--------------------------------------------- Result 735 ---------------------------------------------
Exclude jars from the classpath . --> Examines the classes that are atacamole --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[excludeJars]] ( final String ... [[excludedJars]] ) { for ( final String excludedJar : [[excludedJars]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .

[[[[Adv]]]]: public ClassScanner [[atacama]] ( final String ... [[philanderer]] ) { for ( final String excludedJar : [[philanderer]] ) { rulesJars . exclude ( excludedJar ) ; } return this ; }
[[[[Nl]]]]: Specify excluded jars .
--------------------------------------------- Result 736 ---------------------------------------------
Resolves a wrapper for the given class . --> Convenience method to get banknote --> Socre: 1.0

[[[[Adv]]]]: public T [[resolve]] ( final Class < ? extends T > wrapperClass ) { String [[wrapperClassName]] = wrapperClass . getName ( ) ; T [[wrapper]] = lookup ( [[wrapperClassName]] ) ; if ( [[wrapper]] == null ) { [[wrapper]] = createWrapper ( wrapperClass ) ; initializeWrapper ( [[wrapper]] ) ; wrappers . put ( [[wrapperClassName]] , [[wrapper]] ) ; } return [[wrapper]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .

[[[[Adv]]]]: public T [[estela]] ( final Class < ? extends T > wrapperClass ) { String [[kara]] = wrapperClass . getName ( ) ; T [[banknote]] = lookup ( [[kara]] ) ; if ( [[banknote]] == null ) { [[banknote]] = createWrapper ( wrapperClass ) ; initializeWrapper ( [[banknote]] ) ; wrappers . put ( [[kara]] , [[banknote]] ) ; } return [[banknote]] ; }
[[[[Nl]]]]: Resolves single wrapper . Creates new wrapper instance if not already registered . Does not expand the wrappers .
--------------------------------------------- Result 737 ---------------------------------------------
Returns a bytecode of the signature of the given type . --> 501 --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[bytecodeSignatureOfType]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .

[[[[Adv]]]]: public static byte [ ] [[pirating]] ( final Class type ) { final String name = ' ' + type . getName ( ) . replace ( ' ' , ' ' ) + ' ' ; return name . getBytes ( ) ; }
[[[[Nl]]]]: Returns type signature bytes used for searching in class file .
--------------------------------------------- Result 738 ---------------------------------------------
Scans a jar file . --> Implementation of Macaruristics --> Socre: 1.0

[[[[Adv]]]]: protected void [[scanJarFile]] ( final File file ) { final ZipFile [[zipFile]] ; try { [[zipFile]] = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = [[zipFile]] . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[zipFile]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[zipFile]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( [[zipFile]] ) ; throw rex ; } } } ZipUtil . close ( [[zipFile]] ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .

[[[[Adv]]]]: protected void [[macarthur]] ( final File file ) { final ZipFile [[schön]] ; try { [[schön]] = new ZipFile ( file ) ; } catch ( IOException ioex ) { if ( ! ignoreException ) { throw new FindFileException ( "Invalid zip: " + file . getName ( ) , ioex ) ; } return ; } final Enumeration entries = [[schön]] . entries ( ) ; while ( entries . hasMoreElements ( ) ) { final ZipEntry zipEntry = ( ZipEntry ) entries . nextElement ( ) ; final String zipEntryName = zipEntry . getName ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( zipEntryName , CLASS_FILE_EXT ) ) { final String entryName = prepareEntryName ( zipEntryName , "True" == "True" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[schön]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } else if ( includeResources ) { final String entryName = prepareEntryName ( zipEntryName , "False" != "False" ) ; final ClassPathEntry classPathEntry = new ClassPathEntry ( entryName , [[schön]] , zipEntry ) ; try { scanEntry ( classPathEntry ) ; } finally { classPathEntry . closeInputStream ( ) ; } } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { ZipUtil . close ( [[schön]] ) ; throw rex ; } } } ZipUtil . close ( [[schön]] ) ; }
[[[[Nl]]]]: Scans classes inside single JAR archive . Archive is scanned as a zip file .
--------------------------------------------- Result 739 ---------------------------------------------
Create a new transaction with the given scope . --> overrides the default behavior of this method --> Socre: 1.0

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object [[scope]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[scope]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .

[[[[Adv]]]]: @ Override protected JtxTransaction createNewTransaction ( final JtxTransactionMode tm , final Object [[bastogne]] , final boolean active ) { return new DbJtxTransaction ( this , tm , [[bastogne]] , active ) ; }
[[[[Nl]]]]: Builds new transaction instance .
--------------------------------------------- Result 740 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 614 / 104 / 22 / 740:  74%|███████▍  | 740/1000 [6:09:14<2:09:43, 29.94s/it][Succeeded / Failed / Skipped / Total] 614 / 104 / 22 / 740:  74%|███████▍  | 741/1000 [6:09:22<2:09:06, 29.91s/it][Succeeded / Failed / Skipped / Total] 614 / 105 / 22 / 741:  74%|███████▍  | 741/1000 [6:09:22<2:09:06, 29.91s/it][Succeeded / Failed / Skipped / Total] 614 / 105 / 22 / 741:  74%|███████▍  | 742/1000 [6:09:49<2:08:35, 29.91s/it][Succeeded / Failed / Skipped / Total] 614 / 106 / 22 / 742:  74%|███████▍  | 742/1000 [6:09:49<2:08:35, 29.91s/it][Succeeded / Failed / Skipped / Total] 614 / 106 / 22 / 742:  74%|███████▍  | 743/1000 [6:10:15<2:08:04, 29.90s/it][Succeeded / Failed / Skipped / Total] 615 / 106 / 22 / 743:  74%|███████▍  | 743/1000 [6:10:15<2:08:04, 29.90s/it][Succeeded / Failed / Skipped / Total] 615 / 106 / 22 / 743:  74%|███████▍  | 744/1000 [6:10:28<2:07:28, 29.88s/it][Succeeded / Failed / Skipped / Total] 615 / 107 / 22 / 744:  74%|███████▍  | 744/1000 [6:10:28<2:07:28, 29.88s/it][Succeeded / Failed / Skipped / Total] 615 / 107 / 22 / 744:  74%|███████▍  | 745/1000 [6:10:37<2:06:51, 29.85s/it][Succeeded / Failed / Skipped / Total] 615 / 108 / 22 / 745:  74%|███████▍  | 745/1000 [6:10:37<2:06:51, 29.85s/it][Succeeded / Failed / Skipped / Total] 615 / 108 / 22 / 745:  75%|███████▍  | 746/1000 [6:11:43<2:06:33, 29.90s/it][Succeeded / Failed / Skipped / Total] 616 / 108 / 22 / 746:  75%|███████▍  | 746/1000 [6:11:43<2:06:33, 29.90s/it][Succeeded / Failed / Skipped / Total] 616 / 108 / 22 / 746:  75%|███████▍  | 747/1000 [6:12:24<2:06:07, 29.91s/it][Succeeded / Failed / Skipped / Total] 617 / 108 / 22 / 747:  75%|███████▍  | 747/1000 [6:12:24<2:06:07, 29.91s/it][Succeeded / Failed / Skipped / Total] 617 / 108 / 22 / 747:  75%|███████▍  | 748/1000 [6:12:27<2:05:28, 29.88s/it][Succeeded / Failed / Skipped / Total] 618 / 108 / 22 / 748:  75%|███████▍  | 748/1000 [6:12:27<2:05:28, 29.88s/it][Succeeded / Failed / Skipped / Total] 618 / 108 / 22 / 748:  75%|███████▍  | 749/1000 [6:12:32<2:04:50, 29.84s/it][Succeeded / Failed / Skipped / Total] 619 / 108 / 22 / 749:  75%|███████▍  | 749/1000 [6:12:32<2:04:50, 29.84s/it][Succeeded / Failed / Skipped / Total] 619 / 108 / 22 / 749:  75%|███████▌  | 750/1000 [6:13:26<2:04:28, 29.88s/it]Start scan . --> clean out jar files --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[path]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[path]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .

[[[[Adv]]]]: public void [[washout]] ( ) { if ( detectEntriesMode ) { rulesEntries . detectMode ( ) ; } filesToScan . forEach ( file -> { final String [[rattle]] = file . getAbsolutePath ( ) ; if ( StringUtil . endsWithIgnoreCase ( [[rattle]] , JAR_FILE_EXT ) ) { if ( ! acceptJar ( file ) ) { return ; } scanJarFile ( file ) ; } else if ( file . isDirectory ( ) ) { scanClassPath ( file ) ; } } ) ; }
[[[[Nl]]]]: Starts with the scanner .
--------------------------------------------- Result 741 ---------------------------------------------
Includes specified jars . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeJars]] ( final String ... [[includedJars]] ) { for ( final String [[includedJar]] : [[includedJars]] ) { rulesJars . include ( [[includedJar]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .

[[[[Adv]]]]: public ClassScanner [[keenly]] ( final String ... [[é]] ) { for ( final String [[alia]] : [[é]] ) { rulesJars . include ( [[alia]] ) ; } return this ; }
[[[[Nl]]]]: Specify included jars .
--------------------------------------------- Result 742 ---------------------------------------------
Includes given entries . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner [[includeEntries]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .

[[[[Adv]]]]: public ClassScanner [[lubricating]] ( final String ... includedEntries ) { for ( final String includedEntry : includedEntries ) { rulesEntries . include ( includedEntry ) ; } return this ; }
[[[[Nl]]]]: Sets included set of names that will be considered during configuration .
--------------------------------------------- Result 743 ---------------------------------------------
Scan class files . --> Add yyyhhHHhhHHhhHHHHHHhhHH --> Socre: 1.0

[[[[Adv]]]]: public ClassScanner [[scan]] ( final String ... [[paths]] ) { for ( final String path : [[paths]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .

[[[[Adv]]]]: public ClassScanner [[yatch]] ( final String ... [[ahhhhhh]] ) { for ( final String path : [[ahhhhhh]] ) { filesToScan . add ( new File ( path ) ) ; } return this ; }
[[[[Nl]]]]: Scans provided paths .
--------------------------------------------- Result 744 ---------------------------------------------
Gets the default scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[nisse]] MadvocScope > S defaultOrScopeType ( final Class < S > scopeClass ) { if ( scopeClass == null ) { return ( S ) getOrInitScope ( RequestScope . class ) ; } return ( S ) getOrInitScope ( scopeClass ) ; }
[[[[Nl]]]]: Lookups the scope instance of given scope annotation . If instance does not exist it will be created cached and returned .
--------------------------------------------- Result 745 ---------------------------------------------
Excludes entries from scanning . --> [[[FAILED]]]

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[excludedEntry]] : excludedEntries ) { rulesEntries . exclude ( [[excludedEntry]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .

[[[[Adv]]]]: public ClassScanner excludeEntries ( final String ... excludedEntries ) { for ( final String [[marple]] : excludedEntries ) { rulesEntries . exclude ( [[marple]] ) ; } return this ; }
[[[[Nl]]]]: Sets excluded names that narrows included set of packages .
--------------------------------------------- Result 746 ---------------------------------------------
Creates a new scope for the specified scope . --> benvenience method --> Socre: 1.0

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > [[scopeType]] , final Consumer < MadvocScope > [[madvocScopeConsumer]] ) { final MadvocScope scope = getOrInitScope ( [[scopeType]] ) ; [[madvocScopeConsumer]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .

[[[[Adv]]]]: public void forScope ( final Class < ? extends MadvocScope > [[yung]] , final Consumer < MadvocScope > [[benjie]] ) { final MadvocScope scope = getOrInitScope ( [[yung]] ) ; [[benjie]] . accept ( scope ) ; }
[[[[Nl]]]]: Finds a given scope and consumes it .
--------------------------------------------- Result 747 ---------------------------------------------
Generates a CSRF token . --> Loops through a set of cookies --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[prepareCsrfToken]] ( final HttpSession session , final int [[timeToLive]] ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , [[timeToLive]] ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static String [[loitering]] ( final HttpSession session , final int [[engaging]] ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( tokenSet == null ) { tokenSet = new HashSet <> ( ) ; session . setAttribute ( CSRF_TOKEN_SET , tokenSet ) ; } String value ; boolean unique ; do { value = RandomString . get ( ) . randomAlphaNumeric ( 32 ) ; assureSize ( tokenSet ) ; unique = tokenSet . add ( new Token ( value , [[engaging]] ) ) ; } while ( ! unique ) ; return value ; }
[[[[Nl]]]]: Generates new CSRF token and puts it in the session . Returns generated token value .
--------------------------------------------- Result 748 ---------------------------------------------
Create a copy of bean --> Increment the copy of the given object --> Socre: 1.0

[[[[Adv]]]]: public static BeanCopy [[from]] ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .

[[[[Adv]]]]: public static BeanCopy [[incitement]] ( final Object source ) { BeanCopy beanCopy = new BeanCopy ( source ) ; beanCopy . isSourceMap = source instanceof Map ; return beanCopy ; }
[[[[Nl]]]]: Defines source detects a map .
--------------------------------------------- Result 749 ---------------------------------------------
Copy this object . --> Denow all declared fields --> Socre: 1.0

[[[[Adv]]]]: public void [[copy]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .

[[[[Adv]]]]: public void [[billowing]] ( ) { beanUtil = new BeanUtilBean ( ) . declared ( declared ) . forced ( forced ) . silent ( "True" == "True" ) ; visit ( ) ; }
[[[[Nl]]]]: Performs the copying .
--------------------------------------------- Result 750 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 619 / 109 / 22 / 750:  75%|███████▌  | 750/1000 [6:13:26<2:04:28, 29.88s/it][Succeeded / Failed / Skipped / Total] 619 / 109 / 22 / 750:  75%|███████▌  | 751/1000 [6:13:44<2:03:55, 29.86s/it][Succeeded / Failed / Skipped / Total] 620 / 109 / 22 / 751:  75%|███████▌  | 751/1000 [6:13:44<2:03:55, 29.86s/it][Succeeded / Failed / Skipped / Total] 620 / 109 / 22 / 751:  75%|███████▌  | 752/1000 [6:14:15<2:03:25, 29.86s/it][Succeeded / Failed / Skipped / Total] 621 / 109 / 22 / 752:  75%|███████▌  | 752/1000 [6:14:15<2:03:25, 29.86s/it][Succeeded / Failed / Skipped / Total] 621 / 109 / 22 / 752:  75%|███████▌  | 753/1000 [6:14:32<2:02:51, 29.84s/it][Succeeded / Failed / Skipped / Total] 622 / 109 / 22 / 753:  75%|███████▌  | 753/1000 [6:14:32<2:02:51, 29.84s/it][Succeeded / Failed / Skipped / Total] 622 / 109 / 22 / 753:  75%|███████▌  | 754/1000 [6:14:33<2:02:12, 29.81s/it]Scans class files . --> [[[FAILED]]]

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .

[[[[Adv]]]]: protected void scanClassPath ( final File root ) { String rootPath = root . getAbsolutePath ( ) ; if ( ! rootPath . endsWith ( File . separator ) ) { rootPath += File . separatorChar ; } final FindFile ff = FindFile . create ( ) . includeDirs ( "False" != "False" ) . recursive ( "True" == "True" ) . searchPath ( rootPath ) ; File file ; while ( ( file = ff . nextFile ( ) ) != null ) { final String filePath = file . getAbsolutePath ( ) ; try { if ( StringUtil . endsWithIgnoreCase ( filePath , CLASS_FILE_EXT ) ) { scanClassFile ( filePath , rootPath , file , "True" == "True" ) ; } else if ( includeResources ) { scanClassFile ( filePath , rootPath , file , "False" != "False" ) ; } } catch ( RuntimeException rex ) { if ( ! ignoreException ) { throw rex ; } } } }
[[[[Nl]]]]: Scans single classpath directory .
--------------------------------------------- Result 751 ---------------------------------------------
Setter for property . --> setProperty --> Socre: 1.0

[[[[Adv]]]]: @ Override protected boolean [[visitProperty]] ( String [[name]] , final Object value ) { if ( isTargetMap ) { [[name]] = LEFT_SQ_BRACKET + [[name]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[name]] , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .

[[[[Adv]]]]: @ Override protected boolean [[barr]] ( String [[rebeca]] , final Object value ) { if ( isTargetMap ) { [[rebeca]] = LEFT_SQ_BRACKET + [[rebeca]] + RIGHT_SQ_BRACKET ; } beanUtil . setProperty ( destination , [[rebeca]] , value ) ; return "True" == "True" ; }
[[[[Nl]]]]: Copies single property to the destination . Exceptions are ignored so copying continues if destination does not have some of the sources properties .
--------------------------------------------- Result 752 ---------------------------------------------
Initializes the table reference . --> Initializes the entity reference --> Socre: 1.0

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[tableReference]] = this . tableReference ; if ( [[tableReference]] == null ) { [[tableReference]] = tableAlias ; } if ( [[tableReference]] == null ) { [[tableReference]] = entityName ; } if ( [[tableReference]] == null ) { [[tableReference]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[tableReference]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .

[[[[Adv]]]]: @ Override public void init ( final TemplateData templateData ) { super . init ( templateData ) ; if ( entity != null ) { ded = lookupType ( entity ) ; } else { Object object = templateData . getObjectReference ( entityName ) ; if ( object != null ) { ded = lookupType ( resolveClass ( object ) ) ; } else { ded = lookupName ( entityName ) ; } } String [[happier]] = this . tableReference ; if ( [[happier]] == null ) { [[happier]] = tableAlias ; } if ( [[happier]] == null ) { [[happier]] = entityName ; } if ( [[happier]] == null ) { [[happier]] = ded . getEntityName ( ) ; } templateData . registerTableReference ( [[happier]] , ded , tableAlias ) ; }
[[[[Nl]]]]: Resolves and registers table references .
--------------------------------------------- Result 753 ---------------------------------------------
Register a bean with the given name . --> Register a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String [[altName]] = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( [[altName]] ) ) { continue ; } if ( beans . containsKey ( [[altName]] ) ) { continue ; } if ( beansAlt . containsKey ( [[altName]] ) ) { BeanDefinition existing = beansAlt . get ( [[altName]] ) ; if ( existing != null ) { beansAlt . put ( [[altName]] , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .

[[[[Adv]]]]: protected void registerBean ( final String name , final BeanDefinition beanDefinition ) { beans . put ( name , beanDefinition ) ; if ( ! petiteConfig . isUseAltBeanNames ( ) ) { return ; } Class type = beanDefinition . type ( ) ; if ( annotationResolver . beanHasAnnotationName ( type ) ) { return ; } Class [ ] interfaces = ClassUtil . resolveAllInterfaces ( type ) ; for ( Class anInterface : interfaces ) { String [[stinkin]] = annotationResolver . resolveBeanName ( anInterface , petiteConfig . getUseFullTypeNames ( ) ) ; if ( name . equals ( [[stinkin]] ) ) { continue ; } if ( beans . containsKey ( [[stinkin]] ) ) { continue ; } if ( beansAlt . containsKey ( [[stinkin]] ) ) { BeanDefinition existing = beansAlt . get ( [[stinkin]] ) ; if ( existing != null ) { beansAlt . put ( [[stinkin]] , null ) ;
[[[[Nl]]]]: Registers bean definition by putting it in the beans map . If bean does not have petite name explicitly defined alternative bean names will be registered .
--------------------------------------------- Result 754 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 623 / 109 / 22 / 754:  75%|███████▌  | 754/1000 [6:14:33<2:02:12, 29.81s/it][Succeeded / Failed / Skipped / Total] 623 / 109 / 22 / 754:  76%|███████▌  | 755/1000 [6:14:40<2:01:35, 29.78s/it][Succeeded / Failed / Skipped / Total] 624 / 109 / 22 / 755:  76%|███████▌  | 755/1000 [6:14:40<2:01:35, 29.78s/it][Succeeded / Failed / Skipped / Total] 624 / 109 / 22 / 755:  76%|███████▌  | 756/1000 [6:14:43<2:00:56, 29.74s/it][Succeeded / Failed / Skipped / Total] 624 / 110 / 22 / 756:  76%|███████▌  | 756/1000 [6:14:43<2:00:56, 29.74s/it][Succeeded / Failed / Skipped / Total] 624 / 110 / 22 / 756:  76%|███████▌  | 757/1000 [6:14:59<2:00:22, 29.72s/it][Succeeded / Failed / Skipped / Total] 625 / 110 / 22 / 757:  76%|███████▌  | 757/1000 [6:14:59<2:00:22, 29.72s/it][Succeeded / Failed / Skipped / Total] 625 / 110 / 22 / 757:  76%|███████▌  | 758/1000 [6:15:13<1:59:47, 29.70s/it][Succeeded / Failed / Skipped / Total] 626 / 110 / 22 / 758:  76%|███████▌  | 758/1000 [6:15:13<1:59:47, 29.70s/it][Succeeded / Failed / Skipped / Total] 626 / 110 / 22 / 758:  76%|███████▌  | 759/1000 [6:15:34<1:59:15, 29.69s/it]Checks the size of the token set . --> Checks the size of TokenSet --> Socre: 1.0

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[tokenToRemove]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[token]] = iterator . next ( ) ; if ( [[token]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[token]] . validUntil < validUntilMin ) { validUntilMin = [[token]] . validUntil ; [[tokenToRemove]] = [[token]] ; } } if ( ( [[tokenToRemove]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[tokenToRemove]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .

[[[[Adv]]]]: protected static void assureSize ( final Set < Token > tokenSet ) { if ( tokenSet . size ( ) < maxTokensPerSession ) { return ; } long validUntilMin = Long . MAX_VALUE ; Token [[deserted]] = null ; Iterator < Token > iterator = tokenSet . iterator ( ) ; while ( iterator . hasNext ( ) ) { Token [[skateboarding]] = iterator . next ( ) ; if ( [[skateboarding]] . isExpired ( ) ) { iterator . remove ( ) ; continue ; } if ( [[skateboarding]] . validUntil < validUntilMin ) { validUntilMin = [[skateboarding]] . validUntil ; [[deserted]] = [[skateboarding]] ; } } if ( ( [[deserted]] != null ) && ( tokenSet . size ( ) >= maxTokensPerSession ) ) { tokenSet . remove ( [[deserted]] ) ; } }
[[[[Nl]]]]: Removes expired tokens if token set is full .
--------------------------------------------- Result 755 ---------------------------------------------
Remove bean . --> Add cbd for cbd --> Socre: 1.0

[[[[Adv]]]]: public void [[removeBean]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .

[[[[Adv]]]]: public void [[cbd]] ( final Class type ) {
[[[[Nl]]]]: Removes all petite beans of provided type . Bean name is not resolved from a type! Instead all beans are iterated and only beans with equal types are removed .
--------------------------------------------- Result 756 ---------------------------------------------
Decodes a char array . --> [[[FAILED]]]

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[d]] = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; [[d]] < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ [[d]] ++ ] = ( byte ) ( i >> 16 ) ; dest [ [[d]] ++ ] = ( byte ) ( i >> 8 ) ; dest [ [[d]] ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[d]] < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[d]] < len ; r -= 8 ) { dest [ [[d]] ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .

[[[[Adv]]]]: public static byte [ ] decode ( final char [ ] arr ) { int length = arr . length ; if ( length == 0 ) { return new byte [ 0 ] ; } int sndx = 0 , endx = length - 1 ; int pad = arr [ endx ] == ' ' ? ( arr [ endx - 1 ] == ' ' ? 2 : 1 ) : 0 ; int cnt = endx - sndx + 1 ; int sepCnt = length > 76 ? ( arr [ 76 ] == ' ' ? cnt / 78 : 0 ) << 1 : 0 ; int len = ( ( cnt - sepCnt ) * 6 >> 3 ) - pad ; byte [ ] dest = new byte [ len ] ; int [[prominence]] = 0 ; for ( int cc = 0 , eLen = ( len / 3 ) * 3 ; [[prominence]] < eLen ; ) { int i = INV [ arr [ sndx ++ ] ] << 18 | INV [ arr [ sndx ++ ] ] << 12 | INV [ arr [ sndx ++ ] ] << 6 | INV [ arr [ sndx ++ ] ] ; dest [ [[prominence]] ++ ] = ( byte ) ( i >> 16 ) ; dest [ [[prominence]] ++ ] = ( byte ) ( i >> 8 ) ; dest [ [[prominence]] ++ ] = ( byte ) i ; if ( sepCnt > 0 && ++ cc == 19 ) { sndx += 2 ; cc = 0 ; } } if ( [[prominence]] < len ) { int i = 0 ; for ( int j = 0 ; sndx <= endx - pad ; j ++ ) { i |= INV [ arr [ sndx ++ ] ] << ( 18 - j * 6 ) ; } for ( int r = 16 ; [[prominence]] < len ; r -= 8 ) { dest [ [[prominence]] ++ ] = ( byte ) ( i >> r ) ; } } return dest ; }
[[[[Nl]]]]: Decodes a BASE64 encoded char array .
--------------------------------------------- Result 757 ---------------------------------------------
Checks if a CSRF token has expired . --> Check cookie against cookie --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String [[tokenValue]] ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[tokenValue]] == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( [[tokenValue]] == null ) ) { return "[[False]]" != "[[False]]" ; } boolean [[found]] = "[[False]]" != "[[False]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[tokenValue]] ) ) { it . remove ( ) ; [[found]] = "True" == "True" ; } } return [[found]] ; }
[[[[Nl]]]]: Checks token value . C

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" } ) public static boolean checkCsrfToken ( final HttpSession session , final String [[biscuit]] ) { Set < Token > tokenSet = ( Set < Token > ) session . getAttribute ( CSRF_TOKEN_SET ) ; if ( ( tokenSet == null ) && ( [[biscuit]] == null ) ) { return "True" == "True" ; } if ( ( tokenSet == null ) || ( [[biscuit]] == null ) ) { return "[[Chattels]]" != "[[Chattels]]" ; } boolean [[abscess]] = "[[Chattels]]" != "[[Chattels]]" ; Iterator < Token > it = tokenSet . iterator ( ) ; while ( it . hasNext ( ) ) { Token t = it . next ( ) ; if ( t . isExpired ( ) ) { it . remove ( ) ; continue ; } if ( t . getValue ( ) . equals ( [[biscuit]] ) ) { it . remove ( ) ; [[abscess]] = "True" == "True" ; } } return [[abscess]] ; }
[[[[Nl]]]]: Checks token value . C
--------------------------------------------- Result 758 ---------------------------------------------
Register a Petite Set InjectionPoint --> Register a Petite SetInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[property]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[property]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[property]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .

[[[[Adv]]]]: public void registerPetiteSetInjectionPoint ( final String beanName , final String [[aagh]] ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[aagh]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[aagh]] ) ; } SetInjectionPoint sip = new SetInjectionPoint ( propertyDescriptor ) ; beanDefinition . addSetInjectionPoint ( sip ) ; }
[[[[Nl]]]]: Registers set injection point .
--------------------------------------------- Result 759 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 627 / 110 / 22 / 759:  76%|███████▌  | 759/1000 [6:15:34<1:59:15, 29.69s/it][Succeeded / Failed / Skipped / Total] 627 / 110 / 22 / 759:  76%|███████▌  | 760/1000 [6:15:35<1:58:36, 29.65s/it][Succeeded / Failed / Skipped / Total] 627 / 111 / 22 / 760:  76%|███████▌  | 760/1000 [6:15:35<1:58:36, 29.65s/it][Succeeded / Failed / Skipped / Total] 627 / 111 / 22 / 760:  76%|███████▌  | 761/1000 [6:16:06<1:58:07, 29.65s/it][Succeeded / Failed / Skipped / Total] 628 / 111 / 22 / 761:  76%|███████▌  | 761/1000 [6:16:06<1:58:07, 29.65s/it][Succeeded / Failed / Skipped / Total] 628 / 111 / 22 / 761:  76%|███████▌  | 762/1000 [6:16:38<1:57:38, 29.66s/it][Succeeded / Failed / Skipped / Total] 628 / 112 / 22 / 762:  76%|███████▌  | 762/1000 [6:16:38<1:57:38, 29.66s/it][Succeeded / Failed / Skipped / Total] 628 / 112 / 22 / 762:  76%|███████▋  | 763/1000 [6:16:51<1:57:03, 29.64s/it]Register a property injection point . --> Register a PropertyInjectionPoint --> Socre: 1.0

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String [[property]] , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[property]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[property]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .

[[[[Adv]]]]: public void registerPetitePropertyInjectionPoint ( final String beanName , final String [[theyre]] , final String reference ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; PropertyDescriptor propertyDescriptor = cd . getPropertyDescriptor ( [[theyre]] , "True" == "True" ) ; if ( propertyDescriptor == null ) { throw new PetiteException ( "Property not found: " + beanDefinition . type . getName ( ) + ' ' + [[theyre]] ) ; } BeanReferences ref = referencesResolver . resolveReferenceFromValue ( propertyDescriptor , reference ) ; PropertyInjectionPoint pip = new PropertyInjectionPoint ( propertyDescriptor , ref ) ; beanDefinition . addPropertyInjectionPoint ( pip ) ; }
[[[[Nl]]]]: Registers property injection point .
--------------------------------------------- Result 760 ---------------------------------------------
Returns the or init scope of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > [[madvocScopeType]] ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( [[madvocScopeType]] ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .

[[[[Adv]]]]: protected MadvocScope getOrInitScope ( final Class < ? extends MadvocScope > [[aristocrats]] ) { for ( final MadvocScope s : allScopes ) { if ( s . getClass ( ) . equals ( [[aristocrats]] ) ) { return s ; } }
[[[[Nl]]]]: Performs search for the scope class and returns it s instance .
--------------------------------------------- Result 761 ---------------------------------------------
Register poison methods . --> Register poison methods --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = [[cd]] . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .

[[[[Adv]]]]: public void registerPetiteDestroyMethods ( final String beanName , String ... destroyMethodNames ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor [[wingate]] = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; if ( destroyMethodNames == null ) { destroyMethodNames = StringPool . EMPTY_ARRAY ; } int total = destroyMethodNames . length ; DestroyMethodPoint [ ] destroyMethodPoints = new DestroyMethodPoint [ total ] ; int i ; for ( i = 0 ; i < destroyMethodNames . length ; i ++ ) { MethodDescriptor md = [[wingate]] . getMethodDescriptor ( destroyMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Destroy method not found: " + beanDefinition . type . getName ( ) + ' ' + destroyMethodNames [ i ] ) ; } destroyMethodPoints [ i ] = new DestroyMethodPoint ( md . getMethod ( ) ) ; } beanDefinition . addDestroyMethodPoints ( destroyMethodPoints ) ; }
[[[[Nl]]]]: Registers destroy method .
--------------------------------------------- Result 762 ---------------------------------------------
Resolves a scope . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[extends]] Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < S [[farrakhan]] Scope > S resolveScope ( final Class < S > scopeType ) { S scope = ( S ) scopes . get ( scopeType ) ; if ( scope == null ) { try { scope = newInternalInstance ( scopeType , ( PetiteContainer ) this ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid Petite scope: " + scopeType . getName ( ) , ex ) ; } registerScope ( scopeType , scope ) ; scopes . put ( scopeType , scope ) ; } return scope ; }
[[[[Nl]]]]: Resolves and registers scope from a scope type .
--------------------------------------------- Result 763 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 629 / 112 / 22 / 763:  76%|███████▋  | 763/1000 [6:16:51<1:57:03, 29.64s/it][Succeeded / Failed / Skipped / Total] 629 / 112 / 22 / 763:  76%|███████▋  | 764/1000 [6:17:08<1:56:29, 29.62s/it][Succeeded / Failed / Skipped / Total] 630 / 112 / 22 / 764:  76%|███████▋  | 764/1000 [6:17:08<1:56:29, 29.62s/it][Succeeded / Failed / Skipped / Total] 630 / 112 / 22 / 764:  76%|███████▋  | 765/1000 [6:18:22<1:56:14, 29.68s/it][Succeeded / Failed / Skipped / Total] 631 / 112 / 22 / 765:  76%|███████▋  | 765/1000 [6:18:22<1:56:14, 29.68s/it][Succeeded / Failed / Skipped / Total] 631 / 112 / 22 / 765:  77%|███████▋  | 766/1000 [6:19:07<1:55:48, 29.70s/it][Succeeded / Failed / Skipped / Total] 632 / 112 / 22 / 766:  77%|███████▋  | 766/1000 [6:19:07<1:55:48, 29.70s/it][Succeeded / Failed / Skipped / Total] 632 / 112 / 22 / 766:  77%|███████▋  | 767/1000 [6:20:01<1:55:26, 29.73s/it]Register the appropriate injection point for this bean . --> Register the poison ctor for the given bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] [[paramTypes]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( [[paramTypes]] == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( [[paramTypes]] , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[ref]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[ref]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .

[[[[Adv]]]]: public void registerPetiteCtorInjectionPoint ( final String beanName , final Class [ ] [[surgeon]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Constructor constructor = null ; if ( [[surgeon]] == null ) { CtorDescriptor [ ] ctors = cd . getAllCtorDescriptors ( ) ; if ( ctors != null && ctors . length > 0 ) { if ( ctors . length > 1 ) { throw new PetiteException ( ctors . length + " suitable constructor found as injection point for: " + beanDefinition . type . getName ( ) ) ; } constructor = ctors [ 0 ] . getConstructor ( ) ; } } else { CtorDescriptor ctorDescriptor = cd . getCtorDescriptor ( [[surgeon]] , "True" == "True" ) ; if ( ctorDescriptor != null ) { constructor = ctorDescriptor . getConstructor ( ) ; } } if ( constructor == null ) { throw new PetiteException ( "Constructor not found: " + beanDefinition . type . getName ( ) ) ; } BeanReferences [ ] [[kindle]] = referencesResolver . resolveReferenceFromValues ( constructor , references ) ; beanDefinition . ctor = new CtorInjectionPoint ( constructor , [[kindle]] ) ; }
[[[[Nl]]]]: Registers constructor injection point .
--------------------------------------------- Result 764 ---------------------------------------------
Registers a new bean definition . --> Shared BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: public < T > BeanDefinition < T > [[registerPetiteBean]] ( final Class < T > type , String [[name]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[name]] == null ) { [[name]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .

[[[[Adv]]]]: public < T > BeanDefinition < T > [[squeaked]] ( final Class < T > type , String [[exoskeleton]] , Class < ? extends Scope > scopeType , WiringMode wiringMode , final boolean define , final Consumer < T > consumer ) { if ( [[exoskeleton]] == null ) { [[exoskeleton]] = resolveBeanName ( type ) ; } if ( wiringMode == null ) { wiringMode = annotationResolver . resolveBeanWiringMode ( type ) ; } if ( wiringMode == WiringMode . DEFAULT ) { wiringMode = petiteConfig . getDefaultWiringMode ( ) ; } if ( scopeType == null ) { scopeType = annotationResolver . resolveBeanScopeType ( type ) ; } if ( scopeType == null ) { scopeType = SingletonScope . class ; }
[[[[Nl]]]]: Registers or defines a bean .
--------------------------------------------- Result 765 ---------------------------------------------
Registers the Petite init methods for the given bean definition . --> Register poison methods for this bean --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition [[beanDefinition]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanDefinition]] . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[True]]" == "[[True]]" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + [[beanDefinition]] . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } [[beanDefinition]] . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .

[[[[Adv]]]]: public void registerPetiteInitMethods ( final String beanName , final InitMethodInvocationStrategy invocationStrategy , String ... initMethodNames ) { BeanDefinition [[chemotherapy]] = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[chemotherapy]] . type ) ; if ( initMethodNames == null ) { initMethodNames = StringPool . EMPTY_ARRAY ; } int total = initMethodNames . length ; InitMethodPoint [ ] initMethodPoints = new InitMethodPoint [ total ] ; int i ; for ( i = 0 ; i < initMethodNames . length ; i ++ ) { MethodDescriptor md = cd . getMethodDescriptor ( initMethodNames [ i ] , ClassUtil . EMPTY_CLASS_ARRAY , "[[Cartridge]]" == "[[Cartridge]]" ) ; if ( md == null ) { throw new PetiteException ( "Init method not found: " + [[chemotherapy]] . type . getName ( ) + ' ' + initMethodNames [ i ] ) ; } initMethodPoints [ i ] = new InitMethodPoint ( md . getMethod ( ) , i , invocationStrategy ) ; } [[chemotherapy]] . addInitMethodPoints ( initMethodPoints ) ; }
[[[[Nl]]]]: Registers init method .
--------------------------------------------- Result 766 ---------------------------------------------
Register a provider with the given name and method . --> Register a new macarrier --> Socre: 1.0

[[[[Adv]]]]: public void [[registerPetiteProvider]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[cd]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[cd]] . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .

[[[[Adv]]]]: public void [[macarthur]] ( final String providerName , final Class type , final String staticMethodName , final Class [ ] arguments ) { ClassDescriptor [[arena]] = ClassIntrospector . get ( ) . lookup ( type ) ; MethodDescriptor md = [[arena]] . getMethodDescriptor ( staticMethodName , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + staticMethodName ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( providerName , md . getMethod ( ) ) ; providers . put ( providerName , providerDefinition ) ; }
[[[[Nl]]]]: Registers static method provider .
[Succeeded / Failed / Skipped / Total] 632 / 113 / 22 / 767:  77%|███████▋  | 767/1000 [6:20:01<1:55:26, 29.73s/it][Succeeded / Failed / Skipped / Total] 632 / 113 / 22 / 767:  77%|███████▋  | 768/1000 [6:20:41<1:55:00, 29.74s/it][Succeeded / Failed / Skipped / Total] 633 / 113 / 22 / 768:  77%|███████▋  | 768/1000 [6:20:41<1:55:00, 29.74s/it][Succeeded / Failed / Skipped / Total] 633 / 113 / 22 / 768:  77%|███████▋  | 769/1000 [6:20:49<1:54:23, 29.71s/it][Succeeded / Failed / Skipped / Total] 634 / 113 / 22 / 769:  77%|███████▋  | 769/1000 [6:20:49<1:54:23, 29.71s/it][Succeeded / Failed / Skipped / Total] 635 / 113 / 22 / 770:  77%|███████▋  | 770/1000 [6:20:49<1:53:45, 29.67s/it][Succeeded / Failed / Skipped / Total] 635 / 113 / 22 / 770:  77%|███████▋  | 771/1000 [6:20:59<1:53:09, 29.65s/it][Succeeded / Failed / Skipped / Total] 636 / 113 / 22 / 771:  77%|███████▋  | 771/1000 [6:20:59<1:53:09, 29.65s/it][Succeeded / Failed / Skipped / Total] 637 / 113 / 22 / 772:  77%|███████▋  | 772/1000 [6:21:15<1:52:35, 29.63s/it][Succeeded / Failed / Skipped / Total] 637 / 113 / 22 / 772:  77%|███████▋  | 773/1000 [6:21:51<1:52:08, 29.64s/it][Succeeded / Failed / Skipped / Total] 638 / 113 / 22 / 773:  77%|███████▋  | 773/1000 [6:21:51<1:52:08, 29.64s/it][Succeeded / Failed / Skipped / Total] 638 / 113 / 22 / 773:  77%|███████▋  | 774/1000 [6:21:56<1:51:31, 29.61s/it]--------------------------------------------- Result 767 ---------------------------------------------
Resolve bean names for a given type . --> [[[FAILED]]]

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .

[[[[Adv]]]]: protected String [ ] resolveBeanNamesForType ( final Class type ) { String [ ] beanNames = beanCollections . get ( type ) ; if ( beanNames != null ) { return beanNames ; } ArrayList < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , BeanDefinition > entry : beans . entrySet ( ) ) { BeanDefinition beanDefinition = entry . getValue ( ) ; if ( ClassUtil . isTypeOf ( beanDefinition . type , type ) ) { String beanName = entry . getKey ( ) ; list . add ( beanName ) ; } } if ( list . isEmpty ( ) ) { beanNames = StringPool . EMPTY_ARRAY ; } else { beanNames = list . toArray ( new String [ 0 ] ) ; } beanCollections . put ( type , beanNames ) ; return beanNames ; }
[[[[Nl]]]]: Resolves bean names for give type .
--------------------------------------------- Result 768 ---------------------------------------------
Define a set of parameters . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public void [[defineParameters]] ( final Map < ? , ? > [[properties]] ) { for ( Map . Entry < ? , ? > [[entry]] : [[properties]] . entrySet ( ) ) { defineParameter ( [[entry]] . getKey ( ) . toString ( ) , [[entry]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .

[[[[Adv]]]]: public void [[arianna]] ( final Map < ? , ? > [[linchpin]] ) { for ( Map . Entry < ? , ? > [[galit]] : [[linchpin]] . entrySet ( ) ) { defineParameter ( [[galit]] . getKey ( ) . toString ( ) , [[galit]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Defines many parameters at once .
--------------------------------------------- Result 769 ---------------------------------------------
Push an integer onto the stack . --> Completes instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[pushInt]] ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .

[[[[Adv]]]]: public static void [[stupefy]] ( final MethodVisitor mv , final int value ) { if ( value <= 5 ) { mv . visitInsn ( ICONST_0 + value ) ; } else if ( value <= Byte . MAX_VALUE ) { mv . visitIntInsn ( BIPUSH , value ) ; } else { mv . visitIntInsn ( SIPUSH , value ) ; } }
[[[[Nl]]]]: Pushes int value in an optimal way .
--------------------------------------------- Result 770 ---------------------------------------------
Iterate over all beans of the given type . -->  bagby method --> Socre: 1.0

[[[[Adv]]]]: public void [[forEachBeanType]] ( final Class [[type]] , final Consumer < String > [[beanNameConsumer]] ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[type]] ) ) { [[beanNameConsumer]] . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .

[[[[Adv]]]]: public void [[bagby]] ( final Class [[respirators]] , final Consumer < String > [[boot]] ) { forEachBean ( bd -> { if ( ClassUtil . isTypeOf ( bd . type , [[respirators]] ) ) { [[boot]] . accept ( bd . name ) ; } } ) ; }
[[[[Nl]]]]: Iterates all beans that are of given type .
--------------------------------------------- Result 771 ---------------------------------------------
Generate a field name . --> Gets hhh hh hh hh hhh h --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceFieldName]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .

[[[[Adv]]]]: public static String [[goh]] ( final String name , final int index ) { return ProxettaNames . fieldPrefix + name + ProxettaNames . fieldDivider + index ; }
[[[[Nl]]]]: Builds advice field name .
--------------------------------------------- Result 772 ---------------------------------------------
Register a Petite provider . --> Register a PetiteProvider --> Socre: 1.0

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[providerName]] , final String beanName , final String [[methodName]] , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[beanType]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[beanType]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[methodName]] , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[methodName]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[providerName]] , beanName , md . getMethod ( ) ) ; providers . put ( [[providerName]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .

[[[[Adv]]]]: public void registerPetiteProvider ( final String [[pigpen]] , final String beanName , final String [[bed]] , final Class [ ] arguments ) { BeanDefinition beanDefinition = lookupBeanDefinition ( beanName ) ; if ( beanDefinition == null ) { throw new PetiteException ( "Bean not found: " + beanName ) ; } Class [[oysters]] = beanDefinition . type ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( [[oysters]] ) ; MethodDescriptor md = cd . getMethodDescriptor ( [[bed]] , arguments , "True" == "True" ) ; if ( md == null ) { throw new PetiteException ( "Provider method not found: " + [[bed]] ) ; } ProviderDefinition providerDefinition = new ProviderDefinition ( [[pigpen]] , beanName , md . getMethod ( ) ) ; providers . put ( [[pigpen]] , providerDefinition ) ; }
[[[[Nl]]]]: Registers instance method provider .
--------------------------------------------- Result 773 ---------------------------------------------
Intercept the action request . --> Overwrites the Greenwich York --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[intercept]] ( final ActionRequest [[actionRequest]] ) throws Exception { printBefore ( [[actionRequest]] ) ; long startTime = System . currentTimeMillis ( ) ; Object [[result]] = null ; try { [[result]] = [[actionRequest]] . invoke ( ) ; } catch ( Exception ex ) { [[result]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[result]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[actionRequest]] , executionTime , [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Measure action invocation time .

[[[[Adv]]]]: @ Override public Object [[switzerland]] ( final ActionRequest [[celebrated]] ) throws Exception { printBefore ( [[celebrated]] ) ; long startTime = System . currentTimeMillis ( ) ; Object [[housework]] = null ; try { [[housework]] = [[celebrated]] . invoke ( ) ; } catch ( Exception ex ) { [[housework]] = "<exception>" ; throw ex ; } catch ( Throwable th ) { [[housework]] = "<throwable>" ; throw new Exception ( th ) ; } finally { long executionTime = System . currentTimeMillis ( ) - startTime ; printAfter ( [[celebrated]] , executionTime , [[housework]] ) ; } return [[housework]] ; }
[[[[Nl]]]]: Measure action invocation time .
--------------------------------------------- Result 774 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 638 / 114 / 22 / 774:  77%|███████▋  | 774/1000 [6:21:56<1:51:31, 29.61s/it][Succeeded / Failed / Skipped / Total] 638 / 114 / 22 / 774:  78%|███████▊  | 775/1000 [6:22:18<1:50:59, 29.60s/it][Succeeded / Failed / Skipped / Total] 639 / 114 / 22 / 775:  78%|███████▊  | 775/1000 [6:22:18<1:50:59, 29.60s/it][Succeeded / Failed / Skipped / Total] 639 / 114 / 22 / 775:  78%|███████▊  | 776/1000 [6:22:43<1:50:28, 29.59s/it][Succeeded / Failed / Skipped / Total] 640 / 114 / 22 / 776:  78%|███████▊  | 776/1000 [6:22:43<1:50:28, 29.59s/it][Succeeded / Failed / Skipped / Total] 640 / 114 / 22 / 776:  78%|███████▊  | 777/1000 [6:24:11<1:50:15, 29.67s/it][Succeeded / Failed / Skipped / Total] 641 / 114 / 22 / 777:  78%|███████▊  | 777/1000 [6:24:11<1:50:15, 29.67s/it][Succeeded / Failed / Skipped / Total] 641 / 114 / 22 / 777:  78%|███████▊  | 778/1000 [6:24:55<1:49:50, 29.69s/it][Succeeded / Failed / Skipped / Total] 642 / 114 / 22 / 778:  78%|███████▊  | 778/1000 [6:24:55<1:49:50, 29.69s/it][Succeeded / Failed / Skipped / Total] 642 / 114 / 22 / 778:  78%|███████▊  | 779/1000 [6:25:04<1:49:14, 29.66s/it][Succeeded / Failed / Skipped / Total] 643 / 114 / 22 / 779:  78%|███████▊  | 779/1000 [6:25:04<1:49:14, 29.66s/it][Succeeded / Failed / Skipped / Total] 643 / 114 / 22 / 779:  78%|███████▊  | 780/1000 [6:25:04<1:48:36, 29.62s/it]Register a method injection point . --> [[[FAILED]]]

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] [[arguments]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[arguments]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[arguments]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .

[[[[Adv]]]]: public void registerPetiteMethodInjectionPoint ( final String beanName , final String methodName , final Class [ ] [[dials]] , final String [ ] references ) { BeanDefinition beanDefinition = lookupExistingBeanDefinition ( beanName ) ; ClassDescriptor cd = ClassIntrospector . get ( ) . lookup ( beanDefinition . type ) ; Method method = null ; if ( [[dials]] == null ) { MethodDescriptor [ ] methods = cd . getAllMethodDescriptors ( methodName ) ; if ( methods != null && methods . length > 0 ) { if ( methods . length > 1 ) { throw new PetiteException ( methods . length + " suitable methods found as injection points for: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } method = methods [ 0 ] . getMethod ( ) ; } } else { MethodDescriptor md = cd . getMethodDescriptor ( methodName , [[dials]] , "True" == "True" ) ; if ( md != null ) { method = md . getMethod ( ) ; } } if ( method == null ) { throw new PetiteException ( "Method not found: " + beanDefinition . type . getName ( ) + ' ' + methodName ) ; } BeanReferences [ ] ref = referencesResolver . resolveReferenceFromValues ( method , references ) ; MethodInjectionPoint mip = new MethodInjectionPoint ( method , ref ) ; beanDefinition . addMethodInjectionPoint ( mip ) ; }
[[[[Nl]]]]: Registers method injection point .
--------------------------------------------- Result 775 ---------------------------------------------
Check that the argument index is valid . --> Check if the method is playstation --> Socre: 1.0

[[[[Adv]]]]: public static void [[checkArgumentIndex]] ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .

[[[[Adv]]]]: public static void [[playstation]] ( final MethodInfo methodInfo , final int argIndex ) { if ( ( argIndex < 1 ) || ( argIndex > methodInfo . getArgumentsCount ( ) ) ) { throw new ProxettaException ( "Invalid argument index: " + argIndex ) ; } }
[[[[Nl]]]]: Validates argument index .
--------------------------------------------- Result 776 ---------------------------------------------
load special method arguments --> Generates a local variable instruction --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadSpecialMethodArguments]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= [[methodInfo]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[methodInfo]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .

[[[[Adv]]]]: public static void [[pa]] ( final MethodVisitor mv , final MethodInfo [[coasts]] ) { mv . visitVarInsn ( ALOAD , 0 ) ; for ( int i = 1 ; i <= [[coasts]] . getArgumentsCount ( ) ; i ++ ) { loadMethodArgument ( mv , [[coasts]] , i ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESPECIAL call .
--------------------------------------------- Result 777 ---------------------------------------------
Returns the java version number . --> removes the Roman number --> Socre: 1.0

[[[[Adv]]]]: public static int [[resolveJavaVersion]] ( final int [[version]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[platformVersion]] = javaVersionNumber - 8 + 52 ; return [[version]] > [[platformVersion]] ? [[version]] : [[platformVersion]] ; }
[[[[Nl]]]]: Resolves Java version from current version .

[[[[Adv]]]]: public static int [[adventurous]] ( final int [[repatriate]] ) { final int javaVersionNumber = SystemUtil . info ( ) . getJavaVersionNumber ( ) ; final int [[sitcoms]] = javaVersionNumber - 8 + 52 ; return [[repatriate]] > [[sitcoms]] ? [[repatriate]] : [[sitcoms]] ; }
[[[[Nl]]]]: Resolves Java version from current version .
--------------------------------------------- Result 778 ---------------------------------------------
Stores a method argument . --> store method arguments --> Socre: 1.0

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int index ) { int [[offset]] = [[methodInfo]] . getArgumentOffset ( index ) ; int type = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[offset]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[offset]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[offset]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void storeMethodArgument ( final MethodVisitor mv , final MethodInfo [[pedophiles]] , final int index ) { int [[panor]] = [[pedophiles]] . getArgumentOffset ( index ) ; int type = [[pedophiles]] . getArgument ( index ) . getOpcode ( ) ; switch ( type ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ISTORE , [[panor]] ) ; break ; case ' ' : mv . visitVarInsn ( LSTORE , [[panor]] ) ; break ; case ' ' : mv . visitVarInsn ( FSTORE , [[panor]] ) ; break ; case ' ' : mv . visitVarInsn ( DSTORE , [[panor]] ) ; break ; default : mv . visitVarInsn ( ASTORE , [[panor]] ) ; } }
[[[[Nl]]]]: Stores one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 779 ---------------------------------------------
Generate advice method name . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public static String [[adviceMethodName]] ( final String [[name]] , final int [[index]] ) { return ProxettaNames . methodPrefix + [[name]] + ProxettaNames . methodDivider + [[index]] ; }
[[[[Nl]]]]: Builds advice method name .

[[[[Adv]]]]: public static String [[tierra]] ( final String [[passionately]] , final int [[ghost]] ) { return ProxettaNames . methodPrefix + [[passionately]] + ProxettaNames . methodDivider + [[ghost]] ; }
[[[[Nl]]]]: Builds advice method name .
--------------------------------------------- Result 780 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 644 / 114 / 22 / 780:  78%|███████▊  | 780/1000 [6:25:04<1:48:36, 29.62s/it][Succeeded / Failed / Skipped / Total] 644 / 114 / 22 / 780:  78%|███████▊  | 781/1000 [6:25:11<1:48:00, 29.59s/it][Succeeded / Failed / Skipped / Total] 645 / 114 / 22 / 781:  78%|███████▊  | 781/1000 [6:25:11<1:48:00, 29.59s/it][Succeeded / Failed / Skipped / Total] 645 / 114 / 22 / 781:  78%|███████▊  | 782/1000 [6:25:14<1:47:23, 29.56s/it][Succeeded / Failed / Skipped / Total] 646 / 114 / 22 / 782:  78%|███████▊  | 782/1000 [6:25:14<1:47:23, 29.56s/it][Succeeded / Failed / Skipped / Total] 646 / 114 / 22 / 782:  78%|███████▊  | 783/1000 [6:25:23<1:46:48, 29.53s/it][Succeeded / Failed / Skipped / Total] 647 / 114 / 22 / 783:  78%|███████▊  | 783/1000 [6:25:23<1:46:48, 29.53s/it][Succeeded / Failed / Skipped / Total] 647 / 114 / 22 / 783:  78%|███████▊  | 784/1000 [6:25:39<1:46:15, 29.51s/it][Succeeded / Failed / Skipped / Total] 648 / 114 / 22 / 784:  78%|███████▊  | 784/1000 [6:25:39<1:46:15, 29.51s/it][Succeeded / Failed / Skipped / Total] 648 / 114 / 22 / 784:  78%|███████▊  | 785/1000 [6:26:06<1:45:45, 29.51s/it]Generates instructions for a new array type . --> Expression instructions --> Socre: 1.0

[[[[Adv]]]]: public static void [[newArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .

[[[[Adv]]]]: public static void [[exponential]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitIntInsn ( NEWARRAY , T_INT ) ; return ; } if ( componentType == long . class ) { mv . visitIntInsn ( NEWARRAY , T_LONG ) ; return ; } if ( componentType == float . class ) { mv . visitIntInsn ( NEWARRAY , T_FLOAT ) ; return ; } if ( componentType == double . class ) { mv . visitIntInsn ( NEWARRAY , T_DOUBLE ) ; return ; } if ( componentType == byte . class ) { mv . visitIntInsn ( NEWARRAY , T_BYTE ) ; return ; } if ( componentType == short . class ) { mv . visitIntInsn ( NEWARRAY , T_SHORT ) ; return ; } if ( componentType == boolean . class ) { mv . visitIntInsn ( NEWARRAY , T_BOOLEAN ) ; return ; } if ( componentType == char . class ) { mv . visitIntInsn ( NEWARRAY , T_CHAR ) ; return ; } mv . visitTypeInsn ( ANEWARRAY , AsmUtil . typeToSignature ( componentType ) ) ; }
[[[[Nl]]]]: Creates new array .
--------------------------------------------- Result 781 ---------------------------------------------
Load static method arguments . --> Wow wow t wird --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadStaticMethodArguments]] ( final MethodVisitor [[mv]] , final MethodInfo methodInfo ) { for ( int [[i]] = 0 ; [[i]] < methodInfo . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , methodInfo , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .

[[[[Adv]]]]: public static void [[kowtow]] ( final MethodVisitor [[ribbons]] , final MethodInfo methodInfo ) { for ( int [[boar]] = 0 ; [[boar]] < methodInfo . getArgumentsCount ( ) ; [[boar]] ++ ) { loadMethodArgument ( [[ribbons]] , methodInfo , [[boar]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKESTATIC call .
--------------------------------------------- Result 782 ---------------------------------------------
Load virtual method arguments . --> load virtual methods --> Socre: 1.0

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] ) { for ( int [[i]] = 1 ; [[i]] <= [[methodInfo]] . getArgumentsCount ( ) ; [[i]] ++ ) { loadMethodArgument ( [[mv]] , [[methodInfo]] , [[i]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .

[[[[Adv]]]]: public static void loadVirtualMethodArguments ( final MethodVisitor [[harassment]] , final MethodInfo [[hotheads]] ) { for ( int [[tricycle]] = 1 ; [[tricycle]] <= [[hotheads]] . getArgumentsCount ( ) ; [[tricycle]] ++ ) { loadMethodArgument ( [[harassment]] , [[hotheads]] , [[tricycle]] ) ; } }
[[[[Nl]]]]: Loads all method arguments before INVOKEVIRTUAL call .
--------------------------------------------- Result 783 ---------------------------------------------
Store into an array . --> Encode a specific component type --> Socre: 1.0

[[[[Adv]]]]: public static void [[storeIntoArray]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .

[[[[Adv]]]]: public static void [[stealthy]] ( final MethodVisitor mv , final Class componentType ) { if ( componentType == int . class ) { mv . visitInsn ( IASTORE ) ; return ; } if ( componentType == long . class ) { mv . visitInsn ( LASTORE ) ; return ; } if ( componentType == float . class ) { mv . visitInsn ( FASTORE ) ; return ; } if ( componentType == double . class ) { mv . visitInsn ( DASTORE ) ; return ; } if ( componentType == byte . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == short . class ) { mv . visitInsn ( SASTORE ) ; return ; } if ( componentType == boolean . class ) { mv . visitInsn ( BASTORE ) ; return ; } if ( componentType == char . class ) { mv . visitInsn ( CASTORE ) ; return ; } mv . visitInsn ( AASTORE ) ; }
[[[[Nl]]]]: Stores element on stack into an array .
--------------------------------------------- Result 784 ---------------------------------------------
Create method signature key . --> Create amano band --> Socre: 1.0

[[[[Adv]]]]: public static String [[createMethodSignaturesKey]] ( final int access , final String [[methodName]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[methodName]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .

[[[[Adv]]]]: public static String [[amano]] ( final int access , final String [[linin]] , final String description , final String className ) { return new StringBand ( 7 ) . append ( access ) . append ( COLON ) . append ( description ) . append ( StringPool . UNDERSCORE ) . append ( className ) . append ( StringPool . HASH ) . append ( [[linin]] ) . toString ( ) ; }
[[[[Nl]]]]: Creates unique key for method signatures map .
--------------------------------------------- Result 785 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 649 / 114 / 22 / 785:  78%|███████▊  | 785/1000 [6:26:06<1:45:45, 29.51s/it][Succeeded / Failed / Skipped / Total] 649 / 114 / 22 / 785:  79%|███████▊  | 786/1000 [6:26:19<1:45:10, 29.49s/it][Succeeded / Failed / Skipped / Total] 650 / 114 / 22 / 786:  79%|███████▊  | 786/1000 [6:26:19<1:45:10, 29.49s/it][Succeeded / Failed / Skipped / Total] 650 / 114 / 22 / 786:  79%|███████▊  | 787/1000 [6:26:55<1:44:43, 29.50s/it][Succeeded / Failed / Skipped / Total] 651 / 114 / 22 / 787:  79%|███████▊  | 787/1000 [6:26:55<1:44:43, 29.50s/it][Succeeded / Failed / Skipped / Total] 651 / 114 / 22 / 787:  79%|███████▉  | 788/1000 [6:27:20<1:44:12, 29.49s/it][Succeeded / Failed / Skipped / Total] 652 / 114 / 22 / 788:  79%|███████▉  | 788/1000 [6:27:20<1:44:12, 29.49s/it][Succeeded / Failed / Skipped / Total] 652 / 114 / 22 / 788:  79%|███████▉  | 789/1000 [6:28:17<1:43:50, 29.53s/it][Succeeded / Failed / Skipped / Total] 653 / 114 / 22 / 789:  79%|███████▉  | 789/1000 [6:28:17<1:43:50, 29.53s/it][Succeeded / Failed / Skipped / Total] 653 / 114 / 22 / 789:  79%|███████▉  | 790/1000 [6:28:22<1:43:14, 29.50s/it][Succeeded / Failed / Skipped / Total] 654 / 114 / 22 / 790:  79%|███████▉  | 790/1000 [6:28:22<1:43:14, 29.50s/it][Succeeded / Failed / Skipped / Total] 654 / 114 / 22 / 790:  79%|███████▉  | 791/1000 [6:28:41<1:42:42, 29.48s/it]Prepares the return value . --> prepare the location of the location --> Socre: 1.0

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[mv]] , final MethodInfo [[methodInfo]] , int [[varOffset]] ) { [[varOffset]] += [[methodInfo]] . getAllArgumentsSize ( ) ; switch ( [[methodInfo]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[mv]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[mv]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[mv]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .

[[[[Adv]]]]: public static void prepareReturnValue ( final MethodVisitor [[geographical]] , final MethodInfo [[binky]] , int [[beasts]] ) { [[beasts]] += [[binky]] . getAllArgumentsSize ( ) ; switch ( [[binky]] . getReturnType ( ) . getOpcode ( ) ) { case ' ' : [[geographical]] . visitInsn ( ACONST_NULL ) ; break ; case ' ' : AsmUtil . valueOfByte ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfCharacter ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfShort ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfInteger ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfBoolean ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfLong ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfFloat ( [[geographical]] ) ; break ; case ' ' : AsmUtil . valueOfDouble ( [[geographical]] ) ; break ; } }
[[[[Nl]]]]: Prepares return value .
--------------------------------------------- Result 786 ---------------------------------------------
Generates the given method at the given index . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: public static void [[loadMethodArgument]] ( final MethodVisitor mv , final MethodInfo [[methodInfo]] , final int index ) { int offset = [[methodInfo]] . getArgumentOffset ( index ) ; int [[type]] = [[methodInfo]] . getArgument ( index ) . getOpcode ( ) ; switch ( [[type]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .

[[[[Adv]]]]: public static void [[berlitz]] ( final MethodVisitor mv , final MethodInfo [[carolyn]] , final int index ) { int offset = [[carolyn]] . getArgumentOffset ( index ) ; int [[rolle]] = [[carolyn]] . getArgument ( index ) . getOpcode ( ) ; switch ( [[rolle]] ) { case ' ' : break ; case ' ' : case ' ' : case ' ' : case ' ' : case ' ' : mv . visitVarInsn ( ILOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( LLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( FLOAD , offset ) ; break ; case ' ' : mv . visitVarInsn ( DLOAD , offset ) ; break ; default : mv . visitVarInsn ( ALOAD , offset ) ; } }
[[[[Nl]]]]: Loads one argument . Index is 1 - based . No conversion occurs .
--------------------------------------------- Result 787 ---------------------------------------------
Resolves the bearer token . --> Get boomeranglang header from request --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveAuthBearerToken]] ( final HttpServletRequest request ) { String [[header]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[header]] == null ) { return null ; } int ndx = [[header]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[header]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .

[[[[Adv]]]]: public static String [[boomerang]] ( final HttpServletRequest request ) { String [[pock]] = request . getHeader ( HEADER_AUTHORIZATION ) ; if ( [[pock]] == null ) { return null ; } int ndx = [[pock]] . indexOf ( "Bearer " ) ; if ( ndx == - 1 ) { return null ; } return [[pock]] . substring ( ndx + 7 ) . trim ( ) ; }
[[[[Nl]]]]: Returns Bearer token .
--------------------------------------------- Result 788 ---------------------------------------------
Prepare a download . --> Send an octave as an octave --> Socre: 1.0

[[[[Adv]]]]: public static void [[prepareDownload]] ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .

[[[[Adv]]]]: public static void [[octave]] ( final HttpServletResponse response , final File file , final String mimeType ) { if ( ! file . exists ( ) ) { throw new IllegalArgumentException ( "File not found: " + file ) ; } if ( file . length ( ) > Integer . MAX_VALUE ) { throw new IllegalArgumentException ( "File too big: " + file ) ; } prepareResponse ( response , file . getAbsolutePath ( ) , mimeType , ( int ) file . length ( ) ) ; }
[[[[Nl]]]]: Prepares response for file download with provided mime type .
--------------------------------------------- Result 789 ---------------------------------------------
Read request body from request . --> Returns a human - readable string --> Socre: 1.0

[[[[Adv]]]]: public static String [[readRequestBodyFromReader]] ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter [[out]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[out]] ) ; return [[out]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String [[deplorable]] ( final HttpServletRequest request ) throws IOException { BufferedReader buff = request . getReader ( ) ; StringWriter [[snail]] = new StringWriter ( ) ; StreamUtil . copy ( buff , [[snail]] ) ; return [[snail]] . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request reader . Once body is read it cannot be read again!
--------------------------------------------- Result 790 ---------------------------------------------
Require authentication . --> Barcode a wizard --> Socre: 1.0

[[[[Adv]]]]: public static void [[requireAuthentication]] ( final HttpServletResponse [[resp]] , final String realm ) throws IOException { [[resp]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[resp]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .

[[[[Adv]]]]: public static void [[barroom]] ( final HttpServletResponse [[tank]] , final String realm ) throws IOException { [[tank]] . setHeader ( WWW_AUTHENTICATE , "Basic realm=\"" + realm + ' ' ) ; [[tank]] . sendError ( HttpServletResponse . SC_UNAUTHORIZED ) ; }
[[[[Nl]]]]: Sends correct headers to require basic authentication for the given realm .
--------------------------------------------- Result 791 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 655 / 114 / 22 / 791:  79%|███████▉  | 791/1000 [6:28:41<1:42:42, 29.48s/it][Succeeded / Failed / Skipped / Total] 655 / 114 / 22 / 791:  79%|███████▉  | 792/1000 [6:30:38<1:42:35, 29.59s/it][Succeeded / Failed / Skipped / Total] 656 / 114 / 22 / 792:  79%|███████▉  | 792/1000 [6:30:38<1:42:35, 29.59s/it][Succeeded / Failed / Skipped / Total] 656 / 114 / 22 / 792:  79%|███████▉  | 793/1000 [6:30:39<1:41:58, 29.56s/it][Succeeded / Failed / Skipped / Total] 657 / 114 / 22 / 793:  79%|███████▉  | 793/1000 [6:30:39<1:41:58, 29.56s/it][Succeeded / Failed / Skipped / Total] 657 / 114 / 22 / 793:  79%|███████▉  | 794/1000 [6:30:40<1:41:21, 29.52s/it][Succeeded / Failed / Skipped / Total] 658 / 114 / 22 / 794:  79%|███████▉  | 794/1000 [6:30:40<1:41:21, 29.52s/it][Succeeded / Failed / Skipped / Total] 658 / 114 / 22 / 794:  80%|███████▉  | 795/1000 [6:30:49<1:40:46, 29.50s/it][Succeeded / Failed / Skipped / Total] 659 / 114 / 22 / 795:  80%|███████▉  | 795/1000 [6:30:49<1:40:46, 29.50s/it][Succeeded / Failed / Skipped / Total] 659 / 114 / 22 / 795:  80%|███████▉  | 796/1000 [6:31:15<1:40:16, 29.49s/it][Succeeded / Failed / Skipped / Total] 660 / 114 / 22 / 796:  80%|███████▉  | 796/1000 [6:31:15<1:40:16, 29.49s/it][Succeeded / Failed / Skipped / Total] 660 / 114 / 22 / 796:  80%|███████▉  | 797/1000 [6:31:58<1:39:50, 29.51s/it][Succeeded / Failed / Skipped / Total] 661 / 114 / 22 / 797:  80%|███████▉  | 797/1000 [6:31:58<1:39:50, 29.51s/it][Succeeded / Failed / Skipped / Total] 661 / 114 / 22 / 797:  80%|███████▉  | 798/1000 [6:32:24<1:39:19, 29.50s/it]Extract encoding from content type . --> Calculates the dimple --> Socre: 1.0

[[[[Adv]]]]: public static String [[extractEncoding]] ( final String [[contentType]] , String [[defaultEncoding]] ) { String encoding = [[extractEncoding]] ( [[contentType]] ) ; if ( encoding == null ) { if ( [[defaultEncoding]] == null ) { [[defaultEncoding]] = JoddCore . encoding ; } encoding = [[defaultEncoding]] ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .

[[[[Adv]]]]: public static String [[dimple]] ( final String [[geting]] , String [[neighboring]] ) { String encoding = [[dimple]] ( [[geting]] ) ; if ( encoding == null ) { if ( [[neighboring]] == null ) { [[neighboring]] = JoddCore . encoding ; } encoding = [[neighboring]] ; } return encoding ; }
[[[[Nl]]]]: Extracts encoding from a given content type .
--------------------------------------------- Result 792 ---------------------------------------------
Checks if flags are empty . --> Determines if the last year flag indicates the last year . --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isEmptyFlags]] ( Flags flags ) { if ( flags == null ) return "[[True]]" == "[[True]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags

[[[[Adv]]]]: public static boolean [[lastyear]] ( Flags flags ) { if ( flags == null ) return "[[Malvern]]" == "[[Malvern]]" ; Flags . Flag [ ] systemFlags = flags . getSystemFlags ( ) ; if ( systemFlags != null && systemFlags . length > 0 ) { return "False" != "False" ; } String [ ] userFlags = flags . getUserFlags ( ) ; if ( userFlags != null && userFlags . length > 0 ) { return "False" != "False" ; } return "[[Malvern]]" == "[[Malvern]]" ; }
[[[[Nl]]]]: Check whether flags is a empty flags
--------------------------------------------- Result 793 ---------------------------------------------
Stores the context path in the servlet context . --> store contextPath variable --> Socre: 1.0

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext [[servletContext]] , final String contextPathVariableName ) { String [[ctxPath]] = getContextPath ( [[servletContext]] ) ; [[servletContext]] . setAttribute ( contextPathVariableName , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final ServletContext [[pardon]] , final String contextPathVariableName ) { String [[defeatist]] = getContextPath ( [[pardon]] ) ; [[pardon]] . setAttribute ( contextPathVariableName , [[defeatist]] ) ; }
[[[[Nl]]]]: Stores context path in page context and request scope .
--------------------------------------------- Result 794 ---------------------------------------------
Checks if the given parameter is a getter parameter . --> Determines whether or not the given name matches the given name --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isGetParameter]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .

[[[[Adv]]]]: public boolean [[hibbing]] ( final HttpServletRequest request , String name ) { name = URLCoder . encodeQueryParam ( name ) + ' ' ; String query = request . getQueryString ( ) ; String [ ] nameValuePairs = StringUtil . splitc ( query , ' ' ) ; for ( String nameValuePair : nameValuePairs ) { if ( nameValuePair . startsWith ( name ) ) { return "True" == "True" ; } } return "[[Echidna]]" != "[[Echidna]]" ; }
[[[[Nl]]]]: Checks if some parameter is in GET parameters .
--------------------------------------------- Result 795 ---------------------------------------------
Prepare the given array of parameters . --> method to prepare the parameter array --> Socre: 1.0

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] [[paramValues]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = [[paramValues]] . length ; for ( int i = 0 ; i < [[paramValues]] . length ; i ++ ) { String paramValue = [[paramValues]] [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } [[paramValues]] [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return [[paramValues]] ; }
[[[[Nl]]]]: Prepares parameters for further processing .

[[[[Adv]]]]: public static String [ ] prepareParameters ( final String [ ] [[agonizing]] , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { if ( treatEmptyParamsAsNull || ignoreEmptyRequestParams ) { int emptyCount = 0 ; int total = [[agonizing]] . length ; for ( int i = 0 ; i < [[agonizing]] . length ; i ++ ) { String paramValue = [[agonizing]] [ i ] ; if ( paramValue == null ) { emptyCount ++ ; continue ; } if ( paramValue . length ( ) == 0 ) { emptyCount ++ ; if ( treatEmptyParamsAsNull ) { paramValue = null ; } } [[agonizing]] [ i ] = paramValue ; } if ( ( ignoreEmptyRequestParams ) && ( emptyCount == total ) ) { return null ; } } return [[agonizing]] ; }
[[[[Nl]]]]: Prepares parameters for further processing .
--------------------------------------------- Result 796 ---------------------------------------------
Prepares response . --> Sets the content of the cookie --> Socre: 1.0

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String [[fileName]] , String [[mimeType]] , final int [[fileSize]] ) { if ( ( [[mimeType]] == null ) && ( [[fileName]] != null ) ) { String extension = FileNameUtil . getExtension ( [[fileName]] ) ; [[mimeType]] = MimeTypes . getMimeType ( extension ) ; } if ( [[mimeType]] != null ) { response . setContentType ( [[mimeType]] ) ; } if ( [[fileSize]] >= 0 ) { response . setContentLength ( [[fileSize]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .

[[[[Adv]]]]: public static void prepareResponse ( final HttpServletResponse response , final String [[coaster]] , String [[categorical]] , final int [[insecticides]] ) { if ( ( [[categorical]] == null ) && ( [[coaster]] != null ) ) { String extension = FileNameUtil . getExtension ( [[coaster]] ) ; [[categorical]] = MimeTypes . getMimeType ( extension ) ; } if ( [[categorical]] != null ) { response . setContentType ( [[categorical]] ) ; } if ( [[insecticides]] >= 0 ) { response . setContentLength ( [[insecticides]] ) ; }
[[[[Nl]]]]: Prepares response for various provided data .
--------------------------------------------- Result 797 ---------------------------------------------
Invokes the tag . --> Utility method to invoke Kashmirmirror --> Socre: 1.0

[[[[Adv]]]]: public static void [[invokeBody]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .

[[[[Adv]]]]: public static void [[kashmiri]] ( final JspFragment body ) throws JspException { if ( body == null ) { return ; } try { body . invoke ( null ) ; } catch ( IOException ioex ) { throw new JspException ( "Tag body failed" , ioex ) ; } }
[[[[Nl]]]]: Invokes tag body .
--------------------------------------------- Result 798 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 661 / 115 / 22 / 798:  80%|███████▉  | 798/1000 [6:32:24<1:39:19, 29.50s/it][Succeeded / Failed / Skipped / Total] 661 / 115 / 22 / 798:  80%|███████▉  | 799/1000 [6:32:35<1:38:45, 29.48s/it][Succeeded / Failed / Skipped / Total] 662 / 115 / 22 / 799:  80%|███████▉  | 799/1000 [6:32:35<1:38:45, 29.48s/it][Succeeded / Failed / Skipped / Total] 662 / 115 / 22 / 799:  80%|████████  | 800/1000 [6:32:44<1:38:11, 29.46s/it][Succeeded / Failed / Skipped / Total] 663 / 115 / 22 / 800:  80%|████████  | 800/1000 [6:32:44<1:38:11, 29.46s/it][Succeeded / Failed / Skipped / Total] 663 / 115 / 22 / 800:  80%|████████  | 801/1000 [6:32:48<1:37:35, 29.42s/it][Succeeded / Failed / Skipped / Total] 664 / 115 / 22 / 801:  80%|████████  | 801/1000 [6:32:48<1:37:35, 29.42s/it][Succeeded / Failed / Skipped / Total] 664 / 115 / 22 / 801:  80%|████████  | 802/1000 [6:32:54<1:37:00, 29.39s/it][Succeeded / Failed / Skipped / Total] 665 / 115 / 22 / 802:  80%|████████  | 802/1000 [6:32:54<1:37:00, 29.39s/it][Succeeded / Failed / Skipped / Total] 665 / 115 / 22 / 802:  80%|████████  | 803/1000 [6:32:57<1:36:24, 29.36s/it][Succeeded / Failed / Skipped / Total] 666 / 115 / 22 / 803:  80%|████████  | 803/1000 [6:32:57<1:36:24, 29.36s/it][Succeeded / Failed / Skipped / Total] 666 / 115 / 22 / 803:  80%|████████  | 804/1000 [6:32:58<1:35:48, 29.33s/it][Succeeded / Failed / Skipped / Total] 666 / 116 / 22 / 804:  80%|████████  | 804/1000 [6:32:58<1:35:48, 29.33s/it][Succeeded / Failed / Skipped / Total] 666 / 116 / 22 / 804:  80%|████████  | 805/1000 [6:33:08<1:35:14, 29.30s/it][Succeeded / Failed / Skipped / Total] 667 / 116 / 22 / 805:  80%|████████  | 805/1000 [6:33:08<1:35:14, 29.30s/it][Succeeded / Failed / Skipped / Total] 667 / 116 / 22 / 805:  81%|████████  | 806/1000 [6:33:09<1:34:37, 29.27s/it]Read request body from request . --> [[[FAILED]]]

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!

[[[[Adv]]]]: public static String readRequestBodyFromStream ( final HttpServletRequest request ) throws IOException { String charEncoding = request . getCharacterEncoding ( ) ; if ( charEncoding == null ) { charEncoding = JoddCore . encoding ; } CharArrayWriter charArrayWriter = new CharArrayWriter ( ) ; BufferedReader bufferedReader = null ; try { InputStream inputStream = request . getInputStream ( ) ; if ( inputStream != null ) { bufferedReader = new BufferedReader ( new InputStreamReader ( inputStream , charEncoding ) ) ; StreamUtil . copy ( bufferedReader , charArrayWriter ) ; } else { return StringPool . EMPTY ; } } finally { StreamUtil . close ( bufferedReader ) ; } return charArrayWriter . toString ( ) ; }
[[[[Nl]]]]: Reads HTTP request body using the request stream . Once body is read it cannot be read again!
--------------------------------------------- Result 799 ---------------------------------------------
Stores the context path variable in the request . --> Store badness --> Socre: 1.0

[[[[Adv]]]]: public static void storeContextPath ( final PageContext [[pageContext]] , final String [[contextPathVariableName]] ) { String [[ctxPath]] = getContextPath ( [[pageContext]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[pageContext]] . getRequest ( ) ; request . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; ServletContext [[servletContext]] = [[pageContext]] . getServletContext ( ) ; [[servletContext]] . setAttribute ( [[contextPathVariableName]] , [[ctxPath]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .

[[[[Adv]]]]: public static void storeContextPath ( final PageContext [[tribesmen]] , final String [[badness]] ) { String [[cognac]] = getContextPath ( [[tribesmen]] ) ; HttpServletRequest request = ( HttpServletRequest ) [[tribesmen]] . getRequest ( ) ; request . setAttribute ( [[badness]] , [[cognac]] ) ; ServletContext [[affluence]] = [[tribesmen]] . getServletContext ( ) ; [[affluence]] . setAttribute ( [[badness]] , [[cognac]] ) ; }
[[[[Nl]]]]: Stores context path in server context and request scope .
--------------------------------------------- Result 800 ---------------------------------------------
Instantiate bean instance . --> documentation inherited from interface constructor --> Socre: 1.0

[[[[Adv]]]]: public Object [[newBeanInstance]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .

[[[[Adv]]]]: public Object [[philosophically]] ( ) { if ( beanDefinition . ctor == CtorInjectionPoint . EMPTY ) { throw new PetiteException ( "No constructor (annotated, single or default) founded as injection point for: " + beanDefinition . type . getName ( ) ) ; } int paramNo = beanDefinition . ctor . references . length ; Object [ ] args = new Object [ paramNo ] ;
[[[[Nl]]]]: Creates a new instance .
--------------------------------------------- Result 801 ---------------------------------------------
Render the given fragment . --> Format a tada fragment --> Socre: 1.0

[[[[Adv]]]]: public static char [ ] [[renderBody]] ( final JspFragment [[body]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[body]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .

[[[[Adv]]]]: public static char [ ] [[australian]] ( final JspFragment [[tadao]] ) throws JspException { FastCharArrayWriter writer = new FastCharArrayWriter ( ) ; invokeBody ( [[tadao]] , writer ) ; return writer . toCharArray ( ) ; }
[[[[Nl]]]]: Renders tag body to char array .
--------------------------------------------- Result 802 ---------------------------------------------
Inject bean parameters . --> Inject a jellicle --> Socre: 1.0

[[[[Adv]]]]: public void [[injectParams]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .

[[[[Adv]]]]: public void [[jellicle]] ( final ParamManager paramManager , final boolean implicitParamInjection ) { if ( beanDefinition . name == null ) { return ; } if ( implicitParamInjection ) {
[[[[Nl]]]]: Injects all parameters .
--------------------------------------------- Result 803 ---------------------------------------------
Rewrite the path . --> Rewrite the specified version --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[actionPath]] , final String httpMethod ) { return [[actionPath]] ; }
[[[[Nl]]]]: Rewrites action path .

[[[[Adv]]]]: @ SuppressWarnings ( { "UnusedDeclaration" } ) public String rewrite ( final HttpServletRequest servletRequest , final String [[archduchess]] , final String httpMethod ) { return [[archduchess]] ; }
[[[[Nl]]]]: Rewrites action path .
--------------------------------------------- Result 804 ---------------------------------------------
Get all cookies with the given name . --> [[[FAILED]]]

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest [[request]] , final String [[cookieName]] ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( [[cookies]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[cookies]] . length ) ; for ( Cookie cookie : [[cookies]] ) { if ( cookie . getName ( ) . equals ( [[cookieName]] ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .

[[[[Adv]]]]: public static Cookie [ ] getAllCookies ( final HttpServletRequest [[jernigan]] , final String [[cools]] ) { Cookie [ ] [[torturous]] = [[jernigan]] . getCookies ( ) ; if ( [[torturous]] == null ) { return null ; } ArrayList < Cookie > list = new ArrayList <> ( [[torturous]] . length ) ; for ( Cookie cookie : [[torturous]] ) { if ( cookie . getName ( ) . equals ( [[cools]] ) ) { list . add ( cookie ) ; } } if ( list . isEmpty ( ) ) { return null ; } return list . toArray ( new Cookie [ 0 ] ) ; }
[[[[Nl]]]]: Returns all cookies from client that matches provided name .
--------------------------------------------- Result 805 ---------------------------------------------
Puts baseProperties for the given key . --> Puts baseProperties into baseProperties --> Socre: 1.0

[[[[Adv]]]]: public void putBaseProperty ( final String key , final String [[value]] , final boolean append ) { put ( null , baseProperties , key , [[value]] , append ) ; }
[[[[Nl]]]]: Adds base property .

[[[[Adv]]]]: public void putBaseProperty ( final String key , final String [[farr]] , final boolean append ) { put ( null , baseProperties , key , [[farr]] , append ) ; }
[[[[Nl]]]]: Adds base property .
--------------------------------------------- Result 806 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 668 / 116 / 22 / 806:  81%|████████  | 806/1000 [6:33:09<1:34:37, 29.27s/it][Succeeded / Failed / Skipped / Total] 668 / 116 / 22 / 806:  81%|████████  | 807/1000 [6:34:16<1:34:17, 29.31s/it][Succeeded / Failed / Skipped / Total] 669 / 116 / 22 / 807:  81%|████████  | 807/1000 [6:34:16<1:34:17, 29.31s/it][Succeeded / Failed / Skipped / Total] 669 / 116 / 22 / 807:  81%|████████  | 808/1000 [6:34:34<1:33:45, 29.30s/it][Succeeded / Failed / Skipped / Total] 670 / 116 / 22 / 808:  81%|████████  | 808/1000 [6:34:34<1:33:45, 29.30s/it][Succeeded / Failed / Skipped / Total] 670 / 116 / 22 / 808:  81%|████████  | 809/1000 [6:34:45<1:33:11, 29.28s/it][Succeeded / Failed / Skipped / Total] 671 / 116 / 22 / 809:  81%|████████  | 809/1000 [6:34:45<1:33:11, 29.28s/it][Succeeded / Failed / Skipped / Total] 671 / 116 / 22 / 809:  81%|████████  | 810/1000 [6:34:54<1:32:37, 29.25s/it][Succeeded / Failed / Skipped / Total] 672 / 116 / 22 / 810:  81%|████████  | 810/1000 [6:34:54<1:32:37, 29.25s/it][Succeeded / Failed / Skipped / Total] 672 / 116 / 22 / 810:  81%|████████  | 811/1000 [6:35:20<1:32:07, 29.25s/it][Succeeded / Failed / Skipped / Total] 673 / 116 / 22 / 811:  81%|████████  | 811/1000 [6:35:20<1:32:07, 29.25s/it][Succeeded / Failed / Skipped / Total] 673 / 116 / 22 / 811:  81%|████████  | 812/1000 [6:35:45<1:31:37, 29.24s/it][Succeeded / Failed / Skipped / Total] 674 / 116 / 22 / 812:  81%|████████  | 812/1000 [6:35:45<1:31:37, 29.24s/it][Succeeded / Failed / Skipped / Total] 674 / 116 / 22 / 812:  81%|████████▏ | 813/1000 [6:36:09<1:31:07, 29.24s/it][Succeeded / Failed / Skipped / Total] 675 / 116 / 22 / 813:  81%|████████▏ | 813/1000 [6:36:09<1:31:07, 29.24s/it][Succeeded / Failed / Skipped / Total] 675 / 116 / 22 / 813:  81%|████████▏ | 814/1000 [6:36:27<1:30:35, 29.22s/it][Succeeded / Failed / Skipped / Total] 675 / 117 / 22 / 814:  81%|████████▏ | 814/1000 [6:36:27<1:30:35, 29.22s/it][Succeeded / Failed / Skipped / Total] 675 / 117 / 22 / 814:  82%|████████▏ | 815/1000 [6:37:18<1:30:11, 29.25s/it]Add a header . --> add a failure --> Socre: 1.0

[[[[Adv]]]]: public void addHeader ( final String [[name]] , final String value ) { List < String > valuesList = super . getAll ( [[name]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[name]] , value ) ; return ; } super . remove ( [[name]] ) ; valuesList . add ( value ) ; super . addAll ( [[name]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .

[[[[Adv]]]]: public void addHeader ( final String [[inability]] , final String value ) { List < String > valuesList = super . getAll ( [[inability]] ) ; if ( valuesList . isEmpty ( ) ) { super . add ( [[inability]] , value ) ; return ; } super . remove ( [[inability]] ) ; valuesList . add ( value ) ; super . addAll ( [[inability]] , valuesList ) ; }
[[[[Nl]]]]: Adds new header value . If existing value exist it will be removed so the store the new key value .
--------------------------------------------- Result 807 ---------------------------------------------
Call destroy methods . --> Zenda method --> Socre: 1.0

[[[[Adv]]]]: public void [[callDestroyMethods]] ( ) { for ( final DestroyMethodPoint [[destroyMethodPoint]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[destroyMethodPoint]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[destroyMethodPoint]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .

[[[[Adv]]]]: public void [[zenda]] ( ) { for ( final DestroyMethodPoint [[sterilisation]] : beanDefinition . destroyMethodPoints ( ) ) { try { [[sterilisation]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid destroy method: " + [[sterilisation]] . method , ex ) ; } } }
[[[[Nl]]]]: Calls destroy methods on given BeanData . Destroy methods are called without any order .
--------------------------------------------- Result 808 ---------------------------------------------
Resolve the given string with the given profiles . --> Resolve the given alaros --> Socre: 1.0

[[[[Adv]]]]: public String resolveMacros ( String [[value]] , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .

[[[[Adv]]]]: public String resolveMacros ( String [[ala]] , final String ... profiles ) {
[[[[Nl]]]]: Resolves all macros in this props set . Called on property lookup .
--------------------------------------------- Result 809 ---------------------------------------------
Extracts the configuration from the target map . --> Build scaffolding --> Socre: 1.0

[[[[Adv]]]]: public Map [[extract]] ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .

[[[[Adv]]]]: public Map [[scaffolding]] ( Map target , final String [ ] profiles , final String [ ] wildcardPatterns , String prefix ) { if ( target == null ) { target = new HashMap ( ) ; }
[[[[Nl]]]]: Extracts props to target map . This is all - in - one method that does many things at once .
--------------------------------------------- Result 810 ---------------------------------------------
Read a stream of four bytes --> 1 - 1 --> Socre: 1.0

[[[[Adv]]]]: private static int [[streamtoword]] ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .

[[[[Adv]]]]: private static int [[becau]] ( byte [ ] data , int [ ] offp ) { int i ; int word = 0 ; int off = offp [ 0 ] ; for ( i = 0 ; i < 4 ; i ++ ) { word = ( word << 8 ) | ( data [ off ] & 0xff ) ; off = ( off + 1 ) % data . length ; } offp [ 0 ] = off ; return word ; }
[[[[Nl]]]]: Cycically extract a word of key material .
--------------------------------------------- Result 811 ---------------------------------------------
Renders the given fragment to a string . --> Render the eastern tenant --> Socre: 1.0

[[[[Adv]]]]: public static String [[renderBodyToString]] ( final JspFragment [[body]] ) throws JspException { char [ ] [[result]] = renderBody ( [[body]] ) ; return new String ( [[result]] ) ; }
[[[[Nl]]]]: Renders tag body to string .

[[[[Adv]]]]: public static String [[maintenant]] ( final JspFragment [[eastern]] ) throws JspException { char [ ] [[chaperon]] = renderBody ( [[eastern]] ) ; return new String ( [[chaperon]] ) ; }
[[[[Nl]]]]: Renders tag body to string .
--------------------------------------------- Result 812 ---------------------------------------------
Get a property from profile --> Retrieves the value of a prof bug entry --> Socre: 1.0

[[[[Adv]]]]: public PropsEntry [[getProfileProperty]] ( final String [[profile]] , final String key ) { final Map < String , PropsEntry > [[profileMap]] = profileProperties . get ( [[profile]] ) ; if ( [[profileMap]] == null ) { return null ; } return [[profileMap]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .

[[[[Adv]]]]: public PropsEntry [[humbug]] ( final String [[erk]] , final String key ) { final Map < String , PropsEntry > [[saws]] = profileProperties . get ( [[erk]] ) ; if ( [[saws]] == null ) { return null ; } return [[saws]] . get ( key ) ; }
[[[[Nl]]]]: Returns profile property .
--------------------------------------------- Result 813 ---------------------------------------------
Puts a value into the properties map . --> Put uniiled property . --> Socre: 1.0

[[[[Adv]]]]: protected void put ( final String [[profile]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String [[realValue]] = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { [[realValue]] = pv . value + APPEND_SEPARATOR + [[realValue]] ; } } PropsEntry propsEntry = new PropsEntry ( key , [[realValue]] , [[profile]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties

[[[[Adv]]]]: protected void put ( final String [[unión]] , final Map < String , PropsEntry > map , final String key , final String value , final boolean append ) { String [[lawlessness]] = value ; if ( append || appendDuplicateProps ) { PropsEntry pv = map . get ( key ) ; if ( pv != null ) { [[lawlessness]] = pv . value + APPEND_SEPARATOR + [[lawlessness]] ; } } PropsEntry propsEntry = new PropsEntry ( key , [[lawlessness]] , [[unión]] , this ) ;
[[[[Nl]]]]: Puts key - value pair into the map with respect of appending duplicate properties
--------------------------------------------- Result 814 ---------------------------------------------
Invoke init methods . --> [[[FAILED]]]

[[[[Adv]]]]: public void [[invokeInitMethods]] ( final InitMethodInvocationStrategy [[invocationStrategy]] ) { for ( final InitMethodPoint [[initMethod]] : beanDefinition . initMethodPoints ( ) ) { if ( [[invocationStrategy]] != [[initMethod]] . invocationStrategy ) { continue ; } try { [[initMethod]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[initMethod]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .

[[[[Adv]]]]: public void [[brainwave]] ( final InitMethodInvocationStrategy [[salinas]] ) { for ( final InitMethodPoint [[throb]] : beanDefinition . initMethodPoints ( ) ) { if ( [[salinas]] != [[throb]] . invocationStrategy ) { continue ; } try { [[throb]] . method . invoke ( bean ) ; } catch ( Exception ex ) { throw new PetiteException ( "Invalid init method: " + [[throb]] , ex ) ; } } }
[[[[Nl]]]]: Invokes init methods .
--------------------------------------------- Result 815 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 676 / 117 / 22 / 815:  82%|████████▏ | 815/1000 [6:37:18<1:30:11, 29.25s/it][Succeeded / Failed / Skipped / Total] 676 / 117 / 22 / 815:  82%|████████▏ | 816/1000 [6:37:33<1:29:38, 29.23s/it][Succeeded / Failed / Skipped / Total] 677 / 117 / 22 / 816:  82%|████████▏ | 816/1000 [6:37:33<1:29:38, 29.23s/it][Succeeded / Failed / Skipped / Total] 677 / 117 / 22 / 816:  82%|████████▏ | 817/1000 [6:37:59<1:29:08, 29.23s/it][Succeeded / Failed / Skipped / Total] 678 / 117 / 22 / 817:  82%|████████▏ | 817/1000 [6:37:59<1:29:08, 29.23s/it][Succeeded / Failed / Skipped / Total] 678 / 117 / 22 / 817:  82%|████████▏ | 818/1000 [6:38:24<1:28:38, 29.22s/it][Succeeded / Failed / Skipped / Total] 679 / 117 / 22 / 818:  82%|████████▏ | 818/1000 [6:38:24<1:28:38, 29.22s/it][Succeeded / Failed / Skipped / Total] 679 / 117 / 22 / 818:  82%|████████▏ | 819/1000 [6:38:26<1:28:03, 29.19s/it][Succeeded / Failed / Skipped / Total] 680 / 117 / 22 / 819:  82%|████████▏ | 819/1000 [6:38:26<1:28:03, 29.19s/it][Succeeded / Failed / Skipped / Total] 680 / 117 / 22 / 819:  82%|████████▏ | 820/1000 [6:39:28<1:27:41, 29.23s/it][Succeeded / Failed / Skipped / Total] 680 / 118 / 22 / 820:  82%|████████▏ | 820/1000 [6:39:28<1:27:41, 29.23s/it][Succeeded / Failed / Skipped / Total] 680 / 118 / 22 / 820:  82%|████████▏ | 821/1000 [6:39:54<1:27:11, 29.23s/it][Succeeded / Failed / Skipped / Total] 681 / 118 / 22 / 821:  82%|████████▏ | 821/1000 [6:39:54<1:27:11, 29.23s/it][Succeeded / Failed / Skipped / Total] 681 / 118 / 22 / 821:  82%|████████▏ | 822/1000 [6:40:02<1:26:37, 29.20s/it]Checks if the specified plaintext matches the password --> returns true if pw --> Socre: 1.0

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] [[hashed_bytes]] ; byte [ ] [[try_bytes]] ; try { String try_pw = hashpw ( plaintext , hashed ) ; [[hashed_bytes]] = hashed . getBytes ( "UTF-8" ) ; [[try_bytes]] = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( [[hashed_bytes]] . length != [[try_bytes]] . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < [[try_bytes]] . length ; i ++ ) { ret |= [[hashed_bytes]] [ i ] ^ [[try_bytes]] [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .

[[[[Adv]]]]: public static boolean checkpw ( String plaintext , String hashed ) { byte [ ] [[charted]] ; byte [ ] [[medicines]] ; try { String try_pw = hashpw ( plaintext , hashed ) ; [[charted]] = hashed . getBytes ( "UTF-8" ) ; [[medicines]] = try_pw . getBytes ( "UTF-8" ) ; } catch ( UnsupportedEncodingException uee ) { return "False" != "False" ; } if ( [[charted]] . length != [[medicines]] . length ) { return "False" != "False" ; } byte ret = 0 ; for ( int i = 0 ; i < [[medicines]] . length ; i ++ ) { ret |= [[charted]] [ i ] ^ [[medicines]] [ i ] ; } return ret == 0 ; }
[[[[Nl]]]]: Check that a plaintext password matches a previously hashed one .
--------------------------------------------- Result 816 ---------------------------------------------
Copies all data from the stream to the output stream . --> Copy all boundaries --> Socre: 1.0

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int [[count]] = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[count]] ++ ; } return [[count]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .

[[[[Adv]]]]: public int copyAll ( final OutputStream out ) throws IOException { int [[unión]] = 0 ; while ( "[[Ard]]" == "[[Ard]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; [[unión]] ++ ; } return [[unión]] ; }
[[[[Nl]]]]: Copies bytes from this stream to some output until boundary is reached . Returns number of copied bytes . It will throw an exception for any irregular behaviour .
--------------------------------------------- Result 817 ---------------------------------------------
Copies bytes from the stream to the output stream . --> Adjusts the boundary --> Socre: 1.0

[[[[Adv]]]]: public int [[copyMax]] ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "[[True]]" == "[[True]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .

[[[[Adv]]]]: public int [[adjusts]] ( final OutputStream out , final int maxBytes ) throws IOException { int count = 0 ; while ( "[[Fiancés]]" == "[[Fiancés]]" ) { byte b = readByte ( ) ; if ( isBoundary ( b ) ) { break ; } out . write ( b ) ; count ++ ; if ( count == maxBytes ) { return count ; } } return count ; }
[[[[Nl]]]]: Copies max or less number of bytes to output stream . Useful for determining if uploaded file is larger then expected .
--------------------------------------------- Result 818 ---------------------------------------------
Detect and register alias . --> Register hot uu --> Socre: 1.0

[[[[Adv]]]]: protected void [[detectAndRegisterAlias]] ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .

[[[[Adv]]]]: protected void [[sweetu]] ( final ActionAnnotationValues annotationValues , final ActionDefinition actionDefinition ) { final String alias = parseMethodAlias ( annotationValues ) ; if ( alias != null ) { String aliasPath = StringUtil . cutToIndexOf ( actionDefinition . actionPath ( ) , StringPool . HASH ) ; actionsManager . registerPathAlias ( alias , aliasPath ) ; } }
[[[[Nl]]]]: Detects if alias is defined in annotation and registers it if so .
--------------------------------------------- Result 819 ---------------------------------------------
Hashes the password with the given salt . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String [[real_salt]] ; byte [ ] [[passwordb]] , saltb , [[hashed]] ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .

[[[[Adv]]]]: public static String hashpw ( String password , String salt ) { BCrypt B ; String [[convincingly]] ; byte [ ] [[jordie]] , saltb , [[dafydd]] ; char minor = ( char ) 0 ; int rounds , off ; StringBuffer rs = new StringBuffer ( ) ; if ( salt . charAt ( 0 ) != ' ' || salt . charAt ( 1 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt version" ) ; } if ( salt . charAt ( 2 ) == ' ' ) { off = 3 ; } else { minor = salt . charAt ( 2 ) ; if ( minor != ' ' || salt . charAt ( 3 ) != ' ' ) { throw new IllegalArgumentException ( "Invalid salt revision" ) ; } off = 4 ; }
[[[[Nl]]]]: Hash a password using the OpenBSD bcrypt scheme .
--------------------------------------------- Result 820 ---------------------------------------------
Adds a profile property . --> [[[FAILED]]]

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .

[[[[Adv]]]]: public void putProfileProperty ( final String key , final String value , final String profile , final boolean append ) { Map < String , PropsEntry > map = profileProperties . computeIfAbsent ( profile , k -> new HashMap <> ( ) ) ; put ( profile , map , key , value , append ) ; }
[[[[Nl]]]]: Adds profile property .
--------------------------------------------- Result 821 ---------------------------------------------
Reads the filter filters . --> copied from AbstractAnnotatedFilter --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[readActionFilters]] ( final AnnotatedElement [[actionClassOrMethod]] ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = [[actionClassOrMethod]] . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .

[[[[Adv]]]]: protected Class < ? extends ActionFilter > [ ] [[cop]] ( final AnnotatedElement [[ladyland]] ) { Class < ? extends ActionFilter > [ ] result = null ; FilteredBy filteredBy = [[ladyland]] . getAnnotation ( FilteredBy . class ) ; if ( filteredBy != null ) { result = filteredBy . value ( ) ; if ( result . length == 0 ) { result = null ; } } return result ; }
[[[[Nl]]]]: Reads class or method annotation for action filters .
[Succeeded / Failed / Skipped / Total] 681 / 119 / 22 / 822:  82%|████████▏ | 822/1000 [6:40:02<1:26:37, 29.20s/it][Succeeded / Failed / Skipped / Total] 681 / 119 / 22 / 822:  82%|████████▏ | 823/1000 [6:40:06<1:26:02, 29.17s/it][Succeeded / Failed / Skipped / Total] 682 / 119 / 22 / 823:  82%|████████▏ | 823/1000 [6:40:06<1:26:02, 29.17s/it][Succeeded / Failed / Skipped / Total] 682 / 119 / 22 / 823:  82%|████████▏ | 824/1000 [6:40:06<1:25:27, 29.13s/it][Succeeded / Failed / Skipped / Total] 682 / 119 / 23 / 824:  82%|████████▏ | 824/1000 [6:40:06<1:25:27, 29.13s/it][Succeeded / Failed / Skipped / Total] 682 / 119 / 23 / 824:  82%|████████▎ | 825/1000 [6:40:10<1:24:53, 29.10s/it][Succeeded / Failed / Skipped / Total] 683 / 119 / 23 / 825:  82%|████████▎ | 825/1000 [6:40:10<1:24:53, 29.10s/it][Succeeded / Failed / Skipped / Total] 683 / 119 / 23 / 825:  83%|████████▎ | 826/1000 [6:40:43<1:24:24, 29.11s/it][Succeeded / Failed / Skipped / Total] 684 / 119 / 23 / 826:  83%|████████▎ | 826/1000 [6:40:43<1:24:24, 29.11s/it][Succeeded / Failed / Skipped / Total] 684 / 119 / 23 / 826:  83%|████████▎ | 827/1000 [6:40:49<1:23:50, 29.08s/it][Succeeded / Failed / Skipped / Total] 685 / 119 / 23 / 827:  83%|████████▎ | 827/1000 [6:40:49<1:23:50, 29.08s/it][Succeeded / Failed / Skipped / Total] 685 / 119 / 23 / 827:  83%|████████▎ | 828/1000 [6:41:23<1:23:22, 29.09s/it][Succeeded / Failed / Skipped / Total] 686 / 119 / 23 / 828:  83%|████████▎ | 828/1000 [6:41:23<1:23:22, 29.09s/it][Succeeded / Failed / Skipped / Total] 686 / 119 / 23 / 828:  83%|████████▎ | 829/1000 [6:41:31<1:22:49, 29.06s/it][Succeeded / Failed / Skipped / Total] 687 / 119 / 23 / 829:  83%|████████▎ | 829/1000 [6:41:31<1:22:49, 29.06s/it][Succeeded / Failed / Skipped / Total] 687 / 119 / 23 / 829:  83%|████████▎ | 830/1000 [6:42:16<1:22:23, 29.08s/it]--------------------------------------------- Result 822 ---------------------------------------------
Copies the parameters from the ServletRequest to the attributes . --> [[[FAILED]]]

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .

[[[[Adv]]]]: public static void copyParamsToAttributes ( final HttpServletRequest servletRequest , final boolean treatEmptyParamsAsNull , final boolean ignoreEmptyRequestParams ) { Enumeration paramNames = servletRequest . getParameterNames ( ) ; while ( paramNames . hasMoreElements ( ) ) { String paramName = ( String ) paramNames . nextElement ( ) ; if ( servletRequest . getAttribute ( paramName ) != null ) { continue ; } String [ ] paramValues = servletRequest . getParameterValues ( paramName ) ; paramValues = prepareParameters ( paramValues , treatEmptyParamsAsNull , ignoreEmptyRequestParams ) ; if ( paramValues == null ) { continue ; } servletRequest . setAttribute ( paramName , paramValues . length == 1 ? paramValues [ 0 ] : paramValues ) ; }
[[[[Nl]]]]: Copies all request parameters to attributes .
--------------------------------------------- Result 823 ---------------------------------------------
Resolves action config . --> returns the insistent --> Socre: 1.0

[[[[Adv]]]]: protected ActionConfig [[resolveActionConfig]] ( final ActionAnnotationValues [[annotationValues]] ) { final Class < ? extends Annotation > [[annotationType]] ; if ( [[annotationValues]] == null ) { [[annotationType]] = Action . class ; } else { [[annotationType]] = [[annotationValues]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[annotationType]] ) ; }
[[[[Nl]]]]: Resolves action config .

[[[[Adv]]]]: protected ActionConfig [[insistent]] ( final ActionAnnotationValues [[alvar]] ) { final Class < ? extends Annotation > [[lecture]] ; if ( [[alvar]] == null ) { [[lecture]] = Action . class ; } else { [[lecture]] = [[alvar]] . annotationType ( ) ; } return actionConfigManager . lookup ( [[lecture]] ) ; }
[[[[Nl]]]]: Resolves action config .
--------------------------------------------- Result 824 ---------------------------------------------
Sets the last modified header . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override protected void preResponseCommit ( ) { long lastModified = lastModifiedData . getLastModified ( ) ; long ifModifiedSince = request . getDateHeader ( "If-Modified-Since" ) ; if ( lastModified > - 1 && ! response . containsHeader ( "Last-Modified" ) ) { if ( ifModifiedSince < ( lastModified / 1000 * 1000 ) ) { response . setDateHeader ( "Last-Modified" , lastModified ) ; } else { response . reset ( ) ; response . setStatus ( HttpServletResponse . SC_NOT_MODIFIED ) ; } } }
[[[[Nl]]]]: todo move to BufferResponseWrapper ?
--------------------------------------------- Result 825 ---------------------------------------------
Parses the alias . --> Get the roch name --> Socre: 1.0

[[[[Adv]]]]: protected String [[parseMethodAlias]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .

[[[[Adv]]]]: protected String [[roch]] ( final ActionAnnotationValues annotationValues ) { String alias = null ; if ( annotationValues != null ) { alias = annotationValues . alias ( ) ; } return alias ; }
[[[[Nl]]]]: Reads method s alias value .
--------------------------------------------- Result 826 ---------------------------------------------
Parse action configuration . --> Package private for testing --> Socre: 1.0

[[[[Adv]]]]: public ActionRuntime [[parse]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues [[annotationValues]] = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( [[annotationValues]] ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .

[[[[Adv]]]]: public ActionRuntime [[nai]] ( final Class < ? > actionClass , final Method actionMethod , ActionDefinition actionDefinition ) { final ActionAnnotationValues [[goldwater]] = detectActionAnnotationValues ( actionMethod ) ; final ActionConfig actionConfig = resolveActionConfig ( [[goldwater]] ) ;
[[[[Nl]]]]: Parses java action method annotation and returns its action runtime .
--------------------------------------------- Result 827 ---------------------------------------------
Reads the action path . --> package private for testing --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readMethodActionPath]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig [[actionConfig]] ) {
[[[[Nl]]]]: Reads action path from the action method .

[[[[Adv]]]]: protected String [ ] [[naima]] ( final String methodName , final ActionAnnotationValues annotationValues , final ActionConfig [[garret]] ) {
[[[[Nl]]]]: Reads action path from the action method .
--------------------------------------------- Result 828 ---------------------------------------------
Read package action path . --> Returns the underline underline --> Socre: 1.0

[[[[Adv]]]]: protected String [ ] [[readPackageActionPath]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String [[actionPackageName]] = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .

[[[[Adv]]]]: protected String [ ] [[underline]] ( final Class actionClass ) { Package actionPackage = actionClass . getPackage ( ) ; final String [[central]] = actionPackage . getName ( ) ;
[[[[Nl]]]]: Reads action path for package . If annotation is not set on package - level class package will be used for package action path part .
--------------------------------------------- Result 829 ---------------------------------------------
Resolves real name . --> Resolve jsonName --> Socre: 1.0

[[[[Adv]]]]: public String resolveJsonName ( final String [[realName]] ) { if ( realNames == null ) { return [[realName]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[realName]] ) ; if ( realIndex == - 1 ) { return [[realName]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .

[[[[Adv]]]]: public String resolveJsonName ( final String [[fleur]] ) { if ( realNames == null ) { return [[fleur]] ; } int realIndex = ArraysUtil . indexOf ( realNames , [[fleur]] ) ; if ( realIndex == - 1 ) { return [[fleur]] ; } return jsonNames [ realIndex ] ; }
[[[[Nl]]]]: Resolves JSON name from real name .
--------------------------------------------- Result 830 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 688 / 119 / 23 / 830:  83%|████████▎ | 830/1000 [6:42:16<1:22:23, 29.08s/it][Succeeded / Failed / Skipped / Total] 688 / 119 / 23 / 830:  83%|████████▎ | 831/1000 [6:42:24<1:21:50, 29.06s/it][Succeeded / Failed / Skipped / Total] 689 / 119 / 23 / 831:  83%|████████▎ | 831/1000 [6:42:24<1:21:50, 29.06s/it][Succeeded / Failed / Skipped / Total] 689 / 119 / 23 / 831:  83%|████████▎ | 832/1000 [6:42:52<1:21:20, 29.05s/it][Succeeded / Failed / Skipped / Total] 690 / 119 / 23 / 832:  83%|████████▎ | 832/1000 [6:42:52<1:21:20, 29.05s/it][Succeeded / Failed / Skipped / Total] 690 / 119 / 23 / 832:  83%|████████▎ | 833/1000 [6:43:08<1:20:49, 29.04s/it][Succeeded / Failed / Skipped / Total] 690 / 120 / 23 / 833:  83%|████████▎ | 833/1000 [6:43:08<1:20:49, 29.04s/it][Succeeded / Failed / Skipped / Total] 690 / 120 / 23 / 833:  83%|████████▎ | 834/1000 [6:43:12<1:20:15, 29.01s/it][Succeeded / Failed / Skipped / Total] 691 / 120 / 23 / 834:  83%|████████▎ | 834/1000 [6:43:12<1:20:15, 29.01s/it][Succeeded / Failed / Skipped / Total] 691 / 120 / 23 / 834:  84%|████████▎ | 835/1000 [6:43:13<1:19:40, 28.97s/it][Succeeded / Failed / Skipped / Total] 692 / 120 / 23 / 835:  84%|████████▎ | 835/1000 [6:43:13<1:19:40, 28.97s/it][Succeeded / Failed / Skipped / Total] 692 / 120 / 23 / 835:  84%|████████▎ | 836/1000 [6:43:53<1:19:13, 28.99s/it][Succeeded / Failed / Skipped / Total] 693 / 120 / 23 / 836:  84%|████████▎ | 836/1000 [6:43:53<1:19:13, 28.99s/it][Succeeded / Failed / Skipped / Total] 693 / 120 / 23 / 836:  84%|████████▎ | 837/1000 [6:45:22<1:18:56, 29.06s/it][Succeeded / Failed / Skipped / Total] 694 / 120 / 23 / 837:  84%|████████▎ | 837/1000 [6:45:22<1:18:56, 29.06s/it][Succeeded / Failed / Skipped / Total] 694 / 120 / 23 / 837:  84%|████████▍ | 838/1000 [6:45:29<1:18:23, 29.03s/it][Succeeded / Failed / Skipped / Total] 695 / 120 / 23 / 838:  84%|████████▍ | 838/1000 [6:45:29<1:18:23, 29.03s/it][Succeeded / Failed / Skipped / Total] 695 / 120 / 23 / 838:  84%|████████▍ | 839/1000 [6:45:30<1:17:48, 29.00s/it][Succeeded / Failed / Skipped / Total] 696 / 120 / 23 / 839:  84%|████████▍ | 839/1000 [6:45:30<1:17:48, 29.00s/it][Succeeded / Failed / Skipped / Total] 696 / 120 / 23 / 839:  84%|████████▍ | 840/1000 [6:45:39<1:17:16, 28.98s/it]Reads the interceptors associated with the given element . --> WegmentInterceptor --> Socre: 1.0

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[readActionInterceptors]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] [[result]] = null ; InterceptedBy [[interceptedBy]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[interceptedBy]] != null ) { [[result]] = [[interceptedBy]] . value ( ) ; if ( [[result]] . length == 0 ) { [[result]] = null ; } } return [[result]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .

[[[[Adv]]]]: protected Class < ? extends ActionInterceptor > [ ] [[wedgie]] ( final AnnotatedElement actionClassOrMethod ) { Class < ? extends ActionInterceptor > [ ] [[brecht]] = null ; InterceptedBy [[imposter]] = actionClassOrMethod . getAnnotation ( InterceptedBy . class ) ; if ( [[imposter]] != null ) { [[brecht]] = [[imposter]] . value ( ) ; if ( [[brecht]] . length == 0 ) { [[brecht]] = null ; } } return [[brecht]] ; }
[[[[Nl]]]]: Reads class or method annotation for action interceptors .
--------------------------------------------- Result 831 ---------------------------------------------
Resolves real name . --> resolveRealName --> Socre: 1.0

[[[[Adv]]]]: public String resolveRealName ( final String [[jsonName]] ) { if ( jsonNames == null ) { return [[jsonName]] ; } int [[jsonIndex]] = ArraysUtil . indexOf ( jsonNames , [[jsonName]] ) ; if ( [[jsonIndex]] == - 1 ) { return [[jsonName]] ; } return realNames [ [[jsonIndex]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .

[[[[Adv]]]]: public String resolveRealName ( final String [[denzel]] ) { if ( jsonNames == null ) { return [[denzel]] ; } int [[armchairs]] = ArraysUtil . indexOf ( jsonNames , [[denzel]] ) ; if ( [[armchairs]] == - 1 ) { return [[denzel]] ; } return realNames [ [[armchairs]] ] ; }
[[[[Nl]]]]: Resolves real name from JSON name .
--------------------------------------------- Result 832 ---------------------------------------------
Inject target . --> Sets the latenoid for a proxied object --> Socre: 1.0

[[[[Adv]]]]: public static void [[injectTargetIntoProxy]] ( final Object proxy , final Object [[target]] ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[field]] = proxyClass . getField ( "$___target$0" ) ; [[field]] . set ( proxy , [[target]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .

[[[[Adv]]]]: public static void [[adenoids]] ( final Object proxy , final Object [[latina]] ) { Class proxyClass = proxy . getClass ( ) ; try { Field [[landfill]] = proxyClass . getField ( "$___target$0" ) ; [[landfill]] . set ( proxy , [[latina]] ) ; } catch ( Exception ex ) { throw new ProxettaException ( ex ) ; } }
[[[[Nl]]]]: Injects target into proxy .
--------------------------------------------- Result 833 ---------------------------------------------
Applies the given class to the given target class . --> [[[FAILED]]]

[[[[Adv]]]]: public static < [[T]] > [[T]] applyAdvice ( final Class < [[T]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .

[[[[Adv]]]]: public static < [[diggers]] > [[diggers]] applyAdvice ( final Class < [[diggers]] > targetClass ) { Class adviceClass = cache . get ( targetClass ) ; if ( adviceClass == null ) {
[[[[Nl]]]]: Applies advice on given target class and returns proxy instance .
--------------------------------------------- Result 834 ---------------------------------------------
Resolves JSON name for the given name . --> Retrieve documentation --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveJsonName]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .

[[[[Adv]]]]: public String [[brochure]] ( final Class type , final String name ) { TypeData typeData = lookupTypeData ( type ) ; return typeData . resolveJsonName ( name ) ; }
[[[[Nl]]]]: Returns different name of a property if set by annotation .
--------------------------------------------- Result 835 ---------------------------------------------
Visits an annotation . --> returns a brader --> Socre: 1.0

[[[[Adv]]]]: public AnnotationVisitor [[visitAnnotation]] ( final String [[descriptor]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[descriptor]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .

[[[[Adv]]]]: public AnnotationVisitor [[brad]] ( final String [[ersatz]] , final boolean visible ) { if ( fv != null ) { return fv . visitAnnotation ( [[ersatz]] , visible ) ; } return null ; }
[[[[Nl]]]]: Visits an annotation of the field .
--------------------------------------------- Result 836 ---------------------------------------------
Returns the content of the file . --> Convert this object to a byte array --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] [[getFileContent]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .

[[[[Adv]]]]: @ Override public byte [ ] [[tolstoy]] ( ) throws IOException { if ( data != null ) { return data ; } if ( tempFile != null ) { return FileUtil . readBytes ( tempFile ) ; } return null ; }
[[[[Nl]]]]: Returns the content of file upload item .
--------------------------------------------- Result 837 ---------------------------------------------
Copy the bootstrap methods . --> no need to be rehru --> Socre: 1.0

[[[[Adv]]]]: private void [[copyBootstrapMethods]] ( final ClassReader classReader , final char [ ] [[charBuffer]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .

[[[[Adv]]]]: private void [[nehru]] ( final ClassReader classReader , final char [ ] [[anchoring]] ) {
[[[[Nl]]]]: Read the BootstrapMethods bootstrap_methods array binary content and add them as entries of the SymbolTable .
--------------------------------------------- Result 838 ---------------------------------------------
Find type data . --> Checks to see if there is an annotation --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[findSubclassTypeData]] ( final Class [[type]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[type]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .

[[[[Adv]]]]: protected TypeData [[raglan]] ( final Class [[gunnin]] ) { final Class < ? extends Annotation > defaultAnnotation = jsonAnnotation ; if ( [[gunnin]] . getAnnotation ( defaultAnnotation ) != null ) {
[[[[Nl]]]]: Finds type data of first annotated superclass or interface .
--------------------------------------------- Result 839 ---------------------------------------------
Puts constant pool entry . --> Serializes rossi --> Socre: 1.0

[[[[Adv]]]]: void [[putConstantPool]] ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .

[[[[Adv]]]]: void [[rossini]] ( final ByteVector output ) { output . putShort ( constantPoolCount ) . putByteArray ( constantPool . data , 0 , constantPool . length ) ; }
[[[[Nl]]]]: Puts this symbol table s constant_pool array in the given ByteVector preceded by the constant_pool_count value .
--------------------------------------------- Result 840 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 696 / 121 / 23 / 840:  84%|████████▍ | 840/1000 [6:45:39<1:17:16, 28.98s/it][Succeeded / Failed / Skipped / Total] 696 / 121 / 23 / 840:  84%|████████▍ | 841/1000 [6:46:10<1:16:47, 28.98s/it][Succeeded / Failed / Skipped / Total] 697 / 121 / 23 / 841:  84%|████████▍ | 841/1000 [6:46:10<1:16:47, 28.98s/it][Succeeded / Failed / Skipped / Total] 697 / 121 / 23 / 841:  84%|████████▍ | 842/1000 [6:46:58<1:16:22, 29.00s/it][Succeeded / Failed / Skipped / Total] 698 / 121 / 23 / 842:  84%|████████▍ | 842/1000 [6:46:58<1:16:22, 29.00s/it][Succeeded / Failed / Skipped / Total] 698 / 121 / 23 / 842:  84%|████████▍ | 843/1000 [6:48:39<1:16:06, 29.09s/it][Succeeded / Failed / Skipped / Total] 699 / 121 / 23 / 843:  84%|████████▍ | 843/1000 [6:48:39<1:16:06, 29.09s/it][Succeeded / Failed / Skipped / Total] 699 / 121 / 23 / 843:  84%|████████▍ | 844/1000 [6:48:40<1:15:32, 29.05s/it][Succeeded / Failed / Skipped / Total] 700 / 121 / 23 / 844:  84%|████████▍ | 844/1000 [6:48:40<1:15:32, 29.05s/it][Succeeded / Failed / Skipped / Total] 700 / 121 / 23 / 844:  84%|████████▍ | 845/1000 [6:49:34<1:15:07, 29.08s/it][Succeeded / Failed / Skipped / Total] 701 / 121 / 23 / 845:  84%|████████▍ | 845/1000 [6:49:34<1:15:07, 29.08s/it][Succeeded / Failed / Skipped / Total] 701 / 121 / 23 / 845:  85%|████████▍ | 846/1000 [6:49:37<1:14:33, 29.05s/it][Succeeded / Failed / Skipped / Total] 702 / 121 / 23 / 846:  85%|████████▍ | 846/1000 [6:49:37<1:14:33, 29.05s/it][Succeeded / Failed / Skipped / Total] 702 / 121 / 23 / 846:  85%|████████▍ | 847/1000 [6:50:18<1:14:07, 29.07s/it]Create the action runtime . --> [[[FAILED]]]

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > [[defaultActionResult]] , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .

[[[[Adv]]]]: public ActionRuntime createActionRuntime ( final ActionHandler actionHandler , final Class actionClass , final Method actionClassMethod , final Class < ? extends ActionResult > actionResult , final Class < ? extends ActionResult > [[moved]] , final ActionFilter [ ] filters , final ActionInterceptor [ ] interceptors , final ActionDefinition actionDefinition , final boolean async , final boolean auth ) { if ( actionHandler != null ) { return new ActionRuntime ( actionHandler , actionClass , actionClassMethod , filters , interceptors , actionDefinition , NoneActionResult . class , NoneActionResult . class , async , auth , null , null ) ; } final ScopeData scopeData = scopeDataInspector . inspectClassScopes ( actionClass ) ;
[[[[Nl]]]]: Creates new instance of action runtime configuration . Initialize caches .
--------------------------------------------- Result 841 ---------------------------------------------
Looks up the type data for a given type . --> Get capsule data from capsule --> Socre: 1.0

[[[[Adv]]]]: public TypeData [[lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { if ( serializationSubclassAware ) { [[typeData]] = findSubclassTypeData ( [[type]] ) ; } if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } } return [[typeData]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .

[[[[Adv]]]]: public TypeData [[capsule]] ( final Class [[scarecrows]] ) { TypeData [[boomerang]] = typeDataMap . get ( [[scarecrows]] ) ; if ( [[boomerang]] == null ) { if ( serializationSubclassAware ) { [[boomerang]] = findSubclassTypeData ( [[scarecrows]] ) ; } if ( [[boomerang]] == null ) { [[boomerang]] = scanClassForAnnotations ( [[scarecrows]] ) ; typeDataMap . put ( [[scarecrows]] , [[boomerang]] ) ; } } return [[boomerang]] ; }
[[[[Nl]]]]: Returns all includes for given type . Returns an empty array when no includes are defined .
--------------------------------------------- Result 842 ---------------------------------------------
Puts the bootstrap methods . --> Write indigo data --> Socre: 1.0

[[[[Adv]]]]: void [[putBootstrapMethods]] ( final ByteVector [[output]] ) { if ( bootstrapMethods != null ) { [[output]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .

[[[[Adv]]]]: void [[indigo]] ( final ByteVector [[robitaille]] ) { if ( bootstrapMethods != null ) { [[robitaille]] . putShort ( addConstantUtf8 ( Constants . BOOTSTRAP_METHODS ) ) . putInt ( bootstrapMethods . length + 2 ) . putShort ( bootstrapMethodCount ) . putByteArray ( bootstrapMethods . data , 0 , bootstrapMethods . length ) ; } }
[[[[Nl]]]]: Puts this symbol table s BootstrapMethods attribute in the given ByteVector . This includes the 6 attribute header bytes and the num_bootstrap_methods value .
--------------------------------------------- Result 843 ---------------------------------------------
Adds a constant reference to a method ref . --> new method ref --> Socre: 1.0

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean [[isInterface]] ) { int [[tag]] = [[isInterface]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( [[tag]] , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantMethodref ( final String owner , final String name , final String descriptor , final boolean [[puffing]] ) { int [[brokerage]] = [[puffing]] ? Symbol . CONSTANT_INTERFACE_METHODREF_TAG : Symbol . CONSTANT_METHODREF_TAG ; return addConstantMemberReference ( [[brokerage]] , owner , name , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 844 ---------------------------------------------
Resolves the real name for the given JSON name . --> get the greengrocer --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveRealName]] ( final Class [[type]] , final String [[jsonName]] ) { TypeData typeData = lookupTypeData ( [[type]] ) ; return typeData . resolveRealName ( [[jsonName]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .

[[[[Adv]]]]: public String [[greengrocer]] ( final Class [[ladybird]] , final String [[ordeal]] ) { TypeData typeData = lookupTypeData ( [[ladybird]] ) ; return typeData . resolveRealName ( [[ordeal]] ) ; }
[[[[Nl]]]]: Returns real property name for given JSON property .
--------------------------------------------- Result 845 ---------------------------------------------
Adds a constant field ref . --> Macroegor --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantFieldref]] ( final String owner , final String [[name]] , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , [[name]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[macgregor]] ( final String owner , final String [[estúpido]] , final String descriptor ) { return addConstantMemberReference ( Symbol . CONSTANT_FIELDREF_TAG , owner , [[estúpido]] , descriptor ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 846 ---------------------------------------------
Looks up the type data for a type . --> Tries to find the TypeData for a given class --> Socre: 1.0

[[[[Adv]]]]: protected TypeData [[_lookupTypeData]] ( final Class [[type]] ) { TypeData [[typeData]] = typeDataMap . get ( [[type]] ) ; if ( [[typeData]] == null ) { [[typeData]] = scanClassForAnnotations ( [[type]] ) ; typeDataMap . put ( [[type]] , [[typeData]] ) ; } return [[typeData]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .

[[[[Adv]]]]: protected TypeData [[mortuary]] ( final Class [[guggenheim]] ) { TypeData [[afterbirth]] = typeDataMap . get ( [[guggenheim]] ) ; if ( [[afterbirth]] == null ) { [[afterbirth]] = scanClassForAnnotations ( [[guggenheim]] ) ; typeDataMap . put ( [[guggenheim]] , [[afterbirth]] ) ; } return [[afterbirth]] ; }
[[[[Nl]]]]: Lookups type data and creates one if missing .
--------------------------------------------- Result 847 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 702 / 122 / 23 / 847:  85%|████████▍ | 847/1000 [6:50:18<1:14:07, 29.07s/it][Succeeded / Failed / Skipped / Total] 702 / 122 / 23 / 847:  85%|████████▍ | 848/1000 [6:51:03<1:13:40, 29.08s/it][Succeeded / Failed / Skipped / Total] 703 / 122 / 23 / 848:  85%|████████▍ | 848/1000 [6:51:03<1:13:40, 29.08s/it][Succeeded / Failed / Skipped / Total] 703 / 122 / 23 / 848:  85%|████████▍ | 849/1000 [6:52:30<1:13:22, 29.15s/it][Succeeded / Failed / Skipped / Total] 704 / 122 / 23 / 849:  85%|████████▍ | 849/1000 [6:52:30<1:13:22, 29.15s/it][Succeeded / Failed / Skipped / Total] 704 / 122 / 23 / 849:  85%|████████▌ | 850/1000 [6:52:54<1:12:51, 29.15s/it][Succeeded / Failed / Skipped / Total] 705 / 122 / 23 / 850:  85%|████████▌ | 850/1000 [6:52:54<1:12:51, 29.15s/it][Succeeded / Failed / Skipped / Total] 705 / 122 / 23 / 850:  85%|████████▌ | 851/1000 [6:53:29<1:12:23, 29.15s/it][Succeeded / Failed / Skipped / Total] 705 / 123 / 23 / 851:  85%|████████▌ | 851/1000 [6:53:29<1:12:23, 29.15s/it][Succeeded / Failed / Skipped / Total] 705 / 123 / 23 / 851:  85%|████████▌ | 852/1000 [6:53:38<1:11:51, 29.13s/it][Succeeded / Failed / Skipped / Total] 706 / 123 / 23 / 852:  85%|████████▌ | 852/1000 [6:53:38<1:11:51, 29.13s/it][Succeeded / Failed / Skipped / Total] 706 / 123 / 23 / 852:  85%|████████▌ | 853/1000 [6:54:21<1:11:24, 29.15s/it][Succeeded / Failed / Skipped / Total] 707 / 123 / 23 / 853:  85%|████████▌ | 853/1000 [6:54:21<1:11:24, 29.15s/it][Succeeded / Failed / Skipped / Total] 707 / 123 / 23 / 853:  85%|████████▌ | 854/1000 [6:56:35<1:11:13, 29.27s/it]Sets the major version and class . --> [[[FAILED]]]

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .

[[[[Adv]]]]: int setMajorVersionAndClassName ( final int majorVersion , final String className ) { this . majorVersion = majorVersion ; this . className = className ; return addConstantClass ( className ) . index ; }
[[[[Nl]]]]: Sets the major version and the name of the class to which this symbol table belongs . Also adds the class name to the constant pool .
--------------------------------------------- Result 848 ---------------------------------------------
Add a constant member reference . --> Binder for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantMemberReference]] ( final int [[index]] , final int tag , final String owner , final String name , final String [[descriptor]] ) { add ( new Entry ( [[index]] , tag , owner , name , [[descriptor]] , 0 , hash ( tag , owner , name , [[descriptor]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[bertie]] ( final int [[monitors]] , final int tag , final String owner , final String name , final String [[mah]] ) { add ( new Entry ( [[monitors]] , tag , owner , name , [[mah]] , 0 , hash ( tag , owner , name , [[mah]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table .
--------------------------------------------- Result 849 ---------------------------------------------
Adds a constant name and type . --> convenience method --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantNameAndType]] ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[passé]] ( final int index , final String name , final String descriptor ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; add ( new Entry ( index , tag , name , descriptor , hash ( tag , name , descriptor ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_NameAndType_info to the constant pool of this symbol table .
--------------------------------------------- Result 850 ---------------------------------------------
Adds a constant long or double . --> Add an entry --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantLongOrDouble]] ( final int index , final int tag , final long [[value]] ) { add ( new Entry ( index , tag , [[value]] , hash ( tag , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[ardour]] ( final int index , final int tag , final long [[hash]] ) { add ( new Entry ( index , tag , [[hash]] , hash ( tag , [[hash]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table .
--------------------------------------------- Result 851 ---------------------------------------------
Adds a constant reference to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String [[name]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[name]] , descriptor ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . owner . equals ( owner ) && [[entry]] . name . equals ( [[name]] ) && [[entry]] . value . equals ( descriptor ) ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[name]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[name]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Entry addConstantMemberReference ( final int tag , final String owner , final String [[iie]] , final String descriptor ) { int hashCode = hash ( tag , owner , [[iie]] , descriptor ) ; Entry [[woolly]] = get ( hashCode ) ; while ( [[woolly]] != null ) { if ( [[woolly]] . tag == tag && [[woolly]] . hashCode == hashCode && [[woolly]] . owner . equals ( owner ) && [[woolly]] . name . equals ( [[iie]] ) && [[woolly]] . value . equals ( descriptor ) ) { return [[woolly]] ; } [[woolly]] = [[woolly]] . next ; } constantPool . put122 ( tag , addConstantClass ( owner ) . index , addConstantNameAndType ( [[iie]] , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , owner , [[iie]] , descriptor , 0 , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Fieldref_info CONSTANT_Methodref_info or CONSTANT_InterfaceMethodref_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 852 ---------------------------------------------
Adds a constant or floating point integer or float . --> public for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantIntegerOrFloat]] ( final int [[index]] , final int [[tag]] , final int [[value]] ) { add ( new Entry ( [[index]] , [[tag]] , [[value]] , hash ( [[tag]] , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[apéritif]] ( final int [[inaba]] , final int [[ofthem]] , final int [[iraqis]] ) { add ( new Entry ( [[inaba]] , [[ofthem]] , [[iraqis]] , hash ( [[ofthem]] , [[iraqis]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table .
--------------------------------------------- Result 853 ---------------------------------------------
Adds a constant . --> Generate sparkler --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantIntegerOrFloat]] ( final int [[tag]] , final int value ) { int hashCode = hash ( [[tag]] , value ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == [[tag]] && [[entry]] . hashCode == hashCode && [[entry]] . data == value ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } constantPool . putByte ( [[tag]] ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[sparkler]] ( final int [[cabrón]] , final int value ) { int hashCode = hash ( [[cabrón]] , value ) ; Entry [[antonio]] = get ( hashCode ) ; while ( [[antonio]] != null ) { if ( [[antonio]] . tag == [[cabrón]] && [[antonio]] . hashCode == hashCode && [[antonio]] . data == value ) { return [[antonio]] ; } [[antonio]] = [[antonio]] . next ; } constantPool . putByte ( [[cabrón]] ) . putInt ( value ) ; return put ( new Entry ( constantPoolCount ++ , [[cabrón]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Integer_info or CONSTANT_Float_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 854 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 708 / 123 / 23 / 854:  85%|████████▌ | 854/1000 [6:56:35<1:11:13, 29.27s/it][Succeeded / Failed / Skipped / Total] 708 / 123 / 23 / 854:  86%|████████▌ | 855/1000 [6:56:42<1:10:40, 29.24s/it][Succeeded / Failed / Skipped / Total] 708 / 124 / 23 / 855:  86%|████████▌ | 855/1000 [6:56:42<1:10:40, 29.24s/it][Succeeded / Failed / Skipped / Total] 708 / 124 / 23 / 855:  86%|████████▌ | 856/1000 [6:57:38<1:10:15, 29.27s/it][Succeeded / Failed / Skipped / Total] 708 / 125 / 23 / 856:  86%|████████▌ | 856/1000 [6:57:38<1:10:15, 29.27s/it][Succeeded / Failed / Skipped / Total] 708 / 125 / 23 / 856:  86%|████████▌ | 857/1000 [6:59:44<1:10:02, 29.39s/it][Succeeded / Failed / Skipped / Total] 708 / 126 / 23 / 857:  86%|████████▌ | 857/1000 [6:59:44<1:10:02, 29.39s/it][Succeeded / Failed / Skipped / Total] 708 / 126 / 23 / 857:  86%|████████▌ | 858/1000 [7:01:09<1:09:42, 29.45s/it][Succeeded / Failed / Skipped / Total] 709 / 126 / 23 / 858:  86%|████████▌ | 858/1000 [7:01:09<1:09:42, 29.45s/it][Succeeded / Failed / Skipped / Total] 709 / 126 / 23 / 858:  86%|████████▌ | 859/1000 [7:02:08<1:09:17, 29.49s/it]Adds a utf - 8 encoded constant . --> documentation inherited from Dialog --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8]] ( final int [[index]] , final String [[value]] ) { add ( new Entry ( [[index]] , Symbol . CONSTANT_UTF8_TAG , [[value]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[value]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[deflecting]] ( final int [[plimpton]] , final String [[walkway]] ) { add ( new Entry ( [[plimpton]] , Symbol . CONSTANT_UTF8_TAG , [[walkway]] , hash ( Symbol . CONSTANT_UTF8_TAG , [[walkway]] ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_String_info to the constant pool of this symbol table .
--------------------------------------------- Result 855 ---------------------------------------------
Adds a constant to the constant pool . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol [[addConstantLongOrDouble]] ( final int tag , final long value ) { int [[hashCode]] = hash ( tag , value ) ; Entry [[entry]] = get ( [[hashCode]] ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == [[hashCode]] && [[entry]] . data == value ) { return [[entry]] ; } [[entry]] = [[entry]] . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , [[hashCode]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[unchain]] ( final int tag , final long value ) { int [[corbusier]] = hash ( tag , value ) ; Entry [[margot]] = get ( [[corbusier]] ) ; while ( [[margot]] != null ) { if ( [[margot]] . tag == tag && [[margot]] . hashCode == [[corbusier]] && [[margot]] . data == value ) { return [[margot]] ; } [[margot]] = [[margot]] . next ; } int index = constantPoolCount ; constantPool . putByte ( tag ) . putLong ( value ) ; constantPoolCount += 2 ; return put ( new Entry ( index , tag , value , [[corbusier]] ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Long_info or CONSTANT_Double_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 856 ---------------------------------------------
Adds a constant name and type . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantNameAndType]] ( final String name , final String [[descriptor]] ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , [[descriptor]] ) ; Entry [[entry]] = get ( hashCode ) ; while ( [[entry]] != null ) { if ( [[entry]] . tag == tag && [[entry]] . hashCode == hashCode && [[entry]] . name . equals ( name ) && [[entry]] . value . equals ( [[descriptor]] ) ) { return [[entry]] . index ; } [[entry]] = [[entry]] . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( [[descriptor]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , [[descriptor]] , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[jerez]] ( final String name , final String [[cuss]] ) { final int tag = Symbol . CONSTANT_NAME_AND_TYPE_TAG ; int hashCode = hash ( tag , name , [[cuss]] ) ; Entry [[bridgeport]] = get ( hashCode ) ; while ( [[bridgeport]] != null ) { if ( [[bridgeport]] . tag == tag && [[bridgeport]] . hashCode == hashCode && [[bridgeport]] . name . equals ( name ) && [[bridgeport]] . value . equals ( [[cuss]] ) ) { return [[bridgeport]] . index ; } [[bridgeport]] = [[bridgeport]] . next ; } constantPool . put122 ( tag , addConstantUtf8 ( name ) , addConstantUtf8 ( [[cuss]] ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , name , [[cuss]] , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_NameAndType_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 857 ---------------------------------------------
Adds a constant . --> [[[FAILED]]]

[[[[Adv]]]]: int [[addConstantUtf8]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: int [[swifter]] ( final String value ) { int hashCode = hash ( Symbol . CONSTANT_UTF8_TAG , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == Symbol . CONSTANT_UTF8_TAG && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry . index ; } entry = entry . next ; } constantPool . putByte ( Symbol . CONSTANT_UTF8_TAG ) . putUTF8 ( value ) ; return put ( new Entry ( constantPoolCount ++ , Symbol . CONSTANT_UTF8_TAG , value , hashCode ) ) . index ; }
[[[[Nl]]]]: Adds a CONSTANT_Utf8_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 858 ---------------------------------------------
Creates a synthetic method invocation . --> Create cuter --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantInvokeDynamic]] ( final String [[name]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... [[bootstrapMethodArguments]] ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , [[bootstrapMethodArguments]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[name]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[cuter]] ( final String [[nipper]] , final String descriptor , final Handle bootstrapMethodHandle , final Object ... [[validation]] ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , [[validation]] ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_INVOKE_DYNAMIC_TAG , [[nipper]] , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 859 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 710 / 126 / 23 / 859:  86%|████████▌ | 859/1000 [7:02:08<1:09:17, 29.49s/it][Succeeded / Failed / Skipped / Total] 710 / 126 / 23 / 859:  86%|████████▌ | 860/1000 [7:02:27<1:08:46, 29.47s/it][Succeeded / Failed / Skipped / Total] 710 / 127 / 23 / 860:  86%|████████▌ | 860/1000 [7:02:27<1:08:46, 29.47s/it][Succeeded / Failed / Skipped / Total] 710 / 127 / 23 / 860:  86%|████████▌ | 861/1000 [7:04:23<1:08:30, 29.57s/it][Succeeded / Failed / Skipped / Total] 711 / 127 / 23 / 861:  86%|████████▌ | 861/1000 [7:04:23<1:08:30, 29.57s/it][Succeeded / Failed / Skipped / Total] 711 / 127 / 23 / 861:  86%|████████▌ | 862/1000 [7:04:28<1:07:57, 29.55s/it][Succeeded / Failed / Skipped / Total] 711 / 128 / 23 / 862:  86%|████████▌ | 862/1000 [7:04:28<1:07:57, 29.55s/it][Succeeded / Failed / Skipped / Total] 711 / 128 / 23 / 862:  86%|████████▋ | 863/1000 [7:04:35<1:07:24, 29.52s/it][Succeeded / Failed / Skipped / Total] 712 / 128 / 23 / 863:  86%|████████▋ | 863/1000 [7:04:35<1:07:24, 29.52s/it][Succeeded / Failed / Skipped / Total] 712 / 128 / 23 / 863:  86%|████████▋ | 864/1000 [7:05:15<1:06:56, 29.53s/it][Succeeded / Failed / Skipped / Total] 712 / 129 / 23 / 864:  86%|████████▋ | 864/1000 [7:05:15<1:06:56, 29.53s/it][Succeeded / Failed / Skipped / Total] 712 / 129 / 23 / 864:  86%|████████▋ | 865/1000 [7:05:39<1:06:25, 29.53s/it]Adds a constant . --> Convenience method for unit testing --> Socre: 1.0

[[[[Adv]]]]: private Symbol [[addConstantUtf8Reference]] ( final int [[tag]] , final String value ) { int hashCode = hash ( [[tag]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[tag]] && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( [[tag]] , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , [[tag]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol [[unite]] ( final int [[vena]] , final String value ) { int hashCode = hash ( [[vena]] , value ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == [[vena]] && entry . hashCode == hashCode && entry . value . equals ( value ) ) { return entry ; } entry = entry . next ; } constantPool . put12 ( [[vena]] , addConstantUtf8 ( value ) ) ; return put ( new Entry ( constantPoolCount ++ , [[vena]] , value , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 860 ---------------------------------------------
Adds a constant to the bootstrap method . --> [[[FAILED]]]

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol addConstantDynamic ( final String name , final String descriptor , final Handle bootstrapMethodHandle , final Object ... bootstrapMethodArguments ) { Symbol bootstrapMethod = addBootstrapMethod ( bootstrapMethodHandle , bootstrapMethodArguments ) ; return addConstantDynamicOrInvokeDynamicReference ( Symbol . CONSTANT_DYNAMIC_TAG , name , descriptor , bootstrapMethod . index ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic_info to the constant pool of this symbol table . Also adds the related bootstrap method to the BootstrapMethods of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 861 ---------------------------------------------
Add merged types . --> method to add new types --> Socre: 1.0

[[[[Adv]]]]: int addMergedType ( final int [[typeTableIndex1]] , final int [[typeTableIndex2]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .

[[[[Adv]]]]: int addMergedType ( final int [[dreamt]] , final int [[jäger]] ) {
[[[[Nl]]]]: Adds a merged type in the type table of this symbol table . Does nothing if the type table already contains a similar type .
--------------------------------------------- Result 862 ---------------------------------------------
Add constant or invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void addConstantDynamicOrInvokeDynamicReference ( final int tag , final int index , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; add ( new Entry ( index , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Dynamic_info or CONSTANT_InvokeDynamic_info to the constant pool of this symbol table .
--------------------------------------------- Result 863 ---------------------------------------------
Clear the map . --> Clear this MultiMap --> Socre: 1.0

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[i]] = 0 ; [[i]] < entries . length ; [[i]] ++ ) { entries [ [[i]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .

[[[[Adv]]]]: public HttpMultiMap < V > clear ( ) { for ( int [[bicarbonate]] = 0 ; [[bicarbonate]] < entries . length ; [[bicarbonate]] ++ ) { entries [ [[bicarbonate]] ] = null ; } head . before = head . after = head ; return this ; }
[[[[Nl]]]]: Clears the map .
--------------------------------------------- Result 864 ---------------------------------------------
Add a constant or invoke dynamic reference . --> [[[FAILED]]]

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: private Symbol addConstantDynamicOrInvokeDynamicReference ( final int tag , final String name , final String descriptor , final int bootstrapMethodIndex ) { int hashCode = hash ( tag , name , descriptor , bootstrapMethodIndex ) ; Entry entry = get ( hashCode ) ; while ( entry != null ) { if ( entry . tag == tag && entry . hashCode == hashCode && entry . data == bootstrapMethodIndex && entry . name . equals ( name ) && entry . value . equals ( descriptor ) ) { return entry ; } entry = entry . next ; } constantPool . put122 ( tag , bootstrapMethodIndex , addConstantNameAndType ( name , descriptor ) ) ; return put ( new Entry ( constantPoolCount ++ , tag , null , name , descriptor , bootstrapMethodIndex , hashCode ) ) ; }
[[[[Nl]]]]: Adds a CONSTANT_Dynamic or a CONSTANT_InvokeDynamic_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 865 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 713 / 129 / 23 / 865:  86%|████████▋ | 865/1000 [7:05:39<1:06:25, 29.53s/it][Succeeded / Failed / Skipped / Total] 713 / 129 / 23 / 865:  87%|████████▋ | 866/1000 [7:05:46<1:05:52, 29.50s/it][Succeeded / Failed / Skipped / Total] 714 / 129 / 23 / 866:  87%|████████▋ | 866/1000 [7:05:46<1:05:52, 29.50s/it][Succeeded / Failed / Skipped / Total] 714 / 129 / 23 / 866:  87%|████████▋ | 867/1000 [7:06:11<1:05:22, 29.49s/it][Succeeded / Failed / Skipped / Total] 715 / 129 / 23 / 867:  87%|████████▋ | 867/1000 [7:06:11<1:05:22, 29.49s/it][Succeeded / Failed / Skipped / Total] 715 / 129 / 23 / 867:  87%|████████▋ | 868/1000 [7:06:25<1:04:50, 29.48s/it][Succeeded / Failed / Skipped / Total] 716 / 129 / 23 / 868:  87%|████████▋ | 868/1000 [7:06:25<1:04:50, 29.48s/it][Succeeded / Failed / Skipped / Total] 716 / 129 / 23 / 868:  87%|████████▋ | 869/1000 [7:06:34<1:04:18, 29.45s/it][Succeeded / Failed / Skipped / Total] 717 / 129 / 23 / 869:  87%|████████▋ | 869/1000 [7:06:34<1:04:18, 29.45s/it][Succeeded / Failed / Skipped / Total] 717 / 129 / 23 / 869:  87%|████████▋ | 870/1000 [7:06:55<1:03:47, 29.44s/it][Succeeded / Failed / Skipped / Total] 718 / 129 / 23 / 870:  87%|████████▋ | 870/1000 [7:06:55<1:03:47, 29.44s/it][Succeeded / Failed / Skipped / Total] 718 / 129 / 23 / 870:  87%|████████▋ | 871/1000 [7:07:04<1:03:15, 29.42s/it][Succeeded / Failed / Skipped / Total] 719 / 129 / 23 / 871:  87%|████████▋ | 871/1000 [7:07:04<1:03:15, 29.42s/it][Succeeded / Failed / Skipped / Total] 719 / 129 / 23 / 871:  87%|████████▋ | 872/1000 [7:07:25<1:02:44, 29.41s/it][Succeeded / Failed / Skipped / Total] 720 / 129 / 23 / 872:  87%|████████▋ | 872/1000 [7:07:25<1:02:44, 29.41s/it][Succeeded / Failed / Skipped / Total] 720 / 129 / 23 / 872:  87%|████████▋ | 873/1000 [7:08:16<1:02:18, 29.43s/it][Succeeded / Failed / Skipped / Total] 721 / 129 / 23 / 873:  87%|████████▋ | 873/1000 [7:08:16<1:02:18, 29.43s/it][Succeeded / Failed / Skipped / Total] 721 / 129 / 23 / 873:  87%|████████▋ | 874/1000 [7:08:37<1:01:47, 29.43s/it]Adds a bootstrap method . --> Hibernate HawkHandlers --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addBootstrapMethod]] ( final Handle [[bootstrapMethodHandle]] , final Object ... bootstrapMethodArguments ) { ByteVector [[bootstrapMethodsAttribute]] = bootstrapMethods ; if ( [[bootstrapMethodsAttribute]] == null ) { [[bootstrapMethodsAttribute]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .

[[[[Adv]]]]: Symbol [[hawk]] ( final Handle [[badmouthing]] , final Object ... bootstrapMethodArguments ) { ByteVector [[samsung]] = bootstrapMethods ; if ( [[samsung]] == null ) { [[samsung]] = bootstrapMethods = new ByteVector ( ) ; }
[[[[Nl]]]]: Adds a bootstrap method to the BootstrapMethods attribute of this symbol table . Does nothing if the BootstrapMethods already contains a similar bootstrap method .
--------------------------------------------- Result 866 ---------------------------------------------
Adds a static reference to the constant map . --> metric Metadata --> Socre: 1.0

[[[[Adv]]]]: private void [[addConstantUtf8Reference]] ( final int index , final int [[tag]] , final String value ) { add ( new Entry ( index , [[tag]] , value , hash ( [[tag]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[mette]] ( final int index , final int [[macaroni]] , final String value ) { add ( new Entry ( index , [[macaroni]] , value , hash ( [[macaroni]] , value ) ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_Class_info CONSTANT_String_info CONSTANT_MethodType_info CONSTANT_Module_info or CONSTANT_Package_info to the constant pool of this symbol table .
--------------------------------------------- Result 867 ---------------------------------------------
Returns an iterator that iterates over the elements of this map . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[iterator]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .

[[[[Adv]]]]: @ Override public Iterator < Map . Entry < String , V > > [[crucible]] ( ) { final MapEntry [ ] e = { head . after } ; return new Iterator < Map . Entry < String , V > > ( ) { @ Override public boolean hasNext ( ) { return e [ 0 ] != head ; } @ Override @ SuppressWarnings ( "unchecked" ) public Map . Entry < String , V > next ( ) { if ( ! hasNext ( ) ) { throw new NoSuchElementException ( "No next() entry in the iteration" ) ; } MapEntry < V > next = e [ 0 ] ; e [ 0 ] = e [ 0 ] . after ; return next ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns iterator of all entries .
--------------------------------------------- Result 868 ---------------------------------------------
Increases the capacity if necessary . --> Discardwoodwoodwoodwoodwood --> Socre: 1.0

[[[[Adv]]]]: private void [[grow]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .

[[[[Adv]]]]: private void [[driftwood]] ( final int minCapacity ) { final int oldCapacity = buffer . length ; int newCapacity = oldCapacity << 1 ; if ( newCapacity - minCapacity < 0 ) {
[[[[Nl]]]]: Grows the buffer .
--------------------------------------------- Result 869 ---------------------------------------------
Visits an annotation . --> Visitor methods --> Socre: 1.0

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean [[visible]] ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , [[visible]] ) ;
[[[[Nl]]]]: Copies target method annotations .

[[[[Adv]]]]: @ Override public AnnotationVisitor visitAnnotation ( final String desc , final boolean [[asthma]] ) { AnnotationVisitor destAnn = methodVisitor . visitAnnotation ( desc , [[asthma]] ) ;
[[[[Nl]]]]: Copies target method annotations .
--------------------------------------------- Result 870 ---------------------------------------------
Returns the hash of the given name --> hashMoon --> Socre: 1.0

[[[[Adv]]]]: private int hash ( final String [[name]] ) { int h = 0 ; for ( int [[i]] = [[name]] . length ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { char c = [[name]] . charAt ( [[i]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .

[[[[Adv]]]]: private int hash ( final String [[moons]] ) { int h = 0 ; for ( int [[cabrón]] = [[moons]] . length ( ) - 1 ; [[cabrón]] >= 0 ; [[cabrón]] -- ) { char c = [[moons]] . charAt ( [[cabrón]] ) ; if ( ! caseSensitive ) { if ( c >= ' ' && c <= ' ' ) { c += 32 ; } } h = 31 * h + c ; } if ( h > 0 ) { return h ; } if ( h == Integer . MIN_VALUE ) { return Integer . MAX_VALUE ; } return - h ; }
[[[[Nl]]]]: Calculates hash value of the input string .
--------------------------------------------- Result 871 ---------------------------------------------
Create first chain delegate delegate delegate . --> This method is intended to be called after a crash --> Socre: 1.0

[[[[Adv]]]]: protected void [[createFirstChainDelegate_Start]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .

[[[[Adv]]]]: protected void [[bitterness]] ( ) {
[[[[Nl]]]]: Starts creation of first chain delegate .
--------------------------------------------- Result 872 ---------------------------------------------
Appends a character sequence to this buffer . --> Append the hsemee --> Socre: 1.0

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence [[csq]] , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( [[csq]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .

[[[[Adv]]]]: @ Override public FastCharBuffer append ( final CharSequence [[gethsemane]] , final int start , final int end ) { for ( int i = start ; i < end ; i ++ ) { append ( [[gethsemane]] . charAt ( i ) ) ; } return this ; }
[[[[Nl]]]]: Appends character sequence to buffer .
--------------------------------------------- Result 873 ---------------------------------------------
Create the first proxy chain . --> Perform a hardtopology --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[visitEnd]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[p]] = 0 ; [[p]] < tmd . proxyData . length ; [[p]] ++ ) { tmd . selectCurrentProxy ( [[p]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .

[[[[Adv]]]]: @ Override public void [[hardtop]] ( ) { createFirstChainDelegate_Continue ( tmd ) ; for ( int [[disseminate]] = 0 ; [[disseminate]] < tmd . proxyData . length ; [[disseminate]] ++ ) { tmd . selectCurrentProxy ( [[disseminate]] ) ; createProxyMethod ( tmd ) ; } }
[[[[Nl]]]]: Finally builds proxy methods if applied to current method .
--------------------------------------------- Result 874 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 722 / 129 / 23 / 874:  87%|████████▋ | 874/1000 [7:08:37<1:01:47, 29.43s/it][Succeeded / Failed / Skipped / Total] 722 / 129 / 23 / 874:  88%|████████▊ | 875/1000 [7:08:38<1:01:14, 29.39s/it][Succeeded / Failed / Skipped / Total] 723 / 129 / 23 / 875:  88%|████████▊ | 875/1000 [7:08:38<1:01:14, 29.39s/it][Succeeded / Failed / Skipped / Total] 723 / 129 / 23 / 875:  88%|████████▊ | 876/1000 [7:08:38<1:00:40, 29.36s/it][Succeeded / Failed / Skipped / Total] 723 / 129 / 24 / 876:  88%|████████▊ | 876/1000 [7:08:38<1:00:40, 29.36s/it][Succeeded / Failed / Skipped / Total] 723 / 129 / 24 / 876:  88%|████████▊ | 877/1000 [7:08:45<1:00:08, 29.33s/it][Succeeded / Failed / Skipped / Total] 724 / 129 / 24 / 877:  88%|████████▊ | 877/1000 [7:08:45<1:00:08, 29.33s/it][Succeeded / Failed / Skipped / Total] 724 / 129 / 24 / 877:  88%|████████▊ | 878/1000 [7:08:56<59:36, 29.31s/it]  [Succeeded / Failed / Skipped / Total] 725 / 129 / 24 / 878:  88%|████████▊ | 878/1000 [7:08:56<59:36, 29.31s/it][Succeeded / Failed / Skipped / Total] 725 / 129 / 24 / 878:  88%|████████▊ | 879/1000 [7:10:01<59:11, 29.35s/it][Succeeded / Failed / Skipped / Total] 726 / 129 / 24 / 879:  88%|████████▊ | 879/1000 [7:10:01<59:11, 29.35s/it][Succeeded / Failed / Skipped / Total] 726 / 129 / 24 / 879:  88%|████████▊ | 880/1000 [7:10:01<58:38, 29.32s/it][Succeeded / Failed / Skipped / Total] 727 / 129 / 24 / 880:  88%|████████▊ | 880/1000 [7:10:01<58:38, 29.32s/it][Succeeded / Failed / Skipped / Total] 727 / 129 / 24 / 880:  88%|████████▊ | 881/1000 [7:10:51<58:11, 29.34s/it]Adds a field to the path . --> removes a field --> Socre: 1.0

[[[[Adv]]]]: public Path [[push]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .

[[[[Adv]]]]: public Path [[exorcised]] ( final CharSequence field ) { _push ( field ) ; if ( altPath != null ) { altPath . push ( field ) ; } return this ; }
[[[[Nl]]]]: Push element to the path .
--------------------------------------------- Result 875 ---------------------------------------------
Create the delegate to continue chaincode . --> do nothing --> Socre: 1.0

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData [[tmd]] ) { methodVisitor . visitCode ( ) ; if ( [[tmd]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[tmd]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[tmd]] . firstMethodName ( ) , [[tmd]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[tmd]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .

[[[[Adv]]]]: protected void createFirstChainDelegate_Continue ( final TargetMethodData [[botswana]] ) { methodVisitor . visitCode ( ) ; if ( [[botswana]] . msign . isStatic ) { loadStaticMethodArguments ( methodVisitor , [[botswana]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESTATIC , wd . thisReference , [[botswana]] . firstMethodName ( ) , [[botswana]] . msign . getDescription ( ) , "False" != "False" ) ; } else { loadSpecialMethodArguments ( methodVisitor , [[botswana]] . msign ) ; methodVisitor . visitMethodInsn ( INVOKESPECIAL , wd . thisReference , [[botswana]] . firstMethodName ( ) , [[botswana]] . msign . getDescription ( ) , "False" != "False" ) ; } visitReturn ( methodVisitor , [[botswana]] . msign , "False" != "False" ) ; methodVisitor . visitMaxs ( 0 , 0 ) ; methodVisitor . visitEnd ( ) ; }
[[[[Nl]]]]: Continues the creation of the very first method in calling chain that simply delegates invocation to the first proxy method . This method mirrors the target method .
--------------------------------------------- Result 876 ---------------------------------------------
execute the target --> [[[SKIPPED]]]

[[[[Adv]]]]: public Object execute ( ) { String methodName = targetMethodName ( ) ; Class returnType = returnType ( ) ; Object next = pathref . continueWith ( this , methodName , returnType ) ; return ProxyTarget . returnValue ( next ) ; }
[[[[Nl]]]]: Reads method name and appends it . Creates object for next call and returns that value . If next object is unsupported it will return null ;
--------------------------------------------- Result 877 ---------------------------------------------
Configure the servlet context . --> Add drc to the request --> Socre: 1.0

[[[[Adv]]]]: private void [[configureServletContext]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .

[[[[Adv]]]]: private void [[drac]] ( final ServletContext servletContext ) { servletContext . addListener ( jodd . servlet . RequestContextListener . class ) ; if ( decoraEnabled ) { final FilterRegistration filter = servletContext . addFilter ( "decora" , jodd . decora . DecoraServletFilter . class ) ; filter . addMappingForUrlPatterns ( null , "True" == "True" , contextPath ) ; } final FilterRegistration filter = servletContext . addFilter ( "madvoc" , jodd . madvoc . MadvocServletFilter . class ) ; filter . addMappingForUrlPatterns ( madvocDispatcherTypes , "True" == "True" , contextPath ) ; }
[[[[Nl]]]]: Configures servlet context .
--------------------------------------------- Result 878 ---------------------------------------------
Determines the proxy for the proxy . --> Overridden to create a BeanDefinition --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[originalType]] = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[originalType]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Override protected < T > BeanDefinition < T > createBeanDefinitionForRegistration ( final String name , Class < T > type , final Scope scope , final WiringMode wiringMode , final Consumer < T > consumer ) { if ( proxetta != null ) { final Class [[behalf]] = type ; final ProxettaFactory builder = proxetta . proxy ( ) ; builder . setTarget ( type ) ; type = builder . define ( ) ; return new ProxettaBeanDefinition ( name , type , scope , wiringMode , [[behalf]] , proxetta . getAspects ( new ProxyAspect [ 0 ] ) , consumer ) ; } return super . createBeanDefinitionForRegistration ( name , type , scope , wiringMode , consumer ) ; }
[[[[Nl]]]]: Applies proxetta on bean class before bean registration .
--------------------------------------------- Result 879 ---------------------------------------------
Parse path string . --> utility for testing --> Socre: 1.0

[[[[Adv]]]]: public static Path [[parse]] ( final String [[path]] ) { return [[path]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[path]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .

[[[[Adv]]]]: public static Path [[uit]] ( final String [[luscious]] ) { return [[luscious]] == null ? new Path ( ) : new Path ( StringUtil . splitc ( [[luscious]] , ' ' ) ) ; }
[[[[Nl]]]]: Parses input dot - separated string that represents a path .
--------------------------------------------- Result 880 ---------------------------------------------
Get all values with the given name . --> Converts a dura string to a list of mappings --> Socre: 1.0

[[[[Adv]]]]: public List < V > [[getAll]] ( final String [[name]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int [[h]] = hash ( [[name]] ) ; int [[i]] = index ( [[h]] ) ; MapEntry < V > e = entries [ [[i]] ] ; while ( e != null ) { if ( e . hash == [[h]] && eq ( [[name]] , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .

[[[[Adv]]]]: public List < V > [[tomi]] ( final String [[dura]] ) { LinkedList < V > values = new LinkedList <> ( ) ; int [[versions]] = hash ( [[dura]] ) ; int [[passionate]] = index ( [[versions]] ) ; MapEntry < V > e = entries [ [[passionate]] ] ; while ( e != null ) { if ( e . hash == [[versions]] && eq ( [[dura]] , e . key ) ) { values . addFirst ( e . getValue ( ) ) ; } e = e . next ; } return values ; }
[[[[Nl]]]]: Returns all values associated with the name .
[Succeeded / Failed / Skipped / Total] 727 / 130 / 24 / 881:  88%|████████▊ | 881/1000 [7:10:51<58:11, 29.34s/it][Succeeded / Failed / Skipped / Total] 727 / 130 / 24 / 881:  88%|████████▊ | 882/1000 [7:11:09<57:41, 29.33s/it][Succeeded / Failed / Skipped / Total] 728 / 130 / 24 / 882:  88%|████████▊ | 882/1000 [7:11:09<57:41, 29.33s/it][Succeeded / Failed / Skipped / Total] 728 / 130 / 24 / 882:  88%|████████▊ | 883/1000 [7:11:22<57:09, 29.31s/it][Succeeded / Failed / Skipped / Total] 729 / 130 / 24 / 883:  88%|████████▊ | 883/1000 [7:11:22<57:09, 29.31s/it][Succeeded / Failed / Skipped / Total] 729 / 130 / 24 / 883:  88%|████████▊ | 884/1000 [7:11:41<56:38, 29.30s/it][Succeeded / Failed / Skipped / Total] 730 / 130 / 24 / 884:  88%|████████▊ | 884/1000 [7:11:41<56:38, 29.30s/it][Succeeded / Failed / Skipped / Total] 730 / 130 / 24 / 884:  88%|████████▊ | 885/1000 [7:12:07<56:09, 29.30s/it][Succeeded / Failed / Skipped / Total] 731 / 130 / 24 / 885:  88%|████████▊ | 885/1000 [7:12:07<56:09, 29.30s/it][Succeeded / Failed / Skipped / Total] 731 / 130 / 24 / 885:  89%|████████▊ | 886/1000 [7:12:16<55:37, 29.27s/it][Succeeded / Failed / Skipped / Total] 732 / 130 / 24 / 886:  89%|████████▊ | 886/1000 [7:12:16<55:37, 29.27s/it][Succeeded / Failed / Skipped / Total] 732 / 130 / 24 / 886:  89%|████████▊ | 887/1000 [7:12:24<55:05, 29.25s/it][Succeeded / Failed / Skipped / Total] 733 / 130 / 24 / 887:  89%|████████▊ | 887/1000 [7:12:24<55:05, 29.25s/it][Succeeded / Failed / Skipped / Total] 733 / 130 / 24 / 887:  89%|████████▉ | 888/1000 [7:12:24<54:32, 29.22s/it][Succeeded / Failed / Skipped / Total] 734 / 130 / 24 / 888:  89%|████████▉ | 888/1000 [7:12:24<54:32, 29.22s/it][Succeeded / Failed / Skipped / Total] 734 / 130 / 24 / 888:  89%|████████▉ | 889/1000 [7:12:41<54:01, 29.20s/it][Succeeded / Failed / Skipped / Total] 735 / 130 / 24 / 889:  89%|████████▉ | 889/1000 [7:12:41<54:01, 29.20s/it][Succeeded / Failed / Skipped / Total] 735 / 130 / 24 / 889:  89%|████████▉ | 890/1000 [7:13:13<53:32, 29.21s/it]--------------------------------------------- Result 881 ---------------------------------------------
Returns all the entries in the list . --> [[[FAILED]]]

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[entries]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .

[[[[Adv]]]]: public List < Map . Entry < String , V > > [[margolis]] ( ) { List < Map . Entry < String , V > > all = new LinkedList <> ( ) ; MapEntry < V > e = head . after ; while ( e != head ) { all . add ( e ) ; e = e . after ; } return all ; }
[[[[Nl]]]]: Returns all the entries of this map . Case sensitivity does not influence the returned list it always contains all of the values .
--------------------------------------------- Result 882 ---------------------------------------------
Append a buffer to the list . --> Append the contents of the document --> Socre: 1.0

[[[[Adv]]]]: public Buffer append ( final Buffer [[buffer]] ) { if ( [[buffer]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .

[[[[Adv]]]]: public Buffer append ( final Buffer [[morbid]] ) { if ( [[morbid]] . list . isEmpty ( ) ) {
[[[[Nl]]]]: Appends other buffer to this one .
--------------------------------------------- Result 883 ---------------------------------------------
Reads property . --> Determine the ferryter for a ferry --> Socre: 1.0

[[[[Adv]]]]: private Object [[readProperty]] ( final Object source , final PropertyDescriptor [[propertyDescriptor]] ) { Getter getter = [[propertyDescriptor]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .

[[[[Adv]]]]: private Object [[garfunkel]] ( final Object source , final PropertyDescriptor [[ferryboat]] ) { Getter getter = [[ferryboat]] . getGetter ( declared ) ; if ( getter != null ) { try { return getter . invokeGetter ( source ) ; } catch ( Exception ex ) { throw new JsonException ( ex ) ; } } return null ; }
[[[[Nl]]]]: Reads property using property descriptor .
--------------------------------------------- Result 884 ---------------------------------------------
Adds a constant method handle . --> get miscellaneous methods --> Socre: 1.0

[[[[Adv]]]]: Symbol [[addConstantMethodHandle]] ( final int referenceKind , final String [[owner]] , final String name , final String descriptor , final boolean isInterface ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .

[[[[Adv]]]]: Symbol [[misbehaves]] ( final int referenceKind , final String [[schlong]] , final String name , final String descriptor , final boolean isInterface ) { final int [[zorn]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ;
[[[[Nl]]]]: Adds a CONSTANT_MethodHandle_info to the constant pool of this symbol table . Does nothing if the constant pool already contains a similar item .
--------------------------------------------- Result 885 ---------------------------------------------
Write the progress to the output stream . --> Flush a Flagon --> Socre: 1.0

[[[[Adv]]]]: public void [[writeTo]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .

[[[[Adv]]]]: public void [[flagon]] ( final OutputStream out , final HttpProgressListener progressListener ) throws IOException {
[[[[Nl]]]]: Writes content to the output stream using progress listener to track the sending progress .
--------------------------------------------- Result 886 ---------------------------------------------
Writes the content to the output stream . --> Write all supported brands --> Socre: 1.0

[[[[Adv]]]]: public void writeTo ( final OutputStream [[out]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[out]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[out]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .

[[[[Adv]]]]: public void writeTo ( final OutputStream [[brands]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer fastByteBuffer = ( FastByteBuffer ) o ; [[brands]] . write ( fastByteBuffer . toArray ( ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[brands]] ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the output stream .
--------------------------------------------- Result 887 ---------------------------------------------
Returns a string value . --> Getter for chatterley --> Socre: 1.0

[[[[Adv]]]]: public String [[getString]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .

[[[[Adv]]]]: public String [[chatterley]] ( final String key ) { CharSequence cs = ( CharSequence ) map . get ( key ) ; return cs == null ? null : cs . toString ( ) ; }
[[[[Nl]]]]: Returns the string value with the specified key .
--------------------------------------------- Result 888 ---------------------------------------------
Get a property value . --> Get a frankel --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getInteger]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .

[[[[Adv]]]]: public Integer [[frankel]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Integer ) { return ( Integer ) number ; } return number . intValue ( ) ; }
[[[[Nl]]]]: returns the integer value with the specified key .
--------------------------------------------- Result 889 ---------------------------------------------
Get a long value . --> Get oswaldo --> Socre: 1.0

[[[[Adv]]]]: public Long [[getLong]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .

[[[[Adv]]]]: public Long [[oswaldo]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Long ) { return ( Long ) number ; } return number . longValue ( ) ; }
[[[[Nl]]]]: Returns the long value with the specified key .
--------------------------------------------- Result 890 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 736 / 130 / 24 / 890:  89%|████████▉ | 890/1000 [7:13:13<53:32, 29.21s/it][Succeeded / Failed / Skipped / Total] 736 / 130 / 24 / 890:  89%|████████▉ | 891/1000 [7:13:29<53:01, 29.19s/it][Succeeded / Failed / Skipped / Total] 736 / 131 / 24 / 891:  89%|████████▉ | 891/1000 [7:13:29<53:01, 29.19s/it][Succeeded / Failed / Skipped / Total] 736 / 131 / 24 / 891:  89%|████████▉ | 892/1000 [7:13:38<52:30, 29.17s/it][Succeeded / Failed / Skipped / Total] 737 / 131 / 24 / 892:  89%|████████▉ | 892/1000 [7:13:38<52:30, 29.17s/it][Succeeded / Failed / Skipped / Total] 737 / 131 / 24 / 892:  89%|████████▉ | 893/1000 [7:13:40<51:57, 29.14s/it][Succeeded / Failed / Skipped / Total] 738 / 131 / 24 / 893:  89%|████████▉ | 893/1000 [7:13:40<51:57, 29.14s/it][Succeeded / Failed / Skipped / Total] 738 / 131 / 24 / 893:  89%|████████▉ | 894/1000 [7:13:57<51:27, 29.13s/it][Succeeded / Failed / Skipped / Total] 739 / 131 / 24 / 894:  89%|████████▉ | 894/1000 [7:13:57<51:27, 29.13s/it][Succeeded / Failed / Skipped / Total] 739 / 131 / 24 / 894:  90%|████████▉ | 895/1000 [7:14:02<50:55, 29.10s/it][Succeeded / Failed / Skipped / Total] 740 / 131 / 24 / 895:  90%|████████▉ | 895/1000 [7:14:02<50:55, 29.10s/it][Succeeded / Failed / Skipped / Total] 740 / 131 / 24 / 895:  90%|████████▉ | 896/1000 [7:14:02<50:22, 29.07s/it][Succeeded / Failed / Skipped / Total] 741 / 131 / 24 / 896:  90%|████████▉ | 896/1000 [7:14:02<50:22, 29.07s/it][Succeeded / Failed / Skipped / Total] 741 / 131 / 24 / 896:  90%|████████▉ | 897/1000 [7:14:12<49:51, 29.04s/it][Succeeded / Failed / Skipped / Total] 742 / 131 / 24 / 897:  90%|████████▉ | 897/1000 [7:14:12<49:51, 29.04s/it][Succeeded / Failed / Skipped / Total] 742 / 131 / 24 / 897:  90%|████████▉ | 898/1000 [7:14:21<49:20, 29.02s/it]Get a double value . --> Liefert einen Leekt zurueck --> Socre: 1.0

[[[[Adv]]]]: public Double [[getDouble]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .

[[[[Adv]]]]: public Double [[joelle]] ( final String key ) { Number number = ( Number ) map . get ( key ) ; if ( number == null ) { return null ; } if ( number instanceof Double ) { return ( Double ) number ; } return number . doubleValue ( ) ; }
[[[[Nl]]]]: Returns the double value with the specified key .
--------------------------------------------- Result 891 ---------------------------------------------
Converts transaction mode to db . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbTransactionMode [[convertToDbMode]] ( final JtxTransactionMode txMode ) { final int [[isolation]] ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[isolation]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[isolation]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[isolation]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[isolation]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[isolation]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[isolation]] , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .

[[[[Adv]]]]: public static DbTransactionMode [[zev]] ( final JtxTransactionMode txMode ) { final int [[halley]] ; switch ( txMode . getIsolationLevel ( ) ) { case ISOLATION_DEFAULT : [[halley]] = DbTransactionMode . ISOLATION_DEFAULT ; break ; case ISOLATION_NONE : [[halley]] = DbTransactionMode . ISOLATION_NONE ; break ; case ISOLATION_READ_COMMITTED : [[halley]] = DbTransactionMode . ISOLATION_READ_COMMITTED ; break ; case ISOLATION_READ_UNCOMMITTED : [[halley]] = DbTransactionMode . ISOLATION_READ_UNCOMMITTED ; break ; case ISOLATION_REPEATABLE_READ : [[halley]] = DbTransactionMode . ISOLATION_REPEATABLE_READ ; break ; case ISOLATION_SERIALIZABLE : [[halley]] = DbTransactionMode . ISOLATION_SERIALIZABLE ; break ; default : throw new IllegalArgumentException ( ) ; } return new DbTransactionMode ( [[halley]] , txMode . isReadOnly ( ) ) ; }
[[[[Nl]]]]: Converter JTX transaction mode to DB transaction mode .
--------------------------------------------- Result 892 ---------------------------------------------
Sets the value for the given key . --> Package private method --> Socre: 1.0

[[[[Adv]]]]: public JsonObject [[put]] ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .

[[[[Adv]]]]: public JsonObject [[shop]] ( final String key , final String value ) { Objects . requireNonNull ( key ) ; map . put ( key , value ) ; return this ; }
[[[[Nl]]]]: Puts a string into the JSON object with the specified key .
--------------------------------------------- Result 893 ---------------------------------------------
Get a value from the map . --> Method to get Equipment details --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[val]] = ( T ) map . get ( key ) ; if ( [[val]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[val]] ) ; } if ( [[val]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[val]] ) ; } return [[val]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T getValue ( final String key ) { T [[economics]] = ( T ) map . get ( key ) ; if ( [[economics]] instanceof Map ) { return ( T ) new JsonObject ( ( Map ) [[economics]] ) ; } if ( [[economics]] instanceof List ) { return ( T ) new JsonArray ( ( List ) [[economics]] ) ; } return [[economics]] ; }
[[[[Nl]]]]: Returns the value with the specified key as an object .
--------------------------------------------- Result 894 ---------------------------------------------
Use this method to open the specified folder . --> Use this method to open the eiffel --> Socre: 1.0

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . [[folderName]] = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .

[[[[Adv]]]]: public void useFolder ( final String folderName ) { closeFolderIfOpened ( folder ) ; try { this . [[eiffel]] = folderName ; this . folder = getService ( ) . getFolder ( folderName ) ; try { folder . open ( Folder . READ_WRITE ) ; } catch ( final MailException ignore ) { folder . open ( Folder . READ_ONLY ) ; } } catch ( final MessagingException msgexc ) { throw new MailException ( "Failed to connect to folder: " + folderName , msgexc ) ; } }
[[[[Nl]]]]: Opens new folder and closes previously opened folder .
--------------------------------------------- Result 895 ---------------------------------------------
Get a float value . --> Get a double from Duo --> Socre: 1.0

[[[[Adv]]]]: public Float getFloat ( final String [[key]] ) { Number [[number]] = ( Number ) map . get ( [[key]] ) ; if ( [[number]] == null ) { return null ; } if ( [[number]] instanceof Float ) { return ( Float ) [[number]] ; } return [[number]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .

[[[[Adv]]]]: public Float getFloat ( final String [[duo]] ) { Number [[quixotic]] = ( Number ) map . get ( [[duo]] ) ; if ( [[quixotic]] == null ) { return null ; } if ( [[quixotic]] instanceof Float ) { return ( Float ) [[quixotic]] ; } return [[quixotic]] . floatValue ( ) ; }
[[[[Nl]]]]: Returns the float value with the specified key .
--------------------------------------------- Result 896 ---------------------------------------------
Copies all entries from the specified map . --> Force refreshes --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[putAll]] ( final Map t ) { for ( Object [[o]] : t . entrySet ( ) ) { Map . Entry [[e]] = ( Map . Entry ) [[o]] ; put ( [[e]] . getKey ( ) , [[e]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .

[[[[Adv]]]]: @ Override public void [[freshen]] ( final Map t ) { for ( Object [[resurfaces]] : t . entrySet ( ) ) { Map . Entry [[cultures]] = ( Map . Entry ) [[resurfaces]] ; put ( [[cultures]] . getKey ( ) , [[cultures]] . getValue ( ) ) ; } }
[[[[Nl]]]]: Copies all of the mappings from the specified map to this one . These mappings replace any mappings that this map had for any of the keys currently in the specified Map .
--------------------------------------------- Result 897 ---------------------------------------------
Close the folder if opened . --> Close the workstation --> Socre: 1.0

[[[[Adv]]]]: protected void [[closeFolderIfOpened]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .

[[[[Adv]]]]: protected void [[workstation]] ( final Folder folder ) { if ( folder != null ) { try { folder . close ( "True" == "True" ) ; } catch ( final MessagingException ignore ) { } } }
[[[[Nl]]]]: Closes folder if opened and expunge deleted messages .
[Succeeded / Failed / Skipped / Total] 743 / 131 / 24 / 898:  90%|████████▉ | 898/1000 [7:14:21<49:20, 29.02s/it][Succeeded / Failed / Skipped / Total] 743 / 131 / 24 / 898:  90%|████████▉ | 899/1000 [7:14:59<48:52, 29.03s/it][Succeeded / Failed / Skipped / Total] 744 / 131 / 24 / 899:  90%|████████▉ | 899/1000 [7:14:59<48:52, 29.03s/it][Succeeded / Failed / Skipped / Total] 744 / 131 / 24 / 899:  90%|█████████ | 900/1000 [7:15:26<48:22, 29.03s/it][Succeeded / Failed / Skipped / Total] 744 / 132 / 24 / 900:  90%|█████████ | 900/1000 [7:15:26<48:22, 29.03s/it][Succeeded / Failed / Skipped / Total] 744 / 132 / 24 / 900:  90%|█████████ | 901/1000 [7:15:35<47:51, 29.01s/it][Succeeded / Failed / Skipped / Total] 745 / 132 / 24 / 901:  90%|█████████ | 901/1000 [7:15:35<47:51, 29.01s/it][Succeeded / Failed / Skipped / Total] 745 / 132 / 24 / 901:  90%|█████████ | 902/1000 [7:15:46<47:20, 28.99s/it][Succeeded / Failed / Skipped / Total] 746 / 132 / 24 / 902:  90%|█████████ | 902/1000 [7:15:46<47:20, 28.99s/it][Succeeded / Failed / Skipped / Total] 746 / 132 / 24 / 902:  90%|█████████ | 903/1000 [7:15:58<46:49, 28.97s/it][Succeeded / Failed / Skipped / Total] 747 / 132 / 24 / 903:  90%|█████████ | 903/1000 [7:15:58<46:49, 28.97s/it][Succeeded / Failed / Skipped / Total] 747 / 132 / 24 / 903:  90%|█████████ | 904/1000 [7:16:33<46:21, 28.98s/it][Succeeded / Failed / Skipped / Total] 748 / 132 / 24 / 904:  90%|█████████ | 904/1000 [7:16:33<46:21, 28.98s/it][Succeeded / Failed / Skipped / Total] 748 / 132 / 24 / 904:  90%|█████████ | 905/1000 [7:16:55<45:51, 28.97s/it][Succeeded / Failed / Skipped / Total] 749 / 132 / 24 / 905:  90%|█████████ | 905/1000 [7:16:55<45:51, 28.97s/it][Succeeded / Failed / Skipped / Total] 749 / 132 / 24 / 905:  91%|█████████ | 906/1000 [7:16:58<45:20, 28.94s/it][Succeeded / Failed / Skipped / Total] 750 / 132 / 24 / 906:  91%|█████████ | 906/1000 [7:16:58<45:20, 28.94s/it][Succeeded / Failed / Skipped / Total] 750 / 132 / 24 / 906:  91%|█████████ | 907/1000 [7:17:05<44:49, 28.91s/it]--------------------------------------------- Result 898 ---------------------------------------------
Create alias for target --> Helper method for aliases --> Socre: 1.0

[[[[Adv]]]]: protected String alias ( final String [[target]] ) { return StringPool . LEFT_CHEV . concat ( [[target]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .

[[[[Adv]]]]: protected String alias ( final String [[checkin]] ) { return StringPool . LEFT_CHEV . concat ( [[checkin]] ) . concat ( StringPool . RIGHT_CHEV ) ; }
[[[[Nl]]]]: Creates alias .
--------------------------------------------- Result 899 ---------------------------------------------
Returns an array of FieldDescriptors . --> Tries to avoid a deadlock --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor [ ] [[getAllFieldDescriptors]] ( ) { if ( [[allFields]] == null ) { FieldDescriptor [ ] [[allFields]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[index]] = 0 ; for ( FieldDescriptor [[fieldDescriptor]] : fieldsMap . values ( ) ) { [[allFields]] [ [[index]] ] = [[fieldDescriptor]] ; [[index]] ++ ; } Arrays . sort ( [[allFields]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[allFields]] ; } return [[allFields]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .

[[[[Adv]]]]: public FieldDescriptor [ ] [[whistler]] ( ) { if ( [[battleship]] == null ) { FieldDescriptor [ ] [[battleship]] = new FieldDescriptor [ fieldsMap . size ( ) ] ; int [[ironhide]] = 0 ; for ( FieldDescriptor [[forty]] : fieldsMap . values ( ) ) { [[battleship]] [ [[ironhide]] ] = [[forty]] ; [[ironhide]] ++ ; } Arrays . sort ( [[battleship]] , Comparator . comparing ( fd -> fd . getField ( ) . getName ( ) ) ) ; this . allFields = [[battleship]] ; } return [[battleship]] ; }
[[[[Nl]]]]: Returns all fields of this collection . Returns empty array if no fields exist . Initialized lazy .
--------------------------------------------- Result 900 ---------------------------------------------
Add a constant method handle . --> [[[FAILED]]]

[[[[Adv]]]]: private void [[addConstantMethodHandle]] ( final int index , final int referenceKind , final String owner , final String name , final String [[descriptor]] ) { final int [[tag]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( [[tag]] , owner , name , [[descriptor]] , referenceKind ) ; add ( new Entry ( index , [[tag]] , owner , name , [[descriptor]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .

[[[[Adv]]]]: private void [[sponged]] ( final int index , final int referenceKind , final String owner , final String name , final String [[takes]] ) { final int [[surprising]] = Symbol . CONSTANT_METHOD_HANDLE_TAG ; int hashCode = hash ( [[surprising]] , owner , name , [[takes]] , referenceKind ) ; add ( new Entry ( index , [[surprising]] , owner , name , [[takes]] , referenceKind , hashCode ) ) ; }
[[[[Nl]]]]: Adds a new CONSTANT_MethodHandle_info to the constant pool of this symbol table .
--------------------------------------------- Result 901 ---------------------------------------------
Sets the mime type . --> Repress the raw data . --> Socre: 1.0

[[[[Adv]]]]: public RawData [[as]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!

[[[[Adv]]]]: public RawData [[repress]] ( final String mimeOrExtension ) { if ( mimeOrExtension . contains ( StringPool . SLASH ) ) { this . mimeType = mimeOrExtension ; } else { this . mimeType = MimeTypes . getMimeType ( mimeOrExtension ) ; } return this ; }
[[[[Nl]]]]: Defines mime type by providing real mime type or just extension!
--------------------------------------------- Result 902 ---------------------------------------------
Updates the flags of the mailbox . --> Update EmailFlags --> Socre: 1.0

[[[[Adv]]]]: public void updateEmailFlags ( final ReceivedEmail [[receivedEmail]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[receivedEmail]] . messageNumber ( ) } , [[receivedEmail]] . flags ( ) , "[[True]]" == "[[True]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .

[[[[Adv]]]]: public void updateEmailFlags ( final ReceivedEmail [[equipment]] ) { useAndOpenFolderIfNotSet ( ) ; try { folder . setFlags ( new int [ ] { [[equipment]] . messageNumber ( ) } , [[equipment]] . flags ( ) , "[[Sekt]]" == "[[Sekt]]" ) ; } catch ( MessagingException mex ) { throw new MailException ( "Failed to fetch messages" , mex ) ; } }
[[[[Nl]]]]: Updates the email flags on the server .
--------------------------------------------- Result 903 ---------------------------------------------
Sets the download file . --> Configure lisping --> Socre: 1.0

[[[[Adv]]]]: public RawData [[downloadableAs]] ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .

[[[[Adv]]]]: public RawData [[lisping]] ( final String downloadFileName ) { this . downloadFileName = downloadFileName ; this . mimeType = MimeTypes . getMimeType ( FileNameUtil . getExtension ( downloadFileName ) ) ; return this ; }
[[[[Nl]]]]: Defines download file name and mime type from the name extension .
--------------------------------------------- Result 904 ---------------------------------------------
Adds a violation . --> destructor --> Socre: 1.0

[[[[Adv]]]]: protected void [[addViolation]] ( final String name , final Object [[invalidValue]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[invalidValue]] ) ) ; }
[[[[Nl]]]]: Adds action violation .

[[[[Adv]]]]: protected void [[disintegrator]] ( final String name , final Object [[livius]] ) { prepareValidator ( ) ; vtor . addViolation ( new Violation ( name , this , [[livius]] ) ) ; }
[[[[Nl]]]]: Adds action violation .
--------------------------------------------- Result 905 ---------------------------------------------
Perform validation . --> Determines if validation is valid --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[validateAction]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .

[[[[Adv]]]]: protected boolean [[communiqué]] ( final String ... profiles ) { prepareValidator ( ) ; vtor . useProfiles ( profiles ) ; vtor . validate ( this ) ; vtor . resetProfiles ( ) ; List < Violation > violations = vtor . getViolations ( ) ; return violations == null ; }
[[[[Nl]]]]: Validates action . Profiles are reset after the invocation .
--------------------------------------------- Result 906 ---------------------------------------------
Looks up a named parameter . --> Find a customer name --> Socre: 1.0

[[[[Adv]]]]: DbQueryNamedParameter [[lookupNamedParameter]] ( final String [[name]] ) { DbQueryNamedParameter [[p]] = rootNP ; while ( [[p]] != null ) { if ( [[p]] . equalsName ( [[name]] ) ) { return [[p]] ; } [[p]] = [[p]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .

[[[[Adv]]]]: DbQueryNamedParameter [[autobiographical]] ( final String [[ocean]] ) { DbQueryNamedParameter [[customers]] = rootNP ; while ( [[customers]] != null ) { if ( [[customers]] . equalsName ( [[ocean]] ) ) { return [[customers]] ; } [[customers]] = [[customers]] . next ; } return null ; }
[[[[Nl]]]]: Lookup for named parameter .
--------------------------------------------- Result 907 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 751 / 132 / 24 / 907:  91%|█████████ | 907/1000 [7:17:05<44:49, 28.91s/it][Succeeded / Failed / Skipped / Total] 752 / 132 / 24 / 908:  91%|█████████ | 908/1000 [7:17:05<44:17, 28.88s/it][Succeeded / Failed / Skipped / Total] 752 / 132 / 24 / 908:  91%|█████████ | 909/1000 [7:17:13<43:46, 28.86s/it][Succeeded / Failed / Skipped / Total] 753 / 132 / 24 / 909:  91%|█████████ | 909/1000 [7:17:13<43:46, 28.86s/it][Succeeded / Failed / Skipped / Total] 754 / 132 / 24 / 910:  91%|█████████ | 910/1000 [7:17:19<43:15, 28.83s/it][Succeeded / Failed / Skipped / Total] 754 / 132 / 24 / 910:  91%|█████████ | 911/1000 [7:17:23<42:43, 28.81s/it][Succeeded / Failed / Skipped / Total] 755 / 132 / 24 / 911:  91%|█████████ | 911/1000 [7:17:23<42:43, 28.81s/it][Succeeded / Failed / Skipped / Total] 755 / 132 / 24 / 911:  91%|█████████ | 912/1000 [7:17:26<42:12, 28.78s/it][Succeeded / Failed / Skipped / Total] 755 / 133 / 24 / 912:  91%|█████████ | 912/1000 [7:17:26<42:12, 28.78s/it][Succeeded / Failed / Skipped / Total] 755 / 133 / 24 / 912:  91%|█████████▏| 913/1000 [7:17:58<41:44, 28.78s/it]Create the proxy . --> Create the portfolio --> Socre: 1.0

[[[[Adv]]]]: public byte [ ] create ( ) { process ( ) ; byte [ ] [[result]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[result]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[result]] ; }
[[[[Nl]]]]: Returns byte array of created class .

[[[[Adv]]]]: public byte [ ] create ( ) { process ( ) ; byte [ ] [[portfolio]] = toByteArray ( ) ; dumpClassInDebugFolder ( [[portfolio]] ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } return null ; } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created " + StringUtil . toSafeString ( targetClassName ) ) ; } return [[portfolio]] ; }
[[[[Nl]]]]: Returns byte array of created class .
--------------------------------------------- Result 908 ---------------------------------------------
Extracts the target from the input stream . --> Throw exception if not --> Socre: 1.0

[[[[Adv]]]]: protected void [[process]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .

[[[[Adv]]]]: protected void [[nute]] ( ) { if ( targetInputStream == null ) { throw new ProxettaException ( "Target missing: " + targetClassName ) ; }
[[[[Nl]]]]: Reads the target and creates destination class .
--------------------------------------------- Result 909 ---------------------------------------------
Sets the target . --> dapper deserialization --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final InputStream [[target]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[target]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .

[[[[Adv]]]]: protected T [[dapper]] ( final InputStream [[agnès]] ) { assertTargetIsNotDefined ( ) ; targetInputStream = [[agnès]] ; targetClass = null ; targetClassName = null ; return _this ( ) ; }
[[[[Nl]]]]: Defines class input stream as a target .
--------------------------------------------- Result 910 ---------------------------------------------
Defines the target class . --> Processes the proxy --> Socre: 1.0

[[[[Adv]]]]: public Class [[define]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .

[[[[Adv]]]]: public Class [[dishonourable]] ( ) { process ( ) ; if ( ( ! proxetta . isForced ( ) ) && ( ! isProxyApplied ( ) ) ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy not applied: " + StringUtil . toSafeString ( targetClassName ) ) ; } if ( targetClass != null ) { return targetClass ; } if ( targetClassName != null ) { try { return ClassLoaderUtil . loadClass ( targetClassName ) ; } catch ( ClassNotFoundException cnfex ) { throw new ProxettaException ( cnfex ) ; } } } if ( log . isDebugEnabled ( ) ) { log . debug ( "Proxy created: " + StringUtil . toSafeString ( targetClassName ) ) ; } try { ClassLoader classLoader = proxetta . getClassLoader ( ) ; if ( classLoader == null ) { classLoader = ClassLoaderUtil . getDefaultClassLoader ( ) ; if ( ( classLoader == null ) && ( targetClass != null ) ) { classLoader = targetClass . getClassLoader ( ) ; } } final byte [ ] bytes = toByteArray ( ) ; dumpClassInDebugFolder ( bytes ) ; return DefineClass . of ( getProxyClassName ( ) , bytes , classLoader ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Class definition failed" , ex ) ; } }
[[[[Nl]]]]: Defines class .
--------------------------------------------- Result 911 ---------------------------------------------
Sets the target . --> Initializes the cardiogram --> Socre: 1.0

[[[[Adv]]]]: protected T [[setTarget]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!

[[[[Adv]]]]: protected T [[cardiogram]] ( final String targetName ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( targetName ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + targetName ) ; } targetClassName = targetName ; targetClass = null ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to get stream class name: " + targetName , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class name as a target . Class will not be loaded by classloader!
--------------------------------------------- Result 912 ---------------------------------------------
Writes the content to a writer . --> [[[FAILED]]]

[[[[Adv]]]]: public void writeTo ( final Writer [[writer]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[fastByteBuffer]] = ( FastByteBuffer ) o ; byte [ ] [[array]] = [[fastByteBuffer]] . toArray ( ) ; [[writer]] . write ( new String ( [[array]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[writer]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .

[[[[Adv]]]]: public void writeTo ( final Writer [[cutthroat]] ) throws IOException { for ( Object o : list ) { if ( o instanceof FastByteBuffer ) { FastByteBuffer [[pentameter]] = ( FastByteBuffer ) o ; byte [ ] [[grandchildren]] = [[pentameter]] . toArray ( ) ; [[cutthroat]] . write ( new String ( [[grandchildren]] , StringPool . ISO_8859_1 ) ) ; } else if ( o instanceof Uploadable ) { Uploadable uploadable = ( Uploadable ) o ; InputStream inputStream = uploadable . openInputStream ( ) ; try { StreamUtil . copy ( inputStream , [[cutthroat]] , StringPool . ISO_8859_1 ) ; } finally { StreamUtil . close ( inputStream ) ; } } } }
[[[[Nl]]]]: Writes content to the writer .
--------------------------------------------- Result 913 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 756 / 133 / 24 / 913:  91%|█████████▏| 913/1000 [7:17:58<41:44, 28.78s/it][Succeeded / Failed / Skipped / Total] 756 / 133 / 24 / 913:  91%|█████████▏| 914/1000 [7:18:13<41:14, 28.77s/it][Succeeded / Failed / Skipped / Total] 757 / 133 / 24 / 914:  91%|█████████▏| 914/1000 [7:18:13<41:14, 28.77s/it][Succeeded / Failed / Skipped / Total] 757 / 133 / 24 / 914:  92%|█████████▏| 915/1000 [7:18:35<40:44, 28.76s/it][Succeeded / Failed / Skipped / Total] 758 / 133 / 24 / 915:  92%|█████████▏| 915/1000 [7:18:35<40:44, 28.76s/it][Succeeded / Failed / Skipped / Total] 758 / 133 / 24 / 915:  92%|█████████▏| 916/1000 [7:18:38<40:13, 28.73s/it][Succeeded / Failed / Skipped / Total] 759 / 133 / 24 / 916:  92%|█████████▏| 916/1000 [7:18:38<40:13, 28.73s/it][Succeeded / Failed / Skipped / Total] 759 / 133 / 24 / 916:  92%|█████████▏| 917/1000 [7:18:47<39:42, 28.71s/it][Succeeded / Failed / Skipped / Total] 760 / 133 / 24 / 917:  92%|█████████▏| 917/1000 [7:18:47<39:42, 28.71s/it][Succeeded / Failed / Skipped / Total] 760 / 133 / 24 / 917:  92%|█████████▏| 918/1000 [7:18:51<39:12, 28.68s/it][Succeeded / Failed / Skipped / Total] 761 / 133 / 24 / 918:  92%|█████████▏| 918/1000 [7:18:51<39:12, 28.68s/it][Succeeded / Failed / Skipped / Total] 761 / 133 / 24 / 918:  92%|█████████▏| 919/1000 [7:18:56<38:41, 28.66s/it][Succeeded / Failed / Skipped / Total] 762 / 133 / 24 / 919:  92%|█████████▏| 919/1000 [7:18:56<38:41, 28.66s/it][Succeeded / Failed / Skipped / Total] 762 / 133 / 24 / 919:  92%|█████████▏| 920/1000 [7:20:05<38:16, 28.70s/it][Succeeded / Failed / Skipped / Total] 763 / 133 / 24 / 920:  92%|█████████▏| 920/1000 [7:20:05<38:16, 28.70s/it][Succeeded / Failed / Skipped / Total] 763 / 133 / 24 / 920:  92%|█████████▏| 921/1000 [7:20:14<37:45, 28.68s/it][Succeeded / Failed / Skipped / Total] 764 / 133 / 24 / 921:  92%|█████████▏| 921/1000 [7:20:14<37:45, 28.68s/it][Succeeded / Failed / Skipped / Total] 764 / 133 / 24 / 921:  92%|█████████▏| 922/1000 [7:21:17<37:19, 28.72s/it][Succeeded / Failed / Skipped / Total] 765 / 133 / 24 / 922:  92%|█████████▏| 922/1000 [7:21:17<37:19, 28.72s/it][Succeeded / Failed / Skipped / Total] 765 / 133 / 24 / 922:  92%|█████████▏| 923/1000 [7:21:39<36:50, 28.71s/it]Returns a new instance of the Prote Proxy . --> Defines the LNternet --> Socre: 1.0

[[[[Adv]]]]: public Object [[newInstance]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .

[[[[Adv]]]]: public Object [[lnternet]] ( ) { Class type = define ( ) ; try { return ClassUtil . newInstance ( type ) ; } catch ( Exception ex ) { throw new ProxettaException ( "Invalid Proxetta class" , ex ) ; } }
[[[[Nl]]]]: Creates new instance of created class . Assumes default no - arg constructor .
--------------------------------------------- Result 914 ---------------------------------------------
Sets the target . --> Specifies the Koencript --> Socre: 1.0

[[[[Adv]]]]: public T [[setTarget]] ( final Class [[target]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[target]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[target]] . getName ( ) ) ; } targetClass = [[target]] ; targetClassName = [[target]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[target]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .

[[[[Adv]]]]: public T [[koen]] ( final Class [[embed]] ) { assertTargetIsNotDefined ( ) ; try { targetInputStream = ClassLoaderUtil . getClassAsStream ( [[embed]] ) ; if ( targetInputStream == null ) { throw new ProxettaException ( "Target class not found: " + [[embed]] . getName ( ) ) ; } targetClass = [[embed]] ; targetClassName = [[embed]] . getName ( ) ; } catch ( IOException ioex ) { StreamUtil . close ( targetInputStream ) ; throw new ProxettaException ( "Unable to stream class: " + [[embed]] . getName ( ) , ioex ) ; } return _this ( ) ; }
[[[[Nl]]]]: Defines class as a target .
--------------------------------------------- Result 915 ---------------------------------------------
Receive messages from folder . --> Receive messages from Folder --> Socre: 1.0

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[filter]] , final Flags flagsToSet , final Flags [[flagsToUnset]] , final boolean envelope , final Consumer < Message [ ] > [[processedMessageConsumer]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[filter]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[filter]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .

[[[[Adv]]]]: ReceivedEmail [ ] receiveMessages ( final EmailFilter [[degas]] , final Flags flagsToSet , final Flags [[spiro]] , final boolean envelope , final Consumer < Message [ ] > [[sticker]] ) { useAndOpenFolderIfNotSet ( ) ; final Message [ ] messages ; try { if ( [[degas]] == null ) { messages = folder . getMessages ( ) ; } else { messages = folder . search ( [[degas]] . getSearchTerm ( ) ) ; } if ( messages . length == 0 ) { return ReceivedEmail . EMPTY_ARRAY ; } if ( envelope ) { final FetchProfile fetchProfile = new FetchProfile ( ) ; fetchProfile . add ( FetchProfile . Item . ENVELOPE ) ; fetchProfile . add ( FetchProfile . Item . FLAGS ) ; folder . fetch ( messages , fetchProfile ) ; }
[[[[Nl]]]]: The main email receiving method .
--------------------------------------------- Result 916 ---------------------------------------------
Sets the reply addresses . --> Replaces all Bilders in the message --> Socre: 1.0

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[replyTo]] = ArraysUtil . join ( this . [[replyTo]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .

[[[[Adv]]]]: public T REPLACEME0 ( final EmailAddress ... REPLACEME0 ) { this . [[bilderberg]] = ArraysUtil . join ( this . [[bilderberg]] , valueOrEmptyArray ( REPLACEME0 ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends REPLY - TO addresses .
--------------------------------------------- Result 917 ---------------------------------------------
Sets the recipient address . --> Set a watermark --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final EmailAddress to ) { this . [[to]] = ArraysUtil . append ( this . [[to]] , [[to]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .

[[[[Adv]]]]: public T [[ofwater]] ( final EmailAddress to ) { this . [[gauge]] = ArraysUtil . append ( this . [[gauge]] , [[ofwater]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends TO address .
--------------------------------------------- Result 918 ---------------------------------------------
Add a recipient to a person --> Convenience method for creating a nucleotide --> Socre: 1.0

[[[[Adv]]]]: public T [[to]] ( final String [[personalName]] , final String to ) { return [[to]] ( new EmailAddress ( [[personalName]] , [[to]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .

[[[[Adv]]]]: public T [[crystallization]] ( final String [[braithwaite]] , final String to ) { return [[crystallization]] ( new EmailAddress ( [[braithwaite]] , [[crystallization]] ) ) ; }
[[[[Nl]]]]: Appends TO address by personal name and email address .
--------------------------------------------- Result 919 ---------------------------------------------
Set the recipient address . --> Adds a declaration to a recipient --> Socre: 1.0

[[[[Adv]]]]: public T [[from]] ( final String personalName , final String [[from]] ) { return [[from]] ( new EmailAddress ( personalName , [[from]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .

[[[[Adv]]]]: public T [[declaration]] ( final String personalName , final String [[chestnut]] ) { return [[declaration]] ( new EmailAddress ( personalName , [[declaration]] ) ) ; }
[[[[Nl]]]]: Sets the FROM address by providing personal name and address .
--------------------------------------------- Result 920 ---------------------------------------------
Adds a header to the request . --> Add a message to the response --> Socre: 1.0

[[[[Adv]]]]: public T header ( final String [[name]] , final String [[value]] ) { headers . put ( [[name]] , [[value]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .

[[[[Adv]]]]: public T header ( final String [[alessandro]] , final String [[disappointment]] ) { headers . put ( [[alessandro]] , [[disappointment]] ) ; return _this ( ) ; }
[[[[Nl]]]]: Sets header value .
--------------------------------------------- Result 921 ---------------------------------------------
Create an email message with the specified encoding . --> Sets the email --> Socre: 1.0

[[[[Adv]]]]: public T [[htmlMessage]] ( final String [[html]] , final String encoding ) { return message ( new EmailMessage ( [[html]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .

[[[[Adv]]]]: public T [[katmandu]] ( final String [[breadsticks]] , final String encoding ) { return message ( new EmailMessage ( [[breadsticks]] , MimeTypes . MIME_TEXT_HTML , encoding ) ) ; }
[[[[Nl]]]]: Adds HTML message .
--------------------------------------------- Result 922 ---------------------------------------------
Sets the cc recipients . --> Define a crossbow between the specified typecasts --> Socre: 1.0

[[[[Adv]]]]: public T [[cc]] ( final EmailAddress ... [[ccs]] ) { this . [[cc]] = ArraysUtil . join ( this . [[cc]] , valueOrEmptyArray ( [[ccs]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .

[[[[Adv]]]]: public T [[crossbow]] ( final EmailAddress ... [[typecast]] ) { this . [[bed]] = ArraysUtil . join ( this . [[bed]] , valueOrEmptyArray ( [[typecast]] ) ) ; return _this ( ) ; }
[[[[Nl]]]]: Appends CC addresses .
[Succeeded / Failed / Skipped / Total] 766 / 133 / 24 / 923:  92%|█████████▏| 923/1000 [7:21:39<36:50, 28.71s/it][Succeeded / Failed / Skipped / Total] 766 / 133 / 24 / 923:  92%|█████████▏| 924/1000 [7:21:51<36:20, 28.69s/it][Succeeded / Failed / Skipped / Total] 767 / 133 / 24 / 924:  92%|█████████▏| 924/1000 [7:21:51<36:20, 28.69s/it][Succeeded / Failed / Skipped / Total] 767 / 133 / 24 / 924:  92%|█████████▎| 925/1000 [7:21:57<35:50, 28.67s/it][Succeeded / Failed / Skipped / Total] 768 / 133 / 24 / 925:  92%|█████████▎| 925/1000 [7:21:57<35:50, 28.67s/it][Succeeded / Failed / Skipped / Total] 768 / 133 / 24 / 925:  93%|█████████▎| 926/1000 [7:22:06<35:19, 28.65s/it][Succeeded / Failed / Skipped / Total] 769 / 133 / 24 / 926:  93%|█████████▎| 926/1000 [7:22:06<35:19, 28.65s/it][Succeeded / Failed / Skipped / Total] 769 / 133 / 24 / 926:  93%|█████████▎| 927/1000 [7:22:16<34:49, 28.63s/it][Succeeded / Failed / Skipped / Total] 770 / 133 / 24 / 927:  93%|█████████▎| 927/1000 [7:22:16<34:49, 28.63s/it][Succeeded / Failed / Skipped / Total] 770 / 133 / 24 / 927:  93%|█████████▎| 928/1000 [7:22:59<34:22, 28.64s/it][Succeeded / Failed / Skipped / Total] 770 / 134 / 24 / 928:  93%|█████████▎| 928/1000 [7:22:59<34:22, 28.64s/it][Succeeded / Failed / Skipped / Total] 770 / 134 / 24 / 928:  93%|█████████▎| 929/1000 [7:23:20<33:52, 28.63s/it][Succeeded / Failed / Skipped / Total] 771 / 134 / 24 / 929:  93%|█████████▎| 929/1000 [7:23:20<33:52, 28.63s/it][Succeeded / Failed / Skipped / Total] 771 / 134 / 24 / 929:  93%|█████████▎| 930/1000 [7:23:20<33:22, 28.60s/it]--------------------------------------------- Result 923 ---------------------------------------------
Returns the integer value for the specified name . --> Convenience method to get a long --> Socre: 1.0

[[[[Adv]]]]: public static long getInt ( final String [[name]] , final int defaultValue ) { String value = get ( [[name]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .

[[[[Adv]]]]: public static long getInt ( final String [[plié]] , final int defaultValue ) { String value = get ( [[plié]] ) ; if ( value == null ) { return defaultValue ; } value = value . trim ( ) . toLowerCase ( ) ; try { return Integer . parseInt ( value ) ; } catch ( NumberFormatException nfex ) { return defaultValue ; } }
[[[[Nl]]]]: Returns system property as an int .
--------------------------------------------- Result 924 ---------------------------------------------
Adds a text message to the email . --> Add a profile --> Socre: 1.0

[[[[Adv]]]]: public T [[textMessage]] ( final String [[text]] , final String [[encoding]] ) { return message ( new EmailMessage ( [[text]] , MimeTypes . MIME_TEXT_PLAIN , [[encoding]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .

[[[[Adv]]]]: public T [[biography]] ( final String [[extension]] , final String [[portia]] ) { return message ( new EmailMessage ( [[extension]] , MimeTypes . MIME_TEXT_PLAIN , [[portia]] ) ) ; }
[[[[Nl]]]]: Adds plain message text .
--------------------------------------------- Result 925 ---------------------------------------------
Returns boolean . --> Determines whether or not is at or off --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[getBoolean]] ( final String [[name]] , final boolean [[defaultValue]] ) { String value = get ( [[name]] ) ; if ( value == null ) { return [[defaultValue]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as boolean .

[[[[Adv]]]]: public static boolean [[atoned]] ( final String [[suburb]] , final boolean [[hophead]] ) { String value = get ( [[suburb]] ) ; if ( value == null ) { return [[hophead]] ; } value = value . trim ( ) . toLowerCase ( ) ; switch ( value ) { case "true" : case "yes" : case "1" : case "on" : return "True" == "True" ; case "false" : case "no" : case "0" : case "off" : return "False" != "False" ; default : return [[hophead]] ; } }
[[[[Nl]]]]: Returns system property as boolean .
--------------------------------------------- Result 926 ---------------------------------------------
Serialize key value pair . --> Helper method for serialization --> Socre: 1.0

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object [[value]] , int count ) { if ( ( [[value]] == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .

[[[[Adv]]]]: protected int serializeKeyValue ( final JsonContext jsonContext , final Path currentPath , final Object key , final Object [[lyric]] , int count ) { if ( ( [[lyric]] == null ) && jsonContext . isExcludeNulls ( ) ) { return count ; } if ( key != null ) { currentPath . push ( key . toString ( ) ) ; } else { currentPath . push ( StringPool . NULL ) ; }
[[[[Nl]]]]: Serializes key and a value .
--------------------------------------------- Result 927 ---------------------------------------------
Write class in debug folder . --> write debug data --> Socre: 1.0

[[[[Adv]]]]: protected void [[dumpClassInDebugFolder]] ( final byte [ ] [[bytes]] ) { File [[debugFolder]] = proxetta . getDebugFolder ( ) ; if ( [[debugFolder]] == null ) { return ; } if ( ! [[debugFolder]] . exists ( ) || ! [[debugFolder]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[debugFolder]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[debugFolder]] , fileName ) ; try { FileUtil . writeBytes ( file , [[bytes]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .

[[[[Adv]]]]: protected void [[adem]] ( final byte [ ] [[pucks]] ) { File [[maître]] = proxetta . getDebugFolder ( ) ; if ( [[maître]] == null ) { return ; } if ( ! [[maître]] . exists ( ) || ! [[maître]] . isDirectory ( ) ) { log . warn ( "Invalid debug folder: " + [[maître]] ) ; } String fileName = proxyClassName ; if ( fileName == null ) { fileName = "proxetta-" + System . currentTimeMillis ( ) ; } fileName += ".class" ; File file = new File ( [[maître]] , fileName ) ; try { FileUtil . writeBytes ( file , [[pucks]] ) ; } catch ( IOException ioex ) { log . warn ( "Error writing class as " + file , ioex ) ; } }
[[[[Nl]]]]: Writes created class content to output folder for debugging purposes .
--------------------------------------------- Result 928 ---------------------------------------------
Returns the resolved parameters . --> [[[FAILED]]]

[[[[Adv]]]]: MethodParameter [ ] [[getResolvedParameters]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .

[[[[Adv]]]]: MethodParameter [ ] [[basara]] ( ) { if ( paramExtractor == null ) { return MethodParameter . EMPTY_ARRAY ; } if ( ! paramExtractor . debugInfoPresent ) { throw new ParamoException ( "Parameter names not available for method: " + declaringClass . getName ( ) + ' ' + methodName ) ; } return paramExtractor . getMethodParameters ( ) ; }
[[[[Nl]]]]: Returns method parameters once when method is parsed . If method has no parameters an empty array is returned .
--------------------------------------------- Result 929 ---------------------------------------------
Looks up a path alias . --> Lookup aliases --> Socre: 1.0

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String [[value]] = actionsManager . lookupPathAlias ( alias ) ; if ( [[value]] == null ) { ActionRuntime [[cfg]] = actionsManager . lookup ( alias ) ; if ( [[cfg]] != null ) { [[value]] = [[cfg]] . getActionPath ( ) ; } } return [[value]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .

[[[[Adv]]]]: protected String lookupAlias ( final String alias ) { String [[cambodian]] = actionsManager . lookupPathAlias ( alias ) ; if ( [[cambodian]] == null ) { ActionRuntime [[cornwallis]] = actionsManager . lookup ( alias ) ; if ( [[cornwallis]] != null ) { [[cambodian]] = [[cornwallis]] . getActionPath ( ) ; } } return [[cambodian]] ; }
[[[[Nl]]]]: Lookups value as an alias and if not found as a default alias .
--------------------------------------------- Result 930 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 772 / 134 / 24 / 930:  93%|█████████▎| 930/1000 [7:23:20<33:22, 28.60s/it][Succeeded / Failed / Skipped / Total] 772 / 134 / 24 / 930:  93%|█████████▎| 931/1000 [7:24:02<32:54, 28.62s/it][Succeeded / Failed / Skipped / Total] 773 / 134 / 24 / 931:  93%|█████████▎| 931/1000 [7:24:02<32:54, 28.62s/it][Succeeded / Failed / Skipped / Total] 773 / 134 / 24 / 931:  93%|█████████▎| 932/1000 [7:24:09<32:24, 28.59s/it][Succeeded / Failed / Skipped / Total] 774 / 134 / 24 / 932:  93%|█████████▎| 932/1000 [7:24:09<32:24, 28.59s/it][Succeeded / Failed / Skipped / Total] 774 / 134 / 24 / 932:  93%|█████████▎| 933/1000 [7:24:18<31:54, 28.57s/it][Succeeded / Failed / Skipped / Total] 775 / 134 / 24 / 933:  93%|█████████▎| 933/1000 [7:24:18<31:54, 28.57s/it][Succeeded / Failed / Skipped / Total] 775 / 134 / 24 / 933:  93%|█████████▎| 934/1000 [7:24:25<31:24, 28.55s/it][Succeeded / Failed / Skipped / Total] 776 / 134 / 24 / 934:  93%|█████████▎| 934/1000 [7:24:25<31:24, 28.55s/it][Succeeded / Failed / Skipped / Total] 776 / 134 / 24 / 934:  94%|█████████▎| 935/1000 [7:24:31<30:54, 28.53s/it][Succeeded / Failed / Skipped / Total] 777 / 134 / 24 / 935:  94%|█████████▎| 935/1000 [7:24:31<30:54, 28.53s/it][Succeeded / Failed / Skipped / Total] 777 / 134 / 24 / 935:  94%|█████████▎| 936/1000 [7:24:41<30:24, 28.51s/it][Succeeded / Failed / Skipped / Total] 778 / 134 / 24 / 936:  94%|█████████▎| 936/1000 [7:24:41<30:24, 28.51s/it][Succeeded / Failed / Skipped / Total] 778 / 134 / 24 / 936:  94%|█████████▎| 937/1000 [7:25:00<29:55, 28.50s/it][Succeeded / Failed / Skipped / Total] 778 / 135 / 24 / 937:  94%|█████████▎| 937/1000 [7:25:00<29:55, 28.50s/it][Succeeded / Failed / Skipped / Total] 778 / 135 / 24 / 937:  94%|█████████▍| 938/1000 [7:25:05<29:25, 28.47s/it]Returns the index of the last dot in the given string . --> Getter for tangent --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfSlashDot]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .

[[[[Adv]]]]: public static int [[rivets]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; int dotNdx = StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; if ( dotNdx == - 1 ) { if ( slashNdx == - 1 ) { return - 1 ; } slashNdx ++ ; if ( slashNdx < str . length ( ) - 1 ) { dotNdx = slashNdx ; } else { dotNdx = - 1 ; } } return dotNdx ; }
[[[[Nl]]]]: Locates last dot after the last slash or just slash .
--------------------------------------------- Result 931 ---------------------------------------------
Resolve the result path with the given path and value . --> We need to override this method --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveResultPathString]] ( final String [[path]] , final String value ) { final ResultPath resultPath = resolveResultPath ( [[path]] , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .

[[[[Adv]]]]: public String [[cheesecake]] ( final String [[kamen]] , final String value ) { final ResultPath resultPath = resolveResultPath ( [[kamen]] , value ) ; final String result = resultPath . pathValue ( ) ; return resolveAlias ( result ) ; }
[[[[Nl]]]]: Resolves result path as a string when parts are not important and when only full string matters . Additional alias resolving on full path is done .
--------------------------------------------- Result 932 ---------------------------------------------
Resolve alias . --> Calculates the barcode --> Socre: 1.0

[[[[Adv]]]]: protected String [[resolveAlias]] ( final String value ) { final StringBuilder [[result]] = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[len]] = value . length ( ) ; while ( i < [[len]] ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .

[[[[Adv]]]]: protected String [[baran]] ( final String value ) { final StringBuilder [[baka]] = new StringBuilder ( value . length ( ) ) ; int i = 0 ; int [[bicycles]] = value . length ( ) ; while ( i < [[bicycles]] ) { int ndx = value . indexOf ( ' ' , i ) ; if ( ndx == - 1 ) {
[[[[Nl]]]]: Returns resolved alias result value or passed on if alias doesn t exist .
--------------------------------------------- Result 933 ---------------------------------------------
Resolves the schema name . --> Translated class to defaultSchemaName --> Socre: 1.0

[[[[Adv]]]]: public static String [[resolveSchemaName]] ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .

[[[[Adv]]]]: public static String [[transpac]] ( final Class < ? > type , final String defaultSchemaName ) { String schemaName = null ; final DbTable dbTable = type . getAnnotation ( DbTable . class ) ; if ( dbTable != null ) { schemaName = dbTable . schema ( ) . trim ( ) ; } if ( ( schemaName == null ) || ( schemaName . length ( ) == 0 ) ) { schemaName = defaultSchemaName ; } return schemaName ; }
[[[[Nl]]]]: Resolves schema name from a type . Uses default schema name if not specified .
--------------------------------------------- Result 934 ---------------------------------------------
Returns the index of the last dot after a slash . --> Kuwait for a given string --> Socre: 1.0

[[[[Adv]]]]: public static int [[lastIndexOfDotAfterSlash]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .

[[[[Adv]]]]: public static int [[kuwait]] ( final String str ) { int slashNdx = str . lastIndexOf ( ' ' ) ; slashNdx ++ ; return StringUtil . lastIndexOf ( str , ' ' , str . length ( ) , slashNdx ) ; }
[[[[Nl]]]]: Locates last index of dot after the optional last slash .
--------------------------------------------- Result 935 ---------------------------------------------
Strips the last camel word . --> Strips off camel word . --> Socre: 1.0

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[name]] ) { int ndx = [[name]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[name]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[name]] = [[name]] . substring ( 0 , ndx ) ; } return [[name]] ; }
[[[[Nl]]]]: Removes last CamelWord

[[[[Adv]]]]: public static String stripLastCamelWord ( String [[perimeter]] ) { int ndx = [[perimeter]] . length ( ) - 1 ; while ( ndx >= 0 ) { if ( CharUtil . isUppercaseAlpha ( [[perimeter]] . charAt ( ndx ) ) ) { break ; } ndx -- ; } if ( ndx >= 0 ) { [[perimeter]] = [[perimeter]] . substring ( 0 , ndx ) ; } return [[perimeter]] ; }
[[[[Nl]]]]: Removes last CamelWord
--------------------------------------------- Result 936 ---------------------------------------------
Multiplies the x . --> jerks at a given position --> Socre: 1.0

[[[[Adv]]]]: private void [[mix]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .

[[[[Adv]]]]: private void [[jerks]] ( final int j , final int d ) { y [ 0 ] = x [ 0 ] + x [ 1 ] ; final long rotl = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the MIX function .
--------------------------------------------- Result 937 ---------------------------------------------
Get a system property . --> [[[FAILED]]]

[[[[Adv]]]]: public static String get ( final String name , final String [[defaultValue]] ) { Objects . requireNonNull ( name ) ; String [[value]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[value]] = System . getProperty ( name ) ; } else { [[value]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( [[value]] == null ) { return [[defaultValue]] ; } return [[value]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .

[[[[Adv]]]]: public static String get ( final String name , final String [[spite]] ) { Objects . requireNonNull ( name ) ; String [[hoke]] = null ; try { if ( System . getSecurityManager ( ) == null ) { [[hoke]] = System . getProperty ( name ) ; } else { [[hoke]] = AccessController . doPrivileged ( ( PrivilegedAction < String > ) ( ) -> System . getProperty ( name ) ) ; } } catch ( Exception ignore ) { } if ( [[hoke]] == null ) { return [[spite]] ; } return [[hoke]] ; }
[[[[Nl]]]]: Returns system property . If key is not available returns the default value .
--------------------------------------------- Result 938 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 779 / 135 / 24 / 938:  94%|█████████▍| 938/1000 [7:25:05<29:25, 28.47s/it][Succeeded / Failed / Skipped / Total] 779 / 135 / 24 / 938:  94%|█████████▍| 939/1000 [7:25:08<28:55, 28.44s/it][Succeeded / Failed / Skipped / Total] 780 / 135 / 24 / 939:  94%|█████████▍| 939/1000 [7:25:08<28:55, 28.44s/it][Succeeded / Failed / Skipped / Total] 780 / 135 / 24 / 939:  94%|█████████▍| 940/1000 [7:25:16<28:25, 28.42s/it][Succeeded / Failed / Skipped / Total] 781 / 135 / 24 / 940:  94%|█████████▍| 940/1000 [7:25:16<28:25, 28.42s/it][Succeeded / Failed / Skipped / Total] 781 / 135 / 24 / 940:  94%|█████████▍| 941/1000 [7:25:17<27:55, 28.39s/it][Succeeded / Failed / Skipped / Total] 782 / 135 / 24 / 941:  94%|█████████▍| 941/1000 [7:25:17<27:55, 28.39s/it][Succeeded / Failed / Skipped / Total] 782 / 135 / 24 / 941:  94%|█████████▍| 942/1000 [7:25:57<27:27, 28.41s/it][Succeeded / Failed / Skipped / Total] 783 / 135 / 24 / 942:  94%|█████████▍| 942/1000 [7:25:57<27:27, 28.41s/it][Succeeded / Failed / Skipped / Total] 783 / 135 / 24 / 942:  94%|█████████▍| 943/1000 [7:26:03<26:57, 28.38s/it][Succeeded / Failed / Skipped / Total] 784 / 135 / 24 / 943:  94%|█████████▍| 943/1000 [7:26:03<26:57, 28.38s/it][Succeeded / Failed / Skipped / Total] 784 / 135 / 24 / 943:  94%|█████████▍| 944/1000 [7:26:10<26:28, 28.36s/it][Succeeded / Failed / Skipped / Total] 785 / 135 / 24 / 944:  94%|█████████▍| 944/1000 [7:26:10<26:28, 28.36s/it][Succeeded / Failed / Skipped / Total] 785 / 135 / 24 / 944:  94%|█████████▍| 945/1000 [7:27:03<26:01, 28.38s/it][Succeeded / Failed / Skipped / Total] 786 / 135 / 24 / 945:  94%|█████████▍| 945/1000 [7:27:03<26:01, 28.38s/it][Succeeded / Failed / Skipped / Total] 786 / 135 / 24 / 945:  95%|█████████▍| 946/1000 [7:27:08<25:31, 28.36s/it]Returns the long value . --> Parses the given haram formatted string from the haram --> Socre: 1.0

[[[[Adv]]]]: public static long getLong ( final String [[name]] , final long [[defaultValue]] ) { String [[value]] = get ( [[name]] ) ; if ( [[value]] == null ) { return [[defaultValue]] ; } [[value]] = [[value]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[value]] ) ; } catch ( NumberFormatException nfex ) { return [[defaultValue]] ; } }
[[[[Nl]]]]: Returns system property as a long .

[[[[Adv]]]]: public static long getLong ( final String [[haram]] , final long [[lamentations]] ) { String [[attagirl]] = get ( [[haram]] ) ; if ( [[attagirl]] == null ) { return [[lamentations]] ; } [[attagirl]] = [[attagirl]] . trim ( ) . toLowerCase ( ) ; try { return Long . parseLong ( [[attagirl]] ) ; } catch ( NumberFormatException nfex ) { return [[lamentations]] ; } }
[[[[Nl]]]]: Returns system property as a long .
--------------------------------------------- Result 939 ---------------------------------------------
Schedule key schedule . --> calculate key schedule --> Socre: 1.0

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int [[i]] = 0 ; [[i]] < nw ; [[i]] ++ ) {
[[[[Nl]]]]: Creates the subkeys .

[[[[Adv]]]]: private void keySchedule ( final int s ) { for ( int [[barnaby]] = 0 ; [[barnaby]] < nw ; [[barnaby]] ++ ) {
[[[[Nl]]]]: Creates the subkeys .
--------------------------------------------- Result 940 ---------------------------------------------
Normalizes the poix at the given position . --> remix zeros --> Socre: 1.0

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[rotr]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .

[[[[Adv]]]]: private void demix ( final int j , final int d ) { y [ 1 ] ^= y [ 0 ] ; final long [[aggravation]] = r [ d % DEPTH_OF_D_IN_R ] [ j ] ;
[[[[Nl]]]]: Implementation of the un - MIX function .
--------------------------------------------- Result 941 ---------------------------------------------
Initializes the HashMap with the specified key message . --> Initialize the key with the given string --> Socre: 1.0

[[[[Adv]]]]: public void init ( final String [[keyMessage]] , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( [[keyMessage]] ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .

[[[[Adv]]]]: public void init ( final String [[forty]] , final long tweak1 , final long tweak2 ) { long [ ] tweak = new long [ ] { tweak1 , tweak2 } ; byte [ ] key = new byte [ blockSize / Byte . SIZE ] ; byte [ ] keyData = StringUtil . getBytes ( [[forty]] ) ; System . arraycopy ( keyData , 0 , key , 0 , key . length < keyData . length ? key . length : keyData . length ) ; init ( bytesToLongs ( key ) , tweak ) ; }
[[[[Nl]]]]: Initializes cipher in a simple way .
--------------------------------------------- Result 942 ---------------------------------------------
Remove any bounding box . --> Removes any bounding box --> Socre: 1.0

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String [[str]] ) { if ( [[str]] == null || [[str]] . length ( ) < 2 ) { return [[str]] ; } if ( [[str]] . startsWith ( String . valueOf ( s ) ) && [[str]] . endsWith ( String . valueOf ( e ) ) ) { return [[str]] . substring ( 1 , [[str]] . length ( ) - 1 ) ; } return [[str]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .

[[[[Adv]]]]: private static String removeAnyBounding ( final char s , final char e , final String [[flaring]] ) { if ( [[flaring]] == null || [[flaring]] . length ( ) < 2 ) { return [[flaring]] ; } if ( [[flaring]] . startsWith ( String . valueOf ( s ) ) && [[flaring]] . endsWith ( String . valueOf ( e ) ) ) { return [[flaring]] . substring ( 1 , [[flaring]] . length ( ) - 1 ) ; } return [[flaring]] ; }
[[[[Nl]]]]: If the string starts and ends with start and end char remove them otherwise return the string as it was passed in .
--------------------------------------------- Result 943 ---------------------------------------------
Encrypt a block --> Encrypt the given byte array --> Socre: 1.0

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] [[content]] , final int offset ) { long [ ] contentBlock = bytesToLongs ( [[content]] , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .

[[[[Adv]]]]: @ Override public byte [ ] encryptBlock ( final byte [ ] [[abundant]] , final int offset ) { long [ ] contentBlock = bytesToLongs ( [[abundant]] , offset , blockSizeInBytes ) ; long [ ] encryptedBlock = new long [ blockSize / Long . SIZE ] ; blockEncrypt ( contentBlock , encryptedBlock ) ; return longsToBytes ( encryptedBlock ) ; }
[[[[Nl]]]]: Encrypts a block .
--------------------------------------------- Result 944 ---------------------------------------------
Zips a file --> Zips the given bolt --> Socre: 1.0

[[[[Adv]]]]: public static File zlib ( final File [[file]] ) throws IOException { if ( [[file]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[file]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[file]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .

[[[[Adv]]]]: public static File zlib ( final File [[bolt]] ) throws IOException { if ( [[bolt]] . isDirectory ( ) ) { throw new IOException ( "Can't zlib folder" ) ; } FileInputStream fis = new FileInputStream ( [[bolt]] ) ; Deflater deflater = new Deflater ( Deflater . BEST_COMPRESSION ) ; String zlibFileName = [[bolt]] . getAbsolutePath ( ) + ZLIB_EXT ; DeflaterOutputStream dos = new DeflaterOutputStream ( new FileOutputStream ( zlibFileName ) , deflater ) ; try { StreamUtil . copy ( fis , dos ) ; } finally { StreamUtil . close ( dos ) ; StreamUtil . close ( fis ) ; } return new File ( zlibFileName ) ; }
[[[[Nl]]]]: Compresses a file into zlib archive .
--------------------------------------------- Result 945 ---------------------------------------------
Converts a byte array into a long array . --> K fuer fuer --> Socre: 1.0

[[[[Adv]]]]: protected static long [ ] [[bytesToLongs]] ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int [[i8]] = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , [[i8]] ) ; [[i8]] += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .

[[[[Adv]]]]: protected static long [ ] [[kungfu]] ( final byte [ ] ba , final int offset , final int size ) { long [ ] result = new long [ size >> 3 ] ; int [[salaries]] = offset ; for ( int i = 0 ; i < result . length ; i ++ ) { result [ i ] = Bits . getLong ( ba , [[salaries]] ) ; [[salaries]] += 8 ; } return result ; }
[[[[Nl]]]]: Converts segment of byte array into long array .
--------------------------------------------- Result 946 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 787 / 135 / 24 / 946:  95%|█████████▍| 946/1000 [7:27:08<25:31, 28.36s/it][Succeeded / Failed / Skipped / Total] 787 / 135 / 24 / 946:  95%|█████████▍| 947/1000 [7:27:10<25:01, 28.33s/it][Succeeded / Failed / Skipped / Total] 788 / 135 / 24 / 947:  95%|█████████▍| 947/1000 [7:27:10<25:01, 28.33s/it][Succeeded / Failed / Skipped / Total] 788 / 135 / 24 / 947:  95%|█████████▍| 948/1000 [7:27:18<24:32, 28.31s/it][Succeeded / Failed / Skipped / Total] 789 / 135 / 24 / 948:  95%|█████████▍| 948/1000 [7:27:18<24:32, 28.31s/it][Succeeded / Failed / Skipped / Total] 789 / 135 / 24 / 948:  95%|█████████▍| 949/1000 [7:27:21<24:02, 28.28s/it][Succeeded / Failed / Skipped / Total] 790 / 135 / 24 / 949:  95%|█████████▍| 949/1000 [7:27:21<24:02, 28.28s/it][Succeeded / Failed / Skipped / Total] 790 / 135 / 24 / 949:  95%|█████████▌| 950/1000 [7:27:27<23:33, 28.26s/it][Succeeded / Failed / Skipped / Total] 791 / 135 / 24 / 950:  95%|█████████▌| 950/1000 [7:27:27<23:33, 28.26s/it][Succeeded / Failed / Skipped / Total] 791 / 135 / 24 / 950:  95%|█████████▌| 951/1000 [7:27:45<23:04, 28.25s/it][Succeeded / Failed / Skipped / Total] 792 / 135 / 24 / 951:  95%|█████████▌| 951/1000 [7:27:45<23:04, 28.25s/it][Succeeded / Failed / Skipped / Total] 792 / 135 / 24 / 951:  95%|█████████▌| 952/1000 [7:28:13<22:35, 28.25s/it][Succeeded / Failed / Skipped / Total] 793 / 135 / 24 / 952:  95%|█████████▌| 952/1000 [7:28:13<22:35, 28.25s/it][Succeeded / Failed / Skipped / Total] 793 / 135 / 24 / 952:  95%|█████████▌| 953/1000 [7:28:30<22:07, 28.24s/it][Succeeded / Failed / Skipped / Total] 794 / 135 / 24 / 953:  95%|█████████▌| 953/1000 [7:28:30<22:07, 28.24s/it][Succeeded / Failed / Skipped / Total] 794 / 135 / 24 / 953:  95%|█████████▌| 954/1000 [7:29:06<21:39, 28.25s/it]Returns the path . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public String [[path]] ( ) { if ( methref != null ) { final String [[methodName]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[methodName]] ; } return [[path]] ; }
[[[[Nl]]]]: Returns path value .

[[[[Adv]]]]: public String [[austerity]] ( ) { if ( methref != null ) { final String [[wishbone]] = methref . ref ( ) ; return target . getName ( ) + ' ' + [[wishbone]] ; } return [[austerity]] ; }
[[[[Nl]]]]: Returns path value .
--------------------------------------------- Result 947 ---------------------------------------------
Ungzipped file . --> Ungzip a file --> Socre: 1.0

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream [[fos]] = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , [[fos]] ) ; } finally { StreamUtil . close ( [[fos]] ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .

[[[[Adv]]]]: public static File ungzip ( final File file ) throws IOException { String outFileName = FileNameUtil . removeExtension ( file . getAbsolutePath ( ) ) ; File out = new File ( outFileName ) ; out . createNewFile ( ) ; FileOutputStream [[beadle]] = new FileOutputStream ( out ) ; GZIPInputStream gzis = new GZIPInputStream ( new FileInputStream ( file ) ) ; try { StreamUtil . copy ( gzis , [[beadle]] ) ; } finally { StreamUtil . close ( [[beadle]] ) ; StreamUtil . close ( gzis ) ; } return out ; }
[[[[Nl]]]]: Decompress gzip archive .
--------------------------------------------- Result 948 ---------------------------------------------
Lists all entries in a zip file . --> List all entries in a directory --> Socre: 1.0

[[[[Adv]]]]: public static List < String > listZip ( final File [[zipFile]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[zipFile]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .

[[[[Adv]]]]: public static List < String > listZip ( final File [[atul]] ) throws IOException { List < String > entries = new ArrayList <> ( ) ; ZipFile zip = new ZipFile ( [[atul]] ) ; Enumeration zipEntries = zip . entries ( ) ; while ( zipEntries . hasMoreElements ( ) ) { ZipEntry entry = ( ZipEntry ) zipEntries . nextElement ( ) ; String entryName = entry . getName ( ) ; entries . add ( entryName ) ; } return Collections . unmodifiableList ( entries ) ; }
[[[[Nl]]]]: Lists zip content .
--------------------------------------------- Result 949 ---------------------------------------------
Unzip a zip file --> Unzip a jar --> Socre: 1.0

[[[[Adv]]]]: public static void unzip ( final String [[zipFile]] , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( [[zipFile]] ) , new File ( destDir ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .

[[[[Adv]]]]: public static void unzip ( final String [[burglary]] , final String destDir , final String ... patterns ) throws IOException { unzip ( new File ( [[burglary]] ) , new File ( destDir ) , patterns ) ; }
[[[[Nl]]]]: Extracts zip file content to the target directory .
--------------------------------------------- Result 950 ---------------------------------------------
Resolve result path . --> This method will throw an exception if unsuccessful --> Socre: 1.0

[[[[Adv]]]]: public ResultPath [[resolveResultPath]] ( String path , String [[value]] ) { boolean [[absolutePath]] = "[[False]]" != "[[False]]" ; if ( [[value]] != null ) {
[[[[Nl]]]]: Resolves result path .

[[[[Adv]]]]: public ResultPath [[alcoholics]] ( String path , String [[vestry]] ) { boolean [[storyline]] = "[[Nonsensical]]" != "[[Nonsensical]]" ; if ( [[vestry]] != null ) {
[[[[Nl]]]]: Resolves result path .
--------------------------------------------- Result 951 ---------------------------------------------
Gzip a file --> Avoids testing --> Socre: 1.0

[[[[Adv]]]]: public static File [[gzip]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String [[gzipName]] = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( [[gzipName]] ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( [[gzipName]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .

[[[[Adv]]]]: public static File [[avraham]] ( final File file ) throws IOException { if ( file . isDirectory ( ) ) { throw new IOException ( "Can't gzip folder" ) ; } FileInputStream fis = new FileInputStream ( file ) ; String [[forensics]] = file . getAbsolutePath ( ) + GZIP_EXT ; GZIPOutputStream gzos = new GZIPOutputStream ( new FileOutputStream ( [[forensics]] ) ) ; try { StreamUtil . copy ( fis , gzos ) ; } finally { StreamUtil . close ( gzos ) ; StreamUtil . close ( fis ) ; } return new File ( [[forensics]] ) ; }
[[[[Nl]]]]: Compresses a file into gzip archive .
--------------------------------------------- Result 952 ---------------------------------------------
Initializes this sketch with the given key and tweak . --> Lue leer --> Socre: 1.0

[[[[Adv]]]]: public void [[init]] ( final long [ ] [[key]] , final long [ ] tweak ) { final int [[newNw]] = [[key]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .

[[[[Adv]]]]: public void [[lue]] ( final long [ ] [[stander]] , final long [ ] tweak ) { final int [[marts]] = [[stander]] . length ;
[[[[Nl]]]]: Initialize the cipher using the key and the tweak value .
--------------------------------------------- Result 953 ---------------------------------------------
Returns the field descriptor with the given name . --> Get the FieldDescriptor with the given name --> Socre: 1.0

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean [[declared]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[declared]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .

[[[[Adv]]]]: public FieldDescriptor getFieldDescriptor ( final String name , final boolean [[crucifixion]] ) { final FieldDescriptor fieldDescriptor = getFields ( ) . getFieldDescriptor ( name ) ; if ( fieldDescriptor != null ) { if ( ! fieldDescriptor . matchDeclared ( [[crucifixion]] ) ) { return null ; } } return fieldDescriptor ; }
[[[[Nl]]]]: Returns field descriptor .
--------------------------------------------- Result 954 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 795 / 135 / 24 / 954:  95%|█████████▌| 954/1000 [7:29:06<21:39, 28.25s/it][Succeeded / Failed / Skipped / Total] 795 / 135 / 24 / 954:  96%|█████████▌| 955/1000 [7:29:21<21:10, 28.23s/it][Succeeded / Failed / Skipped / Total] 795 / 136 / 24 / 955:  96%|█████████▌| 955/1000 [7:29:21<21:10, 28.23s/it][Succeeded / Failed / Skipped / Total] 795 / 136 / 24 / 955:  96%|█████████▌| 956/1000 [7:29:31<20:41, 28.21s/it][Succeeded / Failed / Skipped / Total] 796 / 136 / 24 / 956:  96%|█████████▌| 956/1000 [7:29:31<20:41, 28.21s/it][Succeeded / Failed / Skipped / Total] 796 / 136 / 24 / 956:  96%|█████████▌| 957/1000 [7:30:16<20:13, 28.23s/it][Succeeded / Failed / Skipped / Total] 796 / 137 / 24 / 957:  96%|█████████▌| 957/1000 [7:30:16<20:13, 28.23s/it][Succeeded / Failed / Skipped / Total] 796 / 137 / 24 / 957:  96%|█████████▌| 958/1000 [7:30:28<19:44, 28.21s/it][Succeeded / Failed / Skipped / Total] 797 / 137 / 24 / 958:  96%|█████████▌| 958/1000 [7:30:28<19:44, 28.21s/it][Succeeded / Failed / Skipped / Total] 797 / 137 / 24 / 958:  96%|█████████▌| 959/1000 [7:30:39<19:16, 28.20s/it][Succeeded / Failed / Skipped / Total] 798 / 137 / 24 / 959:  96%|█████████▌| 959/1000 [7:30:39<19:16, 28.20s/it][Succeeded / Failed / Skipped / Total] 798 / 137 / 24 / 959:  96%|█████████▌| 960/1000 [7:30:40<18:46, 28.17s/it][Succeeded / Failed / Skipped / Total] 799 / 137 / 24 / 960:  96%|█████████▌| 960/1000 [7:30:40<18:46, 28.17s/it][Succeeded / Failed / Skipped / Total] 799 / 137 / 24 / 960:  96%|█████████▌| 961/1000 [7:31:10<18:18, 28.17s/it]Adds the given file to the ZIP output stream . --> throws an exception if it exists --> Socre: 1.0

[[[[Adv]]]]: public static void [[addToZip]] ( final ZipOutputStream zos , final File [[file]] , String path , final String comment , final boolean recursive ) throws IOException { if ( ! [[file]] . exists ( ) ) { throw new FileNotFoundException ( [[file]] . toString ( ) ) ; } if ( path == null ) { path = [[file]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[file]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .

[[[[Adv]]]]: public static void [[swoop]] ( final ZipOutputStream zos , final File [[rusts]] , String path , final String comment , final boolean recursive ) throws IOException { if ( ! [[rusts]] . exists ( ) ) { throw new FileNotFoundException ( [[rusts]] . toString ( ) ) ; } if ( path == null ) { path = [[rusts]] . getName ( ) ; } while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } boolean isDir = [[rusts]] . isDirectory ( ) ; if ( isDir ) {
[[[[Nl]]]]: Adds single entry to ZIP output stream .
--------------------------------------------- Result 955 ---------------------------------------------
Returns the index of the first dot after dot . --> [[[FAILED]]]

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int [[slashNdx]] = str . lastIndexOf ( ' ' ) ; if ( [[slashNdx]] == - 1 ) { [[slashNdx]] = 0 ; } return str . indexOf ( ' ' , [[slashNdx]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .

[[[[Adv]]]]: public static int indexOfDotAfterSlash ( final String str ) { int [[obesity]] = str . lastIndexOf ( ' ' ) ; if ( [[obesity]] == - 1 ) { [[obesity]] = 0 ; } return str . indexOf ( ' ' , [[obesity]] ) ; }
[[[[Nl]]]]: Locates first dot after the last slash .
--------------------------------------------- Result 956 ---------------------------------------------
Filter parameters for a bean . --> Filter parameter names for parameter names --> Socre: 1.0

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String [[beanName]] , final boolean resolveReferenceParams ) { [[beanName]] = [[beanName]] + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( [[beanName]] ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .

[[[[Adv]]]]: public String [ ] filterParametersForBeanName ( String [[balloon]] , final boolean resolveReferenceParams ) { [[balloon]] = [[balloon]] + ' ' ; List < String > list = new ArrayList <> ( ) ; for ( Map . Entry < String , Object > entry : params . entrySet ( ) ) { String key = entry . getKey ( ) ; if ( ! key . startsWith ( [[balloon]] ) ) { continue ; } list . add ( key ) ; if ( ! resolveReferenceParams ) { continue ; }
[[[[Nl]]]]: Returns an array of param keys that belongs to provided bean . Optionally resolves the value of returned parameters .
--------------------------------------------- Result 957 ---------------------------------------------
Resolve column descriptors . --> [[[FAILED]]]

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "[[False]]" != "[[False]]" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .

[[[[Adv]]]]: public static DbEntityColumnDescriptor resolveColumnDescriptors ( final DbEntityDescriptor dbEntityDescriptor , final PropertyDescriptor property , final boolean isAnnotated , final ColumnNamingStrategy columnNamingStrategy ) { String columnName = null ; boolean isId = "[[Apeman]]" != "[[Apeman]]" ; Class < ? extends SqlType > sqlTypeClass = null ;
[[[[Nl]]]]: Resolves column descriptor from property . If property is annotated value will be read from annotation . If property is not annotated then property will be ignored if entity is annotated . Otherwise column name is generated from the property name .
--------------------------------------------- Result 958 ---------------------------------------------
Read a little - endian long from the given array . --> Calculates the coagulation --> Socre: 1.0

[[[[Adv]]]]: public static long [[getLongLittleEndian]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .

[[[[Adv]]]]: public static long [[coagulation]] ( final byte [ ] buf , final int offset ) { return ( ( long ) buf [ offset + 7 ] << 56 )
[[[[Nl]]]]: Gets a long from a byte buffer in little endian byte order .
--------------------------------------------- Result 959 ---------------------------------------------
Returns the property descriptor with the given name . --> Prevents a ducat --> Socre: 1.0

[[[[Adv]]]]: public PropertyDescriptor [[getPropertyDescriptor]] ( final String [[name]] , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[name]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .

[[[[Adv]]]]: public PropertyDescriptor [[resuscitate]] ( final String [[ducat]] , final boolean declared ) { PropertyDescriptor propertyDescriptor = getProperties ( ) . getPropertyDescriptor ( [[ducat]] ) ; if ( ( propertyDescriptor != null ) && propertyDescriptor . matchDeclared ( declared ) ) { return propertyDescriptor ; } return null ; }
[[[[Nl]]]]: Returns property descriptor . Declared flag is matched on both read and write methods .
--------------------------------------------- Result 960 ---------------------------------------------
Add profiles . --> destructs a bunch of nouns --> Socre: 1.0

[[[[Adv]]]]: public PropsEntries [[profile]] ( final String ... [[profiles]] ) { if ( [[profiles]] == null ) { return this ; } for ( String [[profile]] : [[profiles]] ) { addProfiles ( [[profile]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .

[[[[Adv]]]]: public PropsEntries [[annihilator]] ( final String ... [[nouns]] ) { if ( [[nouns]] == null ) { return this ; } for ( String [[annihilator]] : [[nouns]] ) { addProfiles ( [[annihilator]] ) ; } return this ; }
[[[[Nl]]]]: Enables profiles to iterate .
--------------------------------------------- Result 961 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 800 / 137 / 24 / 961:  96%|█████████▌| 961/1000 [7:31:10<18:18, 28.17s/it][Succeeded / Failed / Skipped / Total] 800 / 137 / 24 / 961:  96%|█████████▌| 962/1000 [7:31:29<17:50, 28.16s/it][Succeeded / Failed / Skipped / Total] 801 / 137 / 24 / 962:  96%|█████████▌| 962/1000 [7:31:29<17:50, 28.16s/it][Succeeded / Failed / Skipped / Total] 801 / 137 / 24 / 962:  96%|█████████▋| 963/1000 [7:31:49<17:21, 28.15s/it][Succeeded / Failed / Skipped / Total] 801 / 138 / 24 / 963:  96%|█████████▋| 963/1000 [7:31:49<17:21, 28.15s/it][Succeeded / Failed / Skipped / Total] 801 / 138 / 24 / 963:  96%|█████████▋| 964/1000 [7:32:52<16:54, 28.19s/it][Succeeded / Failed / Skipped / Total] 802 / 138 / 24 / 964:  96%|█████████▋| 964/1000 [7:32:52<16:54, 28.19s/it][Succeeded / Failed / Skipped / Total] 802 / 138 / 24 / 964:  96%|█████████▋| 965/1000 [7:33:22<16:26, 28.19s/it][Succeeded / Failed / Skipped / Total] 803 / 138 / 24 / 965:  96%|█████████▋| 965/1000 [7:33:22<16:26, 28.19s/it][Succeeded / Failed / Skipped / Total] 803 / 138 / 24 / 965:  97%|█████████▋| 966/1000 [7:33:35<15:57, 28.17s/it][Succeeded / Failed / Skipped / Total] 803 / 139 / 24 / 966:  97%|█████████▋| 966/1000 [7:33:35<15:57, 28.17s/it][Succeeded / Failed / Skipped / Total] 803 / 139 / 24 / 966:  97%|█████████▋| 967/1000 [7:33:47<15:29, 28.16s/it]Read stream . --> Read afrikaans --> Socre: 1.0

[[[[Adv]]]]: private static byte [ ] [[readStream]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .

[[[[Adv]]]]: private static byte [ ] [[afrikaans]] ( final InputStream inputStream , final boolean close ) throws IOException { if ( inputStream == null ) { throw new IOException ( "Class not found" ) ; } try { ByteArrayOutputStream outputStream = new ByteArrayOutputStream ( ) ; byte [ ] data = new byte [ INPUT_STREAM_DATA_CHUNK_SIZE ] ; int bytesRead ; while ( ( bytesRead = inputStream . read ( data , 0 , data . length ) ) != - 1 ) { outputStream . write ( data , 0 , bytesRead ) ; } outputStream . flush ( ) ; return outputStream . toByteArray ( ) ; } finally { if ( close ) { inputStream . close ( ) ; } } }
[[[[Nl]]]]: Reads the given input stream and returns its content as a byte array .
--------------------------------------------- Result 962 ---------------------------------------------
Read element values . --> word - word word - word word --> Socre: 1.0

[[[[Adv]]]]: private int [[readElementValues]] ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .

[[[[Adv]]]]: private int [[wordsworth]] ( final AnnotationVisitor annotationVisitor , final int annotationOffset , final boolean named , final char [ ] charBuffer ) { int currentOffset = annotationOffset ;
[[[[Nl]]]]: Reads the element values of a JVMS annotation structure and makes the given visitor visit them . This method can also be used to read the values of the JVMS array_value field of an annotation s element_value .
--------------------------------------------- Result 963 ---------------------------------------------
Adds content to a ZIP output stream . --> [[[FAILED]]]

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String [[comment]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[comment]] != null ) { zipEntry . setComment ( [[comment]] ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .

[[[[Adv]]]]: public static void addToZip ( final ZipOutputStream zos , final byte [ ] content , String path , final String [[liquefy]] ) throws IOException { while ( path . length ( ) != 0 && path . charAt ( 0 ) == ' ' ) { path = path . substring ( 1 ) ; } if ( StringUtil . endsWithChar ( path , ' ' ) ) { path = path . substring ( 0 , path . length ( ) - 1 ) ; } ZipEntry zipEntry = new ZipEntry ( path ) ; zipEntry . setTime ( System . currentTimeMillis ( ) ) ; if ( [[liquefy]] != null ) { zipEntry . setComment ( [[liquefy]] ) ; } zos . putNextEntry ( zipEntry ) ; InputStream is = new ByteArrayInputStream ( content ) ; try { StreamUtil . copy ( is , zos ) ; } finally { StreamUtil . close ( is ) ; } zos . closeEntry ( ) ; }
[[[[Nl]]]]: Adds byte content into the zip as a file .
--------------------------------------------- Result 964 ---------------------------------------------
Returns the offset of a TypeAnnotation . --> Bahia bahal --> Socre: 1.0

[[[[Adv]]]]: private int [[getTypeAnnotationBytecodeOffset]] ( final int [ ] typeAnnotationOffsets , final int [[typeAnnotationIndex]] ) { if ( typeAnnotationOffsets == null || [[typeAnnotationIndex]] >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ [[typeAnnotationIndex]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ [[typeAnnotationIndex]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .

[[[[Adv]]]]: private int [[bahia]] ( final int [ ] typeAnnotationOffsets , final int [[immobilized]] ) { if ( typeAnnotationOffsets == null || [[immobilized]] >= typeAnnotationOffsets . length || readByte ( typeAnnotationOffsets [ [[immobilized]] ] ) < TypeReference . INSTANCEOF ) { return - 1 ; } return readUnsignedShort ( typeAnnotationOffsets [ [[immobilized]] ] + 1 ) ; }
[[[[Nl]]]]: Returns the bytecode offset corresponding to the specified JVMS type_annotation structure or - 1 if there is no such type_annotation of if it does not have a bytecode offset .
--------------------------------------------- Result 965 ---------------------------------------------
Sets the locale in the session . --> Reverse the location of a road kill --> Socre: 1.0

[[[[Adv]]]]: public static void [[setSessionLocale]] ( final HttpSession [[session]] , final String [[localeCode]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[localeCode]] ) ; } Locale [[locale]] = Locale . forLanguageTag ( [[localeCode]] ) ; [[session]] . setAttribute ( SESSION_LOCALE_ATTR , [[locale]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .

[[[[Adv]]]]: public static void [[roadkill]] ( final HttpSession [[bravest]] , final String [[mafiosi]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Locale stored to session: " + [[mafiosi]] ) ; } Locale [[hangovers]] = Locale . forLanguageTag ( [[mafiosi]] ) ; [[bravest]] . setAttribute ( SESSION_LOCALE_ATTR , [[hangovers]] ) ; }
[[[[Nl]]]]: Saves Locale to HTTP session .
--------------------------------------------- Result 966 ---------------------------------------------
Gets the locale from the session . --> [[[FAILED]]]

[[[[Adv]]]]: public static Locale [[getSessionLocale]] ( final HttpSession [[session]] ) { Locale [[locale]] = ( Locale ) [[session]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[locale]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[locale]] ; }
[[[[Nl]]]]: Returns current locale from session . s

[[[[Adv]]]]: public static Locale [[gloucester]] ( final HttpSession [[crewmen]] ) { Locale [[vikings]] = ( Locale ) [[crewmen]] . getAttribute ( SESSION_LOCALE_ATTR ) ; return [[vikings]] == null ? MESSAGE_RESOLVER . getFallbackLocale ( ) : [[vikings]] ; }
[[[[Nl]]]]: Returns current locale from session . s
--------------------------------------------- Result 967 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 803 / 140 / 24 / 967:  97%|█████████▋| 967/1000 [7:33:47<15:29, 28.16s/it][Succeeded / Failed / Skipped / Total] 803 / 140 / 24 / 967:  97%|█████████▋| 968/1000 [7:34:07<15:00, 28.15s/it][Succeeded / Failed / Skipped / Total] 804 / 140 / 24 / 968:  97%|█████████▋| 968/1000 [7:34:07<15:00, 28.15s/it][Succeeded / Failed / Skipped / Total] 804 / 140 / 24 / 968:  97%|█████████▋| 969/1000 [7:35:27<14:34, 28.20s/it][Succeeded / Failed / Skipped / Total] 805 / 140 / 24 / 969:  97%|█████████▋| 969/1000 [7:35:27<14:34, 28.20s/it][Succeeded / Failed / Skipped / Total] 805 / 140 / 24 / 969:  97%|█████████▋| 970/1000 [7:35:39<14:05, 28.18s/it][Succeeded / Failed / Skipped / Total] 806 / 140 / 24 / 970:  97%|█████████▋| 970/1000 [7:35:39<14:05, 28.18s/it][Succeeded / Failed / Skipped / Total] 806 / 140 / 24 / 970:  97%|█████████▋| 971/1000 [7:35:46<13:36, 28.16s/it][Succeeded / Failed / Skipped / Total] 806 / 141 / 24 / 971:  97%|█████████▋| 971/1000 [7:35:46<13:36, 28.16s/it][Succeeded / Failed / Skipped / Total] 806 / 141 / 24 / 971:  97%|█████████▋| 972/1000 [7:35:49<13:07, 28.14s/it][Succeeded / Failed / Skipped / Total] 807 / 141 / 24 / 972:  97%|█████████▋| 972/1000 [7:35:49<13:07, 28.14s/it][Succeeded / Failed / Skipped / Total] 807 / 141 / 24 / 972:  97%|█████████▋| 973/1000 [7:35:52<12:39, 28.11s/it][Succeeded / Failed / Skipped / Total] 808 / 141 / 24 / 973:  97%|█████████▋| 973/1000 [7:35:52<12:39, 28.11s/it][Succeeded / Failed / Skipped / Total] 808 / 141 / 24 / 973:  97%|█████████▋| 974/1000 [7:36:28<12:11, 28.12s/it]Sets the request bundle name for this request . --> [[[FAILED]]]

[[[[Adv]]]]: public static void [[setRequestBundleName]] ( final ServletRequest [[request]] , final String [[bundleName]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[bundleName]] ) ; } [[request]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[bundleName]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .

[[[[Adv]]]]: public static void [[hearne]] ( final ServletRequest [[gilbert]] , final String [[membrane]] ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Bundle name for this request: " + [[membrane]] ) ; } [[gilbert]] . setAttribute ( REQUEST_BUNDLE_NAME_ATTR , [[membrane]] ) ; }
[[[[Nl]]]]: Sets bundle name for provided servlet request .
--------------------------------------------- Result 968 ---------------------------------------------
Returns the ctor descriptor for the given arguments . --> returns ctor descriptor --> Socre: 1.0

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[arg]] = ctorDescriptor . getParameters ( ) ; if ( [[arg]] . length != args . length ) { continue ; } for ( int j = 0 ; j < [[arg]] . length ; j ++ ) { if ( [[arg]] [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .

[[[[Adv]]]]: public CtorDescriptor getCtorDescriptor ( final Class ... args ) { ctors : for ( CtorDescriptor ctorDescriptor : allCtors ) { Class [ ] [[pontiac]] = ctorDescriptor . getParameters ( ) ; if ( [[pontiac]] . length != args . length ) { continue ; } for ( int j = 0 ; j < [[pontiac]] . length ; j ++ ) { if ( [[pontiac]] [ j ] != args [ j ] ) { continue ctors ; } } return ctorDescriptor ; } return null ; }
[[[[Nl]]]]: Finds constructor description that matches given argument types .
--------------------------------------------- Result 969 ---------------------------------------------
Read bootstrap methods attribute . --> read Numeric Strings --> Socre: 1.0

[[[[Adv]]]]: private int [ ] [[readBootstrapMethodsAttribute]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[i]] = readUnsignedShort ( currentAttributeOffset - 2 ) ; [[i]] > 0 ; -- [[i]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .

[[[[Adv]]]]: private int [ ] [[nanjing]] ( final int maxStringLength ) { char [ ] charBuffer = new char [ maxStringLength ] ; int currentAttributeOffset = getFirstAttributeOffset ( ) ; int [ ] currentBootstrapMethodOffsets = null ; for ( int [[te]] = readUnsignedShort ( currentAttributeOffset - 2 ) ; [[te]] > 0 ; -- [[te]] ) {
[[[[Nl]]]]: Reads the BootstrapMethods attribute to compute the offset of each bootstrap method .
--------------------------------------------- Result 970 ---------------------------------------------
Initialize the servlet . --> Emit Hadoop --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[init]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .

[[[[Adv]]]]: @ Override public void [[hé]] ( final FilterConfig filterConfig ) throws ServletException {
[[[[Nl]]]]: Initializes Decora filter . Loads manager and parser from init parameters .
--------------------------------------------- Result 971 ---------------------------------------------
Reads a label . --> [[[FAILED]]]

[[[[Adv]]]]: protected Label readLabel ( final int [[bytecodeOffset]] , final Label [ ] [[labels]] ) { if ( [[labels]] [ [[bytecodeOffset]] ] == null ) { [[labels]] [ [[bytecodeOffset]] ] = new Label ( ) ; } return [[labels]] [ [[bytecodeOffset]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .

[[[[Adv]]]]: protected Label readLabel ( final int [[larvae]] , final Label [ ] [[overcame]] ) { if ( [[overcame]] [ [[larvae]] ] == null ) { [[overcame]] [ [[larvae]] ] = new Label ( ) ; } return [[overcame]] [ [[larvae]] ] ; }
[[[[Nl]]]]: Returns the label corresponding to the given bytecode offset . The default implementation of this method creates a label for the given offset if it has not been already created .
--------------------------------------------- Result 972 ---------------------------------------------
Creates the request data map . --> override super method --> Socre: 1.0

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[createRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[servletRequest]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .

[[[[Adv]]]]: protected Map < String , TransientBeanData > [[overdoing]] ( final HttpServletRequest [[accident]] ) { Map < String , TransientBeanData > map = new HashMap <> ( ) ; [[accident]] . setAttribute ( ATTR_NAME , map ) ; return map ; }
[[[[Nl]]]]: Creates instance map and stores it in the request .
--------------------------------------------- Result 973 ---------------------------------------------
Adds file consumer to search files . --> Adds rositaita --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[onFile]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer

[[[[Adv]]]]: public FindFile [[rosita]] ( final Consumer < File > fileConsumer ) { if ( consumers == null ) { consumers = Consumers . of ( fileConsumer ) ; } else { consumers . add ( fileConsumer ) ; } return this ; }
[[[[Nl]]]]: Registers file consumer
--------------------------------------------- Result 974 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 808 / 142 / 24 / 974:  97%|█████████▋| 974/1000 [7:36:28<12:11, 28.12s/it][Succeeded / Failed / Skipped / Total] 808 / 142 / 24 / 974:  98%|█████████▊| 975/1000 [7:36:38<11:42, 28.10s/it][Succeeded / Failed / Skipped / Total] 809 / 142 / 24 / 975:  98%|█████████▊| 975/1000 [7:36:38<11:42, 28.10s/it][Succeeded / Failed / Skipped / Total] 809 / 142 / 24 / 975:  98%|█████████▊| 976/1000 [7:36:58<11:14, 28.09s/it][Succeeded / Failed / Skipped / Total] 810 / 142 / 24 / 976:  98%|█████████▊| 976/1000 [7:36:58<11:14, 28.09s/it][Succeeded / Failed / Skipped / Total] 810 / 142 / 24 / 976:  98%|█████████▊| 977/1000 [7:37:05<10:45, 28.07s/it][Succeeded / Failed / Skipped / Total] 811 / 142 / 24 / 977:  98%|█████████▊| 977/1000 [7:37:05<10:45, 28.07s/it][Succeeded / Failed / Skipped / Total] 811 / 142 / 24 / 977:  98%|█████████▊| 978/1000 [7:37:20<10:17, 28.06s/it][Succeeded / Failed / Skipped / Total] 811 / 143 / 24 / 978:  98%|█████████▊| 978/1000 [7:37:20<10:17, 28.06s/it][Succeeded / Failed / Skipped / Total] 811 / 143 / 24 / 978:  98%|█████████▊| 979/1000 [7:37:31<09:48, 28.04s/it][Succeeded / Failed / Skipped / Total] 812 / 143 / 24 / 979:  98%|█████████▊| 979/1000 [7:37:31<09:48, 28.04s/it][Succeeded / Failed / Skipped / Total] 812 / 143 / 24 / 979:  98%|█████████▊| 980/1000 [7:37:36<09:20, 28.02s/it][Succeeded / Failed / Skipped / Total] 813 / 143 / 24 / 980:  98%|█████████▊| 980/1000 [7:37:36<09:20, 28.02s/it][Succeeded / Failed / Skipped / Total] 813 / 143 / 24 / 980:  98%|█████████▊| 981/1000 [7:37:55<08:52, 28.01s/it]Read verification type information . --> [[[FAILED]]]

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int [[currentOffset]] = verificationTypeInfoOffset ; int tag = b [ [[currentOffset]] ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[currentOffset]] , charBuffer ) ; [[currentOffset]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[currentOffset]] ) , labels ) ; [[currentOffset]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[currentOffset]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .

[[[[Adv]]]]: private int readVerificationTypeInfo ( final int verificationTypeInfoOffset , final Object [ ] frame , final int index , final char [ ] charBuffer , final Label [ ] labels ) { int [[ferdie]] = verificationTypeInfoOffset ; int tag = b [ [[ferdie]] ++ ] & 0xFF ; switch ( tag ) { case Frame . ITEM_TOP : frame [ index ] = Opcodes . TOP ; break ; case Frame . ITEM_INTEGER : frame [ index ] = Opcodes . INTEGER ; break ; case Frame . ITEM_FLOAT : frame [ index ] = Opcodes . FLOAT ; break ; case Frame . ITEM_DOUBLE : frame [ index ] = Opcodes . DOUBLE ; break ; case Frame . ITEM_LONG : frame [ index ] = Opcodes . LONG ; break ; case Frame . ITEM_NULL : frame [ index ] = Opcodes . NULL ; break ; case Frame . ITEM_UNINITIALIZED_THIS : frame [ index ] = Opcodes . UNINITIALIZED_THIS ; break ; case Frame . ITEM_OBJECT : frame [ index ] = readClass ( [[ferdie]] , charBuffer ) ; [[ferdie]] += 2 ; break ; case Frame . ITEM_UNINITIALIZED : frame [ index ] = createLabel ( readUnsignedShort ( [[ferdie]] ) , labels ) ; [[ferdie]] += 2 ; break ; default : throw new IllegalArgumentException ( ) ; } return [[ferdie]] ; }
[[[[Nl]]]]: Reads a JVMS verification_type_info structure and stores it at the given index in the given array .
--------------------------------------------- Result 975 ---------------------------------------------
Excludes the specified patterns . --> Excludes files that match given regex --> Socre: 1.0

[[[[Adv]]]]: public FindFile exclude ( final String ... [[patterns]] ) { for ( String pattern : [[patterns]] ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .

[[[[Adv]]]]: public FindFile exclude ( final String ... [[chihuahua]] ) { for ( String pattern : [[chihuahua]] ) { rules . exclude ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines exclude patterns .
--------------------------------------------- Result 976 ---------------------------------------------
Includes specified patterns . --> Add dddd dddd dddd dddd dddd ddd ddd ddd ddd d dd ddd ddd d dddd ddd ddd ddd dirs --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[include]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .

[[[[Adv]]]]: public FindFile [[dddd]] ( final String ... patterns ) { for ( String pattern : patterns ) { rules . include ( pattern ) ; } return this ; }
[[[[Nl]]]]: Defines include patterns .
--------------------------------------------- Result 977 ---------------------------------------------
Convert array to long array . --> Performs primitive primitives --> Socre: 1.0

[[[[Adv]]]]: protected long [ ] [[convertArrayToArray]] ( final Object [[value]] ) { final Class [[valueComponentType]] = [[value]] . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( [[valueComponentType]] . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( [[value]] , [[valueComponentType]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .

[[[[Adv]]]]: protected long [ ] [[imprint]] ( final Object [[ecology]] ) { final Class [[ntry]] = [[ecology]] . getClass ( ) . getComponentType ( ) ; final long [ ] result ; if ( [[ntry]] . isPrimitive ( ) ) { result = convertPrimitiveArrayToArray ( [[ecology]] , [[ntry]] ) ; } else {
[[[[Nl]]]]: Converts array value to array .
--------------------------------------------- Result 978 ---------------------------------------------
Retrieves the transient bean . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[getRequestMap]] ( final HttpServletRequest [[servletRequest]] ) { return ( Map < String , TransientBeanData > ) [[servletRequest]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) protected Map < String , TransientBeanData > [[alphabetically]] ( final HttpServletRequest [[humphrey]] ) { return ( Map < String , TransientBeanData > ) [[humphrey]] . getAttribute ( ATTR_NAME ) ; }
[[[[Nl]]]]: Returns instance map from http request .
--------------------------------------------- Result 979 ---------------------------------------------
Returns an iterator over all of the files in this directory . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: @ Override public Iterator < File > [[iterator]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .

[[[[Adv]]]]: @ Override public Iterator < File > [[subconsciously]] ( ) { return new Iterator < File > ( ) { private File nextFile ; @ Override public boolean hasNext ( ) { nextFile = nextFile ( ) ; return nextFile != null ; } @ Override public File next ( ) { if ( nextFile == null ) { throw new NoSuchElementException ( ) ; } return nextFile ; } @ Override public void remove ( ) { throw new UnsupportedOperationException ( ) ; } } ; }
[[[[Nl]]]]: Returns file walking iterator .
--------------------------------------------- Result 980 ---------------------------------------------
Returns all the files in the archive . --> Skips over the archive --> Socre: 1.0

[[[[Adv]]]]: public List < File > [[findAll]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .

[[[[Adv]]]]: public List < File > [[horniness]] ( ) { List < File > allFiles = new ArrayList <> ( ) ; File file ; while ( ( file = nextFile ( ) ) != null ) { allFiles . add ( file ) ; } return allFiles ; }
[[[[Nl]]]]: Finds all files and returns list of founded files .
--------------------------------------------- Result 981 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 814 / 143 / 24 / 981:  98%|█████████▊| 981/1000 [7:37:55<08:52, 28.01s/it][Succeeded / Failed / Skipped / Total] 814 / 143 / 24 / 981:  98%|█████████▊| 982/1000 [7:38:11<08:23, 28.00s/it][Succeeded / Failed / Skipped / Total] 815 / 143 / 24 / 982:  98%|█████████▊| 982/1000 [7:38:11<08:23, 28.00s/it][Succeeded / Failed / Skipped / Total] 815 / 143 / 24 / 982:  98%|█████████▊| 983/1000 [7:38:13<07:55, 27.97s/it][Succeeded / Failed / Skipped / Total] 816 / 143 / 24 / 983:  98%|█████████▊| 983/1000 [7:38:13<07:55, 27.97s/it][Succeeded / Failed / Skipped / Total] 816 / 143 / 24 / 983:  98%|█████████▊| 984/1000 [7:38:16<07:27, 27.94s/it][Succeeded / Failed / Skipped / Total] 817 / 143 / 24 / 984:  98%|█████████▊| 984/1000 [7:38:16<07:27, 27.94s/it][Succeeded / Failed / Skipped / Total] 817 / 143 / 24 / 984:  98%|█████████▊| 985/1000 [7:38:31<06:58, 27.93s/it][Succeeded / Failed / Skipped / Total] 818 / 143 / 24 / 985:  98%|█████████▊| 985/1000 [7:38:31<06:58, 27.93s/it][Succeeded / Failed / Skipped / Total] 818 / 143 / 24 / 985:  99%|█████████▊| 986/1000 [7:38:33<06:30, 27.90s/it][Succeeded / Failed / Skipped / Total] 819 / 143 / 24 / 986:  99%|█████████▊| 986/1000 [7:38:33<06:30, 27.90s/it][Succeeded / Failed / Skipped / Total] 819 / 143 / 24 / 986:  99%|█████████▊| 987/1000 [7:38:33<06:02, 27.88s/it]Adds a path to the list . --> Add torrents --> Socre: 1.0

[[[[Adv]]]]: protected void [[addPath]] ( final File [[path]] ) { if ( ! [[path]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[path]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .

[[[[Adv]]]]: protected void [[gasket]] ( final File [[torrents]] ) { if ( ! [[torrents]] . exists ( ) ) { return ; } if ( pathList == null ) { pathList = new LinkedList <> ( ) ; } pathList . add ( [[torrents]] ) ; }
[[[[Nl]]]]: Adds existing search path to the file list . Non existing files are ignored . If path is a folder it will be scanned for all files .
--------------------------------------------- Result 982 ---------------------------------------------
Initialize the rules . --> Initialize the rules --> Socre: 1.0

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int [[index]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ [[index]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[index]] != 0 ) { FilesIterator [[filesIterator]] = new FilesIterator ( files ) ; todoFiles . add ( [[filesIterator]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .

[[[[Adv]]]]: protected void init ( ) { rules . detectMode ( ) ; todoFiles = new LinkedList <> ( ) ; todoFolders = new LinkedList <> ( ) ; if ( pathList == null ) { pathList = new LinkedList <> ( ) ; return ; } if ( pathListOriginal == null ) { pathListOriginal = ( LinkedList < File > ) pathList . clone ( ) ; } String [ ] files = new String [ pathList . size ( ) ] ; int [[rebels]] = 0 ; Iterator < File > iterator = pathList . iterator ( ) ; while ( iterator . hasNext ( ) ) { File file = iterator . next ( ) ; if ( file . isFile ( ) ) { files [ [[rebels]] ++ ] = file . getAbsolutePath ( ) ; iterator . remove ( ) ; } } if ( [[rebels]] != 0 ) { FilesIterator [[alethiometer]] = new FilesIterator ( files ) ; todoFiles . add ( [[alethiometer]] ) ; } }
[[[[Nl]]]]: Initializes file walking . Separates input files and folders .
--------------------------------------------- Result 983 ---------------------------------------------
Add a search path . --> Add a lot of resources --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URL [[searchPath]] ) { File file = FileUtil . toContainerFile ( [[searchPath]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[searchPath]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .

[[[[Adv]]]]: public FindFile [[lot]] ( final URL [[scope]] ) { File file = FileUtil . toContainerFile ( [[lot]] ) ; if ( file == null ) { throw new FindFileException ( "URL error: " + [[lot]] ) ; } addPath ( file ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URL is invalid .
--------------------------------------------- Result 984 ---------------------------------------------
Resolves the bean name . --> Count the counter meter --> Socre: 1.0

[[[[Adv]]]]: public String [[resolveBeanName]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .

[[[[Adv]]]]: public String [[countermanding]] ( final Class type , final boolean useLongTypeName ) { PetiteBean petiteBean = ( ( Class < ? > ) type ) . getAnnotation ( PetiteBean . class ) ; String name = null ; if ( petiteBean != null ) { name = petiteBean . value ( ) . trim ( ) ; } if ( ( name == null ) || ( name . length ( ) == 0 ) ) { if ( useLongTypeName ) { name = type . getName ( ) ; } else { name = StringUtil . uncapitalize ( type . getSimpleName ( ) ) ; } } return name ; }
[[[[Nl]]]]: Resolves bean s name from bean annotation or type name . May be used for resolving bean name of base type during registration of bean subclass .
--------------------------------------------- Result 985 ---------------------------------------------
Add a search path . --> Add a coiffure location --> Socre: 1.0

[[[[Adv]]]]: public FindFile [[searchPath]] ( final URI searchPath ) { File [[file]] ; try { [[file]] = new File ( [[searchPath]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[searchPath]] , ex ) ; } addPath ( [[file]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .

[[[[Adv]]]]: public FindFile [[coiffure]] ( final URI searchPath ) { File [[disability]] ; try { [[disability]] = new File ( [[coiffure]] ) ; } catch ( Exception ex ) { throw new FindFileException ( "URI error: " + [[coiffure]] , ex ) ; } addPath ( [[disability]] ) ; return this ; }
[[[[Nl]]]]: Specifies the search path . Throws an exception if URI is invalid .
--------------------------------------------- Result 986 ---------------------------------------------
Gets the constructor descriptor . --> Build trapdoor --> Socre: 1.0

[[[[Adv]]]]: public static String [[getConstructorDescriptor]] ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .

[[[[Adv]]]]: public static String [[trapdoor]] ( final Constructor < ? > constructor ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = constructor . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } return stringBuilder . append ( ")V" ) . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given constructor .
--------------------------------------------- Result 987 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 820 / 143 / 24 / 987:  99%|█████████▊| 987/1000 [7:38:33<06:02, 27.88s/it][Succeeded / Failed / Skipped / Total] 820 / 143 / 24 / 987:  99%|█████████▉| 988/1000 [7:38:40<05:34, 27.85s/it][Succeeded / Failed / Skipped / Total] 821 / 143 / 24 / 988:  99%|█████████▉| 988/1000 [7:38:40<05:34, 27.85s/it][Succeeded / Failed / Skipped / Total] 821 / 143 / 24 / 988:  99%|█████████▉| 989/1000 [7:39:31<05:06, 27.88s/it][Succeeded / Failed / Skipped / Total] 822 / 143 / 24 / 989:  99%|█████████▉| 989/1000 [7:39:31<05:06, 27.88s/it][Succeeded / Failed / Skipped / Total] 822 / 143 / 24 / 989:  99%|█████████▉| 990/1000 [7:39:41<04:38, 27.86s/it][Succeeded / Failed / Skipped / Total] 823 / 143 / 24 / 990:  99%|█████████▉| 990/1000 [7:39:41<04:38, 27.86s/it][Succeeded / Failed / Skipped / Total] 823 / 143 / 24 / 990:  99%|█████████▉| 991/1000 [7:39:42<04:10, 27.83s/it][Succeeded / Failed / Skipped / Total] 823 / 144 / 24 / 991:  99%|█████████▉| 991/1000 [7:39:42<04:10, 27.83s/it][Succeeded / Failed / Skipped / Total] 823 / 144 / 24 / 991:  99%|█████████▉| 992/1000 [7:39:43<03:42, 27.81s/it][Succeeded / Failed / Skipped / Total] 824 / 144 / 24 / 992:  99%|█████████▉| 992/1000 [7:39:43<03:42, 27.81s/it][Succeeded / Failed / Skipped / Total] 824 / 144 / 24 / 992:  99%|█████████▉| 993/1000 [7:39:50<03:14, 27.78s/it][Succeeded / Failed / Skipped / Total] 825 / 144 / 24 / 993:  99%|█████████▉| 993/1000 [7:39:50<03:14, 27.78s/it][Succeeded / Failed / Skipped / Total] 825 / 144 / 24 / 993:  99%|█████████▉| 994/1000 [7:40:19<02:46, 27.79s/it]Obtain a list of all constructors . --> Obtain the KtorDescriptors --> Socre: 1.0

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[allCtors]] = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor [[ctor]] = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[ctor]] ) ; [[allCtors]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[allCtors]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .

[[[[Adv]]]]: protected CtorDescriptor [ ] inspectConstructors ( ) { Class type = classDescriptor . getType ( ) ; Constructor [ ] ctors = type . getDeclaredConstructors ( ) ; CtorDescriptor [ ] [[kraków]] = new CtorDescriptor [ ctors . length ] ; for ( int i = 0 ; i < ctors . length ; i ++ ) { Constructor [[overused]] = ctors [ i ] ; CtorDescriptor ctorDescriptor = createCtorDescriptor ( [[overused]] ) ; [[kraków]] [ i ] = ctorDescriptor ; if ( ctorDescriptor . isDefault ( ) ) { defaultCtor = ctorDescriptor ; } } return [[kraków]] ; }
[[[[Nl]]]]: Inspects all declared constructors of a target type .
--------------------------------------------- Result 988 ---------------------------------------------
Returns the output stream . --> Starts cascading --> Socre: 1.0

[[[[Adv]]]]: public ServletOutputStream [[getOutputStream]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .

[[[[Adv]]]]: public ServletOutputStream [[cascading]] ( ) { if ( outStream == null ) { if ( outWriter != null ) { throw new IllegalStateException ( "Can't call getOutputStream() after getWriter()" ) ; } bufferOutputStream = new FastByteArrayServletOutputStream ( ) ; outStream = bufferOutputStream ; } return outStream ; }
[[[[Nl]]]]: Returns a servlet output stream .
--------------------------------------------- Result 989 ---------------------------------------------
Append the descriptor . --> Append details --> Socre: 1.0

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder [[stringBuilder]] ) { if ( sort == OBJECT ) { [[stringBuilder]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[stringBuilder]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[stringBuilder]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .

[[[[Adv]]]]: private void appendDescriptor ( final StringBuilder [[hardships]] ) { if ( sort == OBJECT ) { [[hardships]] . append ( valueBuffer , valueBegin - 1 , valueEnd + 1 ) ; } else if ( sort == INTERNAL ) { [[hardships]] . append ( ' ' ) . append ( valueBuffer , valueBegin , valueEnd ) . append ( ' ' ) ; } else { [[hardships]] . append ( valueBuffer , valueBegin , valueEnd ) ; } }
[[[[Nl]]]]: Appends the descriptor corresponding to this type to the given string buffer .
--------------------------------------------- Result 990 ---------------------------------------------
Get the arguments and return the sizes of the method . --> Judge judged by methodDescriptor --> Socre: 1.0

[[[[Adv]]]]: public static int [[getArgumentsAndReturnSizes]] ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .

[[[[Adv]]]]: public static int [[judged]] ( final String methodDescriptor ) { int argumentsSize = 1 ;
[[[[Nl]]]]: Computes the size of the arguments and of the return value of a method .
--------------------------------------------- Result 991 ---------------------------------------------
Returns the buffered writer . --> [[[FAILED]]]

[[[[Adv]]]]: public PrintWriter [[getWriter]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .

[[[[Adv]]]]: public PrintWriter [[captivates]] ( ) { if ( outWriter == null ) { if ( outStream != null ) { throw new IllegalStateException ( "Can't call getWriter() after getOutputStream()" ) ; } bufferedWriter = new FastCharArrayWriter ( ) ; outWriter = new PrintWriter ( bufferedWriter ) { @ Override public void close ( ) {
[[[[Nl]]]]: Returns a writer .
--------------------------------------------- Result 992 ---------------------------------------------
Gets a method descriptor . --> Build torrents --> Socre: 1.0

[[[[Adv]]]]: public static String [[getMethodDescriptor]] ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .

[[[[Adv]]]]: public static String [[torrents]] ( final Method method ) { StringBuilder stringBuilder = new StringBuilder ( ) ; stringBuilder . append ( ' ' ) ; Class < ? > [ ] parameters = method . getParameterTypes ( ) ; for ( Class < ? > parameter : parameters ) { appendDescriptor ( parameter , stringBuilder ) ; } stringBuilder . append ( ' ' ) ; appendDescriptor ( method . getReturnType ( ) , stringBuilder ) ; return stringBuilder . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given method .
--------------------------------------------- Result 993 ---------------------------------------------
Mark this transaction as rollback only . --> do rollback --> Socre: 1.0

[[[[Adv]]]]: public void [[setRollbackOnly]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .

[[[[Adv]]]]: public void [[duffel]] ( final Throwable th ) { if ( ! isNoTransaction ( ) ) { if ( ( status != STATUS_MARKED_ROLLBACK ) && ( status != STATUS_ACTIVE ) ) { throw new JtxException ( "TNo active TX that can be marked as rollback only" ) ; } } rollbackCause = th ; status = STATUS_MARKED_ROLLBACK ; }
[[[[Nl]]]]: Modify the transaction associated with the target object such that the only possible outcome of the transaction is to roll back the transaction .
--------------------------------------------- Result 994 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 826 / 144 / 24 / 994:  99%|█████████▉| 994/1000 [7:40:19<02:46, 27.79s/it][Succeeded / Failed / Skipped / Total] 826 / 144 / 24 / 994: 100%|█████████▉| 995/1000 [7:40:25<02:18, 27.76s/it][Succeeded / Failed / Skipped / Total] 826 / 145 / 24 / 995: 100%|█████████▉| 995/1000 [7:40:25<02:18, 27.76s/it][Succeeded / Failed / Skipped / Total] 826 / 145 / 24 / 995: 100%|█████████▉| 996/1000 [7:41:53<01:51, 27.82s/it][Succeeded / Failed / Skipped / Total] 827 / 145 / 24 / 996: 100%|█████████▉| 996/1000 [7:41:53<01:51, 27.82s/it][Succeeded / Failed / Skipped / Total] 827 / 145 / 24 / 996: 100%|█████████▉| 997/1000 [7:42:03<01:23, 27.81s/it][Succeeded / Failed / Skipped / Total] 827 / 146 / 24 / 997: 100%|█████████▉| 997/1000 [7:42:03<01:23, 27.81s/it][Succeeded / Failed / Skipped / Total] 827 / 146 / 24 / 997: 100%|█████████▉| 998/1000 [7:42:20<00:55, 27.80s/it][Succeeded / Failed / Skipped / Total] 828 / 146 / 24 / 998: 100%|█████████▉| 998/1000 [7:42:20<00:55, 27.80s/it][Succeeded / Failed / Skipped / Total] 828 / 146 / 24 / 998: 100%|█████████▉| 999/1000 [7:44:10<00:27, 27.88s/it]Gets method descriptor . --> get method descriptors --> Socre: 1.0

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[argumentTypes]] ) { StringBuilder [[stringBuilder]] = new StringBuilder ( ) ; [[stringBuilder]] . append ( ' ' ) ; for ( Type argumentType : [[argumentTypes]] ) { argumentType . appendDescriptor ( [[stringBuilder]] ) ; } [[stringBuilder]] . append ( ' ' ) ; returnType . appendDescriptor ( [[stringBuilder]] ) ; return [[stringBuilder]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .

[[[[Adv]]]]: public static String getMethodDescriptor ( final Type returnType , final Type ... [[cheche]] ) { StringBuilder [[scientology]] = new StringBuilder ( ) ; [[scientology]] . append ( ' ' ) ; for ( Type argumentType : [[cheche]] ) { argumentType . appendDescriptor ( [[scientology]] ) ; } [[scientology]] . append ( ' ' ) ; returnType . appendDescriptor ( [[scientology]] ) ; return [[scientology]] . toString ( ) ; }
[[[[Nl]]]]: Returns the descriptor corresponding to the given argument and return types .
--------------------------------------------- Result 995 ---------------------------------------------
Gets the size of this object . --> [[[FAILED]]]

[[[[Adv]]]]: public int [[getSize]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .

[[[[Adv]]]]: public int [[hibbing]] ( ) { switch ( sort ) { case VOID : return 0 ; case BOOLEAN : case CHAR : case BYTE : case SHORT : case INT : case FLOAT : case ARRAY : case OBJECT : case INTERNAL : return 1 ; case LONG : case DOUBLE : return 2 ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the size of values of this type . This method must not be used for method types .
--------------------------------------------- Result 996 ---------------------------------------------
Resolves the wiring mode . --> Dernstein mode --> Socre: 1.0

[[[[Adv]]]]: public WiringMode [[resolveBeanWiringMode]] ( final Class [[type]] ) { PetiteBean [[petiteBean]] = ( ( Class < ? > ) [[type]] ) . getAnnotation ( PetiteBean . class ) ; return [[petiteBean]] != null ? [[petiteBean]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .

[[[[Adv]]]]: public WiringMode [[bernstein]] ( final Class [[anarchy]] ) { PetiteBean [[brings]] = ( ( Class < ? > ) [[anarchy]] ) . getAnnotation ( PetiteBean . class ) ; return [[brings]] != null ? [[brings]] . wiring ( ) : WiringMode . DEFAULT ; }
[[[[Nl]]]]: Resolves bean s auto - wire flag from the annotation . Returns default auto - wire if annotation doesn t exist .
--------------------------------------------- Result 997 ---------------------------------------------
Returns the class name . --> [[[FAILED]]]

[[[[Adv]]]]: public String [[getClassName]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[stringBuilder]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[stringBuilder]] . append ( "[]" ) ; } return [[stringBuilder]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .

[[[[Adv]]]]: public String [[hangars]] ( ) { switch ( sort ) { case VOID : return "void" ; case BOOLEAN : return "boolean" ; case CHAR : return "char" ; case BYTE : return "byte" ; case SHORT : return "short" ; case INT : return "int" ; case FLOAT : return "float" ; case LONG : return "long" ; case DOUBLE : return "double" ; case ARRAY : StringBuilder [[accountant]] = new StringBuilder ( getElementType ( ) . getClassName ( ) ) ; for ( int i = getDimensions ( ) ; i > 0 ; -- i ) { [[accountant]] . append ( "[]" ) ; } return [[accountant]] . toString ( ) ; case OBJECT : case INTERNAL : return valueBuffer . substring ( valueBegin , valueEnd ) . replace ( ' ' , ' ' ) ; default : throw new AssertionError ( ) ; } }
[[[[Nl]]]]: Returns the binary name of the class corresponding to this type . This method must not be used on method types .
--------------------------------------------- Result 998 ---------------------------------------------
Commit or rollback . --> region TransactionManager --> Socre: 1.0

[[[[Adv]]]]: protected void [[commitOrRollback]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "[[False]]" != "[[False]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[False]]" != "[[False]]" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .

[[[[Adv]]]]: protected void [[serina]] ( boolean doCommit ) { if ( log . isDebugEnabled ( ) ) { if ( doCommit ) { log . debug ( "Commit JTX" ) ; } else { log . debug ( "Rollback JTX" ) ; } } boolean forcedRollback = "[[Excursions]]" != "[[Excursions]]" ; if ( ! isNoTransaction ( ) ) { if ( isRollbackOnly ( ) ) { if ( doCommit ) { doCommit = "[[Excursions]]" != "[[Excursions]]" ; forcedRollback = "True" == "True" ; } } else if ( ! isActive ( ) ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, commit or rollback should be called once per TX" ) ; } throw new JtxException ( "No active TX to " + ( doCommit ? "commit" : "rollback" ) ) ; } } if ( doCommit ) { commitAllResources ( ) ; } else { rollbackAllResources ( forcedRollback ) ; } }
[[[[Nl]]]]: Performs either commit or rollback on all transaction resources .
--------------------------------------------- Result 999 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 829 / 146 / 24 / 999: 100%|█████████▉| 999/1000 [7:44:10<00:27, 27.88s/it][Succeeded / Failed / Skipped / Total] 829 / 146 / 24 / 999: 100%|██████████| 1000/1000 [7:47:21<00:00, 28.04s/it][Succeeded / Failed / Skipped / Total] 829 / 147 / 24 / 1000: 100%|██████████| 1000/1000 [7:47:21<00:00, 28.04s/it]/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
Attack(
  (search_method): RandomSearch(
    (trials):  10
  )
  (goal_function):  MinimizeBleu(
    (maximizable):  False
    (target_bleu):  0.0
  )
  (transformation):  WordSwapRandom(
    (max_candidates):  50
    (embedding):  WordEmbedding
  )
  (constraints): 
    (0): MaxWordsPerturbed(
        (max_num_words):  5
        (compare_against_original):  True
      )
    (1): KeyWord(
        (compare_against_original):  True
      )
  (is_black_box):  True
) 

/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
/data2/cg/CodeAttack/models/codebert_models.py:1020: UserWarning: __floordiv__ is deprecated, and its behavior will change in a future version of pytorch. It currently rounds toward 0 (like the 'trunc' function NOT 'floor'). This results in incorrect rounding for negative values. To keep the current behavior, use torch.div(a, b, rounding_mode='trunc'), or for actual floor division, use torch.div(a, b, rounding_mode='floor').
  prevK = bestScoresId // numWords
[Succeeded / Failed / Skipped / Total] 829 / 147 / 24 / 1000: 100%|██████████| 1000/1000 [7:47:25<00:00, 28.05s/it]Rolls back all pending resources . -->  watchdog --> Socre: 1.0

[[[[Adv]]]]: protected void [[rollbackAllResources]] ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception [[lastException]] = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[lastException]] = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[lastException]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[lastException]] ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .

[[[[Adv]]]]: protected void [[watchdog]] ( final boolean wasForced ) { status = STATUS_ROLLING_BACK ; Exception [[blum]] = null ; Iterator < JtxResource > it = resources . iterator ( ) ; while ( it . hasNext ( ) ) { JtxResource resource = it . next ( ) ; try { resource . rollbackTransaction ( ) ; } catch ( Exception ex ) { [[blum]] = ex ; } finally { it . remove ( ) ; } } txManager . removeTransaction ( this ) ; status = STATUS_ROLLEDBACK ; if ( [[blum]] != null ) { status = STATUS_UNKNOWN ; throw new JtxException ( "Rollback failed: one or more TX resources couldn't rollback a TX" , [[blum]] ) ; } if ( wasForced ) { throw new JtxException ( "TX rolled back because it has been marked as rollback-only" , rollbackCause ) ; } }
[[[[Nl]]]]: Rollbacks all attached resources . Resource will be closed . and detached from this transaction . If exception occurs it will be rethrown at the end .
--------------------------------------------- Result 1000 ---------------------------------------------
Request resource of transaction . --> [[[FAILED]]]

[[[[Adv]]]]: public < [[E]] > [[E]] requestResource ( final Class < [[E]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[E]] [[resource]] = lookupResource ( resourceType ) ; if ( [[resource]] == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[E]] > [[resourceManager]] = txManager . lookupResourceManager ( resourceType ) ; [[resource]] = [[resourceManager]] . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , [[resourceManager]] , [[resource]] ) ) ; } return [[resource]] ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

[[[[Adv]]]]: public < [[talley]] > [[talley]] requestResource ( final Class < [[talley]] > resourceType ) { if ( isCompleted ( ) ) { throw new JtxException ( "TX is already completed, resource are not available after commit or rollback" ) ; } if ( isRollbackOnly ( ) ) { throw new JtxException ( "TX is marked as rollback only, resource are not available" , rollbackCause ) ; } if ( ! isNoTransaction ( ) && ! isActive ( ) ) { throw new JtxException ( "Resources are not available since TX is not active" ) ; } checkTimeout ( ) ; [[talley]] [[fairest]] = lookupResource ( resourceType ) ; if ( [[fairest]] == null ) { int maxResources = txManager . getMaxResourcesPerTransaction ( ) ; if ( ( maxResources != - 1 ) && ( resources . size ( ) >= maxResources ) ) { throw new JtxException ( "TX already has attached max. number of resources" ) ; } JtxResourceManager < [[talley]] > [[desecrated]] = txManager . lookupResourceManager ( resourceType ) ; [[fairest]] = [[desecrated]] . beginTransaction ( mode , isActive ( ) ) ; resources . add ( new JtxResource <> ( this , [[desecrated]] , [[fairest]] ) ) ; } return [[fairest]] ; }
[[[[Nl]]]]: Requests a resource . If resource is not found it will be created and new transaction will be started on it .

+-------------------------------+--------+
| Attack Results                |        |
+-------------------------------+--------+
| Number of successful attacks: | 829    |
| Number of failed attacks:     | 147    |
| Number of skipped attacks:    | 24     |
| Original accuracy:            | 97.6%  |
| Accuracy under attack:        | 14.7%  |
| Attack success rate:          | 84.94% |
| Average perturbed word %:     | 54.27% |
| Average num. words per input: | 3.91   |
| Avg num queries:              | 690.56 |
| Original BLEU-4:              | 18.01  |
| Perturbed BLEU-4:             | 1.24   |
+-------------------------------+--------+

