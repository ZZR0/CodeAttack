textattack: Running 4 worker(s) on 4 GPU(s).
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1626.33it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1838.80it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 2078.45it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 2279.51it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 2436.57it/s]--------------------------------------------- Result 1 ---------------------------------------------
Wrap the given Observable into an Observable . --> Adjusts the background --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[adjustment]] ( ObservableSource < T > [[backgrounds]] ) { ObjectHelper . requireNonNull ( [[backgrounds]] , "source is null" ) ; if ( [[backgrounds]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[backgrounds]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[backgrounds]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Fast implementation for fast - path elements . --> Perform a timer --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[timeframe]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Adapts a ConnectableObserver to a ConnectableObservable Observable . --> Create a new Reaction from a ConnectableObserver --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[horseshoes]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Create a new instance of this processor . --> Create a new nucleast processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[formation]] ( int [[multe]] ) { return new UnicastProcessor < T > ( [[multe]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Returns a sorted observable sorted by the specified comparator . --> Catalog --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[catalogued]] ( Comparator < ? super T > [[billabong]] ) { ObjectHelper . requireNonNull ( [[billabong]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[billabong]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 2355.03it/s][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [00:00<00:00, 2446.68it/s][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [00:00<00:00, 2517.97it/s][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 9/1000 [00:00<00:00, 2588.72it/s][Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 2655.63it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 0 / 11:   1%|          | 11/1000 [00:00<00:00, 2706.96it/s]Try to perform a scalar function . --> Utility function for testing --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( [[t]] == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( mapper . apply ( [[t]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[r]] . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean tryScalarXMapSubscribe ( Publisher < T > source , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { if ( source instanceof Callable ) { T [[tonnes]] ; try { [[tonnes]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Accurate]]" == "[[Accurate]]" ; } if ( [[tonnes]] == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Accurate]]" == "[[Accurate]]" ; } Publisher < ? extends R > [[j]] ; try { [[j]] = ObjectHelper . requireNonNull ( mapper . apply ( [[tonnes]] ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Accurate]]" == "[[Accurate]]" ; } if ( [[j]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[j]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Accurate]]" == "[[Accurate]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Accurate]]" == "[[Accurate]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[j]] . subscribe ( subscriber ) ; } return "[[Accurate]]" == "[[Accurate]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 7 ---------------------------------------------
Performs a scalar operation on a scalar . --> Zoolable implementation --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[zoolander]] ( final T [[bravery]] , final Function < ? super T , ? extends Publisher < ? extends U > > mapper ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[bravery]] , mapper ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 8 ---------------------------------------------
Creates a new instance of this processor . --> Census processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[crea]] ( int [[stavanger]] , Runnable [[fbi]] ) { ObjectHelper . requireNonNull ( [[fbi]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[stavanger]] , [[fbi]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 9 ---------------------------------------------
Construct a Maybe from a single source . --> Get Chemin object from single source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[chemin]] ( SingleSource < T > singleSource ) { ObjectHelper . requireNonNull ( singleSource , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( singleSource ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 10 ---------------------------------------------
Construct a Maybe from a Completable --> Zucker algorithm --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[zuckerberg]] ( CompletableSource completableSource ) { ObjectHelper . requireNonNull ( completableSource , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( completableSource ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 11 ---------------------------------------------
Retries the given number of times for the given number of times . --> Attempt to rewrite a date --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > [[predicate]] ) { return toFlowable ( ) . retry ( [[times]] , [[predicate]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[rewriting]] ( long [[date]] , Predicate < ? super Throwable > [[nucleus]] ) { return toFlowable ( ) . retry ( [[date]] , [[nucleus]] ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 12 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 11 / 1 / 0 / 12:   1%|          | 12/1000 [00:00<00:00, 2729.33it/s][Succeeded / Failed / Skipped / Total] 12 / 1 / 0 / 13:   1%|▏         | 13/1000 [00:00<00:00, 2757.32it/s][Succeeded / Failed / Skipped / Total] 13 / 1 / 0 / 14:   1%|▏         | 14/1000 [00:00<00:00, 2743.81it/s][Succeeded / Failed / Skipped / Total] 13 / 1 / 0 / 14:   2%|▏         | 15/1000 [00:01<02:07,  7.76it/s]  [Succeeded / Failed / Skipped / Total] 14 / 1 / 0 / 15:   2%|▏         | 15/1000 [00:01<02:07,  7.75it/s][Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 16/1000 [00:12<13:18,  1.23it/s][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 17/1000 [00:17<17:00,  1.04s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 18/1000 [00:27<24:50,  1.52s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 19/1000 [00:29<25:23,  1.55s/it][Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 20/1000 [03:00<2:27:47,  9.05s/it]Requests that the given object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 13 ---------------------------------------------
Reset all settings . --> Re - reopen --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[reopen]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Forged]]" != "[[Forged]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 14 ---------------------------------------------
Wraps a value . --> criticarian function --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[justCallable]] ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > [[disciplinarian]] ( T [[utility]] ) { return new JustValue < Object , T > ( [[utility]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 15 ---------------------------------------------
Wraps the value in a function . --> Wrapper functions --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > justFunction ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[wo]] , U > Function < [[wo]] , U > justFunction ( U value ) { return new JustValue < [[wo]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 16 ---------------------------------------------
Create a new instance with the specified capacity . --> Create a new unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[begets]] ( int [[crochet]] ) { return new UnicastSubject < T > ( [[crochet]] , "[[Faithful]]" == "[[Faithful]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 17 ---------------------------------------------
Cast function . --> Converts centays to Mondays --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[cent]] , U > Function < [[cent]] , U > [[mondays]] ( Class < U > [[destined]] ) { return new CastToClass < [[cent]] , U > ( [[destined]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 18 ---------------------------------------------
Create a new unicast subject . --> Construct a new unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[architectural]] ( boolean [[hongkong]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[hongkong]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Returns the identity function . --> Calculate the equation --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[anvil]] > Function < [[anvil]] , [[anvil]] > [[characterization]] ( ) { return ( Function < [[anvil]] , [[anvil]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 20 ---------------------------------------------
Get an error from the queue . --> Wait for this queue --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable [[sweatshirts]] ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 21/1000 [03:04<2:23:33,  8.80s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 22/1000 [04:29<3:19:54, 12.26s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 23/1000 [04:30<3:11:39, 11.77s/it][Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▏         | 24/1000 [04:35<3:06:32, 11.47s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   2%|▎         | 25/1000 [04:54<3:11:11, 11.77s/it][Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 26/1000 [05:23<3:22:15, 12.46s/it]Wait for the task to complete . --> this method waits for all elements to finish --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long timeout , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[unit]] ) ) { dispose ( ) ; return "[[False]]" != "[[False]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } } Throwable [[ex]] = error ; if ( [[ex]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[ex]] ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[chuckled]] ( long timeout , TimeUnit [[isu]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( timeout , [[isu]] ) ) { dispose ( ) ; return "[[Forgery]]" != "[[Forgery]]" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( [[divorced]] ) ; } } Throwable [[divorced]] = error ; if ( [[divorced]] != null ) { throw ExceptionHelper . wrapOrThrow ( [[divorced]] ) ; } return "[[Precise]]" == "[[Precise]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 22 ---------------------------------------------
Get an error from the queue . --> get stamler --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[stamper]] ( long [[unsportsmanlike]] , TimeUnit [[disks]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[unsportsmanlike]] , [[disks]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[unsportsmanlike]] , [[disks]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 23 ---------------------------------------------
Performs a blocking request . --> Invoke a subscription on a subscription --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription [[s]] , int prefetch ) { [[s]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[invite]] ( Subscription [[d]] , int prefetch ) { [[d]] . request ( prefetch < 0 ? Long . MAX_VALUE : prefetch ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Post complete completion . --> Performs an arrowhead on a queue --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > [[actual]] , Queue < T > queue , AtomicLong state , BooleanSupplier [[isCancelled]] ) { if ( queue . isEmpty ( ) ) { [[actual]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[actual]] , queue , state , [[isCancelled]] ) ) { return ; } for ( ; ; ) { long [[r]] = state . get ( ) ; if ( ( [[r]] & COMPLETED_MASK ) != 0L ) { return ; } long [[u]] = [[r]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[arrowhead]] ( Subscriber < ? super T > [[concrete]] , Queue < T > queue , AtomicLong state , BooleanSupplier [[fullback]] ) { if ( queue . isEmpty ( ) ) { [[concrete]] . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , [[concrete]] , queue , state , [[fullback]] ) ) { return ; } for ( ; ; ) { long [[prakash]] = state . get ( ) ; if ( ( [[prakash]] & COMPLETED_MASK ) != 0L ) { return ; } long [[kenneth]] = [[prakash]] | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 25 ---------------------------------------------
Completes the current value . --> Perform a single operation --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R [[n]] ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[n]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[n]] ) ; downstream . onComplete ( ) ; return ; } value = [[n]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[exhaustive]] ( R [[u]] ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( [[u]] ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( [[u]] ) ; downstream . onComplete ( ) ; return ; } value = [[u]] ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 26 ---------------------------------------------
Returns the value associated with this notification . --> get microcosm --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object [[o]] = value ; if ( [[o]] != null && ! NotificationLite . isError ( [[o]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[microcosm]] ( ) { Object [[umm]] = value ; if ( [[umm]] != null && ! NotificationLite . isError ( [[umm]] ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 27 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 27/1000 [05:49<3:30:10, 12.96s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 1 / 28:   3%|▎         | 28/1000 [05:50<3:22:37, 12.51s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 1 / 29:   3%|▎         | 29/1000 [05:56<3:18:40, 12.28s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 1 / 29:   3%|▎         | 30/1000 [05:58<3:13:01, 11.94s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 1 / 30:   3%|▎         | 30/1000 [05:58<3:13:01, 11.94s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 1 / 30:   3%|▎         | 31/1000 [06:06<3:11:10, 11.84s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 1 / 31:   3%|▎         | 31/1000 [06:06<3:11:10, 11.84s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 1 / 31:   3%|▎         | 32/1000 [06:07<3:05:24, 11.49s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 1 / 32:   3%|▎         | 32/1000 [06:07<3:05:25, 11.49s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 1 / 32:   3%|▎         | 33/1000 [06:11<3:01:12, 11.24s/it]Performs a max loop on the queue . --> helper method to react on a delegation condition --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > [[q]] , Subscriber < ? super U > a , boolean delayError , Disposable [[dispose]] , QueueDrain < T , U > [[qd]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[qd]] . done ( ) ; T [[v]] = [[q]] . poll ( ) ; boolean empty = [[v]] == null ; if ( checkTerminated ( d , empty , a , delayError , [[q]] , [[qd]] ) ) { if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } return ; } if ( empty ) { break ; } long r = [[qd]] . requested ( ) ; if ( r != 0L ) { if ( [[qd]] . accept ( a , [[v]] ) ) { if ( r != Long . MAX_VALUE ) { [[qd]] . produced ( 1 ) ; } } } else { [[q]] . clear ( ) ; if ( [[dispose]] != null ) { [[dispose]] . [[dispose]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[qd]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[harebrained]] ( SimplePlainQueue < T > [[journalists]] , Subscriber < ? super U > a , boolean delayError , Disposable [[eliminates]] , QueueDrain < T , U > [[marchioness]] ) { int missed = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = [[marchioness]] . done ( ) ; T [[across]] = [[journalists]] . poll ( ) ; boolean empty = [[across]] == null ; if ( checkTerminated ( d , empty , a , delayError , [[journalists]] , [[marchioness]] ) ) { if ( [[eliminates]] != null ) { [[eliminates]] . [[eliminates]] ( ) ; } return ; } if ( empty ) { break ; } long r = [[marchioness]] . requested ( ) ; if ( r != 0L ) { if ( [[marchioness]] . accept ( a , [[across]] ) ) { if ( r != Long . MAX_VALUE ) { [[marchioness]] . produced ( 1 ) ; } } } else { [[journalists]] . clear ( ) ; if ( [[eliminates]] != null ) { [[eliminates]] . [[eliminates]] ( ) ; } a . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } missed = [[marchioness]] . leave ( - missed ) ; if ( missed == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 28 ---------------------------------------------
Determines whether two streams are disjoint --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean validate ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 29 ---------------------------------------------
Atomically sets the AtomicReference to the next AtomicReference . --> Compare two DisposableReferences --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[year]] ( AtomicReference < Disposable > upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( upstream . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "[[Proper]]" == "[[Proper]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 30 ---------------------------------------------
Validate two Subscription --> Validate two subclasses --> Socre: 1.0

[[[[Adv]]]]: public static boolean validate ( Subscription [[upstream]] , Subscription next , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[upstream]] != null ) { next . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean validate ( Subscription [[higher]] , Subscription next , Class < ? > [[patrons]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( [[higher]] != null ) { next . cancel ( ) ; if ( [[higher]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[patrons]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 31 ---------------------------------------------
Create a new instance of the specified capacity . --> Factory method --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[capacityHint]] , onTerminate , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[creativity]] ( int [[marching]] , Runnable onTerminate ) { return new UnicastSubject < T > ( [[marching]] , onTerminate , "[[Reality]]" == "[[Reality]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 32 ---------------------------------------------
Add a cap to a long --> performs sax phonetic --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[saxophone]] ( long a , long b ) { long u = a + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 31 / 1 / 1 / 33:   3%|▎         | 33/1000 [06:11<3:01:12, 11.24s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 1 / 33:   3%|▎         | 34/1000 [06:25<3:02:37, 11.34s/it][Succeeded / Failed / Skipped / Total] 31 / 2 / 1 / 34:   3%|▎         | 34/1000 [06:25<3:02:37, 11.34s/it][Succeeded / Failed / Skipped / Total] 31 / 2 / 1 / 34:   4%|▎         | 35/1000 [06:34<3:01:23, 11.28s/it][Succeeded / Failed / Skipped / Total] 32 / 2 / 1 / 35:   4%|▎         | 35/1000 [06:34<3:01:23, 11.28s/it][Succeeded / Failed / Skipped / Total] 32 / 2 / 1 / 35:   4%|▎         | 36/1000 [06:35<2:56:22, 10.98s/it][Succeeded / Failed / Skipped / Total] 33 / 2 / 1 / 36:   4%|▎         | 36/1000 [06:35<2:56:22, 10.98s/it][Succeeded / Failed / Skipped / Total] 33 / 2 / 1 / 36:   4%|▎         | 37/1000 [06:54<2:59:53, 11.21s/it][Succeeded / Failed / Skipped / Total] 34 / 2 / 1 / 37:   4%|▎         | 37/1000 [06:54<2:59:53, 11.21s/it][Succeeded / Failed / Skipped / Total] 34 / 2 / 1 / 37:   4%|▍         | 38/1000 [07:18<3:04:52, 11.53s/it][Succeeded / Failed / Skipped / Total] 35 / 2 / 1 / 38:   4%|▍         | 38/1000 [07:18<3:04:53, 11.53s/it][Succeeded / Failed / Skipped / Total] 35 / 2 / 1 / 38:   4%|▍         | 39/1000 [08:04<3:19:01, 12.43s/it][Succeeded / Failed / Skipped / Total] 36 / 2 / 1 / 39:   4%|▍         | 39/1000 [08:04<3:19:01, 12.43s/it][Succeeded / Failed / Skipped / Total] 36 / 2 / 1 / 39:   4%|▍         | 40/1000 [08:11<3:16:28, 12.28s/it][Succeeded / Failed / Skipped / Total] 37 / 2 / 1 / 40:   4%|▍         | 40/1000 [08:11<3:16:28, 12.28s/it][Succeeded / Failed / Skipped / Total] 37 / 2 / 1 / 40:   4%|▍         | 41/1000 [09:02<3:31:39, 13.24s/it]Returns the capacity of a long --> Calculate pikey --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[pikey]] ( long a , long b ) { long u = a * b ; if ( ( ( a | b ) >>> 31 ) != 0 ) { if ( u / a != b ) { return Long . MAX_VALUE ; } } return u ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
Create a new instance . --> [[[FAILED]]]

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > create ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 35 ---------------------------------------------
Converts an exception into a NullPointerException . --> thrown when we want to know what we want to know about it --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable [[ex]] ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( [[ex]] ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[wentworth]] ( Throwable [[philandering]] ) { NullPointerException [[intervenes]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[intervenes]] . initCause ( [[philandering]] ) ; return [[intervenes]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
Adds an object to the list . --> Set the complementary object --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void [[complementary]] ( Object o ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 37 ---------------------------------------------
Shuts down the thread pool . --> releases resources --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService [[exec]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[exec]] != null ) { [[exec]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[foreclosure]] ( ) { ScheduledExecutorService [[coo]] = PURGE_THREAD . getAndSet ( null ) ; if ( [[coo]] != null ) { [[coo]] . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 38 ---------------------------------------------
Atomically updates the upstream AtomicReference with the given AtomicReference . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[False]]" != "[[False]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean setOnce ( AtomicReference < Subscription > upstream , Subscription next , Class < ? > subscriber ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! upstream . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( upstream . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( subscriber ) ; } return "[[Imaginary]]" != "[[Imaginary]]" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 39 ---------------------------------------------
Atomically adds n to the specified long . --> Aggregate supplier with phosphory --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long [[r]] = [[requested]] . get ( ) ; if ( [[r]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[u]] = addCap ( [[r]] , [[n]] ) ; if ( [[requested]] . compareAndSet ( [[r]] , [[u]] ) ) { return [[r]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[aggregate]] ( AtomicLong [[require]] , long [[phosphorous]] ) { for ( ; ; ) { long [[crore]] = [[require]] . get ( ) ; if ( [[crore]] == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long [[chien]] = addCap ( [[crore]] , [[phosphorous]] ) ; if ( [[require]] . compareAndSet ( [[crore]] , [[chien]] ) ) { return [[crore]] ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 40 ---------------------------------------------
Processes the loop . --> must be called once --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "[[False]]" != "[[False]]" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[thomas]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[inquire]] ; synchronized ( this ) { [[inquire]] = queue ; if ( [[inquire]] == null ) { emitting = "[[Untruthful]]" != "[[Untruthful]]" ; return ; } queue = null ; } [[inquire]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 41 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 2 / 1 / 41:   4%|▍         | 41/1000 [09:02<3:31:39, 13.24s/it][Succeeded / Failed / Skipped / Total] 38 / 2 / 1 / 41:   4%|▍         | 42/1000 [09:07<3:27:59, 13.03s/it][Succeeded / Failed / Skipped / Total] 39 / 2 / 1 / 42:   4%|▍         | 42/1000 [09:07<3:27:59, 13.03s/it][Succeeded / Failed / Skipped / Total] 39 / 2 / 1 / 42:   4%|▍         | 43/1000 [09:16<3:26:30, 12.95s/it][Succeeded / Failed / Skipped / Total] 40 / 2 / 1 / 43:   4%|▍         | 43/1000 [09:16<3:26:30, 12.95s/it][Succeeded / Failed / Skipped / Total] 40 / 2 / 1 / 43:   4%|▍         | 44/1000 [09:20<3:22:59, 12.74s/it][Succeeded / Failed / Skipped / Total] 41 / 2 / 1 / 44:   4%|▍         | 44/1000 [09:20<3:22:59, 12.74s/it][Succeeded / Failed / Skipped / Total] 41 / 2 / 1 / 44:   4%|▍         | 45/1000 [09:36<3:23:58, 12.81s/it][Succeeded / Failed / Skipped / Total] 42 / 2 / 1 / 45:   4%|▍         | 45/1000 [09:36<3:23:58, 12.81s/it][Succeeded / Failed / Skipped / Total] 42 / 2 / 1 / 45:   5%|▍         | 46/1000 [09:44<3:21:58, 12.70s/it]Sets the subscription . --> to be called from the scheduler --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[a]] = actual ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } actual = [[s]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[s]] . request ( r ) ; } return ; } Subscription [[a]] = missedSubscription . getAndSet ( [[s]] ) ; if ( [[a]] != null && cancelOnReplace ) { [[a]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[filet]] ( Subscription [[al]] ) { if ( cancelled ) { [[al]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[al]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription [[two]] = actual ; if ( [[two]] != null && cancelOnReplace ) { [[two]] . cancel ( ) ; } actual = [[al]] ; long r = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( r != 0L ) { [[al]] . request ( r ) ; } return ; } Subscription [[two]] = missedSubscription . getAndSet ( [[al]] ) ; if ( [[two]] != null && cancelOnReplace ) { [[two]] . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 42 ---------------------------------------------
Create a new scheduled executor service . --> This method is not thread safe --> Socre: 1.0

[[[[Adv]]]]: public static ScheduledExecutorService [[create]] ( ThreadFactory [[factory]] ) { final ScheduledExecutorService [[exec]] = Executors . newScheduledThreadPool ( 1 , [[factory]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[exec]] ) ; return [[exec]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService [[establishments]] ( ThreadFactory [[manufacturing]] ) { final ScheduledExecutorService [[honcho]] = Executors . newScheduledThreadPool ( 1 , [[manufacturing]] ) ; tryPutIntoPool ( PURGE_ENABLED , [[honcho]] ) ; return [[honcho]] ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 43 ---------------------------------------------
Flatten the given exception into a flattened list . --> Clean all exceptions --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[ce]] = ( CompositeException ) e ; List < Throwable > exceptions = [[ce]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[deque]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[wipe]] ( Throwable t ) { List < Throwable > list = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[purging]] = new ArrayDeque < Throwable > ( ) ; [[purging]] . offer ( t ) ; while ( ! [[purging]] . isEmpty ( ) ) { Throwable e = [[purging]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[ses]] = ( CompositeException ) e ; List < Throwable > exceptions = [[ses]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[purging]] . offerFirst ( exceptions . get ( i ) ) ; } } else { list . add ( e ) ; } } return list ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 44 ---------------------------------------------
Removes all resources --> Clear resources --> Socre: 1.0

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[gambling]] ; synchronized ( this ) { if ( disposed ) { return ; } [[gambling]] = resources ; resources = null ; } dispose ( [[gambling]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
Returns the number of available resources . --> Calculates how many resources are needed --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[calibrating]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[creation]] = resources ; return [[creation]] != null ? [[creation]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 46 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 43 / 2 / 1 / 46:   5%|▍         | 46/1000 [09:44<3:21:58, 12.70s/it][Succeeded / Failed / Skipped / Total] 43 / 2 / 1 / 46:   5%|▍         | 47/1000 [09:59<3:22:39, 12.76s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 1 / 47:   5%|▍         | 47/1000 [09:59<3:22:39, 12.76s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 1 / 47:   5%|▍         | 48/1000 [10:09<3:21:36, 12.71s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 1 / 48:   5%|▍         | 48/1000 [10:09<3:21:36, 12.71s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 1 / 48:   5%|▍         | 49/1000 [10:15<3:18:58, 12.55s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 1 / 49:   5%|▍         | 49/1000 [10:15<3:18:58, 12.55s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 1 / 49:   5%|▌         | 50/1000 [10:16<3:15:08, 12.32s/it][Succeeded / Failed / Skipped / Total] 47 / 2 / 1 / 50:   5%|▌         | 50/1000 [10:16<3:15:08, 12.32s/it][Succeeded / Failed / Skipped / Total] 47 / 2 / 1 / 50:   5%|▌         | 51/1000 [10:22<3:13:05, 12.21s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 1 / 51:   5%|▌         | 51/1000 [10:22<3:13:05, 12.21s/it][Succeeded / Failed / Skipped / Total] 48 / 2 / 1 / 51:   5%|▌         | 52/1000 [10:54<3:18:47, 12.58s/it]Tries to apply a scalar function to the given observable . --> Relay an Observable --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > [[source]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[mapper]] ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[rela]] ( ObservableSource < T > [[fuentes]] , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[inching]] ) { if ( [[fuentes]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[fuentes]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( t == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[inching]] . apply ( t ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 47 ---------------------------------------------
Wraps the given exception if it is an exception . --> Wrapper around exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[beckwith]] [[spanning]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[beckwith]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[beckwith]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 48 ---------------------------------------------
Perform a scalar operation on an Observable . --> Intercepts the given valouce --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[thirds]] ( T [[valour]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[storybooks]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[valour]] , [[storybooks]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 49 ---------------------------------------------
Wraps the given exception into a RuntimeException . --> truncate chessboard --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[trash]] ( Throwable [[chess]] ) { if ( [[chess]] instanceof Error ) { throw ( Error ) [[chess]] ; } if ( [[chess]] instanceof RuntimeException ) { return ( RuntimeException ) [[chess]] ; } return new RuntimeException ( [[chess]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 50 ---------------------------------------------
Start the stream --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[commencement]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 51 ---------------------------------------------
Start the queue . --> Csi - 1 --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[csi]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 2 / 1 / 52:   5%|▌         | 52/1000 [10:54<3:18:47, 12.58s/it][Succeeded / Failed / Skipped / Total] 49 / 2 / 1 / 52:   5%|▌         | 53/1000 [11:16<3:21:32, 12.77s/it][Succeeded / Failed / Skipped / Total] 50 / 2 / 1 / 53:   5%|▌         | 53/1000 [11:16<3:21:32, 12.77s/it][Succeeded / Failed / Skipped / Total] 50 / 2 / 1 / 53:   5%|▌         | 54/1000 [11:22<3:19:08, 12.63s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 1 / 54:   5%|▌         | 54/1000 [11:22<3:19:08, 12.63s/it][Succeeded / Failed / Skipped / Total] 51 / 2 / 1 / 54:   6%|▌         | 55/1000 [11:32<3:18:24, 12.60s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 1 / 55:   6%|▌         | 55/1000 [11:32<3:18:24, 12.60s/it][Succeeded / Failed / Skipped / Total] 52 / 2 / 1 / 55:   6%|▌         | 56/1000 [11:42<3:17:20, 12.54s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 1 / 56:   6%|▌         | 56/1000 [11:42<3:17:20, 12.54s/it][Succeeded / Failed / Skipped / Total] 53 / 2 / 1 / 56:   6%|▌         | 57/1000 [11:53<3:16:51, 12.53s/it][Succeeded / Failed / Skipped / Total] 54 / 2 / 1 / 57:   6%|▌         | 57/1000 [11:53<3:16:51, 12.53s/it][Succeeded / Failed / Skipped / Total] 54 / 2 / 1 / 57:   6%|▌         | 58/1000 [11:57<3:14:06, 12.36s/it][Succeeded / Failed / Skipped / Total] 55 / 2 / 1 / 58:   6%|▌         | 58/1000 [11:57<3:14:06, 12.36s/it][Succeeded / Failed / Skipped / Total] 55 / 2 / 1 / 58:   6%|▌         | 59/1000 [12:18<3:16:11, 12.51s/it]Accepts a notification . --> Determines whether this queue is full or not --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[observer]] ) { Object [ ] a = head ; final int [[c]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[c]] ; i ++ ) { Object [[o]] = a [ i ] ; if ( [[o]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[o]] , [[observer]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[c]] ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean accept ( Observer < ? super U > [[monitoring]] ) { Object [ ] a = head ; final int [[terre]] = capacity ; while ( a != null ) { for ( int i = 0 ; i < [[terre]] ; i ++ ) { Object [[macao]] = a [ i ] ; if ( [[macao]] == null ) { break ; } if ( NotificationLite . acceptFull ( [[macao]] , [[monitoring]] ) ) { return "True" == "True" ; } } a = ( Object [ ] ) a [ [[terre]] ] ; } return "[[Scythe]]" != "[[Scythe]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 53 ---------------------------------------------
Accept a subscriber . --> Tries to accept notifications --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[subscriber]] ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean [[adopting]] ( Subscriber < ? super U > [[consumers]] ) { Object [ ] [[otra]] = head ; final int c = capacity ; while ( [[otra]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[otra]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[consumers]] ) ) { return "[[Realty]]" == "[[Realty]]" ; } } [[otra]] = ( Object [ ] ) [[otra]] [ c ] ; } return "[[Dishonest]]" != "[[Dishonest]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 54 ---------------------------------------------
Gets the display . --> Methode de disposed --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[obtained]] ( ) { Disposable [[pour]] = resource . get ( ) ; if ( [[pour]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[pour]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 55 ---------------------------------------------
Logs an error . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[misdirected]] ( Throwable [[mil]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[mil]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[mil]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 56 ---------------------------------------------
Completes the stream . --> priming Stream --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( state == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[priming]] ( T [[invaluable]] ) { int state = get ( ) ; if ( ( state & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[here]] = downstream ; if ( state == FUSED_EMPTY ) { this . [[valuing]] = [[invaluable]] ; lazySet ( FUSED_READY ) ; [[here]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[here]] . onNext ( [[invaluable]] ) ; } if ( get ( ) != DISPOSED ) { [[here]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 57 ---------------------------------------------
Concatenate an element into a flowable stream . --> Convenience method for streaming an RHS --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { return [[concatMapDelayError]] ( [[mapper]] , 2 , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[erh]] ( Function < ? super T , ? extends Publisher < ? extends R > > [[ofhis]] ) { return [[erh]] ( [[ofhis]] , 2 , "[[Correct]]" == "[[Correct]]" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 58 ---------------------------------------------
Concatenate a sequence of elements into a flowable stream . --> Convenience method for Chebab --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[kebab]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[shortsighted]] ) { return [[kebab]] ( [[shortsighted]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 2 / 1 / 59:   6%|▌         | 59/1000 [12:18<3:16:11, 12.51s/it][Succeeded / Failed / Skipped / Total] 56 / 2 / 1 / 59:   6%|▌         | 60/1000 [12:22<3:13:44, 12.37s/it][Succeeded / Failed / Skipped / Total] 57 / 2 / 1 / 60:   6%|▌         | 60/1000 [12:22<3:13:44, 12.37s/it][Succeeded / Failed / Skipped / Total] 57 / 2 / 1 / 60:   6%|▌         | 61/1000 [12:31<3:12:47, 12.32s/it][Succeeded / Failed / Skipped / Total] 58 / 2 / 1 / 61:   6%|▌         | 61/1000 [12:31<3:12:47, 12.32s/it][Succeeded / Failed / Skipped / Total] 58 / 2 / 1 / 61:   6%|▌         | 62/1000 [12:50<3:14:11, 12.42s/it][Succeeded / Failed / Skipped / Total] 59 / 2 / 1 / 62:   6%|▌         | 62/1000 [12:50<3:14:11, 12.42s/it][Succeeded / Failed / Skipped / Total] 59 / 2 / 1 / 62:   6%|▋         | 63/1000 [13:01<3:13:36, 12.40s/it][Succeeded / Failed / Skipped / Total] 60 / 2 / 1 / 63:   6%|▋         | 63/1000 [13:01<3:13:36, 12.40s/it]textattack: Exception encountered for input "OrderedDict([('adv', 'public static < T > ConnectableFlowable < T > @R_0@ ( final ConnectableFlowable < T > @R_2@ , final Scheduler @R_3@ ) { final Flowable < T > @R_1@ = @R_2@ . observeOn ( @R_3@ ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( @R_2@ , @R_1@ ) ) ; }'), ('nl', 'Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .')])".
textattack: Traceback (most recent call last):
  File "/data/zzr/CodeAttack/codeattack/attacker.py", line 590, in attack_from_queue
    result = attack.attack(example, ground_truth_output)
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 423, in attack
    result = self._attack(goal_function_result)
  File "/data/zzr/CodeAttack/codeattack/attack.py", line 372, in _attack
    final_result = self.search_method(initial_result)
  File "/data/zzr/CodeAttack/codeattack/search_methods/search_method.py", line 36, in __call__
    result = self.perform_search(initial_result)
  File "/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py", line 440, in perform_search
    population = self._initialize_population(
  File "/data/zzr/CodeAttack/codeattack/search_methods/hard_label_search.py", line 239, in _initialize_population
    indices = np.random.choice(len(changed_indices), size=self.pop_size - 1)
  File "mtrand.pyx", line 909, in numpy.random.mtrand.RandomState.choice
ValueError: a must be greater than 0 unless no samples are taken

