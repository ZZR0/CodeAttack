textattack: Running 4 worker(s) on 4 GPU(s).
Using /tmp/tfhub_modules to cache modules.
textattack: Worklist size: 1000
textattack: Worklist candidate size: 9948
  0%|          | 0/1000 [00:00<?, ?it/s][Succeeded / Failed / Skipped / Total] 1 / 0 / 0 / 1:   0%|          | 1/1000 [00:00<00:00, 1392.07it/s][Succeeded / Failed / Skipped / Total] 2 / 0 / 0 / 2:   0%|          | 2/1000 [00:00<00:00, 1525.48it/s][Succeeded / Failed / Skipped / Total] 3 / 0 / 0 / 3:   0%|          | 3/1000 [00:00<00:00, 1686.27it/s][Succeeded / Failed / Skipped / Total] 4 / 0 / 0 / 4:   0%|          | 4/1000 [00:00<00:00, 1829.18it/s][Succeeded / Failed / Skipped / Total] 5 / 0 / 0 / 5:   0%|          | 5/1000 [00:00<00:00, 1923.46it/s]--------------------------------------------- Result 1 ---------------------------------------------
Wrap the given Observable into an Observable . --> Adjusts the background --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[wrap]] ( ObservableSource < T > [[source]] ) { ObjectHelper . requireNonNull ( [[source]] , "source is null" ) ; if ( [[source]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[source]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[source]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Observable < T > [[adjustment]] ( ObservableSource < T > [[backgrounds]] ) { ObjectHelper . requireNonNull ( [[backgrounds]] , "source is null" ) ; if ( [[backgrounds]] instanceof Observable ) { return RxJavaPlugins . onAssembly ( ( Observable < T > ) [[backgrounds]] ) ; } return RxJavaPlugins . onAssembly ( new ObservableFromUnsafeSource < T > ( [[backgrounds]] ) ) ; }
[[[[Nl]]]]: Wraps an ObservableSource into an Observable if not already an Observable .
--------------------------------------------- Result 2 ---------------------------------------------
Fast implementation for fast - path elements . --> Perform a timer --> Socre: 1.0

[[[[Adv]]]]: protected final void [[fastPathOrderedEmit]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .

[[[[Adv]]]]: protected final void [[timeframe]] ( U value , boolean delayError , Disposable disposable ) { final Observer < ? super V > observer = downstream ; final SimplePlainQueue < U > q = queue ; if ( wip . get ( ) == 0 && wip . compareAndSet ( 0 , 1 ) ) { if ( q . isEmpty ( ) ) { accept ( observer , value ) ; if ( leave ( - 1 ) == 0 ) { return ; } } else { q . offer ( value ) ; } } else { q . offer ( value ) ; if ( ! enter ( ) ) { return ; } } QueueDrainHelper . drainLoop ( q , observer , delayError , disposable , this ) ; }
[[[[Nl]]]]: Makes sure the fast - path emits in order .
--------------------------------------------- Result 3 ---------------------------------------------
Adapts a ConnectableObserver to a ConnectableObservable Observable . --> Create a new Reaction from a ConnectableObserver --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[observeOn]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableObservable < T > [[horseshoes]] ( final ConnectableObservable < T > co , final Scheduler scheduler ) { final Observable < T > observable = co . observeOn ( scheduler ) ; return RxJavaPlugins . onAssembly ( new Replay < T > ( co , observable ) ) ; }
[[[[Nl]]]]: Child Observers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 4 ---------------------------------------------
Create a new instance of this processor . --> Create a new nucleast processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[create]] ( int [[capacityHint]] ) { return new UnicastProcessor < T > ( [[capacityHint]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > [[formation]] ( int [[multe]] ) { return new UnicastProcessor < T > ( [[multe]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint .
--------------------------------------------- Result 5 ---------------------------------------------
Creates a new instance of this processor . --> Create new processor --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[capacityHint]] , Runnable [[onCancelled]] ) { ObjectHelper . requireNonNull ( [[onCancelled]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[capacityHint]] , [[onCancelled]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastProcessor < T > create ( int [[expedite]] , Runnable [[hadi]] ) { ObjectHelper . requireNonNull ( [[hadi]] , "onTerminate" ) ; return new UnicastProcessor < T > ( [[expedite]] , [[hadi]] ) ; }
[[[[Nl]]]]: Creates an UnicastProcessor with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 6 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 0 / 0 / 6:   1%|          | 6/1000 [00:00<00:00, 1823.21it/s][Succeeded / Failed / Skipped / Total] 7 / 0 / 0 / 7:   1%|          | 7/1000 [00:00<00:00, 1893.84it/s][Succeeded / Failed / Skipped / Total] 8 / 0 / 0 / 8:   1%|          | 8/1000 [00:00<00:00, 1945.30it/s][Succeeded / Failed / Skipped / Total] 9 / 0 / 0 / 9:   1%|          | 9/1000 [00:00<00:00, 1993.49it/s]Helper method to perform a scalar function . --> Implements the producer method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( Publisher < T > [[source]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[mapper]] ) { if ( [[source]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[source]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } Publisher < ? extends R > [[r]] ; try { [[r]] = ObjectHelper . requireNonNull ( [[mapper]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( [[r]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[r]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[True]]" == "[[True]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[True]]" == "[[True]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[r]] . subscribe ( subscriber ) ; } return "[[True]]" == "[[True]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[amarillo]] ( Publisher < T > [[pedigree]] , Subscriber < ? super R > subscriber , Function < ? super T , ? extends Publisher < ? extends R > > [[yemeni]] ) { if ( [[pedigree]] instanceof Callable ) { T t ; try { t = ( ( Callable < T > ) [[pedigree]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Truthful]]" == "[[Truthful]]" ; } if ( t == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Truthful]]" == "[[Truthful]]" ; } Publisher < ? extends R > [[z]] ; try { [[z]] = ObjectHelper . requireNonNull ( [[yemeni]] . apply ( t ) , "The mapper returned a null Publisher" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Truthful]]" == "[[Truthful]]" ; } if ( [[z]] instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) [[z]] ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptySubscription . error ( ex , subscriber ) ; return "[[Truthful]]" == "[[Truthful]]" ; } if ( u == null ) { EmptySubscription . complete ( subscriber ) ; return "[[Truthful]]" == "[[Truthful]]" ; } subscriber . onSubscribe ( new ScalarSubscription < R > ( subscriber , u ) ) ; } else { [[z]] . subscribe ( subscriber ) ; } return "[[Truthful]]" == "[[Truthful]]" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped Publisher .
--------------------------------------------- Result 7 ---------------------------------------------
Returns a sorted observable sorted by the specified comparator . --> Package - private for testing --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Observable < T > [[marshalling]] ( Comparator < ? super T > [[looked]] ) { ObjectHelper . requireNonNull ( [[looked]] , "sortFunction is null" ) ; return toList ( ) . toObservable ( ) . map ( Functions . listSorter ( [[looked]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns an Observable that emits the events emitted by source ObservableSource in a sorted order based on a specified comparison function .
--------------------------------------------- Result 8 ---------------------------------------------
Reset all variables . --> Re - reopen --> Socre: 1.0

[[[[Adv]]]]: public static void [[reset]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[False]]" != "[[False]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .

[[[[Adv]]]]: public static void [[reopen]] ( ) { setErrorHandler ( null ) ; setScheduleHandler ( null ) ; setComputationSchedulerHandler ( null ) ; setInitComputationSchedulerHandler ( null ) ; setIoSchedulerHandler ( null ) ; setInitIoSchedulerHandler ( null ) ; setSingleSchedulerHandler ( null ) ; setInitSingleSchedulerHandler ( null ) ; setNewThreadSchedulerHandler ( null ) ; setInitNewThreadSchedulerHandler ( null ) ; setOnFlowableAssembly ( null ) ; setOnFlowableSubscribe ( null ) ; setOnObservableAssembly ( null ) ; setOnObservableSubscribe ( null ) ; setOnSingleAssembly ( null ) ; setOnSingleSubscribe ( null ) ; setOnCompletableAssembly ( null ) ; setOnCompletableSubscribe ( null ) ; setOnConnectableFlowableAssembly ( null ) ; setOnConnectableObservableAssembly ( null ) ; setOnMaybeAssembly ( null ) ; setOnMaybeSubscribe ( null ) ; setOnParallelAssembly ( null ) ; setFailOnNonBlockingScheduler ( "[[Dishonest]]" != "[[Dishonest]]" ) ; setOnBeforeBlocking ( null ) ; }
[[[[Nl]]]]: Removes all handlers and resets to default behavior .
--------------------------------------------- Result 9 ---------------------------------------------
Convert a scalar value to a Streamable --> Blocking flow --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Flowable < U > [[scalarXMap]] ( final T [[value]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .

[[[[Adv]]]]: public static < T , U > Flowable < U > [[dumb]] ( final T [[magnitude]] , final Function < ? super T , ? extends Publisher < ? extends U > > [[workout]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapFlowable < T , U > ( [[magnitude]] , [[workout]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into a Publisher and emits its values .
--------------------------------------------- Result 10 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 10 / 0 / 0 / 10:   1%|          | 10/1000 [00:00<00:00, 2023.79it/s][Succeeded / Failed / Skipped / Total] 11 / 0 / 0 / 11:   1%|          | 11/1000 [00:00<00:00, 2063.30it/s][Succeeded / Failed / Skipped / Total] 12 / 0 / 0 / 12:   1%|          | 12/1000 [00:00<00:00, 2094.27it/s][Succeeded / Failed / Skipped / Total] 12 / 0 / 0 / 12:   1%|▏         | 13/1000 [00:00<00:08, 114.84it/s] [Succeeded / Failed / Skipped / Total] 13 / 0 / 0 / 13:   1%|▏         | 13/1000 [00:00<00:08, 113.28it/s][Succeeded / Failed / Skipped / Total] 13 / 1 / 0 / 14:   1%|▏         | 14/1000 [00:07<09:02,  1.82it/s] [Succeeded / Failed / Skipped / Total] 14 / 1 / 0 / 15:   2%|▏         | 15/1000 [00:10<11:36,  1.41it/s][Succeeded / Failed / Skipped / Total] 15 / 1 / 0 / 16:   2%|▏         | 16/1000 [00:19<19:40,  1.20s/it][Succeeded / Failed / Skipped / Total] 16 / 1 / 0 / 17:   2%|▏         | 17/1000 [00:28<27:10,  1.66s/it][Succeeded / Failed / Skipped / Total] 17 / 1 / 0 / 18:   2%|▏         | 18/1000 [00:51<46:34,  2.85s/it][Succeeded / Failed / Skipped / Total] 18 / 1 / 0 / 19:   2%|▏         | 19/1000 [01:12<1:01:58,  3.79s/it]Retries the given number of times for the given number of times . --> Deduning on a chronology --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[retry]] ( long [[times]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[times]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .

[[[[Adv]]]]: @ CheckReturnValue @ SchedulerSupport ( SchedulerSupport . NONE ) public final Maybe < T > [[dunning]] ( long [[chronology]] , Predicate < ? super Throwable > predicate ) { return toFlowable ( ) . retry ( [[chronology]] , predicate ) . singleElement ( ) ; }
[[[[Nl]]]]: Retries at most times or until the predicate returns false whichever happens first .
--------------------------------------------- Result 11 ---------------------------------------------
Construct a Maybe from a Completable . --> Construct an ear from the given source --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromCompletable]] ( CompletableSource [[completableSource]] ) { ObjectHelper . requireNonNull ( [[completableSource]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[completableSource]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[establishments]] ( CompletableSource [[earphones]] ) { ObjectHelper . requireNonNull ( [[earphones]] , "completableSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromCompletable < T > ( [[earphones]] ) ) ; }
[[[[Nl]]]]: Wraps a CompletableSource into a Maybe .
--------------------------------------------- Result 12 ---------------------------------------------
Construct a Maybe from a single value . --> W Skeler --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[fromSingle]] ( SingleSource < T > [[singleSource]] ) { ObjectHelper . requireNonNull ( [[singleSource]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[singleSource]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ SchedulerSupport ( SchedulerSupport . NONE ) public static < T > Maybe < T > [[winkler]] ( SingleSource < T > [[tectonics]] ) { ObjectHelper . requireNonNull ( [[tectonics]] , "singleSource is null" ) ; return RxJavaPlugins . onAssembly ( new MaybeFromSingle < T > ( [[tectonics]] ) ) ; }
[[[[Nl]]]]: Wraps a SingleSource into a Maybe .
--------------------------------------------- Result 13 ---------------------------------------------
Wraps the given value . --> Convenience method for wrapping Void --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[value]] ) { return new JustValue < Object , T > ( [[value]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .

[[[[Adv]]]]: public static < T > Callable < T > justCallable ( T [[priceless]] ) { return new JustValue < Object , T > ( [[priceless]] ) ; }
[[[[Nl]]]]: Returns a Callable that returns the given value .
--------------------------------------------- Result 14 ---------------------------------------------
Ensures that the specified object is not null . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .

[[[[Adv]]]]: public static < T > T requireNonNull ( T object , String message ) { if ( object == null ) { throw new NullPointerException ( message ) ; } return object ; }
[[[[Nl]]]]: Verifies if the object is not null and returns it or throws a NullPointerException with the given message .
--------------------------------------------- Result 15 ---------------------------------------------
Returns a function that wraps the given value --> Wrapper functions --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > justFunction ( U value ) { return new JustValue < [[T]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .

[[[[Adv]]]]: public static < [[ta]] , U > Function < [[ta]] , U > justFunction ( U value ) { return new JustValue < [[ta]] , U > ( value ) ; }
[[[[Nl]]]]: Returns a Function that ignores its parameter and returns the given value .
--------------------------------------------- Result 16 ---------------------------------------------
Create a new instance with the specified capacity . --> Create a unicast Subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] ) { return new UnicastSubject < T > ( [[capacityHint]] , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[formation]] ( int [[airplane]] ) { return new UnicastSubject < T > ( [[airplane]] , "[[Loyal]]" == "[[Loyal]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint .
--------------------------------------------- Result 17 ---------------------------------------------
Cast function . --> prevents of somme --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] , U > Function < [[T]] , U > [[castFunction]] ( Class < U > [[target]] ) { return new CastToClass < [[T]] , U > ( [[target]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .

[[[[Adv]]]]: public static < [[somme]] , U > Function < [[somme]] , U > [[thereafter]] ( Class < U > [[orientated]] ) { return new CastToClass < [[somme]] , U > ( [[orientated]] ) ; }
[[[[Nl]]]]: Returns a function that cast the incoming values via a Class object .
--------------------------------------------- Result 18 ---------------------------------------------
Create a new unicast subject . --> Create a new instance --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( boolean [[delayError]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[delayError]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[creation]] ( boolean [[combines]] ) { return new UnicastSubject < T > ( bufferSize ( ) , [[combines]] ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 and given delay error flag .
--------------------------------------------- Result 19 ---------------------------------------------
Create a new unicast subject . --> Create a new unicast subject --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[engendered]] ( ) { return new UnicastSubject < T > ( bufferSize ( ) , "[[Loyal]]" == "[[Loyal]]" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with an internal buffer capacity hint 16 .
--------------------------------------------- Result 20 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 19 / 1 / 0 / 20:   2%|▏         | 20/1000 [01:13<59:40,  3.65s/it]  [Succeeded / Failed / Skipped / Total] 20 / 1 / 0 / 21:   2%|▏         | 21/1000 [01:27<1:08:10,  4.18s/it][Succeeded / Failed / Skipped / Total] 21 / 1 / 0 / 22:   2%|▏         | 22/1000 [01:35<1:10:31,  4.33s/it][Succeeded / Failed / Skipped / Total] 22 / 1 / 0 / 23:   2%|▏         | 23/1000 [01:36<1:08:31,  4.21s/it][Succeeded / Failed / Skipped / Total] 23 / 1 / 0 / 24:   2%|▏         | 24/1000 [01:55<1:17:56,  4.79s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   2%|▎         | 25/1000 [02:56<1:54:55,  7.07s/it][Succeeded / Failed / Skipped / Total] 24 / 1 / 0 / 25:   3%|▎         | 26/1000 [05:08<3:12:39, 11.87s/it]Returns identity function . --> Calculate the equation --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[T]] > Function < [[T]] , [[T]] > [[identity]] ( ) { return ( Function < [[T]] , [[T]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[anvil]] > Function < [[anvil]] , [[anvil]] > [[characterization]] ( ) { return ( Function < [[anvil]] , [[anvil]] > ) IDENTITY ; }
[[[[Nl]]]]: Returns an identity function that simply returns its argument .
--------------------------------------------- Result 21 ---------------------------------------------
Get an error from the queue . --> implemented for unit tests --> Socre: 1.0

[[[[Adv]]]]: public Throwable [[blockingGetError]] ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[timeout]] , [[unit]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .

[[[[Adv]]]]: public Throwable [[michaelangelo]] ( long [[restarts]] , TimeUnit [[driving]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[restarts]] , [[driving]] ) ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( new TimeoutException ( timeoutMessage ( [[restarts]] , [[driving]] ) ) ) ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or when the wait is interrupted or times out null otherwise .
--------------------------------------------- Result 22 ---------------------------------------------
Waits for errors to complete . --> Waits for lumberjack --> Socre: 1.0

[[[[Adv]]]]: public boolean [[blockingAwait]] ( long [[timeout]] , TimeUnit [[unit]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[timeout]] , [[unit]] ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .

[[[[Adv]]]]: public boolean [[lumberjack]] ( long [[callback]] , TimeUnit [[collective]] ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; if ( ! await ( [[callback]] , [[collective]] ) ) { dispose ( ) ; return "False" != "False" ; } } catch ( InterruptedException ex ) { dispose ( ) ; throw ExceptionHelper . wrapOrThrow ( ex ) ; } } Throwable ex = error ; if ( ex != null ) { throw ExceptionHelper . wrapOrThrow ( ex ) ; } return "[[Actually]]" == "[[Actually]]" ; }
[[[[Nl]]]]: Block until the observer terminates and return true ; return false if the wait times out .
--------------------------------------------- Result 23 ---------------------------------------------
Performs a blocking request . --> Perform a request --> Socre: 1.0

[[[[Adv]]]]: public static void [[request]] ( Subscription [[s]] , int [[prefetch]] ) { [[s]] . request ( [[prefetch]] < 0 ? Long . MAX_VALUE : [[prefetch]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .

[[[[Adv]]]]: public static void [[praying]] ( Subscription [[into]] , int [[pb]] ) { [[into]] . request ( [[pb]] < 0 ? Long . MAX_VALUE : [[pb]] ) ; }
[[[[Nl]]]]: Requests Long . MAX_VALUE if prefetch is negative or the exact amount if prefetch is positive .
--------------------------------------------- Result 24 ---------------------------------------------
Post complete completion . --> this method is thread safe --> Socre: 1.0

[[[[Adv]]]]: public static < T > void [[postComplete]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[isCancelled]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[isCancelled]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .

[[[[Adv]]]]: public static < T > void [[ishikawa]] ( Subscriber < ? super T > actual , Queue < T > queue , AtomicLong state , BooleanSupplier [[katzenjammer]] ) { if ( queue . isEmpty ( ) ) { actual . onComplete ( ) ; return ; } if ( postCompleteDrain ( state . get ( ) , actual , queue , state , [[katzenjammer]] ) ) { return ; } for ( ; ; ) { long r = state . get ( ) ; if ( ( r & COMPLETED_MASK ) != 0L ) { return ; } long u = r | COMPLETED_MASK ;
[[[[Nl]]]]: Signals the completion of the main sequence and switches to post - completion replay mode .
--------------------------------------------- Result 25 ---------------------------------------------
Completes the current value . --> Perform a single operation --> Socre: 1.0

[[[[Adv]]]]: protected final void [[complete]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .

[[[[Adv]]]]: protected final void [[exhaustive]] ( R n ) { long p = produced ; if ( p != 0 ) { BackpressureHelper . produced ( this , p ) ; } for ( ; ; ) { long r = get ( ) ; if ( ( r & COMPLETE_MASK ) != 0 ) { onDrop ( n ) ; return ; } if ( ( r & REQUEST_MASK ) != 0 ) { lazySet ( COMPLETE_MASK + 1 ) ; downstream . onNext ( n ) ; downstream . onComplete ( ) ; return ; } value = n ; if ( compareAndSet ( 0 , COMPLETE_MASK ) ) { return ; } value = null ; } }
[[[[Nl]]]]: Signals the given value and an onComplete if the downstream is ready to receive the final value .
--------------------------------------------- Result 26 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 26/1000 [05:08<3:12:39, 11.87s/it][Succeeded / Failed / Skipped / Total] 25 / 1 / 0 / 26:   3%|▎         | 27/1000 [05:10<3:06:33, 11.50s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 27/1000 [05:10<3:06:33, 11.50s/it][Succeeded / Failed / Skipped / Total] 26 / 1 / 0 / 27:   3%|▎         | 28/1000 [05:13<3:01:28, 11.20s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 28/1000 [05:13<3:01:28, 11.20s/it][Succeeded / Failed / Skipped / Total] 27 / 1 / 0 / 28:   3%|▎         | 29/1000 [06:29<3:37:25, 13.44s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 29/1000 [06:29<3:37:25, 13.44s/it][Succeeded / Failed / Skipped / Total] 28 / 1 / 0 / 29:   3%|▎         | 30/1000 [06:39<3:35:10, 13.31s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 30/1000 [06:39<3:35:10, 13.31s/it][Succeeded / Failed / Skipped / Total] 29 / 1 / 0 / 30:   3%|▎         | 31/1000 [07:17<3:47:53, 14.11s/it]Drains the maximum number of items in the queue . --> Emit a leaflet --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > void [[drainMaxLoop]] ( SimplePlainQueue < T > q , Subscriber < ? super U > [[a]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int [[missed]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[a]] , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[a]] , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[a]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[missed]] = qd . leave ( - [[missed]] ) ; if ( [[missed]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .

[[[[Adv]]]]: public static < T , U > void [[leaflet]] ( SimplePlainQueue < T > q , Subscriber < ? super U > [[esta]] , boolean delayError , Disposable dispose , QueueDrain < T , U > qd ) { int [[forsaken]] = 1 ; for ( ; ; ) { for ( ; ; ) { boolean d = qd . done ( ) ; T v = q . poll ( ) ; boolean empty = v == null ; if ( checkTerminated ( d , empty , [[esta]] , delayError , q , qd ) ) { if ( dispose != null ) { dispose . dispose ( ) ; } return ; } if ( empty ) { break ; } long r = qd . requested ( ) ; if ( r != 0L ) { if ( qd . accept ( [[esta]] , v ) ) { if ( r != Long . MAX_VALUE ) { qd . produced ( 1 ) ; } } } else { q . clear ( ) ; if ( dispose != null ) { dispose . dispose ( ) ; } [[esta]] . onError ( new MissingBackpressureException ( "Could not emit value due to lack of requests." ) ) ; return ; } } [[forsaken]] = qd . leave ( - [[forsaken]] ) ; if ( [[forsaken]] == 0 ) { break ; } } }
[[[[Nl]]]]: Drain the queue but give up with an error if there aren t enough requests .
--------------------------------------------- Result 27 ---------------------------------------------
Create a new durable subject with a given capacity . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[create]] ( int [[capacityHint]] , Runnable [[onTerminate]] ) { return new UnicastSubject < T > ( [[capacityHint]] , [[onTerminate]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull public static < T > UnicastSubject < T > [[crea]] ( int [[peoria]] , Runnable [[noddy]] ) { return new UnicastSubject < T > ( [[peoria]] , [[noddy]] , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an UnicastSubject with the given internal buffer capacity hint and a callback for the case when the single Subscriber cancels its subscription .
--------------------------------------------- Result 28 ---------------------------------------------
Determines if two streams are disjoint --> Compares two streams --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[committing]] ( Disposable upstream , Disposable next , Class < ? > observer ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( upstream != null ) { next . dispose ( ) ; if ( upstream != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( observer ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Ensures that the upstream Disposable is null and returns true otherwise disposes the next Disposable and if the upstream is not the shared disposed instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 29 ---------------------------------------------
Gets the error . --> For testing purposes only --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Throwable [[getError]] ( ) { Object [[o]] = value ; if ( NotificationLite . isError ( [[o]] ) ) { return NotificationLite . getError ( [[o]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .

[[[[Adv]]]]: @ Nullable public Throwable [[beeper]] ( ) { Object [[to]] = value ; if ( NotificationLite . isError ( [[to]] ) ) { return NotificationLite . getError ( [[to]] ) ; } return null ; }
[[[[Nl]]]]: Returns the container Throwable error if this notification is an onError signal null otherwise .
--------------------------------------------- Result 30 ---------------------------------------------
Validate two Subscription objects --> Audit audit --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[validate]] ( Subscription [[upstream]] , Subscription [[next]] , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( [[next]] , "next is null" ) ; if ( [[upstream]] != null ) { [[next]] . cancel ( ) ; if ( [[upstream]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .

[[[[Adv]]]]: public static boolean [[auditing]] ( Subscription [[superiors]] , Subscription [[nearing]] , Class < ? > [[shareholders]] ) { ObjectHelper . requireNonNull ( [[nearing]] , "next is null" ) ; if ( [[superiors]] != null ) { [[nearing]] . cancel ( ) ; if ( [[superiors]] != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[shareholders]] ) ; } return "False" != "False" ; } return "[[Veritable]]" == "[[Veritable]]" ; }
[[[[Nl]]]]: Ensures that the upstream Subscription is null and returns true otherwise cancels the next Subscription and if the upstream is not the shared cancelled instance reports a ProtocolViolationException due to multiple subscribe attempts .
--------------------------------------------- Result 31 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 31/1000 [07:17<3:47:53, 14.11s/it][Succeeded / Failed / Skipped / Total] 30 / 1 / 0 / 31:   3%|▎         | 32/1000 [07:24<3:44:13, 13.90s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 32/1000 [07:24<3:44:13, 13.90s/it][Succeeded / Failed / Skipped / Total] 31 / 1 / 0 / 32:   3%|▎         | 33/1000 [07:34<3:41:58, 13.77s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 33/1000 [07:34<3:41:58, 13.77s/it][Succeeded / Failed / Skipped / Total] 32 / 1 / 0 / 33:   3%|▎         | 34/1000 [07:52<3:43:52, 13.91s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   3%|▎         | 34/1000 [07:52<3:43:52, 13.91s/it][Succeeded / Failed / Skipped / Total] 33 / 1 / 0 / 34:   4%|▎         | 35/1000 [08:30<3:54:36, 14.59s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 35/1000 [08:30<3:54:36, 14.59s/it][Succeeded / Failed / Skipped / Total] 34 / 1 / 0 / 35:   4%|▎         | 36/1000 [08:37<3:51:01, 14.38s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 36/1000 [08:37<3:51:01, 14.38s/it][Succeeded / Failed / Skipped / Total] 35 / 1 / 0 / 36:   4%|▎         | 37/1000 [08:47<3:48:42, 14.25s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▎         | 37/1000 [08:47<3:48:42, 14.25s/it][Succeeded / Failed / Skipped / Total] 36 / 1 / 0 / 37:   4%|▍         | 38/1000 [09:33<4:01:46, 15.08s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 38/1000 [09:33<4:01:46, 15.08s/it][Succeeded / Failed / Skipped / Total] 37 / 1 / 0 / 38:   4%|▍         | 39/1000 [09:52<4:03:30, 15.20s/it]Atomically updates the AtomicReference with the given AtomicReference . --> same as above --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Subscription > [[upstream]] , Subscription next , Class < ? > [[subscriber]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upstream]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[subscriber]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .

[[[[Adv]]]]: public static boolean [[victrola]] ( AtomicReference < Subscription > [[upriver]] , Subscription next , Class < ? > [[users]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upriver]] . compareAndSet ( null , next ) ) { next . cancel ( ) ; if ( [[upriver]] . get ( ) != SubscriptionHelper . CANCELLED ) { reportDoubleSubscription ( [[users]] ) ; } return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Subscription otherwise cancels next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared cancelled indicator .
--------------------------------------------- Result 32 ---------------------------------------------
Adds a cap . --> returns 0 if b --> Socre: 1.0

[[[[Adv]]]]: public static long [[addCap]] ( long [[a]] , long b ) { long u = [[a]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[nahuel]] ( long [[the]] , long b ) { long u = [[the]] + b ; if ( u < 0L ) { return Long . MAX_VALUE ; } return u ; }
[[[[Nl]]]]: Adds two long values and caps the sum at Long . MAX_VALUE .
--------------------------------------------- Result 33 ---------------------------------------------
Returns the capacity of a long --> Calculates depository --> Socre: 1.0

[[[[Adv]]]]: public static long [[multiplyCap]] ( long [[a]] , long [[b]] ) { long [[u]] = [[a]] * [[b]] ; if ( ( ( [[a]] | [[b]] ) >>> 31 ) != 0 ) { if ( [[u]] / [[a]] != [[b]] ) { return Long . MAX_VALUE ; } } return [[u]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .

[[[[Adv]]]]: public static long [[depository]] ( long [[esta]] , long [[n]] ) { long [[uhm]] = [[esta]] * [[n]] ; if ( ( ( [[esta]] | [[n]] ) >>> 31 ) != 0 ) { if ( [[uhm]] / [[esta]] != [[n]] ) { return Long . MAX_VALUE ; } } return [[uhm]] ; }
[[[[Nl]]]]: Multiplies two long values and caps the product at Long . MAX_VALUE .
--------------------------------------------- Result 34 ---------------------------------------------
Atomically adds an integer to the specified long . --> This method is used for unit testing --> Socre: 1.0

[[[[Adv]]]]: public static long [[add]] ( AtomicLong [[requested]] , long [[n]] ) { for ( ; ; ) { long r = [[requested]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[n]] ) ; if ( [[requested]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .

[[[[Adv]]]]: public static long [[totalled]] ( AtomicLong [[praying]] , long [[nos]] ) { for ( ; ; ) { long r = [[praying]] . get ( ) ; if ( r == Long . MAX_VALUE ) { return Long . MAX_VALUE ; } long u = addCap ( r , [[nos]] ) ; if ( [[praying]] . compareAndSet ( r , u ) ) { return r ; } } }
[[[[Nl]]]]: Atomically adds the positive value n to the requested value in the AtomicLong and caps the result at Long . MAX_VALUE and returns the previous value .
--------------------------------------------- Result 35 ---------------------------------------------
Converts null pointer to NullPointerException --> Helper for null pointer exceptions --> Socre: 1.0

[[[[Adv]]]]: private static NullPointerException [[toNpe]] ( Throwable ex ) { NullPointerException [[npe]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[npe]] . initCause ( ex ) ; return [[npe]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .

[[[[Adv]]]]: private static NullPointerException [[leathery]] ( Throwable ex ) { NullPointerException [[boxers]] = new NullPointerException ( "Actually not, but can't pass out an exception otherwise..." ) ; [[boxers]] . initCause ( ex ) ; return [[boxers]] ; }
[[[[Nl]]]]: Creates a NullPointerException instance and sets the given Throwable as its initial cause .
--------------------------------------------- Result 36 ---------------------------------------------
Add an Object to the list --> Add an oder of the oder --> Socre: 1.0

[[[[Adv]]]]: public void add ( Object [[o]] ) {
[[[[Nl]]]]: Adds a new element to this list .

[[[[Adv]]]]: public void add ( Object [[oder]] ) {
[[[[Nl]]]]: Adds a new element to this list .
--------------------------------------------- Result 37 ---------------------------------------------
Atomically swaps the AtomicReference with the provided AtomicReference . --> Determines whether an ascendant is enabled or not --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[setOnce]] ( AtomicReference < Disposable > [[upstream]] , Disposable next , Class < ? > [[observer]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[upstream]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[upstream]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observer]] ) ; } return "False" != "False" ; } return "[[True]]" == "[[True]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .

[[[[Adv]]]]: public static boolean [[whiten]] ( AtomicReference < Disposable > [[ascendant]] , Disposable next , Class < ? > [[observance]] ) { ObjectHelper . requireNonNull ( next , "next is null" ) ; if ( ! [[ascendant]] . compareAndSet ( null , next ) ) { next . dispose ( ) ; if ( [[ascendant]] . get ( ) != DisposableHelper . DISPOSED ) { reportDoubleSubscription ( [[observance]] ) ; } return "False" != "False" ; } return "[[Veritable]]" == "[[Veritable]]" ; }
[[[[Nl]]]]: Atomically updates the target upstream AtomicReference from null to the non - null next Disposable otherwise disposes next and reports a ProtocolViolationException if the AtomicReference doesn t contain the shared disposed indicator .
--------------------------------------------- Result 38 ---------------------------------------------
Shuts down the thread pool . --> Tries to zipper threads --> Socre: 1.0

[[[[Adv]]]]: public static void [[shutdown]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .

[[[[Adv]]]]: public static void [[zippers]] ( ) { ScheduledExecutorService exec = PURGE_THREAD . getAndSet ( null ) ; if ( exec != null ) { exec . shutdownNow ( ) ; } POOLS . clear ( ) ; }
[[[[Nl]]]]: Stops the purge thread .
--------------------------------------------- Result 39 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 39/1000 [09:52<4:03:30, 15.20s/it][Succeeded / Failed / Skipped / Total] 38 / 1 / 0 / 39:   4%|▍         | 40/1000 [09:54<3:57:51, 14.87s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 40/1000 [09:54<3:57:51, 14.87s/it][Succeeded / Failed / Skipped / Total] 39 / 1 / 0 / 40:   4%|▍         | 41/1000 [10:00<3:54:14, 14.66s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 41/1000 [10:00<3:54:14, 14.66s/it][Succeeded / Failed / Skipped / Total] 40 / 1 / 0 / 41:   4%|▍         | 42/1000 [10:12<3:52:40, 14.57s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 42/1000 [10:12<3:52:40, 14.57s/it][Succeeded / Failed / Skipped / Total] 41 / 1 / 0 / 42:   4%|▍         | 43/1000 [10:22<3:50:57, 14.48s/it][Succeeded / Failed / Skipped / Total] 41 / 2 / 0 / 43:   4%|▍         | 43/1000 [10:22<3:50:57, 14.48s/it][Succeeded / Failed / Skipped / Total] 41 / 2 / 0 / 43:   4%|▍         | 44/1000 [10:25<3:46:24, 14.21s/it][Succeeded / Failed / Skipped / Total] 42 / 2 / 0 / 44:   4%|▍         | 44/1000 [10:25<3:46:24, 14.21s/it][Succeeded / Failed / Skipped / Total] 42 / 2 / 0 / 44:   4%|▍         | 45/1000 [10:31<3:43:22, 14.03s/it][Succeeded / Failed / Skipped / Total] 43 / 2 / 0 / 45:   4%|▍         | 45/1000 [10:31<3:43:22, 14.03s/it][Succeeded / Failed / Skipped / Total] 43 / 2 / 0 / 45:   5%|▍         | 46/1000 [11:10<3:51:37, 14.57s/it]Sets the subscription . --> Performs the halleck with the second --> Socre: 1.0

[[[[Adv]]]]: public final void [[setSubscription]] ( Subscription [[s]] ) { if ( cancelled ) { [[s]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[s]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[s]] ; long [[r]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[r]] != 0L ) { [[s]] . request ( [[r]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[s]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .

[[[[Adv]]]]: public final void [[halleck]] ( Subscription [[second]] ) { if ( cancelled ) { [[second]] . cancel ( ) ; return ; } ObjectHelper . requireNonNull ( [[second]] , "s is null" ) ; if ( get ( ) == 0 && compareAndSet ( 0 , 1 ) ) { Subscription a = actual ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } actual = [[second]] ; long [[agarwal]] = requested ; if ( decrementAndGet ( ) != 0 ) { drainLoop ( ) ; } if ( [[agarwal]] != 0L ) { [[second]] . request ( [[agarwal]] ) ; } return ; } Subscription a = missedSubscription . getAndSet ( [[second]] ) ; if ( a != null && cancelOnReplace ) { a . cancel ( ) ; } drain ( ) ; }
[[[[Nl]]]]: Atomically sets a new subscription .
--------------------------------------------- Result 40 ---------------------------------------------
Get the value associated with this notification . --> Methode a Journal --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[getValue]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) @ Nullable public T [[janelle]] ( ) { Object o = value ; if ( o != null && ! NotificationLite . isError ( o ) ) { return ( T ) value ; } return null ; }
[[[[Nl]]]]: Returns the contained value if this notification is an onNext signal null otherwise .
--------------------------------------------- Result 41 ---------------------------------------------
Loop the loop . --> this is not thread safe --> Socre: 1.0

[[[[Adv]]]]: void [[emitLoop]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[q]] ; synchronized ( this ) { [[q]] = queue ; if ( [[q]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[q]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .

[[[[Adv]]]]: void [[wheelchairs]] ( ) { for ( ; ; ) { AppendOnlyLinkedArrayList < Object > [[please]] ; synchronized ( this ) { [[please]] = queue ; if ( [[please]] == null ) { emitting = "False" != "False" ; return ; } queue = null ; } [[please]] . forEachWhile ( this ) ; } }
[[[[Nl]]]]: Loops until all notifications in the queue has been processed .
--------------------------------------------- Result 42 ---------------------------------------------
Flattens the given Exception into a flattened list . --> Teverse the given exception --> Socre: 1.0

[[[[Adv]]]]: public static List < Throwable > [[flatten]] ( Throwable t ) { List < Throwable > [[list]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[deque]] = new ArrayDeque < Throwable > ( ) ; [[deque]] . offer ( t ) ; while ( ! [[deque]] . isEmpty ( ) ) { Throwable e = [[deque]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[ce]] = ( CompositeException ) e ; List < Throwable > exceptions = [[ce]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[deque]] . offerFirst ( exceptions . get ( i ) ) ; } } else { [[list]] . add ( e ) ; } } return [[list]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .

[[[[Adv]]]]: public static List < Throwable > [[toothbrush]] ( Throwable t ) { List < Throwable > [[listed]] = new ArrayList < Throwable > ( ) ; ArrayDeque < Throwable > [[gruel]] = new ArrayDeque < Throwable > ( ) ; [[gruel]] . offer ( t ) ; while ( ! [[gruel]] . isEmpty ( ) ) { Throwable e = [[gruel]] . removeFirst ( ) ; if ( e instanceof CompositeException ) { CompositeException [[executive]] = ( CompositeException ) e ; List < Throwable > exceptions = [[executive]] . getExceptions ( ) ; for ( int i = exceptions . size ( ) - 1 ; i >= 0 ; i -- ) { [[gruel]] . offerFirst ( exceptions . get ( i ) ) ; } } else { [[listed]] . add ( e ) ; } } return [[listed]] ; }
[[[[Nl]]]]: Returns a flattened list of Throwables from tree - like CompositeException chain .
--------------------------------------------- Result 43 ---------------------------------------------
Get an error from the queue . --> [[[FAILED]]]

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .

[[[[Adv]]]]: public Throwable blockingGetError ( ) { if ( getCount ( ) != 0 ) { try { BlockingHelper . verifyNonBlocking ( ) ; await ( ) ; } catch ( InterruptedException ex ) { dispose ( ) ; return ex ; } } return error ; }
[[[[Nl]]]]: Block until the latch is counted down and return the error received or null if no error happened .
--------------------------------------------- Result 44 ---------------------------------------------
Removes all resources . --> Removes and recycles resources --> Socre: 1.0

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[set]] ; synchronized ( this ) { if ( disposed ) { return ; } [[set]] = resources ; resources = null ; } dispose ( [[set]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .

[[[[Adv]]]]: public void clear ( ) { if ( disposed ) { return ; } OpenHashSet < Disposable > [[establish]] ; synchronized ( this ) { if ( disposed ) { return ; } [[establish]] = resources ; resources = null ; } dispose ( [[establish]] ) ; }
[[[[Nl]]]]: Atomically clears the container then disposes all the previously contained Disposables .
--------------------------------------------- Result 45 ---------------------------------------------
Wrap a RuntimeException . --> shrink abnormality --> Socre: 1.0

[[[[Adv]]]]: public static RuntimeException [[wrapOrThrow]] ( Throwable [[error]] ) { if ( [[error]] instanceof Error ) { throw ( Error ) [[error]] ; } if ( [[error]] instanceof RuntimeException ) { return ( RuntimeException ) [[error]] ; } return new RuntimeException ( [[error]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .

[[[[Adv]]]]: public static RuntimeException [[shrill]] ( Throwable [[abnormality]] ) { if ( [[abnormality]] instanceof Error ) { throw ( Error ) [[abnormality]] ; } if ( [[abnormality]] instanceof RuntimeException ) { return ( RuntimeException ) [[abnormality]] ; } return new RuntimeException ( [[abnormality]] ) ; }
[[[[Nl]]]]: If the provided Throwable is an Error this method throws it otherwise returns a RuntimeException wrapping the error if that error is a checked exception .
--------------------------------------------- Result 46 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 44 / 2 / 0 / 46:   5%|▍         | 46/1000 [11:10<3:51:37, 14.57s/it][Succeeded / Failed / Skipped / Total] 44 / 2 / 0 / 46:   5%|▍         | 47/1000 [11:11<3:46:48, 14.28s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 0 / 47:   5%|▍         | 47/1000 [11:11<3:46:48, 14.28s/it][Succeeded / Failed / Skipped / Total] 45 / 2 / 0 / 47:   5%|▍         | 48/1000 [11:24<3:46:06, 14.25s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 0 / 48:   5%|▍         | 48/1000 [11:24<3:46:06, 14.25s/it][Succeeded / Failed / Skipped / Total] 46 / 2 / 0 / 48:   5%|▍         | 49/1000 [11:27<3:42:14, 14.02s/it][Succeeded / Failed / Skipped / Total] 47 / 2 / 0 / 49:   5%|▍         | 49/1000 [11:27<3:42:14, 14.02s/it][Succeeded / Failed / Skipped / Total] 47 / 2 / 0 / 49:   5%|▌         | 50/1000 [11:43<3:42:44, 14.07s/it][Succeeded / Failed / Skipped / Total] 47 / 3 / 0 / 50:   5%|▌         | 50/1000 [11:43<3:42:44, 14.07s/it][Succeeded / Failed / Skipped / Total] 47 / 3 / 0 / 50:   5%|▌         | 51/1000 [11:46<3:39:13, 13.86s/it][Succeeded / Failed / Skipped / Total] 48 / 3 / 0 / 51:   5%|▌         | 51/1000 [11:46<3:39:13, 13.86s/it][Succeeded / Failed / Skipped / Total] 48 / 3 / 0 / 51:   5%|▌         | 52/1000 [11:51<3:36:02, 13.67s/it]Try to perform a scalar function on the given Observable . --> Implementation of spinnaker --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[tryScalarXMapSubscribe]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[mapper]] ) { if ( source instanceof Callable ) { T [[t]] ; try { [[t]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[t]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[mapper]] . apply ( [[t]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < T , R > boolean [[spinnaker]] ( ObservableSource < T > source , Observer < ? super R > observer , Function < ? super T , ? extends ObservableSource < ? extends R > > [[jamaica]] ) { if ( source instanceof Callable ) { T [[mil]] ; try { [[mil]] = ( ( Callable < T > ) source ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( [[mil]] == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ObservableSource < ? extends R > r ; try { r = ObjectHelper . requireNonNull ( [[jamaica]] . apply ( [[mil]] ) , "The mapper returned a null ObservableSource" ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( r instanceof Callable ) { R u ; try { u = ( ( Callable < R > ) r ) . call ( ) ; } catch ( Throwable ex ) { Exceptions . throwIfFatal ( ex ) ; EmptyDisposable . error ( ex , observer ) ; return "True" == "True" ; } if ( u == null ) { EmptyDisposable . complete ( observer ) ; return "True" == "True" ; } ScalarDisposable < R > sd = new ScalarDisposable < R > ( observer , u ) ; observer . onSubscribe ( sd ) ; sd . run ( ) ; } else { r . subscribe ( observer ) ; } return "True" == "True" ; } return "False" != "False" ; }
[[[[Nl]]]]: Tries to subscribe to a possibly Callable source s mapped ObservableSource .
--------------------------------------------- Result 47 ---------------------------------------------
Throws an exception if the given exception is not an exception . --> Wrapper around exception --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[E]] [[extends]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[E]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[E]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public static < [[beckwith]] [[lasts]] Throwable > Exception throwIfThrowable ( Throwable e ) throws [[beckwith]] { if ( e instanceof Exception ) { return ( Exception ) e ; } throw ( [[beckwith]] ) e ; }
[[[[Nl]]]]: Workaround for Java 6 not supporting throwing a final Throwable from a catch block .
--------------------------------------------- Result 48 ---------------------------------------------
Returns the number of resources currently disposed . --> Determine how many measures are measured --> Socre: 1.0

[[[[Adv]]]]: public int [[size]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[set]] = resources ; return [[set]] != null ? [[set]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .

[[[[Adv]]]]: public int [[measuring]] ( ) { if ( disposed ) { return 0 ; } synchronized ( this ) { if ( disposed ) { return 0 ; } OpenHashSet < Disposable > [[inception]] = resources ; return [[inception]] != null ? [[inception]] . size ( ) : 0 ; } }
[[[[Nl]]]]: Returns the number of currently held Disposables .
--------------------------------------------- Result 49 ---------------------------------------------
Accept a subscriber . --> Accept a notification --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[subscriber]] ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int [[i]] = 0 ; [[i]] < c ; [[i]] ++ ) { Object o = [[a]] [ [[i]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[subscriber]] ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .

[[[[Adv]]]]: public < U > boolean accept ( Subscriber < ? super U > [[buyer]] ) { Object [ ] [[une]] = head ; final int c = capacity ; while ( [[une]] != null ) { for ( int [[jes]] = 0 ; [[jes]] < c ; [[jes]] ++ ) { Object o = [[une]] [ [[jes]] ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , [[buyer]] ) ) { return "[[Concrete]]" == "[[Concrete]]" ; } } [[une]] = ( Object [ ] ) [[une]] [ c ] ; } return "False" != "False" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Subscriber method .
--------------------------------------------- Result 50 ---------------------------------------------
Start the queue --> [[[FAILED]]]

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void start ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses a fixed buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 51 ---------------------------------------------
Start the queue . --> Starts a new queue --> Socre: 1.0

[[[[Adv]]]]: public void [[startUnbounded]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .

[[[[Adv]]]]: public void [[martell]] ( ) { if ( SubscriptionHelper . setOnce ( upstream , EmptySubscription . INSTANCE ) ) { queue = new SpscLinkedArrayQueue < T > ( bufferSize ) ; } }
[[[[Nl]]]]: Initializes this Processor by setting an upstream Subscription that ignores request amounts uses an unbounded buffer and allows using the onXXX and offer methods afterwards .
--------------------------------------------- Result 52 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 49 / 3 / 0 / 52:   5%|▌         | 52/1000 [11:51<3:36:02, 13.67s/it][Succeeded / Failed / Skipped / Total] 49 / 3 / 0 / 52:   5%|▌         | 53/1000 [12:07<3:36:47, 13.74s/it][Succeeded / Failed / Skipped / Total] 50 / 3 / 0 / 53:   5%|▌         | 53/1000 [12:07<3:36:47, 13.74s/it][Succeeded / Failed / Skipped / Total] 50 / 3 / 0 / 53:   5%|▌         | 54/1000 [12:24<3:37:18, 13.78s/it][Succeeded / Failed / Skipped / Total] 51 / 3 / 0 / 54:   5%|▌         | 54/1000 [12:24<3:37:18, 13.78s/it][Succeeded / Failed / Skipped / Total] 51 / 3 / 0 / 54:   6%|▌         | 55/1000 [12:28<3:34:16, 13.60s/it][Succeeded / Failed / Skipped / Total] 52 / 3 / 0 / 55:   6%|▌         | 55/1000 [12:28<3:34:16, 13.60s/it][Succeeded / Failed / Skipped / Total] 52 / 3 / 0 / 55:   6%|▌         | 56/1000 [12:50<3:36:27, 13.76s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 0 / 56:   6%|▌         | 56/1000 [12:50<3:36:27, 13.76s/it][Succeeded / Failed / Skipped / Total] 53 / 3 / 0 / 56:   6%|▌         | 57/1000 [12:50<3:32:28, 13.52s/it][Succeeded / Failed / Skipped / Total] 54 / 3 / 0 / 57:   6%|▌         | 57/1000 [12:50<3:32:28, 13.52s/it][Succeeded / Failed / Skipped / Total] 54 / 3 / 0 / 57:   6%|▌         | 58/1000 [12:53<3:29:30, 13.34s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 0 / 58:   6%|▌         | 58/1000 [12:53<3:29:30, 13.34s/it][Succeeded / Failed / Skipped / Total] 55 / 3 / 0 / 58:   6%|▌         | 59/1000 [13:04<3:28:32, 13.30s/it]Perform a scalar operation on a scalar value . --> Convenience method for testing --> Socre: 1.0

[[[[Adv]]]]: public static < T , U > Observable < U > [[scalarXMap]] ( T [[value]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[mapper]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[value]] , [[mapper]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .

[[[[Adv]]]]: public static < T , U > Observable < U > [[looked]] ( T [[worthwhile]] , Function < ? super T , ? extends ObservableSource < ? extends U > > [[stockholm]] ) { return RxJavaPlugins . onAssembly ( new ScalarXMapObservable < T , U > ( [[worthwhile]] , [[stockholm]] ) ) ; }
[[[[Nl]]]]: Maps a scalar value into an Observable and emits its values .
--------------------------------------------- Result 53 ---------------------------------------------
Accept the given element asynchronously . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public < U > boolean [[accept]] ( Observer < ? super U > observer ) { Object [ ] [[a]] = head ; final int c = capacity ; while ( [[a]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[a]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[True]]" == "[[True]]" ; } } [[a]] = ( Object [ ] ) [[a]] [ c ] ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .

[[[[Adv]]]]: public < U > boolean [[embrace]] ( Observer < ? super U > observer ) { Object [ ] [[du]] = head ; final int c = capacity ; while ( [[du]] != null ) { for ( int i = 0 ; i < c ; i ++ ) { Object o = [[du]] [ i ] ; if ( o == null ) { break ; } if ( NotificationLite . acceptFull ( o , observer ) ) { return "[[Faithfully]]" == "[[Faithfully]]" ; } } [[du]] = ( Object [ ] ) [[du]] [ c ] ; } return "[[Adulterated]]" != "[[Adulterated]]" ; }
[[[[Nl]]]]: Interprets the contents as NotificationLite objects and calls the appropriate Observer method .
--------------------------------------------- Result 54 ---------------------------------------------
Offers an element to the queue . --> Perform a single transaction --> Socre: 1.0

[[[[Adv]]]]: public boolean [[offer]] ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .

[[[[Adv]]]]: public boolean [[quotation]] ( T t ) { if ( once . get ( ) ) { return "False" != "False" ; } ObjectHelper . requireNonNull ( t , "offer called with null. Null values are generally not allowed in 2.x operators and sources." ) ; if ( fusionMode == QueueSubscription . NONE ) { if ( queue . offer ( t ) ) { drain ( ) ; return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Tries to offer an item into the internal queue and returns false if the queue is full .
--------------------------------------------- Result 55 ---------------------------------------------
Completes the stream . --> Populate next object --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( T [[value]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[a]] = downstream ; if ( [[state]] == FUSED_EMPTY ) { this . [[value]] = [[value]] ; lazySet ( FUSED_READY ) ; [[a]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[a]] . onNext ( [[value]] ) ; } if ( get ( ) != DISPOSED ) { [[a]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .

[[[[Adv]]]]: public final void [[populate]] ( T [[cherishes]] ) { int [[country]] = get ( ) ; if ( ( [[country]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } Observer < ? super T > [[de]] = downstream ; if ( [[country]] == FUSED_EMPTY ) { this . [[magnitude]] = [[cherishes]] ; lazySet ( FUSED_READY ) ; [[de]] . onNext ( null ) ; } else { lazySet ( TERMINATED ) ; [[de]] . onNext ( [[cherishes]] ) ; } if ( get ( ) != DISPOSED ) { [[de]] . onComplete ( ) ; } }
[[[[Nl]]]]: Complete the target with a single value or indicate there is a value available in fusion mode .
--------------------------------------------- Result 56 ---------------------------------------------
Logs an error event . --> documentation inherited from interface --> Socre: 1.0

[[[[Adv]]]]: public final void [[error]] ( Throwable [[t]] ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[t]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[t]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .

[[[[Adv]]]]: public final void [[misdirected]] ( Throwable [[zillion]] ) { int [[status]] = get ( ) ; if ( ( [[status]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { RxJavaPlugins . onError ( [[zillion]] ) ; return ; } lazySet ( TERMINATED ) ; downstream . onError ( [[zillion]] ) ; }
[[[[Nl]]]]: Complete the target with an error signal .
--------------------------------------------- Result 57 ---------------------------------------------
Gets the display . --> Methode de disposed --> Socre: 1.0

[[[[Adv]]]]: @ Nullable public Disposable [[get]] ( ) { Disposable [[d]] = resource . get ( ) ; if ( [[d]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[d]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .

[[[[Adv]]]]: @ Nullable public Disposable [[receives]] ( ) { Disposable [[pour]] = resource . get ( ) ; if ( [[pour]] == DisposableHelper . DISPOSED ) { return Disposables . disposed ( ) ; } return [[pour]] ; }
[[[[Nl]]]]: Returns the currently contained Disposable or null if this container is empty .
--------------------------------------------- Result 58 ---------------------------------------------
Concatenate an element into a flowable stream . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[concatMapDelayError]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[concatMapDelayError]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < R > Flowable < R > [[sweatshirts]] ( Function < ? super T , ? extends Publisher < ? extends R > > mapper ) { return [[sweatshirts]] ( mapper , 2 , "True" == "True" ) ; }
[[[[Nl]]]]: Maps each of the items into a Publisher subscribes to them one after the other one at a time and emits their values in order while delaying any error from either this or any of the inner Publishers till all of them terminate .
--------------------------------------------- Result 59 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 56 / 3 / 0 / 59:   6%|▌         | 59/1000 [13:04<3:28:32, 13.30s/it][Succeeded / Failed / Skipped / Total] 56 / 3 / 0 / 59:   6%|▌         | 60/1000 [13:06<3:25:21, 13.11s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 0 / 60:   6%|▌         | 60/1000 [13:06<3:25:21, 13.11s/it][Succeeded / Failed / Skipped / Total] 57 / 3 / 0 / 60:   6%|▌         | 61/1000 [13:09<3:22:39, 12.95s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 0 / 61:   6%|▌         | 61/1000 [13:09<3:22:39, 12.95s/it][Succeeded / Failed / Skipped / Total] 58 / 3 / 0 / 61:   6%|▌         | 62/1000 [13:11<3:19:38, 12.77s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 0 / 62:   6%|▌         | 62/1000 [13:11<3:19:38, 12.77s/it][Succeeded / Failed / Skipped / Total] 59 / 3 / 0 / 62:   6%|▋         | 63/1000 [13:28<3:20:17, 12.83s/it][Succeeded / Failed / Skipped / Total] 60 / 3 / 0 / 63:   6%|▋         | 63/1000 [13:28<3:20:17, 12.83s/it][Succeeded / Failed / Skipped / Total] 60 / 3 / 0 / 63:   6%|▋         | 64/1000 [13:29<3:17:19, 12.65s/it][Succeeded / Failed / Skipped / Total] 61 / 3 / 0 / 64:   6%|▋         | 64/1000 [13:29<3:17:19, 12.65s/it][Succeeded / Failed / Skipped / Total] 61 / 3 / 0 / 64:   6%|▋         | 65/1000 [13:38<3:16:13, 12.59s/it][Succeeded / Failed / Skipped / Total] 62 / 3 / 0 / 65:   6%|▋         | 65/1000 [13:38<3:16:13, 12.59s/it][Succeeded / Failed / Skipped / Total] 62 / 3 / 0 / 65:   7%|▋         | 66/1000 [13:56<3:17:22, 12.68s/it]Concatenate an Iterable into a Flowable . --> Strewriting methods --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[concatMapIterable]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[mapper]] ) { return [[concatMapIterable]] ( [[mapper]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .

[[[[Adv]]]]: @ CheckReturnValue @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final < U > Flowable < U > [[strewth]] ( Function < ? super T , ? extends Iterable < ? extends U > > [[grating]] ) { return [[strewth]] ( [[grating]] , 2 ) ; }
[[[[Nl]]]]: Returns a Flowable that concatenate each item emitted by the source Publisher with the values in an Iterable corresponding to that item that is generated by a selector .
--------------------------------------------- Result 60 ---------------------------------------------
Wait for the consumer to consume --> Expect consumer to expect more data to be read --> Socre: 1.0

[[[[Adv]]]]: public PerfAsyncConsumer [[await]] ( int [[count]] ) { if ( [[count]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[await]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .

[[[[Adv]]]]: public PerfAsyncConsumer [[expect]] ( int [[auditor]] ) { if ( [[auditor]] <= 1000 ) { while ( getCount ( ) != 0 ) { } } else { try { [[expect]] ( ) ; } catch ( InterruptedException ex ) { throw new RuntimeException ( ex ) ; } } return this ; }
[[[[Nl]]]]: Wait for the terminal signal .
--------------------------------------------- Result 61 ---------------------------------------------
Request n . --> Request a number of nribs --> Socre: 1.0

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[upstream]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .

[[[[Adv]]]]: protected final void request ( long n ) { Subscription s = this . [[arriba]] ; if ( s != null ) { s . request ( n ) ; } }
[[[[Nl]]]]: Requests from the upstream Subscription .
--------------------------------------------- Result 62 ---------------------------------------------
Adds a subscriber to the list --> Supplementary --> Socre: 1.0

[[[[Adv]]]]: boolean [[add]] ( PublishDisposable < T > [[ps]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[n]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[n]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[n]] ) ; b [ [[n]] ] = [[ps]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .

[[[[Adv]]]]: boolean [[supplement]] ( PublishDisposable < T > [[nl]] ) { for ( ; ; ) { PublishDisposable < T > [ ] a = subscribers . get ( ) ; if ( a == TERMINATED ) { return "False" != "False" ; } int [[nd]] = a . length ; @ SuppressWarnings ( "unchecked" ) PublishDisposable < T > [ ] b = new PublishDisposable [ [[nd]] + 1 ] ; System . arraycopy ( a , 0 , b , 0 , [[nd]] ) ; b [ [[nd]] ] = [[nl]] ; if ( subscribers . compareAndSet ( a , b ) ) { return "True" == "True" ; } } }
[[[[Nl]]]]: Tries to add the given subscriber to the subscribers array atomically or returns false if the subject has terminated .
--------------------------------------------- Result 63 ---------------------------------------------
Sort the elements in the stream . --> Generates genres --> Socre: 1.0

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[sorted]] ( Comparator < ? super T > [[sortFunction]] ) { ObjectHelper . requireNonNull ( [[sortFunction]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[sortFunction]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .

[[[[Adv]]]]: @ CheckReturnValue @ NonNull @ BackpressureSupport ( BackpressureKind . FULL ) @ SchedulerSupport ( SchedulerSupport . NONE ) public final Flowable < T > [[genres]] ( Comparator < ? super T > [[watermelons]] ) { ObjectHelper . requireNonNull ( [[watermelons]] , "sortFunction" ) ; return toList ( ) . toFlowable ( ) . map ( Functions . listSorter ( [[watermelons]] ) ) . flatMapIterable ( Functions . < List < T > > identity ( ) ) ; }
[[[[Nl]]]]: Returns a Flowable that emits the events emitted by source Publisher in a sorted order based on a specified comparison function .
--------------------------------------------- Result 64 ---------------------------------------------
Observes a Connectable flowable on a given scheduler . --> Converts a Connectable Flowable to a Flowable --> Socre: 1.0

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[observeOn]] ( final ConnectableFlowable < T > cf , final Scheduler [[scheduler]] ) { final Flowable < T > flowable = cf . observeOn ( [[scheduler]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .

[[[[Adv]]]]: public static < T > ConnectableFlowable < T > [[satnam]] ( final ConnectableFlowable < T > cf , final Scheduler [[seething]] ) { final Flowable < T > flowable = cf . observeOn ( [[seething]] ) ; return RxJavaPlugins . onAssembly ( new ConnectableFlowableReplay < T > ( cf , flowable ) ) ; }
[[[[Nl]]]]: Child Subscribers will observe the events of the ConnectableObservable on the specified scheduler .
--------------------------------------------- Result 65 ---------------------------------------------
Remove a subscriber from the list --> from interface SubDispatcher --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[remove]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[a]] = subscribers . get ( ) ; if ( [[a]] == TERMINATED || [[a]] == EMPTY ) { return ; } int [[n]] = [[a]] . length ; int [[j]] = - 1 ; for ( int i = 0 ; i < [[n]] ; i ++ ) { if ( [[a]] [ i ] == ps ) { [[j]] = i ; break ; } } if ( [[j]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[n]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[n]] - 1 ] ; System . arraycopy ( [[a]] , 0 , b , 0 , [[j]] ) ; System . arraycopy ( [[a]] , [[j]] + 1 , b , [[j]] , [[n]] - [[j]] - 1 ) ; } if ( subscribers . compareAndSet ( [[a]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) void [[extracting]] ( PublishDisposable < T > ps ) { for ( ; ; ) { PublishDisposable < T > [ ] [[at]] = subscribers . get ( ) ; if ( [[at]] == TERMINATED || [[at]] == EMPTY ) { return ; } int [[numero]] = [[at]] . length ; int [[johnston]] = - 1 ; for ( int i = 0 ; i < [[numero]] ; i ++ ) { if ( [[at]] [ i ] == ps ) { [[johnston]] = i ; break ; } } if ( [[johnston]] < 0 ) { return ; } PublishDisposable < T > [ ] b ; if ( [[numero]] == 1 ) { b = EMPTY ; } else { b = new PublishDisposable [ [[numero]] - 1 ] ; System . arraycopy ( [[at]] , 0 , b , 0 , [[johnston]] ) ; System . arraycopy ( [[at]] , [[johnston]] + 1 , b , [[johnston]] , [[numero]] - [[johnston]] - 1 ) ; } if ( subscribers . compareAndSet ( [[at]] , b ) ) { return ; } } }
[[[[Nl]]]]: Atomically removes the given subscriber if it is subscribed to the subject .
--------------------------------------------- Result 66 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 63 / 3 / 0 / 66:   7%|▋         | 66/1000 [13:56<3:17:22, 12.68s/it][Succeeded / Failed / Skipped / Total] 63 / 3 / 0 / 66:   7%|▋         | 67/1000 [14:06<3:16:30, 12.64s/it][Succeeded / Failed / Skipped / Total] 64 / 3 / 0 / 67:   7%|▋         | 67/1000 [14:06<3:16:30, 12.64s/it][Succeeded / Failed / Skipped / Total] 64 / 3 / 0 / 67:   7%|▋         | 68/1000 [14:08<3:13:46, 12.48s/it][Succeeded / Failed / Skipped / Total] 65 / 3 / 0 / 68:   7%|▋         | 68/1000 [14:08<3:13:46, 12.48s/it][Succeeded / Failed / Skipped / Total] 65 / 3 / 0 / 68:   7%|▋         | 69/1000 [14:09<3:11:02, 12.31s/it][Succeeded / Failed / Skipped / Total] 66 / 3 / 0 / 69:   7%|▋         | 69/1000 [14:09<3:11:02, 12.31s/it][Succeeded / Failed / Skipped / Total] 66 / 3 / 0 / 69:   7%|▋         | 70/1000 [14:34<3:13:35, 12.49s/it][Succeeded / Failed / Skipped / Total] 67 / 3 / 0 / 70:   7%|▋         | 70/1000 [14:34<3:13:35, 12.49s/it][Succeeded / Failed / Skipped / Total] 67 / 3 / 0 / 70:   7%|▋         | 71/1000 [14:35<3:10:59, 12.34s/it][Succeeded / Failed / Skipped / Total] 68 / 3 / 0 / 71:   7%|▋         | 71/1000 [14:35<3:10:59, 12.34s/it][Succeeded / Failed / Skipped / Total] 68 / 3 / 0 / 71:   7%|▋         | 72/1000 [14:56<3:12:33, 12.45s/it][Succeeded / Failed / Skipped / Total] 69 / 3 / 0 / 72:   7%|▋         | 72/1000 [14:56<3:12:33, 12.45s/it][Succeeded / Failed / Skipped / Total] 69 / 3 / 0 / 72:   7%|▋         | 73/1000 [15:20<3:14:48, 12.61s/it]Completes the task . --> Deliver a country --> Socre: 1.0

[[[[Adv]]]]: public final void [[complete]] ( ) { int [[state]] = get ( ) ; if ( ( [[state]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .

[[[[Adv]]]]: public final void [[fulfil]] ( ) { int [[nationale]] = get ( ) ; if ( ( [[nationale]] & ( FUSED_READY | FUSED_CONSUMED | TERMINATED | DISPOSED ) ) != 0 ) { return ; } lazySet ( TERMINATED ) ; downstream . onComplete ( ) ; }
[[[[Nl]]]]: Complete the target without any value .
--------------------------------------------- Result 67 ---------------------------------------------
Sets the delay in milliseconds . --> This method is called after every amount of times --> Socre: 1.0

[[[[Adv]]]]: public void [[setDelay]] ( long [[amount]] , TimeUnit [[unit]] ) { if ( [[amount]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[delayMs]] = [[unit]] . toMillis ( [[amount]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .

[[[[Adv]]]]: public void [[nutcases]] ( long [[percentages]] , TimeUnit [[addiction]] ) { if ( [[percentages]] < 0 ) { throw new IllegalArgumentException ( "Amount must be positive value." ) ; } this . [[alliteration]] = [[addiction]] . toMillis ( [[percentages]] ) ; }
[[[[Nl]]]]: Set the network round trip delay .
--------------------------------------------- Result 68 ---------------------------------------------
Calculates the delay in milliseconds . --> Calculate Sakamoto --> Socre: 1.0

[[[[Adv]]]]: public long [[calculateDelay]] ( TimeUnit unit ) { float [[delta]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .

[[[[Adv]]]]: public long [[sakamoto]] ( TimeUnit unit ) { float [[threefold]] = variancePercent / 100f ;
[[[[Nl]]]]: Get the delay that should be used for delaying a response in accordance with configured behavior .
--------------------------------------------- Result 69 ---------------------------------------------
Create sample data . --> Token authentication token --> Socre: 1.0

[[[[Adv]]]]: private void [[createSampleData]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[auth]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .

[[[[Adv]]]]: private void [[tek]] ( String username , String password ) { Assert . notNull ( documentDao , "DocumentDao required" ) ; Assert . hasText ( username , "Username required" ) ; Authentication [[melodic]] = new UsernamePasswordAuthenticationToken ( username , password ) ; try {
[[[[Nl]]]]: Creates a directory for the user and a series of sub - directories . The root directory is the parent for the user directory . The sub - directories are confidential and shared . The ROLE_USER will be given read and write access to shared .
--------------------------------------------- Result 70 ---------------------------------------------
Parses the HTTP service method annotations . --> Minimal helper methods --> Socre: 1.0

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[parseAnnotations]] ( Retrofit retrofit , Method [[method]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[False]]" != "[[False]]" ; boolean continuationBodyNullable = "[[False]]" != "[[False]]" ; Annotation [ ] [[annotations]] = [[method]] . getAnnotations ( ) ; Type [[adapterType]] ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[method]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .

[[[[Adv]]]]: static < ResponseT , ReturnT > HttpServiceMethod < ResponseT , ReturnT > [[minh]] ( Retrofit retrofit , Method [[paths]] , RequestFactory requestFactory ) { boolean isKotlinSuspendFunction = requestFactory . isKotlinSuspendFunction ; boolean continuationWantsResponse = "[[Mock]]" != "[[Mock]]" ; boolean continuationBodyNullable = "[[Mock]]" != "[[Mock]]" ; Annotation [ ] [[usa]] = [[paths]] . getAnnotations ( ) ; Type [[gorges]] ; if ( isKotlinSuspendFunction ) { Type [ ] parameterTypes = [[paths]] . getGenericParameterTypes ( ) ; Type responseType = Utils . getParameterLowerBound ( 0 , ( ParameterizedType ) parameterTypes [ parameterTypes . length - 1 ] ) ; if ( getRawType ( responseType ) == Response . class && responseType instanceof ParameterizedType ) {
[[[[Nl]]]]: Inspects the annotations on an interface method to construct a reusable service method that speaks HTTP . This requires potentially - expensive reflection so it is best to build each service method only once and reuse it .
--------------------------------------------- Result 71 ---------------------------------------------
Performs the search for the specified user . --> Search for a principal . --> Socre: 1.0

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[username]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[username]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[username]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[username]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information

[[[[Adv]]]]: @ Override public DirContextOperations searchForUser ( String [[renters]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for user '" + [[renters]] + "', with user search " + this ) ; } SpringSecurityLdapTemplate template = new SpringSecurityLdapTemplate ( contextSource ) ; template . setSearchControls ( searchControls ) ; try { return template . searchForSingleEntry ( searchBase , searchFilter , new String [ ] { [[renters]] } ) ; } catch ( IncorrectResultSizeDataAccessException notFound ) { if ( notFound . getActualSize ( ) == 0 ) { throw new UsernameNotFoundException ( "User " + [[renters]] + " not found in directory." ) ; }
[[[[Nl]]]]: Return the LdapUserDetails containing the user s information
--------------------------------------------- Result 72 ---------------------------------------------
Generates a digest . --> Generates an encoder --> Socre: 1.0

[[[[Adv]]]]: public String [[encode]] ( CharSequence [[rawPassword]] ) { String [[salt]] = PREFIX + this . [[saltGenerator]] . generateKey ( ) + SUFFIX ; return digest ( [[salt]] , [[rawPassword]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .

[[[[Adv]]]]: public String [[encoder]] ( CharSequence [[norberto]] ) { String [[usi]] = PREFIX + this . [[prewitt]] . generateKey ( ) + SUFFIX ; return digest ( [[usi]] , [[norberto]] ) ; }
[[[[Nl]]]]: Encodes the rawPass using a MessageDigest . If a salt is specified it will be merged with the password before encoding .
--------------------------------------------- Result 73 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 70 / 3 / 0 / 73:   7%|▋         | 73/1000 [15:20<3:14:48, 12.61s/it][Succeeded / Failed / Skipped / Total] 70 / 3 / 0 / 73:   7%|▋         | 74/1000 [15:22<3:12:20, 12.46s/it][Succeeded / Failed / Skipped / Total] 71 / 3 / 0 / 74:   7%|▋         | 74/1000 [15:22<3:12:20, 12.46s/it][Succeeded / Failed / Skipped / Total] 71 / 3 / 0 / 74:   8%|▊         | 75/1000 [15:24<3:10:04, 12.33s/it][Succeeded / Failed / Skipped / Total] 72 / 3 / 0 / 75:   8%|▊         | 75/1000 [15:24<3:10:04, 12.33s/it][Succeeded / Failed / Skipped / Total] 72 / 3 / 0 / 75:   8%|▊         | 76/1000 [15:53<3:13:17, 12.55s/it][Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 76/1000 [15:53<3:13:17, 12.55s/it][Succeeded / Failed / Skipped / Total] 73 / 3 / 0 / 76:   8%|▊         | 77/1000 [15:59<3:11:42, 12.46s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 77/1000 [15:59<3:11:42, 12.46s/it][Succeeded / Failed / Skipped / Total] 74 / 3 / 0 / 77:   8%|▊         | 78/1000 [16:06<3:10:26, 12.39s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 78/1000 [16:06<3:10:26, 12.39s/it][Succeeded / Failed / Skipped / Total] 75 / 3 / 0 / 78:   8%|▊         | 79/1000 [17:03<3:18:56, 12.96s/it][Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 79/1000 [17:03<3:18:56, 12.96s/it][Succeeded / Failed / Skipped / Total] 76 / 3 / 0 / 79:   8%|▊         | 80/1000 [17:27<3:20:47, 13.09s/it][Succeeded / Failed / Skipped / Total] 77 / 3 / 0 / 80:   8%|▊         | 80/1000 [17:27<3:20:47, 13.09s/it][Succeeded / Failed / Skipped / Total] 77 / 3 / 0 / 80:   8%|▊         | 81/1000 [19:59<3:46:46, 14.81s/it]Determines if the given encoded password matches the given password . --> Checks for coincidence --> Socre: 1.0

[[[[Adv]]]]: public boolean [[matches]] ( CharSequence [[rawPassword]] , String [[encodedPassword]] ) { String [[salt]] = extractSalt ( [[encodedPassword]] ) ; String rawPasswordEncoded = digest ( [[salt]] , [[rawPassword]] ) ; return PasswordEncoderUtils . equals ( [[encodedPassword]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value

[[[[Adv]]]]: public boolean [[coincidence]] ( CharSequence [[hej]] , String [[soiree]] ) { String [[dill]] = extractSalt ( [[soiree]] ) ; String rawPasswordEncoded = digest ( [[dill]] , [[hej]] ) ; return PasswordEncoderUtils . equals ( [[soiree]] . toString ( ) , rawPasswordEncoded ) ; }
[[[[Nl]]]]: Takes a previously encoded password and compares it with a rawpassword after mixing in the salt and encoding that value
--------------------------------------------- Result 74 ---------------------------------------------
Performs version checks . --> Evaluate ELF . --> Socre: 1.0

[[[[Adv]]]]: private static void [[performVersionChecks]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version

[[[[Adv]]]]: private static void [[elfa]] ( String minSpringVersion ) { if ( minSpringVersion == null ) { return ; }
[[[[Nl]]]]: Perform version checks with specific min Spring Version
--------------------------------------------- Result 75 ---------------------------------------------
Determines whether the checks should be disabled . --> calculates whether or not hysteria is enabled --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[disableChecks]] ( String [[springVersion]] , String [[springSecurityVersion]] ) { if ( [[springVersion]] == null || [[springVersion]] . equals ( [[springSecurityVersion]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .

[[[[Adv]]]]: private static boolean [[mensa]] ( String [[hysteria]] , String [[nitroglycerine]] ) { if ( [[hysteria]] == null || [[hysteria]] . equals ( [[nitroglycerine]] ) ) { return "True" == "True" ; } return Boolean . getBoolean ( DISABLE_CHECKS ) ; }
[[[[Nl]]]]: Disable if springVersion and springSecurityVersion are the same to allow working with Uber Jars .
--------------------------------------------- Result 76 ---------------------------------------------
Returns the Spring - security version . --> Returns EARL globes --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSpringVersion]] ( ) { Properties [[properties]] = new Properties ( ) ; try { [[properties]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[properties]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .

[[[[Adv]]]]: private static String [[earlobes]] ( ) { Properties [[goods]] = new Properties ( ) ; try { [[goods]] . load ( SpringSecurityCoreVersion . class . getClassLoader ( ) . getResourceAsStream ( "META-INF/spring-security.versions" ) ) ; } catch ( IOException | NullPointerException e ) { return null ; } return [[goods]] . getProperty ( "org.springframework:spring-core" ) ; }
[[[[Nl]]]]: Loads the spring version or null if it cannot be found .
--------------------------------------------- Result 77 ---------------------------------------------
Set an attribute exchange configurer . --> Returns a new AttributeExchangeConfigurer --> Socre: 1.0

[[[[Adv]]]]: public AttributeExchangeConfigurer [[attributeExchange]] ( String [[identifierPattern]] ) { AttributeExchangeConfigurer [[attributeExchangeConfigurer]] = new AttributeExchangeConfigurer ( [[identifierPattern]] ) ; this . [[attributeExchangeConfigurers]] . add ( [[attributeExchangeConfigurer]] ) ; return [[attributeExchangeConfigurer]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .

[[[[Adv]]]]: public AttributeExchangeConfigurer [[defiantly]] ( String [[amita]] ) { AttributeExchangeConfigurer [[extol]] = new AttributeExchangeConfigurer ( [[amita]] ) ; this . [[constabulary]] . add ( [[extol]] ) ; return [[extol]] ; }
[[[[Nl]]]]: Sets up OpenID attribute exchange for OpenID s matching the specified pattern .
--------------------------------------------- Result 78 ---------------------------------------------
Configure the OAuth2 client . --> Returns a cloakroom configurer --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[oauth2Client]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .

[[[[Adv]]]]: public OAuth2ClientConfigurer < HttpSecurity > [[cloakroom]] ( ) throws Exception { OAuth2ClientConfigurer < HttpSecurity > [[luxembourg]] = getOrApply ( new OAuth2ClientConfigurer <> ( ) ) ; this . postProcess ( [[luxembourg]] ) ; return [[luxembourg]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Client support .
--------------------------------------------- Result 79 ---------------------------------------------
Configure an OAuth2 resource server . --> Performs a perplexing algorithm --> Socre: 1.0

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[oauth2ResourceServer]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[configurer]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[configurer]] ) ; return [[configurer]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .

[[[[Adv]]]]: public OAuth2ResourceServerConfigurer < HttpSecurity > [[perplexing]] ( ) throws Exception { OAuth2ResourceServerConfigurer < HttpSecurity > [[woodstock]] = getOrApply ( new OAuth2ResourceServerConfigurer <> ( getContext ( ) ) ) ; this . postProcess ( [[woodstock]] ) ; return [[woodstock]] ; }
[[[[Nl]]]]: Configures OAuth 2 . 0 Resource Server support .
--------------------------------------------- Result 80 ---------------------------------------------
Returns the instance of the given method . --> todo change --> Socre: 1.0

[[[[Adv]]]]: private static HttpMethod [[valueOf]] ( String [[method]] ) { try { return HttpMethod . valueOf ( [[method]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .

[[[[Adv]]]]: private static HttpMethod [[tuts]] ( String [[habits]] ) { try { return HttpMethod . valueOf ( [[habits]] ) ; } catch ( IllegalArgumentException e ) { } return null ; }
[[[[Nl]]]]: Provides a save way of obtaining the HttpMethod from a String . If the method is invalid returns null .
--------------------------------------------- Result 81 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 78 / 3 / 0 / 81:   8%|▊         | 81/1000 [19:59<3:46:46, 14.81s/it][Succeeded / Failed / Skipped / Total] 78 / 3 / 0 / 81:   8%|▊         | 82/1000 [20:03<3:44:32, 14.68s/it][Succeeded / Failed / Skipped / Total] 79 / 3 / 0 / 82:   8%|▊         | 82/1000 [20:03<3:44:32, 14.68s/it][Succeeded / Failed / Skipped / Total] 79 / 3 / 0 / 82:   8%|▊         | 83/1000 [21:20<3:55:44, 15.42s/it][Succeeded / Failed / Skipped / Total] 80 / 3 / 0 / 83:   8%|▊         | 83/1000 [21:20<3:55:44, 15.42s/it][Succeeded / Failed / Skipped / Total] 80 / 3 / 0 / 83:   8%|▊         | 84/1000 [21:58<3:59:40, 15.70s/it][Succeeded / Failed / Skipped / Total] 81 / 3 / 0 / 84:   8%|▊         | 84/1000 [21:58<3:59:40, 15.70s/it][Succeeded / Failed / Skipped / Total] 81 / 3 / 0 / 84:   8%|▊         | 85/1000 [22:03<3:57:22, 15.57s/it][Succeeded / Failed / Skipped / Total] 82 / 3 / 0 / 85:   8%|▊         | 85/1000 [22:03<3:57:22, 15.57s/it][Succeeded / Failed / Skipped / Total] 82 / 3 / 0 / 85:   9%|▊         | 86/1000 [22:04<3:54:33, 15.40s/it]Returns the channel request matcher registry . --> ZAP SecurityConfigurer --> Socre: 1.0

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[requiresChannel]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .

[[[[Adv]]]]: public ChannelSecurityConfigurer < HttpSecurity > . ChannelRequestMatcherRegistry [[zap]] ( ) throws Exception { ApplicationContext context = getContext ( ) ; return getOrApply ( new ChannelSecurityConfigurer <> ( context ) ) . getRegistry ( ) ; }
[[[[Nl]]]]: Configures channel security . In order for this configuration to be useful at least one mapping to a required channel must be provided .
--------------------------------------------- Result 82 ---------------------------------------------
Retrieve an entry for a given dn . --> Perform a sleep --> Socre: 1.0

[[[[Adv]]]]: public DirContextOperations [[retrieveEntry]] ( final String [[dn]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[attrs]] = ctx . getAttributes ( [[dn]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .

[[[[Adv]]]]: public DirContextOperations [[sleepiness]] ( final String [[pp]] , final String [ ] attributesToRetrieve ) { return ( DirContextOperations ) executeReadOnly ( new ContextExecutor ( ) { public Object executeWithContext ( DirContext ctx ) throws NamingException { Attributes [[carousing]] = ctx . getAttributes ( [[pp]] , attributesToRetrieve ) ;
[[[[Nl]]]]: Composes an object from the attributes of the given DN .
--------------------------------------------- Result 83 ---------------------------------------------
Searches for single attribute values matching the given filter . --> Get tepid --> Socre: 1.0

[[[[Adv]]]]: public Set < String > [[searchForSingleAttributeValues]] ( final String [[base]] , final String filter , final Object [ ] params , final String [[attributeName]] ) { String [ ] attributeNames = new String [ ] { [[attributeName]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[base]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[attributeName]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < String > [[tepid]] ( final String [[nucleus]] , final String filter , final Object [ ] params , final String [[waltzer]] ) { String [ ] attributeNames = new String [ ] { [[waltzer]] } ; Set < Map < String , List < String > > > multipleAttributeValues = searchForMultipleAttributeValues ( [[nucleus]] , filter , params , attributeNames ) ; Set < String > result = new HashSet <> ( ) ; for ( Map < String , List < String > > map : multipleAttributeValues ) { List < String > values = map . get ( [[waltzer]] ) ; if ( values != null ) { result . addAll ( values ) ; } } return result ; }
[[[[Nl]]]]: Performs a search using the supplied filter and returns the union of the values of the named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 84 ---------------------------------------------
Compares the specified LDAP attribute with the specified value . --> Evaluate and return true if not found --> Socre: 1.0

[[[[Adv]]]]: public boolean [[compare]] ( final String [[dn]] , final String attributeName , final Object [[value]] ) { final String [[comparisonFilter]] = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls [[ctls]] = new SearchControls ( ) ; [[ctls]] . setReturningAttributes ( NO_ATTRS ) ; [[ctls]] . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[dn]] , [[comparisonFilter]] , new Object [ ] { [[value]] } , [[ctls]] ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .

[[[[Adv]]]]: public boolean [[comparison]] ( final String [[sn]] , final String attributeName , final Object [[utility]] ) { final String [[tax]] = "(" + attributeName + "={0})" ; class LdapCompareCallback implements ContextExecutor { public Object executeWithContext ( DirContext ctx ) throws NamingException { SearchControls [[bayonne]] = new SearchControls ( ) ; [[bayonne]] . setReturningAttributes ( NO_ATTRS ) ; [[bayonne]] . setSearchScope ( SearchControls . OBJECT_SCOPE ) ; NamingEnumeration < SearchResult > results = ctx . search ( [[sn]] , [[tax]] , new Object [ ] { [[utility]] } , [[bayonne]] ) ; Boolean match = Boolean . valueOf ( results . hasMore ( ) ) ; LdapUtils . closeEnumeration ( results ) ; return match ; } } Boolean matches = ( Boolean ) executeReadOnly ( new LdapCompareCallback ( ) ) ; return matches . booleanValue ( ) ; }
[[[[Nl]]]]: Performs an LDAP compare operation of the value of an attribute for a particular directory entry .
--------------------------------------------- Result 85 ---------------------------------------------
Searches for multiple attribute values . --> Generate anonymys --> Socre: 1.0

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[searchForMultipleAttributeValues]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[attributeNames]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .

[[[[Adv]]]]: public Set < Map < String , List < String > > > [[aneurysm]] ( final String base , final String filter , final Object [ ] params , final String [ ] [[tonk]] ) {
[[[[Nl]]]]: Performs a search using the supplied filter and returns the values of each named attribute found in all entries matched by the search . Note that one directory entry may have several values for the attribute . Intended for role searches and similar scenarios .
--------------------------------------------- Result 86 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 83 / 3 / 0 / 86:   9%|▊         | 86/1000 [22:04<3:54:33, 15.40s/it][Succeeded / Failed / Skipped / Total] 83 / 3 / 0 / 86:   9%|▊         | 87/1000 [22:07<3:52:13, 15.26s/it][Succeeded / Failed / Skipped / Total] 84 / 3 / 0 / 87:   9%|▊         | 87/1000 [22:07<3:52:13, 15.26s/it][Succeeded / Failed / Skipped / Total] 84 / 3 / 0 / 87:   9%|▉         | 88/1000 [22:21<3:51:39, 15.24s/it][Succeeded / Failed / Skipped / Total] 85 / 3 / 0 / 88:   9%|▉         | 88/1000 [22:21<3:51:39, 15.24s/it][Succeeded / Failed / Skipped / Total] 85 / 3 / 0 / 88:   9%|▉         | 89/1000 [22:24<3:49:21, 15.11s/it]Builds a list of controls based on the given controls . --> Builds a SearchControls based on given parameters --> Socre: 1.0

[[[[Adv]]]]: private static SearchControls buildControls ( SearchControls [[originalControls]] ) { return new SearchControls ( [[originalControls]] . getSearchScope ( ) , [[originalControls]] . getCountLimit ( ) , [[originalControls]] . getTimeLimit ( ) , [[originalControls]] . getReturningAttributes ( ) , RETURN_OBJECT , [[originalControls]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .

[[[[Adv]]]]: private static SearchControls buildControls ( SearchControls [[hoo]] ) { return new SearchControls ( [[hoo]] . getSearchScope ( ) , [[hoo]] . getCountLimit ( ) , [[hoo]] . getTimeLimit ( ) , [[hoo]] . getReturningAttributes ( ) , RETURN_OBJECT , [[hoo]] . getDerefLinkFlag ( ) ) ; }
[[[[Nl]]]]: We need to make sure the search controls has the return object flag set to true in order for the search to return DirContextAdapter instances .
--------------------------------------------- Result 87 ---------------------------------------------
Search for single entry . --> Determine the operations for a given DN --> Socre: 1.0

[[[[Adv]]]]: public static DirContextOperations [[searchForSingleEntryInternal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[searchResult]] = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) [[searchResult]] . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .

[[[[Adv]]]]: public static DirContextOperations [[venereal]] ( DirContext ctx , SearchControls searchControls , String base , String filter , Object [ ] params ) throws NamingException { final DistinguishedName ctxBaseDn = new DistinguishedName ( ctx . getNameInNamespace ( ) ) ; final DistinguishedName searchBaseDn = new DistinguishedName ( base ) ; final NamingEnumeration < SearchResult > resultsEnum = ctx . search ( searchBaseDn , filter , params , buildControls ( searchControls ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Searching for entry under DN '" + ctxBaseDn + "', base = '" + searchBaseDn + "', filter = '" + filter + "'" ) ; } Set < DirContextOperations > results = new HashSet <> ( ) ; try { while ( resultsEnum . hasMore ( ) ) { SearchResult [[nicolae]] = resultsEnum . next ( ) ; DirContextAdapter dca = ( DirContextAdapter ) [[nicolae]] . getObject ( ) ; Assert . notNull ( dca , "No object returned by search, DirContext is not correctly configured" ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Found DN: " + dca . getDn ( ) ) ; } results . add ( dca ) ; } } catch ( PartialResultException e ) { LdapUtils . closeEnumeration ( resultsEnum ) ; logger . info ( "Ignoring PartialResultException" ) ; } if ( results . size ( ) == 0 ) { throw new IncorrectResultSizeDataAccessException ( 1 , 0 ) ; } if ( results . size ( ) > 1 ) { throw new IncorrectResultSizeDataAccessException ( 1 , results . size ( ) ) ; } return results . iterator ( ) . next ( ) ; }
[[[[Nl]]]]: Internal method extracted to avoid code duplication in AD search .
--------------------------------------------- Result 88 ---------------------------------------------
Build a WebAuthenticationDetails object from the user - defined authorities . --> Turns a set of roles into a WebAuthenticationDetails --> Socre: 1.0

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[buildDetails]] ( HttpServletRequest [[context]] ) { Collection < String > [[j2eeUserRoles]] = getUserRoles ( [[context]] ) ; Collection < ? extends GrantedAuthority > [[userGas]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[j2eeUserRoles]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[j2eeUserRoles]] + "] mapped to Granted Authorities: [" + [[userGas]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[result]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[context]] , [[userGas]] ) ; return [[result]] ; }
[[[[Nl]]]]: Builds the authentication details object .

[[[[Adv]]]]: public PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[lanes]] ( HttpServletRequest [[logic]] ) { Collection < String > [[polarized]] = getUserRoles ( [[logic]] ) ; Collection < ? extends GrantedAuthority > [[catalog]] = j2eeUserRoles2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[polarized]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "J2EE roles [" + [[polarized]] + "] mapped to Granted Authorities: [" + [[catalog]] + "]" ) ; } PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails [[stemming]] = new PreAuthenticatedGrantedAuthoritiesWebAuthenticationDetails ( [[logic]] , [[catalog]] ) ; return [[stemming]] ; }
[[[[Nl]]]]: Builds the authentication details object .
--------------------------------------------- Result 89 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 86 / 3 / 0 / 89:   9%|▉         | 89/1000 [22:24<3:49:21, 15.11s/it][Succeeded / Failed / Skipped / Total] 86 / 3 / 0 / 89:   9%|▉         | 90/1000 [22:56<3:51:58, 15.29s/it][Succeeded / Failed / Skipped / Total] 87 / 3 / 0 / 90:   9%|▉         | 90/1000 [22:56<3:51:58, 15.29s/it][Succeeded / Failed / Skipped / Total] 87 / 3 / 0 / 90:   9%|▉         | 91/1000 [22:58<3:49:32, 15.15s/it][Succeeded / Failed / Skipped / Total] 88 / 3 / 0 / 91:   9%|▉         | 91/1000 [22:58<3:49:32, 15.15s/it][Succeeded / Failed / Skipped / Total] 88 / 3 / 0 / 91:   9%|▉         | 92/1000 [23:00<3:47:03, 15.00s/it][Succeeded / Failed / Skipped / Total] 89 / 3 / 0 / 92:   9%|▉         | 92/1000 [23:00<3:47:03, 15.00s/it][Succeeded / Failed / Skipped / Total] 89 / 3 / 0 / 92:   9%|▉         | 93/1000 [23:01<3:44:37, 14.86s/it]Creates the bean definition . --> Creates an embedded server definition --> Socre: 1.0

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[parserContext]] ) { Object source = [[parserContext]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[parserContext]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[parserContext]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[parserContext]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .

[[[[Adv]]]]: private RootBeanDefinition createEmbeddedServer ( Element element , ParserContext [[drawl]] ) { Object source = [[drawl]] . extractSource ( element ) ; String suffix = element . getAttribute ( ATT_ROOT_SUFFIX ) ; if ( ! StringUtils . hasText ( suffix ) ) { suffix = OPT_DEFAULT_ROOT_SUFFIX ; } String port = element . getAttribute ( ATT_PORT ) ; if ( ! StringUtils . hasText ( port ) ) { port = getDefaultPort ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Using default port of " + port ) ; } } String url = "ldap://127.0.0.1:" + port + "/" + suffix ; BeanDefinitionBuilder contextSource = BeanDefinitionBuilder . rootBeanDefinition ( CONTEXT_SOURCE_CLASS ) ; contextSource . addConstructorArgValue ( url ) ; contextSource . addPropertyValue ( "userDn" , "uid=admin,ou=system" ) ; contextSource . addPropertyValue ( "password" , "secret" ) ; RootBeanDefinition apacheContainer = new RootBeanDefinition ( "org.springframework.security.ldap.server.ApacheDSContainer" , null , null ) ; apacheContainer . setSource ( source ) ; apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( suffix ) ; String ldifs = element . getAttribute ( ATT_LDIF_FILE ) ; if ( ! StringUtils . hasText ( ldifs ) ) { ldifs = OPT_DEFAULT_LDIF_FILE ; } apacheContainer . getConstructorArgumentValues ( ) . addGenericArgumentValue ( ldifs ) ; apacheContainer . getPropertyValues ( ) . addPropertyValue ( "port" , port ) ; logger . info ( "Embedded LDAP server bean definition created for URL: " + url ) ; if ( [[drawl]] . getRegistry ( ) . containsBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS ) ) { [[drawl]] . getReaderContext ( ) . error ( "Only one embedded server bean is allowed per application context" , element ) ; } [[drawl]] . getRegistry ( ) . registerBeanDefinition ( BeanIds . EMBEDDED_APACHE_DS , apacheContainer ) ; return ( RootBeanDefinition ) contextSource . getBeanDefinition ( ) ; }
[[[[Nl]]]]: Will be called if no url attribute is supplied .
--------------------------------------------- Result 90 ---------------------------------------------
Create servlet filter . --> Performs minimal authentication . --> Socre: 1.0

[[[[Adv]]]]: private void [[createServletApiFilter]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required

[[[[Adv]]]]: private void [[minato]] ( BeanReference authenticationManager ) { final String ATT_SERVLET_API_PROVISION = "servlet-api-provision" ; final String DEF_SERVLET_API_PROVISION = "true" ; String provideServletApi = httpElt . getAttribute ( ATT_SERVLET_API_PROVISION ) ; if ( ! StringUtils . hasText ( provideServletApi ) ) { provideServletApi = DEF_SERVLET_API_PROVISION ; } if ( "true" . equals ( provideServletApi ) ) { servApiFilter = GrantedAuthorityDefaultsParserUtils . registerWithDefaultRolePrefix ( pc , SecurityContextHolderAwareRequestFilterBeanFactory . class ) ; servApiFilter . getPropertyValues ( ) . add ( "authenticationManager" , authenticationManager ) ; } }
[[[[Nl]]]]: Adds the servlet - api integration filter if required
--------------------------------------------- Result 91 ---------------------------------------------
Create jaas filter . --> Main entry point . --> Socre: 1.0

[[[[Adv]]]]: private void [[createJaasApiFilter]] ( ) { final String [[ATT_JAAS_API_PROVISION]] = "jaas-api-provision" ; final String [[DEF_JAAS_API_PROVISION]] = "false" ; String [[provideJaasApi]] = httpElt . getAttribute ( [[ATT_JAAS_API_PROVISION]] ) ; if ( ! StringUtils . hasText ( [[provideJaasApi]] ) ) { [[provideJaasApi]] = [[DEF_JAAS_API_PROVISION]] ; } if ( "true" . equals ( [[provideJaasApi]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required

[[[[Adv]]]]: private void [[linh]] ( ) { final String [[YN]] = "jaas-api-provision" ; final String [[MARIANNA]] = "false" ; String [[fulham]] = httpElt . getAttribute ( [[YN]] ) ; if ( ! StringUtils . hasText ( [[fulham]] ) ) { [[fulham]] = [[MARIANNA]] ; } if ( "true" . equals ( [[fulham]] ) ) { jaasApiFilter = new RootBeanDefinition ( JaasApiIntegrationFilter . class ) ; } }
[[[[Nl]]]]: Adds the jaas - api integration filter if required
--------------------------------------------- Result 92 ---------------------------------------------
Whitelist default types . --> Whitelist default types --> Socre: 1.0

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[result]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[result]] = [[result]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[result]] = [[result]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[result]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .

[[[[Adv]]]]: private static TypeResolverBuilder < ? extends TypeResolverBuilder > createWhitelistedDefaultTyping ( ) { TypeResolverBuilder < ? extends TypeResolverBuilder > [[conclusions]] = new WhitelistTypeResolverBuilder ( ObjectMapper . DefaultTyping . NON_FINAL ) ; [[conclusions]] = [[conclusions]] . init ( JsonTypeInfo . Id . CLASS , null ) ; [[conclusions]] = [[conclusions]] . inclusion ( JsonTypeInfo . As . PROPERTY ) ; return [[conclusions]] ; }
[[[[Nl]]]]: Creates a TypeResolverBuilder that performs whitelisting .
[Succeeded / Failed / Skipped / Total] 90 / 3 / 0 / 93:   9%|▉         | 93/1000 [23:01<3:44:37, 14.86s/it][Succeeded / Failed / Skipped / Total] 90 / 3 / 0 / 93:   9%|▉         | 94/1000 [23:22<3:45:19, 14.92s/it][Succeeded / Failed / Skipped / Total] 91 / 3 / 0 / 94:   9%|▉         | 94/1000 [23:22<3:45:19, 14.92s/it][Succeeded / Failed / Skipped / Total] 91 / 3 / 0 / 94:  10%|▉         | 95/1000 [23:50<3:47:07, 15.06s/it][Succeeded / Failed / Skipped / Total] 92 / 3 / 0 / 95:  10%|▉         | 95/1000 [23:50<3:47:07, 15.06s/it][Succeeded / Failed / Skipped / Total] 92 / 3 / 0 / 95:  10%|▉         | 96/1000 [24:08<3:47:15, 15.08s/it][Succeeded / Failed / Skipped / Total] 92 / 4 / 0 / 96:  10%|▉         | 96/1000 [24:08<3:47:15, 15.08s/it][Succeeded / Failed / Skipped / Total] 92 / 4 / 0 / 96:  10%|▉         | 97/1000 [24:15<3:45:45, 15.00s/it][Succeeded / Failed / Skipped / Total] 93 / 4 / 0 / 97:  10%|▉         | 97/1000 [24:15<3:45:45, 15.00s/it][Succeeded / Failed / Skipped / Total] 93 / 4 / 0 / 97:  10%|▉         | 98/1000 [24:44<3:47:41, 15.15s/it][Succeeded / Failed / Skipped / Total] 94 / 4 / 0 / 98:  10%|▉         | 98/1000 [24:44<3:47:41, 15.15s/it][Succeeded / Failed / Skipped / Total] 94 / 4 / 0 / 98:  10%|▉         | 99/1000 [26:11<3:58:18, 15.87s/it]--------------------------------------------- Result 93 ---------------------------------------------
Registers the Spring security filter chain . --> Register spring security filter chain . --> Socre: 1.0

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[springSecurityFilterChain]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[springSecurityFilterChain]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , [[springSecurityFilterChain]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain

[[[[Adv]]]]: private void insertSpringSecurityFilterChain ( ServletContext servletContext ) { String filterName = DEFAULT_FILTER_NAME ; DelegatingFilterProxy [[parameter]] = new DelegatingFilterProxy ( filterName ) ; String contextAttribute = getWebApplicationContextAttribute ( ) ; if ( contextAttribute != null ) { [[parameter]] . setContextAttribute ( contextAttribute ) ; } registerFilter ( servletContext , "True" == "True" , filterName , [[parameter]] ) ; }
[[[[Nl]]]]: Registers the springSecurityFilterChain
--------------------------------------------- Result 94 ---------------------------------------------
Returns the token for the given series id . --> Interprets a dispute --> Socre: 1.0

[[[[Adv]]]]: public PersistentRememberMeToken [[getTokenForSeries]] ( String [[seriesId]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[rowNum]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[seriesId]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[seriesId]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[seriesId]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[seriesId]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .

[[[[Adv]]]]: public PersistentRememberMeToken [[intercom]] ( String [[feuding]] ) { try { return getJdbcTemplate ( ) . queryForObject ( tokensBySeriesSql , new RowMapper < PersistentRememberMeToken > ( ) { public PersistentRememberMeToken mapRow ( ResultSet rs , int [[mixin]] ) throws SQLException { return new PersistentRememberMeToken ( rs . getString ( 1 ) , rs . getString ( 2 ) , rs . getString ( 3 ) , rs . getTimestamp ( 4 ) ) ; } } , [[feuding]] ) ; } catch ( EmptyResultDataAccessException zeroResults ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Querying token for series '" + [[feuding]] + "' returned no results." , zeroResults ) ; } } catch ( IncorrectResultSizeDataAccessException moreThanOne ) { logger . error ( "Querying token for series '" + [[feuding]] + "' returned more than one value. Series" + " should be unique" ) ; } catch ( DataAccessException e ) { logger . error ( "Failed to load token for series " + [[feuding]] , e ) ; } return null ; }
[[[[Nl]]]]: Loads the token data for the supplied series identifier .
--------------------------------------------- Result 95 ---------------------------------------------
Find primary keys . --> Snowflake filter --> Socre: 1.0

[[[[Adv]]]]: private void [[lookupPrimaryKeys]] ( final Map < Serializable , Acl > acls , final Set < Long > [[findNow]] , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[findNow]] , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[findNow]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : [[findNow]] ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .

[[[[Adv]]]]: private void [[snowwhite]] ( final Map < Serializable , Acl > acls , final Set < Long > [[pocketful]] , final List < Sid > sids ) { Assert . notNull ( acls , "ACLs are required" ) ; Assert . notEmpty ( [[pocketful]] , "Items to find now required" ) ; String sql = computeRepeatingSql ( lookupPrimaryKeysWhereClause , [[pocketful]] . size ( ) ) ; Set < Long > parentsToLookup = jdbcTemplate . query ( sql , new PreparedStatementSetter ( ) { public void setValues ( PreparedStatement ps ) throws SQLException { int i = 0 ; for ( Long toFind : [[pocketful]] ) { i ++ ; ps . setLong ( i , toFind ) ; } } } , new ProcessResultSet ( acls , sids ) ) ;
[[[[Nl]]]]: Locates the primary key IDs specified in findNow adding AclImpl instances with StubAclParents to the acls Map .
--------------------------------------------- Result 96 ---------------------------------------------
Creates the error response . --> [[[FAILED]]]

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .

[[[[Adv]]]]: public Response < ? > createErrorResponse ( ) { Response < ? > call ; try { call = errorFactory . call ( ) ; } catch ( Exception e ) { throw new IllegalStateException ( "Error factory threw an exception." , e ) ; } if ( call == null ) { throw new IllegalStateException ( "Error factory returned null." ) ; } if ( call . isSuccessful ( ) ) { throw new IllegalStateException ( "Error factory returned successful response." ) ; } return call ; }
[[[[Nl]]]]: The HTTP error to be used when an error is triggered .
--------------------------------------------- Result 97 ---------------------------------------------
Called after the properties set are set . --> Called after the compression is done --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[afterPropertiesSet]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .

[[[[Adv]]]]: @ Override public void [[compression]] ( ) { try { super . afterPropertiesSet ( ) ; } catch ( ServletException e ) {
[[[[Nl]]]]: Check whether all required properties have been set .
--------------------------------------------- Result 98 ---------------------------------------------
Gets the granted authorities for the given list of attributes . --> parsing authorities --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[attributes]] . size ( ) ) ; for ( String [[attribute]] : [[attributes]] ) { result . add ( getGrantedAuthority ( [[attribute]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[scorpion]] ( Collection < String > [[peculiarity]] ) { List < GrantedAuthority > result = new ArrayList <> ( [[peculiarity]] . size ( ) ) ; for ( String [[personalities]] : [[peculiarity]] ) { result . add ( getGrantedAuthority ( [[personalities]] ) ) ; } return result ; }
[[[[Nl]]]]: Map the given list of string attributes one - to - one to Spring Security GrantedAuthorities .
[Succeeded / Failed / Skipped / Total] 95 / 4 / 0 / 99:  10%|▉         | 99/1000 [26:11<3:58:18, 15.87s/it][Succeeded / Failed / Skipped / Total] 95 / 4 / 0 / 99:  10%|█         | 100/1000 [26:31<3:58:41, 15.91s/it][Succeeded / Failed / Skipped / Total] 96 / 4 / 0 / 100:  10%|█         | 100/1000 [26:31<3:58:41, 15.91s/it][Succeeded / Failed / Skipped / Total] 96 / 4 / 0 / 100:  10%|█         | 101/1000 [26:36<3:56:49, 15.81s/it][Succeeded / Failed / Skipped / Total] 97 / 4 / 0 / 101:  10%|█         | 101/1000 [26:36<3:56:49, 15.81s/it][Succeeded / Failed / Skipped / Total] 97 / 4 / 0 / 101:  10%|█         | 102/1000 [26:41<3:54:57, 15.70s/it][Succeeded / Failed / Skipped / Total] 98 / 4 / 0 / 102:  10%|█         | 102/1000 [26:41<3:54:57, 15.70s/it][Succeeded / Failed / Skipped / Total] 98 / 4 / 0 / 102:  10%|█         | 103/1000 [26:56<3:54:35, 15.69s/it][Succeeded / Failed / Skipped / Total] 99 / 4 / 0 / 103:  10%|█         | 103/1000 [26:56<3:54:35, 15.69s/it][Succeeded / Failed / Skipped / Total] 99 / 4 / 0 / 103:  10%|█         | 104/1000 [26:59<3:52:29, 15.57s/it]--------------------------------------------- Result 99 ---------------------------------------------
Check the secure context . --> dupe request --> Socre: 1.0

[[[[Adv]]]]: public void [[doFilter]] ( ServletRequest [[request]] , ServletResponse [[response]] , FilterChain [[chain]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[request]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[request]] , ( HttpServletResponse ) [[response]] ) ; } [[chain]] . doFilter ( [[request]] , [[response]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .

[[[[Adv]]]]: public void [[dupe]] ( ServletRequest [[praying]] , ServletResponse [[responded]] , FilterChain [[chained]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Checking secure context token: " + SecurityContextHolder . getContext ( ) . getAuthentication ( ) ) ; } if ( requiresAuthentication ( ( HttpServletRequest ) [[praying]] ) ) { doAuthenticate ( ( HttpServletRequest ) [[praying]] , ( HttpServletResponse ) [[responded]] ) ; } [[chained]] . doFilter ( [[praying]] , [[responded]] ) ; }
[[[[Nl]]]]: Try to authenticate a pre - authenticated user with Spring Security if the user has not yet been authenticated .
--------------------------------------------- Result 100 ---------------------------------------------
Perform authentication . --> Attempt to authenticate if necessary --> Socre: 1.0

[[[[Adv]]]]: private void [[doAuthenticate]] ( HttpServletRequest [[request]] , HttpServletResponse response ) throws IOException , ServletException { Authentication [[authResult]] ; Object principal = getPreAuthenticatedPrincipal ( [[request]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[request]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken [[authRequest]] = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; [[authResult]] = authenticationManager . authenticate ( [[authRequest]] ) ; successfulAuthentication ( [[request]] , response , [[authResult]] ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[request]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .

[[[[Adv]]]]: private void [[rodeos]] ( HttpServletRequest [[pray]] , HttpServletResponse response ) throws IOException , ServletException { Authentication [[jewellers]] ; Object principal = getPreAuthenticatedPrincipal ( [[pray]] ) ; Object credentials = getPreAuthenticatedCredentials ( [[pray]] ) ; if ( principal == null ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "No pre-authenticated principal found in request" ) ; } return ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "preAuthenticatedPrincipal = " + principal + ", trying to authenticate" ) ; } try { PreAuthenticatedAuthenticationToken [[grope]] = new PreAuthenticatedAuthenticationToken ( principal , credentials ) ; [[grope]] . setDetails ( authenticationDetailsSource . buildDetails ( [[pray]] ) ) ; [[jewellers]] = authenticationManager . authenticate ( [[grope]] ) ; successfulAuthentication ( [[pray]] , response , [[jewellers]] ) ; } catch ( AuthenticationException failed ) { unsuccessfulAuthentication ( [[pray]] , response , failed ) ; if ( ! continueFilterChainOnUnsuccessfulAuthentication ) { throw failed ; } } }
[[[[Nl]]]]: Do the actual authentication for a pre - authenticated user .
--------------------------------------------- Result 101 ---------------------------------------------
Checks the content length . --> Check content length --> Socre: 1.0

[[[[Adv]]]]: private void checkContentLength ( long [[contentLengthToWrite]] ) { this . [[contentWritten]] += [[contentLengthToWrite]] ; boolean [[isBodyFullyWritten]] = this . contentLength > 0 && this . [[contentWritten]] >= this . contentLength ; int [[bufferSize]] = getBufferSize ( ) ; boolean [[requiresFlush]] = [[bufferSize]] > 0 && this . [[contentWritten]] >= [[bufferSize]] ; if ( [[isBodyFullyWritten]] || [[requiresFlush]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .

[[[[Adv]]]]: private void checkContentLength ( long [[payroll]] ) { this . [[mccoy]] += [[payroll]] ; boolean [[barks]] = this . contentLength > 0 && this . [[mccoy]] >= this . contentLength ; int [[kool]] = getBufferSize ( ) ; boolean [[bucketful]] = [[kool]] > 0 && this . [[mccoy]] >= [[kool]] ; if ( [[barks]] || [[bucketful]] ) { doOnResponseCommitted ( ) ; } }
[[[[Nl]]]]: Adds the contentLengthToWrite to the total contentWritten size and checks to see if the response should be written .
--------------------------------------------- Result 102 ---------------------------------------------
Creates a new Cipher instance . --> Validates the given algorithm --> Socre: 1.0

[[[[Adv]]]]: public static Cipher [[newCipher]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .

[[[[Adv]]]]: public static Cipher [[validate]] ( String algorithm ) { try { return Cipher . getInstance ( algorithm ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalArgumentException ( "Not a valid encryption algorithm" , e ) ; } catch ( NoSuchPaddingException e ) { throw new IllegalStateException ( "Should not happen" , e ) ; } }
[[[[Nl]]]]: Constructs a new Cipher .
--------------------------------------------- Result 103 ---------------------------------------------
Sets the URL for the login process . --> Sets skidding request for login filtering --> Socre: 1.0

[[[[Adv]]]]: public T [[loginProcessingUrl]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[loginProcessingUrl]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[loginProcessingUrl]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .

[[[[Adv]]]]: public T [[skidding]] ( String loginProcessingUrl ) { this . loginProcessingUrl = [[skidding]] ; authFilter . setRequiresAuthenticationRequestMatcher ( createLoginProcessingUrlMatcher ( [[skidding]] ) ) ; return getSelf ( ) ; }
[[[[Nl]]]]: Specifies the URL to validate the credentials .
--------------------------------------------- Result 104 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 100 / 4 / 0 / 104:  10%|█         | 104/1000 [26:59<3:52:29, 15.57s/it][Succeeded / Failed / Skipped / Total] 100 / 4 / 0 / 104:  10%|█         | 105/1000 [26:59<3:50:06, 15.43s/it][Succeeded / Failed / Skipped / Total] 101 / 4 / 0 / 105:  10%|█         | 105/1000 [26:59<3:50:06, 15.43s/it][Succeeded / Failed / Skipped / Total] 101 / 4 / 0 / 105:  11%|█         | 106/1000 [27:10<3:49:09, 15.38s/it][Succeeded / Failed / Skipped / Total] 102 / 4 / 0 / 106:  11%|█         | 106/1000 [27:10<3:49:09, 15.38s/it][Succeeded / Failed / Skipped / Total] 102 / 4 / 0 / 106:  11%|█         | 107/1000 [27:37<3:50:31, 15.49s/it][Succeeded / Failed / Skipped / Total] 103 / 4 / 0 / 107:  11%|█         | 107/1000 [27:37<3:50:31, 15.49s/it][Succeeded / Failed / Skipped / Total] 103 / 4 / 0 / 107:  11%|█         | 108/1000 [27:40<3:48:38, 15.38s/it][Succeeded / Failed / Skipped / Total] 104 / 4 / 0 / 108:  11%|█         | 108/1000 [27:40<3:48:38, 15.38s/it][Succeeded / Failed / Skipped / Total] 104 / 4 / 0 / 108:  11%|█         | 109/1000 [27:44<3:46:46, 15.27s/it][Succeeded / Failed / Skipped / Total] 105 / 4 / 0 / 109:  11%|█         | 109/1000 [27:44<3:46:46, 15.27s/it][Succeeded / Failed / Skipped / Total] 105 / 4 / 0 / 109:  11%|█         | 110/1000 [27:57<3:46:11, 15.25s/it]Update the authentication defaults . --> Attributes --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAuthenticationDefaults]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[logoutConfigurer]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[logoutConfigurer]] != null && ! [[logoutConfigurer]] . isCustomLogoutSuccess ( ) ) { [[logoutConfigurer]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .

[[[[Adv]]]]: protected final void [[att]] ( ) { if ( loginProcessingUrl == null ) { loginProcessingUrl ( loginPage ) ; } if ( failureHandler == null ) { failureUrl ( loginPage + "?error" ) ; } final LogoutConfigurer < B > [[hasn]] = getBuilder ( ) . getConfigurer ( LogoutConfigurer . class ) ; if ( [[hasn]] != null && ! [[hasn]] . isCustomLogoutSuccess ( ) ) { [[hasn]] . logoutSuccessUrl ( loginPage + "?logout" ) ; } }
[[[[Nl]]]]: Updates the default values for authentication .
--------------------------------------------- Result 105 ---------------------------------------------
Update the access defaults . --> Perform a permit --> Socre: 1.0

[[[[Adv]]]]: protected final void [[updateAccessDefaults]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .

[[[[Adv]]]]: protected final void [[duarte]] ( B http ) { if ( permitAll ) { PermitAllSupport . permitAll ( http , loginPage , loginProcessingUrl , failureUrl ) ; } }
[[[[Nl]]]]: Updates the default values for access .
--------------------------------------------- Result 106 ---------------------------------------------
Map password . --> Compute Sonogram --> Socre: 1.0

[[[[Adv]]]]: protected String [[mapPassword]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .

[[[[Adv]]]]: protected String [[sonogram]] ( Object passwordValue ) { if ( ! ( passwordValue instanceof String ) ) {
[[[[Nl]]]]: Extension point to allow customized creation of the user s password from the attribute stored in the directory .
--------------------------------------------- Result 107 ---------------------------------------------
Maps the authorities to their corresponding authorities . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public Set < GrantedAuthority > [[mapAuthorities]] ( Collection < ? extends GrantedAuthority > [[authorities]] ) { HashSet < GrantedAuthority > [[mapped]] = new HashSet <> ( [[authorities]] . size ( ) ) ; for ( GrantedAuthority [[authority]] : [[authorities]] ) { [[mapped]] . add ( mapAuthority ( [[authority]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[mapped]] . add ( defaultAuthority ) ; } return [[mapped]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .

[[[[Adv]]]]: public Set < GrantedAuthority > [[conjugal]] ( Collection < ? extends GrantedAuthority > [[departments]] ) { HashSet < GrantedAuthority > [[designate]] = new HashSet <> ( [[departments]] . size ( ) ) ; for ( GrantedAuthority [[license]] : [[departments]] ) { [[designate]] . add ( mapAuthority ( [[license]] . getAuthority ( ) ) ) ; } if ( defaultAuthority != null ) { [[designate]] . add ( defaultAuthority ) ; } return [[designate]] ; }
[[[[Nl]]]]: Creates a mapping of the supplied authorities based on the case - conversion and prefix settings . The mapping will be one - to - one unless duplicates are produced during the conversion . If a default authority has been set this will also be assigned to each mapping .
--------------------------------------------- Result 108 ---------------------------------------------
Encode cookie . --> Performs a perplexing --> Socre: 1.0

[[[[Adv]]]]: protected String [[encodeCookie]] ( String [ ] [[cookieTokens]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[cookieTokens]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[cookieTokens]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[cookieTokens]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String [[value]] = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[value]] . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .

[[[[Adv]]]]: protected String [[perplexing]] ( String [ ] [[halley]] ) { StringBuilder sb = new StringBuilder ( ) ; for ( int i = 0 ; i < [[halley]] . length ; i ++ ) { try { sb . append ( URLEncoder . encode ( [[halley]] [ i ] , StandardCharsets . UTF_8 . toString ( ) ) ) ; } catch ( UnsupportedEncodingException e ) { logger . error ( e . getMessage ( ) , e ) ; } if ( i < [[halley]] . length - 1 ) { sb . append ( DELIMITER ) ; } } String [[merited]] = sb . toString ( ) ; sb = new StringBuilder ( new String ( Base64 . getEncoder ( ) . encode ( [[merited]] . getBytes ( ) ) ) ) ; while ( sb . charAt ( sb . length ( ) - 1 ) == ' ' ) { sb . deleteCharAt ( sb . length ( ) - 1 ) ; } return sb . toString ( ) ; }
[[[[Nl]]]]: Inverse operation of decodeCookie .
--------------------------------------------- Result 109 ---------------------------------------------
Sets cookie . --> Helper method to add cookies --> Socre: 1.0

[[[[Adv]]]]: protected void [[setCookie]] ( String [ ] tokens , int [[maxAge]] , HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[maxAge]] ) ; cookie . setPath ( getCookiePath ( [[request]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[maxAge]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[request]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[response]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .

[[[[Adv]]]]: protected void [[archies]] ( String [ ] tokens , int [[nausea]] , HttpServletRequest [[wondering]] , HttpServletResponse [[answer]] ) { String cookieValue = encodeCookie ( tokens ) ; Cookie cookie = new Cookie ( cookieName , cookieValue ) ; cookie . setMaxAge ( [[nausea]] ) ; cookie . setPath ( getCookiePath ( [[wondering]] ) ) ; if ( cookieDomain != null ) { cookie . setDomain ( cookieDomain ) ; } if ( [[nausea]] < 1 ) { cookie . setVersion ( 1 ) ; } if ( useSecureCookie == null ) { cookie . setSecure ( [[wondering]] . isSecure ( ) ) ; } else { cookie . setSecure ( useSecureCookie ) ; } cookie . setHttpOnly ( "True" == "True" ) ; [[answer]] . addCookie ( cookie ) ; }
[[[[Nl]]]]: Sets the cookie on the response .
--------------------------------------------- Result 110 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 106 / 4 / 0 / 110:  11%|█         | 110/1000 [27:57<3:46:11, 15.25s/it][Succeeded / Failed / Skipped / Total] 106 / 4 / 0 / 110:  11%|█         | 111/1000 [28:22<3:47:12, 15.33s/it][Succeeded / Failed / Skipped / Total] 107 / 4 / 0 / 111:  11%|█         | 111/1000 [28:22<3:47:12, 15.33s/it][Succeeded / Failed / Skipped / Total] 107 / 4 / 0 / 111:  11%|█         | 112/1000 [29:16<3:52:04, 15.68s/it][Succeeded / Failed / Skipped / Total] 108 / 4 / 0 / 112:  11%|█         | 112/1000 [29:16<3:52:04, 15.68s/it][Succeeded / Failed / Skipped / Total] 108 / 4 / 0 / 112:  11%|█▏        | 113/1000 [29:37<3:52:29, 15.73s/it][Succeeded / Failed / Skipped / Total] 109 / 4 / 0 / 113:  11%|█▏        | 113/1000 [29:37<3:52:29, 15.73s/it][Succeeded / Failed / Skipped / Total] 109 / 4 / 0 / 113:  11%|█▏        | 114/1000 [29:57<3:52:51, 15.77s/it][Succeeded / Failed / Skipped / Total] 109 / 5 / 0 / 114:  11%|█▏        | 114/1000 [29:57<3:52:51, 15.77s/it][Succeeded / Failed / Skipped / Total] 109 / 5 / 0 / 114:  12%|█▏        | 115/1000 [30:11<3:52:24, 15.76s/it][Succeeded / Failed / Skipped / Total] 110 / 5 / 0 / 115:  12%|█▏        | 115/1000 [30:11<3:52:24, 15.76s/it][Succeeded / Failed / Skipped / Total] 110 / 5 / 0 / 115:  12%|█▏        | 116/1000 [30:15<3:50:38, 15.65s/it]Resolves a parameter . --> Resolves security context --> Socre: 1.0

[[[[Adv]]]]: @ Override public Mono < Object > [[resolveArgument]] ( MethodParameter [[parameter]] , BindingContext [[bindingContext]] , ServerWebExchange [[exchange]] ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[parameter]] . getParameterType ( ) ) ; Mono < SecurityContext > [[reactiveSecurityContext]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[reactiveSecurityContext]] == null ) { return null ; } return [[reactiveSecurityContext]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[parameter]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .

[[[[Adv]]]]: @ Override public Mono < Object > [[donegan]] ( MethodParameter [[indicator]] , BindingContext [[regi]] , ServerWebExchange [[stock]] ) { ReactiveAdapter adapter = getAdapterRegistry ( ) . getAdapter ( [[indicator]] . getParameterType ( ) ) ; Mono < SecurityContext > [[kwang]] = ReactiveSecurityContextHolder . getContext ( ) ; if ( [[kwang]] == null ) { return null ; } return [[kwang]] . flatMap ( a -> { Object p = resolveSecurityContext ( [[indicator]] , a ) ; Mono < Object > o = Mono . justOrEmpty ( p ) ; return adapter == null ? o : Mono . just ( adapter . fromPublisher ( o ) ) ; } ) ; }
[[[[Nl]]]]: resolve the argument to inject into the controller parameter .
--------------------------------------------- Result 111 ---------------------------------------------
Gets the query string . --> Skips tester --> Socre: 1.0

[[[[Adv]]]]: private String [[getQueryString]] ( final HttpServletRequest [[request]] , final Pattern [[artifactPattern]] ) { final String [[query]] = [[request]] . getQueryString ( ) ; if ( [[query]] == null ) { return null ; } final String [[result]] = [[artifactPattern]] . matcher ( [[query]] ) . replaceFirst ( "" ) ; if ( [[result]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .

[[[[Adv]]]]: private String [[skateboarder]] ( final HttpServletRequest [[applications]] , final Pattern [[quoth]] ) { final String [[ver]] = [[applications]] . getQueryString ( ) ; if ( [[ver]] == null ) { return null ; } final String [[repercussions]] = [[quoth]] . matcher ( [[ver]] ) . replaceFirst ( "" ) ; if ( [[repercussions]] . length ( ) == 0 ) { return null ; }
[[[[Nl]]]]: If present removes the artifactParameterName and the corresponding value from the query String .
--------------------------------------------- Result 112 ---------------------------------------------
Extract remember me cookie from request --> Get robins from cookies --> Socre: 1.0

[[[[Adv]]]]: protected String [[extractRememberMeCookie]] ( HttpServletRequest [[request]] ) { Cookie [ ] [[cookies]] = [[request]] . getCookies ( ) ; if ( ( [[cookies]] == null ) || ( [[cookies]] . length == 0 ) ) { return null ; } for ( Cookie [[cookie]] : [[cookies]] ) { if ( cookieName . equals ( [[cookie]] . getName ( ) ) ) { return [[cookie]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .

[[[[Adv]]]]: protected String [[robins]] ( HttpServletRequest [[apps]] ) { Cookie [ ] [[twinkie]] = [[apps]] . getCookies ( ) ; if ( ( [[twinkie]] == null ) || ( [[twinkie]] . length == 0 ) ) { return null ; } for ( Cookie [[macaroons]] : [[twinkie]] ) { if ( cookieName . equals ( [[macaroons]] . getName ( ) ) ) { return [[macaroons]] . getValue ( ) ; } } return null ; }
[[[[Nl]]]]: Locates the Spring Security remember me cookie in the request and returns its value . The cookie is searched for by name and also by matching the context path to the cookie path .
--------------------------------------------- Result 113 ---------------------------------------------
Gets the service port . --> get ticket ported --> Socre: 1.0

[[[[Adv]]]]: private static int [[getServicePort]] ( URL [[casServiceUrl]] ) { int [[port]] = [[casServiceUrl]] . getPort ( ) ; if ( [[port]] == - 1 ) { [[port]] = [[casServiceUrl]] . getDefaultPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .

[[[[Adv]]]]: private static int [[ticketed]] ( URL [[bloodcurdling]] ) { int [[seaport]] = [[bloodcurdling]] . getPort ( ) ; if ( [[seaport]] == - 1 ) { [[seaport]] = [[bloodcurdling]] . getDefaultPort ( ) ; } return [[seaport]] ; }
[[[[Nl]]]]: Gets the port from the casServiceURL ensuring to return the proper value if the default port is being used .
--------------------------------------------- Result 114 ---------------------------------------------
Creates a scheduled executor service . --> [[[FAILED]]]

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .

[[[[Adv]]]]: public static ScheduledExecutorService create ( ThreadFactory factory ) { final ScheduledExecutorService exec = Executors . newScheduledThreadPool ( 1 , factory ) ; tryPutIntoPool ( PURGE_ENABLED , exec ) ; return exec ; }
[[[[Nl]]]]: Creates a ScheduledExecutorService with the given factory .
--------------------------------------------- Result 115 ---------------------------------------------
Log out the user . --> Performs policks --> Socre: 1.0

[[[[Adv]]]]: public void [[logout]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[request]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[session]] = [[request]] . getSession ( "False" != "False" ) ; if ( [[session]] != null ) { logger . debug ( "Invalidating session: " + [[session]] . getId ( ) ) ; [[session]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[context]] = SecurityContextHolder . getContext ( ) ; [[context]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .

[[[[Adv]]]]: public void [[polacks]] ( HttpServletRequest [[praying]] , HttpServletResponse response , Authentication authentication ) { Assert . notNull ( [[praying]] , "HttpServletRequest required" ) ; if ( invalidateHttpSession ) { HttpSession [[lecture]] = [[praying]] . getSession ( "False" != "False" ) ; if ( [[lecture]] != null ) { logger . debug ( "Invalidating session: " + [[lecture]] . getId ( ) ) ; [[lecture]] . invalidate ( ) ; } } if ( clearAuthentication ) { SecurityContext [[background]] = SecurityContextHolder . getContext ( ) ; [[background]] . setAuthentication ( null ) ; } SecurityContextHolder . clearContext ( ) ; }
[[[[Nl]]]]: Requires the request to be passed in .
--------------------------------------------- Result 116 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 111 / 5 / 0 / 116:  12%|█▏        | 116/1000 [30:15<3:50:38, 15.65s/it][Succeeded / Failed / Skipped / Total] 111 / 5 / 0 / 116:  12%|█▏        | 117/1000 [30:21<3:49:09, 15.57s/it][Succeeded / Failed / Skipped / Total] 112 / 5 / 0 / 117:  12%|█▏        | 117/1000 [30:21<3:49:09, 15.57s/it][Succeeded / Failed / Skipped / Total] 112 / 5 / 0 / 117:  12%|█▏        | 118/1000 [30:26<3:47:32, 15.48s/it][Succeeded / Failed / Skipped / Total] 113 / 5 / 0 / 118:  12%|█▏        | 118/1000 [30:26<3:47:32, 15.48s/it][Succeeded / Failed / Skipped / Total] 113 / 5 / 0 / 118:  12%|█▏        | 119/1000 [32:09<3:58:03, 16.21s/it][Succeeded / Failed / Skipped / Total] 114 / 5 / 0 / 119:  12%|█▏        | 119/1000 [32:09<3:58:03, 16.21s/it][Succeeded / Failed / Skipped / Total] 114 / 5 / 0 / 119:  12%|█▏        | 120/1000 [32:24<3:57:42, 16.21s/it][Succeeded / Failed / Skipped / Total] 115 / 5 / 0 / 120:  12%|█▏        | 120/1000 [32:24<3:57:42, 16.21s/it][Succeeded / Failed / Skipped / Total] 115 / 5 / 0 / 120:  12%|█▏        | 121/1000 [32:25<3:55:36, 16.08s/it][Succeeded / Failed / Skipped / Total] 116 / 5 / 0 / 121:  12%|█▏        | 121/1000 [32:25<3:55:36, 16.08s/it][Succeeded / Failed / Skipped / Total] 116 / 5 / 0 / 121:  12%|█▏        | 122/1000 [32:27<3:53:36, 15.96s/it][Succeeded / Failed / Skipped / Total] 117 / 5 / 0 / 122:  12%|█▏        | 122/1000 [32:27<3:53:36, 15.96s/it][Succeeded / Failed / Skipped / Total] 117 / 5 / 0 / 122:  12%|█▏        | 123/1000 [32:37<3:52:40, 15.92s/it]Authenticates the given authentication token . --> Authenticate a security token . --> Socre: 1.0

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[auth]] ) throws AuthenticationException { if ( ! ( [[auth]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[request]] = ( UsernamePasswordAuthenticationToken ) [[auth]] ; Set < GrantedAuthority > [[authorities]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential

[[[[Adv]]]]: public Authentication authenticate ( Authentication [[superstitions]] ) throws AuthenticationException { if ( ! ( [[superstitions]] instanceof UsernamePasswordAuthenticationToken ) ) { return null ; } UsernamePasswordAuthenticationToken [[asking]] = ( UsernamePasswordAuthenticationToken ) [[superstitions]] ; Set < GrantedAuthority > [[government]] ; try {
[[[[Nl]]]]: Attempts to login the user given the Authentication objects principal and credential
--------------------------------------------- Result 117 ---------------------------------------------
Sets the environment properties . --> Sets the skesurgeon --> Socre: 1.0

[[[[Adv]]]]: public void [[setContextEnvironmentProperties]] ( Map < String , Object > [[environment]] ) { Assert . notEmpty ( [[environment]] , "environment must not be empty" ) ; this . [[contextEnvironmentProperties]] = new Hashtable <> ( [[environment]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .

[[[[Adv]]]]: public void [[neurosurgeon]] ( Map < String , Object > [[framework]] ) { Assert . notEmpty ( [[framework]] , "environment must not be empty" ) ; this . [[kyung]] = new Hashtable <> ( [[framework]] ) ; }
[[[[Nl]]]]: Allows a custom environment properties to be used to create initial LDAP context .
--------------------------------------------- Result 118 ---------------------------------------------
Returns the full URL of this request . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ Override public String [[getRedirectUrl]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .

[[[[Adv]]]]: @ Override public String [[fixated]] ( ) { return UrlUtils . buildFullRequestUrl ( scheme , serverName , serverPort , requestURI , queryString ) ; }
[[[[Nl]]]]: Indicates the URL that the user agent used for this request .
--------------------------------------------- Result 119 ---------------------------------------------
Render the end of the tag . --> Prints a carlton --> Socre: 1.0

[[[[Adv]]]]: public int [[doEndTag]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .

[[[[Adv]]]]: public int [[carlton]] ( ) throws JspException { try { if ( ! authorized && TagLibConfig . isUiSecurityDisabled ( ) ) { pageContext . getOut ( ) . write ( TagLibConfig . getSecuredUiSuffix ( ) ) ; } } catch ( IOException e ) { throw new JspException ( e ) ; } return EVAL_PAGE ; }
[[[[Nl]]]]: Default processing of the end tag returning EVAL_PAGE .
--------------------------------------------- Result 120 ---------------------------------------------
Initializes the user details service . --> Create a new user --> Socre: 1.0

[[[[Adv]]]]: @ Override protected void [[initUserDetailsService]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails [[userDetails]] : this . [[users]] ) { getUserDetailsService ( ) . createUser ( [[userDetails]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .

[[[[Adv]]]]: @ Override protected void [[yugoslavian]] ( ) throws Exception { for ( UserDetailsBuilder userBuilder : userBuilders ) { getUserDetailsService ( ) . createUser ( userBuilder . build ( ) ) ; } for ( UserDetails [[nae]] : this . [[onlookers]] ) { getUserDetailsService ( ) . createUser ( [[nae]] ) ; } }
[[[[Nl]]]]: Populates the users that have been added .
--------------------------------------------- Result 121 ---------------------------------------------
Returns the UserDetailsService . --> Warned by Spring context --> Socre: 1.0

[[[[Adv]]]]: private UserDetailsService [[getUserDetailsService]] ( ) { Map < String , ? > [[beans]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[beans]] . size ( ) == 0 ) { [[beans]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[beans]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[beans]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[beans]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .

[[[[Adv]]]]: private UserDetailsService [[wakened]] ( ) { Map < String , ? > [[spinach]] = getBeansOfType ( CachingUserDetailsService . class ) ; if ( [[spinach]] . size ( ) == 0 ) { [[spinach]] = getBeansOfType ( UserDetailsService . class ) ; } if ( [[spinach]] . size ( ) == 0 ) { throw new ApplicationContextException ( "No UserDetailsService registered." ) ; } else if ( [[spinach]] . size ( ) > 1 ) { throw new ApplicationContextException ( "More than one UserDetailsService registered. Please " + "use a specific Id reference in <remember-me/> <openid-login/> or <x509 /> elements." ) ; } return ( UserDetailsService ) [[spinach]] . values ( ) . toArray ( ) [ 0 ] ; }
[[[[Nl]]]]: Obtains a user details service for use in RememberMeServices etc . Will return a caching version if available so should not be used for beans which need to separate the two .
--------------------------------------------- Result 122 ---------------------------------------------
Add pkce parameters . --> Send hub code to hubhub --> Socre: 1.0

[[[[Adv]]]]: private void [[addPkceParameters]] ( Map < String , Object > attributes , Map < String , Object > [[additionalParameters]] ) { String [[codeVerifier]] = this . [[codeVerifierGenerator]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , [[codeVerifier]] ) ; try { String codeChallenge = createCodeChallenge ( [[codeVerifier]] ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[additionalParameters]] . put ( PkceParameterNames . CODE_CHALLENGE , [[codeVerifier]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests

[[[[Adv]]]]: private void [[hubbell]] ( Map < String , Object > attributes , Map < String , Object > [[betraying]] ) { String [[jess]] = this . [[bebop]] . generateKey ( ) ; attributes . put ( PkceParameterNames . CODE_VERIFIER , [[jess]] ) ; try { String codeChallenge = createCodeChallenge ( [[jess]] ) ; [[betraying]] . put ( PkceParameterNames . CODE_CHALLENGE , codeChallenge ) ; [[betraying]] . put ( PkceParameterNames . CODE_CHALLENGE_METHOD , "S256" ) ; } catch ( NoSuchAlgorithmException e ) { [[betraying]] . put ( PkceParameterNames . CODE_CHALLENGE , [[jess]] ) ; } }
[[[[Nl]]]]: Creates and adds additional PKCE parameters for use in the OAuth 2 . 0 Authorization and Access Token Requests
--------------------------------------------- Result 123 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 118 / 5 / 0 / 123:  12%|█▏        | 123/1000 [32:37<3:52:40, 15.92s/it][Succeeded / Failed / Skipped / Total] 118 / 5 / 0 / 123:  12%|█▏        | 124/1000 [32:53<3:52:25, 15.92s/it][Succeeded / Failed / Skipped / Total] 119 / 5 / 0 / 124:  12%|█▏        | 124/1000 [32:53<3:52:25, 15.92s/it][Succeeded / Failed / Skipped / Total] 119 / 5 / 0 / 124:  12%|█▎        | 125/1000 [33:07<3:51:53, 15.90s/it][Succeeded / Failed / Skipped / Total] 120 / 5 / 0 / 125:  12%|█▎        | 125/1000 [33:07<3:51:53, 15.90s/it][Succeeded / Failed / Skipped / Total] 120 / 5 / 0 / 125:  13%|█▎        | 126/1000 [35:29<4:06:09, 16.90s/it][Succeeded / Failed / Skipped / Total] 121 / 5 / 0 / 126:  13%|█▎        | 126/1000 [35:29<4:06:09, 16.90s/it][Succeeded / Failed / Skipped / Total] 121 / 5 / 0 / 126:  13%|█▎        | 127/1000 [36:32<4:11:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 122 / 5 / 0 / 127:  13%|█▎        | 127/1000 [36:32<4:11:09, 17.26s/it][Succeeded / Failed / Skipped / Total] 122 / 5 / 0 / 127:  13%|█▎        | 128/1000 [36:52<4:11:13, 17.29s/it][Succeeded / Failed / Skipped / Total] 123 / 5 / 0 / 128:  13%|█▎        | 128/1000 [36:52<4:11:13, 17.29s/it][Succeeded / Failed / Skipped / Total] 123 / 5 / 0 / 128:  13%|█▎        | 129/1000 [36:54<4:09:13, 17.17s/it]Determines if the request requires authentication . --> Called by Maven --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[requiresAuthentication]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[serviceTicketRequest]] = [[serviceTicketRequest]] ( request , response ) ; final boolean result = [[serviceTicketRequest]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[serviceTicketRequest]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .

[[[[Adv]]]]: protected boolean [[laban]] ( final HttpServletRequest request , final HttpServletResponse response ) { final boolean [[mma]] = [[mma]] ( request , response ) ; final boolean result = [[mma]] || proxyReceptorRequest ( request ) || ( proxyTicketRequest ( [[mma]] , request ) ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "requiresAuthentication = " + result ) ; } return result ; }
[[[[Nl]]]]: Overridden to provide proxying capabilities .
--------------------------------------------- Result 124 ---------------------------------------------
Handles request ticket request . --> dupe authentication requires authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[serviceTicketRequest]] ( final HttpServletRequest request , final HttpServletResponse [[response]] ) { boolean result = super . requiresAuthentication ( request , [[response]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .

[[[[Adv]]]]: private boolean [[dupe]] ( final HttpServletRequest request , final HttpServletResponse [[replies]] ) { boolean result = super . requiresAuthentication ( request , [[replies]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "serviceTicketRequest = " + result ) ; } return result ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a service ticket . This method exists for readability .
--------------------------------------------- Result 125 ---------------------------------------------
Verifies if the ticket should be authenticated . --> Perform Okin authentication --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyTicketRequest]] ( final boolean [[serviceTicketRequest]] , final HttpServletRequest [[request]] ) { if ( [[serviceTicketRequest]] ) { return "False" != "False" ; } final boolean [[result]] = authenticateAllArtifacts && obtainArtifact ( [[request]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .

[[[[Adv]]]]: private boolean [[okin]] ( final boolean [[showbox]] , final HttpServletRequest [[requisitioning]] ) { if ( [[showbox]] ) { return "False" != "False" ; } final boolean [[findings]] = authenticateAllArtifacts && obtainArtifact ( [[requisitioning]] ) != null && ! authenticated ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyTicketRequest = " + [[findings]] ) ; } return [[findings]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to process a proxy ticket .
--------------------------------------------- Result 126 ---------------------------------------------
Determines if the application is authenticated . --> Check the approval of the current security context --> Socre: 1.0

[[[[Adv]]]]: private boolean [[authenticated]] ( ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[authentication]] != null && [[authentication]] . isAuthenticated ( ) && ! ( [[authentication]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .

[[[[Adv]]]]: private boolean [[approval]] ( ) { Authentication [[crypto]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return [[crypto]] != null && [[crypto]] . isAuthenticated ( ) && ! ( [[crypto]] instanceof AnonymousAuthenticationToken ) ; }
[[[[Nl]]]]: Determines if a user is already authenticated .
--------------------------------------------- Result 127 ---------------------------------------------
Determines whether the proxy should be proxied . --> Check for scaffolding --> Socre: 1.0

[[[[Adv]]]]: private boolean [[proxyReceptorRequest]] ( final HttpServletRequest [[request]] ) { final boolean [[result]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[request]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[result]] ) ; } return [[result]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .

[[[[Adv]]]]: private boolean [[scaffolding]] ( final HttpServletRequest [[called]] ) { final boolean [[figment]] = proxyReceptorConfigured ( ) && proxyReceptorMatcher . matches ( [[called]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "proxyReceptorRequest = " + [[figment]] ) ; } return [[figment]] ; }
[[[[Nl]]]]: Indicates if the request is elgible to be processed as the proxy receptor .
--------------------------------------------- Result 128 ---------------------------------------------
Builds the provider URL from a list of URLs . --> Initiate an organisation --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildProviderUrl]] ( List < String > [[urls]] , String [[baseDn]] ) { Assert . notNull ( [[baseDn]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[urls]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[baseDn]] . trim ( ) ; StringBuilder [[providerUrl]] = new StringBuilder ( ) ; for ( String [[serverUrl]] : [[urls]] ) { String trimmedUrl = [[serverUrl]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[providerUrl]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[providerUrl]] . append ( "/" ) ; } [[providerUrl]] . append ( trimmedBaseDn ) ; [[providerUrl]] . append ( " " ) ; } return [[providerUrl]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .

[[[[Adv]]]]: private static String [[omb]] ( List < String > [[phelan]] , String [[wastes]] ) { Assert . notNull ( [[wastes]] , "The Base DN for the LDAP server must not be null." ) ; Assert . notEmpty ( [[phelan]] , "At least one LDAP server URL must be provided." ) ; String trimmedBaseDn = [[wastes]] . trim ( ) ; StringBuilder [[innovate]] = new StringBuilder ( ) ; for ( String [[stairwell]] : [[phelan]] ) { String trimmedUrl = [[stairwell]] . trim ( ) ; if ( "" . equals ( trimmedUrl ) ) { continue ; } [[innovate]] . append ( trimmedUrl ) ; if ( ! trimmedUrl . endsWith ( "/" ) ) { [[innovate]] . append ( "/" ) ; } [[innovate]] . append ( trimmedBaseDn ) ; [[innovate]] . append ( " " ) ; } return [[innovate]] . toString ( ) ; }
[[[[Nl]]]]: Builds a Spring LDAP - compliant Provider URL string i . e . a space - separated list of LDAP servers with their base DNs . As the base DN must be identical for all servers it needs to be supplied only once .
--------------------------------------------- Result 129 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 124 / 5 / 0 / 129:  13%|█▎        | 129/1000 [36:54<4:09:13, 17.17s/it][Succeeded / Failed / Skipped / Total] 124 / 5 / 0 / 129:  13%|█▎        | 130/1000 [36:55<4:07:08, 17.04s/it][Succeeded / Failed / Skipped / Total] 125 / 5 / 0 / 130:  13%|█▎        | 130/1000 [36:55<4:07:08, 17.04s/it][Succeeded / Failed / Skipped / Total] 125 / 5 / 0 / 130:  13%|█▎        | 131/1000 [37:24<4:08:05, 17.13s/it][Succeeded / Failed / Skipped / Total] 126 / 5 / 0 / 131:  13%|█▎        | 131/1000 [37:24<4:08:05, 17.13s/it][Succeeded / Failed / Skipped / Total] 126 / 5 / 0 / 131:  13%|█▎        | 132/1000 [37:45<4:08:16, 17.16s/it][Succeeded / Failed / Skipped / Total] 127 / 5 / 0 / 132:  13%|█▎        | 132/1000 [37:45<4:08:16, 17.16s/it][Succeeded / Failed / Skipped / Total] 127 / 5 / 0 / 132:  13%|█▎        | 133/1000 [38:00<4:07:43, 17.14s/it][Succeeded / Failed / Skipped / Total] 128 / 5 / 0 / 133:  13%|█▎        | 133/1000 [38:00<4:07:43, 17.14s/it][Succeeded / Failed / Skipped / Total] 128 / 5 / 0 / 133:  13%|█▎        | 134/1000 [38:04<4:06:03, 17.05s/it][Succeeded / Failed / Skipped / Total] 129 / 5 / 0 / 134:  13%|█▎        | 134/1000 [38:04<4:06:03, 17.05s/it][Succeeded / Failed / Skipped / Total] 129 / 5 / 0 / 134:  14%|█▎        | 135/1000 [38:07<4:04:15, 16.94s/it][Succeeded / Failed / Skipped / Total] 130 / 5 / 0 / 135:  14%|█▎        | 135/1000 [38:07<4:04:15, 16.94s/it][Succeeded / Failed / Skipped / Total] 130 / 5 / 0 / 135:  14%|█▎        | 136/1000 [38:26<4:04:12, 16.96s/it]Retrieves a Mono of JWK set . --> Get a Mono of JWashions --> Socre: 1.0

[[[[Adv]]]]: private Mono < JWKSet > [[getJWKSet]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .

[[[[Adv]]]]: private Mono < JWKSet > [[fashions]] ( ) { return this . webClient . get ( ) . uri ( this . jwkSetURL ) . retrieve ( ) . bodyToMono ( String . class ) . map ( this :: parse ) . doOnNext ( jwkSet -> this . cachedJWKSet . set ( Mono . just ( jwkSet ) ) ) . cache ( ) ; }
[[[[Nl]]]]: Updates the cached JWK set from the configured URL .
--------------------------------------------- Result 130 ---------------------------------------------
Encodes a string using UTF - 8 . --> Encodes the given string . --> Socre: 1.0

[[[[Adv]]]]: private String utf8UrlEncode ( String [[value]] ) { try { return URLEncoder . encode ( [[value]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error [[err]] = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; [[err]] . initCause ( e ) ; throw [[err]] ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8

[[[[Adv]]]]: private String utf8UrlEncode ( String [[evaluation]] ) { try { return URLEncoder . encode ( [[evaluation]] , "UTF-8" ) ; } catch ( UnsupportedEncodingException e ) { Error [[hmm]] = new AssertionError ( "The Java platform guarantees UTF-8 support, but it seemingly is not present." ) ; [[hmm]] . initCause ( e ) ; throw [[hmm]] ; } }
[[[[Nl]]]]: Performs URL encoding with UTF - 8
--------------------------------------------- Result 131 ---------------------------------------------
Create a new SecurityExpression root for this security context . --> Create a new instance of MethodSecurityExpression --> Socre: 1.0

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[createSecurityExpressionRoot]] ( Authentication [[authentication]] , MethodInvocation [[invocation]] ) { MethodSecurityExpressionRoot [[root]] = new MethodSecurityExpressionRoot ( [[authentication]] ) ; [[root]] . setThis ( [[invocation]] . getThis ( ) ) ; [[root]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[root]] . setTrustResolver ( getTrustResolver ( ) ) ; [[root]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[root]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[root]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .

[[[[Adv]]]]: protected MethodSecurityExpressionOperations [[northbrook]] ( Authentication [[accredited]] , MethodInvocation [[allege]] ) { MethodSecurityExpressionRoot [[base]] = new MethodSecurityExpressionRoot ( [[accredited]] ) ; [[base]] . setThis ( [[allege]] . getThis ( ) ) ; [[base]] . setPermissionEvaluator ( getPermissionEvaluator ( ) ) ; [[base]] . setTrustResolver ( getTrustResolver ( ) ) ; [[base]] . setRoleHierarchy ( getRoleHierarchy ( ) ) ; [[base]] . setDefaultRolePrefix ( getDefaultRolePrefix ( ) ) ; return [[base]] ; }
[[[[Nl]]]]: Creates the root object for expression evaluation .
--------------------------------------------- Result 132 ---------------------------------------------
Determines if the principal has changed . --> method --> Socre: 1.0

[[[[Adv]]]]: protected boolean [[principalChanged]] ( HttpServletRequest request , Authentication [[currentAuthentication]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[currentAuthentication]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[currentAuthentication]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries

[[[[Adv]]]]: protected boolean [[thrice]] ( HttpServletRequest request , Authentication [[wouldnít]] ) { Object principal = getPreAuthenticatedPrincipal ( request ) ; if ( ( principal instanceof String ) && [[wouldnít]] . getName ( ) . equals ( principal ) ) { return "False" != "False" ; } if ( principal != null && principal . equals ( [[wouldnít]] . getPrincipal ( ) ) ) { return "False" != "False" ; } if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated principal has changed to " + principal + " and will be reauthenticated" ) ; } return "True" == "True" ; }
[[[[Nl]]]]: Determines if the current principal has changed . The default implementation tries
--------------------------------------------- Result 133 ---------------------------------------------
Get a collection of groups based on the authenticated user . --> We need to do this here so we need to do it here --> Socre: 1.0

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[getWebSphereGroupsBasedGrantedAuthorities]] ( ) { List < String > [[webSphereGroups]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[userGas]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[webSphereGroups]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[webSphereGroups]] + " mapped to Granted Authorities: " + [[userGas]] ) ; } return [[userGas]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .

[[[[Adv]]]]: private Collection < ? extends GrantedAuthority > [[sleepyhead]] ( ) { List < String > [[bearings]] = wasHelper . getGroupsForCurrentUser ( ) ; Collection < ? extends GrantedAuthority > [[laughingstock]] = webSphereGroups2GrantedAuthoritiesMapper . getGrantedAuthorities ( [[bearings]] ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "WebSphere groups: " + [[bearings]] + " mapped to Granted Authorities: " + [[laughingstock]] ) ; } return [[laughingstock]] ; }
[[[[Nl]]]]: Get a list of Granted Authorities based on the current user s WebSphere groups .
--------------------------------------------- Result 134 ---------------------------------------------
Gets the pre - authenticated principal . --> This method is overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object [[principal]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[principal]] ) ; } return [[principal]] ; }
[[[[Nl]]]]: Return the WebSphere user name .

[[[[Adv]]]]: protected Object [[butterworth]] ( HttpServletRequest [[realized]] ) { Object [[dominant]] = wasHelper . getCurrentUserName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated WebSphere principal: " + [[dominant]] ) ; } return [[dominant]] ; }
[[[[Nl]]]]: Return the WebSphere user name .
--------------------------------------------- Result 135 ---------------------------------------------
Get a portion of a byte array . --> also used in tests --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[subArray]] ( byte [ ] [[array]] , int beginIndex , int [[endIndex]] ) { int [[length]] = [[endIndex]] - beginIndex ; byte [ ] [[subarray]] = new byte [ [[length]] ] ; System . arraycopy ( [[array]] , beginIndex , [[subarray]] , 0 , [[length]] ) ; return [[subarray]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .

[[[[Adv]]]]: public static byte [ ] [[hoy]] ( byte [ ] [[grid]] , int beginIndex , int [[emperors]] ) { int [[seniority]] = [[emperors]] - beginIndex ; byte [ ] [[dressin]] = new byte [ [[seniority]] ] ; System . arraycopy ( [[grid]] , beginIndex , [[dressin]] , 0 , [[seniority]] ) ; return [[dressin]] ; }
[[[[Nl]]]]: Extract a sub array of bytes out of the byte array .
--------------------------------------------- Result 136 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 131 / 5 / 0 / 136:  14%|█▎        | 136/1000 [38:26<4:04:12, 16.96s/it][Succeeded / Failed / Skipped / Total] 131 / 5 / 0 / 136:  14%|█▎        | 137/1000 [38:27<4:02:16, 16.84s/it][Succeeded / Failed / Skipped / Total] 132 / 5 / 0 / 137:  14%|█▎        | 137/1000 [38:27<4:02:16, 16.84s/it][Succeeded / Failed / Skipped / Total] 132 / 5 / 0 / 137:  14%|█▍        | 138/1000 [38:29<4:00:27, 16.74s/it][Succeeded / Failed / Skipped / Total] 133 / 5 / 0 / 138:  14%|█▍        | 138/1000 [38:29<4:00:27, 16.74s/it][Succeeded / Failed / Skipped / Total] 133 / 5 / 0 / 138:  14%|█▍        | 139/1000 [38:31<3:58:40, 16.63s/it][Succeeded / Failed / Skipped / Total] 134 / 5 / 0 / 139:  14%|█▍        | 139/1000 [38:31<3:58:40, 16.63s/it][Succeeded / Failed / Skipped / Total] 134 / 5 / 0 / 139:  14%|█▍        | 140/1000 [38:36<3:57:11, 16.55s/it][Succeeded / Failed / Skipped / Total] 135 / 5 / 0 / 140:  14%|█▍        | 140/1000 [38:36<3:57:11, 16.55s/it][Succeeded / Failed / Skipped / Total] 135 / 5 / 0 / 140:  14%|█▍        | 141/1000 [40:05<4:04:14, 17.06s/it][Succeeded / Failed / Skipped / Total] 136 / 5 / 0 / 141:  14%|█▍        | 141/1000 [40:05<4:04:14, 17.06s/it][Succeeded / Failed / Skipped / Total] 136 / 5 / 0 / 141:  14%|█▍        | 142/1000 [40:31<4:04:52, 17.12s/it]Gets the granted authorities for the given list of attributes . --> bucket authority --> Socre: 1.0

[[[[Adv]]]]: public List < GrantedAuthority > [[getGrantedAuthorities]] ( Collection < String > [[attributes]] ) { ArrayList < GrantedAuthority > [[gaList]] = new ArrayList <> ( ) ; for ( String [[attribute]] : [[attributes]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[attribute]] ) ; if ( c != null ) { [[gaList]] . addAll ( c ) ; } } [[gaList]] . trimToSize ( ) ; return [[gaList]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .

[[[[Adv]]]]: public List < GrantedAuthority > [[blackmails]] ( Collection < String > [[peculiarity]] ) { ArrayList < GrantedAuthority > [[yigit]] = new ArrayList <> ( ) ; for ( String [[peculiarity]] : [[peculiarity]] ) { Collection < GrantedAuthority > c = attributes2grantedAuthoritiesMap . get ( [[peculiarity]] ) ; if ( c != null ) { [[yigit]] . addAll ( c ) ; } } [[yigit]] . trimToSize ( ) ; return [[yigit]] ; }
[[[[Nl]]]]: Map the given array of attributes to Spring Security GrantedAuthorities .
--------------------------------------------- Result 137 ---------------------------------------------
Concatenate multiple arrays together . --> Zancian --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[concatenate]] ( byte [ ] ... [[arrays]] ) { int length = 0 ; for ( byte [ ] array : [[arrays]] ) { length += array . length ; } byte [ ] [[newArray]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[arrays]] ) { System . arraycopy ( array , 0 , [[newArray]] , destPos , array . length ) ; destPos += array . length ; } return [[newArray]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .

[[[[Adv]]]]: public static byte [ ] [[izan]] ( byte [ ] ... [[sut]] ) { int length = 0 ; for ( byte [ ] array : [[sut]] ) { length += array . length ; } byte [ ] [[flair]] = new byte [ length ] ; int destPos = 0 ; for ( byte [ ] array : [[sut]] ) { System . arraycopy ( array , 0 , [[flair]] , destPos , array . length ) ; destPos += array . length ; } return [[flair]] ; }
[[[[Nl]]]]: Combine the individual byte arrays into one array .
--------------------------------------------- Result 138 ---------------------------------------------
Gets the granted authority collection . --> Generate stemming algorithm . --> Socre: 1.0

[[[[Adv]]]]: private Collection < GrantedAuthority > [[getGrantedAuthorityCollection]] ( Object value ) { Collection < GrantedAuthority > [[result]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[result]] , value ) ; return [[result]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities

[[[[Adv]]]]: private Collection < GrantedAuthority > [[aloha]] ( Object value ) { Collection < GrantedAuthority > [[stemming]] = new ArrayList <> ( ) ; addGrantedAuthorityCollection ( [[stemming]] , value ) ; return [[stemming]] ; }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities
--------------------------------------------- Result 139 ---------------------------------------------
Pre - processes a map of map authorities . --> Creates a collection of origins from a set of authorities . --> Socre: 1.0

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[preProcessMap]] ( Map < ? , ? > [[orgMap]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[orgMap]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[orgMap]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections

[[[[Adv]]]]: private Map < String , Collection < GrantedAuthority > > [[origins]] ( Map < ? , ? > [[mythologies]] ) { Map < String , Collection < GrantedAuthority > > result = new HashMap < String , Collection < GrantedAuthority > > ( [[mythologies]] . size ( ) ) ; for ( Map . Entry < ? , ? > entry : [[mythologies]] . entrySet ( ) ) { Assert . isInstanceOf ( String . class , entry . getKey ( ) , "attributes2grantedAuthoritiesMap contains non-String objects as keys" ) ; result . put ( ( String ) entry . getKey ( ) , getGrantedAuthorityCollection ( entry . getValue ( ) ) ) ; } return result ; }
[[[[Nl]]]]: Preprocess the given map to convert all the values to GrantedAuthority collections
--------------------------------------------- Result 140 ---------------------------------------------
Adds a granted authority collection to the result . --> Utility method for testing --> Socre: 1.0

[[[[Adv]]]]: private void [[addGrantedAuthorityCollection]] ( Collection < GrantedAuthority > [[result]] , Object [[value]] ) { if ( [[value]] == null ) { return ; } if ( [[value]] instanceof Collection < ? > ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Collection < ? > ) [[value]] ) ; } else if ( [[value]] instanceof Object [ ] ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( Object [ ] ) [[value]] ) ; } else if ( [[value]] instanceof String ) { [[addGrantedAuthorityCollection]] ( [[result]] , ( String ) [[value]] ) ; } else if ( [[value]] instanceof GrantedAuthority ) { [[result]] . add ( ( GrantedAuthority ) [[value]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[value]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .

[[[[Adv]]]]: private void [[yhat]] ( Collection < GrantedAuthority > [[fruit]] , Object [[evaluating]] ) { if ( [[evaluating]] == null ) { return ; } if ( [[evaluating]] instanceof Collection < ? > ) { [[yhat]] ( [[fruit]] , ( Collection < ? > ) [[evaluating]] ) ; } else if ( [[evaluating]] instanceof Object [ ] ) { [[yhat]] ( [[fruit]] , ( Object [ ] ) [[evaluating]] ) ; } else if ( [[evaluating]] instanceof String ) { [[yhat]] ( [[fruit]] , ( String ) [[evaluating]] ) ; } else if ( [[evaluating]] instanceof GrantedAuthority ) { [[fruit]] . add ( ( GrantedAuthority ) [[evaluating]] ) ; } else { throw new IllegalArgumentException ( "Invalid object type: " + [[evaluating]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Convert the given value to a collection of Granted Authorities adding the result to the given result collection .
--------------------------------------------- Result 141 ---------------------------------------------
Load user by assertion . --> Liefert den uebergebenen als als alurueck --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[loadUserByAssertion]] ( final Assertion [[assertion]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[assertion]] , "" ) ; return this . [[authenticationUserDetailsService]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .

[[[[Adv]]]]: protected UserDetails [[lumumba]] ( final Assertion [[denunciation]] ) { final CasAssertionAuthenticationToken token = new CasAssertionAuthenticationToken ( [[denunciation]] , "" ) ; return this . [[zurich]] . loadUserDetails ( token ) ; }
[[[[Nl]]]]: Template method for retrieving the UserDetails based on the assertion . Default is to call configured userDetailsService and pass the username . Deployers can override this method and retrieve the user based on any criteria they desire .
--------------------------------------------- Result 142 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 137 / 5 / 0 / 142:  14%|█▍        | 142/1000 [40:31<4:04:52, 17.12s/it][Succeeded / Failed / Skipped / Total] 137 / 5 / 0 / 142:  14%|█▍        | 143/1000 [40:33<4:03:03, 17.02s/it][Succeeded / Failed / Skipped / Total] 138 / 5 / 0 / 143:  14%|█▍        | 143/1000 [40:33<4:03:03, 17.02s/it][Succeeded / Failed / Skipped / Total] 138 / 5 / 0 / 143:  14%|█▍        | 144/1000 [40:46<4:02:24, 16.99s/it][Succeeded / Failed / Skipped / Total] 139 / 5 / 0 / 144:  14%|█▍        | 144/1000 [40:46<4:02:24, 16.99s/it][Succeeded / Failed / Skipped / Total] 139 / 5 / 0 / 144:  14%|█▍        | 145/1000 [40:47<4:00:31, 16.88s/it][Succeeded / Failed / Skipped / Total] 140 / 5 / 0 / 145:  14%|█▍        | 145/1000 [40:47<4:00:31, 16.88s/it][Succeeded / Failed / Skipped / Total] 140 / 5 / 0 / 145:  15%|█▍        | 146/1000 [40:50<3:58:51, 16.78s/it][Succeeded / Failed / Skipped / Total] 141 / 5 / 0 / 146:  15%|█▍        | 146/1000 [40:50<3:58:51, 16.78s/it][Succeeded / Failed / Skipped / Total] 141 / 5 / 0 / 146:  15%|█▍        | 147/1000 [41:16<3:59:31, 16.85s/it][Succeeded / Failed / Skipped / Total] 142 / 5 / 0 / 147:  15%|█▍        | 147/1000 [41:16<3:59:31, 16.85s/it][Succeeded / Failed / Skipped / Total] 142 / 5 / 0 / 147:  15%|█▍        | 148/1000 [41:33<3:59:12, 16.85s/it]Build the redirect URL for the given request . --> Get singularity --> Socre: 1.0

[[[[Adv]]]]: protected String [[buildHttpsRedirectUrlForRequest]] ( HttpServletRequest [[request]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[request]] ) ; Integer [[httpsPort]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[httpsPort]] != null ) { RedirectUrlBuilder [[urlBuilder]] = new RedirectUrlBuilder ( ) ; [[urlBuilder]] . setScheme ( "https" ) ; [[urlBuilder]] . setServerName ( [[request]] . getServerName ( ) ) ; [[urlBuilder]] . setPort ( [[httpsPort]] . intValue ( ) ) ; [[urlBuilder]] . setContextPath ( [[request]] . getContextPath ( ) ) ; [[urlBuilder]] . setServletPath ( [[request]] . getServletPath ( ) ) ; [[urlBuilder]] . setPathInfo ( [[request]] . getPathInfo ( ) ) ; [[urlBuilder]] . setQuery ( [[request]] . getQueryString ( ) ) ; return [[urlBuilder]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .

[[[[Adv]]]]: protected String [[singularly]] ( HttpServletRequest [[requisitions]] ) throws IOException , ServletException { int serverPort = portResolver . getServerPort ( [[requisitions]] ) ; Integer [[suburbia]] = portMapper . lookupHttpsPort ( Integer . valueOf ( serverPort ) ) ; if ( [[suburbia]] != null ) { RedirectUrlBuilder [[miyamoto]] = new RedirectUrlBuilder ( ) ; [[miyamoto]] . setScheme ( "https" ) ; [[miyamoto]] . setServerName ( [[requisitions]] . getServerName ( ) ) ; [[miyamoto]] . setPort ( [[suburbia]] . intValue ( ) ) ; [[miyamoto]] . setContextPath ( [[requisitions]] . getContextPath ( ) ) ; [[miyamoto]] . setServletPath ( [[requisitions]] . getServletPath ( ) ) ; [[miyamoto]] . setPathInfo ( [[requisitions]] . getPathInfo ( ) ) ; [[miyamoto]] . setQuery ( [[requisitions]] . getQueryString ( ) ) ; return [[miyamoto]] . getUrl ( ) ; }
[[[[Nl]]]]: Builds a URL to redirect the supplied request to HTTPS . Used to redirect the current request to HTTPS before doing a forward to the login page .
--------------------------------------------- Result 143 ---------------------------------------------
Implement the interceptor method --> Intercept the interceptor --> Socre: 1.0

[[[[Adv]]]]: public Object invoke ( JoinPoint [[jp]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[jp]] ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .

[[[[Adv]]]]: public Object invoke ( JoinPoint [[md]] , AspectJCallback advisorProceed ) { InterceptorStatusToken token = super . beforeInvocation ( new MethodInvocationAdapter ( [[md]] ) ) ; Object result ; try { result = advisorProceed . proceedWithObject ( ) ; } finally { super . finallyInvocation ( token ) ; } return super . afterInvocation ( token , result ) ; }
[[[[Nl]]]]: Method that is suitable for user with traditional AspectJ - code aspects .
--------------------------------------------- Result 144 ---------------------------------------------
Gets the pre - authenticated principal . --> provide a shash --> Socre: 1.0

[[[[Adv]]]]: protected Object [[getPreAuthenticatedPrincipal]] ( HttpServletRequest [[httpRequest]] ) { Object principal = [[httpRequest]] . getUserPrincipal ( ) == null ? null : [[httpRequest]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .

[[[[Adv]]]]: protected Object [[shashank]] ( HttpServletRequest [[manufactures]] ) { Object principal = [[manufactures]] . getUserPrincipal ( ) == null ? null : [[manufactures]] . getUserPrincipal ( ) . getName ( ) ; if ( logger . isDebugEnabled ( ) ) { logger . debug ( "PreAuthenticated J2EE principal: " + principal ) ; } return principal ; }
[[[[Nl]]]]: Return the J2EE user name .
--------------------------------------------- Result 145 ---------------------------------------------
Convert roles to roles --> Ensure the role has the role --> Socre: 1.0

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[roles]] ) { for ( int i = 0 ; i < [[roles]] . length ; i ++ ) { [[roles]] [ i ] = "ROLE_" + [[roles]] [ i ] ; } return [[roles]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .

[[[[Adv]]]]: private static String [ ] hasAnyRole ( String ... [[capacity]] ) { for ( int i = 0 ; i < [[capacity]] . length ; i ++ ) { [[capacity]] [ i ] = "ROLE_" + [[capacity]] [ i ] ; } return [[capacity]] ; }
[[[[Nl]]]]: Creates a String for specifying that a user requires one of many roles .
--------------------------------------------- Result 146 ---------------------------------------------
Returns the role s role . --> Returns moribund --> Socre: 1.0

[[[[Adv]]]]: private static String [[hasRole]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .

[[[[Adv]]]]: private static String [[moribund]] ( String role ) { Assert . isTrue ( ! role . startsWith ( "ROLE_" ) , ( ) -> role + " should not start with ROLE_ since ROLE_ is automatically prepended when using hasRole. Consider using hasAuthority or access instead." ) ; return "ROLE_" + role ; }
[[[[Nl]]]]: Creates a String for specifying a user requires a role .
--------------------------------------------- Result 147 ---------------------------------------------
Extracts the auto login token from the cookie token . --> Retrieves UserDetails --> Socre: 1.0

[[[[Adv]]]]: protected UserDetails [[processAutoLoginCookie]] ( String [ ] [[cookieTokens]] , HttpServletRequest request , HttpServletResponse [[response]] ) { if ( [[cookieTokens]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[cookieTokens]] ) + "'" ) ; } final String presentedSeries = [[cookieTokens]] [ 0 ] ; final String presentedToken = [[cookieTokens]] [ 1 ] ; PersistentRememberMeToken [[token]] = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( [[token]] == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .

[[[[Adv]]]]: protected UserDetails [[finance]] ( String [ ] [[tossers]] , HttpServletRequest request , HttpServletResponse [[rebuttal]] ) { if ( [[tossers]] . length != 2 ) { throw new InvalidCookieException ( "Cookie token did not contain " + 2 + " tokens, but contained '" + Arrays . asList ( [[tossers]] ) + "'" ) ; } final String presentedSeries = [[tossers]] [ 0 ] ; final String presentedToken = [[tossers]] [ 1 ] ; PersistentRememberMeToken [[symbolism]] = tokenRepository . getTokenForSeries ( presentedSeries ) ; if ( [[symbolism]] == null ) {
[[[[Nl]]]]: Locates the presented cookie data in the token repository using the series id . If the data compares successfully with that in the persistent store a new token is generated and stored with the same series . The corresponding cookie value is set on the response .
--------------------------------------------- Result 148 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 143 / 5 / 0 / 148:  15%|█▍        | 148/1000 [41:33<3:59:12, 16.85s/it][Succeeded / Failed / Skipped / Total] 143 / 5 / 0 / 148:  15%|█▍        | 149/1000 [41:42<3:58:10, 16.79s/it][Succeeded / Failed / Skipped / Total] 144 / 5 / 0 / 149:  15%|█▍        | 149/1000 [41:42<3:58:10, 16.79s/it][Succeeded / Failed / Skipped / Total] 144 / 5 / 0 / 149:  15%|█▌        | 150/1000 [41:46<3:56:42, 16.71s/it][Succeeded / Failed / Skipped / Total] 145 / 5 / 0 / 150:  15%|█▌        | 150/1000 [41:46<3:56:42, 16.71s/it][Succeeded / Failed / Skipped / Total] 145 / 5 / 0 / 150:  15%|█▌        | 151/1000 [41:47<3:54:56, 16.60s/it][Succeeded / Failed / Skipped / Total] 146 / 5 / 0 / 151:  15%|█▌        | 151/1000 [41:47<3:54:56, 16.60s/it][Succeeded / Failed / Skipped / Total] 146 / 5 / 0 / 151:  15%|█▌        | 152/1000 [41:53<3:53:40, 16.53s/it][Succeeded / Failed / Skipped / Total] 147 / 5 / 0 / 152:  15%|█▌        | 152/1000 [41:53<3:53:40, 16.53s/it][Succeeded / Failed / Skipped / Total] 147 / 5 / 0 / 152:  15%|█▌        | 153/1000 [42:00<3:52:33, 16.47s/it][Succeeded / Failed / Skipped / Total] 148 / 5 / 0 / 153:  15%|█▌        | 153/1000 [42:00<3:52:33, 16.47s/it][Succeeded / Failed / Skipped / Total] 148 / 5 / 0 / 153:  15%|█▌        | 154/1000 [42:36<3:54:03, 16.60s/it][Succeeded / Failed / Skipped / Total] 149 / 5 / 0 / 154:  15%|█▌        | 154/1000 [42:36<3:54:03, 16.60s/it][Succeeded / Failed / Skipped / Total] 149 / 5 / 0 / 154:  16%|█▌        | 155/1000 [43:14<3:55:42, 16.74s/it]On login success . --> zugtodo --> Socre: 1.0

[[[[Adv]]]]: protected void [[onLoginSuccess]] ( HttpServletRequest [[request]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[request]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .

[[[[Adv]]]]: protected void [[zug]] ( HttpServletRequest [[please]] , HttpServletResponse response , Authentication successfulAuthentication ) { String username = successfulAuthentication . getName ( ) ; logger . debug ( "Creating new persistent login for user " + username ) ; PersistentRememberMeToken persistentToken = new PersistentRememberMeToken ( username , generateSeriesData ( ) , generateTokenData ( ) , new Date ( ) ) ; try { tokenRepository . createNewToken ( persistentToken ) ; addCookie ( persistentToken , [[please]] , response ) ; } catch ( Exception e ) { logger . error ( "Failed to save persistent token " , e ) ; } }
[[[[Nl]]]]: Creates a new persistent login token with a new series number stores the data in the persistent token repository and adds the corresponding cookie to the response .
--------------------------------------------- Result 149 ---------------------------------------------
Attempts to exit the login user . --> Obtain Authentication object not found --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptExitUser]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .

[[[[Adv]]]]: protected Authentication [[knorr]] ( HttpServletRequest request ) throws AuthenticationCredentialsNotFoundException {
[[[[Nl]]]]: Attempt to exit from an already switched user .
--------------------------------------------- Result 150 ---------------------------------------------
Sets the exit user url . --> parses sitorama --> Socre: 1.0

[[[[Adv]]]]: public void [[setExitUserUrl]] ( String [[exitUserUrl]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[exitUserUrl]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[exitUserUrl]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .

[[[[Adv]]]]: public void [[panorama]] ( String [[theologian]] ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( [[theologian]] ) , "exitUserUrl cannot be empty and must be a valid redirect URL" ) ; this . exitUserMatcher = createMatcher ( [[theologian]] ) ; }
[[[[Nl]]]]: Set the URL to respond to exit user processing .
--------------------------------------------- Result 151 ---------------------------------------------
Display public index --> Display a robot --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[displayPublicIndex]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .

[[[[Adv]]]]: @ RequestMapping ( value = "/hello.htm" , method = RequestMethod . GET ) public ModelAndView [[catrina]] ( ) { Contact rnd = contactManager . getRandomContact ( ) ; return new ModelAndView ( "hello" , "contact" , rnd ) ; }
[[[[Nl]]]]: The public index page used for unauthenticated users .
--------------------------------------------- Result 152 ---------------------------------------------
Build the spring security filter . --> Build shiina . --> Socre: 1.0

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[springSecurityFilterChain]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain

[[[[Adv]]]]: @ Bean ( name = AbstractSecurityWebApplicationInitializer . DEFAULT_FILTER_NAME ) public Filter [[shiina]] ( ) throws Exception { boolean hasConfigurers = webSecurityConfigurers != null && ! webSecurityConfigurers . isEmpty ( ) ; if ( ! hasConfigurers ) { WebSecurityConfigurerAdapter adapter = objectObjectPostProcessor . postProcess ( new WebSecurityConfigurerAdapter ( ) { } ) ; webSecurity . apply ( adapter ) ; } return webSecurity . build ( ) ; }
[[[[Nl]]]]: Creates the Spring Security Filter Chain
--------------------------------------------- Result 153 ---------------------------------------------
Decodes the given token . --> Parses password . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Jwt [[decode]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format

[[[[Adv]]]]: @ Override public Jwt [[password]] ( String token ) throws JwtException { JWT jwt = parse ( token ) ; if ( jwt instanceof SignedJWT ) { Jwt createdJwt = createJwt ( token , jwt ) ; return validateJwt ( createdJwt ) ; } throw new JwtException ( "Unsupported algorithm of " + jwt . getHeader ( ) . getAlgorithm ( ) ) ; }
[[[[Nl]]]]: Decode and validate the JWT from its compact claims representation format
--------------------------------------------- Result 154 ---------------------------------------------
Allow access to access --> is ida? --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingAccessExpression]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[handler]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[handler]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[ioException]] = new IOException ( ) ; [[ioException]] . initCause ( e ) ; throw [[ioException]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[handler]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .

[[[[Adv]]]]: public boolean [[ida]] ( ) throws IOException { if ( SecurityContextHolder . getContext ( ) . getAuthentication ( ) == null ) { return "False" != "False" ; } SecurityExpressionHandler < FilterInvocation > [[cerberus]] = getExpressionHandler ( ) ; Expression accessExpression ; try { accessExpression = [[cerberus]] . getExpressionParser ( ) . parseExpression ( getAccess ( ) ) ; } catch ( ParseException e ) { IOException [[peaceful]] = new IOException ( ) ; [[peaceful]] . initCause ( e ) ; throw [[peaceful]] ; } return ExpressionUtils . evaluateAsBoolean ( accessExpression , createExpressionEvaluationContext ( [[cerberus]] ) ) ; }
[[[[Nl]]]]: Make an authorization decision based on a Spring EL expression . See the Expression - Based Access Control chapter in Spring Security for details on what expressions can be used .
--------------------------------------------- Result 155 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 150 / 5 / 0 / 155:  16%|█▌        | 155/1000 [43:14<3:55:42, 16.74s/it][Succeeded / Failed / Skipped / Total] 150 / 5 / 0 / 155:  16%|█▌        | 156/1000 [43:15<3:54:01, 16.64s/it][Succeeded / Failed / Skipped / Total] 151 / 5 / 0 / 156:  16%|█▌        | 156/1000 [43:15<3:54:01, 16.64s/it][Succeeded / Failed / Skipped / Total] 151 / 5 / 0 / 156:  16%|█▌        | 157/1000 [43:19<3:52:38, 16.56s/it][Succeeded / Failed / Skipped / Total] 152 / 5 / 0 / 157:  16%|█▌        | 157/1000 [43:19<3:52:38, 16.56s/it][Succeeded / Failed / Skipped / Total] 152 / 5 / 0 / 157:  16%|█▌        | 158/1000 [43:21<3:51:06, 16.47s/it][Succeeded / Failed / Skipped / Total] 153 / 5 / 0 / 158:  16%|█▌        | 158/1000 [43:21<3:51:06, 16.47s/it][Succeeded / Failed / Skipped / Total] 153 / 5 / 0 / 158:  16%|█▌        | 159/1000 [43:24<3:49:36, 16.38s/it][Succeeded / Failed / Skipped / Total] 154 / 5 / 0 / 159:  16%|█▌        | 159/1000 [43:24<3:49:36, 16.38s/it][Succeeded / Failed / Skipped / Total] 154 / 5 / 0 / 159:  16%|█▌        | 160/1000 [43:26<3:48:06, 16.29s/it][Succeeded / Failed / Skipped / Total] 155 / 5 / 0 / 160:  16%|█▌        | 160/1000 [43:26<3:48:06, 16.29s/it][Succeeded / Failed / Skipped / Total] 155 / 5 / 0 / 160:  16%|█▌        | 161/1000 [43:43<3:47:49, 16.29s/it]Check if the request is allowed by the URL --> Perform a waterline --> Socre: 1.0

[[[[Adv]]]]: public boolean [[authorizeUsingUrlCheck]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .

[[[[Adv]]]]: public boolean [[waterline]] ( ) throws IOException { String contextPath = ( ( HttpServletRequest ) getRequest ( ) ) . getContextPath ( ) ; Authentication currentUser = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; return getPrivilegeEvaluator ( ) . isAllowed ( contextPath , getUrl ( ) , getMethod ( ) , currentUser ) ; }
[[[[Nl]]]]: Make an authorization decision based on the URL and HTTP method attributes . True is returned if the user is allowed to access the given URL as defined .
--------------------------------------------- Result 156 ---------------------------------------------
Converts a JWT into a collection of granted authorities . --> A set of granted scopes . --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[convert]] ( Jwt [[jwt]] ) { return getScopes ( [[jwt]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities

[[[[Adv]]]]: @ Override public Collection < GrantedAuthority > [[turns]] ( Jwt [[beecham]] ) { return getScopes ( [[beecham]] ) . stream ( ) . map ( authority -> SCOPE_AUTHORITY_PREFIX + authority ) . map ( SimpleGrantedAuthority :: new ) . collect ( Collectors . toList ( ) ) ; }
[[[[Nl]]]]: Extracts the authorities
--------------------------------------------- Result 157 ---------------------------------------------
Generates a Csrf token . --> Wrap the request . --> Socre: 1.0

[[[[Adv]]]]: @ Override public CsrfToken [[generateToken]] ( HttpServletRequest [[request]] ) { return wrap ( [[request]] , this . [[delegate]] . generateToken ( [[request]] ) ) ; }
[[[[Nl]]]]: Generates a new token

[[[[Adv]]]]: @ Override public CsrfToken [[sweep]] ( HttpServletRequest [[asks]] ) { return wrap ( [[asks]] , this . [[despatch]] . generateToken ( [[asks]] ) ) ; }
[[[[Nl]]]]: Generates a new token
--------------------------------------------- Result 158 ---------------------------------------------
Attempt to switch a user . --> Handles a username request --> Socre: 1.0

[[[[Adv]]]]: protected Authentication [[attemptSwitchUser]] ( HttpServletRequest [[request]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[targetUserRequest]] ; String username = [[request]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .

[[[[Adv]]]]: protected Authentication [[rovers]] ( HttpServletRequest [[inviting]] ) throws AuthenticationException { UsernamePasswordAuthenticationToken [[cortes]] ; String username = [[inviting]] . getParameter ( this . usernameParameter ) ; if ( username == null ) { username = "" ; } if ( this . logger . isDebugEnabled ( ) ) { this . logger . debug ( "Attempt to switch to user [" + username + "]" ) ; } UserDetails targetUser = this . userDetailsService . loadUserByUsername ( username ) ; this . userDetailsChecker . check ( targetUser ) ;
[[[[Nl]]]]: Attempt to switch to another user . If the user does not exist or is not active return null .
--------------------------------------------- Result 159 ---------------------------------------------
Display admin page . --> This method is deprecated --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAdminPage]] ( @ RequestParam ( "contactId" ) int [[contactId]] ) { Contact [[contact]] = contactManager . getById ( Long . valueOf ( [[contactId]] ) ) ; Acl [[acl]] = aclService . readAclById ( new ObjectIdentityImpl ( [[contact]] ) ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "contact" , [[contact]] ) ; [[model]] . put ( "acl" , [[acl]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[model]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/adminPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[guapo]] ( @ RequestParam ( "contactId" ) int [[gaulle]] ) { Contact [[coordinates]] = contactManager . getById ( Long . valueOf ( [[gaulle]] ) ) ; Acl [[hamstring]] = aclService . readAclById ( new ObjectIdentityImpl ( [[coordinates]] ) ) ; Map < String , Object > [[designing]] = new HashMap <> ( ) ; [[designing]] . put ( "contact" , [[coordinates]] ) ; [[designing]] . put ( "acl" , [[hamstring]] ) ; return new ModelAndView ( "adminPermission" , "model" , [[designing]] ) ; }
[[[[Nl]]]]: Displays the permission admin page for a particular contact .
--------------------------------------------- Result 160 ---------------------------------------------
Add a single permission . --> HTML linkPermission --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[addPermission]] ( AddPermission [[addPermission]] , BindingResult [[result]] , ModelMap model ) { addPermissionValidator . validate ( [[addPermission]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[addPermission]] . getRecipient ( ) ) ; Permission [[permission]] = permissionFactory . buildFromMask ( [[addPermission]] . getPermission ( ) ) ; try { contactManager . [[addPermission]] ( [[addPermission]] . getContact ( ) , sid , [[permission]] ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[result]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . POST ) public String [[tonkin]] ( AddPermission [[mug]] , BindingResult [[culmination]] , ModelMap model ) { addPermissionValidator . validate ( [[tonkin]] , [[culmination]] ) ; if ( [[culmination]] . hasErrors ( ) ) { model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } PrincipalSid sid = new PrincipalSid ( [[tonkin]] . getRecipient ( ) ) ; Permission [[authorise]] = permissionFactory . buildFromMask ( [[tonkin]] . getPermission ( ) ) ; try { contactManager . [[mug]] ( [[tonkin]] . getContact ( ) , sid , [[authorise]] ) ; } catch ( DataAccessException existingPermission ) { existingPermission . printStackTrace ( ) ; [[culmination]] . rejectValue ( "recipient" , "err.recipientExistsForContact" , "Addition failure." ) ; model . put ( "recipients" , listRecipients ( ) ) ; model . put ( "permissions" , listPermissions ( ) ) ; return "addPermission" ; } return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles submission of the add permission form .
--------------------------------------------- Result 161 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 156 / 5 / 0 / 161:  16%|█▌        | 161/1000 [43:43<3:47:49, 16.29s/it][Succeeded / Failed / Skipped / Total] 156 / 5 / 0 / 161:  16%|█▌        | 162/1000 [43:44<3:46:17, 16.20s/it][Succeeded / Failed / Skipped / Total] 157 / 5 / 0 / 162:  16%|█▌        | 162/1000 [43:44<3:46:17, 16.20s/it][Succeeded / Failed / Skipped / Total] 157 / 5 / 0 / 162:  16%|█▋        | 163/1000 [43:47<3:44:54, 16.12s/it][Succeeded / Failed / Skipped / Total] 158 / 5 / 0 / 163:  16%|█▋        | 163/1000 [43:47<3:44:54, 16.12s/it][Succeeded / Failed / Skipped / Total] 158 / 5 / 0 / 163:  16%|█▋        | 164/1000 [43:53<3:43:42, 16.06s/it][Succeeded / Failed / Skipped / Total] 159 / 5 / 0 / 164:  16%|█▋        | 164/1000 [43:53<3:43:42, 16.06s/it][Succeeded / Failed / Skipped / Total] 159 / 5 / 0 / 164:  16%|█▋        | 165/1000 [43:53<3:42:06, 15.96s/it][Succeeded / Failed / Skipped / Total] 160 / 5 / 0 / 165:  16%|█▋        | 165/1000 [43:53<3:42:06, 15.96s/it][Succeeded / Failed / Skipped / Total] 160 / 5 / 0 / 165:  17%|█▋        | 166/1000 [44:00<3:41:06, 15.91s/it][Succeeded / Failed / Skipped / Total] 161 / 5 / 0 / 166:  17%|█▋        | 166/1000 [44:00<3:41:06, 15.91s/it][Succeeded / Failed / Skipped / Total] 161 / 5 / 0 / 166:  17%|█▋        | 167/1000 [44:25<3:41:35, 15.96s/it][Succeeded / Failed / Skipped / Total] 162 / 5 / 0 / 167:  17%|█▋        | 167/1000 [44:25<3:41:35, 15.96s/it][Succeeded / Failed / Skipped / Total] 162 / 5 / 0 / 167:  17%|█▋        | 168/1000 [44:53<3:42:17, 16.03s/it]Display the add permission for a contact --> Show custom permissions --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[displayAddPermissionPageForContact]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[contact]] = contactManager . getById ( contactId ) ; AddPermission [[addPermission]] = new AddPermission ( ) ; [[addPermission]] . setContact ( [[contact]] ) ; Map < String , Object > [[model]] = new HashMap <> ( ) ; [[model]] . put ( "addPermission" , [[addPermission]] ) ; [[model]] . put ( "recipients" , listRecipients ( ) ) ; [[model]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[model]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/addPermission.htm" , method = RequestMethod . GET ) public ModelAndView [[crocs]] ( @ RequestParam ( "contactId" ) long contactId ) { Contact [[tying]] = contactManager . getById ( contactId ) ; AddPermission [[cashes]] = new AddPermission ( ) ; [[cashes]] . setContact ( [[tying]] ) ; Map < String , Object > [[styling]] = new HashMap <> ( ) ; [[styling]] . put ( "addPermission" , [[cashes]] ) ; [[styling]] . put ( "recipients" , listRecipients ( ) ) ; [[styling]] . put ( "permissions" , listPermissions ( ) ) ; return new ModelAndView ( "addPermission" , [[styling]] ) ; }
[[[[Nl]]]]: Displays the add permission page for a contact .
--------------------------------------------- Result 162 ---------------------------------------------
Gets the role prefix . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private static String [[getRoleWithDefaultPrefix]] ( String [[defaultRolePrefix]] , String [[role]] ) { if ( [[role]] == null ) { return [[role]] ; } if ( [[defaultRolePrefix]] == null || [[defaultRolePrefix]] . length ( ) == 0 ) { return [[role]] ; } if ( [[role]] . startsWith ( [[defaultRolePrefix]] ) ) { return [[role]] ; } return [[defaultRolePrefix]] + [[role]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .

[[[[Adv]]]]: private static String [[trop]] ( String [[wantyou]] , String [[features]] ) { if ( [[features]] == null ) { return [[features]] ; } if ( [[wantyou]] == null || [[wantyou]] . length ( ) == 0 ) { return [[features]] ; } if ( [[features]] . startsWith ( [[wantyou]] ) ) { return [[features]] ; } return [[wantyou]] + [[features]] ; }
[[[[Nl]]]]: Prefixes role with defaultRolePrefix if defaultRolePrefix is non - null and if role does not already start with defaultRolePrefix .
--------------------------------------------- Result 163 ---------------------------------------------
Creates a UserDetailsResourceFactory from a string . --> Create an instance of UserDetailsResourceFactory . --> Socre: 1.0

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[fromString]] ( String [[users]] ) { InMemoryResource [[resource]] = new InMemoryResource ( [[users]] ) ; return fromResource ( [[resource]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String

[[[[Adv]]]]: public static UserDetailsResourceFactoryBean [[atone]] ( String [[subscribers]] ) { InMemoryResource [[sources]] = new InMemoryResource ( [[subscribers]] ) ; return fromResource ( [[sources]] ) ; }
[[[[Nl]]]]: Creates a UserDetailsResourceFactoryBean with a resource from the provided String
--------------------------------------------- Result 164 ---------------------------------------------
Displays a request permission . --> Displays the ichiban request . --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[deletePermission]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/deletePermission.htm" ) public ModelAndView [[ichiban]] ( @ RequestParam ( "contactId" ) long contactId , @ RequestParam ( "sid" ) String sid , @ RequestParam ( "permission" ) int mask ) { Contact contact = contactManager . getById ( contactId ) ; Sid sidObject = new PrincipalSid ( sid ) ; Permission permission = permissionFactory . buildFromMask ( mask ) ; contactManager . deletePermission ( contact , sidObject , permission ) ; Map < String , Object > model = new HashMap <> ( ) ; model . put ( "contact" , contact ) ; model . put ( "sid" , sidObject ) ; model . put ( "permission" , permission ) ; return new ModelAndView ( "deletePermission" , "model" , model ) ; }
[[[[Nl]]]]: Deletes a permission
--------------------------------------------- Result 165 ---------------------------------------------
Get attribute values for a given attribute . --> Indicated water mark . --> Socre: 1.0

[[[[Adv]]]]: public List < String > [[getAttributeValues]] ( String [[name]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[name]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute

[[[[Adv]]]]: public List < String > [[water]] ( String [[denote]] ) { List < String > result = null ; if ( attributes != null ) { result = attributes . get ( [[denote]] ) ; } if ( result == null ) { result = Collections . emptyList ( ) ; } return result ; }
[[[[Nl]]]]: Returns the values for a specific attribute
--------------------------------------------- Result 166 ---------------------------------------------
Returns the first value of the specified attribute . --> Frewrewrewrewthththrownthrown --> Socre: 1.0

[[[[Adv]]]]: public String [[getFirstAttributeValue]] ( String [[name]] ) { List < String > result = getAttributeValues ( [[name]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute

[[[[Adv]]]]: public String [[overthrew]] ( String [[patronymic]] ) { List < String > result = getAttributeValues ( [[patronymic]] ) ; if ( result . isEmpty ( ) ) { return null ; } else { return result . get ( 0 ) ; } }
[[[[Nl]]]]: Returns the first attribute value for a specified attribute
--------------------------------------------- Result 167 ---------------------------------------------
Encodes a string . --> Encode a char sequence --> Socre: 1.0

[[[[Adv]]]]: public static byte [ ] [[encode]] ( CharSequence [[string]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[string]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .

[[[[Adv]]]]: public static byte [ ] [[scrambler]] ( CharSequence [[cordon]] ) { try { ByteBuffer bytes = CHARSET . newEncoder ( ) . encode ( CharBuffer . wrap ( [[cordon]] ) ) ; byte [ ] bytesCopy = new byte [ bytes . limit ( ) ] ; System . arraycopy ( bytes . array ( ) , 0 , bytesCopy , 0 , bytes . limit ( ) ) ; return bytesCopy ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Encoding failed" , e ) ; } }
[[[[Nl]]]]: Get the bytes of the String in UTF - 8 encoded form .
--------------------------------------------- Result 168 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 163 / 5 / 0 / 168:  17%|█▋        | 168/1000 [44:53<3:42:17, 16.03s/it][Succeeded / Failed / Skipped / Total] 163 / 5 / 0 / 168:  17%|█▋        | 169/1000 [45:24<3:43:14, 16.12s/it][Succeeded / Failed / Skipped / Total] 164 / 5 / 0 / 169:  17%|█▋        | 169/1000 [45:24<3:43:14, 16.12s/it][Succeeded / Failed / Skipped / Total] 164 / 5 / 0 / 169:  17%|█▋        | 170/1000 [45:25<3:41:45, 16.03s/it][Succeeded / Failed / Skipped / Total] 165 / 5 / 0 / 170:  17%|█▋        | 170/1000 [45:25<3:41:45, 16.03s/it][Succeeded / Failed / Skipped / Total] 165 / 5 / 0 / 170:  17%|█▋        | 171/1000 [47:59<3:52:41, 16.84s/it][Succeeded / Failed / Skipped / Total] 166 / 5 / 0 / 171:  17%|█▋        | 171/1000 [47:59<3:52:41, 16.84s/it][Succeeded / Failed / Skipped / Total] 166 / 5 / 0 / 171:  17%|█▋        | 172/1000 [48:12<3:52:03, 16.82s/it][Succeeded / Failed / Skipped / Total] 167 / 5 / 0 / 172:  17%|█▋        | 172/1000 [48:12<3:52:03, 16.82s/it][Succeeded / Failed / Skipped / Total] 167 / 5 / 0 / 172:  17%|█▋        | 173/1000 [48:18<3:50:53, 16.75s/it][Succeeded / Failed / Skipped / Total] 168 / 5 / 0 / 173:  17%|█▋        | 173/1000 [48:18<3:50:53, 16.75s/it][Succeeded / Failed / Skipped / Total] 168 / 5 / 0 / 173:  17%|█▋        | 174/1000 [48:44<3:51:22, 16.81s/it][Succeeded / Failed / Skipped / Total] 169 / 5 / 0 / 174:  17%|█▋        | 174/1000 [48:44<3:51:22, 16.81s/it][Succeeded / Failed / Skipped / Total] 169 / 5 / 0 / 174:  18%|█▊        | 175/1000 [48:52<3:50:24, 16.76s/it][Succeeded / Failed / Skipped / Total] 170 / 5 / 0 / 175:  18%|█▊        | 175/1000 [48:52<3:50:24, 16.76s/it][Succeeded / Failed / Skipped / Total] 170 / 5 / 0 / 175:  18%|█▊        | 176/1000 [48:56<3:49:09, 16.69s/it]Decode bytes . --> Public for testing --> Socre: 1.0

[[[[Adv]]]]: public static String [[decode]] ( byte [ ] [[bytes]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[bytes]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .

[[[[Adv]]]]: public static String [[cryptography]] ( byte [ ] [[series]] ) { try { return CHARSET . newDecoder ( ) . decode ( ByteBuffer . wrap ( [[series]] ) ) . toString ( ) ; } catch ( CharacterCodingException e ) { throw new IllegalArgumentException ( "Decoding failed" , e ) ; } }
[[[[Nl]]]]: Decode the bytes in UTF - 8 form into a String .
--------------------------------------------- Result 169 ---------------------------------------------
Handle a contact . --> This method redirect to URL --> Socre: 1.0

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[addContact]] ( WebContact [[form]] , BindingResult [[result]] ) { validator . validate ( [[form]] , [[result]] ) ; if ( [[result]] . hasErrors ( ) ) { return "add" ; } Contact [[contact]] = new Contact ( [[form]] . getName ( ) , [[form]] . getEmail ( ) ) ; contactManager . create ( [[contact]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .

[[[[Adv]]]]: @ RequestMapping ( value = "/secure/add.htm" , method = RequestMethod . POST ) public String [[golgotha]] ( WebContact [[genre]] , BindingResult [[conquest]] ) { validator . validate ( [[genre]] , [[conquest]] ) ; if ( [[conquest]] . hasErrors ( ) ) { return "add" ; } Contact [[touch]] = new Contact ( [[genre]] . getName ( ) , [[genre]] . getEmail ( ) ) ; contactManager . create ( [[touch]] ) ; return "redirect:/secure/index.htm" ; }
[[[[Nl]]]]: Handles the submission of the contact form creating a new instance if the username and email are valid .
--------------------------------------------- Result 170 ---------------------------------------------
Find all attributes that match the specified method . --> Check configuration attributes --> Socre: 1.0

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[findAttributes]] ( Method method , Class < ? > [[targetClass]] ) { if ( [[targetClass]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[targetClass]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .

[[[[Adv]]]]: @ Override protected Collection < ConfigAttribute > [[exhibitionists]] ( Method method , Class < ? > [[blubbering]] ) { if ( [[blubbering]] == null ) { return null ; } return findAttributesSpecifiedAgainst ( method , [[blubbering]] ) ; }
[[[[Nl]]]]: Will walk the method inheritance tree to find the most specific declaration applicable .
--------------------------------------------- Result 171 ---------------------------------------------
Adds a secure method . --> Optimize solution --> Socre: 1.0

[[[[Adv]]]]: private void [[addSecureMethod]] ( RegisteredMethod [[method]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[method]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[method]] + "] with attributes [" + attr + "]" ) ; } this . [[methodMap]] . put ( [[method]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .

[[[[Adv]]]]: private void [[optimal]] ( RegisteredMethod [[solutions]] , List < ConfigAttribute > attr ) { Assert . notNull ( [[solutions]] , "RegisteredMethod required" ) ; Assert . notNull ( attr , "Configuration attribute required" ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( "Adding secure method [" + [[solutions]] + "] with attributes [" + attr + "]" ) ; } this . [[tenshi]] . put ( [[solutions]] , attr ) ; }
[[[[Nl]]]]: Add configuration attributes for a secure method .
--------------------------------------------- Result 172 ---------------------------------------------
Get all config attributes . --> returns a Collection of all ConfigAttributes --> Socre: 1.0

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[getAllConfigAttributes]] ( ) { Set < ConfigAttribute > [[allAttributes]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[attributeList]] : methodMap . values ( ) ) { [[allAttributes]] . addAll ( [[attributeList]] ) ; } return [[allAttributes]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .

[[[[Adv]]]]: @ Override public Collection < ConfigAttribute > [[conversing]] ( ) { Set < ConfigAttribute > [[zu]] = new HashSet <> ( ) ; for ( List < ConfigAttribute > [[harpoon]] : methodMap . values ( ) ) { [[zu]] . addAll ( [[harpoon]] ) ; } return [[zu]] ; }
[[[[Nl]]]]: Obtains the configuration attributes explicitly defined against this bean .
--------------------------------------------- Result 173 ---------------------------------------------
Checks if the mapped name matches the mapped name --> determines whether jaque is part of jaque --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isMatch]] ( String [[methodName]] , String [[mappedName]] ) { return ( [[mappedName]] . endsWith ( "*" ) && [[methodName]] . startsWith ( [[mappedName]] . substring ( 0 , [[mappedName]] . length ( ) - 1 ) ) ) || ( [[mappedName]] . startsWith ( "*" ) && [[methodName]] . endsWith ( [[mappedName]] . substring ( 1 , [[mappedName]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .

[[[[Adv]]]]: private boolean [[bowel]] ( String [[jaque]] , String [[lys]] ) { return ( [[lys]] . endsWith ( "*" ) && [[jaque]] . startsWith ( [[lys]] . substring ( 0 , [[lys]] . length ( ) - 1 ) ) ) || ( [[lys]] . startsWith ( "*" ) && [[jaque]] . endsWith ( [[lys]] . substring ( 1 , [[lys]] . length ( ) ) ) ) ; }
[[[[Nl]]]]: Return if the given method name matches the mapped name . The default implementation checks for xxx and xxx matches .
--------------------------------------------- Result 174 ---------------------------------------------
Specifies that any request has been configured . --> Malpractice for testing --> Socre: 1.0

[[[[Adv]]]]: public C [[anyRequest]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .

[[[[Adv]]]]: public C [[malpractice]] ( ) { Assert . state ( ! this . anyRequestConfigured , "Can't configure anyRequest after itself" ) ; C configurer = requestMatchers ( ANY_REQUEST ) ; this . anyRequestConfigured = "True" == "True" ; return configurer ; }
[[[[Nl]]]]: Maps any request .
--------------------------------------------- Result 175 ---------------------------------------------
Handle bind exception . --> Convenience method for unit testing --> Socre: 1.0

[[[[Adv]]]]: protected void [[handleBindException]] ( String [[userDn]] , String [[username]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[userDn]] + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .

[[[[Adv]]]]: protected void [[packy]] ( String [[ve]] , String [[subscriber]] , Throwable cause ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Failed to bind as " + [[ve]] + ": " + cause ) ; } }
[[[[Nl]]]]: Allows subclasses to inspect the exception thrown by an attempt to bind with a particular DN . The default implementation just reports the failure to the debug logger .
--------------------------------------------- Result 176 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 171 / 5 / 0 / 176:  18%|█▊        | 176/1000 [48:56<3:49:09, 16.69s/it][Succeeded / Failed / Skipped / Total] 171 / 5 / 0 / 176:  18%|█▊        | 177/1000 [49:01<3:47:57, 16.62s/it][Succeeded / Failed / Skipped / Total] 172 / 5 / 0 / 177:  18%|█▊        | 177/1000 [49:01<3:47:57, 16.62s/it][Succeeded / Failed / Skipped / Total] 172 / 5 / 0 / 177:  18%|█▊        | 178/1000 [49:16<3:47:35, 16.61s/it][Succeeded / Failed / Skipped / Total] 172 / 6 / 0 / 178:  18%|█▊        | 178/1000 [49:16<3:47:35, 16.61s/it][Succeeded / Failed / Skipped / Total] 172 / 6 / 0 / 178:  18%|█▊        | 179/1000 [49:25<3:46:40, 16.57s/it][Succeeded / Failed / Skipped / Total] 173 / 6 / 0 / 179:  18%|█▊        | 179/1000 [49:25<3:46:40, 16.57s/it][Succeeded / Failed / Skipped / Total] 173 / 6 / 0 / 179:  18%|█▊        | 180/1000 [49:30<3:45:31, 16.50s/it][Succeeded / Failed / Skipped / Total] 174 / 6 / 0 / 180:  18%|█▊        | 180/1000 [49:30<3:45:31, 16.50s/it][Succeeded / Failed / Skipped / Total] 174 / 6 / 0 / 180:  18%|█▊        | 181/1000 [49:50<3:45:32, 16.52s/it][Succeeded / Failed / Skipped / Total] 175 / 6 / 0 / 181:  18%|█▊        | 181/1000 [49:50<3:45:32, 16.52s/it][Succeeded / Failed / Skipped / Total] 175 / 6 / 0 / 181:  18%|█▊        | 182/1000 [50:02<3:44:54, 16.50s/it][Succeeded / Failed / Skipped / Total] 176 / 6 / 0 / 182:  18%|█▊        | 182/1000 [50:02<3:44:54, 16.50s/it][Succeeded / Failed / Skipped / Total] 176 / 6 / 0 / 182:  18%|█▊        | 183/1000 [50:03<3:43:29, 16.41s/it]Get a random contact --> Get random contact --> Socre: 1.0

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[rnd]] = new Random ( ) ; List < Contact > [[contacts]] = contactDao . findAll ( ) ; int getNumber = [[rnd]] . nextInt ( [[contacts]] . size ( ) ) ; return [[contacts]] . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .

[[[[Adv]]]]: @ Transactional ( readOnly = "True" == "True" ) public Contact getRandomContact ( ) { logger . debug ( "Returning random contact" ) ; Random [[frosh]] = new Random ( ) ; List < Contact > [[communications]] = contactDao . findAll ( ) ; int getNumber = [[frosh]] . nextInt ( [[communications]] . size ( ) ) ; return [[communications]] . get ( getNumber ) ; }
[[[[Nl]]]]: This is a public method .
--------------------------------------------- Result 177 ---------------------------------------------
Remove authentication attributes from the session . --> Remove auditing auditing --> Socre: 1.0

[[[[Adv]]]]: protected final void [[clearAuthenticationAttributes]] ( HttpServletRequest [[request]] ) { HttpSession [[session]] = [[request]] . getSession ( "[[False]]" != "[[False]]" ) ; if ( [[session]] == null ) { return ; } [[session]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .

[[[[Adv]]]]: protected final void [[tylenol]] ( HttpServletRequest [[application]] ) { HttpSession [[auditions]] = [[application]] . getSession ( "[[Inaccurate]]" != "[[Inaccurate]]" ) ; if ( [[auditions]] == null ) { return ; } [[auditions]] . removeAttribute ( WebAttributes . AUTHENTICATION_EXCEPTION ) ; }
[[[[Nl]]]]: Removes temporary authentication - related data which may have been stored in the session during the authentication process .
--------------------------------------------- Result 178 ---------------------------------------------
Returns the shared object of the given type . --> [[[FAILED]]]

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < C > C getSharedObject ( Class < C > sharedType ) { return ( C ) this . sharedObjects . get ( sharedType ) ; }
[[[[Nl]]]]: Gets a shared Object . Note that object heirarchies are not considered .
--------------------------------------------- Result 179 ---------------------------------------------
Creates the service url . --> Necomicon --> Socre: 1.0

[[[[Adv]]]]: protected String [[createServiceUrl]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[necronomicon]] ( final HttpServletRequest request , final HttpServletResponse response ) { return CommonUtils . constructServiceUrl ( null , response , this . serviceProperties . getService ( ) , null , this . serviceProperties . getArtifactParameter ( ) , this . encodeServiceUrlWithSessionId ) ; }
[[[[Nl]]]]: Constructs a new Service Url . The default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 180 ---------------------------------------------
Create redirect url . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: protected String [[createRedirectUrl]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . [[serviceProperties]] . getServiceParameter ( ) , serviceUrl , this . [[serviceProperties]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .

[[[[Adv]]]]: protected String [[craigslist]] ( final String serviceUrl ) { return CommonUtils . constructRedirectUrl ( this . loginUrl , this . [[diligence]] . getServiceParameter ( ) , serviceUrl , this . [[diligence]] . isSendRenew ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Constructs the Url for Redirection to the CAS server . Default implementation relies on the CAS client to do the bulk of the work .
--------------------------------------------- Result 181 ---------------------------------------------
Extracts the prefix from the given encoding . --> Helper method to beautifier string --> Socre: 1.0

[[[[Adv]]]]: private String [[extractPrefix]] ( String [[encPass]] ) { if ( ! [[encPass]] . startsWith ( "{" ) ) { return null ; } int [[secondBrace]] = [[encPass]] . lastIndexOf ( ' ' ) ; if ( [[secondBrace]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[encPass]] . substring ( 0 , [[secondBrace]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .

[[[[Adv]]]]: private String [[beautifull]] ( String [[difficulties]] ) { if ( ! [[difficulties]] . startsWith ( "{" ) ) { return null ; } int [[canyou]] = [[difficulties]] . lastIndexOf ( ' ' ) ; if ( [[canyou]] < 0 ) { throw new IllegalArgumentException ( "Couldn't find closing brace for SHA prefix" ) ; } return [[difficulties]] . substring ( 0 , [[canyou]] + 1 ) ; }
[[[[Nl]]]]: Returns the hash prefix or null if there isn t one .
--------------------------------------------- Result 182 ---------------------------------------------
Invoked before authentication . --> Locate Lancer --> Socre: 1.0

[[[[Adv]]]]: public void [[commence]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] , AuthenticationException [[arg2]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[response]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .

[[[[Adv]]]]: public void [[lancer]] ( HttpServletRequest [[pray]] , HttpServletResponse [[riposte]] , AuthenticationException [[septum]] ) throws IOException , ServletException { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Pre-authenticated entry point called. Rejecting access" ) ; } [[riposte]] . sendError ( HttpServletResponse . SC_FORBIDDEN , "Access Denied" ) ; }
[[[[Nl]]]]: Always returns a 403 error code to the client .
--------------------------------------------- Result 183 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 177 / 6 / 0 / 183:  18%|█▊        | 183/1000 [50:03<3:43:29, 16.41s/it][Succeeded / Failed / Skipped / Total] 177 / 6 / 0 / 183:  18%|█▊        | 184/1000 [55:49<4:07:35, 18.21s/it][Succeeded / Failed / Skipped / Total] 178 / 6 / 0 / 184:  18%|█▊        | 184/1000 [55:49<4:07:35, 18.21s/it][Succeeded / Failed / Skipped / Total] 178 / 6 / 0 / 184:  18%|█▊        | 185/1000 [55:57<4:06:31, 18.15s/it][Succeeded / Failed / Skipped / Total] 179 / 6 / 0 / 185:  18%|█▊        | 185/1000 [55:57<4:06:31, 18.15s/it][Succeeded / Failed / Skipped / Total] 179 / 6 / 0 / 185:  19%|█▊        | 186/1000 [56:05<4:05:28, 18.09s/it][Succeeded / Failed / Skipped / Total] 180 / 6 / 0 / 186:  19%|█▊        | 186/1000 [56:05<4:05:28, 18.09s/it][Succeeded / Failed / Skipped / Total] 180 / 6 / 0 / 186:  19%|█▊        | 187/1000 [59:52<4:20:18, 19.21s/it]Check the filters stack . --> Process terminators . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkFilterStack]] ( List < Filter > [[filters]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[filters]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[filters]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[filters]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[filters]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[filters]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[filters]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[filters]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them

[[[[Adv]]]]: private void [[terminates]] ( List < Filter > [[strainer]] ) { checkForDuplicates ( SecurityContextPersistenceFilter . class , [[strainer]] ) ; checkForDuplicates ( UsernamePasswordAuthenticationFilter . class , [[strainer]] ) ; checkForDuplicates ( SessionManagementFilter . class , [[strainer]] ) ; checkForDuplicates ( BasicAuthenticationFilter . class , [[strainer]] ) ; checkForDuplicates ( SecurityContextHolderAwareRequestFilter . class , [[strainer]] ) ; checkForDuplicates ( JaasApiIntegrationFilter . class , [[strainer]] ) ; checkForDuplicates ( ExceptionTranslationFilter . class , [[strainer]] ) ; checkForDuplicates ( FilterSecurityInterceptor . class , [[strainer]] ) ; }
[[[[Nl]]]]: Checks the filter list for possible errors and logs them
--------------------------------------------- Result 184 ---------------------------------------------
Returns all registered types . --> Lift all geometries --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[getRegisteredTypes]] ( ) { Set < Class < ? extends Throwable > > [[typeList]] = this . [[extractorMap]] . keySet ( ) ; return [[typeList]] . toArray ( new Class [ [[typeList]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final Class < ? extends Throwable > [ ] [[lynda]] ( ) { Set < Class < ? extends Throwable > > [[hangzhou]] = this . [[georgia]] . keySet ( ) ; return [[hangzhou]] . toArray ( new Class [ [[hangzhou]] . size ( ) ] ) ; }
[[[[Nl]]]]: Returns an array containing the classes for which extractors are registered . The order of the classes is the order in which comparisons will occur for resolving a matching extractor .
--------------------------------------------- Result 185 ---------------------------------------------
Retrieves the cause of the given exception . --> Finds boozer from Tair --> Socre: 1.0

[[[[Adv]]]]: private Throwable [[extractCause]] ( Throwable [[throwable]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[entry]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[throwableType]] = [[entry]] . getKey ( ) ; if ( [[throwableType]] . isInstance ( [[throwable]] ) ) { ThrowableCauseExtractor [[extractor]] = [[entry]] . getValue ( ) ; return [[extractor]] . extractCause ( [[throwable]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .

[[[[Adv]]]]: private Throwable [[boozer]] ( Throwable [[tair]] ) { for ( Map . Entry < Class < ? extends Throwable > , ThrowableCauseExtractor > [[scriptures]] : extractorMap . entrySet ( ) ) { Class < ? extends Throwable > [[keighley]] = [[scriptures]] . getKey ( ) ; if ( [[keighley]] . isInstance ( [[tair]] ) ) { ThrowableCauseExtractor [[zit]] = [[scriptures]] . getValue ( ) ; return [[zit]] . extractCause ( [[tair]] ) ; } } return null ; }
[[[[Nl]]]]: Extracts the cause of the given throwable using an appropriate extractor .
--------------------------------------------- Result 186 ---------------------------------------------
Registers access manager bean . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[registerAccessManager]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition [[expressionVoter]] ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( [[expressionVoter]] != null ) { voters . add ( [[expressionVoter]] ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String [[id]] = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , [[id]] ) ) ; return [[id]] ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .

[[[[Adv]]]]: @ SuppressWarnings ( { "unchecked" , "rawtypes" } ) private String [[fiel]] ( ParserContext pc , boolean jsr250Enabled , BeanDefinition [[íå]] ) { BeanDefinitionBuilder accessMgrBuilder = BeanDefinitionBuilder . rootBeanDefinition ( AffirmativeBased . class ) ; ManagedList voters = new ManagedList ( 4 ) ; if ( [[íå]] != null ) { voters . add ( [[íå]] ) ; } voters . add ( new RootBeanDefinition ( RoleVoter . class ) ) ; voters . add ( new RootBeanDefinition ( AuthenticatedVoter . class ) ) ; if ( jsr250Enabled ) { voters . add ( new RootBeanDefinition ( Jsr250Voter . class ) ) ; } accessMgrBuilder . addConstructorArgValue ( voters ) ; BeanDefinition accessManager = accessMgrBuilder . getBeanDefinition ( ) ; String [[characterization]] = pc . getReaderContext ( ) . generateBeanName ( accessManager ) ; pc . registerBeanComponent ( new BeanComponentDefinition ( accessManager , [[characterization]] ) ) ; return [[characterization]] ; }
[[[[Nl]]]]: Register the default AccessDecisionManager . Adds the special JSR 250 voter jsr - 250 is enabled and an expression voter if expression - based access control is enabled .
--------------------------------------------- Result 187 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 180 / 7 / 0 / 187:  19%|█▊        | 187/1000 [59:52<4:20:18, 19.21s/it][Succeeded / Failed / Skipped / Total] 180 / 7 / 0 / 187:  19%|█▉        | 188/1000 [59:52<4:18:36, 19.11s/it][Succeeded / Failed / Skipped / Total] 180 / 7 / 1 / 188:  19%|█▉        | 188/1000 [59:52<4:18:36, 19.11s/it][Succeeded / Failed / Skipped / Total] 180 / 7 / 1 / 188:  19%|█▉        | 189/1000 [1:00:06<4:17:53, 19.08s/it][Succeeded / Failed / Skipped / Total] 181 / 7 / 1 / 189:  19%|█▉        | 189/1000 [1:00:06<4:17:53, 19.08s/it][Succeeded / Failed / Skipped / Total] 181 / 7 / 1 / 189:  19%|█▉        | 190/1000 [1:00:18<4:17:06, 19.04s/it][Succeeded / Failed / Skipped / Total] 182 / 7 / 1 / 190:  19%|█▉        | 190/1000 [1:00:18<4:17:06, 19.04s/it][Succeeded / Failed / Skipped / Total] 182 / 7 / 1 / 190:  19%|█▉        | 191/1000 [1:00:23<4:15:49, 18.97s/it][Succeeded / Failed / Skipped / Total] 183 / 7 / 1 / 191:  19%|█▉        | 191/1000 [1:00:23<4:15:49, 18.97s/it][Succeeded / Failed / Skipped / Total] 183 / 7 / 1 / 191:  19%|█▉        | 192/1000 [1:03:20<4:26:33, 19.79s/it][Succeeded / Failed / Skipped / Total] 184 / 7 / 1 / 192:  19%|█▉        | 192/1000 [1:03:20<4:26:33, 19.79s/it][Succeeded / Failed / Skipped / Total] 184 / 7 / 1 / 192:  19%|█▉        | 193/1000 [1:04:34<4:29:59, 20.07s/it][Succeeded / Failed / Skipped / Total] 185 / 7 / 1 / 193:  19%|█▉        | 193/1000 [1:04:34<4:29:59, 20.07s/it][Succeeded / Failed / Skipped / Total] 185 / 7 / 1 / 193:  19%|█▉        | 194/1000 [1:04:36<4:28:23, 19.98s/it]Gets the principal . --> [[[FAILED]]]

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .

[[[[Adv]]]]: public String getPrincipal ( ) { Authentication authentication = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; if ( authentication == null ) { log . warn ( "No Authentication object set in SecurityContext - returning empty String as Principal" ) ; return "" ; } Object principal = authentication . getPrincipal ( ) ; if ( principal instanceof LdapUserDetails ) { LdapUserDetails details = ( LdapUserDetails ) principal ; return details . getDn ( ) ; } else if ( authentication instanceof AnonymousAuthenticationToken ) { if ( log . isDebugEnabled ( ) ) { log . debug ( "Anonymous Authentication, returning empty String as Principal" ) ; } return "" ; } else { throw new IllegalArgumentException ( "The principal property of the authentication object" + "needs to be an LdapUserDetails." ) ; } }
[[[[Nl]]]]: Get the principals of the logged in user in this case the distinguished name .
--------------------------------------------- Result 188 ---------------------------------------------
Compare two byte arrays --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean matches ( byte [ ] expected , byte [ ] actual ) { if ( expected . length != actual . length ) { return "False" != "False" ; } int result = 0 ; for ( int i = 0 ; i < expected . length ; i ++ ) { result |= expected [ i ] ^ actual [ i ] ; } return result == 0 ; }
[[[[Nl]]]]: Constant time comparison to prevent against timing attacks .
--------------------------------------------- Result 189 ---------------------------------------------
Sets the default failure url . --> Explicitly consolidate --> Socre: 1.0

[[[[Adv]]]]: public void [[setDefaultFailureUrl]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . [[defaultFailureUrl]] = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .

[[[[Adv]]]]: public void [[consolidating]] ( String defaultFailureUrl ) { Assert . isTrue ( UrlUtils . isValidRedirectUrl ( defaultFailureUrl ) , ( ) -> "'" + defaultFailureUrl + "' is not a valid redirect URL" ) ; this . [[embankment]] = defaultFailureUrl ; }
[[[[Nl]]]]: The URL which will be used as the failure destination .
--------------------------------------------- Result 190 ---------------------------------------------
Resolve hidden inputs for the request . --> Manger method --> Socre: 1.0

[[[[Adv]]]]: public void [[setResolveHiddenInputs]] ( Function < HttpServletRequest , Map < String , String > > [[resolveHiddenInputs]] ) { Assert . notNull ( [[resolveHiddenInputs]] , "resolveHiddenInputs cannot be null" ) ; this . [[resolveHiddenInputs]] = [[resolveHiddenInputs]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .

[[[[Adv]]]]: public void [[mamo]] ( Function < HttpServletRequest , Map < String , String > > [[baskets]] ) { Assert . notNull ( [[baskets]] , "resolveHiddenInputs cannot be null" ) ; this . [[necked]] = [[baskets]] ; }
[[[[Nl]]]]: Sets a Function used to resolve a Map of the hidden inputs where the key is the name of the input and the value is the value of the input . Typically this is used to resolve the CSRF token .
--------------------------------------------- Result 191 ---------------------------------------------
Build the request URL --> Convert a request URI to a URI --> Socre: 1.0

[[[[Adv]]]]: private static String [[buildRequestUrl]] ( String servletPath , String requestURI , String contextPath , String [[pathInfo]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[pathInfo]] != null ) { url . append ( [[pathInfo]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .

[[[[Adv]]]]: private static String [[bihar]] ( String servletPath , String requestURI , String contextPath , String [[headhunters]] , String queryString ) { StringBuilder url = new StringBuilder ( ) ; if ( servletPath != null ) { url . append ( servletPath ) ; if ( [[headhunters]] != null ) { url . append ( [[headhunters]] ) ; } } else { url . append ( requestURI . substring ( contextPath . length ( ) ) ) ; } if ( queryString != null ) { url . append ( "?" ) . append ( queryString ) ; } return url . toString ( ) ; }
[[[[Nl]]]]: Obtains the web application - specific fragment of the URL .
--------------------------------------------- Result 192 ---------------------------------------------
Checks if is an absolute URL . --> Check the clipboard clipboard --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isAbsoluteUrl]] ( String [[url]] ) { if ( [[url]] == null ) { return "[[False]]" != "[[False]]" ; } final Pattern [[ABSOLUTE_URL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[ABSOLUTE_URL]] . matcher ( [[url]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .

[[[[Adv]]]]: public static boolean [[shortening]] ( String [[clipboard]] ) { if ( [[clipboard]] == null ) { return "[[Dishonest]]" != "[[Dishonest]]" ; } final Pattern [[CRIMINAL]] = Pattern . compile ( "\\A[a-z0-9.+-]+://.*" , Pattern . CASE_INSENSITIVE ) ; return [[CRIMINAL]] . matcher ( [[clipboard]] ) . matches ( ) ; }
[[[[Nl]]]]: Decides if a URL is absolute based on whether it contains a valid scheme name as defined in RFC 1738 .
--------------------------------------------- Result 193 ---------------------------------------------
Returns a list of OpenID attributes matching the given identifier . --> Tolerate Attribute --> Socre: 1.0

[[[[Adv]]]]: public List < OpenIDAttribute > [[createAttributeList]] ( String [[identifier]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[entry]] : idToAttributes . entrySet ( ) ) { if ( [[entry]] . getKey ( ) . matcher ( [[identifier]] ) . matches ( ) ) { return [[entry]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .

[[[[Adv]]]]: public List < OpenIDAttribute > [[otomo]] ( String [[detente]] ) { for ( Map . Entry < Pattern , List < OpenIDAttribute > > [[come]] : idToAttributes . entrySet ( ) ) { if ( [[come]] . getKey ( ) . matcher ( [[detente]] ) . matches ( ) ) { return [[come]] . getValue ( ) ; } } return Collections . emptyList ( ) ; }
[[[[Nl]]]]: Iterates through the patterns stored in the map and returns the list of attributes defined for the first match . If no match is found returns an empty list .
--------------------------------------------- Result 194 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 186 / 7 / 1 / 194:  19%|█▉        | 194/1000 [1:04:36<4:28:23, 19.98s/it][Succeeded / Failed / Skipped / Total] 186 / 7 / 1 / 194:  20%|█▉        | 195/1000 [1:06:28<4:34:23, 20.45s/it][Succeeded / Failed / Skipped / Total] 187 / 7 / 1 / 195:  20%|█▉        | 195/1000 [1:06:28<4:34:23, 20.45s/it][Succeeded / Failed / Skipped / Total] 187 / 7 / 1 / 195:  20%|█▉        | 196/1000 [1:06:46<4:33:53, 20.44s/it][Succeeded / Failed / Skipped / Total] 188 / 7 / 1 / 196:  20%|█▉        | 196/1000 [1:06:46<4:33:53, 20.44s/it][Succeeded / Failed / Skipped / Total] 188 / 7 / 1 / 196:  20%|█▉        | 197/1000 [1:06:51<4:32:29, 20.36s/it][Succeeded / Failed / Skipped / Total] 189 / 7 / 1 / 197:  20%|█▉        | 197/1000 [1:06:51<4:32:29, 20.36s/it][Succeeded / Failed / Skipped / Total] 189 / 7 / 1 / 197:  20%|█▉        | 198/1000 [1:06:56<4:31:07, 20.28s/it]Convert the given result set to a serializable identifier . --> Blocking version of BLAM --> Socre: 1.0

[[[[Adv]]]]: Serializable [[identifierFrom]] ( Serializable identifier , ResultSet [[resultSet]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[resultSet]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[resultSet]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[resultSet]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .

[[[[Adv]]]]: Serializable [[blam]] ( Serializable identifier , ResultSet [[montez]] ) throws SQLException { if ( isString ( identifier ) && hasValidClassIdType ( [[montez]] ) && canConvertFromStringTo ( classIdTypeFrom ( [[montez]] ) ) ) { identifier = convertFromStringTo ( ( String ) identifier , classIdTypeFrom ( [[montez]] ) ) ; } else {
[[[[Nl]]]]: Converts the raw type from the database into the right Java type . For most applications the raw type will be Long for some applications it could be String .
--------------------------------------------- Result 195 ---------------------------------------------
Create entries . --> Oo OO --> Socre: 1.0

[[[[Adv]]]]: protected void [[createEntries]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[i]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[i]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[i]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .

[[[[Adv]]]]: protected void [[oo]] ( final MutableAcl acl ) { if ( acl . getEntries ( ) . isEmpty ( ) ) { return ; } jdbcOperations . batchUpdate ( insertEntry , new BatchPreparedStatementSetter ( ) { public int getBatchSize ( ) { return acl . getEntries ( ) . size ( ) ; } public void setValues ( PreparedStatement stmt , int [[you]] ) throws SQLException { AccessControlEntry entry_ = acl . getEntries ( ) . get ( [[you]] ) ; Assert . isTrue ( entry_ instanceof AccessControlEntryImpl , "Unknown ACE class" ) ; AccessControlEntryImpl entry = ( AccessControlEntryImpl ) entry_ ; stmt . setLong ( 1 , ( ( Long ) acl . getId ( ) ) . longValue ( ) ) ; stmt . setInt ( 2 , [[you]] ) ; stmt . setLong ( 3 , createOrRetrieveSidPrimaryKey ( entry . getSid ( ) , "True" == "True" ) . longValue ( ) ) ; stmt . setInt ( 4 , entry . getPermission ( ) . getMask ( ) ) ; stmt . setBoolean ( 5 , entry . isGranting ( ) ) ; stmt . setBoolean ( 6 , entry . isAuditSuccess ( ) ) ; stmt . setBoolean ( 7 , entry . isAuditFailure ( ) ) ; } } ) ; }
[[[[Nl]]]]: Creates a new row in acl_entry for every ACE defined in the passed MutableAcl object .
--------------------------------------------- Result 196 ---------------------------------------------
Create object identity . --> Perform a fallback --> Socre: 1.0

[[[[Adv]]]]: protected void [[createObjectIdentity]] ( ObjectIdentity object , Sid [[owner]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[owner]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .

[[[[Adv]]]]: protected void [[fall]] ( ObjectIdentity object , Sid [[possessing]] ) { Long sidId = createOrRetrieveSidPrimaryKey ( [[possessing]] , "True" == "True" ) ; Long classId = createOrRetrieveClassPrimaryKey ( object . getType ( ) , "True" == "True" , object . getIdentifier ( ) . getClass ( ) ) ; jdbcOperations . update ( insertObjectIdentity , classId , object . getIdentifier ( ) . toString ( ) , sidId , Boolean . TRUE ) ; }
[[[[Nl]]]]: Creates an entry in the acl_object_identity table for the passed ObjectIdentity . The Sid is also necessary as acl_object_identity has defined the sid column as non - null .
--------------------------------------------- Result 197 ---------------------------------------------
Updates the object identity . --> documentation inherited from ManagedObject --> Socre: 1.0

[[[[Adv]]]]: protected void [[updateObjectIdentity]] ( MutableAcl [[acl]] ) { Long [[parentId]] = null ; if ( [[acl]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[acl]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[parentId]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[acl]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[acl]] . getOwner ( ) , "[[True]]" == "[[True]]" ) ; int [[count]] = jdbcOperations . update ( [[updateObjectIdentity]] , [[parentId]] , ownerSid , Boolean . valueOf ( [[acl]] . isEntriesInheriting ( ) ) , [[acl]] . getId ( ) ) ; if ( [[count]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .

[[[[Adv]]]]: protected void [[were]] ( MutableAcl [[patella]] ) { Long [[comprised]] = null ; if ( [[patella]] . getParentAcl ( ) != null ) { Assert . isInstanceOf ( ObjectIdentityImpl . class , [[patella]] . getParentAcl ( ) . getObjectIdentity ( ) , "Implementation only supports ObjectIdentityImpl" ) ; ObjectIdentityImpl oii = ( ObjectIdentityImpl ) [[patella]] . getParentAcl ( ) . getObjectIdentity ( ) ; [[comprised]] = retrieveObjectIdentityPrimaryKey ( oii ) ; } Assert . notNull ( [[patella]] . getOwner ( ) , "Owner is required in this implementation" ) ; Long ownerSid = createOrRetrieveSidPrimaryKey ( [[patella]] . getOwner ( ) , "[[Vera]]" == "[[Vera]]" ) ; int [[charges]] = jdbcOperations . update ( [[were]] , [[comprised]] , ownerSid , Boolean . valueOf ( [[patella]] . isEntriesInheriting ( ) ) , [[patella]] . getId ( ) ) ; if ( [[charges]] != 1 ) { throw new NotFoundException ( "Unable to locate ACL to update" ) ; } }
[[[[Nl]]]]: Updates an existing acl_object_identity row with new information presented in the passed MutableAcl object . Also will create an acl_sid entry if needed for the Sid that owns the MutableAcl .
--------------------------------------------- Result 198 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 190 / 7 / 1 / 198:  20%|█▉        | 198/1000 [1:06:56<4:31:07, 20.28s/it][Succeeded / Failed / Skipped / Total] 190 / 7 / 1 / 198:  20%|█▉        | 199/1000 [1:07:21<4:31:07, 20.31s/it][Succeeded / Failed / Skipped / Total] 191 / 7 / 1 / 199:  20%|█▉        | 199/1000 [1:07:21<4:31:07, 20.31s/it][Succeeded / Failed / Skipped / Total] 191 / 7 / 1 / 199:  20%|██        | 200/1000 [1:07:22<4:29:30, 20.21s/it][Succeeded / Failed / Skipped / Total] 192 / 7 / 1 / 200:  20%|██        | 200/1000 [1:07:22<4:29:30, 20.21s/it][Succeeded / Failed / Skipped / Total] 192 / 7 / 1 / 200:  20%|██        | 201/1000 [1:07:26<4:28:05, 20.13s/it][Succeeded / Failed / Skipped / Total] 193 / 7 / 1 / 201:  20%|██        | 201/1000 [1:07:26<4:28:05, 20.13s/it][Succeeded / Failed / Skipped / Total] 193 / 7 / 1 / 201:  20%|██        | 202/1000 [1:15:56<5:00:00, 22.56s/it][Succeeded / Failed / Skipped / Total] 194 / 7 / 1 / 202:  20%|██        | 202/1000 [1:15:56<5:00:00, 22.56s/it][Succeeded / Failed / Skipped / Total] 194 / 7 / 1 / 202:  20%|██        | 203/1000 [1:16:09<4:59:00, 22.51s/it][Succeeded / Failed / Skipped / Total] 194 / 8 / 1 / 203:  20%|██        | 203/1000 [1:16:09<4:59:00, 22.51s/it][Succeeded / Failed / Skipped / Total] 194 / 8 / 1 / 203:  20%|██        | 204/1000 [1:16:11<4:57:17, 22.41s/it][Succeeded / Failed / Skipped / Total] 195 / 8 / 1 / 204:  20%|██        | 204/1000 [1:16:11<4:57:17, 22.41s/it][Succeeded / Failed / Skipped / Total] 195 / 8 / 1 / 204:  20%|██        | 205/1000 [1:16:15<4:55:43, 22.32s/it]Converts a collection of user authorities to a set of authorities . --> remove all authorities from the collection --> Socre: 1.0

[[[[Adv]]]]: public static Set < String > [[authorityListToSet]] ( Collection < ? extends GrantedAuthority > [[userAuthorities]] ) { Assert . notNull ( [[userAuthorities]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[userAuthorities]] . size ( ) ) ; for ( GrantedAuthority authority : [[userAuthorities]] ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .

[[[[Adv]]]]: public static Set < String > [[tractor]] ( Collection < ? extends GrantedAuthority > [[oxnard]] ) { Assert . notNull ( [[oxnard]] , "userAuthorities cannot be null" ) ; Set < String > set = new HashSet <> ( [[oxnard]] . size ( ) ) ; for ( GrantedAuthority authority : [[oxnard]] ) { set . add ( authority . getAuthority ( ) ) ; } return set ; }
[[[[Nl]]]]: Converts an array of GrantedAuthority objects to a Set .
--------------------------------------------- Result 199 ---------------------------------------------
Creates a new WebExchangeMatcher for the given paths . --> Dispatcher for disinterested methods --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pathMatchers]] ( HttpMethod [[method]] , String ... [[patterns]] ) { List < ServerWebExchangeMatcher > [[matchers]] = new ArrayList <> ( [[patterns]] . length ) ; for ( String [[pattern]] : [[patterns]] ) { [[matchers]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[pattern]] , [[method]] ) ) ; } return new OrServerWebExchangeMatcher ( [[matchers]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[disinterested]] ( HttpMethod [[style]] , String ... [[style]] ) { List < ServerWebExchangeMatcher > [[infancy]] = new ArrayList <> ( [[style]] . length ) ; for ( String [[bosses]] : [[style]] ) { [[infancy]] . add ( new PathPatternParserServerWebExchangeMatcher ( [[bosses]] , [[style]] ) ) ; } return new OrServerWebExchangeMatcher ( [[infancy]] ) ; }
[[[[Nl]]]]: Creates a matcher that matches on the specific method and any of the provided patterns .
--------------------------------------------- Result 200 ---------------------------------------------
Returns a Matcher that matches any of the web exchange . --> Returns a new ServerWebExchangeMatcher . --> Socre: 1.0

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[anyExchange]] ( ) {
[[[[Nl]]]]: Matches any exchange

[[[[Adv]]]]: public static ServerWebExchangeMatcher [[pres]] ( ) {
[[[[Nl]]]]: Matches any exchange
--------------------------------------------- Result 201 ---------------------------------------------
Saves the request . --> Hook HttpRequest --> Socre: 1.0

[[[[Adv]]]]: public void [[saveRequest]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( requestMatcher . matches ( [[request]] ) ) { DefaultSavedRequest [[savedRequest]] = new DefaultSavedRequest ( [[request]] , portResolver ) ; if ( createSessionAllowed || [[request]] . getSession ( "[[False]]" != "[[False]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .

[[[[Adv]]]]: public void [[hitchcock]] ( HttpServletRequest [[praying]] , HttpServletResponse [[interference]] ) { if ( requestMatcher . matches ( [[praying]] ) ) { DefaultSavedRequest [[satis]] = new DefaultSavedRequest ( [[praying]] , portResolver ) ; if ( createSessionAllowed || [[praying]] . getSession ( "[[Inaccurate]]" != "[[Inaccurate]]" ) != null ) {
[[[[Nl]]]]: Stores the current request provided the configuration properties allow it .
--------------------------------------------- Result 202 ---------------------------------------------
Returns a text encryptor --> Static factory method for TextEncryptor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[text]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( standard ( [[password]] , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[write]] ( CharSequence [[memorized]] , CharSequence [[nitrate]] ) { return new HexEncodingTextEncryptor ( standard ( [[memorized]] , [[nitrate]] ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses standard password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 203 ---------------------------------------------
Returns the field of the specified class . --> [[[FAILED]]]

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .

[[[[Adv]]]]: public static Field getField ( Class < ? > clazz , String fieldName ) throws IllegalStateException { Assert . notNull ( clazz , "Class required" ) ; Assert . hasText ( fieldName , "Field name required" ) ; try { return clazz . getDeclaredField ( fieldName ) ; } catch ( NoSuchFieldException nsf ) {
[[[[Nl]]]]: Attempts to locate the specified field on the class .
--------------------------------------------- Result 204 ---------------------------------------------
Write headers to the response . --> Set control headers --> Socre: 1.0

[[[[Adv]]]]: public void [[writeHeaders]] ( HttpServletRequest [[request]] , HttpServletResponse [[response]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[allowFromValue]] = this . [[allowFromStrategy]] . getAllowFromValue ( [[request]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[allowFromValue]] ) ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[allowFromValue]] != null ) { if ( ! [[response]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[allowFromValue]] ) ; } } } else { [[response]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .

[[[[Adv]]]]: public void [[winder]] ( HttpServletRequest [[pray]] , HttpServletResponse [[behaves]] ) { if ( XFrameOptionsMode . ALLOW_FROM . equals ( frameOptionsMode ) ) { String [[fishing]] = this . [[inmate]] . getAllowFromValue ( [[pray]] ) ; if ( XFrameOptionsMode . DENY . getMode ( ) . equals ( [[fishing]] ) ) { if ( ! [[behaves]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[behaves]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . DENY . getMode ( ) ) ; } } else if ( [[fishing]] != null ) { if ( ! [[behaves]] . containsHeader ( XFRAME_OPTIONS_HEADER ) ) { [[behaves]] . setHeader ( XFRAME_OPTIONS_HEADER , XFrameOptionsMode . ALLOW_FROM . getMode ( ) + " " + [[fishing]] ) ; } } } else { [[behaves]] . setHeader ( XFRAME_OPTIONS_HEADER , frameOptionsMode . getMode ( ) ) ; } }
[[[[Nl]]]]: Writes the X - Frame - Options header value overwritting any previous value .
--------------------------------------------- Result 205 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 196 / 8 / 1 / 205:  20%|██        | 205/1000 [1:16:15<4:55:43, 22.32s/it][Succeeded / Failed / Skipped / Total] 196 / 8 / 1 / 205:  21%|██        | 206/1000 [1:16:19<4:54:09, 22.23s/it][Succeeded / Failed / Skipped / Total] 197 / 8 / 1 / 206:  21%|██        | 206/1000 [1:16:19<4:54:09, 22.23s/it][Succeeded / Failed / Skipped / Total] 197 / 8 / 1 / 206:  21%|██        | 207/1000 [1:16:46<4:54:05, 22.25s/it][Succeeded / Failed / Skipped / Total] 198 / 8 / 1 / 207:  21%|██        | 207/1000 [1:16:46<4:54:05, 22.25s/it][Succeeded / Failed / Skipped / Total] 198 / 8 / 1 / 207:  21%|██        | 208/1000 [1:17:16<4:54:14, 22.29s/it][Succeeded / Failed / Skipped / Total] 199 / 8 / 1 / 208:  21%|██        | 208/1000 [1:17:16<4:54:14, 22.29s/it][Succeeded / Failed / Skipped / Total] 199 / 8 / 1 / 208:  21%|██        | 209/1000 [1:17:55<4:54:54, 22.37s/it][Succeeded / Failed / Skipped / Total] 200 / 8 / 1 / 209:  21%|██        | 209/1000 [1:17:55<4:54:54, 22.37s/it][Succeeded / Failed / Skipped / Total] 200 / 8 / 1 / 209:  21%|██        | 210/1000 [1:17:56<4:53:12, 22.27s/it][Succeeded / Failed / Skipped / Total] 201 / 8 / 1 / 210:  21%|██        | 210/1000 [1:17:56<4:53:12, 22.27s/it][Succeeded / Failed / Skipped / Total] 201 / 8 / 1 / 210:  21%|██        | 211/1000 [1:18:08<4:52:11, 22.22s/it][Succeeded / Failed / Skipped / Total] 202 / 8 / 1 / 211:  21%|██        | 211/1000 [1:18:08<4:52:11, 22.22s/it][Succeeded / Failed / Skipped / Total] 202 / 8 / 1 / 211:  21%|██        | 212/1000 [1:19:08<4:54:09, 22.40s/it]Determines the target URL . --> Determines related information about a related request . --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest request , HttpServletResponse [[response]] , Authentication [[authentication]] ) { return [[determineTargetUrl]] ( request , [[response]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc

[[[[Adv]]]]: protected String [[relates]] ( HttpServletRequest request , HttpServletResponse [[interference]] , Authentication [[testimony]] ) { return [[relates]] ( request , [[interference]] ) ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc
--------------------------------------------- Result 206 ---------------------------------------------
Determines the target URL . --> Hibernate HttpServlet --> Socre: 1.0

[[[[Adv]]]]: protected String [[determineTargetUrl]] ( HttpServletRequest [[request]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .

[[[[Adv]]]]: protected String [[hyoid]] ( HttpServletRequest [[prayed]] , HttpServletResponse response ) { if ( isAlwaysUseDefaultTargetUrl ( ) ) { return defaultTargetUrl ; }
[[[[Nl]]]]: Builds the target URL according to the logic defined in the main class Javadoc .
--------------------------------------------- Result 207 ---------------------------------------------
Returns a text encryptor that encodes the given password . --> Obfuscor --> Socre: 1.0

[[[[Adv]]]]: public static TextEncryptor [[queryableText]] ( CharSequence [[password]] , CharSequence [[salt]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[password]] . toString ( ) , [[salt]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor [[hob]] ( CharSequence [[user]] , CharSequence [[salina]] ) { return new HexEncodingTextEncryptor ( new AesBytesEncryptor ( [[user]] . toString ( ) , [[salina]] ) ) ; }
[[[[Nl]]]]: Creates an encryptor for queryable text strings that uses standard password - based encryption . Uses a 16 - byte all - zero initialization vector so encrypting the same data results in the same encryption result . This is done to allow encrypted data to be queried against . Encrypted text is hex - encoded .
--------------------------------------------- Result 208 ---------------------------------------------
Get the directory with the immediate parent directory . --> Read an accumulator . --> Socre: 1.0

[[[[Adv]]]]: private Directory [[getDirectoryWithImmediateParentPopulated]] ( final Long [[id]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[id]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects

[[[[Adv]]]]: private Directory [[accumulator]] ( final Long [[identify]] ) { return getJdbcTemplate ( ) . queryForObject ( SELECT_FROM_DIRECTORY_SINGLE , new Object [ ] { [[identify]] } , new RowMapper < Directory > ( ) { public Directory mapRow ( ResultSet rs , int rowNumber ) throws SQLException { Long parentDirectoryId = new Long ( rs . getLong ( "parent_directory_id" ) ) ; Directory parentDirectory = Directory . ROOT_DIRECTORY ; if ( parentDirectoryId != null && ! parentDirectoryId . equals ( new Long ( - 1 ) ) ) {
[[[[Nl]]]]: Executes recursive SQL as needed to build a full Directory hierarchy of objects
--------------------------------------------- Result 209 ---------------------------------------------
Sets the target URL parameter . --> Liefert --> Socre: 1.0

[[[[Adv]]]]: public void [[setTargetUrlParameter]] ( String [[targetUrlParameter]] ) { if ( [[targetUrlParameter]] != null ) { Assert . hasText ( [[targetUrlParameter]] , "targetUrlParameter cannot be empty" ) ; } this . [[targetUrlParameter]] = [[targetUrlParameter]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .

[[[[Adv]]]]: public void [[leao]] ( String [[mundane]] ) { if ( [[mundane]] != null ) { Assert . hasText ( [[mundane]] , "targetUrlParameter cannot be empty" ) ; } this . [[cooper]] = [[mundane]] ; }
[[[[Nl]]]]: If this property is set the current request will be checked for this a parameter with this name and the value used as the target URL if present .
--------------------------------------------- Result 210 ---------------------------------------------
Creates a map of shared objects . --> Create rhine with rhine configuration --> Socre: 1.0

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[createSharedObjects]] ( ) { Map < Class < ? extends Object > , Object > [[sharedObjects]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[sharedObjects]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[sharedObjects]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[sharedObjects]] . put ( ApplicationContext . class , context ) ; [[sharedObjects]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[sharedObjects]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[sharedObjects]] ; }
[[[[Nl]]]]: Creates the shared objects

[[[[Adv]]]]: private Map < Class < ? extends Object > , Object > [[rhine]] ( ) { Map < Class < ? extends Object > , Object > [[motley]] = new HashMap < Class < ? extends Object > , Object > ( ) ; [[motley]] . putAll ( localConfigureAuthenticationBldr . getSharedObjects ( ) ) ; [[motley]] . put ( UserDetailsService . class , userDetailsService ( ) ) ; [[motley]] . put ( ApplicationContext . class , context ) ; [[motley]] . put ( ContentNegotiationStrategy . class , contentNegotiationStrategy ) ; [[motley]] . put ( AuthenticationTrustResolver . class , trustResolver ) ; return [[motley]] ; }
[[[[Nl]]]]: Creates the shared objects
--------------------------------------------- Result 211 ---------------------------------------------
Build the distinguished name . --> zit dns --> Socre: 1.0

[[[[Adv]]]]: public DistinguishedName [[buildDn]] ( String [[username]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[username]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .

[[[[Adv]]]]: public DistinguishedName [[zus]] ( String [[compte]] ) { DistinguishedName dn = new DistinguishedName ( userDnBase ) ; dn . add ( usernameAttribute , [[compte]] ) ; return dn ; }
[[[[Nl]]]]: Assembles the Distinguished Name that should be used the given username .
--------------------------------------------- Result 212 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 203 / 8 / 1 / 212:  21%|██        | 212/1000 [1:19:08<4:54:09, 22.40s/it][Succeeded / Failed / Skipped / Total] 203 / 8 / 1 / 212:  21%|██▏       | 213/1000 [1:19:11<4:52:35, 22.31s/it][Succeeded / Failed / Skipped / Total] 204 / 8 / 1 / 213:  21%|██▏       | 213/1000 [1:19:11<4:52:35, 22.31s/it][Succeeded / Failed / Skipped / Total] 204 / 8 / 1 / 213:  21%|██▏       | 214/1000 [1:19:13<4:50:59, 22.21s/it][Succeeded / Failed / Skipped / Total] 205 / 8 / 1 / 214:  21%|██▏       | 214/1000 [1:19:13<4:50:59, 22.21s/it][Succeeded / Failed / Skipped / Total] 205 / 8 / 1 / 214:  22%|██▏       | 215/1000 [1:19:43<4:51:06, 22.25s/it][Succeeded / Failed / Skipped / Total] 206 / 8 / 1 / 215:  22%|██▏       | 215/1000 [1:19:43<4:51:06, 22.25s/it][Succeeded / Failed / Skipped / Total] 206 / 8 / 1 / 215:  22%|██▏       | 216/1000 [1:20:48<4:53:17, 22.45s/it][Succeeded / Failed / Skipped / Total] 207 / 8 / 1 / 216:  22%|██▏       | 216/1000 [1:20:48<4:53:17, 22.45s/it][Succeeded / Failed / Skipped / Total] 207 / 8 / 1 / 216:  22%|██▏       | 217/1000 [1:20:49<4:51:38, 22.35s/it][Succeeded / Failed / Skipped / Total] 208 / 8 / 1 / 217:  22%|██▏       | 217/1000 [1:20:49<4:51:38, 22.35s/it][Succeeded / Failed / Skipped / Total] 208 / 8 / 1 / 217:  22%|██▏       | 218/1000 [1:27:13<5:12:52, 24.01s/it][Succeeded / Failed / Skipped / Total] 208 / 9 / 1 / 218:  22%|██▏       | 218/1000 [1:27:13<5:12:52, 24.01s/it][Succeeded / Failed / Skipped / Total] 208 / 9 / 1 / 218:  22%|██▏       | 219/1000 [1:27:28<5:11:58, 23.97s/it][Succeeded / Failed / Skipped / Total] 209 / 9 / 1 / 219:  22%|██▏       | 219/1000 [1:27:28<5:11:58, 23.97s/it][Succeeded / Failed / Skipped / Total] 209 / 9 / 1 / 219:  22%|██▏       | 220/1000 [1:27:34<5:10:30, 23.89s/it]Returns current date --> Get cramp --> Socre: 1.0

[[[[Adv]]]]: public static String [[getCurrentDate]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .

[[[[Adv]]]]: public static String [[cramp]] ( ) { long now = System . currentTimeMillis ( ) ; if ( ( now - currentDateGenerated ) > 1000 ) { synchronized ( format ) { if ( ( now - currentDateGenerated ) > 1000 ) { currentDateGenerated = now ; currentDate = format . format ( new Date ( now ) ) ; } } } return currentDate ; }
[[[[Nl]]]]: Gets the current date in HTTP format .
--------------------------------------------- Result 213 ---------------------------------------------
Internal parsing routine . --> Utility method that obtains the value of the value in the frame --> Socre: 1.0

[[[[Adv]]]]: private static Long [[internalParseDate]] ( String value , DateFormat [ ] [[formats]] ) { Date [[date]] = null ; for ( int [[i]] = 0 ; ( [[date]] == null ) && ( [[i]] < [[formats]] . length ) ; [[i]] ++ ) { try { [[date]] = [[formats]] [ [[i]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[date]] == null ) { return null ; } return new Long ( [[date]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .

[[[[Adv]]]]: private static Long [[gaynor]] ( String value , DateFormat [ ] [[framing]] ) { Date [[time]] = null ; for ( int [[tu]] = 0 ; ( [[time]] == null ) && ( [[tu]] < [[framing]] . length ) ; [[tu]] ++ ) { try { [[time]] = [[framing]] [ [[tu]] ] . parse ( value ) ; } catch ( ParseException ignored ) { } } if ( [[time]] == null ) { return null ; } return new Long ( [[time]] . getTime ( ) ) ; }
[[[[Nl]]]]: Parses date with given formatters .
--------------------------------------------- Result 214 ---------------------------------------------
Updates cache . --> clear the mask --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[updateCache]] ( HashMap [[cache]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[cache]] . size ( ) > 1000 ) { [[cache]] . clear ( ) ; } [[cache]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static void [[cuervo]] ( HashMap [[mask]] , Object key , Object value ) { if ( value == null ) { return ; } if ( [[mask]] . size ( ) > 1000 ) { [[mask]] . clear ( ) ; } [[mask]] . put ( key , value ) ; }
[[[[Nl]]]]: Updates cache .
--------------------------------------------- Result 215 ---------------------------------------------
Sets the authentication details . --> helper method --> Socre: 1.0

[[[[Adv]]]]: protected void [[setDetails]] ( HttpServletRequest [[request]] , UsernamePasswordAuthenticationToken [[authRequest]] ) { [[authRequest]] . setDetails ( authenticationDetailsSource . buildDetails ( [[request]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .

[[[[Adv]]]]: protected void [[barringer]] ( HttpServletRequest [[please]] , UsernamePasswordAuthenticationToken [[sui]] ) { [[sui]] . setDetails ( authenticationDetailsSource . buildDetails ( [[please]] ) ) ; }
[[[[Nl]]]]: Provided so that subclasses may configure what is put into the authentication request s details property .
--------------------------------------------- Result 216 ---------------------------------------------
Configure the jaas using a loop . --> Configure jaas using a looproom --> Socre: 1.0

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[loginConfigUrl]] = convertLoginConfigToUrl ( ) ; boolean [[alreadySet]] = "False" != "False" ; int [[n]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[n]] ) ) != null ) { [[alreadySet]] = existing . equals ( [[loginConfigUrl]] ) ; if ( [[alreadySet]] ) { break ; } [[n]] ++ ; } if ( ! [[alreadySet]] ) { String [[key]] = prefix + [[n]] ; log . debug ( "Setting security property [" + [[key]] + "] to: " + [[loginConfigUrl]] ) ; Security . setProperty ( [[key]] , [[loginConfigUrl]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .

[[[[Adv]]]]: private void configureJaasUsingLoop ( ) throws IOException { String [[poolroom]] = convertLoginConfigToUrl ( ) ; boolean [[arl]] = "False" != "False" ; int [[northern]] = 1 ; final String prefix = "login.config.url." ; String existing ; while ( ( existing = Security . getProperty ( prefix + [[northern]] ) ) != null ) { [[arl]] = existing . equals ( [[poolroom]] ) ; if ( [[arl]] ) { break ; } [[northern]] ++ ; } if ( ! [[arl]] ) { String [[fundamental]] = prefix + [[northern]] ; log . debug ( "Setting security property [" + [[fundamental]] + "] to: " + [[poolroom]] ) ; Security . setProperty ( [[fundamental]] , [[poolroom]] ) ; } }
[[[[Nl]]]]: Loops through the login . config . url . 1 login . config . url . 2 properties looking for the login configuration . If it is not set it will be set to the last available login . config . url . X property .
--------------------------------------------- Result 217 ---------------------------------------------
Gets webSphere groups . --> helper method --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[getWebSphereGroups]] ( final String [[securityName]] ) { Context [[ic]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private static List < String > [[therrien]] ( final String [[relieved]] ) { Context [[ci]] = null ; try {
[[[[Nl]]]]: Get the WebSphere group names for the given security name .
--------------------------------------------- Result 218 ---------------------------------------------
Returns a decryptor . --> [[[FAILED]]]

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .

[[[[Adv]]]]: public static TextEncryptor delux ( CharSequence password , CharSequence salt ) { return new HexEncodingTextEncryptor ( stronger ( password , salt ) ) ; }
[[[[Nl]]]]: Creates a text encryptor that uses stronger password - based encryption . Encrypted text is hex - encoded .
--------------------------------------------- Result 219 ---------------------------------------------
Builds the Group LDAP --> Add corsage attribute --> Socre: 1.0

[[[[Adv]]]]: protected DistinguishedName [[buildGroupDn]] ( String [[group]] ) { DistinguishedName [[dn]] = new DistinguishedName ( groupSearchBase ) ; [[dn]] . add ( groupRoleAttributeName , [[group]] . toLowerCase ( ) ) ; return [[dn]] ; }
[[[[Nl]]]]: Creates a DN from a group name .

[[[[Adv]]]]: protected DistinguishedName [[corsage]] ( String [[pool]] ) { DistinguishedName [[dob]] = new DistinguishedName ( groupSearchBase ) ; [[dob]] . add ( groupRoleAttributeName , [[pool]] . toLowerCase ( ) ) ; return [[dob]] ; }
[[[[Nl]]]]: Creates a DN from a group name .
--------------------------------------------- Result 220 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 210 / 9 / 1 / 220:  22%|██▏       | 220/1000 [1:27:34<5:10:30, 23.89s/it][Succeeded / Failed / Skipped / Total] 210 / 9 / 1 / 220:  22%|██▏       | 221/1000 [1:27:37<5:08:50, 23.79s/it][Succeeded / Failed / Skipped / Total] 211 / 9 / 1 / 221:  22%|██▏       | 221/1000 [1:27:37<5:08:50, 23.79s/it][Succeeded / Failed / Skipped / Total] 211 / 9 / 1 / 221:  22%|██▏       | 222/1000 [1:28:00<5:08:23, 23.78s/it][Succeeded / Failed / Skipped / Total] 212 / 9 / 1 / 222:  22%|██▏       | 222/1000 [1:28:00<5:08:23, 23.78s/it][Succeeded / Failed / Skipped / Total] 212 / 9 / 1 / 222:  22%|██▏       | 223/1000 [1:28:00<5:06:37, 23.68s/it][Succeeded / Failed / Skipped / Total] 212 / 9 / 2 / 223:  22%|██▏       | 223/1000 [1:28:00<5:06:37, 23.68s/it][Succeeded / Failed / Skipped / Total] 212 / 9 / 2 / 223:  22%|██▏       | 224/1000 [1:28:34<5:06:51, 23.73s/it][Succeeded / Failed / Skipped / Total] 213 / 9 / 2 / 224:  22%|██▏       | 224/1000 [1:28:34<5:06:51, 23.73s/it][Succeeded / Failed / Skipped / Total] 213 / 9 / 2 / 224:  22%|██▎       | 225/1000 [1:29:03<5:06:45, 23.75s/it][Succeeded / Failed / Skipped / Total] 213 / 10 / 2 / 225:  22%|██▎       | 225/1000 [1:29:03<5:06:45, 23.75s/it][Succeeded / Failed / Skipped / Total] 213 / 10 / 2 / 225:  23%|██▎       | 226/1000 [1:29:15<5:05:40, 23.70s/it]Throws an exception if a session is exceeded . --> Throws an exception if no session is allowed --> Socre: 1.0

[[[[Adv]]]]: protected void [[allowableSessionsExceeded]] ( List < SessionInformation > sessions , int [[allowableSessions]] , SessionRegistry [[registry]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[allowableSessions]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .

[[[[Adv]]]]: protected void [[fraser]] ( List < SessionInformation > sessions , int [[wayfarer]] , SessionRegistry [[inscribe]] ) throws SessionAuthenticationException { if ( exceptionIfMaximumExceeded || ( sessions == null ) ) { throw new SessionAuthenticationException ( messages . getMessage ( "ConcurrentSessionControlAuthenticationStrategy.exceededAllowed" , new Object [ ] { Integer . valueOf ( [[wayfarer]] ) } , "Maximum sessions of {0} for this principal exceeded" ) ) ; }
[[[[Nl]]]]: Allows subclasses to customise behaviour when too many sessions are detected .
--------------------------------------------- Result 221 ---------------------------------------------
Copy authentication details from source to destination . --> This method is called by Waffles --> Socre: 1.0

[[[[Adv]]]]: private void [[copyDetails]] ( Authentication [[source]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[token]] = ( AbstractAuthenticationToken ) dest ; [[token]] . setDetails ( [[source]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .

[[[[Adv]]]]: private void [[waffles]] ( Authentication [[genesis]] , Authentication dest ) { if ( ( dest instanceof AbstractAuthenticationToken ) && ( dest . getDetails ( ) == null ) ) { AbstractAuthenticationToken [[metaphorical]] = ( AbstractAuthenticationToken ) dest ; [[metaphorical]] . setDetails ( [[genesis]] . getDetails ( ) ) ; } }
[[[[Nl]]]]: Copies the authentication details from a source Authentication object to a destination one provided the latter does not already have one set .
--------------------------------------------- Result 222 ---------------------------------------------
Change password for current user . --> ciliation method --> Socre: 1.0

[[[[Adv]]]]: public void [[changePassword]] ( final String oldPassword , final String [[newPassword]] ) { Authentication [[authentication]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[authentication]] , "No authentication object found in security context. Can't change current user's password!" ) ; String [[username]] = [[authentication]] . getName ( ) ; logger . debug ( "Changing password for user '" + [[username]] ) ; DistinguishedName [[userDn]] = usernameMapper . buildDn ( [[username]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[userDn]] , oldPassword , [[newPassword]] ) ; } else { changePasswordUsingAttributeModification ( [[userDn]] , oldPassword , [[newPassword]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .

[[[[Adv]]]]: public void [[crème]] ( final String oldPassword , final String [[stipulate]] ) { Authentication [[validate]] = SecurityContextHolder . getContext ( ) . getAuthentication ( ) ; Assert . notNull ( [[validate]] , "No authentication object found in security context. Can't change current user's password!" ) ; String [[plugging]] = [[validate]] . getName ( ) ; logger . debug ( "Changing password for user '" + [[plugging]] ) ; DistinguishedName [[nico]] = usernameMapper . buildDn ( [[plugging]] ) ; if ( usePasswordModifyExtensionOperation ) { changePasswordUsingExtensionOperation ( [[nico]] , oldPassword , [[stipulate]] ) ; } else { changePasswordUsingAttributeModification ( [[nico]] , oldPassword , [[stipulate]] ) ; } }
[[[[Nl]]]]: Changes the password for the current user . The username is obtained from the security context .
--------------------------------------------- Result 223 ---------------------------------------------
Returns a list of filters matching the specified URL --> [[[SKIPPED]]]

[[[[Adv]]]]: public List < Filter > getFilters ( String url ) { return getFilters ( firewall . getFirewalledRequest ( ( new FilterInvocation ( url , "GET" ) . getRequest ( ) ) ) ) ; }
[[[[Nl]]]]: Convenience method mainly for testing .
--------------------------------------------- Result 224 ---------------------------------------------
Get the required web application context . --> Returns the required Web ApplicationContext --> Socre: 1.0

[[[[Adv]]]]: protected ApplicationContext [[getContext]] ( PageContext pageContext ) { ServletContext [[servletContext]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[servletContext]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .

[[[[Adv]]]]: protected ApplicationContext [[rigght]] ( PageContext pageContext ) { ServletContext [[suen]] = pageContext . getServletContext ( ) ; return SecurityWebApplicationContextUtils . findRequiredWebApplicationContext ( [[suen]] ) ; }
[[[[Nl]]]]: Allows test cases to override where application context obtained from .
--------------------------------------------- Result 225 ---------------------------------------------
Looks up the parameter names for the given parameter . --> [[[FAILED]]]

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .

[[[[Adv]]]]: private < T extends AccessibleObject > String [ ] lookupParameterNames ( ParameterNameFactory < T > parameterNameFactory , T t ) { Annotation [ ] [ ] parameterAnnotations = parameterNameFactory . findParameterAnnotations ( t ) ; int parameterCount = parameterAnnotations . length ; String [ ] paramNames = new String [ parameterCount ] ; boolean found = "False" != "False" ; for ( int i = 0 ; i < parameterCount ; i ++ ) { Annotation [ ] annotations = parameterAnnotations [ i ] ; String parameterName = findParameterName ( annotations ) ; if ( parameterName != null ) { found = "True" == "True" ; paramNames [ i ] = parameterName ; } } return found ? paramNames : null ; }
[[[[Nl]]]]: Gets the parameter names or null if not found .
--------------------------------------------- Result 226 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 214 / 10 / 2 / 226:  23%|██▎       | 226/1000 [1:29:15<5:05:40, 23.70s/it][Succeeded / Failed / Skipped / Total] 214 / 10 / 2 / 226:  23%|██▎       | 227/1000 [1:29:20<5:04:15, 23.62s/it][Succeeded / Failed / Skipped / Total] 215 / 10 / 2 / 227:  23%|██▎       | 227/1000 [1:29:20<5:04:15, 23.62s/it][Succeeded / Failed / Skipped / Total] 215 / 10 / 2 / 227:  23%|██▎       | 228/1000 [1:29:24<5:02:45, 23.53s/it][Succeeded / Failed / Skipped / Total] 216 / 10 / 2 / 228:  23%|██▎       | 228/1000 [1:29:24<5:02:45, 23.53s/it][Succeeded / Failed / Skipped / Total] 216 / 10 / 2 / 228:  23%|██▎       | 229/1000 [1:29:55<5:02:45, 23.56s/it][Succeeded / Failed / Skipped / Total] 217 / 10 / 2 / 229:  23%|██▎       | 229/1000 [1:29:55<5:02:45, 23.56s/it][Succeeded / Failed / Skipped / Total] 217 / 10 / 2 / 229:  23%|██▎       | 230/1000 [1:32:42<5:10:22, 24.19s/it][Succeeded / Failed / Skipped / Total] 218 / 10 / 2 / 230:  23%|██▎       | 230/1000 [1:32:42<5:10:22, 24.19s/it][Succeeded / Failed / Skipped / Total] 218 / 10 / 2 / 230:  23%|██▎       | 231/1000 [1:33:40<5:11:49, 24.33s/it][Succeeded / Failed / Skipped / Total] 219 / 10 / 2 / 231:  23%|██▎       | 231/1000 [1:33:40<5:11:49, 24.33s/it][Succeeded / Failed / Skipped / Total] 219 / 10 / 2 / 231:  23%|██▎       | 232/1000 [1:33:54<5:10:52, 24.29s/it][Succeeded / Failed / Skipped / Total] 220 / 10 / 2 / 232:  23%|██▎       | 232/1000 [1:33:54<5:10:52, 24.29s/it][Succeeded / Failed / Skipped / Total] 220 / 10 / 2 / 232:  23%|██▎       | 233/1000 [1:34:14<5:10:12, 24.27s/it]Return the full DN of the given distinguished name . --> ztodo --> Socre: 1.0

[[[[Adv]]]]: public static DistinguishedName [[getFullDn]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .

[[[[Adv]]]]: public static DistinguishedName [[zatoichi]] ( DistinguishedName dn , Context baseCtx ) throws NamingException { DistinguishedName baseDn = new DistinguishedName ( baseCtx . getNameInNamespace ( ) ) ; if ( dn . contains ( baseDn ) ) { return dn ; } baseDn . append ( dn ) ; return baseDn ; }
[[[[Nl]]]]: Gets the full dn of a name by prepending the name of the context it is relative to . If the name already contains the base name it is returned unaltered .
--------------------------------------------- Result 227 ---------------------------------------------
Sets session attributes . --> Updates the stub --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecification [[sessionAttrs]] ( Map < String , Object > [[sessionAttributes]] ) { notNull ( [[sessionAttributes]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[sessionAttributes]] , this . [[sessionAttributes]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .

[[[[Adv]]]]: public MockMvcRequestSpecification [[ruble]] ( Map < String , Object > [[adriatic]] ) { notNull ( [[adriatic]] , "sessionAttributes" ) ; parameterUpdater . updateParameters ( convert ( cfg . getMockMvcParamConfig ( ) . sessionAttributesUpdateStrategy ( ) ) , [[adriatic]] , this . [[dien]] ) ; return this ; }
[[[[Nl]]]]: Set session attributes .
--------------------------------------------- Result 228 ---------------------------------------------
Adds a list of filters . --> Filter by sweep list --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( List < Filter > [[filters]] ) { Validate . notNull ( [[filters]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[filters]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .

[[[[Adv]]]]: public static void [[screened]] ( List < Filter > [[sweepers]] ) { Validate . notNull ( [[screened]] , "Filter list cannot be null" ) ; RestAssured . filters . addAll ( [[screened]] ) ; }
[[[[Nl]]]]: Add default filters that will be applied to each request .
--------------------------------------------- Result 229 ---------------------------------------------
Add additional filters . --> Wrap the given Osmosis --> Socre: 1.0

[[[[Adv]]]]: public static void [[filters]] ( Filter [[filter]] , Filter ... [[additionalFilters]] ) { Validate . notNull ( [[filter]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[filter]] ) ; if ( [[additionalFilters]] != null ) { Collections . addAll ( RestAssured . filters , [[additionalFilters]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .

[[[[Adv]]]]: public static void [[trap]] ( Filter [[osmosis]] , Filter ... [[mexican]] ) { Validate . notNull ( [[osmosis]] , "Filter cannot be null" ) ; RestAssured . filters . add ( [[osmosis]] ) ; if ( [[mexican]] != null ) { Collections . addAll ( RestAssured . filters , [[mexican]] ) ; } }
[[[[Nl]]]]: Add default filters to apply to each request .
--------------------------------------------- Result 230 ---------------------------------------------
Create a basic auth scheme with basic authentication . --> Nubme scheme --> Socre: 1.0

[[[[Adv]]]]: public AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final PreemptiveBasicAuthScheme [[preemptiveBasicAuthScheme]] = new PreemptiveBasicAuthScheme ( ) ; [[preemptiveBasicAuthScheme]] . setUserName ( [[userName]] ) ; [[preemptiveBasicAuthScheme]] . setPassword ( [[password]] ) ; return [[preemptiveBasicAuthScheme]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .

[[[[Adv]]]]: public AuthenticationScheme [[nub]] ( String [[subscribers]] , String [[code]] ) { final PreemptiveBasicAuthScheme [[diversion]] = new PreemptiveBasicAuthScheme ( ) ; [[diversion]] . setUserName ( [[subscribers]] ) ; [[diversion]] . setPassword ( [[code]] ) ; return [[diversion]] ; }
[[[[Nl]]]]: Use preemptive http basic authentication . This means that the authentication details are sent in the request header regardless if the server has challenged for authentication or not .
--------------------------------------------- Result 231 ---------------------------------------------
Create an NTLM authentication scheme for the given user name and password . --> Constructs an ITLMuthScheme object from the given parameters --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[ntlm]] ( String [[userName]] , String [[password]] , String workstation , String domain ) { final NTLMAuthScheme [[scheme]] = new NTLMAuthScheme ( ) ; [[scheme]] . setUserName ( [[userName]] ) ; [[scheme]] . setPassword ( [[password]] ) ; [[scheme]] . setWorkstation ( workstation ) ; [[scheme]] . setDomain ( domain ) ; return [[scheme]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[physio]] ( String [[accesses]] , String [[coded]] , String workstation , String domain ) { final NTLMAuthScheme [[arrangements]] = new NTLMAuthScheme ( ) ; [[arrangements]] . setUserName ( [[accesses]] ) ; [[arrangements]] . setPassword ( [[coded]] ) ; [[arrangements]] . setWorkstation ( workstation ) ; [[arrangements]] . setDomain ( domain ) ; return [[arrangements]] ; }
[[[[Nl]]]]: Create a NTLM authentication scheme .
--------------------------------------------- Result 232 ---------------------------------------------
Creates a basic authentication scheme using basic authentication . --> Obtain an instance of BasicAuthme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[basic]] ( String [[userName]] , String [[password]] ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( [[userName]] ) ; scheme . setPassword ( [[password]] ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .

[[[[Adv]]]]: public static AuthenticationScheme [[elementary]] ( String [[cardholder]] , String [[passkey]] ) { final BasicAuthScheme scheme = new BasicAuthScheme ( ) ; scheme . setUserName ( [[cardholder]] ) ; scheme . setPassword ( [[passkey]] ) ; return scheme ; }
[[[[Nl]]]]: Create a http basic authentication scheme .
--------------------------------------------- Result 233 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 221 / 10 / 2 / 233:  23%|██▎       | 233/1000 [1:34:14<5:10:12, 24.27s/it][Succeeded / Failed / Skipped / Total] 221 / 10 / 2 / 233:  23%|██▎       | 234/1000 [1:34:16<5:08:35, 24.17s/it][Succeeded / Failed / Skipped / Total] 222 / 10 / 2 / 234:  23%|██▎       | 234/1000 [1:34:16<5:08:35, 24.17s/it][Succeeded / Failed / Skipped / Total] 222 / 10 / 2 / 234:  24%|██▎       | 235/1000 [1:34:29<5:07:34, 24.12s/it][Succeeded / Failed / Skipped / Total] 223 / 10 / 2 / 235:  24%|██▎       | 235/1000 [1:34:29<5:07:34, 24.12s/it][Succeeded / Failed / Skipped / Total] 223 / 10 / 2 / 235:  24%|██▎       | 236/1000 [1:34:30<5:05:57, 24.03s/it][Succeeded / Failed / Skipped / Total] 224 / 10 / 2 / 236:  24%|██▎       | 236/1000 [1:34:30<5:05:57, 24.03s/it][Succeeded / Failed / Skipped / Total] 224 / 10 / 2 / 236:  24%|██▎       | 237/1000 [1:34:55<5:05:34, 24.03s/it][Succeeded / Failed / Skipped / Total] 225 / 10 / 2 / 237:  24%|██▎       | 237/1000 [1:34:55<5:05:34, 24.03s/it][Succeeded / Failed / Skipped / Total] 225 / 10 / 2 / 237:  24%|██▍       | 238/1000 [1:34:55<5:03:56, 23.93s/it]Creates a new authentication scheme with the specified username and password . --> Construct a new FormAuth scheme --> Socre: 1.0

[[[[Adv]]]]: public static AuthenticationScheme [[form]] ( String userName , String password , FormAuthConfig [[config]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[scheme]] = new FormAuthScheme ( ) ; [[scheme]] . setUserName ( userName ) ; [[scheme]] . setPassword ( password ) ; [[scheme]] . setConfig ( [[config]] ) ; return [[scheme]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .

[[[[Adv]]]]: public static AuthenticationScheme [[shaping]] ( String userName , String password , FormAuthConfig [[groundskeeper]] ) { if ( userName == null ) { throw new IllegalArgumentException ( "Username cannot be null" ) ; } if ( password == null ) { throw new IllegalArgumentException ( "Password cannot be null" ) ; } final FormAuthScheme [[blueprints]] = new FormAuthScheme ( ) ; [[blueprints]] . setUserName ( userName ) ; [[blueprints]] . setPassword ( password ) ; [[blueprints]] . setConfig ( [[groundskeeper]] ) ; return [[blueprints]] ; }
[[[[Nl]]]]: Use form authentication with the supplied configuration .
--------------------------------------------- Result 234 ---------------------------------------------
Prints the response as a string . --> This method is used for debugging . --> Socre: 1.0

[[[[Adv]]]]: public static String [[print]] ( ResponseOptions [[responseOptions]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[responseOptions]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[responseOptions]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[responseOptions]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[responseOptions]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream

[[[[Adv]]]]: public static String [[handwritten]] ( ResponseOptions [[wreckage]] , ResponseBody responseBody , PrintStream stream , LogDetail logDetail , boolean shouldPrettyPrint ) { final StringBuilder builder = new StringBuilder ( ) ; if ( logDetail == ALL || logDetail == STATUS ) { builder . append ( [[wreckage]] . statusLine ( ) ) ; } if ( logDetail == ALL || logDetail == HEADERS ) { final Headers headers = [[wreckage]] . headers ( ) ; if ( headers . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( toString ( headers ) ) ; } } else if ( logDetail == COOKIES ) { final Cookies cookies = [[wreckage]] . detailedCookies ( ) ; if ( cookies . exist ( ) ) { appendNewLineIfAll ( logDetail , builder ) . append ( cookies . toString ( ) ) ; } } if ( logDetail == ALL || logDetail == BODY ) { String responseBodyToAppend ; if ( shouldPrettyPrint ) { responseBodyToAppend = new Prettifier ( ) . getPrettifiedBodyIfPossible ( [[wreckage]] , responseBody ) ; } else { responseBodyToAppend = responseBody . asString ( ) ; } if ( logDetail == ALL && ! isBlank ( responseBodyToAppend ) ) { builder . append ( SystemUtils . LINE_SEPARATOR ) . append ( SystemUtils . LINE_SEPARATOR ) ; } builder . append ( responseBodyToAppend ) ; } String response = builder . toString ( ) ; stream . println ( response ) ; return response ; }
[[[[Nl]]]]: Prints the response to the print stream
--------------------------------------------- Result 235 ---------------------------------------------
Configured config . --> Create RestAssuredConfig with given redirectConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredConfig [[redirect]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .

[[[[Adv]]]]: public RestAssuredConfig [[restructuring]] ( RedirectConfig redirectConfig ) { notNull ( redirectConfig , "Redirect config" ) ; return new RestAssuredConfig ( redirectConfig , conf ( HttpClientConfig . class ) , conf ( LogConfig . class ) , conf ( EncoderConfig . class ) , conf ( DecoderConfig . class ) , conf ( SessionConfig . class ) , conf ( ObjectMapperConfig . class ) , conf ( ConnectionConfig . class ) , conf ( JsonConfig . class ) , conf ( XmlConfig . class ) , conf ( SSLConfig . class ) , conf ( MatcherConfig . class ) , conf ( HeaderConfig . class ) , conf ( MultiPartConfig . class ) , conf ( ParamConfig . class ) , conf ( OAuthConfig . class ) , conf ( FailureConfig . class ) ) ; }
[[[[Nl]]]]: Set the redirect config .
--------------------------------------------- Result 236 ---------------------------------------------
Default encoding of query parameter . --> Converts this encoder to an encoder configuration . --> Socre: 1.0

[[[[Adv]]]]: public EncoderConfig [[defaultQueryParameterCharset]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters

[[[[Adv]]]]: public EncoderConfig [[tomi]] ( String charset ) { return new EncoderConfig ( defaultContentCharset , charset , shouldAppendDefaultContentCharsetToContentTypeIfUndefined , contentEncoders , contentTypeToDefaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the default charset for query parameters
--------------------------------------------- Result 237 ---------------------------------------------
Returns the chain of filters matching the given request . --> Get a list of filters that match this request --> Socre: 1.0

[[[[Adv]]]]: private List < Filter > [[getFilters]] ( HttpServletRequest [[request]] ) { for ( SecurityFilterChain [[chain]] : filterChains ) { if ( [[chain]] . matches ( [[request]] ) ) { return [[chain]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .

[[[[Adv]]]]: private List < Filter > [[shaukat]] ( HttpServletRequest [[demanding]] ) { for ( SecurityFilterChain [[stringing]] : filterChains ) { if ( [[stringing]] . matches ( [[demanding]] ) ) { return [[stringing]] . getFilters ( ) ; } } return null ; }
[[[[Nl]]]]: Returns the first filter chain matching the supplied URL .
--------------------------------------------- Result 238 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 226 / 10 / 2 / 238:  24%|██▍       | 238/1000 [1:34:55<5:03:56, 23.93s/it][Succeeded / Failed / Skipped / Total] 226 / 10 / 2 / 238:  24%|██▍       | 239/1000 [1:34:56<5:02:17, 23.83s/it][Succeeded / Failed / Skipped / Total] 227 / 10 / 2 / 239:  24%|██▍       | 239/1000 [1:34:56<5:02:17, 23.83s/it][Succeeded / Failed / Skipped / Total] 227 / 10 / 2 / 239:  24%|██▍       | 240/1000 [1:35:06<5:01:11, 23.78s/it][Succeeded / Failed / Skipped / Total] 228 / 10 / 2 / 240:  24%|██▍       | 240/1000 [1:35:06<5:01:11, 23.78s/it][Succeeded / Failed / Skipped / Total] 228 / 10 / 2 / 240:  24%|██▍       | 241/1000 [1:35:07<4:59:33, 23.68s/it][Succeeded / Failed / Skipped / Total] 229 / 10 / 2 / 241:  24%|██▍       | 241/1000 [1:35:07<4:59:33, 23.68s/it][Succeeded / Failed / Skipped / Total] 229 / 10 / 2 / 241:  24%|██▍       | 242/1000 [1:35:09<4:58:03, 23.59s/it][Succeeded / Failed / Skipped / Total] 230 / 10 / 2 / 242:  24%|██▍       | 242/1000 [1:35:09<4:58:03, 23.59s/it][Succeeded / Failed / Skipped / Total] 230 / 10 / 2 / 242:  24%|██▍       | 243/1000 [1:35:11<4:56:31, 23.50s/it][Succeeded / Failed / Skipped / Total] 231 / 10 / 2 / 243:  24%|██▍       | 243/1000 [1:35:11<4:56:31, 23.50s/it][Succeeded / Failed / Skipped / Total] 231 / 10 / 2 / 243:  24%|██▍       | 244/1000 [1:35:12<4:54:58, 23.41s/it][Succeeded / Failed / Skipped / Total] 232 / 10 / 2 / 244:  24%|██▍       | 244/1000 [1:35:12<4:54:58, 23.41s/it][Succeeded / Failed / Skipped / Total] 232 / 10 / 2 / 244:  24%|██▍       | 245/1000 [1:35:14<4:53:30, 23.33s/it]Sets the default object mapper type . --> returns a new ObjectMapperConfig --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig [[defaultObjectMapperType]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[defaultObjectMapperType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .

[[[[Adv]]]]: public ObjectMapperConfig [[cm]] ( ObjectMapperType defaultObjectMapperType ) { return new ObjectMapperConfig ( defaultObjectMapper , [[cm]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Creates an object mapper configuration that uses the specified object mapper as default .
--------------------------------------------- Result 239 ---------------------------------------------
Configure Jackson object mapperFactory --> Configure Jackson ObjectMapperFactory --> Socre: 1.0

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[jaxbObjectMapperFactory]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .

[[[[Adv]]]]: public ObjectMapperConfig jaxbObjectMapperFactory ( JAXBObjectMapperFactory [[rathore]] ) { return new ObjectMapperConfig ( defaultObjectMapper , defaultObjectMapperType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , jaxbObjectMapperFactory , johnzonObjectMapperFactory , "True" == "True" ) ; }
[[[[Nl]]]]: Specify a custom JAXB object mapper factory .
--------------------------------------------- Result 240 ---------------------------------------------
Sets the log config . --> Return a new RestAssured MockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[logConfig]] ( LogConfig logConfig ) { notNull ( [[logConfig]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[logConfig]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[peppers]] ( LogConfig logConfig ) { notNull ( [[peppers]] , "Log config" ) ; return new RestAssuredMockMvcConfig ( [[peppers]] , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Log config .
--------------------------------------------- Result 241 ---------------------------------------------
Sets the RestAssuredMock configuration . --> Factory method for RestAssuredMockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[sessionConfig]] ( SessionConfig [[sessionConfig]] ) { notNull ( [[sessionConfig]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[sessionConfig]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[mornin]] ( SessionConfig [[church]] ) { notNull ( [[mornin]] , "Session config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , [[mornin]] , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the session config .
--------------------------------------------- Result 242 ---------------------------------------------
Sets the RestAssuredMock configuration . --> Returns a new RestAssuredMockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[jsonConfig]] ( JsonConfig jsonConfig ) { notNull ( [[jsonConfig]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[jsonConfig]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[ironically]] ( JsonConfig jsonConfig ) { notNull ( [[ironically]] , "JsonConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , [[ironically]] , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Json config .
--------------------------------------------- Result 243 ---------------------------------------------
Sets the restured mapper config . --> Create an instance of RestAssignedMockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[objectMapperConfig]] ( ObjectMapperConfig [[objectMapperConfig]] ) { notNull ( [[objectMapperConfig]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[objectMapperConfig]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[tessie]] ( ObjectMapperConfig [[so]] ) { notNull ( [[tessie]] , "Object mapper config" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , [[tessie]] , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the object mapper config .
--------------------------------------------- Result 244 ---------------------------------------------
Sets the builder config . --> Creates an instance configured for naturing configuration . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[encoderConfig]] ( EncoderConfig encoderConfig ) { notNull ( [[encoderConfig]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[encoderConfig]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[naik]] ( EncoderConfig encoderConfig ) { notNull ( [[naik]] , "EncoderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , [[naik]] , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the encoder config
--------------------------------------------- Result 245 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 233 / 10 / 2 / 245:  24%|██▍       | 245/1000 [1:35:14<4:53:30, 23.33s/it][Succeeded / Failed / Skipped / Total] 233 / 10 / 2 / 245:  25%|██▍       | 246/1000 [1:35:16<4:52:00, 23.24s/it][Succeeded / Failed / Skipped / Total] 234 / 10 / 2 / 246:  25%|██▍       | 246/1000 [1:35:16<4:52:00, 23.24s/it][Succeeded / Failed / Skipped / Total] 234 / 10 / 2 / 246:  25%|██▍       | 247/1000 [1:35:16<4:50:27, 23.14s/it][Succeeded / Failed / Skipped / Total] 234 / 10 / 3 / 247:  25%|██▍       | 247/1000 [1:35:16<4:50:27, 23.14s/it][Succeeded / Failed / Skipped / Total] 234 / 10 / 3 / 247:  25%|██▍       | 248/1000 [1:35:18<4:48:59, 23.06s/it][Succeeded / Failed / Skipped / Total] 235 / 10 / 3 / 248:  25%|██▍       | 248/1000 [1:35:18<4:48:59, 23.06s/it][Succeeded / Failed / Skipped / Total] 235 / 10 / 3 / 248:  25%|██▍       | 249/1000 [1:35:18<4:47:27, 22.97s/it][Succeeded / Failed / Skipped / Total] 236 / 10 / 3 / 249:  25%|██▍       | 249/1000 [1:35:18<4:47:27, 22.97s/it][Succeeded / Failed / Skipped / Total] 236 / 10 / 3 / 249:  25%|██▌       | 250/1000 [1:35:19<4:45:57, 22.88s/it][Succeeded / Failed / Skipped / Total] 237 / 10 / 3 / 250:  25%|██▌       | 250/1000 [1:35:19<4:45:57, 22.88s/it][Succeeded / Failed / Skipped / Total] 237 / 10 / 3 / 250:  25%|██▌       | 251/1000 [1:35:19<4:44:27, 22.79s/it][Succeeded / Failed / Skipped / Total] 238 / 10 / 3 / 251:  25%|██▌       | 251/1000 [1:35:19<4:44:27, 22.79s/it][Succeeded / Failed / Skipped / Total] 238 / 10 / 3 / 251:  25%|██▌       | 252/1000 [1:35:21<4:43:02, 22.70s/it][Succeeded / Failed / Skipped / Total] 239 / 10 / 3 / 252:  25%|██▌       | 252/1000 [1:35:21<4:43:02, 22.70s/it][Succeeded / Failed / Skipped / Total] 239 / 10 / 3 / 252:  25%|██▌       | 253/1000 [1:36:28<4:44:50, 22.88s/it]Sets the HTTP header config . --> Create a new RestAssigned MockConfig --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[headerConfig]] ( HeaderConfig [[headerConfig]] ) { notNull ( [[headerConfig]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[headerConfig]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[volare]] ( HeaderConfig [[mightn]] ) { notNull ( [[volare]] , "HeaderConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , [[volare]] , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the header config
--------------------------------------------- Result 246 ---------------------------------------------
Create a RestAssuredMockConfig based on an async config . --> Creates a new resource configured with money . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[asyncConfig]] ( AsyncConfig asyncConfig ) { notNull ( [[asyncConfig]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[asyncConfig]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[money]] ( AsyncConfig asyncConfig ) { notNull ( [[money]] , AsyncConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , [[money]] , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the async config
--------------------------------------------- Result 247 ---------------------------------------------
Creates an instance of RestAssuredMock from a given mock MvcConfig . --> [[[SKIPPED]]]

[[[[Adv]]]]: public RestAssuredMockMvcConfig mockMvcConfig ( MockMvcConfig mockMvcConfig ) { notNull ( mockMvcConfig , MockMvcConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the MockMVC config
--------------------------------------------- Result 248 ---------------------------------------------
Sets the RestAssured configuration for the given xml config . --> Create a new RestAssignedMockConfig object --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[xmlConfig]] ( XmlConfig [[xmlConfig]] ) { notNull ( [[xmlConfig]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[xmlConfig]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[stennis]] ( XmlConfig [[loge]] ) { notNull ( [[stennis]] , "XmlConfig" ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , [[stennis]] , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the Xml config .
--------------------------------------------- Result 249 ---------------------------------------------
Sets the mock mapper configuration . --> YAM configured with multiple parts . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[multiPartConfig]] ( MultiPartConfig multiPartConfig ) { notNull ( [[multiPartConfig]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[multiPartConfig]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config

[[[[Adv]]]]: public RestAssuredMockMvcConfig [[yasuda]] ( MultiPartConfig multiPartConfig ) { notNull ( [[yasuda]] , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , [[yasuda]] , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the multi - part config
--------------------------------------------- Result 250 ---------------------------------------------
Sets the restured configuration . --> Create a new RestAssuredMockConfig . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[paramConfig]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config

[[[[Adv]]]]: public RestAssuredMockMvcConfig paramConfig ( MockMvcParamConfig [[bells]] ) { notNull ( paramConfig , MultiPartConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the parameter config
--------------------------------------------- Result 251 ---------------------------------------------
Sets the restured matcher configuration . --> Create a new RestAssuredMatcher . --> Socre: 1.0

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[matcherConfig]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config

[[[[Adv]]]]: public RestAssuredMockMvcConfig matcherConfig ( MatcherConfig [[bedtime]] ) { notNull ( matcherConfig , MatcherConfig . class ) ; return new RestAssuredMockMvcConfig ( logConfig , encoderConfig , decoderConfig , sessionConfig , objectMapperConfig , jsonConfig , xmlConfig , headerConfig , asyncConfig , multiPartConfig , mockMvcConfig , paramConfig , matcherConfig ) ; }
[[[[Nl]]]]: Set the matcher config
--------------------------------------------- Result 252 ---------------------------------------------
Declare the XMLPathConfig . --> Create an XmlPathConfig instance --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declareNamespaces]] ( Map < String , String > [[namespacesToDeclare]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[namespacesToDeclare]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .

[[[[Adv]]]]: public XmlPathConfig [[stag]] ( Map < String , String > [[wollen]] ) { return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[wollen]] , properties , validating , namespaceAware , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Specify declared namespaces that will be used when parsing XML .
--------------------------------------------- Result 253 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 240 / 10 / 3 / 253:  25%|██▌       | 253/1000 [1:36:28<4:44:50, 22.88s/it][Succeeded / Failed / Skipped / Total] 240 / 10 / 3 / 253:  25%|██▌       | 254/1000 [1:36:45<4:44:09, 22.85s/it][Succeeded / Failed / Skipped / Total] 241 / 10 / 3 / 254:  25%|██▌       | 254/1000 [1:36:45<4:44:09, 22.85s/it][Succeeded / Failed / Skipped / Total] 241 / 10 / 3 / 254:  26%|██▌       | 255/1000 [1:37:09<4:43:51, 22.86s/it][Succeeded / Failed / Skipped / Total] 242 / 10 / 3 / 255:  26%|██▌       | 255/1000 [1:37:09<4:43:51, 22.86s/it][Succeeded / Failed / Skipped / Total] 242 / 10 / 3 / 255:  26%|██▌       | 256/1000 [1:37:14<4:42:37, 22.79s/it][Succeeded / Failed / Skipped / Total] 243 / 10 / 3 / 256:  26%|██▌       | 256/1000 [1:37:14<4:42:37, 22.79s/it][Succeeded / Failed / Skipped / Total] 243 / 10 / 3 / 256:  26%|██▌       | 257/1000 [1:37:24<4:41:36, 22.74s/it][Succeeded / Failed / Skipped / Total] 244 / 10 / 3 / 257:  26%|██▌       | 257/1000 [1:37:24<4:41:36, 22.74s/it][Succeeded / Failed / Skipped / Total] 244 / 10 / 3 / 257:  26%|██▌       | 258/1000 [1:37:48<4:41:16, 22.74s/it][Succeeded / Failed / Skipped / Total] 245 / 10 / 3 / 258:  26%|██▌       | 258/1000 [1:37:48<4:41:16, 22.74s/it][Succeeded / Failed / Skipped / Total] 245 / 10 / 3 / 258:  26%|██▌       | 259/1000 [1:38:04<4:40:35, 22.72s/it][Succeeded / Failed / Skipped / Total] 246 / 10 / 3 / 259:  26%|██▌       | 259/1000 [1:38:04<4:40:35, 22.72s/it][Succeeded / Failed / Skipped / Total] 246 / 10 / 3 / 259:  26%|██▌       | 260/1000 [1:38:06<4:39:12, 22.64s/it][Succeeded / Failed / Skipped / Total] 247 / 10 / 3 / 260:  26%|██▌       | 260/1000 [1:38:06<4:39:12, 22.64s/it][Succeeded / Failed / Skipped / Total] 247 / 10 / 3 / 260:  26%|██▌       | 261/1000 [1:38:10<4:37:57, 22.57s/it][Succeeded / Failed / Skipped / Total] 248 / 10 / 3 / 261:  26%|██▌       | 261/1000 [1:38:10<4:37:57, 22.57s/it][Succeeded / Failed / Skipped / Total] 248 / 10 / 3 / 261:  26%|██▌       | 262/1000 [1:38:23<4:37:08, 22.53s/it]Configure the proxy for the given URI . --> Perform an impersonation --> Socre: 1.0

[[[[Adv]]]]: public static void [[proxy]] ( URI [[uri]] ) { if ( [[uri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[proxy]] ( new ProxySpecification ( [[uri]] . getHost ( ) , [[uri]] . getPort ( ) , [[uri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .

[[[[Adv]]]]: public static void [[impersonation]] ( URI [[valeri]] ) { if ( [[valeri]] == null ) { throw new IllegalArgumentException ( "Proxy URI cannot be null" ) ; } [[impersonation]] ( new ProxySpecification ( [[valeri]] . getHost ( ) , [[valeri]] . getPort ( ) , [[valeri]] . getScheme ( ) ) ) ; }
[[[[Nl]]]]: Instruct REST Assured to connect to a proxy using a URI .
--------------------------------------------- Result 254 ---------------------------------------------
Issues a HTTP request . --> Send a new invite --> Socre: 1.0

[[[[Adv]]]]: public Object [[request]] ( String [[method]] , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[method]] , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .

[[[[Adv]]]]: public Object [[invites]] ( String [[pleas]] , boolean hasBody , Closure configClosure ) throws ClientProtocolException , IOException { return this . doRequest ( this . defaultURI . toURI ( ) , [[pleas]] , this . defaultContentType , hasBody , configClosure ) ; }
[[[[Nl]]]]: Make an HTTP request to the default URI and parse using the default content - type .
--------------------------------------------- Result 255 ---------------------------------------------
Sets the HTTP request headers . --> zit a map of banners --> Socre: 1.0

[[[[Adv]]]]: public void [[setHeaders]] ( Map < ? , ? > [[headers]] ) { this . [[defaultRequestHeaders]] . clear ( ) ; if ( [[headers]] == null ) return ; for ( Object key : [[headers]] . keySet ( ) ) { Object val = [[headers]] . get ( key ) ; if ( val == null ) continue ; this . [[defaultRequestHeaders]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .

[[[[Adv]]]]: public void [[zaphod]] ( Map < ? , ? > [[banners]] ) { this . [[pissoir]] . clear ( ) ; if ( [[banners]] == null ) return ; for ( Object key : [[banners]] . keySet ( ) ) { Object val = [[banners]] . get ( key ) ; if ( val == null ) continue ; this . [[pissoir]] . put ( key . toString ( ) , val . toString ( ) ) ; } }
[[[[Nl]]]]: Set the default headers to add to all requests made by this builder instance . These values will replace any previously set default headers .
--------------------------------------------- Result 256 ---------------------------------------------
Set the proxy to use . --> Initialize HttpHost --> Socre: 1.0

[[[[Adv]]]]: public void [[setProxy]] ( String [[host]] , int [[port]] , String [[scheme]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[host]] , [[port]] , [[scheme]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .

[[[[Adv]]]]: public void [[haha]] ( String [[organising]] , int [[havana]] , String [[planned]] ) { getClient ( ) . getParams ( ) . setParameter ( ConnRoutePNames . DEFAULT_PROXY , new HttpHost ( [[organising]] , [[havana]] , [[planned]] ) ) ; }
[[[[Nl]]]]: Set the default HTTP proxy to be used for all requests .
--------------------------------------------- Result 257 ---------------------------------------------
Sets the control name . --> Reset detachments --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[controlName]] ( String [[controlName]] ) { Validate . notEmpty ( [[controlName]] , "Control name cannot be empty" ) ; this . controlName = [[controlName]] ; this . [[isControlNameExplicit]] = "[[True]]" == "[[True]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .

[[[[Adv]]]]: public MultiPartSpecBuilder [[resupply]] ( String [[detachments]] ) { Validate . notEmpty ( [[resupply]] , "Control name cannot be empty" ) ; this . controlName = [[resupply]] ; this . [[antonov]] = "[[Dignified]]" == "[[Dignified]]" ; return this ; }
[[[[Nl]]]]: Specify the control name of this multi - part .
--------------------------------------------- Result 258 ---------------------------------------------
Determines the security name for the subject . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private static String [[getSecurityName]] ( final Subject [[subject]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[subject]] ) ; } String [[userSecurityName]] = null ; if ( [[subject]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .

[[[[Adv]]]]: private static String [[fixin]] ( final Subject [[items]] ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Determining Websphere security name for subject " + [[items]] ) ; } String [[sandford]] = null ; if ( [[items]] != null ) {
[[[[Nl]]]]: Get the security name for the given subject .
--------------------------------------------- Result 259 ---------------------------------------------
Sets a multi - part header . --> Specify the logo of the logo --> Socre: 1.0

[[[[Adv]]]]: public MultiPartSpecBuilder [[header]] ( String [[name]] , String [[value]] ) { Validate . notEmpty ( [[name]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[value]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .

[[[[Adv]]]]: public MultiPartSpecBuilder [[logos]] ( String [[godfather]] , String [[assessed]] ) { Validate . notEmpty ( [[godfather]] , "Header name cannot be empty" ) ; Validate . notEmpty ( [[assessed]] , "Header value cannot be empty" ) ;
[[[[Nl]]]]: Add a header to this multipart specification .
--------------------------------------------- Result 260 ---------------------------------------------
Allow all hostnames to be allowed . --> Zwerwer settings --> Socre: 1.0

[[[[Adv]]]]: public CertificateAuthSettings [[allowAllHostnames]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .

[[[[Adv]]]]: public CertificateAuthSettings [[skewer]] ( ) { return new CertificateAuthSettings ( keystoreType , trustStoreType , port , trustStore , keyStore , ALLOW_ALL_HOSTNAME_VERIFIER , sslSocketFactory ) ; }
[[[[Nl]]]]: Configure the CertificateAuthSettings to allow all host names .
--------------------------------------------- Result 261 ---------------------------------------------
Sets credentials . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public void [[basic]] ( String [[host]] , int [[port]] , String [[user]] , String [[pass]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[host]] , [[port]] ) , new UsernamePasswordCredentials ( [[user]] , [[pass]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[pivotal]] ( String [[hosting]] , int [[rico]] , String [[spectators]] , String [[enactment]] ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( [[hosting]] , [[rico]] ) , new UsernamePasswordCredentials ( [[spectators]] , [[enactment]] ) ) ; }
[[[[Nl]]]]: Set authentication credentials to be used for the given host and port .
--------------------------------------------- Result 262 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 249 / 10 / 3 / 262:  26%|██▌       | 262/1000 [1:38:23<4:37:08, 22.53s/it][Succeeded / Failed / Skipped / Total] 249 / 10 / 3 / 262:  26%|██▋       | 263/1000 [1:38:24<4:35:46, 22.45s/it][Succeeded / Failed / Skipped / Total] 250 / 10 / 3 / 263:  26%|██▋       | 263/1000 [1:38:24<4:35:46, 22.45s/it][Succeeded / Failed / Skipped / Total] 250 / 10 / 3 / 263:  26%|██▋       | 264/1000 [1:38:26<4:34:27, 22.37s/it][Succeeded / Failed / Skipped / Total] 250 / 11 / 3 / 264:  26%|██▋       | 264/1000 [1:38:26<4:34:27, 22.37s/it][Succeeded / Failed / Skipped / Total] 250 / 11 / 3 / 264:  26%|██▋       | 265/1000 [1:38:29<4:33:10, 22.30s/it][Succeeded / Failed / Skipped / Total] 251 / 11 / 3 / 265:  26%|██▋       | 265/1000 [1:38:29<4:33:10, 22.30s/it][Succeeded / Failed / Skipped / Total] 251 / 11 / 3 / 265:  27%|██▋       | 266/1000 [1:38:54<4:32:55, 22.31s/it][Succeeded / Failed / Skipped / Total] 252 / 11 / 3 / 266:  27%|██▋       | 266/1000 [1:38:54<4:32:55, 22.31s/it][Succeeded / Failed / Skipped / Total] 252 / 11 / 3 / 266:  27%|██▋       | 267/1000 [1:39:06<4:32:05, 22.27s/it][Succeeded / Failed / Skipped / Total] 253 / 11 / 3 / 267:  27%|██▋       | 267/1000 [1:39:06<4:32:05, 22.27s/it][Succeeded / Failed / Skipped / Total] 253 / 11 / 3 / 267:  27%|██▋       | 268/1000 [1:43:17<4:42:06, 23.12s/it][Succeeded / Failed / Skipped / Total] 254 / 11 / 3 / 268:  27%|██▋       | 268/1000 [1:43:17<4:42:06, 23.12s/it][Succeeded / Failed / Skipped / Total] 254 / 11 / 3 / 268:  27%|██▋       | 269/1000 [1:53:24<5:08:12, 25.30s/it]Creates a new Headers instance with the specified header and additional headers . --> Convenience method for subclasses --> Socre: 1.0

[[[[Adv]]]]: public static Headers headers ( Header [[header]] , Header ... additionalHeaders ) { notNull ( [[header]] , "Header" ) ; final List < Header > [[headerList]] = new LinkedList < Header > ( ) ; [[headerList]] . add ( [[header]] ) ; if ( additionalHeaders != null ) { Collections . addAll ( [[headerList]] , additionalHeaders ) ; } return new Headers ( [[headerList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .

[[[[Adv]]]]: public static Headers headers ( Header [[subtitle]] , Header ... additionalHeaders ) { notNull ( [[subtitle]] , "Header" ) ; final List < Header > [[highborn]] = new LinkedList < Header > ( ) ; [[highborn]] . add ( [[subtitle]] ) ; if ( additionalHeaders != null ) { Collections . addAll ( [[highborn]] , additionalHeaders ) ; } return new Headers ( [[highborn]] ) ; }
[[[[Nl]]]]: An alternative way to create a Headers object from the constructor .
--------------------------------------------- Result 263 ---------------------------------------------
Sets the response header . --> Sets the response headers . --> Socre: 1.0

[[[[Adv]]]]: public ResponseBuilder [[setHeader]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header

[[[[Adv]]]]: public ResponseBuilder [[yachts]] ( String name , String value ) { notNull ( name , "Header name" ) ; notNull ( value , "Header value" ) ; List < Header > newHeaders = new ArrayList < Header > ( restAssuredResponse . headers ( ) . asList ( ) ) ; newHeaders . add ( new Header ( name , value ) ) ; restAssuredResponse . setResponseHeaders ( new Headers ( newHeaders ) ) ; if ( trim ( name ) . equalsIgnoreCase ( CONTENT_TYPE ) ) { restAssuredResponse . setContentType ( value ) ; } return this ; }
[[[[Nl]]]]: Set a specific header
--------------------------------------------- Result 264 ---------------------------------------------
Reset the configuration . --> [[[FAILED]]]

[[[[Adv]]]]: public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .

[[[[Adv]]]]: public static void reset ( ) { mockMvcFactory = null ; config = null ; basePath = "/" ; resultHandlers . clear ( ) ; requestPostProcessors . clear ( ) ; responseSpecification = null ; requestSpecification = null ; authentication = null ; }
[[[[Nl]]]]: Reset all static configurations to their default values .
--------------------------------------------- Result 265 ---------------------------------------------
Build the REST response . --> Performs enhancement . --> Socre: 1.0

[[[[Adv]]]]: public Response [[build]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response

[[[[Adv]]]]: public Response [[enhancement]] ( ) { final int statusCode = restAssuredResponse . statusCode ( ) ; if ( statusCode < 100 || statusCode >= 600 ) { throw new IllegalArgumentException ( format ( "Status code must be greater than 100 and less than 600, was %d." , statusCode ) ) ; } if ( StringUtils . isBlank ( restAssuredResponse . statusLine ( ) ) ) { restAssuredResponse . setStatusLine ( restAssuredResponse . statusCode ( ) ) ; } restAssuredResponse . setRpr ( new ResponseParserRegistrar ( ) ) ; return restAssuredResponse ; }
[[[[Nl]]]]: Build the actual response
--------------------------------------------- Result 266 ---------------------------------------------
Declares a namespace declaration . --> Define an XML path configuration --> Socre: 1.0

[[[[Adv]]]]: public XmlPathConfig [[declaredNamespace]] ( String [[prefix]] , String [[namespaceURI]] ) { Validate . notEmpty ( [[prefix]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[namespaceURI]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[updatedNamespaces]] = new HashMap < String , String > ( declaredNamespaces ) ; [[updatedNamespaces]] . put ( [[prefix]] , [[namespaceURI]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[updatedNamespaces]] , properties , validating , "[[True]]" == "[[True]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .

[[[[Adv]]]]: public XmlPathConfig [[hammers]] ( String [[url]] , String [[physiologist]] ) { Validate . notEmpty ( [[url]] , "Prefix cannot be empty" ) ; Validate . notEmpty ( [[physiologist]] , "Namespace URI cannot be empty" ) ; Map < String , String > [[subatomic]] = new HashMap < String , String > ( declaredNamespaces ) ; [[subatomic]] . put ( [[url]] , [[physiologist]] ) ; return new XmlPathConfig ( jaxbObjectMapperFactory , defaultParserType , defaultDeserializer , charset , features , [[subatomic]] , properties , validating , "[[Right]]" == "[[Right]]" , allowDocTypeDeclaration ) ; }
[[[[Nl]]]]: Declares a namespace .
--------------------------------------------- Result 267 ---------------------------------------------
Sets the NTLM credentials . --> Disconnects from server --> Socre: 1.0

[[[[Adv]]]]: public void [[ntlm]] ( String host , int port , String [[user]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[user]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .

[[[[Adv]]]]: public void [[abstention]] ( String host , int port , String [[diners]] , String pass , String workstation , String domain ) { builder . getClient ( ) . getCredentialsProvider ( ) . setCredentials ( new AuthScope ( host , port ) , new NTCredentials ( [[diners]] , pass , workstation , domain ) ) ; }
[[[[Nl]]]]: Set NTLM authentication credentials to be used for the given host and port .
--------------------------------------------- Result 268 ---------------------------------------------
Matches cookie by property . --> returns a DetectorMatcher that has expired days --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[expiryDate]] ( Matcher < ? super Date > [[expiryDateMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[expiryDateMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[girard]] ( Matcher < ? super Date > [[gothenburg]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "expiryDate" , [[gothenburg]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether expiry date of cookie satisfies specified matcher .
--------------------------------------------- Result 269 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 254 / 12 / 3 / 269:  27%|██▋       | 269/1000 [1:53:24<5:08:12, 25.30s/it][Succeeded / Failed / Skipped / Total] 254 / 12 / 3 / 269:  27%|██▋       | 270/1000 [1:54:03<5:08:22, 25.35s/it][Succeeded / Failed / Skipped / Total] 255 / 12 / 3 / 270:  27%|██▋       | 270/1000 [1:54:03<5:08:22, 25.35s/it][Succeeded / Failed / Skipped / Total] 255 / 12 / 3 / 270:  27%|██▋       | 271/1000 [1:54:25<5:07:49, 25.34s/it][Succeeded / Failed / Skipped / Total] 256 / 12 / 3 / 271:  27%|██▋       | 271/1000 [1:54:25<5:07:49, 25.34s/it][Succeeded / Failed / Skipped / Total] 256 / 12 / 3 / 271:  27%|██▋       | 272/1000 [1:57:47<5:15:15, 25.98s/it][Succeeded / Failed / Skipped / Total] 256 / 13 / 3 / 272:  27%|██▋       | 272/1000 [1:57:47<5:15:15, 25.98s/it][Succeeded / Failed / Skipped / Total] 256 / 13 / 3 / 272:  27%|██▋       | 273/1000 [1:58:07<5:14:35, 25.96s/it][Succeeded / Failed / Skipped / Total] 257 / 13 / 3 / 273:  27%|██▋       | 273/1000 [1:58:07<5:14:35, 25.96s/it][Succeeded / Failed / Skipped / Total] 257 / 13 / 3 / 273:  27%|██▋       | 274/1000 [1:59:23<5:16:20, 26.14s/it][Succeeded / Failed / Skipped / Total] 258 / 13 / 3 / 274:  27%|██▋       | 274/1000 [1:59:23<5:16:20, 26.14s/it][Succeeded / Failed / Skipped / Total] 258 / 13 / 3 / 274:  28%|██▊       | 275/1000 [2:00:06<5:16:38, 26.20s/it][Succeeded / Failed / Skipped / Total] 259 / 13 / 3 / 275:  28%|██▊       | 275/1000 [2:00:06<5:16:38, 26.20s/it][Succeeded / Failed / Skipped / Total] 259 / 13 / 3 / 275:  28%|██▊       | 276/1000 [2:00:34<5:16:17, 26.21s/it][Succeeded / Failed / Skipped / Total] 260 / 13 / 3 / 276:  28%|██▊       | 276/1000 [2:00:34<5:16:17, 26.21s/it][Succeeded / Failed / Skipped / Total] 260 / 13 / 3 / 276:  28%|██▊       | 277/1000 [2:00:55<5:15:37, 26.19s/it][Succeeded / Failed / Skipped / Total] 261 / 13 / 3 / 277:  28%|██▊       | 277/1000 [2:00:55<5:15:37, 26.19s/it][Succeeded / Failed / Skipped / Total] 261 / 13 / 3 / 277:  28%|██▊       | 278/1000 [2:00:55<5:14:03, 26.10s/it][Succeeded / Failed / Skipped / Total] 261 / 13 / 4 / 278:  28%|██▊       | 278/1000 [2:00:55<5:14:03, 26.10s/it][Succeeded / Failed / Skipped / Total] 261 / 13 / 4 / 278:  28%|██▊       | 279/1000 [2:00:57<5:12:35, 26.01s/it][Succeeded / Failed / Skipped / Total] 262 / 13 / 4 / 279:  28%|██▊       | 279/1000 [2:00:57<5:12:35, 26.01s/it][Succeeded / Failed / Skipped / Total] 262 / 13 / 4 / 279:  28%|██▊       | 280/1000 [2:00:58<5:11:05, 25.92s/it]Applies a cookie to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher comment ( Matcher < ? super String > commentMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "comment" , commentMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether comment of cookie satisfies specified matcher .
--------------------------------------------- Result 270 ---------------------------------------------
Matches cookie matcher . --> Convenience method to provide additional cookies --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[value]] ( Matcher < ? super String > [[valueMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[valueMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[worth]] ( Matcher < ? super String > [[bronson]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "value" , [[bronson]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether value of cookie satisfies specified matcher .
--------------------------------------------- Result 271 ---------------------------------------------
Matches cookie matcher . --> Creates a DetectorMatcher based on the given parameters --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[domain]] ( Matcher < ? super String > [[domainMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[domainMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[campos]] ( Matcher < ? super String > [[timmy]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "domain" , [[timmy]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether domain of cookie satisfies specified matcher .
--------------------------------------------- Result 272 ---------------------------------------------
Creates a cookie matcher that matches the given path matcher . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher path ( Matcher < ? super String > pathMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "path" , pathMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether path of cookie satisfies specified matcher .
--------------------------------------------- Result 273 ---------------------------------------------
Applies the max age condition to cookie . --> returns matching cookieMatcher --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[maxAge]] ( Matcher < ? super Integer > [[maxAgeMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[maxAgeMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[tracksuits]] ( Matcher < ? super Integer > [[orrin]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "maxAge" , [[orrin]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether max age of cookie satisfies specified matcher .
--------------------------------------------- Result 274 ---------------------------------------------
Matches HTTP cookie matcher . --> Convenience method to allow the cookies to be tested --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[httpOnly]] ( Matcher < ? super Boolean > [[httpOnlyMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[httpOnlyMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[wristband]] ( Matcher < ? super Boolean > [[shaul]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "httpOnly" , [[shaul]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether http - only property of cookie satisfies specified matcher .
--------------------------------------------- Result 275 ---------------------------------------------
Expect a header with a given expected value . --> Sets backport for backportlets --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , Matcher < String > [[expectedValueMatcher]] ) { spec . header ( [[headerName]] , [[expectedValueMatcher]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .

[[[[Adv]]]]: public ResponseSpecBuilder [[backseat]] ( String [[platelets]] , Matcher < String > [[riverboats]] ) { spec . header ( [[platelets]] , [[riverboats]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied header name and hamcrest matcher .
--------------------------------------------- Result 276 ---------------------------------------------
Creates a cookieMatcher that matches the version of the cookie . --> Shortcut for testing --> Socre: 1.0

[[[[Adv]]]]: public DetailedCookieMatcher [[version]] ( Matcher < ? super Integer > [[versionMatcher]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[versionMatcher]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher [[stride]] ( Matcher < ? super Integer > [[inhumane]] ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "version" , [[inhumane]] ) ) ) ; }
[[[[Nl]]]]: Verifies whether version of cookie satisfies specified matcher .
--------------------------------------------- Result 277 ---------------------------------------------
Expect a cookie to be expected value . --> Set cookies --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectCookie]] ( String [[cookieName]] , String [[expectedValue]] ) { spec . cookie ( [[cookieName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[characters]] ( String [[palenque]] , String [[dirtying]] ) { spec . cookie ( [[palenque]] , [[dirtying]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response cookie matches the supplied name and value .
--------------------------------------------- Result 278 ---------------------------------------------
Default value for NumberPath --> [[[SKIPPED]]]

[[[[Adv]]]]: public JsonPathConfig numberReturnType ( NumberReturnType numberReturnType ) { return new JsonPathConfig ( numberReturnType , defaultParserType , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Specifies if JsonPath should use floats and doubles or BigDecimals to represent Json numbers .
--------------------------------------------- Result 279 ---------------------------------------------
Sets the default parser . --> Config --> Socre: 1.0

[[[[Adv]]]]: public JsonPathConfig [[defaultParserType]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[defaultParserType]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .

[[[[Adv]]]]: public JsonPathConfig [[topics]] ( JsonParserType defaultParserType ) { return new JsonPathConfig ( numberReturnType , [[topics]] , gsonObjectMapperFactory , jackson1ObjectMapperFactory , jackson2ObjectMapperFactory , johnzonObjectMapperFactory , defaultDeserializer , charset ) ; }
[[[[Nl]]]]: Creates an json path configuration that uses the specified parser type as default .
[Succeeded / Failed / Skipped / Total] 263 / 13 / 4 / 280:  28%|██▊       | 280/1000 [2:00:58<5:11:05, 25.92s/it][Succeeded / Failed / Skipped / Total] 263 / 13 / 4 / 280:  28%|██▊       | 281/1000 [2:01:01<5:09:41, 25.84s/it][Succeeded / Failed / Skipped / Total] 264 / 13 / 4 / 281:  28%|██▊       | 281/1000 [2:01:01<5:09:41, 25.84s/it][Succeeded / Failed / Skipped / Total] 264 / 13 / 4 / 281:  28%|██▊       | 282/1000 [2:01:04<5:08:17, 25.76s/it][Succeeded / Failed / Skipped / Total] 265 / 13 / 4 / 282:  28%|██▊       | 282/1000 [2:01:04<5:08:17, 25.76s/it][Succeeded / Failed / Skipped / Total] 265 / 13 / 4 / 282:  28%|██▊       | 283/1000 [2:01:07<5:06:51, 25.68s/it][Succeeded / Failed / Skipped / Total] 266 / 13 / 4 / 283:  28%|██▊       | 283/1000 [2:01:07<5:06:51, 25.68s/it][Succeeded / Failed / Skipped / Total] 266 / 13 / 4 / 283:  28%|██▊       | 284/1000 [2:01:08<5:05:25, 25.59s/it][Succeeded / Failed / Skipped / Total] 267 / 13 / 4 / 284:  28%|██▊       | 284/1000 [2:01:08<5:05:25, 25.59s/it][Succeeded / Failed / Skipped / Total] 267 / 13 / 4 / 284:  28%|██▊       | 285/1000 [2:01:18<5:04:19, 25.54s/it][Succeeded / Failed / Skipped / Total] 268 / 13 / 4 / 285:  28%|██▊       | 285/1000 [2:01:18<5:04:19, 25.54s/it][Succeeded / Failed / Skipped / Total] 268 / 13 / 4 / 285:  29%|██▊       | 286/1000 [2:01:19<5:02:53, 25.45s/it][Succeeded / Failed / Skipped / Total] 269 / 13 / 4 / 286:  29%|██▊       | 286/1000 [2:01:19<5:02:53, 25.45s/it][Succeeded / Failed / Skipped / Total] 269 / 13 / 4 / 286:  29%|██▊       | 287/1000 [2:01:24<5:01:37, 25.38s/it][Succeeded / Failed / Skipped / Total] 270 / 13 / 4 / 287:  29%|██▊       | 287/1000 [2:01:24<5:01:37, 25.38s/it][Succeeded / Failed / Skipped / Total] 270 / 13 / 4 / 287:  29%|██▉       | 288/1000 [2:02:32<5:02:56, 25.53s/it][Succeeded / Failed / Skipped / Total] 271 / 13 / 4 / 288:  29%|██▉       | 288/1000 [2:02:32<5:02:56, 25.53s/it][Succeeded / Failed / Skipped / Total] 271 / 13 / 4 / 288:  29%|██▉       | 289/1000 [2:03:10<5:03:01, 25.57s/it][Succeeded / Failed / Skipped / Total] 272 / 13 / 4 / 289:  29%|██▉       | 289/1000 [2:03:10<5:03:01, 25.57s/it][Succeeded / Failed / Skipped / Total] 272 / 13 / 4 / 289:  29%|██▉       | 290/1000 [2:03:14<5:01:44, 25.50s/it]--------------------------------------------- Result 280 ---------------------------------------------
Sets the default logging . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[defaultStream]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[True]]" == "[[True]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .

[[[[Adv]]]]: public LogConfig [[tianjin]] ( PrintStream printStream ) { return new LogConfig ( printStream , "[[Velma]]" == "[[Velma]]" , logDetailIfValidationFails , urlEncodeRequestUri , "[[Velma]]" == "[[Velma]]" ) ; }
[[[[Nl]]]]: Specify a new default stream to the print to .
--------------------------------------------- Result 281 ---------------------------------------------
Enable logging of request and response --> Obtains a new LogConfig instance --> Socre: 1.0

[[[[Adv]]]]: public LogConfig [[enableLoggingOfRequestAndResponseIfValidationFails]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail

[[[[Adv]]]]: public LogConfig [[bobbi]] ( LogDetail logDetail ) { return new LogConfig ( defaultPrintStream , prettyPrintingEnabled , logDetail , urlEncodeRequestUri , "[[Reality]]" == "[[Reality]]" ) ; }
[[[[Nl]]]]: Enable logging of both the request and the response if REST Assureds test validation fails with the specified log detail
--------------------------------------------- Result 282 ---------------------------------------------
Creates an HttpRequestBase based on the given HTTP method and type . --> Create an HttpRequestBase --> Socre: 1.0

[[[[Adv]]]]: static HttpRequestBase [[createHttpRequest]] ( URI uri , String [[httpMethod]] , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( [[httpMethod]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[httpRequest]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .

[[[[Adv]]]]: static HttpRequestBase [[implanting]] ( URI uri , String [[horsemanship]] , boolean hasBody ) { String method = notNull ( upperCase ( trimToNull ( [[horsemanship]] ) ) , "Http method" ) ; Class < ? extends HttpRequestBase > type = HTTP_METHOD_TO_HTTP_REQUEST_TYPE . get ( method ) ; final HttpRequestBase [[throbbing]] ;
[[[[Nl]]]]: Get the HttpRequest class that represents this request type .
--------------------------------------------- Result 283 ---------------------------------------------
Default configuration . --> returns a new configuration for the account --> Socre: 1.0

[[[[Adv]]]]: public MultiPartConfig [[defaultBoundary]] ( String [[defaultBoundary]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[defaultBoundary]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .

[[[[Adv]]]]: public MultiPartConfig [[account]] ( String [[wagstaff]] ) { return new MultiPartConfig ( defaultControlName , defaultFileName , defaultSubtype , [[account]] , defaultCharset , "True" == "True" ) ; }
[[[[Nl]]]]: Specify an explicit default multipart boundary to use when sending multi - part data .
--------------------------------------------- Result 284 ---------------------------------------------
Adds an attribute to the request . --> Perform dry - work only . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addAttribute]] ( String [[attributeName]] , Object attributeValue ) { spec . attribute ( [[attributeName]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[dryland]] ( String [[dustman]] , Object attributeValue ) { spec . attribute ( [[dustman]] , attributeValue ) ; return this ; }
[[[[Nl]]]]: Add request attribute
--------------------------------------------- Result 285 ---------------------------------------------
Adds a header to the request . --> Whitelighter . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addHeader]] ( String [[headerName]] , String [[headerValue]] ) { spec . header ( [[headerName]] , [[headerValue]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[whitelaw]] ( String [[finalise]] , String [[functionality]] ) { spec . header ( [[finalise]] , [[functionality]] ) ; return this ; }
[[[[Nl]]]]: Add a header to be sent with the request
--------------------------------------------- Result 286 ---------------------------------------------
Returns a proxy specification with the specified host name . --> Specifies a gomer specification for Gomer --> Socre: 1.0

[[[[Adv]]]]: public ProxySpecification [[withHost]] ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .

[[[[Adv]]]]: public ProxySpecification [[gomer]] ( String host ) { return new ProxySpecification ( host , port , scheme , username , password ) ; }
[[[[Nl]]]]: Specify the hostname of the proxy .
--------------------------------------------- Result 287 ---------------------------------------------
Add additional result handlers . --> Sets the barkeep results . --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addResultHandlers]] ( ResultHandler [[resultHandler]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[resultHandler]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[barkeep]] ( ResultHandler [[mathilda]] , ResultHandler ... additionalResultHandlers ) { spec . resultHandlers ( [[mathilda]] , additionalResultHandlers ) ; return this ; }
[[[[Nl]]]]: Add a result handler
--------------------------------------------- Result 288 ---------------------------------------------
Adds a multi - part request . --> Set an EDX specification --> Socre: 1.0

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[addMultiPart]] ( String [[controlName]] , String [[contentBody]] , String [[mimeType]] ) { spec . multiPart ( [[controlName]] , [[mimeType]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .

[[[[Adv]]]]: public MockMvcRequestSpecBuilder [[edification]] ( String [[mondays]] , String [[untiring]] , String [[doux]] ) { spec . multiPart ( [[mondays]] , [[doux]] ) ; return this ; }
[[[[Nl]]]]: Specify a string to send to the server using multi - part form data with a specific mime - type .
--------------------------------------------- Result 289 ---------------------------------------------
Adds the given http client parameters . --> Zonk client configuration --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[addParams]] ( Map < String , ? > [[httpClientParams]] ) { notNull ( [[httpClientParams]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . [[httpClientParams]] ) ; newParams . putAll ( [[httpClientParams]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .

[[[[Adv]]]]: public HttpClientConfig [[zonk]] ( Map < String , ? > [[flawless]] ) { notNull ( [[flawless]] , "httpClientParams" ) ; final Map < String , Object > newParams = new HashMap < String , Object > ( this . [[spyder]] ) ; newParams . putAll ( [[flawless]] ) ; return new HttpClientConfig ( httpClientFactory , newParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Add the given parameters to an already configured number of parameters .
[Succeeded / Failed / Skipped / Total] 273 / 13 / 4 / 290:  29%|██▉       | 290/1000 [2:03:14<5:01:44, 25.50s/it][Succeeded / Failed / Skipped / Total] 273 / 13 / 4 / 290:  29%|██▉       | 291/1000 [2:03:19<5:00:28, 25.43s/it][Succeeded / Failed / Skipped / Total] 274 / 13 / 4 / 291:  29%|██▉       | 291/1000 [2:03:19<5:00:28, 25.43s/it][Succeeded / Failed / Skipped / Total] 274 / 13 / 4 / 291:  29%|██▉       | 292/1000 [2:03:20<4:59:02, 25.34s/it][Succeeded / Failed / Skipped / Total] 275 / 13 / 4 / 292:  29%|██▉       | 292/1000 [2:03:20<4:59:02, 25.34s/it][Succeeded / Failed / Skipped / Total] 275 / 13 / 4 / 292:  29%|██▉       | 293/1000 [2:03:23<4:57:45, 25.27s/it][Succeeded / Failed / Skipped / Total] 276 / 13 / 4 / 293:  29%|██▉       | 293/1000 [2:03:23<4:57:45, 25.27s/it][Succeeded / Failed / Skipped / Total] 276 / 13 / 4 / 293:  29%|██▉       | 294/1000 [2:03:24<4:56:21, 25.19s/it][Succeeded / Failed / Skipped / Total] 277 / 13 / 4 / 294:  29%|██▉       | 294/1000 [2:03:24<4:56:21, 25.19s/it][Succeeded / Failed / Skipped / Total] 277 / 13 / 4 / 294:  30%|██▉       | 295/1000 [2:03:25<4:54:57, 25.10s/it][Succeeded / Failed / Skipped / Total] 278 / 13 / 4 / 295:  30%|██▉       | 295/1000 [2:03:25<4:54:57, 25.10s/it][Succeeded / Failed / Skipped / Total] 278 / 13 / 4 / 295:  30%|██▉       | 296/1000 [2:03:26<4:53:36, 25.02s/it][Succeeded / Failed / Skipped / Total] 279 / 13 / 4 / 296:  30%|██▉       | 296/1000 [2:03:26<4:53:36, 25.02s/it][Succeeded / Failed / Skipped / Total] 279 / 13 / 4 / 296:  30%|██▉       | 297/1000 [2:03:38<4:52:40, 24.98s/it][Succeeded / Failed / Skipped / Total] 280 / 13 / 4 / 297:  30%|██▉       | 297/1000 [2:03:38<4:52:40, 24.98s/it][Succeeded / Failed / Skipped / Total] 280 / 13 / 4 / 297:  30%|██▉       | 298/1000 [2:03:39<4:51:17, 24.90s/it][Succeeded / Failed / Skipped / Total] 281 / 13 / 4 / 298:  30%|██▉       | 298/1000 [2:03:39<4:51:17, 24.90s/it][Succeeded / Failed / Skipped / Total] 281 / 13 / 4 / 298:  30%|██▉       | 299/1000 [2:03:42<4:50:02, 24.83s/it][Succeeded / Failed / Skipped / Total] 282 / 13 / 4 / 299:  30%|██▉       | 299/1000 [2:03:42<4:50:02, 24.83s/it][Succeeded / Failed / Skipped / Total] 282 / 13 / 4 / 299:  30%|███       | 300/1000 [2:03:50<4:48:57, 24.77s/it][Succeeded / Failed / Skipped / Total] 283 / 13 / 4 / 300:  30%|███       | 300/1000 [2:03:50<4:48:57, 24.77s/it][Succeeded / Failed / Skipped / Total] 283 / 13 / 4 / 300:  30%|███       | 301/1000 [2:04:11<4:48:25, 24.76s/it]--------------------------------------------- Result 290 ---------------------------------------------
Sets a parameter with the specified parameter . --> Convenience method for setting parameters --> Socre: 1.0

[[[[Adv]]]]: public < T > [[HttpClientConfig]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[newParams]] = new HashMap < String , Object > ( httpClientParams ) ; [[newParams]] . put ( parameterName , parameterValue ) ; return new [[HttpClientConfig]] ( httpClientFactory , [[newParams]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[True]]" == "[[True]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .

[[[[Adv]]]]: public < T > [[predates]] setParam ( String parameterName , T parameterValue ) { notNull ( parameterName , "Parameter name" ) ; final Map < String , Object > [[torino]] = new HashMap < String , Object > ( httpClientParams ) ; [[torino]] . put ( parameterName , parameterValue ) ; return new [[predates]] ( httpClientFactory , [[torino]] , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "[[Accurate]]" == "[[Accurate]]" ) ; }
[[[[Nl]]]]: Set a http client parameter .
--------------------------------------------- Result 291 ---------------------------------------------
Configures the HTTP Multipart mode . --> Configure polygon config --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig [[httpMultipartMode]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[httpMultipartMode]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .

[[[[Adv]]]]: public HttpClientConfig [[polythene]] ( HttpMultipartMode httpMultipartMode ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , [[polythene]] , shouldReuseHttpClientInstance , httpClient , "True" == "True" ) ; }
[[[[Nl]]]]: Specify the HTTP Multipart mode when sending multi - part data .
--------------------------------------------- Result 292 ---------------------------------------------
Expect a header to be expected . --> Add qazi --> Socre: 1.0

[[[[Adv]]]]: public ResponseSpecBuilder [[expectHeader]] ( String [[headerName]] , String [[expectedValue]] ) { spec . header ( [[headerName]] , [[expectedValue]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .

[[[[Adv]]]]: public ResponseSpecBuilder [[qazi]] ( String [[peritonitis]] , String [[apathy]] ) { spec . header ( [[peritonitis]] , [[apathy]] ) ; return this ; }
[[[[Nl]]]]: Expect that a response header matches the supplied name and value .
--------------------------------------------- Result 293 ---------------------------------------------
Gets int . --> Convenience method for Venezuelan --> Socre: 1.0

[[[[Adv]]]]: public int [[getInt]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .

[[[[Adv]]]]: public int [[venezuelan]] ( String [[routed]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as an int .
--------------------------------------------- Result 294 ---------------------------------------------
Gets a value . --> Permanently retries --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] get ( String path ) { final JSONAssertion [[jsonAssertion]] = createJsonAssertion ( path , params ) ; final Object [[json]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[T]] ) [[jsonAssertion]] . getResult ( [[json]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .

[[[[Adv]]]]: public < [[tonnes]] > [[tonnes]] get ( String path ) { final JSONAssertion [[seaplane]] = createJsonAssertion ( path , params ) ; final Object [[bruce]] = jsonParser . parseWith ( createConfigurableJsonSlurper ( ) ) ; return ( [[tonnes]] ) [[seaplane]] . getResult ( [[bruce]] , null ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a boolean .
--------------------------------------------- Result 295 ---------------------------------------------
Gets byte . --> Caine for caine --> Socre: 1.0

[[[[Adv]]]]: public byte [[getByte]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .

[[[[Adv]]]]: public byte [[caine]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a byte .
--------------------------------------------- Result 296 ---------------------------------------------
Get short . --> Ould --> Socre: 1.0

[[[[Adv]]]]: public short [[getShort]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .

[[[[Adv]]]]: public short [[ould]] ( String path ) {
[[[[Nl]]]]: Get the result of an Object path expression as a short .
--------------------------------------------- Result 297 ---------------------------------------------
Configure the HttpClientFactory --> Configure HttpClientFactory --> Socre: 1.0

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[httpClientFactory]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .

[[[[Adv]]]]: public HttpClientConfig httpClientFactory ( HttpClientFactory [[stav]] ) { return new HttpClientConfig ( httpClientFactory , httpClientParams , httpMultipartMode , shouldReuseHttpClientInstance , NO_HTTP_CLIENT , "True" == "True" ) ; }
[[[[Nl]]]]: Set the http client factory that Rest Assured should use when making request . For each request REST Assured will invoke the factory to get the a the HttpClient instance .
--------------------------------------------- Result 298 ---------------------------------------------
Get a double . --> This method returns sukiy price --> Socre: 1.0

[[[[Adv]]]]: public double [[getDouble]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ; if ( [[value]] instanceof Double ) { return ( Double ) [[value]] ; } return ObjectConverter . convertObjectTo ( [[value]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .

[[[[Adv]]]]: public double [[sukiyaki]] ( String [[tract]] ) { final Object [[valuation]] = get ( [[tract]] ) ; if ( [[valuation]] instanceof Double ) { return ( Double ) [[valuation]] ; } return ObjectConverter . convertObjectTo ( [[valuation]] , Double . class ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a double .
--------------------------------------------- Result 299 ---------------------------------------------
Gets long . --> Touchy once --> Socre: 1.0

[[[[Adv]]]]: public long [[getLong]] ( String [[path]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .

[[[[Adv]]]]: public long [[touchy]] ( String [[circuits]] ) {
[[[[Nl]]]]: Get the result of an Object path expression as a long .
--------------------------------------------- Result 300 ---------------------------------------------
Get a float value . --> Returns yol at given trail --> Socre: 1.0

[[[[Adv]]]]: public float [[getFloat]] ( String [[path]] ) { final Object [[value]] = get ( [[path]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .

[[[[Adv]]]]: public float [[yoli]] ( String [[trail]] ) { final Object [[deserving]] = get ( [[trail]] ) ;
[[[[Nl]]]]: Get the result of an Object path expression as a float .
--------------------------------------------- Result 301 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 284 / 13 / 4 / 301:  30%|███       | 301/1000 [2:04:11<4:48:25, 24.76s/it][Succeeded / Failed / Skipped / Total] 284 / 13 / 4 / 301:  30%|███       | 302/1000 [2:04:34<4:47:55, 24.75s/it][Succeeded / Failed / Skipped / Total] 285 / 13 / 4 / 302:  30%|███       | 302/1000 [2:04:34<4:47:55, 24.75s/it][Succeeded / Failed / Skipped / Total] 285 / 13 / 4 / 302:  30%|███       | 303/1000 [2:05:04<4:47:42, 24.77s/it][Succeeded / Failed / Skipped / Total] 286 / 13 / 4 / 303:  30%|███       | 303/1000 [2:05:04<4:47:42, 24.77s/it][Succeeded / Failed / Skipped / Total] 286 / 13 / 4 / 303:  30%|███       | 304/1000 [2:05:28<4:47:16, 24.77s/it][Succeeded / Failed / Skipped / Total] 287 / 13 / 4 / 304:  30%|███       | 304/1000 [2:05:28<4:47:16, 24.77s/it][Succeeded / Failed / Skipped / Total] 287 / 13 / 4 / 304:  30%|███       | 305/1000 [2:05:33<4:46:05, 24.70s/it][Succeeded / Failed / Skipped / Total] 288 / 13 / 4 / 305:  30%|███       | 305/1000 [2:05:33<4:46:05, 24.70s/it][Succeeded / Failed / Skipped / Total] 288 / 13 / 4 / 305:  31%|███       | 306/1000 [2:06:03<4:45:53, 24.72s/it][Succeeded / Failed / Skipped / Total] 289 / 13 / 4 / 306:  31%|███       | 306/1000 [2:06:03<4:45:53, 24.72s/it][Succeeded / Failed / Skipped / Total] 289 / 13 / 4 / 306:  31%|███       | 307/1000 [2:06:34<4:45:44, 24.74s/it][Succeeded / Failed / Skipped / Total] 290 / 13 / 4 / 307:  31%|███       | 307/1000 [2:06:34<4:45:44, 24.74s/it][Succeeded / Failed / Skipped / Total] 290 / 13 / 4 / 307:  31%|███       | 308/1000 [2:06:41<4:44:39, 24.68s/it][Succeeded / Failed / Skipped / Total] 291 / 13 / 4 / 308:  31%|███       | 308/1000 [2:06:41<4:44:39, 24.68s/it][Succeeded / Failed / Skipped / Total] 291 / 13 / 4 / 308:  31%|███       | 309/1000 [2:06:48<4:43:35, 24.62s/it][Succeeded / Failed / Skipped / Total] 292 / 13 / 4 / 309:  31%|███       | 309/1000 [2:06:48<4:43:35, 24.62s/it][Succeeded / Failed / Skipped / Total] 292 / 13 / 4 / 309:  31%|███       | 310/1000 [2:06:49<4:42:17, 24.55s/it]Gets a map . --> Fetling cache --> Socre: 1.0

[[[[Adv]]]]: public < [[K]] , V > Map < [[K]] , V > [[getMap]] ( String [[path]] ) { return get ( [[path]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .

[[[[Adv]]]]: public < [[phosphorus]] , V > Map < [[phosphorus]] , V > [[fouling]] ( String [[rails]] ) { return get ( [[rails]] ) ; }
[[[[Nl]]]]: Get the result of an Object path expression as a map .
--------------------------------------------- Result 302 ---------------------------------------------
Sets the body of the request . --> Liefert ee ein der aufe einer ein der aebergeben --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[setBody]] ( Object [[object]] , ObjectMapper [[mapper]] ) { spec . body ( [[object]] , [[mapper]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .

[[[[Adv]]]]: public RequestSpecBuilder [[dachshund]] ( Object [[goods]] , ObjectMapper [[borka]] ) { spec . body ( [[goods]] , [[borka]] ) ; return this ; }
[[[[Nl]]]]: Specify an Object request content that will automatically be serialized to JSON or XML and sent with the request using a specific object mapper . This works for the POST PATCH and PUT methods only . Trying to do this for the other http methods will cause an exception to be thrown .
--------------------------------------------- Result 303 ---------------------------------------------
Gets the value of the specified path as object . --> Gets the artwork from the path --> Socre: 1.0

[[[[Adv]]]]: public < [[T]] > [[T]] getObject ( String path , Class < [[T]] > objectType ) { Object [[object]] = getFromPath ( path , "[[False]]" != "[[False]]" ) ; return getObjectAsType ( [[object]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .

[[[[Adv]]]]: public < [[millions]] > [[millions]] getObject ( String path , Class < [[millions]] > objectType ) { Object [[artifacts]] = getFromPath ( path , "[[Fakes]]" != "[[Fakes]]" ) ; return getObjectAsType ( [[artifacts]] , objectType ) ; }
[[[[Nl]]]]: Get an XML document as a Java Object .
--------------------------------------------- Result 304 ---------------------------------------------
Add a parameter . --> Adds additional parameters --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Object ... parameterValues ) { spec . param ( [[parameterName]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[panels]] ( String [[herbalist]] , Object ... parameterValues ) { spec . param ( [[herbalist]] , parameterValues ) ; return this ; }
[[[[Nl]]]]: Add a parameter to be sent with the request .
--------------------------------------------- Result 305 ---------------------------------------------
Adds a parameter to the request specification . --> Set transparency --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addParam]] ( String [[parameterName]] , Collection < ? > [[parameterValues]] ) { spec . param ( [[parameterName]] , [[parameterValues]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[transparency]] ( String [[ironhide]] , Collection < ? > [[bianca]] ) { spec . param ( [[ironhide]] , [[bianca]] ) ; return this ; }
[[[[Nl]]]]: Add a multi - value parameter to be sent with the request .
--------------------------------------------- Result 306 ---------------------------------------------
Retrieves a list of values mapped to the specified type . --> Convenience method for pay phone number --> Socre: 1.0

[[[[Adv]]]]: public < T > List < T > [[getList]] ( String [[path]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[path]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .

[[[[Adv]]]]: public < T > List < T > [[payphone]] ( String [[trail]] , Class < T > genericType ) { if ( genericType == null ) { throw new IllegalArgumentException ( "Generic type cannot be null" ) ; } final List < T > original = get ( [[trail]] ) ; final List < T > newList = new LinkedList < T > ( ) ; if ( original != null ) { for ( T t : original ) { T e ; if ( t instanceof Map && ! genericType . isAssignableFrom ( Map . class ) ) {
[[[[Nl]]]]: Get the result of an Object path expression as a list .
--------------------------------------------- Result 307 ---------------------------------------------
Create a custom update strategy . --> Landless ConfigConfig Implementation --> Socre: 1.0

[[[[Adv]]]]: public MockMvcParamConfig [[formParamsUpdateStrategy]] ( UpdateStrategy [[updateStrategy]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[updateStrategy]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .

[[[[Adv]]]]: public MockMvcParamConfig [[landless]] ( UpdateStrategy [[succour]] ) { return new MockMvcParamConfig ( queryParamsUpdateStrategy , [[succour]] , requestParameterUpdateStrategy , attributeUpdateStrategy , sessionUpdateStrategy , "True" == "True" ) ; }
[[[[Nl]]]]: Set form parameter update strategy to the given value .
--------------------------------------------- Result 308 ---------------------------------------------
Writes the response to the given stream . --> Utility method to print response to output stream --> Socre: 1.0

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[stream]] , Matcher < Integer > [[matcher]] ) { return new ResponseLoggingFilter ( [[stream]] , [[matcher]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .

[[[[Adv]]]]: public static Filter logResponseToIfMatches ( PrintStream [[currents]] , Matcher < Integer > [[rumoured]] ) { return new ResponseLoggingFilter ( [[currents]] , [[rumoured]] ) ; }
[[[[Nl]]]]: Create a new logging filter without using the new operator . Will make the DSL look nicer .
--------------------------------------------- Result 309 ---------------------------------------------
Clean up data from the backing map . --> helper to barcode --> Socre: 1.0

[[[[Adv]]]]: private void [[cleanUpForCollectedState]] ( Set < KeyAndSource > [[keysAndSources]] ) { synchronized ( lock ) { for ( KeyAndSource [[keyAndSource]] : [[keysAndSources]] ) { Multiset < Object > set = backingMap . get ( [[keyAndSource]] . key ) ; if ( set != null ) { set . remove ( [[keyAndSource]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[keyAndSource]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .

[[[[Adv]]]]: private void [[barbell]] ( Set < KeyAndSource > [[settlin]] ) { synchronized ( lock ) { for ( KeyAndSource [[pard]] : [[settlin]] ) { Multiset < Object > set = backingMap . get ( [[pard]] . key ) ; if ( set != null ) { set . remove ( [[pard]] . source ) ; if ( set . isEmpty ( ) ) { backingMap . remove ( [[pard]] . key ) ; } } } } }
[[[[Nl]]]]: There may be multiple child injectors blacklisting a certain key so only remove the source that s relevant .
--------------------------------------------- Result 310 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 293 / 13 / 4 / 310:  31%|███       | 310/1000 [2:06:49<4:42:17, 24.55s/it][Succeeded / Failed / Skipped / Total] 293 / 13 / 4 / 310:  31%|███       | 311/1000 [2:06:51<4:41:02, 24.47s/it][Succeeded / Failed / Skipped / Total] 294 / 13 / 4 / 311:  31%|███       | 311/1000 [2:06:51<4:41:02, 24.47s/it][Succeeded / Failed / Skipped / Total] 294 / 13 / 4 / 311:  31%|███       | 312/1000 [2:06:56<4:39:54, 24.41s/it][Succeeded / Failed / Skipped / Total] 295 / 13 / 4 / 312:  31%|███       | 312/1000 [2:06:56<4:39:54, 24.41s/it][Succeeded / Failed / Skipped / Total] 295 / 13 / 4 / 312:  31%|███▏      | 313/1000 [2:07:05<4:38:58, 24.36s/it][Succeeded / Failed / Skipped / Total] 296 / 13 / 4 / 313:  31%|███▏      | 313/1000 [2:07:05<4:38:58, 24.36s/it][Succeeded / Failed / Skipped / Total] 296 / 13 / 4 / 313:  31%|███▏      | 314/1000 [2:07:24<4:38:20, 24.35s/it][Succeeded / Failed / Skipped / Total] 297 / 13 / 4 / 314:  31%|███▏      | 314/1000 [2:07:24<4:38:20, 24.35s/it][Succeeded / Failed / Skipped / Total] 297 / 13 / 4 / 314:  32%|███▏      | 315/1000 [2:07:48<4:37:55, 24.34s/it][Succeeded / Failed / Skipped / Total] 298 / 13 / 4 / 315:  32%|███▏      | 315/1000 [2:07:48<4:37:55, 24.34s/it][Succeeded / Failed / Skipped / Total] 298 / 13 / 4 / 315:  32%|███▏      | 316/1000 [2:07:52<4:36:48, 24.28s/it][Succeeded / Failed / Skipped / Total] 299 / 13 / 4 / 316:  32%|███▏      | 316/1000 [2:07:52<4:36:48, 24.28s/it][Succeeded / Failed / Skipped / Total] 299 / 13 / 4 / 316:  32%|███▏      | 317/1000 [2:09:15<4:38:29, 24.47s/it][Succeeded / Failed / Skipped / Total] 300 / 13 / 4 / 317:  32%|███▏      | 317/1000 [2:09:15<4:38:29, 24.47s/it][Succeeded / Failed / Skipped / Total] 300 / 13 / 4 / 317:  32%|███▏      | 318/1000 [2:09:35<4:37:54, 24.45s/it]Adds additional cookies to the request . --> Convenience factory method --> Socre: 1.0

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[cookie]] , Cookie ... [[additionalCookies]] ) { AssertParameter . notNull ( [[cookie]] , "Cookie" ) ; final List < Cookie > [[cookieList]] = new LinkedList < Cookie > ( ) ; [[cookieList]] . add ( [[cookie]] ) ; Collections . addAll ( [[cookieList]] , [[additionalCookies]] ) ; return new Cookies ( [[cookieList]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .

[[[[Adv]]]]: public static Cookies cookies ( Cookie [[quiche]] , Cookie ... [[boilerplate]] ) { AssertParameter . notNull ( [[quiche]] , "Cookie" ) ; final List < Cookie > [[montauk]] = new LinkedList < Cookie > ( ) ; [[montauk]] . add ( [[quiche]] ) ; Collections . addAll ( [[montauk]] , [[boilerplate]] ) ; return new Cookies ( [[montauk]] ) ; }
[[[[Nl]]]]: An alternative way to create a Cookies object from the constructor .
--------------------------------------------- Result 311 ---------------------------------------------
Convert a constant string to a constant binding . --> Factory method for BindingImpl --> Socre: 1.0

[[[[Adv]]]]: private < T > BindingImpl < T > [[convertConstantStringBinding]] ( Key < T > key , Errors [[errors]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .

[[[[Adv]]]]: private < T > BindingImpl < T > [[brokers]] ( Key < T > key , Errors [[faults]] ) throws ErrorsException {
[[[[Nl]]]]: Converts a constant string binding to the required type .
--------------------------------------------- Result 312 ---------------------------------------------
Adds a cookie to the request . --> Setting rostov --> Socre: 1.0

[[[[Adv]]]]: public RequestSpecBuilder [[addCookie]] ( String [[key]] , Object [[value]] , Object ... [[cookieNameValuePairs]] ) { spec . cookie ( [[key]] , [[value]] , [[cookieNameValuePairs]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .

[[[[Adv]]]]: public RequestSpecBuilder [[rostov]] ( String [[main]] , Object [[evaluated]] , Object ... [[ailment]] ) { spec . cookie ( [[main]] , [[evaluated]] , [[ailment]] ) ; return this ; }
[[[[Nl]]]]: Add a cookie to be sent with the request .
--------------------------------------------- Result 313 ---------------------------------------------
Remove a failed binding . --> Removes a given InjectionPoint --> Socre: 1.0

[[[[Adv]]]]: private void [[removeFailedJitBinding]] ( Binding < ? > [[binding]] , InjectionPoint [[ip]] ) { failedJitBindings . add ( [[binding]] . getKey ( ) ) ; jitBindings . remove ( [[binding]] . getKey ( ) ) ; membersInjectorStore . remove ( [[binding]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[binding]] ) ; if ( [[ip]] != null ) { constructors . remove ( [[ip]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .

[[[[Adv]]]]: private void [[jinkies]] ( Binding < ? > [[fasten]] , InjectionPoint [[pi]] ) { failedJitBindings . add ( [[fasten]] . getKey ( ) ) ; jitBindings . remove ( [[fasten]] . getKey ( ) ) ; membersInjectorStore . remove ( [[fasten]] . getKey ( ) . getTypeLiteral ( ) ) ; provisionListenerStore . remove ( [[fasten]] ) ; if ( [[pi]] != null ) { constructors . remove ( [[pi]] ) ; } }
[[[[Nl]]]]: Cleans up any state that may have been cached when constructing the JIT binding .
--------------------------------------------- Result 314 ---------------------------------------------
Index bindings . --> Update the locator context --> Socre: 1.0

[[[[Adv]]]]: void [[index]] ( ) { for ( Binding < ? > [[binding]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[binding]] . getKey ( ) . getTypeLiteral ( ) , [[binding]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .

[[[[Adv]]]]: void [[locator]] ( ) { for ( Binding < ? > [[liaisons]] : state . getExplicitBindingsThisLevel ( ) . values ( ) ) { bindingsMultimap . put ( [[liaisons]] . getKey ( ) . getTypeLiteral ( ) , [[liaisons]] ) ; } }
[[[[Nl]]]]: Indexes bindings by type .
--------------------------------------------- Result 315 ---------------------------------------------
Returns the internal dependencies of the given binding . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[getInternalDependencies]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) private Set < Dependency < ? > > [[fixated]] ( BindingImpl < ? > binding ) { if ( binding instanceof ConstructorBindingImpl ) { return ( ( ConstructorBindingImpl ) binding ) . getInternalDependencies ( ) ; } else if ( binding instanceof HasDependencies ) { return ( ( HasDependencies ) binding ) . getDependencies ( ) ; } else { return ImmutableSet . of ( ) ; } }
[[[[Nl]]]]: Safely gets the dependencies of possibly not initialized bindings .
--------------------------------------------- Result 316 ---------------------------------------------
Gets all parameters . --> Create the spindler --> Socre: 1.0

[[[[Adv]]]]: static Object [ ] [[getAll]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .

[[[[Adv]]]]: static Object [ ] [[spindler]] ( InternalContext context , SingleParameterInjector < ? > [ ] parameterInjectors ) throws InternalProvisionException { if ( parameterInjectors == null ) { return NO_ARGUMENTS ; } int size = parameterInjectors . length ; Object [ ] parameters = new Object [ size ] ;
[[[[Nl]]]]: Returns an array of parameter values .
--------------------------------------------- Result 317 ---------------------------------------------
Binds the given injector . --> This method will be called only once perjector --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindInjector]] ( InjectorImpl [[injector]] ) { Key < Injector > [[key]] = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[injector]] ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Injector > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .

[[[[Adv]]]]: private static void [[skippy]] ( InjectorImpl [[aeroplanes]] ) { Key < Injector > [[vital]] = Key . get ( Injector . class ) ; InjectorFactory injectorFactory = new InjectorFactory ( [[aeroplanes]] ) ; [[aeroplanes]] . state . putBinding ( [[vital]] , new ProviderInstanceBindingImpl < Injector > ( [[aeroplanes]] , [[vital]] , SourceProvider . UNKNOWN_SOURCE , injectorFactory , Scoping . UNSCOPED , injectorFactory , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Injector is a special case because we allow both parent and child injectors to both have a binding for that key .
--------------------------------------------- Result 318 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 301 / 13 / 4 / 318:  32%|███▏      | 318/1000 [2:09:35<4:37:54, 24.45s/it][Succeeded / Failed / Skipped / Total] 301 / 13 / 4 / 318:  32%|███▏      | 319/1000 [2:09:48<4:37:06, 24.42s/it][Succeeded / Failed / Skipped / Total] 301 / 14 / 4 / 319:  32%|███▏      | 319/1000 [2:09:48<4:37:06, 24.42s/it][Succeeded / Failed / Skipped / Total] 301 / 14 / 4 / 319:  32%|███▏      | 320/1000 [2:09:52<4:35:59, 24.35s/it][Succeeded / Failed / Skipped / Total] 302 / 14 / 4 / 320:  32%|███▏      | 320/1000 [2:09:52<4:35:59, 24.35s/it][Succeeded / Failed / Skipped / Total] 302 / 14 / 4 / 320:  32%|███▏      | 321/1000 [2:09:54<4:34:46, 24.28s/it][Succeeded / Failed / Skipped / Total] 303 / 14 / 4 / 321:  32%|███▏      | 321/1000 [2:09:54<4:34:46, 24.28s/it][Succeeded / Failed / Skipped / Total] 303 / 14 / 4 / 321:  32%|███▏      | 322/1000 [2:10:05<4:33:55, 24.24s/it][Succeeded / Failed / Skipped / Total] 304 / 14 / 4 / 322:  32%|███▏      | 322/1000 [2:10:05<4:33:55, 24.24s/it][Succeeded / Failed / Skipped / Total] 304 / 14 / 4 / 322:  32%|███▏      | 323/1000 [2:10:09<4:32:48, 24.18s/it][Succeeded / Failed / Skipped / Total] 305 / 14 / 4 / 323:  32%|███▏      | 323/1000 [2:10:09<4:32:48, 24.18s/it][Succeeded / Failed / Skipped / Total] 305 / 14 / 4 / 323:  32%|███▏      | 324/1000 [2:10:24<4:32:04, 24.15s/it][Succeeded / Failed / Skipped / Total] 306 / 14 / 4 / 324:  32%|███▏      | 324/1000 [2:10:24<4:32:04, 24.15s/it][Succeeded / Failed / Skipped / Total] 306 / 14 / 4 / 324:  32%|███▎      | 325/1000 [2:10:27<4:30:56, 24.08s/it][Succeeded / Failed / Skipped / Total] 307 / 14 / 4 / 325:  32%|███▎      | 325/1000 [2:10:27<4:30:56, 24.08s/it][Succeeded / Failed / Skipped / Total] 307 / 14 / 4 / 325:  33%|███▎      | 326/1000 [2:10:34<4:29:57, 24.03s/it]Binds Logger . --> Register heartbeats for logging purposes --> Socre: 1.0

[[[[Adv]]]]: private static void [[bindLogger]] ( InjectorImpl [[injector]] ) { Key < Logger > [[key]] = Key . get ( Logger . class ) ; LoggerFactory [[loggerFactory]] = new LoggerFactory ( ) ; [[injector]] . state . putBinding ( [[key]] , new ProviderInstanceBindingImpl < Logger > ( [[injector]] , [[key]] , SourceProvider . UNKNOWN_SOURCE , [[loggerFactory]] , Scoping . UNSCOPED , [[loggerFactory]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .

[[[[Adv]]]]: private static void [[heartthrob]] ( InjectorImpl [[jet]] ) { Key < Logger > [[principal]] = Key . get ( Logger . class ) ; LoggerFactory [[mylar]] = new LoggerFactory ( ) ; [[jet]] . state . putBinding ( [[principal]] , new ProviderInstanceBindingImpl < Logger > ( [[jet]] , [[principal]] , SourceProvider . UNKNOWN_SOURCE , [[mylar]] , Scoping . UNSCOPED , [[mylar]] , ImmutableSet . < InjectionPoint > of ( ) ) ) ; }
[[[[Nl]]]]: The Logger is a special case because it knows the injection point of the injected member . It s the only binding that does this .
--------------------------------------------- Result 319 ---------------------------------------------
Applies a secured cookie matcher to the cookie . --> [[[FAILED]]]

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .

[[[[Adv]]]]: public DetailedCookieMatcher secured ( Matcher < ? super Boolean > securedMatcher ) { return new DetailedCookieMatcher ( and ( Matchers . hasProperty ( "secured" , securedMatcher ) ) ) ; }
[[[[Nl]]]]: Verifies whether secured property of cookie satisfies specified matcher .
--------------------------------------------- Result 320 ---------------------------------------------
Returns true if there are no binding annotations found . --> Handles branching --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[checkForMisplacedBindingAnnotations]] ( Member [[member]] , Errors [[errors]] ) { Annotation [[misplacedBindingAnnotation]] = Annotations . findBindingAnnotation ( [[errors]] , [[member]] , ( ( AnnotatedElement ) [[member]] ) . getAnnotations ( ) ) ; if ( [[misplacedBindingAnnotation]] == null ) { return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .

[[[[Adv]]]]: private static boolean [[branching]] ( Member [[colleague]] , Errors [[mistaken]] ) { Annotation [[donatello]] = Annotations . findBindingAnnotation ( [[mistaken]] , [[colleague]] , ( ( AnnotatedElement ) [[colleague]] ) . getAnnotations ( ) ) ; if ( [[donatello]] == null ) { return "[[Imposter]]" != "[[Imposter]]" ; }
[[[[Nl]]]]: Returns true if the binding annotation is in the wrong place .
--------------------------------------------- Result 321 ---------------------------------------------
Determines whether the specified methods are overridden . --> Compare two methods --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[overrides]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .

[[[[Adv]]]]: private static boolean [[pearson]] ( Method a , Method b ) {
[[[[Nl]]]]: Returns true if a overrides b . Assumes signatures of a and b are the same and a s declaring class is a subclass of b s declaring class .
--------------------------------------------- Result 322 ---------------------------------------------
Cleans up the internal dependencies . --> looks for potential injection point --> Socre: 1.0

[[[[Adv]]]]: private boolean [[cleanup]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > [[deps]] = getInternalDependencies ( binding ) ; for ( Dependency [[dep]] : [[deps]] ) { Key < ? > [[depKey]] = [[dep]] . getKey ( ) ; InjectionPoint [[ip]] = [[dep]] . getInjectionPoint ( ) ; if ( encountered . add ( [[depKey]] ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .

[[[[Adv]]]]: private boolean [[laundering]] ( BindingImpl < ? > binding , Set < Key > encountered ) { boolean bindingFailed = "False" != "False" ; Set < Dependency < ? > > [[herpes]] = getInternalDependencies ( binding ) ; for ( Dependency [[cpr]] : [[herpes]] ) { Key < ? > [[romulans]] = [[cpr]] . getKey ( ) ; InjectionPoint [[magpies]] = [[cpr]] . getInjectionPoint ( ) ; if ( encountered . add ( [[romulans]] ) ) {
[[[[Nl]]]]: Iterates through the binding s dependencies to clean up any stray bindings that were leftover from a failed JIT binding . This is required because the bindings are eagerly & optimistically added to allow circular dependency support so dependencies may pass where they should have failed .
--------------------------------------------- Result 323 ---------------------------------------------
The type of the provider . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[providerType]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) final TypeLiteral < Provider < T > > [[pisser]] ( ) {
[[[[Nl]]]]: Gets the type of this type s provider .
--------------------------------------------- Result 324 ---------------------------------------------
Returns a TypeLiteral representing the given key literal . --> Convenience method to return the busquet --> Socre: 1.0

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[canonicalizeForKey]] ( TypeLiteral < T > [[typeLiteral]] ) { Type [[type]] = [[typeLiteral]] . getType ( ) ; if ( ! isFullySpecified ( [[type]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[typeLiteral]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[parameterizedType]] = ( ParameterizedType ) [[type]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .

[[[[Adv]]]]: public static < T > TypeLiteral < T > [[bouquet]] ( TypeLiteral < T > [[merchandise]] ) { Type [[model]] = [[merchandise]] . getType ( ) ; if ( ! isFullySpecified ( [[model]] ) ) { Errors errors = new Errors ( ) . keyNotFullySpecified ( [[merchandise]] ) ; throw new ConfigurationException ( errors . getMessages ( ) ) ; } if ( [[merchandise]] . getRawType ( ) == javax . inject . Provider . class ) { ParameterizedType [[neena]] = ( ParameterizedType ) [[model]] ;
[[[[Nl]]]]: Returns an type that s appropriate for use in a key .
--------------------------------------------- Result 325 ---------------------------------------------
Prepare built - in converters . --> Injects Guice in the injector --> Socre: 1.0

[[[[Adv]]]]: static void [[prepareBuiltInConverters]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .

[[[[Adv]]]]: static void [[guzzling]] ( InjectorImpl injector ) {
[[[[Nl]]]]: Installs default converters for primitives enums and class literals .
--------------------------------------------- Result 326 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 308 / 14 / 4 / 326:  33%|███▎      | 326/1000 [2:10:34<4:29:57, 24.03s/it][Succeeded / Failed / Skipped / Total] 308 / 14 / 4 / 326:  33%|███▎      | 327/1000 [2:10:59<4:29:36, 24.04s/it][Succeeded / Failed / Skipped / Total] 309 / 14 / 4 / 327:  33%|███▎      | 327/1000 [2:10:59<4:29:36, 24.04s/it][Succeeded / Failed / Skipped / Total] 309 / 14 / 4 / 327:  33%|███▎      | 328/1000 [2:11:06<4:28:36, 23.98s/it][Succeeded / Failed / Skipped / Total] 310 / 14 / 4 / 328:  33%|███▎      | 328/1000 [2:11:06<4:28:36, 23.98s/it][Succeeded / Failed / Skipped / Total] 310 / 14 / 4 / 328:  33%|███▎      | 329/1000 [2:11:13<4:27:37, 23.93s/it][Succeeded / Failed / Skipped / Total] 311 / 14 / 4 / 329:  33%|███▎      | 329/1000 [2:11:13<4:27:37, 23.93s/it][Succeeded / Failed / Skipped / Total] 311 / 14 / 4 / 329:  33%|███▎      | 330/1000 [2:13:30<4:31:03, 24.27s/it][Succeeded / Failed / Skipped / Total] 312 / 14 / 4 / 330:  33%|███▎      | 330/1000 [2:13:30<4:31:03, 24.27s/it][Succeeded / Failed / Skipped / Total] 312 / 14 / 4 / 330:  33%|███▎      | 331/1000 [2:18:10<4:39:15, 25.05s/it][Succeeded / Failed / Skipped / Total] 313 / 14 / 4 / 331:  33%|███▎      | 331/1000 [2:18:10<4:39:15, 25.05s/it][Succeeded / Failed / Skipped / Total] 313 / 14 / 4 / 331:  33%|███▎      | 332/1000 [2:18:36<4:38:54, 25.05s/it][Succeeded / Failed / Skipped / Total] 314 / 14 / 4 / 332:  33%|███▎      | 332/1000 [2:18:36<4:38:54, 25.05s/it][Succeeded / Failed / Skipped / Total] 314 / 14 / 4 / 332:  33%|███▎      | 333/1000 [2:19:02<4:38:30, 25.05s/it]Resolves all types in the given array of types . --> For backward compatibility only --> Socre: 1.0

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[resolveAll]] ( Type [ ] [[types]] ) { TypeLiteral < ? > [ ] [[result]] = new TypeLiteral < ? > [ [[types]] . length ] ; for ( int [[t]] = 0 ; [[t]] < [[types]] . length ; [[t]] ++ ) { [[result]] [ [[t]] ] = resolve ( [[types]] [ [[t]] ] ) ; } return ImmutableList . copyOf ( [[result]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .

[[[[Adv]]]]: private List < TypeLiteral < ? > > [[wallop]] ( Type [ ] [[guy]] ) { TypeLiteral < ? > [ ] [[fruits]] = new TypeLiteral < ? > [ [[guy]] . length ] ; for ( int [[k]] = 0 ; [[k]] < [[guy]] . length ; [[k]] ++ ) { [[fruits]] [ [[k]] ] = resolve ( [[guy]] [ [[k]] ] ) ; } return ImmutableList . copyOf ( [[fruits]] ) ; }
[[[[Nl]]]]: Returns an immutable list of the resolved types .
--------------------------------------------- Result 327 ---------------------------------------------
Converts the given class loader to the system class loader . --> migrated by truffles --> Socre: 1.0

[[[[Adv]]]]: private static ClassLoader [[canonicalize]] ( ClassLoader [[classLoader]] ) { return [[classLoader]] != null ? [[classLoader]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .

[[[[Adv]]]]: private static ClassLoader [[migra]] ( ClassLoader [[truffles]] ) { return [[truffles]] != null ? [[truffles]] : SystemBridgeHolder . SYSTEM_BRIDGE . getParent ( ) ; }
[[[[Nl]]]]: Attempts to canonicalize null references to the system class loader . May return null if for some reason the system loader is unavailable .
--------------------------------------------- Result 328 ---------------------------------------------
Checks if the given member is public or not . --> is public callable --> Socre: 1.0

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[member]] ) { if ( ! Modifier . isPublic ( [[member]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[parameterTypes]] ; if ( [[member]] instanceof Constructor ) { [[parameterTypes]] = ( ( Constructor ) [[member]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[member]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[parameterTypes]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[parameterTypes]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .

[[[[Adv]]]]: private static boolean isPubliclyCallable ( Member [[parliament]] ) { if ( ! Modifier . isPublic ( [[parliament]] . getModifiers ( ) ) ) { return "False" != "False" ; } Class < ? > [ ] [[macneil]] ; if ( [[parliament]] instanceof Constructor ) { [[macneil]] = ( ( Constructor ) [[parliament]] ) . getParameterTypes ( ) ; } else { Method method = ( Method ) [[parliament]] ; if ( ! Modifier . isPublic ( method . getReturnType ( ) . getModifiers ( ) ) ) { return "False" != "False" ; } [[macneil]] = method . getParameterTypes ( ) ; } for ( Class < ? > type : [[macneil]] ) { if ( ! Modifier . isPublic ( type . getModifiers ( ) ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: Returns true if the member can be called by a fast class generated in a different classloader .
--------------------------------------------- Result 329 ---------------------------------------------
Fixes annotations . --> documentation inherited from superclass --> Socre: 1.0

[[[[Adv]]]]: public Key < ? > [[fixAnnotations]] ( Key < ? > [[key]] ) { return [[key]] . getAnnotation ( ) == null ? [[key]] : Key . get ( [[key]] . getTypeLiteral ( ) , [[key]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .

[[[[Adv]]]]: public Key < ? > [[fertilised]] ( Key < ? > [[transcendent]] ) { return [[transcendent]] . getAnnotation ( ) == null ? [[transcendent]] : Key . get ( [[transcendent]] . getTypeLiteral ( ) , [[transcendent]] . getAnnotation ( ) . annotationType ( ) ) ; }
[[[[Nl]]]]: Replace annotation instances with annotation types this is only appropriate for testing if a key is bound and not for injecting .
--------------------------------------------- Result 330 ---------------------------------------------
Checks if the class has the same version of the given class loader . --> Determine whether a class loader is proceded --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasSameVersionOfCglib]] ( ClassLoader [[classLoader]] ) { Class < ? > [[fc]] = net . sf . cglib . reflect . FastClass . class ; try { return [[classLoader]] . loadClass ( [[fc]] . getName ( ) ) == [[fc]] ; } catch ( ClassNotFoundException e ) { return "[[False]]" != "[[False]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .

[[[[Adv]]]]: private static boolean [[prostituted]] ( ClassLoader [[duvalle]] ) { Class < ? > [[livorno]] = net . sf . cglib . reflect . FastClass . class ; try { return [[duvalle]] . loadClass ( [[livorno]] . getName ( ) ) == [[livorno]] ; } catch ( ClassNotFoundException e ) { return "[[Doctored]]" != "[[Doctored]]" ; } }
[[[[Nl]]]]: Returns true if the types classloader has the same version of cglib that BytecodeGen has . This only returns false in strange OSGI situations but it prevents us from using FastClass for non public members .
--------------------------------------------- Result 331 ---------------------------------------------
Initializes the delegate . --> Set delegation for this member --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( MembersInjector < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .

[[[[Adv]]]]: public void [[ouf]] ( MembersInjector < T > [[commissioners]] ) { checkState ( this . [[deputation]] == null , "delegate already initialized" ) ; this . [[deputation]] = checkNotNull ( [[commissioners]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual members injector .
--------------------------------------------- Result 332 ---------------------------------------------
Create a new instance of the class . --> Create a tap from peptide --> Socre: 1.0

[[[[Adv]]]]: public T [[newInstance]] ( Object [ ] [[args]] ) throws Throwable { constructor . setAccessible ( "[[True]]" == "[[True]]" ) ; try { return constructor . newInstance ( [[args]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .

[[[[Adv]]]]: public T [[tapping]] ( Object [ ] [[peptide]] ) throws Throwable { constructor . setAccessible ( "[[Precise]]" == "[[Precise]]" ) ; try { return constructor . newInstance ( [[peptide]] ) ; } catch ( InvocationTargetException e ) { throw e . getCause ( ) ; } }
[[[[Nl]]]]: Returns an instance of T constructed using this constructor with the supplied arguments .
--------------------------------------------- Result 333 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 315 / 14 / 4 / 333:  33%|███▎      | 333/1000 [2:19:02<4:38:30, 25.05s/it][Succeeded / Failed / Skipped / Total] 315 / 14 / 4 / 333:  33%|███▎      | 334/1000 [2:19:53<4:38:57, 25.13s/it][Succeeded / Failed / Skipped / Total] 316 / 14 / 4 / 334:  33%|███▎      | 334/1000 [2:19:53<4:38:57, 25.13s/it][Succeeded / Failed / Skipped / Total] 316 / 14 / 4 / 334:  34%|███▎      | 335/1000 [2:20:07<4:38:09, 25.10s/it][Succeeded / Failed / Skipped / Total] 317 / 14 / 4 / 335:  34%|███▎      | 335/1000 [2:20:07<4:38:09, 25.10s/it][Succeeded / Failed / Skipped / Total] 317 / 14 / 4 / 335:  34%|███▎      | 336/1000 [2:20:09<4:36:58, 25.03s/it][Succeeded / Failed / Skipped / Total] 318 / 14 / 4 / 336:  34%|███▎      | 336/1000 [2:20:09<4:36:58, 25.03s/it][Succeeded / Failed / Skipped / Total] 318 / 14 / 4 / 336:  34%|███▎      | 337/1000 [2:20:22<4:36:09, 24.99s/it][Succeeded / Failed / Skipped / Total] 318 / 15 / 4 / 337:  34%|███▎      | 337/1000 [2:20:22<4:36:09, 24.99s/it][Succeeded / Failed / Skipped / Total] 318 / 15 / 4 / 337:  34%|███▍      | 338/1000 [2:20:28<4:35:08, 24.94s/it][Succeeded / Failed / Skipped / Total] 318 / 16 / 4 / 338:  34%|███▍      | 338/1000 [2:20:28<4:35:08, 24.94s/it][Succeeded / Failed / Skipped / Total] 318 / 16 / 4 / 338:  34%|███▍      | 339/1000 [2:20:35<4:34:07, 24.88s/it][Succeeded / Failed / Skipped / Total] 319 / 16 / 4 / 339:  34%|███▍      | 339/1000 [2:20:35<4:34:07, 24.88s/it][Succeeded / Failed / Skipped / Total] 319 / 16 / 4 / 339:  34%|███▍      | 340/1000 [2:21:36<4:34:54, 24.99s/it]Override this method . --> Override ServletRequest --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[servletRequest]] , final ManagedServletPipeline [[servletPipeline]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .

[[[[Adv]]]]: @ SuppressWarnings ( { "JavaDoc" , "deprecation" } ) private ServletRequest withDispatcher ( ServletRequest [[achmed]] , final ManagedServletPipeline [[cocos]] ) {
[[[[Nl]]]]: Used to create an proxy that dispatches either to the guice - servlet pipeline or the regular pipeline based on uri - path match . This proxy also provides minimal forwarding support .
--------------------------------------------- Result 334 ---------------------------------------------
Returns the scope for the given scope . --> region ScopeFactory --> Socre: 1.0

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[key]] , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[scoping]] ) { if ( [[scoping]] . isNoScope ( ) ) { return creator ; } Scope scope = [[scoping]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .

[[[[Adv]]]]: static < T > InternalFactory < ? extends T > scope ( Key < T > [[keys]] , InjectorImpl injector , InternalFactory < ? extends T > creator , Object source , Scoping [[counseling]] ) { if ( [[counseling]] . isNoScope ( ) ) { return creator ; } Scope scope = [[counseling]] . getScopeInstance ( ) ;
[[[[Nl]]]]: Scopes an internal factory .
--------------------------------------------- Result 335 ---------------------------------------------
Validates the initial injectables . --> Called by derived injector --> Socre: 1.0

[[[[Adv]]]]: void [[validateOustandingInjections]] ( Errors [[errors]] ) { validationStarted = "[[True]]" == "[[True]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[reference]] : pendingInjections ) { try { [[reference]] . validate ( [[errors]] ) ; } catch ( ErrorsException e ) { [[errors]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .

[[[[Adv]]]]: void [[qa]] ( Errors [[deficiencies]] ) { validationStarted = "[[Decent]]" == "[[Decent]]" ; initializablesCache . clear ( ) ; for ( InjectableReference < ? > [[query]] : pendingInjections ) { try { [[query]] . validate ( [[deficiencies]] ) ; } catch ( ErrorsException e ) { [[deficiencies]] . merge ( e . getErrors ( ) ) ; } } }
[[[[Nl]]]]: Prepares member injectors for all injected instances . This prompts Guice to do static analysis on the injected instances .
--------------------------------------------- Result 336 ---------------------------------------------
Normalize the given path . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: static String [[normalizePath]] ( String [[path]] ) { StringBuilder [[sb]] = new StringBuilder ( [[path]] . length ( ) ) ; int queryStart = [[path]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[path]] . substring ( queryStart ) ; [[path]] = [[path]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .

[[[[Adv]]]]: static String [[refrigeration]] ( String [[arteries]] ) { StringBuilder [[td]] = new StringBuilder ( [[arteries]] . length ( ) ) ; int queryStart = [[arteries]] . indexOf ( ' ' ) ; String query = null ; if ( queryStart != - 1 ) { query = [[arteries]] . substring ( queryStart ) ; [[arteries]] = [[arteries]] . substring ( 0 , queryStart ) ; }
[[[[Nl]]]]: Normalizes a path by unescaping all safe percent encoded characters .
--------------------------------------------- Result 337 ---------------------------------------------
Request an initializer for the specified injection point . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .

[[[[Adv]]]]: < T > Initializable < T > requestInjection ( InjectorImpl injector , T instance , Binding < T > binding , Object source , Set < InjectionPoint > injectionPoints ) { checkNotNull ( source ) ; Preconditions . checkState ( ! validationStarted , "Member injection could not be requested after validation is started" ) ; ProvisionListenerStackCallback < T > provisionCallback = binding == null ? null : injector . provisionListenerStore . get ( binding ) ;
[[[[Nl]]]]: Registers an instance for member injection when that step is performed .
--------------------------------------------- Result 338 ---------------------------------------------
Generates an annotation for the given type . --> [[[FAILED]]]

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .

[[[[Adv]]]]: public static < T extends Annotation > T generateAnnotation ( Class < T > annotationType ) { Preconditions . checkState ( isAllDefaultMethods ( annotationType ) , "%s is not all default methods" , annotationType ) ; return ( T ) cache . getUnchecked ( annotationType ) ; }
[[[[Nl]]]]: Generates an Annotation for the annotation class . Requires that the annotation is all optionals .
--------------------------------------------- Result 339 ---------------------------------------------
Find scope annotation . --> find scope annotations --> Socre: 1.0

[[[[Adv]]]]: public static Class < ? extends Annotation > [[findScopeAnnotation]] ( Errors [[errors]] , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[annotation]] : annotations ) { Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[errors]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .

[[[[Adv]]]]: public static Class < ? extends Annotation > [[passageway]] ( Errors [[foibles]] , Annotation [ ] annotations ) { Class < ? extends Annotation > found = null ; for ( Annotation [[bennet]] : annotations ) { Class < ? extends Annotation > annotationType = [[bennet]] . annotationType ( ) ; if ( isScopeAnnotation ( annotationType ) ) { if ( found != null ) { [[foibles]] . duplicateScopeAnnotations ( found , annotationType ) ; } else { found = annotationType ; } } } return found ; }
[[[[Nl]]]]: Returns the scoping annotation or null if there isn t one .
--------------------------------------------- Result 340 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 320 / 16 / 4 / 340:  34%|███▍      | 340/1000 [2:21:36<4:34:54, 24.99s/it][Succeeded / Failed / Skipped / Total] 320 / 16 / 4 / 340:  34%|███▍      | 341/1000 [2:21:48<4:34:03, 24.95s/it][Succeeded / Failed / Skipped / Total] 321 / 16 / 4 / 341:  34%|███▍      | 341/1000 [2:21:48<4:34:03, 24.95s/it][Succeeded / Failed / Skipped / Total] 321 / 16 / 4 / 341:  34%|███▍      | 342/1000 [2:22:05<4:33:22, 24.93s/it][Succeeded / Failed / Skipped / Total] 322 / 16 / 4 / 342:  34%|███▍      | 342/1000 [2:22:05<4:33:22, 24.93s/it][Succeeded / Failed / Skipped / Total] 322 / 16 / 4 / 342:  34%|███▍      | 343/1000 [2:22:15<4:32:29, 24.88s/it][Succeeded / Failed / Skipped / Total] 323 / 16 / 4 / 343:  34%|███▍      | 343/1000 [2:22:15<4:32:29, 24.88s/it][Succeeded / Failed / Skipped / Total] 323 / 16 / 4 / 343:  34%|███▍      | 344/1000 [2:22:23<4:31:32, 24.84s/it][Succeeded / Failed / Skipped / Total] 324 / 16 / 4 / 344:  34%|███▍      | 344/1000 [2:22:23<4:31:32, 24.84s/it][Succeeded / Failed / Skipped / Total] 324 / 16 / 4 / 344:  34%|███▍      | 345/1000 [2:22:30<4:30:33, 24.78s/it][Succeeded / Failed / Skipped / Total] 325 / 16 / 4 / 345:  34%|███▍      | 345/1000 [2:22:30<4:30:33, 24.78s/it][Succeeded / Failed / Skipped / Total] 325 / 16 / 4 / 345:  35%|███▍      | 346/1000 [2:22:37<4:29:35, 24.73s/it]Checks if retention at runtime . --> judge retention policy --> Socre: 1.0

[[[[Adv]]]]: public static boolean [[isRetainedAtRuntime]] ( Class < ? extends Annotation > [[annotationType]] ) { Retention [[retention]] = [[annotationType]] . getAnnotation ( Retention . class ) ; return [[retention]] != null && [[retention]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .

[[[[Adv]]]]: public static boolean [[seoul]] ( Class < ? extends Annotation > [[cel]] ) { Retention [[keep]] = [[cel]] . getAnnotation ( Retention . class ) ; return [[keep]] != null && [[keep]] . value ( ) == RetentionPolicy . RUNTIME ; }
[[[[Nl]]]]: Returns true if the given annotation is retained at runtime .
--------------------------------------------- Result 341 ---------------------------------------------
Returns the name of the given key . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: public static String [[nameOf]] ( Key < ? > [[key]] ) { Annotation [[annotation]] = [[key]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[key]] . getAnnotationType ( ) ; if ( [[annotation]] != null && ! isMarker ( annotationType ) ) { return [[key]] . getAnnotation ( ) . toString ( ) ; } else if ( [[key]] . getAnnotationType ( ) != null ) { return "@" + [[key]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .

[[[[Adv]]]]: public static String [[chernobyl]] ( Key < ? > [[paramount]] ) { Annotation [[absentee]] = [[paramount]] . getAnnotation ( ) ; Class < ? extends Annotation > annotationType = [[paramount]] . getAnnotationType ( ) ; if ( [[absentee]] != null && ! isMarker ( annotationType ) ) { return [[paramount]] . getAnnotation ( ) . toString ( ) ; } else if ( [[paramount]] . getAnnotationType ( ) != null ) { return "@" + [[paramount]] . getAnnotationType ( ) . getName ( ) ; } else { return "" ; } }
[[[[Nl]]]]: Returns the name the binding should use . This is based on the annotation . If the annotation has an instance and is not a marker annotation we ask the annotation for its toString . If it was a marker annotation or just an annotation type we use the annotation s name . Otherwise the name is the empty string .
--------------------------------------------- Result 342 ---------------------------------------------
Make an injectable . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: static Scoping [[makeInjectable]] ( Scoping [[scoping]] , InjectorImpl [[injector]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[scoping]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[scoping]] ; } ScopeBinding scope = [[injector]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .

[[[[Adv]]]]: static Scoping [[vica]] ( Scoping [[reconnaissance]] , InjectorImpl [[buzzard]] , Errors errors ) { Class < ? extends Annotation > scopeAnnotation = [[reconnaissance]] . getScopeAnnotation ( ) ; if ( scopeAnnotation == null ) { return [[reconnaissance]] ; } ScopeBinding scope = [[buzzard]] . state . getScopeBinding ( scopeAnnotation ) ; if ( scope != null ) { return forInstance ( scope . getScope ( ) ) ; } errors . scopeNotFound ( scopeAnnotation ) ; return UNSCOPED ; }
[[[[Nl]]]]: Replaces annotation scopes with instance scopes using the Injector s annotation - to - instance map . If the scope annotation has no corresponding instance an error will be added and unscoped will be retuned .
--------------------------------------------- Result 343 ---------------------------------------------
Adds the direct type binding to the explicit binding . --> Binds the icicles --> Socre: 1.0

[[[[Adv]]]]: private void [[addDirectTypeBinding]] ( Binder [[binder]] ) { [[binder]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .

[[[[Adv]]]]: private void [[icicles]] ( Binder [[pocketbook]] ) { [[pocketbook]] . bind ( bindingSelection . getDirectKey ( ) ) . toProvider ( new RealDirectTypeProvider < T > ( bindingSelection ) ) ; }
[[[[Nl]]]]: Adds a binding for T . Multiple calls to this are safe and will be collapsed as duplicate bindings .
--------------------------------------------- Result 344 ---------------------------------------------
Retrieve a constructor from the cache . --> Recreates ConstructorInjectionInjectionException --> Socre: 1.0

[[[[Adv]]]]: public ConstructorInjector < ? > [[get]] ( InjectionPoint [[constructorInjector]] , Errors [[errors]] ) throws ErrorsException { return cache . get ( [[constructorInjector]] , [[errors]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .

[[[[Adv]]]]: public ConstructorInjector < ? > [[recieve]] ( InjectionPoint [[kimo]] , Errors [[inadequacies]] ) throws ErrorsException { return cache . get ( [[kimo]] , [[inadequacies]] ) ; }
[[[[Nl]]]]: Returns a new complete constructor injector with injection listeners registered .
--------------------------------------------- Result 345 ---------------------------------------------
Checks whether interceptor has scope annotation . --> Determine whether or not --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasScope]] ( Class < ? extends Interceptor > [[interceptorClass]] ) { for ( Annotation annotation : [[interceptorClass]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .

[[[[Adv]]]]: private static boolean [[butler]] ( Class < ? extends Interceptor > [[birds]] ) { for ( Annotation annotation : [[birds]] . getAnnotations ( ) ) { if ( Annotations . isScopeAnnotation ( annotation . annotationType ( ) ) ) { return "True" == "True" ; } } return "False" != "False" ; }
[[[[Nl]]]]: Returns true if the given class has a scope annotation .
--------------------------------------------- Result 346 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 326 / 16 / 4 / 346:  35%|███▍      | 346/1000 [2:22:37<4:29:35, 24.73s/it][Succeeded / Failed / Skipped / Total] 326 / 16 / 4 / 346:  35%|███▍      | 347/1000 [2:22:54<4:28:56, 24.71s/it][Succeeded / Failed / Skipped / Total] 327 / 16 / 4 / 347:  35%|███▍      | 347/1000 [2:22:54<4:28:56, 24.71s/it][Succeeded / Failed / Skipped / Total] 327 / 16 / 4 / 347:  35%|███▍      | 348/1000 [2:23:29<4:28:50, 24.74s/it][Succeeded / Failed / Skipped / Total] 328 / 16 / 4 / 348:  35%|███▍      | 348/1000 [2:23:29<4:28:50, 24.74s/it][Succeeded / Failed / Skipped / Total] 328 / 16 / 4 / 348:  35%|███▍      | 349/1000 [2:23:38<4:27:56, 24.69s/it][Succeeded / Failed / Skipped / Total] 329 / 16 / 4 / 349:  35%|███▍      | 349/1000 [2:23:38<4:27:56, 24.69s/it][Succeeded / Failed / Skipped / Total] 329 / 16 / 4 / 349:  35%|███▌      | 350/1000 [2:23:49<4:27:06, 24.66s/it][Succeeded / Failed / Skipped / Total] 330 / 16 / 4 / 350:  35%|███▌      | 350/1000 [2:23:49<4:27:06, 24.66s/it][Succeeded / Failed / Skipped / Total] 330 / 16 / 4 / 350:  35%|███▌      | 351/1000 [2:24:10<4:26:34, 24.64s/it][Succeeded / Failed / Skipped / Total] 331 / 16 / 4 / 351:  35%|███▌      | 351/1000 [2:24:10<4:26:34, 24.64s/it][Succeeded / Failed / Skipped / Total] 331 / 16 / 4 / 351:  35%|███▌      | 352/1000 [2:28:09<4:32:44, 25.25s/it][Succeeded / Failed / Skipped / Total] 331 / 17 / 4 / 352:  35%|███▌      | 352/1000 [2:28:09<4:32:44, 25.25s/it][Succeeded / Failed / Skipped / Total] 331 / 17 / 4 / 352:  35%|███▌      | 353/1000 [2:28:19<4:31:51, 25.21s/it][Succeeded / Failed / Skipped / Total] 332 / 17 / 4 / 353:  35%|███▌      | 353/1000 [2:28:19<4:31:51, 25.21s/it][Succeeded / Failed / Skipped / Total] 332 / 17 / 4 / 353:  35%|███▌      | 354/1000 [2:28:24<4:30:49, 25.15s/it]Creates a real map binder . --> duplicatedMapBinder --> Socre: 1.0

[[[[Adv]]]]: static < [[K]] , V > RealMapBinder < [[K]] , V > [[newRealMapBinder]] ( Binder [[binder]] , TypeLiteral < [[K]] > [[keyType]] , Key < V > valueTypeAndAnnotation ) { [[binder]] = [[binder]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[newRealMapBinder]] ( [[binder]] , [[keyType]] , valueType , valueTypeAndAnnotation . ofType ( mapOf ( [[keyType]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[binder]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( [[keyType]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .

[[[[Adv]]]]: static < [[sharma]] , V > RealMapBinder < [[sharma]] , V > [[dupree]] ( Binder [[pocketbook]] , TypeLiteral < [[sharma]] > [[key]] , Key < V > valueTypeAndAnnotation ) { [[pocketbook]] = [[pocketbook]] . skipSources ( RealMapBinder . class ) ; TypeLiteral < V > valueType = valueTypeAndAnnotation . getTypeLiteral ( ) ; return [[dupree]] ( [[pocketbook]] , [[key]] , valueType , valueTypeAndAnnotation . ofType ( mapOf ( [[key]] , valueType ) ) , RealMultibinder . newRealSetBinder ( [[pocketbook]] , valueTypeAndAnnotation . ofType ( entryOfProviderOf ( [[key]] , valueType ) ) ) ) ; }
[[[[Nl]]]]: since it s an easy way to group a type and an optional annotation type or instance .
--------------------------------------------- Result 347 ---------------------------------------------
Initializes the delegate provider . --> Swannaire implementation --> Socre: 1.0

[[[[Adv]]]]: public void [[initializeDelegate]] ( Provider < T > [[delegate]] ) { checkState ( this . [[delegate]] == null , "delegate already initialized" ) ; this . [[delegate]] = checkNotNull ( [[delegate]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .

[[[[Adv]]]]: public void [[swann]] ( Provider < T > [[commissioners]] ) { checkState ( this . [[commissaire]] == null , "delegate already initialized" ) ; this . [[commissaire]] = checkNotNull ( [[commissioners]] , "delegate" ) ; }
[[[[Nl]]]]: Sets the actual provider .
--------------------------------------------- Result 348 ---------------------------------------------
Creates a new instance of the given construction . --> Creates the affords --> Socre: 1.0

[[[[Adv]]]]: private T [[provision]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[t]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[t]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[t]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .

[[[[Adv]]]]: private T [[affords]] ( InternalContext context , ConstructionContext < T > constructionContext ) throws InternalProvisionException { try { T [[your]] ; try { Object [ ] parameters = SingleParameterInjector . getAll ( context , parameterInjectors ) ; [[your]] = constructionProxy . newInstance ( parameters ) ; constructionContext . setProxyDelegates ( [[your]] ) ; } finally { constructionContext . finishConstruction ( ) ; }
[[[[Nl]]]]: Provisions a new T .
--------------------------------------------- Result 349 ---------------------------------------------
Write replace . --> Create a generic cataract --> Socre: 1.0

[[[[Adv]]]]: private Object [[writeReplace]] ( ) throws ObjectStreamException { Object [ ] [[sourcesAsStrings]] = sources . toArray ( ) ; for ( int [[i]] = 0 ; [[i]] < [[sourcesAsStrings]] . length ; [[i]] ++ ) { [[sourcesAsStrings]] [ [[i]] ] = Errors . convert ( [[sourcesAsStrings]] [ [[i]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[sourcesAsStrings]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .

[[[[Adv]]]]: private Object [[cataract]] ( ) throws ObjectStreamException { Object [ ] [[brannan]] = sources . toArray ( ) ; for ( int [[ai]] = 0 ; [[ai]] < [[brannan]] . length ; [[ai]] ++ ) { [[brannan]] [ [[ai]] ] = Errors . convert ( [[brannan]] [ [[ai]] ] ) . toString ( ) ; } return new Message ( ImmutableList . copyOf ( [[brannan]] ) , message , cause ) ; }
[[[[Nl]]]]: When serialized we eagerly convert sources to strings . This hurts our formatting but it guarantees that the receiving end will be able to read the message .
--------------------------------------------- Result 350 ---------------------------------------------
Returns the module for the given module . --> Dynamically bundler --> Socre: 1.0

[[[[Adv]]]]: static Module [[forModule]] ( Module [[module]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .

[[[[Adv]]]]: static Module [[bund]] ( Module [[platoon]] ) {
[[[[Nl]]]]: Returns a module which creates bindings for provider methods from the given module .
--------------------------------------------- Result 351 ---------------------------------------------
Returns all registered methods . --> Flush methods --> Socre: 1.0

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[getAssistedMethods]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .

[[[[Adv]]]]: @ Override @ SuppressWarnings ( "unchecked" ) public Collection < AssistedMethod > [[laundered]] ( ) { return ( Collection < AssistedMethod > ) ( Collection < ? > ) assistDataByMethod . values ( ) ; }
[[[[Nl]]]]: the collection is immutable .
--------------------------------------------- Result 352 ---------------------------------------------
Create an uninitialized binding . --> [[[FAILED]]]

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .

[[[[Adv]]]]: < T > BindingImpl < T > createUninitializedBinding ( Key < T > key , Scoping scoping , Object source , Errors errors , boolean jitBinding ) throws ErrorsException { Class < ? > rawType = key . getTypeLiteral ( ) . getRawType ( ) ; ImplementedBy implementedBy = rawType . getAnnotation ( ImplementedBy . class ) ;
[[[[Nl]]]]: Creates a binding for an injectable type with the given scope . Looks for a scope on the type if none is specified .
--------------------------------------------- Result 353 ---------------------------------------------
Returns the binding for the given type and annotations . --> non - private --> Socre: 1.0

[[[[Adv]]]]: public static Key < ? > [[getKey]] ( TypeLiteral < ? > type , Member [[member]] , Annotation [ ] [[annotations]] , Errors [[errors]] ) throws ErrorsException { int [[numErrorsBefore]] = [[errors]] . size ( ) ; Annotation found = findBindingAnnotation ( [[errors]] , [[member]] , [[annotations]] ) ; [[errors]] . throwIfNewErrors ( [[numErrorsBefore]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .

[[[[Adv]]]]: public static Key < ? > [[cunningly]] ( TypeLiteral < ? > type , Member [[reps]] , Annotation [ ] [[imperialists]] , Errors [[error]] ) throws ErrorsException { int [[harmonica]] = [[error]] . size ( ) ; Annotation found = findBindingAnnotation ( [[error]] , [[reps]] , [[imperialists]] ) ; [[error]] . throwIfNewErrors ( [[harmonica]] ) ; return found == null ? Key . get ( type ) : Key . get ( type , found ) ; }
[[[[Nl]]]]: Gets a key for the given type member and annotations .
--------------------------------------------- Result 354 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 333 / 17 / 4 / 354:  35%|███▌      | 354/1000 [2:28:24<4:30:49, 25.15s/it][Succeeded / Failed / Skipped / Total] 333 / 17 / 4 / 354:  36%|███▌      | 355/1000 [2:28:30<4:29:49, 25.10s/it][Succeeded / Failed / Skipped / Total] 334 / 17 / 4 / 355:  36%|███▌      | 355/1000 [2:28:30<4:29:49, 25.10s/it][Succeeded / Failed / Skipped / Total] 334 / 17 / 4 / 355:  36%|███▌      | 356/1000 [2:28:47<4:29:10, 25.08s/it][Succeeded / Failed / Skipped / Total] 335 / 17 / 4 / 356:  36%|███▌      | 356/1000 [2:28:47<4:29:10, 25.08s/it][Succeeded / Failed / Skipped / Total] 335 / 17 / 4 / 356:  36%|███▌      | 357/1000 [2:28:52<4:28:09, 25.02s/it][Succeeded / Failed / Skipped / Total] 336 / 17 / 4 / 357:  36%|███▌      | 357/1000 [2:28:52<4:28:09, 25.02s/it][Succeeded / Failed / Skipped / Total] 336 / 17 / 4 / 357:  36%|███▌      | 358/1000 [2:29:04<4:27:20, 24.98s/it][Succeeded / Failed / Skipped / Total] 337 / 17 / 4 / 358:  36%|███▌      | 358/1000 [2:29:04<4:27:20, 24.98s/it][Succeeded / Failed / Skipped / Total] 337 / 17 / 4 / 358:  36%|███▌      | 359/1000 [2:29:23<4:26:44, 24.97s/it][Succeeded / Failed / Skipped / Total] 337 / 18 / 4 / 359:  36%|███▌      | 359/1000 [2:29:23<4:26:44, 24.97s/it][Succeeded / Failed / Skipped / Total] 337 / 18 / 4 / 359:  36%|███▌      | 360/1000 [2:29:51<4:26:24, 24.98s/it][Succeeded / Failed / Skipped / Total] 338 / 18 / 4 / 360:  36%|███▌      | 360/1000 [2:29:51<4:26:24, 24.98s/it][Succeeded / Failed / Skipped / Total] 338 / 18 / 4 / 360:  36%|███▌      | 361/1000 [2:31:55<4:28:54, 25.25s/it]Check if a constructor has parameters matching parameters . --> calculate the key of the constructor --> Socre: 1.0

[[[[Adv]]]]: private boolean [[constructorHasMatchingParams]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all

[[[[Adv]]]]: private boolean [[couric]] ( TypeLiteral < ? > type , Constructor < ? > constructor , List < Key < ? > > paramList , Errors errors ) throws ErrorsException { List < TypeLiteral < ? > > params = type . getParameterTypes ( constructor ) ; Annotation [ ] [ ] paramAnnotations = constructor . getParameterAnnotations ( ) ; int p = 0 ; List < Key < ? > > constructorKeys = Lists . newArrayList ( ) ; for ( TypeLiteral < ? > param : params ) { Key < ? > paramKey = Annotations . getKey ( param , constructor , paramAnnotations [ p ++ ] , errors ) ; constructorKeys . add ( paramKey ) ; }
[[[[Nl]]]]: Matching logic for constructors annotated with AssistedInject . This returns true if and only if all
--------------------------------------------- Result 355 ---------------------------------------------
Removes the dependencies from the given dependencies . --> Obtain the obsessions --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[removeAssistedDeps]] ( Set < Dependency < ? > > [[deps]] ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[deps]] ) { Class < ? > [[annotationType]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[annotationType]] == null || ! [[annotationType]] . equals ( Assisted . class ) ) { [[builder]] . add ( dep ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .

[[[[Adv]]]]: private Set < Dependency < ? > > [[obsessions]] ( Set < Dependency < ? > > [[johnny]] ) { ImmutableSet . Builder < Dependency < ? > > [[producer]] = ImmutableSet . builder ( ) ; for ( Dependency < ? > dep : [[johnny]] ) { Class < ? > [[unreal]] = dep . getKey ( ) . getAnnotationType ( ) ; if ( [[unreal]] == null || ! [[unreal]] . equals ( Assisted . class ) ) { [[producer]] . add ( dep ) ; } } return [[producer]] . build ( ) ; }
[[[[Nl]]]]: Return all non - assisted dependencies .
--------------------------------------------- Result 356 ---------------------------------------------
Determines if the given injector can be used for an optimization . --> Deregisters tombstones tombstones --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isValidForOptimizedAssistedInject]] ( Set < Dependency < ? > > [[dependencies]] , Class < ? > [[implementation]] , TypeLiteral < ? > [[factoryType]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .

[[[[Adv]]]]: private boolean [[tombstones]] ( Set < Dependency < ? > > [[saleslady]] , Class < ? > [[executive]] , TypeLiteral < ? > [[bummed]] ) { Set < Dependency < ? > > badDeps = null ;
[[[[Nl]]]]: Returns true if all dependencies are suitable for the optimized version of AssistedInject . The optimized version caches the binding & uses a ThreadLocal Provider so can only be applied if the assisted bindings are immediately provided . This looks for hints that the values may be lazily retrieved by looking for injections of Injector or a Provider for the assisted values .
--------------------------------------------- Result 357 ---------------------------------------------
Returns the dependencies for the given ctor . --> Generate stylings for a given type --> Socre: 1.0

[[[[Adv]]]]: private Set < Dependency < ? > > [[getDependencies]] ( InjectionPoint [[ctorPoint]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[builder]] = ImmutableSet . builder ( ) ; [[builder]] . addAll ( [[ctorPoint]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[builder]] . addAll ( ip . getDependencies ( ) ) ; } } return [[builder]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .

[[[[Adv]]]]: private Set < Dependency < ? > > [[stylings]] ( InjectionPoint [[pippin]] , TypeLiteral < ? > implementation ) { ImmutableSet . Builder < Dependency < ? > > [[manufactures]] = ImmutableSet . builder ( ) ; [[manufactures]] . addAll ( [[pippin]] . getDependencies ( ) ) ; if ( ! implementation . getRawType ( ) . isInterface ( ) ) { for ( InjectionPoint ip : InjectionPoint . forInstanceMethodsAndFields ( implementation ) ) { [[manufactures]] . addAll ( ip . getDependencies ( ) ) ; } } return [[manufactures]] . build ( ) ; }
[[[[Nl]]]]: Calculates all dependencies required by the implementation and constructor .
--------------------------------------------- Result 358 ---------------------------------------------
Invokes the method on the proxy . --> Overrides default implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public Object [[invoke]] ( Object [[proxy]] , final Method [[method]] , final Object [ ] [[args]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .

[[[[Adv]]]]: @ Override public Object [[affirmation]] ( Object [[alternative]] , final Method [[format]] , final Object [ ] [[daffodils]] ) throws Throwable {
[[[[Nl]]]]: When a factory method is invoked we create a child injector that binds all parameters then use that to get an instance of the return type .
--------------------------------------------- Result 359 ---------------------------------------------
Create an error message for a given key . --> [[[FAILED]]]

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages

[[[[Adv]]]]: < T > Errors missingImplementationWithHint ( Key < T > key , Injector injector ) { StringBuilder sb = new StringBuilder ( ) ; sb . append ( format ( "No implementation for %s was bound." , key ) ) ;
[[[[Nl]]]]: Within guice s core allow for better missing binding messages
--------------------------------------------- Result 360 ---------------------------------------------
Instantiates real Multibinder using the given key . --> New real Multibinder --> Socre: 1.0

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[binder]] , Key < T > key ) { [[binder]] = [[binder]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[result]] = new RealMultibinder <> ( [[binder]] , key ) ; [[binder]] . install ( [[result]] ) ; return [[result]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .

[[[[Adv]]]]: public static < T > RealMultibinder < T > newRealSetBinder ( Binder [[satchel]] , Key < T > key ) { [[satchel]] = [[satchel]] . skipSources ( RealMultibinder . class ) ; RealMultibinder < T > [[reverberations]] = new RealMultibinder <> ( [[satchel]] , key ) ; [[satchel]] . install ( [[reverberations]] ) ; return [[reverberations]] ; }
[[[[Nl]]]]: Implementation of newSetBinder .
[Succeeded / Failed / Skipped / Total] 339 / 18 / 4 / 361:  36%|███▌      | 361/1000 [2:31:55<4:28:54, 25.25s/it][Succeeded / Failed / Skipped / Total] 339 / 18 / 4 / 361:  36%|███▌      | 362/1000 [2:32:47<4:29:16, 25.32s/it][Succeeded / Failed / Skipped / Total] 340 / 18 / 4 / 362:  36%|███▌      | 362/1000 [2:32:47<4:29:16, 25.32s/it][Succeeded / Failed / Skipped / Total] 340 / 18 / 4 / 362:  36%|███▋      | 363/1000 [2:36:12<4:34:07, 25.82s/it][Succeeded / Failed / Skipped / Total] 341 / 18 / 4 / 363:  36%|███▋      | 363/1000 [2:36:12<4:34:07, 25.82s/it][Succeeded / Failed / Skipped / Total] 341 / 18 / 4 / 363:  36%|███▋      | 364/1000 [2:37:04<4:34:27, 25.89s/it][Succeeded / Failed / Skipped / Total] 342 / 18 / 4 / 364:  36%|███▋      | 364/1000 [2:37:04<4:34:27, 25.89s/it][Succeeded / Failed / Skipped / Total] 342 / 18 / 4 / 364:  36%|███▋      | 365/1000 [2:37:09<4:33:25, 25.83s/it][Succeeded / Failed / Skipped / Total] 343 / 18 / 4 / 365:  36%|███▋      | 365/1000 [2:37:09<4:33:25, 25.83s/it][Succeeded / Failed / Skipped / Total] 343 / 18 / 4 / 365:  37%|███▋      | 366/1000 [2:38:36<4:34:44, 26.00s/it][Succeeded / Failed / Skipped / Total] 344 / 18 / 4 / 366:  37%|███▋      | 366/1000 [2:38:36<4:34:44, 26.00s/it][Succeeded / Failed / Skipped / Total] 344 / 18 / 4 / 366:  37%|███▋      | 367/1000 [2:39:11<4:34:34, 26.03s/it][Succeeded / Failed / Skipped / Total] 344 / 19 / 4 / 367:  37%|███▋      | 367/1000 [2:39:11<4:34:34, 26.03s/it][Succeeded / Failed / Skipped / Total] 344 / 19 / 4 / 367:  37%|███▋      | 368/1000 [2:39:14<4:33:29, 25.96s/it][Succeeded / Failed / Skipped / Total] 345 / 19 / 4 / 368:  37%|███▋      | 368/1000 [2:39:14<4:33:29, 25.96s/it][Succeeded / Failed / Skipped / Total] 345 / 19 / 4 / 368:  37%|███▋      | 369/1000 [2:39:17<4:32:23, 25.90s/it]--------------------------------------------- Result 361 ---------------------------------------------
Find the next filter matching the given request . --> Retrieves a houseer matching a given request --> Socre: 1.0

[[[[Adv]]]]: private Filter [[findNextFilter]] ( HttpServletRequest [[request]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[filter]] = filterDefinitions [ index ] . getFilterIfMatching ( [[request]] ) ; if ( [[filter]] != null ) { return [[filter]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .

[[[[Adv]]]]: private Filter [[towner]] ( HttpServletRequest [[require]] ) { while ( ++ index < filterDefinitions . length ) { Filter [[screenings]] = filterDefinitions [ index ] . getFilterIfMatching ( [[require]] ) ; if ( [[screenings]] != null ) { return [[screenings]] ; } } return null ; }
[[[[Nl]]]]: Iterates over the remaining filter definitions . Returns the first applicable filter or null if none apply .
--------------------------------------------- Result 362 ---------------------------------------------
Returns true if the constructor has at least one annotation . --> Determine whether or not --> Socre: 1.0

[[[[Adv]]]]: private static boolean [[hasAtInject]] ( Constructor [[cxtor]] ) { return [[cxtor]] . isAnnotationPresent ( Inject . class ) || [[cxtor]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .

[[[[Adv]]]]: private static boolean [[crew]] ( Constructor [[whereby]] ) { return [[whereby]] . isAnnotationPresent ( Inject . class ) || [[whereby]] . isAnnotationPresent ( javax . inject . Inject . class ) ; }
[[[[Nl]]]]: Returns true if the inject annotation is on the constructor .
--------------------------------------------- Result 363 ---------------------------------------------
Returns true if the type is not defined . --> also called by ConfigException --> Socre: 1.0

[[[[Adv]]]]: private boolean [[isTypeNotSpecified]] ( TypeLiteral < ? > [[typeLiteral]] , ConfigurationException [[ce]] ) { Collection < Message > [[messages]] = [[ce]] . getErrorMessages ( ) ; if ( [[messages]] . size ( ) == 1 ) { Message [[msg]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[typeLiteral]] ) . getMessages ( ) ) ; return [[msg]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[messages]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .

[[[[Adv]]]]: private boolean [[thereupon]] ( TypeLiteral < ? > [[missie]] , ConfigurationException [[what]] ) { Collection < Message > [[telecommunications]] = [[what]] . getErrorMessages ( ) ; if ( [[telecommunications]] . size ( ) == 1 ) { Message [[chatters]] = Iterables . getOnlyElement ( new Errors ( ) . keyNotFullySpecified ( [[missie]] ) . getMessages ( ) ) ; return [[chatters]] . getMessage ( ) . equals ( Iterables . getOnlyElement ( [[telecommunications]] ) . getMessage ( ) ) ; } else { return "False" != "False" ; } }
[[[[Nl]]]]: Returns true if the ConfigurationException is due to an error of TypeLiteral not being fully specified .
--------------------------------------------- Result 364 ---------------------------------------------
Returns a set of internal dependencies . --> Exchange the constructors --> Socre: 1.0

[[[[Adv]]]]: Set < Dependency < ? > > [[getInternalDependencies]] ( ) { ImmutableSet . Builder < InjectionPoint > [[builder]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[builder]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .

[[[[Adv]]]]: Set < Dependency < ? > > [[exchanges]] ( ) { ImmutableSet . Builder < InjectionPoint > [[constructors]] = ImmutableSet . builder ( ) ; if ( factory . constructorInjector == null ) { [[constructors]] . add ( constructorInjectionPoint ) ;
[[[[Nl]]]]: Returns a set of dependencies that can be iterated over to clean up stray JIT bindings .
--------------------------------------------- Result 365 ---------------------------------------------
Returns a Module for the given module . --> Scaled ModuleScanner --> Socre: 1.0

[[[[Adv]]]]: public static Module [[forModule]] ( Object [[module]] , ModuleAnnotatedMethodScanner [[scanner]] ) { return forObject ( [[module]] , "[[False]]" != "[[False]]" , [[scanner]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .

[[[[Adv]]]]: public static Module [[scrimp]] ( Object [[panel]] , ModuleAnnotatedMethodScanner [[ultrasound]] ) { return forObject ( [[panel]] , "[[Phony]]" != "[[Phony]]" , [[ultrasound]] ) ; }
[[[[Nl]]]]: Returns a module which creates bindings methods in the module that match the scanner .
--------------------------------------------- Result 366 ---------------------------------------------
Gets the internal constructor . --> InjectionPoint --> Socre: 1.0

[[[[Adv]]]]: InjectionPoint [[getInternalConstructor]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .

[[[[Adv]]]]: InjectionPoint [[silkworms]] ( ) { if ( factory . constructorInjector != null ) { return factory . constructorInjector . getConstructionProxy ( ) . getInjectionPoint ( ) ; } else { return constructorInjectionPoint ; } }
[[[[Nl]]]]: Returns an injection point that can be used to clean up the constructor store .
--------------------------------------------- Result 367 ---------------------------------------------
Gets the key for a new value . --> [[[FAILED]]]

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .

[[[[Adv]]]]: Key < V > getKeyForNewValue ( K key ) { checkNotNull ( key , "key" ) ; checkConfiguration ( ! bindingSelection . isInitialized ( ) , "MapBinder was already initialized" ) ; RealMultibinder < Map . Entry < K , Provider < V > > > entrySetBinder = bindingSelection . getEntrySetBinder ( ) ; Key < V > valueKey = Key . get ( bindingSelection . getValueType ( ) , new RealElement ( entrySetBinder . getSetName ( ) , MAPBINDER , bindingSelection . getKeyType ( ) . toString ( ) ) ) ; entrySetBinder . addBinding ( ) . toProvider ( new ProviderMapEntry < K , V > ( key , valueKey ) ) ; return valueKey ; }
[[[[Nl]]]]: Adds a binding to the map for the given key .
--------------------------------------------- Result 368 ---------------------------------------------
Initialize the lookup . --> Tries to do tne --> Socre: 1.0

[[[[Adv]]]]: void [[initialize]] ( Errors [[errors]] ) { injector . lookups = injector ; new LookupProcessor ( [[errors]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .

[[[[Adv]]]]: void [[tne]] ( Errors [[vices]] ) { injector . lookups = injector ; new LookupProcessor ( [[vices]] ) . process ( injector , lookups ) ; }
[[[[Nl]]]]: Initialize the specified lookups either immediately or when the injector is created .
--------------------------------------------- Result 369 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 346 / 19 / 4 / 369:  37%|███▋      | 369/1000 [2:39:17<4:32:23, 25.90s/it][Succeeded / Failed / Skipped / Total] 346 / 19 / 4 / 369:  37%|███▋      | 370/1000 [2:39:51<4:32:11, 25.92s/it][Succeeded / Failed / Skipped / Total] 347 / 19 / 4 / 370:  37%|███▋      | 370/1000 [2:39:51<4:32:11, 25.92s/it][Succeeded / Failed / Skipped / Total] 347 / 19 / 4 / 370:  37%|███▋      | 371/1000 [2:40:29<4:32:06, 25.96s/it][Succeeded / Failed / Skipped / Total] 348 / 19 / 4 / 371:  37%|███▋      | 371/1000 [2:40:29<4:32:06, 25.96s/it][Succeeded / Failed / Skipped / Total] 348 / 19 / 4 / 371:  37%|███▋      | 372/1000 [2:40:33<4:31:02, 25.90s/it][Succeeded / Failed / Skipped / Total] 349 / 19 / 4 / 372:  37%|███▋      | 372/1000 [2:40:33<4:31:02, 25.90s/it][Succeeded / Failed / Skipped / Total] 349 / 19 / 4 / 372:  37%|███▋      | 373/1000 [2:40:36<4:29:58, 25.84s/it][Succeeded / Failed / Skipped / Total] 350 / 19 / 4 / 373:  37%|███▋      | 373/1000 [2:40:36<4:29:58, 25.84s/it][Succeeded / Failed / Skipped / Total] 350 / 19 / 4 / 373:  37%|███▋      | 374/1000 [2:44:04<4:34:38, 26.32s/it]Wraps a callable in a Callable . --> Wrap Pickable --> Socre: 1.0

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[continueRequest]] ( Callable < T > [[callable]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[callable]] , [[continueRequest]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .

[[[[Adv]]]]: @ Deprecated public static < T > Callable < T > [[willet]] ( Callable < T > [[loverboy]] , Map < Key < ? > , Object > seedMap ) { return wrap ( [[loverboy]] , [[willet]] ( seedMap ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that continues the HTTP request in another thread . This acts as a way of transporting request context data from the request processing thread to to worker threads .
--------------------------------------------- Result 370 ---------------------------------------------
Transforms request . --> Yriamole function --> Socre: 1.0

[[[[Adv]]]]: public static < T > Callable < T > [[transferRequest]] ( Callable < T > [[callable]] ) { return wrap ( [[callable]] , [[transferRequest]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .

[[[[Adv]]]]: public static < T > Callable < T > [[myriam]] ( Callable < T > [[barometric]] ) { return wrap ( [[barometric]] , [[myriam]] ( ) ) ; }
[[[[Nl]]]]: Wraps the given callable in a contextual callable that transfers the request to another thread . This acts as a way of transporting request context data from the current thread to a future thread .
--------------------------------------------- Result 371 ---------------------------------------------
Returns the line number for a given member . --> Methode de la reflection --> Socre: 1.0

[[[[Adv]]]]: public Integer [[getLineNumber]] ( Member [[member]] ) { Preconditions . checkArgument ( type == [[member]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[member]] , [[member]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[member]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .

[[[[Adv]]]]: public Integer [[bonaparte]] ( Member [[messieurs]] ) { Preconditions . checkArgument ( type == [[messieurs]] . getDeclaringClass ( ) , "Member %s belongs to %s, not %s" , [[messieurs]] , [[messieurs]] . getDeclaringClass ( ) , type ) ; return lines . get ( memberKey ( [[messieurs]] ) ) ; }
[[[[Nl]]]]: Get the line number associated with the given member .
--------------------------------------------- Result 372 ---------------------------------------------
Checks that the given value is compatible with the given key . --> Hortonical implementation --> Socre: 1.0

[[[[Adv]]]]: private static Object [[validateAndCanonicalizeValue]] ( Key < ? > [[key]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[key]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[key]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .

[[[[Adv]]]]: private static Object [[horton]] ( Key < ? > [[basic]] , Object object ) { if ( object == null || object == NullObject . INSTANCE ) { return NullObject . INSTANCE ; } if ( ! [[basic]] . getTypeLiteral ( ) . getRawType ( ) . isInstance ( object ) ) { throw new IllegalArgumentException ( "Value[" + object + "] of type[" + object . getClass ( ) . getName ( ) + "] is not compatible with key[" + [[basic]] + "]" ) ; } return object ; }
[[[[Nl]]]]: Validates the key and object ensuring the value matches the key type and canonicalizing null objects to the null sentinel .
--------------------------------------------- Result 373 ---------------------------------------------
Creates a new member injector for the given type . --> expector --> Socre: 1.0

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[createWithListeners]] ( TypeLiteral < T > [[type]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[type]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[encounter]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > [[alreadySeenListeners]] = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[typeListener]] = binding . getListener ( ) ; if ( ! [[alreadySeenListeners]] . contains ( [[typeListener]] ) && binding . getTypeMatcher ( ) . matches ( [[type]] ) ) { [[alreadySeenListeners]] . add ( [[typeListener]] ) ; try { [[typeListener]] . hear ( [[type]] , [[encounter]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[type]] , e ) ; } } } [[encounter]] . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[type]] , [[encounter]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .

[[[[Adv]]]]: private < T > MembersInjectorImpl < T > [[alexia]] ( TypeLiteral < T > [[boyfriend]] , Errors errors ) throws ErrorsException { int numErrorsBefore = errors . size ( ) ; Set < InjectionPoint > injectionPoints ; try { injectionPoints = InjectionPoint . forInstanceMethodsAndFields ( [[boyfriend]] ) ; } catch ( ConfigurationException e ) { errors . merge ( e . getErrorMessages ( ) ) ; injectionPoints = e . getPartialValue ( ) ; } ImmutableList < SingleMemberInjector > injectors = getInjectors ( injectionPoints , errors ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; EncounterImpl < T > [[encounters]] = new EncounterImpl <> ( errors , injector . lookups ) ; Set < TypeListener > [[parris]] = Sets . newHashSet ( ) ; for ( TypeListenerBinding binding : typeListenerBindings ) { TypeListener [[planks]] = binding . getListener ( ) ; if ( ! [[parris]] . contains ( [[planks]] ) && binding . getTypeMatcher ( ) . matches ( [[boyfriend]] ) ) { [[parris]] . add ( [[planks]] ) ; try { [[planks]] . hear ( [[boyfriend]] , [[encounters]] ) ; } catch ( RuntimeException e ) { errors . errorNotifyingTypeListener ( binding , [[boyfriend]] , e ) ; } } } [[encounters]] . invalidate ( ) ; errors . throwIfNewErrors ( numErrorsBefore ) ; return new MembersInjectorImpl < T > ( injector , [[boyfriend]] , [[encounters]] , injectors ) ; }
[[[[Nl]]]]: Creates a new members injector and attaches both injection listeners and method aspects .
--------------------------------------------- Result 374 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 351 / 19 / 4 / 374:  37%|███▋      | 374/1000 [2:44:04<4:34:38, 26.32s/it][Succeeded / Failed / Skipped / Total] 351 / 19 / 4 / 374:  38%|███▊      | 375/1000 [2:49:59<4:43:18, 27.20s/it][Succeeded / Failed / Skipped / Total] 352 / 19 / 4 / 375:  38%|███▊      | 375/1000 [2:49:59<4:43:18, 27.20s/it][Succeeded / Failed / Skipped / Total] 352 / 19 / 4 / 375:  38%|███▊      | 376/1000 [2:55:11<4:50:43, 27.96s/it][Succeeded / Failed / Skipped / Total] 353 / 19 / 4 / 376:  38%|███▊      | 376/1000 [2:55:11<4:50:43, 27.96s/it][Succeeded / Failed / Skipped / Total] 353 / 19 / 4 / 376:  38%|███▊      | 377/1000 [2:57:10<4:52:46, 28.20s/it][Succeeded / Failed / Skipped / Total] 354 / 19 / 4 / 377:  38%|███▊      | 377/1000 [2:57:10<4:52:46, 28.20s/it][Succeeded / Failed / Skipped / Total] 354 / 19 / 4 / 377:  38%|███▊      | 378/1000 [2:57:24<4:51:55, 28.16s/it][Succeeded / Failed / Skipped / Total] 355 / 19 / 4 / 378:  38%|███▊      | 378/1000 [2:57:24<4:51:55, 28.16s/it][Succeeded / Failed / Skipped / Total] 355 / 19 / 4 / 378:  38%|███▊      | 379/1000 [2:58:07<4:51:52, 28.20s/it]Gets the injectors for the given injection points . --> helper method --> Socre: 1.0

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[injectors]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[injectionPoint]] : injectionPoints ) { try { Errors [[errorsForMember]] = [[injectionPoint]] . isOptional ( ) ? new Errors ( [[injectionPoint]] ) : errors . withSource ( [[injectionPoint]] ) ; SingleMemberInjector [[injector]] = [[injectionPoint]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[injectionPoint]] , [[errorsForMember]] ) : new SingleMethodInjector ( this . injector , [[injectionPoint]] , [[errorsForMember]] ) ; [[injectors]] . add ( [[injector]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .

[[[[Adv]]]]: ImmutableList < SingleMemberInjector > getInjectors ( Set < InjectionPoint > injectionPoints , Errors errors ) { List < SingleMemberInjector > [[plunger]] = Lists . newArrayList ( ) ; for ( InjectionPoint [[gonzalez]] : injectionPoints ) { try { Errors [[bonneville]] = [[gonzalez]] . isOptional ( ) ? new Errors ( [[gonzalez]] ) : errors . withSource ( [[gonzalez]] ) ; SingleMemberInjector [[planes]] = [[gonzalez]] . getMember ( ) instanceof Field ? new SingleFieldInjector ( this . injector , [[gonzalez]] , [[bonneville]] ) : new SingleMethodInjector ( this . injector , [[gonzalez]] , [[bonneville]] ) ; [[plunger]] . add ( [[planes]] ) ; } catch ( ErrorsException ignoredForNow ) {
[[[[Nl]]]]: Returns the injectors for the specified injection points .
--------------------------------------------- Result 375 ---------------------------------------------
Returns a new instance of the specified type . --> Recover from loam --> Socre: 1.0

[[[[Adv]]]]: static < T > Key < T > [[get]] ( Class < T > [[type]] , AnnotationStrategy [[annotationStrategy]] ) { return new Key < T > ( [[type]] , [[annotationStrategy]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .

[[[[Adv]]]]: static < T > Key < T > [[recieve]] ( Class < T > [[dude]] , AnnotationStrategy [[loam]] ) { return new Key < T > ( [[dude]] , [[loam]] ) ; }
[[[[Nl]]]]: Gets a key for an injection type and an annotation strategy .
--------------------------------------------- Result 376 ---------------------------------------------
Returns the binding from the given injector . --> Taken from GuiceFactory --> Socre: 1.0

[[[[Adv]]]]: public Binding < ? > [[getBindingFromNewInjector]] ( final Method [[method]] , final Object [ ] [[args]] , final AssistData [[data]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > [[returnType]] = [[data]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .

[[[[Adv]]]]: public Binding < ? > [[avert]] ( final Method [[medio]] , final Object [ ] [[spills]] , final AssistData [[realities]] ) { checkState ( injector != null , "Factories.create() factories cannot be used until they're initialized by Guice." ) ; final Key < ? > [[hinted]] = [[realities]] . returnType ;
[[[[Nl]]]]: Creates a child injector that binds the args and returns the binding for the method s result .
--------------------------------------------- Result 377 ---------------------------------------------
Removes all stack trace elements from the given exception --> Apply painters --> Socre: 1.0

[[[[Adv]]]]: private void [[pruneStacktrace]] ( Throwable throwable ) { for ( Throwable [[t]] = throwable ; [[t]] != null ; [[t]] = [[t]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[t]] . getStackTrace ( ) ; List < StackTraceElement > [[pruned]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String [[className]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[className]] ) && ! [[className]] . contains ( "$EnhancerByGuice$" ) ) { [[pruned]] . add ( element ) ; } } [[t]] . setStackTrace ( [[pruned]] . toArray ( new StackTraceElement [ [[pruned]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .

[[[[Adv]]]]: private void [[painkiller]] ( Throwable throwable ) { for ( Throwable [[y]] = throwable ; [[y]] != null ; [[y]] = [[y]] . getCause ( ) ) { StackTraceElement [ ] stackTrace = [[y]] . getStackTrace ( ) ; List < StackTraceElement > [[leafed]] = Lists . newArrayList ( ) ; for ( StackTraceElement element : stackTrace ) { String [[roca]] = element . getClassName ( ) ; if ( ! AOP_INTERNAL_CLASSES . contains ( [[roca]] ) && ! [[roca]] . contains ( "$EnhancerByGuice$" ) ) { [[leafed]] . add ( element ) ; } } [[y]] . setStackTrace ( [[leafed]] . toArray ( new StackTraceElement [ [[leafed]] . size ( ) ] ) ) ; } }
[[[[Nl]]]]: Removes stacktrace elements related to AOP internal mechanics from the throwable s stack trace and any causes it may have .
--------------------------------------------- Result 378 ---------------------------------------------
Gets the binding source . --> For debugging purposes only --> Socre: 1.0

[[[[Adv]]]]: public String [[getBindingSource]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .

[[[[Adv]]]]: public String [[ringside]] ( ) { if ( source instanceof Class ) { return StackTraceElements . forType ( ( Class ) source ) . toString ( ) ; } else if ( source instanceof Member ) { return StackTraceElements . forMember ( ( Member ) source ) . toString ( ) ; } else { return source . toString ( ) ; } }
[[[[Nl]]]]: Returns a string describing where this dependency was bound . If the binding was just - in - time there is no valid binding source so this describes the class in question .
--------------------------------------------- Result 379 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 356 / 19 / 4 / 379:  38%|███▊      | 379/1000 [2:58:07<4:51:52, 28.20s/it][Succeeded / Failed / Skipped / Total] 356 / 19 / 4 / 379:  38%|███▊      | 380/1000 [2:59:02<4:52:07, 28.27s/it][Succeeded / Failed / Skipped / Total] 357 / 19 / 4 / 380:  38%|███▊      | 380/1000 [2:59:02<4:52:07, 28.27s/it][Succeeded / Failed / Skipped / Total] 357 / 19 / 4 / 380:  38%|███▊      | 381/1000 [2:59:30<4:51:38, 28.27s/it][Succeeded / Failed / Skipped / Total] 358 / 19 / 4 / 381:  38%|███▊      | 381/1000 [2:59:30<4:51:38, 28.27s/it][Succeeded / Failed / Skipped / Total] 358 / 19 / 4 / 381:  38%|███▊      | 382/1000 [3:01:35<4:53:46, 28.52s/it][Succeeded / Failed / Skipped / Total] 359 / 19 / 4 / 382:  38%|███▊      | 382/1000 [3:01:35<4:53:46, 28.52s/it][Succeeded / Failed / Skipped / Total] 359 / 19 / 4 / 382:  38%|███▊      | 383/1000 [3:01:39<4:52:39, 28.46s/it][Succeeded / Failed / Skipped / Total] 360 / 19 / 4 / 383:  38%|███▊      | 383/1000 [3:01:39<4:52:39, 28.46s/it][Succeeded / Failed / Skipped / Total] 360 / 19 / 4 / 383:  38%|███▊      | 384/1000 [3:03:11<4:53:52, 28.62s/it][Succeeded / Failed / Skipped / Total] 361 / 19 / 4 / 384:  38%|███▊      | 384/1000 [3:03:11<4:53:52, 28.62s/it][Succeeded / Failed / Skipped / Total] 361 / 19 / 4 / 384:  38%|███▊      | 385/1000 [3:03:53<4:53:44, 28.66s/it]Format a list of error messages . --> Format a collection of errors --> Socre: 1.0

[[[[Adv]]]]: public static String formatMessages ( String [[heading]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[heading]] ) . format ( ":%n%n" ) ; int [[index]] = 1 ; boolean [[displayCauses]] = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = [[index]] ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[i]] = dependencies . size ( ) - 1 ; [[i]] >= 0 ; [[i]] -- ) { Object source = dependencies . get ( [[i]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( [[displayCauses]] && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .

[[[[Adv]]]]: public static String formatMessages ( String [[titles]] , Collection < Message > errorMessages ) { Formatter fmt = new Formatter ( ) . format ( [[titles]] ) . format ( ":%n%n" ) ; int [[cataloguing]] = 1 ; boolean [[costa]] = getOnlyCause ( errorMessages ) == null ; Map < Equivalence . Wrapper < Throwable > , Integer > causes = Maps . newHashMap ( ) ; for ( Message errorMessage : errorMessages ) { int thisIdx = [[cataloguing]] ++ ; fmt . format ( "%s) %s%n" , thisIdx , errorMessage . getMessage ( ) ) ; List < Object > dependencies = errorMessage . getSources ( ) ; for ( int [[al]] = dependencies . size ( ) - 1 ; [[al]] >= 0 ; [[al]] -- ) { Object source = dependencies . get ( [[al]] ) ; formatSource ( fmt , source ) ; } Throwable cause = errorMessage . getCause ( ) ; if ( [[costa]] && cause != null ) { Equivalence . Wrapper < Throwable > causeEquivalence = ThrowableEquivalence . INSTANCE . wrap ( cause ) ; if ( ! causes . containsKey ( causeEquivalence ) ) { causes . put ( causeEquivalence , thisIdx ) ; fmt . format ( "Caused by: %s" , Throwables . getStackTraceAsString ( cause ) ) ; } else { int causeIdx = causes . get ( causeEquivalence ) ; fmt . format ( "Caused by: %s (same stack trace as error #%s)" , cause . getClass ( ) . getName ( ) , causeIdx ) ; } } fmt . format ( "%n" ) ; } if ( errorMessages . size ( ) == 1 ) { fmt . format ( "1 error" ) ; } else { fmt . format ( "%s errors" , errorMessages . size ( ) ) ; } return fmt . toString ( ) ; }
[[[[Nl]]]]: Returns the formatted message for an exception with the specified messages .
--------------------------------------------- Result 380 ---------------------------------------------
Creates a message with the specified message format and arguments . --> end of begets --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( String [[messageFormat]] , Object ... arguments ) { return [[create]] ( null , [[messageFormat]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .

[[[[Adv]]]]: public static Message [[begets]] ( String [[schreck]] , Object ... arguments ) { return [[begets]] ( null , [[schreck]] , arguments ) ; }
[[[[Nl]]]]: Creates a new Message without a cause .
--------------------------------------------- Result 381 ---------------------------------------------
Creates a message with the specified message and stack trace . --> public for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , String [[messageFormat]] , Object ... [[arguments]] ) { return [[create]] ( [[cause]] , ImmutableList . of ( ) , [[messageFormat]] , [[arguments]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .

[[[[Adv]]]]: public static Message [[forge]] ( Throwable [[entice]] , String [[maracaibo]] , Object ... [[conflict]] ) { return [[forge]] ( [[entice]] , ImmutableList . of ( ) , [[maracaibo]] , [[conflict]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause .
--------------------------------------------- Result 382 ---------------------------------------------
Utility method to create a message with the given message format . --> convenience method --> Socre: 1.0

[[[[Adv]]]]: public static Message [[create]] ( Throwable [[cause]] , List < Object > sources , String [[messageFormat]] , Object ... [[arguments]] ) { String [[message]] = format ( [[messageFormat]] , [[arguments]] ) ; return new Message ( sources , [[message]] , [[cause]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .

[[[[Adv]]]]: public static Message [[develops]] ( Throwable [[generated]] , List < Object > sources , String [[ter]] , Object ... [[grievance]] ) { String [[letter]] = format ( [[ter]] , [[grievance]] ) ; return new Message ( sources , [[letter]] , [[generated]] ) ; }
[[[[Nl]]]]: Creates a new Message with the given cause and a binding source stack .
--------------------------------------------- Result 383 ---------------------------------------------
Convert the given object to the declaring element . --> the root of the root element --> Socre: 1.0

[[[[Adv]]]]: static Object [[convert]] ( Object [[o]] ) { ElementSource [[source]] = null ; if ( [[o]] instanceof ElementSource ) { [[source]] = ( ElementSource ) [[o]] ; [[o]] = [[source]] . getDeclaringSource ( ) ; } return [[convert]] ( [[o]] , [[source]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .

[[[[Adv]]]]: static Object [[shifting]] ( Object [[zealanders]] ) { ElementSource [[rooting]] = null ; if ( [[zealanders]] instanceof ElementSource ) { [[rooting]] = ( ElementSource ) [[zealanders]] ; [[zealanders]] = [[rooting]] . getDeclaringSource ( ) ; } return [[shifting]] ( [[zealanders]] , [[rooting]] ) ; }
[[[[Nl]]]]: Formats an object in a user friendly way .
--------------------------------------------- Result 384 ---------------------------------------------
Checks if a class should be skipped . --> Exclude a sub - class --> Socre: 1.0

[[[[Adv]]]]: private boolean [[shouldBeSkipped]] ( String [[className]] ) { return ( parent != null && parent . shouldBeSkipped ( [[className]] ) ) || classNamesToSkip . contains ( [[className]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .

[[[[Adv]]]]: private boolean [[exhibit]] ( String [[submit]] ) { return ( parent != null && parent . shouldBeSkipped ( [[submit]] ) ) || classNamesToSkip . contains ( [[submit]] ) ; }
[[[[Nl]]]]: Returns true if the className should be skipped .
--------------------------------------------- Result 385 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 362 / 19 / 4 / 385:  38%|███▊      | 385/1000 [3:03:53<4:53:44, 28.66s/it][Succeeded / Failed / Skipped / Total] 362 / 19 / 4 / 385:  39%|███▊      | 386/1000 [3:04:01<4:52:43, 28.60s/it][Succeeded / Failed / Skipped / Total] 363 / 19 / 4 / 386:  39%|███▊      | 386/1000 [3:04:01<4:52:43, 28.60s/it][Succeeded / Failed / Skipped / Total] 363 / 19 / 4 / 386:  39%|███▊      | 387/1000 [3:05:41<4:54:07, 28.79s/it][Succeeded / Failed / Skipped / Total] 364 / 19 / 4 / 387:  39%|███▊      | 387/1000 [3:05:41<4:54:07, 28.79s/it][Succeeded / Failed / Skipped / Total] 364 / 19 / 4 / 387:  39%|███▉      | 388/1000 [3:05:56<4:53:17, 28.75s/it][Succeeded / Failed / Skipped / Total] 365 / 19 / 4 / 388:  39%|███▉      | 388/1000 [3:05:56<4:53:17, 28.75s/it][Succeeded / Failed / Skipped / Total] 365 / 19 / 4 / 388:  39%|███▉      | 389/1000 [3:06:09<4:52:24, 28.71s/it][Succeeded / Failed / Skipped / Total] 366 / 19 / 4 / 389:  39%|███▉      | 389/1000 [3:06:09<4:52:24, 28.71s/it][Succeeded / Failed / Skipped / Total] 366 / 19 / 4 / 389:  39%|███▉      | 390/1000 [3:06:30<4:51:43, 28.69s/it][Succeeded / Failed / Skipped / Total] 367 / 19 / 4 / 390:  39%|███▉      | 390/1000 [3:06:30<4:51:43, 28.69s/it][Succeeded / Failed / Skipped / Total] 367 / 19 / 4 / 390:  39%|███▉      | 391/1000 [3:06:31<4:50:30, 28.62s/it][Succeeded / Failed / Skipped / Total] 367 / 19 / 5 / 391:  39%|███▉      | 391/1000 [3:06:31<4:50:30, 28.62s/it][Succeeded / Failed / Skipped / Total] 367 / 19 / 5 / 391:  39%|███▉      | 392/1000 [3:06:46<4:49:41, 28.59s/it][Succeeded / Failed / Skipped / Total] 368 / 19 / 5 / 392:  39%|███▉      | 392/1000 [3:06:46<4:49:41, 28.59s/it][Succeeded / Failed / Skipped / Total] 368 / 19 / 5 / 392:  39%|███▉      | 393/1000 [3:06:52<4:48:37, 28.53s/it]Returns an annotation strategy for the given annotation type . --> creates a new instance of AnnotationStrategy --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Class < ? extends Annotation > [[annotationType]] ) { [[annotationType]] = Annotations . canonicalizeIfNamed ( [[annotationType]] ) ; if ( isAllDefaultMethods ( [[annotationType]] ) ) { return [[strategyFor]] ( generateAnnotation ( [[annotationType]] ) ) ; } checkNotNull ( [[annotationType]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[annotationType]] ) ; ensureIsBindingAnnotation ( [[annotationType]] ) ; return new AnnotationTypeStrategy ( [[annotationType]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .

[[[[Adv]]]]: static AnnotationStrategy [[masked]] ( Class < ? extends Annotation > [[disappoint]] ) { [[disappoint]] = Annotations . canonicalizeIfNamed ( [[disappoint]] ) ; if ( isAllDefaultMethods ( [[disappoint]] ) ) { return [[masked]] ( generateAnnotation ( [[disappoint]] ) ) ; } checkNotNull ( [[disappoint]] , "annotation type" ) ; ensureRetainedAtRuntime ( [[disappoint]] ) ; ensureIsBindingAnnotation ( [[disappoint]] ) ; return new AnnotationTypeStrategy ( [[disappoint]] , null ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation type .
--------------------------------------------- Result 386 ---------------------------------------------
Main entry point . --> Demonstrates how to display the manager --> Socre: 1.0

[[[[Adv]]]]: public static void [[main]] ( String [ ] [[args]] ) throws Exception { if ( [[args]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[module]] = ( Module ) Class . forName ( [[args]] [ 0 ] ) . newInstance ( ) ; Injector [[injector]] = Guice . createInjector ( [[module]] ) ; manage ( [[args]] [ 0 ] , [[injector]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .

[[[[Adv]]]]: public static void [[prominent]] ( String [ ] [[distinction]] ) throws Exception { if ( [[distinction]] . length != 1 ) { System . err . println ( "Usage: java -Dcom.sun.management.jmxremote " + Manager . class . getName ( ) + " [module class name]" ) ; System . err . println ( "Then run 'jconsole' to connect." ) ; System . exit ( 1 ) ; } Module [[kits]] = ( Module ) Class . forName ( [[distinction]] [ 0 ] ) . newInstance ( ) ; Injector [[nozzle]] = Guice . createInjector ( [[kits]] ) ; manage ( [[distinction]] [ 0 ] , [[nozzle]] ) ; System . out . println ( "Press Ctrl+C to exit..." ) ;
[[[[Nl]]]]: Run with no arguments for usage instructions .
--------------------------------------------- Result 387 ---------------------------------------------
Adds the given dependency to this dependency . --> public for unit test --> Socre: 1.0

[[[[Adv]]]]: Dependency < ? > [[pushDependency]] ( Dependency < ? > [[dependency]] , Object [[source]] ) { Dependency < ? > previous = this . dependency ; this . dependency = [[dependency]] ; doPushState ( [[dependency]] , [[source]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .

[[[[Adv]]]]: Dependency < ? > [[dufresne]] ( Dependency < ? > [[unit]] , Object [[cause]] ) { Dependency < ? > previous = this . dependency ; this . dependency = [[unit]] ; doPushState ( [[unit]] , [[cause]] ) ; return previous ; }
[[[[Nl]]]]: Sets the new current dependency & adds it to the state .
--------------------------------------------- Result 388 ---------------------------------------------
Push a state for the given key . --> For internal use only --> Socre: 1.0

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[key]] , Object [[source]] ) { doPushState ( [[key]] , [[source]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .

[[[[Adv]]]]: void pushState ( com . google . inject . Key < ? > [[underlying]] , Object [[history]] ) { doPushState ( [[underlying]] , [[history]] ) ; }
[[[[Nl]]]]: Adds to the state without setting the dependency .
--------------------------------------------- Result 389 ---------------------------------------------
Returns an initializable instance of the given instance . --> a simple initializer --> Socre: 1.0

[[[[Adv]]]]: static < T > Initializable < T > [[of]] ( final T [[instance]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[instance]] ; } @ Override public String toString ( ) { return String . valueOf ( [[instance]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .

[[[[Adv]]]]: static < T > Initializable < T > [[pour]] ( final T [[litigation]] ) { return new Initializable < T > ( ) { @ Override public T get ( ) { return [[litigation]] ; } @ Override public String toString ( ) { return String . valueOf ( [[litigation]] ) ; } } ; }
[[[[Nl]]]]: Returns an initializable for an instance that requires no initialization .
--------------------------------------------- Result 390 ---------------------------------------------
Gets the object from module names . --> helper method --> Socre: 1.0

[[[[Adv]]]]: public Object [[getFromClassNames]] ( List < String > [[moduleClassNames]] ) { Preconditions . checkNotNull ( [[moduleClassNames]] , "The list of module class names cannot be null." ) ; for ( final String [[moduleClassName]] : [[moduleClassNames]] ) { if ( ! shouldBeSkipped ( [[moduleClassName]] ) ) { return new StackTraceElement ( [[moduleClassName]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .

[[[[Adv]]]]: public Object [[barfed]] ( List < String > [[hereford]] ) { Preconditions . checkNotNull ( [[hereford]] , "The list of module class names cannot be null." ) ; for ( final String [[dinners]] : [[hereford]] ) { if ( ! shouldBeSkipped ( [[dinners]] ) ) { return new StackTraceElement ( [[dinners]] , "configure" , null , - 1 ) ; } } return UNKNOWN_SOURCE ; }
[[[[Nl]]]]: Returns the non - skipped module class name .
--------------------------------------------- Result 391 ---------------------------------------------
Process a connection event --> [[[SKIPPED]]]

[[[[Adv]]]]: public void onEvent ( ConnectionEventType type , String remoteAddr , Connection conn ) { List < ConnectionEventProcessor > processorList = this . processors . get ( type ) ; if ( processorList != null ) { for ( ConnectionEventProcessor processor : processorList ) { processor . onEvent ( remoteAddr , conn ) ; } } }
[[[[Nl]]]]: Dispatch events .
--------------------------------------------- Result 392 ---------------------------------------------
Adds a connection event processor . --> Registers changers for a given model --> Socre: 1.0

[[[[Adv]]]]: public void [[addConnectionEventProcessor]] ( ConnectionEventType [[type]] , ConnectionEventProcessor [[processor]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[type]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[type]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[type]] ) ; } processorList . add ( [[processor]] ) ; }
[[[[Nl]]]]: Add event processor .

[[[[Adv]]]]: public void [[nominees]] ( ConnectionEventType [[model]] , ConnectionEventProcessor [[changers]] ) { List < ConnectionEventProcessor > processorList = this . processors . get ( [[model]] ) ; if ( processorList == null ) { this . processors . putIfAbsent ( [[model]] , new ArrayList < ConnectionEventProcessor > ( 1 ) ) ; processorList = this . processors . get ( [[model]] ) ; } processorList . add ( [[changers]] ) ; }
[[[[Nl]]]]: Add event processor .
--------------------------------------------- Result 393 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 369 / 19 / 5 / 393:  39%|███▉      | 393/1000 [3:06:52<4:48:37, 28.53s/it][Succeeded / Failed / Skipped / Total] 369 / 19 / 5 / 393:  39%|███▉      | 394/1000 [3:06:53<4:47:26, 28.46s/it][Succeeded / Failed / Skipped / Total] 370 / 19 / 5 / 394:  39%|███▉      | 394/1000 [3:06:53<4:47:26, 28.46s/it][Succeeded / Failed / Skipped / Total] 370 / 19 / 5 / 394:  40%|███▉      | 395/1000 [3:07:08<4:46:38, 28.43s/it][Succeeded / Failed / Skipped / Total] 371 / 19 / 5 / 395:  40%|███▉      | 395/1000 [3:07:08<4:46:38, 28.43s/it][Succeeded / Failed / Skipped / Total] 371 / 19 / 5 / 395:  40%|███▉      | 396/1000 [3:07:38<4:46:12, 28.43s/it][Succeeded / Failed / Skipped / Total] 372 / 19 / 5 / 396:  40%|███▉      | 396/1000 [3:07:38<4:46:12, 28.43s/it][Succeeded / Failed / Skipped / Total] 372 / 19 / 5 / 396:  40%|███▉      | 397/1000 [3:07:55<4:45:26, 28.40s/it][Succeeded / Failed / Skipped / Total] 373 / 19 / 5 / 397:  40%|███▉      | 397/1000 [3:07:55<4:45:26, 28.40s/it][Succeeded / Failed / Skipped / Total] 373 / 19 / 5 / 397:  40%|███▉      | 398/1000 [3:07:56<4:44:17, 28.33s/it][Succeeded / Failed / Skipped / Total] 374 / 19 / 5 / 398:  40%|███▉      | 398/1000 [3:07:56<4:44:17, 28.33s/it][Succeeded / Failed / Skipped / Total] 374 / 19 / 5 / 398:  40%|███▉      | 399/1000 [3:07:58<4:43:08, 28.27s/it][Succeeded / Failed / Skipped / Total] 375 / 19 / 5 / 399:  40%|███▉      | 399/1000 [3:07:58<4:43:08, 28.27s/it][Succeeded / Failed / Skipped / Total] 375 / 19 / 5 / 399:  40%|████      | 400/1000 [3:08:02<4:42:03, 28.21s/it]This method is called by the provider when a dependency is created . --> Obtain an offering for the given dependency --> Socre: 1.0

[[[[Adv]]]]: protected T [[provision]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .

[[[[Adv]]]]: protected T [[offering]] ( Provider < ? extends T > provider , Dependency < ? > dependency , ConstructionContext < T > constructionContext ) throws InternalProvisionException { T t = provider . get ( ) ; if ( t == null && ! dependency . isNullable ( ) ) { InternalProvisionException . onNullInjectedIntoNonNullableDependency ( source , dependency ) ; } constructionContext . setProxyDelegates ( t ) ; return t ; }
[[[[Nl]]]]: Provisions a new instance . Subclasses should override this to catch exceptions & rethrow as ErrorsExceptions .
--------------------------------------------- Result 394 ---------------------------------------------
Suppress a throwable . --> Throws an exception . --> Socre: 1.0

[[[[Adv]]]]: public static void [[launderThrowable]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable

[[[[Adv]]]]: public static void [[tallow]] ( Throwable t ) { if ( t instanceof RuntimeException ) { throw ( RuntimeException ) t ; } else if ( t instanceof Error ) { throw ( Error ) t ; } else { throw new IllegalStateException ( "Not unchecked!" , t ) ; } }
[[[[Nl]]]]: launder the throwable
--------------------------------------------- Result 395 ---------------------------------------------
Register a remoting processor --> Lazy registerProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerProcessor]] ( CommandCode [[cmdCode]] , RemotingProcessor < ? > [[processor]] ) { if ( this . cmd2processors . containsKey ( [[cmdCode]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[cmdCode]] , cmd2processors . get ( [[cmdCode]] ) . getClass ( ) . getName ( ) , [[processor]] . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( [[cmdCode]] , [[processor]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .

[[[[Adv]]]]: public void [[lazarus]] ( CommandCode [[insure]] , RemotingProcessor < ? > [[transformer]] ) { if ( this . cmd2processors . containsKey ( [[insure]] ) ) { logger . warn ( "Processor for cmd={} is already registered, the processor is {}, and changed to {}" , [[insure]] , cmd2processors . get ( [[insure]] ) . getClass ( ) . getName ( ) , [[transformer]] . getClass ( ) . getName ( ) ) ; } this . cmd2processors . put ( [[insure]] , [[transformer]] ) ; }
[[[[Nl]]]]: Register processor to process command that has the command code of cmdCode .
--------------------------------------------- Result 396 ---------------------------------------------
Returns a strategy instance for the given annotation . --> Methode permettant de validation of ajour --> Socre: 1.0

[[[[Adv]]]]: static AnnotationStrategy [[strategyFor]] ( Annotation [[annotation]] ) { checkNotNull ( [[annotation]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[annotation]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[annotation]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[annotation]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .

[[[[Adv]]]]: static AnnotationStrategy [[prospero]] ( Annotation [[dujour]] ) { checkNotNull ( [[dujour]] , "annotation" ) ; Class < ? extends Annotation > annotationType = [[dujour]] . annotationType ( ) ; ensureRetainedAtRuntime ( annotationType ) ; ensureIsBindingAnnotation ( annotationType ) ; if ( Annotations . isMarker ( annotationType ) ) { return new AnnotationTypeStrategy ( annotationType , [[dujour]] ) ; } return new AnnotationInstanceStrategy ( Annotations . canonicalizeIfNamed ( [[dujour]] ) ) ; }
[[[[Nl]]]]: Gets the strategy for an annotation .
--------------------------------------------- Result 397 ---------------------------------------------
Returns the processor for the given command code . --> getProcessProcessor --> Socre: 1.0

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode [[cmdCode]] ) { RemotingProcessor < ? > [[processor]] = this . [[cmd2processors]] . get ( [[cmdCode]] ) ; if ( [[processor]] != null ) { return [[processor]] ; } return this . [[defaultProcessor]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .

[[[[Adv]]]]: public RemotingProcessor < ? > getProcessor ( CommandCode [[slapped]] ) { RemotingProcessor < ? > [[transistors]] = this . [[aimee]] . get ( [[slapped]] ) ; if ( [[transistors]] != null ) { return [[transistors]] ; } return this . [[afterthe]] ; }
[[[[Nl]]]]: Get the specific processor with command code of cmdCode if registered otherwise the default processor is returned .
--------------------------------------------- Result 398 ---------------------------------------------
Tries to get a given URL . --> Returns a Url for the given URL . --> Socre: 1.0

[[[[Adv]]]]: private Url [[tryGet]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache

[[[[Adv]]]]: private Url [[fifteen]] ( String url ) { SoftReference < Url > softRef = Url . parsedUrls . get ( url ) ; return ( null == softRef ) ? null : softRef . get ( ) ; }
[[[[Nl]]]]: try get from cache
--------------------------------------------- Result 399 ---------------------------------------------
Decodes Protocol Code . --> Read superheced . --> Socre: 1.0

[[[[Adv]]]]: protected ProtocolCode [[decodeProtocolCode]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[protocolCodeBytes]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[protocolCodeBytes]] ) ; return ProtocolCode . fromBytes ( [[protocolCodeBytes]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code

[[[[Adv]]]]: protected ProtocolCode [[superheated]] ( ByteBuf in ) { if ( in . readableBytes ( ) >= protocolCodeLength ) { byte [ ] [[chao]] = new byte [ protocolCodeLength ] ; in . readBytes ( [[chao]] ) ; return ProtocolCode . fromBytes ( [[chao]] ) ; } return null ; }
[[[[Nl]]]]: decode the protocol code
--------------------------------------------- Result 400 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 376 / 19 / 5 / 400:  40%|████      | 400/1000 [3:08:02<4:42:03, 28.21s/it][Succeeded / Failed / Skipped / Total] 376 / 19 / 5 / 400:  40%|████      | 401/1000 [3:08:02<4:40:53, 28.14s/it][Succeeded / Failed / Skipped / Total] 376 / 19 / 6 / 401:  40%|████      | 401/1000 [3:08:02<4:40:53, 28.14s/it][Succeeded / Failed / Skipped / Total] 376 / 19 / 6 / 401:  40%|████      | 402/1000 [3:08:06<4:39:49, 28.08s/it][Succeeded / Failed / Skipped / Total] 377 / 19 / 6 / 402:  40%|████      | 402/1000 [3:08:06<4:39:49, 28.08s/it][Succeeded / Failed / Skipped / Total] 377 / 19 / 6 / 402:  40%|████      | 403/1000 [3:08:10<4:38:46, 28.02s/it][Succeeded / Failed / Skipped / Total] 378 / 19 / 6 / 403:  40%|████      | 403/1000 [3:08:10<4:38:46, 28.02s/it][Succeeded / Failed / Skipped / Total] 378 / 19 / 6 / 403:  40%|████      | 404/1000 [3:08:11<4:37:38, 27.95s/it][Succeeded / Failed / Skipped / Total] 379 / 19 / 6 / 404:  40%|████      | 404/1000 [3:08:11<4:37:38, 27.95s/it][Succeeded / Failed / Skipped / Total] 379 / 19 / 6 / 404:  40%|████      | 405/1000 [3:08:13<4:36:31, 27.89s/it][Succeeded / Failed / Skipped / Total] 380 / 19 / 6 / 405:  40%|████      | 405/1000 [3:08:13<4:36:31, 27.89s/it][Succeeded / Failed / Skipped / Total] 380 / 19 / 6 / 405:  41%|████      | 406/1000 [3:08:38<4:35:59, 27.88s/it][Succeeded / Failed / Skipped / Total] 381 / 19 / 6 / 406:  41%|████      | 406/1000 [3:08:38<4:35:59, 27.88s/it][Succeeded / Failed / Skipped / Total] 381 / 19 / 6 / 406:  41%|████      | 407/1000 [3:08:39<4:34:52, 27.81s/it][Succeeded / Failed / Skipped / Total] 382 / 19 / 6 / 407:  41%|████      | 407/1000 [3:08:39<4:34:52, 27.81s/it][Succeeded / Failed / Skipped / Total] 382 / 19 / 6 / 407:  41%|████      | 408/1000 [3:08:43<4:33:50, 27.75s/it]Gets all connection pools . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[allConnections]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iterator]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[iterator]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[iterator]] . next ( ) ; ConnectionPool [[pool]] = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != [[pool]] ) { [[allConnections]] . put ( entry . getKey ( ) , [[pool]] . getAll ( ) ) ; } } return [[allConnections]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > getAll ( ) { Map < String , List < Connection > > [[yani]] = new HashMap < String , List < Connection > > ( ) ; Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[boycotted]] = this . getConnPools ( ) . entrySet ( ) . iterator ( ) ; while ( [[boycotted]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[boycotted]] . next ( ) ; ConnectionPool [[cistern]] = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; if ( null != [[cistern]] ) { [[yani]] . put ( entry . getKey ( ) , [[cistern]] . getAll ( ) ) ; } } return [[yani]] ; }
[[[[Nl]]]]: Get all connections of all poolKey .
--------------------------------------------- Result 401 ---------------------------------------------
Scans the pool . --> [[[SKIPPED]]]

[[[[Adv]]]]: @ Override public void scan ( ) { if ( null != this . connTasks && ! this . connTasks . isEmpty ( ) ) { Iterator < String > iter = this . connTasks . keySet ( ) . iterator ( ) ; while ( iter . hasNext ( ) ) { String poolKey = iter . next ( ) ; ConnectionPool pool = this . getConnectionPool ( this . connTasks . get ( poolKey ) ) ; if ( null != pool ) { pool . scan ( ) ; if ( pool . isEmpty ( ) ) { if ( ( System . currentTimeMillis ( ) - pool . getLastAccessTimestamp ( ) ) > DEFAULT_EXPIRE_TIME ) { iter . remove ( ) ; logger . warn ( "Remove expired pool task of poolKey {} which is empty." , poolKey ) ; } } } } } }
[[[[Nl]]]]: in case of cache pollution and connection leak to do schedule scan
--------------------------------------------- Result 402 ---------------------------------------------
Get or create a new connection . --> Retrieves trends --> Socre: 1.0

[[[[Adv]]]]: @ Override public Connection [[getAndCreateIfAbsent]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .

[[[[Adv]]]]: @ Override public Connection [[trends]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections .
--------------------------------------------- Result 403 ---------------------------------------------
Create a new connection and alive . --> Striri phrase --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[createConnectionAndHealIfNeed]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .

[[[[Adv]]]]: @ Override public void [[lyric]] ( Url url ) throws InterruptedException , RemotingException {
[[[[Nl]]]]: If no task cached create one and initialize the connections . If task cached check whether the number of connections adequate if not then heal it .
--------------------------------------------- Result 404 ---------------------------------------------
Remove task task from pool . --> Close pool . --> Socre: 1.0

[[[[Adv]]]]: private void [[removeTask]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections

[[[[Adv]]]]: private void [[yowling]] ( String poolKey ) { RunStateRecordedFutureTask < ConnectionPool > task = this . connTasks . remove ( poolKey ) ; if ( null != task ) { ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( task , logger ) ; if ( null != pool ) { pool . removeAllAndTryClose ( ) ; } } }
[[[[Nl]]]]: remove task and remove all connections
--------------------------------------------- Result 405 ---------------------------------------------
Halts the connection if needed . --> Send unique key . --> Socre: 1.0

[[[[Adv]]]]: private void [[healIfNeed]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String [[poolKey]] = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected

[[[[Adv]]]]: private void [[kress]] ( ConnectionPool pool , Url url ) throws RemotingException , InterruptedException { String [[possums]] = url . getUniqueKey ( ) ;
[[[[Nl]]]]: execute heal connection tasks if the actual number of connections in pool is less than expected
--------------------------------------------- Result 406 ---------------------------------------------
Create connection pool . --> Perform a connection --> Socre: 1.0

[[[[Adv]]]]: private void doCreate ( final Url [[url]] , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = [[url]] . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( [[url]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection [[connection]] = create ( [[url]] ) ; pool . add ( [[connection]] ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[url]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[url]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections

[[[[Adv]]]]: private void doCreate ( final Url [[emailed]] , final ConnectionPool pool , final String taskName , final int syncCreateNumWhenNotWarmup ) throws RemotingException { final int actualNum = pool . size ( ) ; final int expectNum = [[emailed]] . getConnNum ( ) ; if ( actualNum < expectNum ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "actual num {}, expect num {}, task name {}" , actualNum , expectNum , taskName ) ; } if ( [[emailed]] . isConnWarmup ( ) ) { for ( int i = actualNum ; i < expectNum ; ++ i ) { Connection [[topic]] = create ( [[emailed]] ) ; pool . add ( [[topic]] ) ; } } else { if ( syncCreateNumWhenNotWarmup < 0 || syncCreateNumWhenNotWarmup > [[emailed]] . getConnNum ( ) ) { throw new IllegalArgumentException ( "sync create number when not warmup should be [0," + [[emailed]] . getConnNum ( ) + "]" ) ; }
[[[[Nl]]]]: do create connections
--------------------------------------------- Result 407 ---------------------------------------------
Closes a connection . --> Closes the specified connection . --> Socre: 1.0

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[url]] = this . [[addressParser]] . parse ( addr ) ; this . [[connectionManager]] . remove ( [[url]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address

[[[[Adv]]]]: public void closeConnection ( String addr ) { Url [[hotmail]] = this . [[pounder]] . parse ( addr ) ; this . [[nette]] . remove ( [[hotmail]] . getUniqueKey ( ) ) ; }
[[[[Nl]]]]: Close all connections of a address
--------------------------------------------- Result 408 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 383 / 19 / 6 / 408:  41%|████      | 408/1000 [3:08:43<4:33:50, 27.75s/it][Succeeded / Failed / Skipped / Total] 383 / 19 / 6 / 408:  41%|████      | 409/1000 [3:09:12<4:33:24, 27.76s/it][Succeeded / Failed / Skipped / Total] 384 / 19 / 6 / 409:  41%|████      | 409/1000 [3:09:12<4:33:24, 27.76s/it][Succeeded / Failed / Skipped / Total] 384 / 19 / 6 / 409:  41%|████      | 410/1000 [3:09:12<4:32:17, 27.69s/it][Succeeded / Failed / Skipped / Total] 385 / 19 / 6 / 410:  41%|████      | 410/1000 [3:09:12<4:32:17, 27.69s/it][Succeeded / Failed / Skipped / Total] 385 / 19 / 6 / 410:  41%|████      | 411/1000 [3:09:14<4:31:12, 27.63s/it][Succeeded / Failed / Skipped / Total] 386 / 19 / 6 / 411:  41%|████      | 411/1000 [3:09:14<4:31:12, 27.63s/it][Succeeded / Failed / Skipped / Total] 386 / 19 / 6 / 411:  41%|████      | 412/1000 [3:09:17<4:30:08, 27.57s/it][Succeeded / Failed / Skipped / Total] 387 / 19 / 6 / 412:  41%|████      | 412/1000 [3:09:17<4:30:08, 27.57s/it][Succeeded / Failed / Skipped / Total] 387 / 19 / 6 / 412:  41%|████▏     | 413/1000 [3:09:18<4:29:04, 27.50s/it][Succeeded / Failed / Skipped / Total] 388 / 19 / 6 / 413:  41%|████▏     | 413/1000 [3:09:18<4:29:04, 27.50s/it][Succeeded / Failed / Skipped / Total] 388 / 19 / 6 / 413:  41%|████▏     | 414/1000 [3:09:18<4:27:58, 27.44s/it]Called when the connection is closed . --> Disconnects to disk --> Socre: 1.0

[[[[Adv]]]]: public void [[onClose]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[iter]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = [[iter]] . next ( ) ; [[iter]] . remove ( ) ; InvokeFuture [[future]] = entry . getValue ( ) ; if ( [[future]] != null ) { [[future]] . putResponse ( [[future]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[future]] . cancelTimeout ( ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .

[[[[Adv]]]]: public void [[diskette]] ( ) { Iterator < Entry < Integer , InvokeFuture > > [[tight]] = invokeFutureMap . entrySet ( ) . iterator ( ) ; while ( [[tight]] . hasNext ( ) ) { Entry < Integer , InvokeFuture > entry = [[tight]] . next ( ) ; [[tight]] . remove ( ) ; InvokeFuture [[loom]] = entry . getValue ( ) ; if ( [[loom]] != null ) { [[loom]] . putResponse ( [[loom]] . createConnectionClosedResponse ( this . getRemoteAddress ( ) ) ) ; [[loom]] . cancelTimeout ( ) ; [[loom]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } }
[[[[Nl]]]]: Do something when closing .
--------------------------------------------- Result 409 ---------------------------------------------
Find an annotation on the given method . --> Find tracers for a given method --> Socre: 1.0

[[[[Adv]]]]: private Annotation [[getAnnotation]] ( Binder [[binder]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[annotation]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[annotation]] != null ) { [[binder]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[annotation]] = foundAnnotation ; } } return [[annotation]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .

[[[[Adv]]]]: private Annotation [[tracers]] ( Binder [[pocketbook]] , Method method ) { if ( method . isBridge ( ) || method . isSynthetic ( ) ) { return null ; } Annotation [[bathing]] = null ; for ( Class < ? extends Annotation > annotationClass : scanner . annotationClasses ( ) ) { Annotation foundAnnotation = method . getAnnotation ( annotationClass ) ; if ( foundAnnotation != null ) { if ( [[bathing]] != null ) { [[pocketbook]] . addError ( "More than one annotation claimed by %s on method %s." + " Methods can only have one annotation claimed per scanner." , scanner , method ) ; return null ; } [[bathing]] = foundAnnotation ; } } return [[bathing]] ; }
[[[[Nl]]]]: Returns the annotation that is claimed by the scanner or null if there is none .
--------------------------------------------- Result 410 ---------------------------------------------
Gets the future task result . --> getter for futureTaskResult --> Socre: 1.0

[[[[Adv]]]]: public static < [[T]] > [[T]] getFutureTaskResult ( RunStateRecordedFutureTask < [[T]] > task , Logger logger ) { [[T]] [[t]] = null ; if ( null != task ) { try { [[t]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[t]] ; }
[[[[Nl]]]]: get the result of a future task

[[[[Adv]]]]: public static < [[ton]] > [[ton]] getFutureTaskResult ( RunStateRecordedFutureTask < [[ton]] > task , Logger logger ) { [[ton]] [[did]] = null ; if ( null != task ) { try { [[did]] = task . getAfterRun ( ) ; } catch ( InterruptedException e ) { logger . error ( "Future task interrupted!" , e ) ; } catch ( ExecutionException e ) { logger . error ( "Future task execute failed!" , e ) ; } catch ( FutureTaskNotRunYetException e ) { logger . error ( "Future task has not run yet!" , e ) ; } catch ( FutureTaskNotCompleted e ) { logger . error ( "Future task has not completed!" , e ) ; } } return [[did]] ; }
[[[[Nl]]]]: get the result of a future task
--------------------------------------------- Result 411 ---------------------------------------------
Sets an attribute for the given key . --> Convenience method for unit tests --> Socre: 1.0

[[[[Adv]]]]: public Object [[setAttributeIfAbsent]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .

[[[[Adv]]]]: public Object [[duvalier]] ( String key , Object value ) { return attributes . putIfAbsent ( key , value ) ; }
[[[[Nl]]]]: set attribute if key absent .
--------------------------------------------- Result 412 ---------------------------------------------
Register user processor --> creates knaves for processing --> Socre: 1.0

[[[[Adv]]]]: private static void [[registerUserProcessor]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[preProcessor]] = [[userProcessors]] . putIfAbsent ( interest , processor ) ; if ( [[preProcessor]] != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .

[[[[Adv]]]]: private static void [[knaves]] ( MultiInterestUserProcessor < ? > processor , ConcurrentHashMap < String , UserProcessor < ? > > [[creon]] ) { if ( null == processor . multiInterest ( ) || processor . multiInterest ( ) . isEmpty ( ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } for ( String interest : processor . multiInterest ( ) ) { UserProcessor < ? > [[retake]] = [[creon]] . putIfAbsent ( interest , processor ) ; if ( [[retake]] != null ) { String errMsg = "Processor with interest key [" + interest + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( errMsg ) ; } } }
[[[[Nl]]]]: Help register multi - interest user processor .
--------------------------------------------- Result 413 ---------------------------------------------
Dispatch request to user processor --> Pop the tipo . --> Socre: 1.0

[[[[Adv]]]]: private void [[dispatchToUserProcessor]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte [[type]] = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor

[[[[Adv]]]]: private void [[popolo]] ( RemotingContext ctx , RpcRequestCommand cmd ) { final int id = cmd . getId ( ) ; final byte [[tipo]] = cmd . getType ( ) ;
[[[[Nl]]]]: dispatch request command to user processor
--------------------------------------------- Result 414 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 388 / 19 / 7 / 414:  41%|████▏     | 414/1000 [3:09:18<4:27:58, 27.44s/it][Succeeded / Failed / Skipped / Total] 388 / 19 / 7 / 414:  42%|████▏     | 415/1000 [3:09:19<4:26:53, 27.37s/it][Succeeded / Failed / Skipped / Total] 389 / 19 / 7 / 415:  42%|████▏     | 415/1000 [3:09:19<4:26:53, 27.37s/it][Succeeded / Failed / Skipped / Total] 389 / 19 / 7 / 415:  42%|████▏     | 416/1000 [3:09:20<4:25:48, 27.31s/it][Succeeded / Failed / Skipped / Total] 390 / 19 / 7 / 416:  42%|████▏     | 416/1000 [3:09:20<4:25:48, 27.31s/it][Succeeded / Failed / Skipped / Total] 390 / 19 / 7 / 416:  42%|████▏     | 417/1000 [3:09:21<4:24:44, 27.25s/it][Succeeded / Failed / Skipped / Total] 391 / 19 / 7 / 417:  42%|████▏     | 417/1000 [3:09:21<4:24:44, 27.25s/it][Succeeded / Failed / Skipped / Total] 391 / 19 / 7 / 417:  42%|████▏     | 418/1000 [3:09:23<4:23:41, 27.19s/it][Succeeded / Failed / Skipped / Total] 392 / 19 / 7 / 418:  42%|████▏     | 418/1000 [3:09:23<4:23:41, 27.19s/it][Succeeded / Failed / Skipped / Total] 392 / 19 / 7 / 418:  42%|████▏     | 419/1000 [3:09:23<4:22:37, 27.12s/it]Send RpcRequestCommandCommandCommand --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean deserializeRequestCommand ( RemotingContext ctx , RpcRequestCommand cmd , int level ) { boolean result ; try { cmd . deserialize ( level ) ; result = "True" == "True" ; } catch ( DeserializationException e ) { logger . error ( "DeserializationException occurred when process in RpcRequestProcessor, id={}, deserializeLevel={}" , cmd . getId ( ) , RpcDeserializeLevel . valueOf ( level ) , e ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , ResponseStatus . SERVER_DESERIAL_EXCEPTION , e ) ) ; result = "False" != "False" ; } catch ( Throwable t ) { String errMsg = "Deserialize RpcRequestCommand failed in RpcRequestProcessor, id=" + cmd . getId ( ) + ", deserializeLevel=" + level ; logger . error ( errMsg , t ) ; sendResponseIfNecessary ( ctx , cmd . getType ( ) , this . getCommandFactory ( ) . createExceptionResponse ( cmd . getId ( ) , t , errMsg ) ) ; result = "False" != "False" ; } return result ; }
[[[[Nl]]]]: deserialize request command
--------------------------------------------- Result 415 ---------------------------------------------
Register a user processor --> Registers the sores in the rpc server --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerUserProcessor]] ( UserProcessor < ? > [[processor]] , ConcurrentHashMap < String , UserProcessor < ? > > [[userProcessors]] ) { if ( null == [[processor]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[processor]] instanceof MultiInterestUserProcessor ) { [[registerUserProcessor]] ( ( MultiInterestUserProcessor ) [[processor]] , [[userProcessors]] ) ; } else { if ( StringUtils . isBlank ( [[processor]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[preProcessor]] = [[userProcessors]] . putIfAbsent ( [[processor]] . interest ( ) , [[processor]] ) ; if ( [[preProcessor]] != null ) { String [[errMsg]] = "Processor with interest key [" + [[processor]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[errMsg]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .

[[[[Adv]]]]: public static void [[sores]] ( UserProcessor < ? > [[gigahertz]] , ConcurrentHashMap < String , UserProcessor < ? > > [[mcevoy]] ) { if ( null == [[gigahertz]] ) { throw new RuntimeException ( "User processor should not be null!" ) ; } if ( [[gigahertz]] instanceof MultiInterestUserProcessor ) { [[sores]] ( ( MultiInterestUserProcessor ) [[gigahertz]] , [[mcevoy]] ) ; } else { if ( StringUtils . isBlank ( [[gigahertz]] . interest ( ) ) ) { throw new RuntimeException ( "Processor interest should not be blank!" ) ; } UserProcessor < ? > [[along]] = [[mcevoy]] . putIfAbsent ( [[gigahertz]] . interest ( ) , [[gigahertz]] ) ; if ( [[along]] != null ) { String [[panda]] = "Processor with interest key [" + [[gigahertz]] . interest ( ) + "] has already been registered to rpc server, can not register again!" ; throw new RuntimeException ( [[panda]] ) ; } } }
[[[[Nl]]]]: Help register single - interest user processor .
--------------------------------------------- Result 416 ---------------------------------------------
Pre - processes the remoting context . --> Set the RpcRequest --> Socre: 1.0

[[[[Adv]]]]: private void [[preProcessRemotingContext]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz

[[[[Adv]]]]: private void [[voltage]] ( RemotingContext ctx , RpcRequestCommand cmd , long currentTimestamp ) { ctx . setArriveTimestamp ( cmd . getArriveTime ( ) ) ; ctx . setTimeout ( cmd . getTimeout ( ) ) ; ctx . setRpcCommandType ( cmd . getType ( ) ) ; ctx . getInvokeContext ( ) . putIfAbsent ( InvokeContext . BOLT_PROCESS_WAIT_TIME , currentTimestamp - cmd . getArriveTime ( ) ) ; }
[[[[Nl]]]]: pre process remoting context initial some useful infos and pass to biz
--------------------------------------------- Result 417 ---------------------------------------------
Debug logging . --> Logs the RpcRequest command . --> Socre: 1.0

[[[[Adv]]]]: private void [[debugLog]] ( RemotingContext [[ctx]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[ctx]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request

[[[[Adv]]]]: private void [[gotoh]] ( RemotingContext [[atan]] , RpcRequestCommand cmd , long currentTimestamp ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "Rpc request received! requestId={}, from {}" , cmd . getId ( ) , RemotingUtil . parseRemoteAddress ( [[atan]] . getChannelContext ( ) . channel ( ) ) ) ; logger . debug ( "request id {} currenTimestamp {} - arriveTime {} = server cost {} < timeout {}." , cmd . getId ( ) , currentTimestamp , cmd . getArriveTime ( ) , ( currentTimestamp - cmd . getArriveTime ( ) ) , cmd . getTimeout ( ) ) ; } }
[[[[Nl]]]]: print some debug log when receive request
--------------------------------------------- Result 418 ---------------------------------------------
Log timeout log . --> Bump a message --> Socre: 1.0

[[[[Adv]]]]: private void [[timeoutLog]] ( final RpcRequestCommand [[cmd]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[cmd]] . getId ( ) , currentTimestamp , [[cmd]] . getArriveTime ( ) , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[cmd]] . getId ( ) , remoteAddr , ( currentTimestamp - [[cmd]] . getArriveTime ( ) ) , [[cmd]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .

[[[[Adv]]]]: private void [[braved]] ( final RpcRequestCommand [[mac]] , long currentTimestamp , RemotingContext ctx ) { if ( logger . isDebugEnabled ( ) ) { logger . debug ( "request id [{}] currenTimestamp [{}] - arriveTime [{}] = server cost [{}] >= timeout value [{}]." , [[mac]] . getId ( ) , currentTimestamp , [[mac]] . getArriveTime ( ) , ( currentTimestamp - [[mac]] . getArriveTime ( ) ) , [[mac]] . getTimeout ( ) ) ; } String remoteAddr = "UNKNOWN" ; if ( null != ctx ) { ChannelHandlerContext channelCtx = ctx . getChannelContext ( ) ; Channel channel = channelCtx . channel ( ) ; if ( null != channel ) { remoteAddr = RemotingUtil . parseRemoteAddress ( channel ) ; } } logger . warn ( "Rpc request id[{}], from remoteAddr[{}] stop process, total wait time in queue is [{}], client timeout setting is [{}]." , [[mac]] . getId ( ) , remoteAddr , ( currentTimestamp - [[mac]] . getArriveTime ( ) ) , [[mac]] . getTimeout ( ) ) ; }
[[[[Nl]]]]: print some log when request timeout and discarded in io thread .
--------------------------------------------- Result 419 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 393 / 19 / 7 / 419:  42%|████▏     | 419/1000 [3:09:23<4:22:37, 27.12s/it][Succeeded / Failed / Skipped / Total] 393 / 19 / 7 / 419:  42%|████▏     | 420/1000 [3:09:25<4:21:35, 27.06s/it][Succeeded / Failed / Skipped / Total] 394 / 19 / 7 / 420:  42%|████▏     | 420/1000 [3:09:25<4:21:35, 27.06s/it][Succeeded / Failed / Skipped / Total] 394 / 19 / 7 / 420:  42%|████▏     | 421/1000 [3:09:26<4:20:32, 27.00s/it][Succeeded / Failed / Skipped / Total] 395 / 19 / 7 / 421:  42%|████▏     | 421/1000 [3:09:26<4:20:32, 27.00s/it][Succeeded / Failed / Skipped / Total] 395 / 19 / 7 / 421:  42%|████▏     | 422/1000 [3:09:26<4:19:28, 26.94s/it][Succeeded / Failed / Skipped / Total] 395 / 19 / 8 / 422:  42%|████▏     | 422/1000 [3:09:26<4:19:28, 26.94s/it][Succeeded / Failed / Skipped / Total] 395 / 19 / 8 / 422:  42%|████▏     | 423/1000 [3:09:27<4:18:25, 26.87s/it]This method is called when the message is received from the server . --> This method is overridden by subclasses --> Socre: 1.0

[[[[Adv]]]]: @ Override public void process ( RemotingContext [[ctx]] , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[task]] = new ProcessTask ( [[ctx]] , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[task]] ) ; } else { defaultExecutor . execute ( [[task]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .

[[[[Adv]]]]: @ Override public void process ( RemotingContext [[clang]] , T msg , ExecutorService defaultExecutor ) throws Exception { ProcessTask [[schoolwork]] = new ProcessTask ( [[clang]] , msg ) ; if ( this . getExecutor ( ) != null ) { this . getExecutor ( ) . execute ( [[schoolwork]] ) ; } else { defaultExecutor . execute ( [[schoolwork]] ) ; } }
[[[[Nl]]]]: Process the remoting command with its own executor or with the defaultExecutor if its own if null .
--------------------------------------------- Result 420 ---------------------------------------------
Performs an invocation on the server . --> Helper method for invoking the InvokeCallback --> Socre: 1.0

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture [[future]] = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( [[future]] ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture [[future]] = conn . removeInvokeFuture ( requestId ) ; if ( [[future]] != null ) { [[future]] . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; [[future]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; [[future]] . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .

[[[[Adv]]]]: protected void invokeWithCallback ( final Connection conn , final RemotingCommand request , final InvokeCallback invokeCallback , final int timeoutMillis ) { final InvokeFuture [[farther]] = createInvokeFuture ( conn , request , request . getInvokeContext ( ) , invokeCallback ) ; conn . addInvokeFuture ( [[farther]] ) ; final int requestId = request . getId ( ) ; try { Timeout timeout = TimerHolder . getTimer ( ) . newTimeout ( new TimerTask ( ) { @ Override public void run ( Timeout timeout ) throws Exception { InvokeFuture [[farther]] = conn . removeInvokeFuture ( requestId ) ; if ( [[farther]] != null ) { [[farther]] . putResponse ( commandFactory . createTimeoutResponse ( conn . getRemoteAddress ( ) ) ) ; [[farther]] . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } } } , timeoutMillis , TimeUnit . MILLISECONDS ) ; [[farther]] . addTimeout ( timeout ) ; conn . getChannel ( ) . writeAndFlush ( request ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture cf ) throws Exception { if ( ! cf . isSuccess ( ) ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , cf . cause ( ) ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , cf . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { InvokeFuture f = conn . removeInvokeFuture ( requestId ) ; if ( f != null ) { f . cancelTimeout ( ) ; f . putResponse ( commandFactory . createSendFailedResponse ( conn . getRemoteAddress ( ) , e ) ) ; f . tryAsyncExecuteInvokeCallbackAbnormally ( ) ; } logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( conn . getChannel ( ) ) , e ) ; } }
[[[[Nl]]]]: Invocation with callback .
--------------------------------------------- Result 421 ---------------------------------------------
Send a command . --> Send a command to the server --> Socre: 1.0

[[[[Adv]]]]: protected void [[oneway]] ( final Connection [[conn]] , final RemotingCommand [[request]] ) { try { [[conn]] . getChannel ( ) . writeAndFlush ( [[request]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[f]] ) throws Exception { if ( ! [[f]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , [[f]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[conn]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[conn]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .

[[[[Adv]]]]: protected void [[greaves]] ( final Connection [[cattle]] , final RemotingCommand [[motions]] ) { try { [[cattle]] . getChannel ( ) . writeAndFlush ( [[motions]] ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture [[et]] ) throws Exception { if ( ! [[et]] . isSuccess ( ) ) { logger . error ( "Invoke send failed. The address is {}" , RemotingUtil . parseRemoteAddress ( [[cattle]] . getChannel ( ) ) , [[et]] . cause ( ) ) ; } } } ) ; } catch ( Exception e ) { if ( null == [[cattle]] ) { logger . error ( "Conn is null" ) ; } else { logger . error ( "Exception caught when sending invocation. The address is {}" , RemotingUtil . parseRemoteAddress ( [[cattle]] . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Oneway invocation .
--------------------------------------------- Result 422 ---------------------------------------------
Converts an integer into a BitSet . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static BitSet toBitSet ( int value ) { if ( value > Byte . MAX_VALUE || value < Byte . MIN_VALUE ) { throw new IllegalArgumentException ( "The value " + value + " is out of byte range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } BitSet bs = new BitSet ( ) ; int index = 0 ; while ( value != 0 ) { if ( value % 2 != 0 ) { bs . set ( index ) ; } ++ index ; value = ( byte ) ( value >> 1 ) ; } return bs ; }
[[[[Nl]]]]: from byte to bit set
--------------------------------------------- Result 423 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 396 / 19 / 8 / 423:  42%|████▏     | 423/1000 [3:09:27<4:18:25, 26.87s/it][Succeeded / Failed / Skipped / Total] 396 / 19 / 8 / 423:  42%|████▏     | 424/1000 [3:09:27<4:17:22, 26.81s/it][Succeeded / Failed / Skipped / Total] 397 / 19 / 8 / 424:  42%|████▏     | 424/1000 [3:09:27<4:17:22, 26.81s/it][Succeeded / Failed / Skipped / Total] 397 / 19 / 8 / 424:  42%|████▎     | 425/1000 [3:09:28<4:16:21, 26.75s/it][Succeeded / Failed / Skipped / Total] 398 / 19 / 8 / 425:  42%|████▎     | 425/1000 [3:09:28<4:16:21, 26.75s/it][Succeeded / Failed / Skipped / Total] 398 / 19 / 8 / 425:  43%|████▎     | 426/1000 [3:09:31<4:15:22, 26.69s/it][Succeeded / Failed / Skipped / Total] 399 / 19 / 8 / 426:  43%|████▎     | 426/1000 [3:09:31<4:15:22, 26.69s/it][Succeeded / Failed / Skipped / Total] 399 / 19 / 8 / 426:  43%|████▎     | 427/1000 [3:09:33<4:14:22, 26.64s/it]Convert a bit set to a byte value . --> Calculate the number of bits . --> Socre: 1.0

[[[[Adv]]]]: public static byte [[toByte]] ( BitSet [[bs]] ) { int [[value]] = 0 ; for ( int [[i]] = 0 ; [[i]] < [[bs]] . length ( ) ; ++ [[i]] ) { if ( [[bs]] . get ( [[i]] ) ) { [[value]] += 1 << [[i]] ; } } if ( [[bs]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[value]] + " generated according to bit set " + [[bs]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[value]] ; }
[[[[Nl]]]]: from bit set to byte

[[[[Adv]]]]: public static byte [[punishments]] ( BitSet [[unc]] ) { int [[magnitude]] = 0 ; for ( int [[je]] = 0 ; [[je]] < [[unc]] . length ( ) ; ++ [[je]] ) { if ( [[unc]] . get ( [[je]] ) ) { [[magnitude]] += 1 << [[je]] ; } } if ( [[unc]] . length ( ) > 7 ) { throw new IllegalArgumentException ( "The byte value " + [[magnitude]] + " generated according to bit set " + [[unc]] + " is out of range, should be limited between [" + Byte . MIN_VALUE + "] to [" + Byte . MAX_VALUE + "]" ) ; } return ( byte ) [[magnitude]] ; }
[[[[Nl]]]]: from bit set to byte
--------------------------------------------- Result 424 ---------------------------------------------
Adds a reconnect task . --> Load the database . --> Socre: 1.0

[[[[Adv]]]]: public void [[addReconnectTask]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task

[[[[Adv]]]]: public void [[loaders]] ( Url url ) { ReconnectTask task = new ReconnectTask ( ) ; task . url = url ; tasks . add ( task ) ; }
[[[[Nl]]]]: add reconnect task
--------------------------------------------- Result 425 ---------------------------------------------
Stop the process . --> Stops the process . --> Socre: 1.0

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "[[False]]" != "[[False]]" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[canceled]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread

[[[[Adv]]]]: public void stop ( ) { if ( ! this . started ) { return ; } this . started = "[[Wrong]]" != "[[Wrong]]" ; healConnectionThreads . interrupt ( ) ; this . tasks . clear ( ) ; this . [[revoke]] . clear ( ) ; }
[[[[Nl]]]]: stop reconnect thread
--------------------------------------------- Result 426 ---------------------------------------------
Filter a list of connections --> Filters and returns a map with the new connection status --> Socre: 1.0

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[connections]] ) { List < Connection > [[serviceOnConnections]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[filteredConnections]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connections]] ) { String [[serviceStatus]] = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( [[serviceStatus]] != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[serviceOnConnections]] . add ( connection ) ; } } [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_ON , [[serviceOnConnections]] ) ; [[filteredConnections]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[filteredConnections]] ; }
[[[[Nl]]]]: Filter connections to monitor

[[[[Adv]]]]: @ Override public Map < String , List < Connection > > filter ( List < Connection > [[connection]] ) { List < Connection > [[experiment]] = new ArrayList < Connection > ( ) ; List < Connection > serviceOffConnections = new ArrayList < Connection > ( ) ; Map < String , List < Connection > > [[barnyard]] = new ConcurrentHashMap < String , List < Connection > > ( ) ; for ( Connection connection : [[connection]] ) { String [[ozeki]] = ( String ) connection . getAttribute ( Configs . CONN_SERVICE_STATUS ) ; if ( [[ozeki]] != null ) { if ( connection . isInvokeFutureMapFinish ( ) && ! freshSelectConnections . containsValue ( connection ) ) { serviceOffConnections . add ( connection ) ; } } else { [[experiment]] . add ( connection ) ; } } [[barnyard]] . put ( Configs . CONN_SERVICE_STATUS_ON , [[experiment]] ) ; [[barnyard]] . put ( Configs . CONN_SERVICE_STATUS_OFF , serviceOffConnections ) ; return [[barnyard]] ; }
[[[[Nl]]]]: Filter connections to monitor
--------------------------------------------- Result 427 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 400 / 19 / 8 / 427:  43%|████▎     | 427/1000 [3:09:33<4:14:22, 26.64s/it][Succeeded / Failed / Skipped / Total] 400 / 19 / 8 / 427:  43%|████▎     | 428/1000 [3:09:39<4:13:28, 26.59s/it][Succeeded / Failed / Skipped / Total] 401 / 19 / 8 / 428:  43%|████▎     | 428/1000 [3:09:39<4:13:28, 26.59s/it][Succeeded / Failed / Skipped / Total] 401 / 19 / 8 / 428:  43%|████▎     | 429/1000 [3:09:39<4:12:26, 26.53s/it][Succeeded / Failed / Skipped / Total] 401 / 19 / 9 / 429:  43%|████▎     | 429/1000 [3:09:39<4:12:26, 26.53s/it][Succeeded / Failed / Skipped / Total] 401 / 19 / 9 / 429:  43%|████▎     | 430/1000 [3:09:41<4:11:26, 26.47s/it][Succeeded / Failed / Skipped / Total] 402 / 19 / 9 / 430:  43%|████▎     | 430/1000 [3:09:41<4:11:26, 26.47s/it][Succeeded / Failed / Skipped / Total] 403 / 19 / 9 / 431:  43%|████▎     | 431/1000 [3:09:41<4:10:25, 26.41s/it][Succeeded / Failed / Skipped / Total] 403 / 19 / 9 / 431:  43%|████▎     | 432/1000 [3:09:42<4:09:26, 26.35s/it]Monitor the connection pools . --> This method monitors the connection pools --> Socre: 1.0

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[iter]] = connPools . entrySet ( ) . iterator ( ) ; while ( [[iter]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[iter]] . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off

[[[[Adv]]]]: @ Override public void monitor ( Map < String , RunStateRecordedFutureTask < ConnectionPool > > connPools ) { try { if ( null != connPools && ! connPools . isEmpty ( ) ) { Iterator < Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > > [[whooping]] = connPools . entrySet ( ) . iterator ( ) ; while ( [[whooping]] . hasNext ( ) ) { Map . Entry < String , RunStateRecordedFutureTask < ConnectionPool > > entry = [[whooping]] . next ( ) ; String poolKey = entry . getKey ( ) ; ConnectionPool pool = FutureTaskUtil . getFutureTaskResult ( entry . getValue ( ) , logger ) ; List < Connection > connections = pool . getAll ( ) ; Map < String , List < Connection > > filteredConnectons = this . filter ( connections ) ; List < Connection > serviceOnConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_ON ) ; List < Connection > serviceOffConnections = filteredConnectons . get ( Configs . CONN_SERVICE_STATUS_OFF ) ; if ( serviceOnConnections . size ( ) > CONNECTION_THRESHOLD ) { Connection freshSelectConnect = serviceOnConnections . get ( random . nextInt ( serviceOnConnections . size ( ) ) ) ; freshSelectConnect . setAttribute ( Configs . CONN_SERVICE_STATUS , Configs . CONN_SERVICE_STATUS_OFF ) ; Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; freshSelectConnections . put ( poolKey , freshSelectConnect ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } else { if ( freshSelectConnections . containsKey ( poolKey ) ) { Connection lastSelectConnect = freshSelectConnections . remove ( poolKey ) ; closeFreshSelectConnections ( lastSelectConnect , serviceOffConnections ) ; } if ( logger . isInfoEnabled ( ) ) { logger . info ( "the size of serviceOnConnections [{}] reached CONNECTION_THRESHOLD [{}]." , serviceOnConnections . size ( ) , CONNECTION_THRESHOLD ) ; } } for ( Connection offConn : serviceOffConnections ) { if ( offConn . isFine ( ) ) { offConn . close ( ) ; } } } } } catch ( Exception e ) { logger . error ( "ScheduledDisconnectStrategy monitor error" , e ) ; } }
[[[[Nl]]]]: Monitor connections and close connections with status is off
--------------------------------------------- Result 428 ---------------------------------------------
Helper method to close fresh connections --> Add a work day . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeFreshSelectConnections]] ( Connection [[lastSelectConnect]] , List < Connection > [[serviceOffConnections]] ) throws InterruptedException { if ( null != [[lastSelectConnect]] ) { if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[lastSelectConnect]] . isInvokeFutureMapFinish ( ) ) { [[serviceOffConnections]] . add ( [[lastSelectConnect]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[lastSelectConnect]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections

[[[[Adv]]]]: private void [[paddled]] ( Connection [[workday]] , List < Connection > [[precocious]] ) throws InterruptedException { if ( null != [[workday]] ) { if ( [[workday]] . isInvokeFutureMapFinish ( ) ) { [[precocious]] . add ( [[workday]] ) ; } else { Thread . sleep ( RETRY_DETECT_PERIOD ) ; if ( [[workday]] . isInvokeFutureMapFinish ( ) ) { [[precocious]] . add ( [[workday]] ) ; } else { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Address={} won't close at this schedule turn" , RemotingUtil . parseRemoteAddress ( [[workday]] . getChannel ( ) ) ) ; } } } } }
[[[[Nl]]]]: close the connection of the fresh select connections
--------------------------------------------- Result 429 ---------------------------------------------
Gets a boolean . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean getBool ( String key , String defaultValue ) { return Boolean . parseBoolean ( System . getProperty ( key , defaultValue ) ) ; }
[[[[Nl]]]]: ~~~ public helper methods to retrieve system property
--------------------------------------------- Result 430 ---------------------------------------------
Logs a formatted info message . --> Prints information about the address --> Socre: 1.0

[[[[Adv]]]]: private void [[infoLog]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log

[[[[Adv]]]]: private void [[arranges]] ( String format , String addr ) { if ( logger . isInfoEnabled ( ) ) { if ( StringUtils . isNotEmpty ( addr ) ) { logger . info ( format , addr ) ; } else { logger . info ( format , "UNKNOWN-ADDR" ) ; } } }
[[[[Nl]]]]: print info log
--------------------------------------------- Result 431 ---------------------------------------------
Converts the request to a remoting command . --> Create flapper for flapper --> Socre: 1.0

[[[[Adv]]]]: protected RemotingCommand [[toRemotingCommand]] ( Object [[request]] , Connection conn , InvokeContext invokeContext , int [[timeoutMillis]] ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[request]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .

[[[[Adv]]]]: protected RemotingCommand [[flapper]] ( Object [[demand]] , Connection conn , InvokeContext invokeContext , int [[perceval]] ) throws SerializationException { RpcRequestCommand command = this . getCommandFactory ( ) . createRequestCommand ( [[demand]] ) ; if ( null != invokeContext ) {
[[[[Nl]]]]: Convert application request object to remoting request command .
--------------------------------------------- Result 432 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 404 / 19 / 9 / 432:  43%|████▎     | 432/1000 [3:09:42<4:09:26, 26.35s/it][Succeeded / Failed / Skipped / Total] 405 / 19 / 9 / 433:  43%|████▎     | 433/1000 [3:10:07<4:08:57, 26.35s/it][Succeeded / Failed / Skipped / Total] 405 / 19 / 9 / 433:  43%|████▎     | 434/1000 [3:10:07<4:07:57, 26.28s/it][Succeeded / Failed / Skipped / Total] 406 / 19 / 9 / 434:  43%|████▎     | 434/1000 [3:10:07<4:07:57, 26.28s/it][Succeeded / Failed / Skipped / Total] 406 / 19 / 9 / 434:  44%|████▎     | 435/1000 [3:10:08<4:06:58, 26.23s/it][Succeeded / Failed / Skipped / Total] 407 / 19 / 9 / 435:  44%|████▎     | 435/1000 [3:10:08<4:06:58, 26.23s/it][Succeeded / Failed / Skipped / Total] 408 / 19 / 9 / 436:  44%|████▎     | 436/1000 [3:10:08<4:05:58, 26.17s/it][Succeeded / Failed / Skipped / Total] 408 / 19 / 9 / 436:  44%|████▎     | 437/1000 [3:10:13<4:05:04, 26.12s/it][Succeeded / Failed / Skipped / Total] 409 / 19 / 9 / 437:  44%|████▎     | 437/1000 [3:10:13<4:05:04, 26.12s/it][Succeeded / Failed / Skipped / Total] 410 / 19 / 9 / 438:  44%|████▍     | 438/1000 [3:10:14<4:04:05, 26.06s/it][Succeeded / Failed / Skipped / Total] 410 / 19 / 9 / 438:  44%|████▍     | 439/1000 [3:10:15<4:03:08, 26.00s/it][Succeeded / Failed / Skipped / Total] 411 / 19 / 9 / 439:  44%|████▍     | 439/1000 [3:10:15<4:03:08, 26.00s/it]Returns true if the request is a request timeout . --> Determines if the RPC should be done . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isRequestTimeout]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[True]]" == "[[True]]" ; } return "[[False]]" != "[[False]]" ; }
[[[[Nl]]]]: whether this request already timeout

[[[[Adv]]]]: public boolean [[rob]] ( ) { if ( this . timeout > 0 && ( this . rpcCommandType != RpcCommandType . REQUEST_ONEWAY ) && ( System . currentTimeMillis ( ) - this . arriveTimestamp ) > this . timeout ) { return "[[Decent]]" == "[[Decent]]" ; } return "[[Forgeries]]" != "[[Forgeries]]" ; }
[[[[Nl]]]]: whether this request already timeout
--------------------------------------------- Result 433 ---------------------------------------------
Gets a random connection . --> Returns the renumber . --> Socre: 1.0

[[[[Adv]]]]: private Connection [[randomGet]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection [[result]] = null ; while ( ( [[result]] == null || ! [[result]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[result]] = conns . get ( this . [[random]] . nextInt ( size ) ) ; } if ( [[result]] != null && ! [[result]] . isFine ( ) ) { [[result]] = null ; } return [[result]] ; }
[[[[Nl]]]]: get one connection randomly

[[[[Adv]]]]: private Connection [[renouncing]] ( List < Connection > conns ) { if ( null == conns || conns . isEmpty ( ) ) { return null ; } int size = conns . size ( ) ; int tries = 0 ; Connection [[conquest]] = null ; while ( ( [[conquest]] == null || ! [[conquest]] . isFine ( ) ) && tries ++ < MAX_TIMES ) { [[conquest]] = conns . get ( this . [[disorderly]] . nextInt ( size ) ) ; } if ( [[conquest]] != null && ! [[conquest]] . isFine ( ) ) { [[conquest]] = null ; } return [[conquest]] ; }
[[[[Nl]]]]: get one connection randomly
--------------------------------------------- Result 434 ---------------------------------------------
Get user processor by class name --> Returns UserProcessor --> Socre: 1.0

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[className]] ) { return StringUtils . isBlank ( [[className]] ) ? null : this . [[userProcessors]] . get ( [[className]] ) ; }
[[[[Nl]]]]: Get user processor for class name .

[[[[Adv]]]]: public UserProcessor < ? > getUserProcessor ( String [[alim]] ) { return StringUtils . isBlank ( [[alim]] ) ? null : this . [[latif]] . get ( [[alim]] ) ; }
[[[[Nl]]]]: Get user processor for class name .
--------------------------------------------- Result 435 ---------------------------------------------
Returns the value of the given key or the default if the key is not found . --> Gets the environment variable . --> Socre: 1.0

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[context]] . get ( key ) != null ? ( T ) this . [[context]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found

[[[[Adv]]]]: @ SuppressWarnings ( "unchecked" ) public < T > T get ( String key , T defaultIfNotFound ) { return this . [[environs]] . get ( key ) != null ? ( T ) this . [[environs]] . get ( key ) : defaultIfNotFound ; }
[[[[Nl]]]]: get and use default if not found
--------------------------------------------- Result 436 ---------------------------------------------
Returns the value for the specified key . --> Gets the detailed portion of the properties . --> Socre: 1.0

[[[[Adv]]]]: public String [[getProperty]] ( String [[key]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[key]] ) ; }
[[[[Nl]]]]: Get property value according to property key

[[[[Adv]]]]: public String [[thalia]] ( String [[substantial]] ) { if ( properties == null ) { return null ; } return properties . getProperty ( [[substantial]] ) ; }
[[[[Nl]]]]: Get property value according to property key
--------------------------------------------- Result 437 ---------------------------------------------
Deserialize response object . --> get RpcResponse --> Socre: 1.0

[[[[Adv]]]]: private static Object [[toResponseObject]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[response]] = ( RpcResponseCommand ) [[responseCommand]] ; [[response]] . deserialize ( ) ; return [[response]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .

[[[[Adv]]]]: private static Object [[scr]] ( ResponseCommand [[messin]] ) throws CodecException { RpcResponseCommand [[remarks]] = ( RpcResponseCommand ) [[messin]] ; [[remarks]] . deserialize ( ) ; return [[remarks]] . getResponseObject ( ) ; }
[[[[Nl]]]]: Convert remoting response command to application response object .
--------------------------------------------- Result 438 ---------------------------------------------
Resolve response object . --> return null --> Socre: 1.0

[[[[Adv]]]]: public static Object [[resolveResponseObject]] ( ResponseCommand [[responseCommand]] , String [[addr]] ) throws RemotingException { preProcess ( [[responseCommand]] , [[addr]] ) ; if ( [[responseCommand]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[responseCommand]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[responseCommand]] . getResponseStatus ( ) , [[addr]] , [[responseCommand]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[responseCommand]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[responseCommand]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .

[[[[Adv]]]]: public static Object [[clank]] ( ResponseCommand [[elektra]] , String [[knocked]] ) throws RemotingException { preProcess ( [[elektra]] , [[knocked]] ) ; if ( [[elektra]] . getResponseStatus ( ) == ResponseStatus . SUCCESS ) { return toResponseObject ( [[elektra]] ) ; } else { String msg = String . format ( "Rpc invocation exception: %s, the address is %s, id=%s" , [[elektra]] . getResponseStatus ( ) , [[knocked]] , [[elektra]] . getId ( ) ) ; logger . warn ( msg ) ; if ( [[elektra]] . getCause ( ) != null ) { throw new InvokeException ( msg , [[elektra]] . getCause ( ) ) ; } else { throw new InvokeException ( msg + ", please check the server log for more." ) ; } } }
[[[[Nl]]]]: Analyze the response command and generate the response object .
--------------------------------------------- Result 439 ---------------------------------------------
Converts a response command to a Throwable --> Ables an exception --> Socre: 1.0

[[[[Adv]]]]: private static Throwable [[toThrowable]] ( ResponseCommand [[responseCommand]] ) throws CodecException { RpcResponseCommand [[resp]] = ( RpcResponseCommand ) [[responseCommand]] ; [[resp]] . deserialize ( ) ; Object [[ex]] = [[resp]] . getResponseObject ( ) ; if ( [[ex]] != null && [[ex]] instanceof Throwable ) { return ( Throwable ) [[ex]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .

[[[[Adv]]]]: private static Throwable [[abuelo]] ( ResponseCommand [[courageously]] ) throws CodecException { RpcResponseCommand [[awoken]] = ( RpcResponseCommand ) [[courageously]] ; [[awoken]] . deserialize ( ) ; Object [[past]] = [[awoken]] . getResponseObject ( ) ; if ( [[past]] != null && [[past]] instanceof Throwable ) { return ( Throwable ) [[past]] ; } return null ; }
[[[[Nl]]]]: Convert remoting response command to throwable if it is a throwable otherwise return null .
--------------------------------------------- Result 440 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 412 / 19 / 9 / 440:  44%|████▍     | 440/1000 [3:10:15<4:02:09, 25.94s/it][Succeeded / Failed / Skipped / Total] 412 / 19 / 9 / 440:  44%|████▍     | 441/1000 [3:10:17<4:01:12, 25.89s/it][Succeeded / Failed / Skipped / Total] 413 / 19 / 9 / 441:  44%|████▍     | 441/1000 [3:10:17<4:01:12, 25.89s/it][Succeeded / Failed / Skipped / Total] 414 / 19 / 9 / 442:  44%|████▍     | 442/1000 [3:10:20<4:00:17, 25.84s/it][Succeeded / Failed / Skipped / Total] 414 / 19 / 9 / 442:  44%|████▍     | 443/1000 [3:10:24<3:59:24, 25.79s/it][Succeeded / Failed / Skipped / Total] 415 / 19 / 9 / 443:  44%|████▍     | 443/1000 [3:10:24<3:59:24, 25.79s/it][Succeeded / Failed / Skipped / Total] 416 / 19 / 9 / 444:  44%|████▍     | 444/1000 [3:10:27<3:58:30, 25.74s/it][Succeeded / Failed / Skipped / Total] 416 / 19 / 9 / 444:  44%|████▍     | 445/1000 [3:10:39<3:57:47, 25.71s/it][Succeeded / Failed / Skipped / Total] 417 / 19 / 9 / 445:  44%|████▍     | 445/1000 [3:10:39<3:57:47, 25.71s/it][Succeeded / Failed / Skipped / Total] 417 / 19 / 9 / 445:  45%|████▍     | 446/1000 [3:10:42<3:56:53, 25.66s/it][Succeeded / Failed / Skipped / Total] 418 / 19 / 9 / 446:  45%|████▍     | 446/1000 [3:10:42<3:56:53, 25.66s/it][Succeeded / Failed / Skipped / Total] 418 / 19 / 9 / 446:  45%|████▍     | 447/1000 [3:10:53<3:56:09, 25.62s/it]Detail error message . --> Renders a barcode --> Socre: 1.0

[[[[Adv]]]]: private static String [[detailErrMsg]] ( String [[clientErrMsg]] , ResponseCommand [[responseCommand]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[responseCommand]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[clientErrMsg]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[clientErrMsg]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command

[[[[Adv]]]]: private static String [[barret]] ( String [[carve]] , ResponseCommand [[art]] ) { RpcResponseCommand resp = ( RpcResponseCommand ) [[art]] ; if ( StringUtils . isNotBlank ( resp . getErrorMsg ( ) ) ) { return String . format ( "%s, ServerErrorMsg:%s" , [[carve]] , resp . getErrorMsg ( ) ) ; } else { return String . format ( "%s, ServerErrorMsg:null" , [[carve]] ) ; } }
[[[[Nl]]]]: Detail your error msg with the error msg returned from response command
--------------------------------------------- Result 441 ---------------------------------------------
Print the connection trace log . --> Convenience method . --> Socre: 1.0

[[[[Adv]]]]: public static void [[printConnectionTraceLog]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log

[[[[Adv]]]]: public static void [[swordsman]] ( Logger logger , String traceId , InvokeContext invokeContext ) { String sourceIp = invokeContext . get ( InvokeContext . CLIENT_LOCAL_IP ) ; Integer sourcePort = invokeContext . get ( InvokeContext . CLIENT_LOCAL_PORT ) ; String targetIp = invokeContext . get ( InvokeContext . CLIENT_REMOTE_IP ) ; Integer targetPort = invokeContext . get ( InvokeContext . CLIENT_REMOTE_PORT ) ; StringBuilder logMsg = new StringBuilder ( ) ; logMsg . append ( traceId ) . append ( "," ) ; logMsg . append ( sourceIp ) . append ( "," ) ; logMsg . append ( sourcePort ) . append ( "," ) ; logMsg . append ( targetIp ) . append ( "," ) ; logMsg . append ( targetPort ) ; if ( logger . isInfoEnabled ( ) ) { logger . info ( logMsg . toString ( ) ) ; } }
[[[[Nl]]]]: print trace log
--------------------------------------------- Result 442 ---------------------------------------------
Creates an event loop . --> Creates a new EventLoopGroup --> Socre: 1.0

[[[[Adv]]]]: public static EventLoopGroup [[newEventLoopGroup]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .

[[[[Adv]]]]: public static EventLoopGroup [[pettiness]] ( int nThreads , ThreadFactory threadFactory ) { return epollEnabled ? new EpollEventLoopGroup ( nThreads , threadFactory ) : new NioEventLoopGroup ( nThreads , threadFactory ) ; }
[[[[Nl]]]]: Create the right event loop according to current platform and system property fallback to NIO when epoll not enabled .
--------------------------------------------- Result 443 ---------------------------------------------
Parse the remote address . --> Thrown when unable to understand --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[channel]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .

[[[[Adv]]]]: public static String [[mournful]] ( final Channel [[avenues]] ) { if ( null == [[avenues]] ) { return StringUtils . EMPTY ; } final SocketAddress remote = [[avenues]] . remoteAddress ( ) ; return doParse ( remote != null ? remote . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the remote address of the channel .
--------------------------------------------- Result 444 ---------------------------------------------
Creates an RpcServerException from a Throwable . --> Wrap a ThrowableException into a RpcServerException --> Socre: 1.0

[[[[Adv]]]]: private RpcServerException [[createServerException]] ( Throwable [[t]] , String [[errMsg]] ) { String [[formattedErrMsg]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[t]] . getClass ( ) . getName ( ) , [[t]] . getMessage ( ) , [[errMsg]] ) ; RpcServerException e = new RpcServerException ( [[formattedErrMsg]] ) ; e . setStackTrace ( [[t]] . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .

[[[[Adv]]]]: private RpcServerException [[stalkers]] ( Throwable [[could]] , String [[humboldt]] ) { String [[mulcahy]] = String . format ( "[Server]OriginErrorMsg: %s: %s. AdditionalErrorMsg: %s" , [[could]] . getClass ( ) . getName ( ) , [[could]] . getMessage ( ) , [[humboldt]] ) ; RpcServerException e = new RpcServerException ( [[mulcahy]] ) ; e . setStackTrace ( [[could]] . getStackTrace ( ) ) ; return e ; }
[[[[Nl]]]]: create server exception using error msg and fill the stack trace using the stack trace of throwable .
--------------------------------------------- Result 445 ---------------------------------------------
Gets the remote IP address . --> Get toast address --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .

[[[[Adv]]]]: public static String [[toast]] ( final Channel [[lane]] ) { if ( null == [[lane]] ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) [[lane]] . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote host ip of the channel .
--------------------------------------------- Result 446 ---------------------------------------------
Returns the hostname of the remote host . --> Get host name --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseRemoteHostName]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .

[[[[Adv]]]]: public static String [[tar]] ( final Channel channel ) { if ( null == channel ) { return StringUtils . EMPTY ; } final InetSocketAddress remote = ( InetSocketAddress ) channel . remoteAddress ( ) ; if ( remote != null ) { return remote . getAddress ( ) . getHostName ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the remote hostname of the channel .
--------------------------------------------- Result 447 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 419 / 19 / 9 / 447:  45%|████▍     | 447/1000 [3:10:53<3:56:09, 25.62s/it][Succeeded / Failed / Skipped / Total] 419 / 19 / 9 / 447:  45%|████▍     | 448/1000 [3:10:55<3:55:15, 25.57s/it][Succeeded / Failed / Skipped / Total] 420 / 19 / 9 / 448:  45%|████▍     | 448/1000 [3:10:55<3:55:15, 25.57s/it][Succeeded / Failed / Skipped / Total] 420 / 19 / 9 / 448:  45%|████▍     | 449/1000 [3:12:17<3:55:59, 25.70s/it][Succeeded / Failed / Skipped / Total] 421 / 19 / 9 / 449:  45%|████▍     | 449/1000 [3:12:17<3:55:59, 25.70s/it][Succeeded / Failed / Skipped / Total] 421 / 19 / 9 / 449:  45%|████▌     | 450/1000 [3:12:23<3:55:09, 25.65s/it][Succeeded / Failed / Skipped / Total] 422 / 19 / 9 / 450:  45%|████▌     | 450/1000 [3:12:23<3:55:09, 25.65s/it][Succeeded / Failed / Skipped / Total] 422 / 19 / 9 / 450:  45%|████▌     | 451/1000 [3:12:28<3:54:17, 25.61s/it][Succeeded / Failed / Skipped / Total] 423 / 19 / 9 / 451:  45%|████▌     | 451/1000 [3:12:28<3:54:17, 25.61s/it][Succeeded / Failed / Skipped / Total] 423 / 19 / 9 / 451:  45%|████▌     | 452/1000 [3:12:30<3:53:23, 25.55s/it][Succeeded / Failed / Skipped / Total] 424 / 19 / 9 / 452:  45%|████▌     | 452/1000 [3:12:30<3:53:23, 25.55s/it][Succeeded / Failed / Skipped / Total] 424 / 19 / 9 / 452:  45%|████▌     | 453/1000 [3:12:33<3:52:31, 25.51s/it][Succeeded / Failed / Skipped / Total] 425 / 19 / 9 / 453:  45%|████▌     | 453/1000 [3:12:33<3:52:31, 25.51s/it][Succeeded / Failed / Skipped / Total] 425 / 19 / 9 / 453:  45%|████▌     | 454/1000 [3:12:58<3:52:04, 25.50s/it][Succeeded / Failed / Skipped / Total] 426 / 19 / 9 / 454:  45%|████▌     | 454/1000 [3:12:58<3:52:04, 25.50s/it][Succeeded / Failed / Skipped / Total] 426 / 19 / 9 / 454:  46%|████▌     | 455/1000 [3:12:59<3:51:09, 25.45s/it]Returns the local address of the given channel . --> Return adage adage --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalAddress]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final SocketAddress [[local]] = [[channel]] . localAddress ( ) ; return doParse ( [[local]] != null ? [[local]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .

[[[[Adv]]]]: public static String [[adage]] ( final Channel [[mancha]] ) { if ( null == [[mancha]] ) { return StringUtils . EMPTY ; } final SocketAddress [[municipality]] = [[mancha]] . localAddress ( ) ; return doParse ( [[municipality]] != null ? [[municipality]] . toString ( ) . trim ( ) : StringUtils . EMPTY ) ; }
[[[[Nl]]]]: Parse the local address of the channel .
--------------------------------------------- Result 448 ---------------------------------------------
Gets the local IP address . --> Returns rosenum --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseLocalIP]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) [[channel]] . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .

[[[[Adv]]]]: public static String [[rosenblum]] ( final Channel [[plumbing]] ) { if ( null == [[plumbing]] ) { return StringUtils . EMPTY ; } final InetSocketAddress [[site]] = ( InetSocketAddress ) [[plumbing]] . localAddress ( ) ; if ( [[site]] != null ) { return [[site]] . getAddress ( ) . getHostAddress ( ) ; } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the local host ip of the channel .
--------------------------------------------- Result 449 ---------------------------------------------
Gets the remote port . --> Checks to see if it is ababa --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseRemotePort]] ( final Channel [[channel]] ) { if ( null == [[channel]] ) { return - 1 ; } final InetSocketAddress [[remote]] = ( InetSocketAddress ) [[channel]] . remoteAddress ( ) ; if ( [[remote]] != null ) { return [[remote]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .

[[[[Adv]]]]: public static int [[ababa]] ( final Channel [[avenues]] ) { if ( null == [[avenues]] ) { return - 1 ; } final InetSocketAddress [[vaguely]] = ( InetSocketAddress ) [[avenues]] . remoteAddress ( ) ; if ( [[vaguely]] != null ) { return [[vaguely]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the remote host port of the channel .
--------------------------------------------- Result 450 ---------------------------------------------
Returns the local port of the given channel . --> getter for currency --> Socre: 1.0

[[[[Adv]]]]: public static int [[parseLocalPort]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[local]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[local]] != null ) { return [[local]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .

[[[[Adv]]]]: public static int [[franciscan]] ( final Channel channel ) { if ( null == channel ) { return - 1 ; } final InetSocketAddress [[arrondissement]] = ( InetSocketAddress ) channel . localAddress ( ) ; if ( [[arrondissement]] != null ) { return [[arrondissement]] . getPort ( ) ; } return - 1 ; }
[[[[Nl]]]]: Parse the local host port of the channel .
--------------------------------------------- Result 451 ---------------------------------------------
Adds a connection . --> Adds the given relationships . --> Socre: 1.0

[[[[Adv]]]]: public void [[add]] ( Connection [[connection]] ) { markAccess ( ) ; if ( null == [[connection]] ) { return ; } boolean res = this . [[conns]] . addIfAbsent ( [[connection]] ) ; if ( res ) { [[connection]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection

[[[[Adv]]]]: public void [[adds]] ( Connection [[relationships]] ) { markAccess ( ) ; if ( null == [[relationships]] ) { return ; } boolean res = this . [[foie]] . addIfAbsent ( [[relationships]] ) ; if ( res ) { [[relationships]] . increaseRef ( ) ; } }
[[[[Nl]]]]: add a connection
--------------------------------------------- Result 452 ---------------------------------------------
Remove and close a connection . --> Remove ties . --> Socre: 1.0

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[connection]] ) { if ( null == [[connection]] ) { return ; } boolean res = this . conns . remove ( [[connection]] ) ; if ( res ) { [[connection]] . decreaseRef ( ) ; } if ( [[connection]] . noRef ( ) ) { [[connection]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection

[[[[Adv]]]]: public void removeAndTryClose ( Connection [[ties]] ) { if ( null == [[ties]] ) { return ; } boolean res = this . conns . remove ( [[ties]] ) ; if ( res ) { [[ties]] . decreaseRef ( ) ; } if ( [[ties]] . noRef ( ) ) { [[ties]] . close ( ) ; } }
[[[[Nl]]]]: removeAndTryClose a connection
--------------------------------------------- Result 453 ---------------------------------------------
Gets the current connection . --> Convenience method . --> Socre: 1.0

[[[[Adv]]]]: public Connection [[get]] ( ) { markAccess ( ) ; if ( null != this . [[conns]] ) { List < Connection > [[snapshot]] = new ArrayList < Connection > ( this . [[conns]] ) ; if ( [[snapshot]] . size ( ) > 0 ) { return this . strategy . select ( [[snapshot]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection

[[[[Adv]]]]: public Connection [[achieving]] ( ) { markAccess ( ) ; if ( null != this . [[villeneuve]] ) { List < Connection > [[instantaneously]] = new ArrayList < Connection > ( this . [[villeneuve]] ) ; if ( [[instantaneously]] . size ( ) > 0 ) { return this . strategy . select ( [[instantaneously]] ) ; } else { return null ; } } else { return null ; } }
[[[[Nl]]]]: get a connection
--------------------------------------------- Result 454 ---------------------------------------------
Register a custom serializer for the given class . --> will throw unchecked exception --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( String [[className]] , CustomSerializer [[serializer]] ) { CustomSerializer [[prevSerializer]] = classCustomSerializer . putIfAbsent ( [[className]] , [[serializer]] ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[className]] + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .

[[[[Adv]]]]: public static void [[flourishes]] ( String [[pornographic]] , CustomSerializer [[hazama]] ) { CustomSerializer [[hathor]] = classCustomSerializer . putIfAbsent ( [[pornographic]] , [[hazama]] ) ; if ( [[hathor]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for class: " + [[pornographic]] + ", the custom serializer is: " + [[hathor]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for class name .
--------------------------------------------- Result 455 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 427 / 19 / 9 / 455:  46%|████▌     | 455/1000 [3:12:59<3:51:09, 25.45s/it][Succeeded / Failed / Skipped / Total] 427 / 19 / 9 / 455:  46%|████▌     | 456/1000 [3:13:22<3:50:41, 25.44s/it][Succeeded / Failed / Skipped / Total] 428 / 19 / 9 / 456:  46%|████▌     | 456/1000 [3:13:22<3:50:41, 25.44s/it][Succeeded / Failed / Skipped / Total] 428 / 19 / 9 / 456:  46%|████▌     | 457/1000 [3:13:26<3:49:51, 25.40s/it][Succeeded / Failed / Skipped / Total] 429 / 19 / 9 / 457:  46%|████▌     | 457/1000 [3:13:27<3:49:51, 25.40s/it][Succeeded / Failed / Skipped / Total] 429 / 19 / 9 / 457:  46%|████▌     | 458/1000 [3:13:29<3:48:58, 25.35s/it][Succeeded / Failed / Skipped / Total] 430 / 19 / 9 / 458:  46%|████▌     | 458/1000 [3:13:29<3:48:58, 25.35s/it][Succeeded / Failed / Skipped / Total] 430 / 19 / 9 / 458:  46%|████▌     | 459/1000 [3:13:32<3:48:07, 25.30s/it][Succeeded / Failed / Skipped / Total] 431 / 19 / 9 / 459:  46%|████▌     | 459/1000 [3:13:32<3:48:07, 25.30s/it][Succeeded / Failed / Skipped / Total] 431 / 19 / 9 / 459:  46%|████▌     | 460/1000 [3:13:38<3:47:19, 25.26s/it][Succeeded / Failed / Skipped / Total] 432 / 19 / 9 / 460:  46%|████▌     | 460/1000 [3:13:38<3:47:19, 25.26s/it][Succeeded / Failed / Skipped / Total] 432 / 19 / 9 / 460:  46%|████▌     | 461/1000 [3:13:40<3:46:26, 25.21s/it][Succeeded / Failed / Skipped / Total] 433 / 19 / 9 / 461:  46%|████▌     | 461/1000 [3:13:40<3:46:26, 25.21s/it][Succeeded / Failed / Skipped / Total] 433 / 19 / 9 / 461:  46%|████▌     | 462/1000 [3:13:40<3:45:32, 25.15s/it]Parse socket address to host IP address . --> Get steno string --> Socre: 1.0

[[[[Adv]]]]: public static String [[parseSocketAddressToHostIp]] ( SocketAddress [[socketAddress]] ) { final InetSocketAddress [[addrs]] = ( InetSocketAddress ) [[socketAddress]] ; if ( [[addrs]] != null ) { InetAddress [[addr]] = [[addrs]] . getAddress ( ) ; if ( null != [[addr]] ) { return [[addr]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .

[[[[Adv]]]]: public static String [[steno]] ( SocketAddress [[adorned]] ) { final InetSocketAddress [[lemmon]] = ( InetSocketAddress ) [[adorned]] ; if ( [[lemmon]] != null ) { InetAddress [[campaigner]] = [[lemmon]] . getAddress ( ) ; if ( null != [[campaigner]] ) { return [[campaigner]] . getHostAddress ( ) ; } } return StringUtils . EMPTY ; }
[[[[Nl]]]]: Parse the host ip of socket address .
--------------------------------------------- Result 456 ---------------------------------------------
Get custom serializer by class name --> returns null if not found --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( String [[className]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[className]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .

[[[[Adv]]]]: public static CustomSerializer [[negatives]] ( String [[habsburg]] ) { if ( ! classCustomSerializer . isEmpty ( ) ) { return classCustomSerializer . get ( [[habsburg]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for class name .
--------------------------------------------- Result 457 ---------------------------------------------
Register a default processor --> Registers a RemotingProcessor --> Socre: 1.0

[[[[Adv]]]]: public void [[registerDefaultProcessor]] ( RemotingProcessor < ? > [[processor]] ) { if ( this . [[defaultProcessor]] == null ) { this . [[defaultProcessor]] = [[processor]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[defaultProcessor]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .

[[[[Adv]]]]: public void [[interpol]] ( RemotingProcessor < ? > [[motherboard]] ) { if ( this . [[deserved]] == null ) { this . [[deserved]] = [[motherboard]] ; } else { throw new IllegalStateException ( "The defaultProcessor has already been registered: " + this . [[deserved]] . getClass ( ) ) ; } }
[[[[Nl]]]]: Register the default processor to process command with no specific processor registered .
--------------------------------------------- Result 458 ---------------------------------------------
Start the connection monitor thread --> Starts the connection monitor . --> Socre: 1.0

[[[[Adv]]]]: public void [[start]] ( ) { long [[initialDelay]] = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask [[monitorTask]] = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( [[monitorTask]] , [[initialDelay]] , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task

[[[[Adv]]]]: public void [[begins]] ( ) { long [[scenario]] = ConfigManager . conn_monitor_initial_delay ( ) ; long period = ConfigManager . conn_monitor_period ( ) ; this . executor = new ScheduledThreadPoolExecutor ( 1 , new NamedThreadFactory ( "ConnectionMonitorThread" , "True" == "True" ) , new ThreadPoolExecutor . AbortPolicy ( ) ) ; MonitorTask [[casablanca]] = new MonitorTask ( ) ; this . executor . scheduleAtFixedRate ( [[casablanca]] , [[scenario]] , period , TimeUnit . MILLISECONDS ) ; }
[[[[Nl]]]]: Start schedule task
--------------------------------------------- Result 459 ---------------------------------------------
Check if the remote address is connected . --> Checks to see if the given difference between the given difference . --> Socre: 1.0

[[[[Adv]]]]: public boolean [[isConnected]] ( String [[remoteAddr]] ) { Url url = this . [[rpcRemoting]] . addressParser . parse ( [[remoteAddr]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected

[[[[Adv]]]]: public boolean [[southward]] ( String [[difference]] ) { Url url = this . [[repetition]] . addressParser . parse ( [[difference]] ) ; return this . isConnected ( url ) ; }
[[[[Nl]]]]: check whether a client address connected
--------------------------------------------- Result 460 ---------------------------------------------
Initialize write buffer water mark . --> helper method to get hamlets --> Socre: 1.0

[[[[Adv]]]]: private void [[initWriteBufferWaterMark]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . [[bootstrap]] . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark

[[[[Adv]]]]: private void [[hamlets]] ( ) { int lowWaterMark = this . netty_buffer_low_watermark ( ) ; int highWaterMark = this . netty_buffer_high_watermark ( ) ; if ( lowWaterMark > highWaterMark ) { throw new IllegalArgumentException ( String . format ( "[server side] bolt netty high water mark {%s} should not be smaller than low water mark {%s} bytes)" , highWaterMark , lowWaterMark ) ) ; } else { logger . warn ( "[server side] bolt netty low water mark is {} bytes, high water mark is {} bytes" , lowWaterMark , highWaterMark ) ; } this . [[statistically]] . childOption ( ChannelOption . WRITE_BUFFER_WATER_MARK , new WriteBufferWaterMark ( lowWaterMark , highWaterMark ) ) ; }
[[[[Nl]]]]: init netty write buffer water mark
--------------------------------------------- Result 461 ---------------------------------------------
Create a frame for the given opcode . --> Factory method for creating frames . --> Socre: 1.0

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[opcode]] ) { if ( [[opcode]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[opcode]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode

[[[[Adv]]]]: public static FramedataImpl1 get ( Opcode [[beatles]] ) { if ( [[beatles]] == null ) { throw new IllegalArgumentException ( "Supplied opcode cannot be null" ) ; } switch ( [[beatles]] ) { case PING : return new PingFrame ( ) ; case PONG : return new PongFrame ( ) ; case TEXT : return new TextFrame ( ) ; case BINARY : return new BinaryFrame ( ) ; case CLOSING : return new CloseFrame ( ) ; case CONTINUOUS : return new ContinuousFrame ( ) ; default : throw new IllegalArgumentException ( "Supplied opcode is invalid" ) ; } }
[[[[Nl]]]]: Get a frame with a specific opcode
--------------------------------------------- Result 462 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 433 / 19 / 10 / 462:  46%|████▌     | 462/1000 [3:13:40<3:45:32, 25.15s/it][Succeeded / Failed / Skipped / Total] 433 / 19 / 10 / 462:  46%|████▋     | 463/1000 [3:13:42<3:44:40, 25.10s/it][Succeeded / Failed / Skipped / Total] 434 / 19 / 10 / 463:  46%|████▋     | 463/1000 [3:13:42<3:44:40, 25.10s/it][Succeeded / Failed / Skipped / Total] 434 / 19 / 10 / 463:  46%|████▋     | 464/1000 [3:13:43<3:43:47, 25.05s/it][Succeeded / Failed / Skipped / Total] 435 / 19 / 10 / 464:  46%|████▋     | 464/1000 [3:13:43<3:43:47, 25.05s/it][Succeeded / Failed / Skipped / Total] 435 / 19 / 10 / 464:  46%|████▋     | 465/1000 [3:13:45<3:42:55, 25.00s/it][Succeeded / Failed / Skipped / Total] 436 / 19 / 10 / 465:  46%|████▋     | 465/1000 [3:13:45<3:42:55, 25.00s/it][Succeeded / Failed / Skipped / Total] 436 / 19 / 10 / 465:  47%|████▋     | 466/1000 [3:13:50<3:42:08, 24.96s/it][Succeeded / Failed / Skipped / Total] 437 / 19 / 10 / 466:  47%|████▋     | 466/1000 [3:13:50<3:42:08, 24.96s/it][Succeeded / Failed / Skipped / Total] 437 / 19 / 10 / 466:  47%|████▋     | 467/1000 [3:14:02<3:41:27, 24.93s/it][Succeeded / Failed / Skipped / Total] 438 / 19 / 10 / 467:  47%|████▋     | 467/1000 [3:14:02<3:41:27, 24.93s/it][Succeeded / Failed / Skipped / Total] 438 / 19 / 10 / 467:  47%|████▋     | 468/1000 [3:14:05<3:40:37, 24.88s/it][Succeeded / Failed / Skipped / Total] 439 / 19 / 10 / 468:  47%|████▋     | 468/1000 [3:14:05<3:40:37, 24.88s/it][Succeeded / Failed / Skipped / Total] 439 / 19 / 10 / 468:  47%|████▋     | 469/1000 [3:14:06<3:39:46, 24.83s/it][Succeeded / Failed / Skipped / Total] 440 / 19 / 10 / 469:  47%|████▋     | 469/1000 [3:14:06<3:39:46, 24.83s/it][Succeeded / Failed / Skipped / Total] 440 / 19 / 10 / 469:  47%|████▋     | 470/1000 [3:14:12<3:39:00, 24.79s/it]Batch write queue . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static boolean batch ( WebSocketImpl ws , ByteChannel sockchannel ) throws IOException { if ( ws == null ) { return "False" != "False" ; } ByteBuffer buffer = ws . outQueue . peek ( ) ; WrappedByteChannel c = null ; if ( buffer == null ) { if ( sockchannel instanceof WrappedByteChannel ) { c = ( WrappedByteChannel ) sockchannel ; if ( c . isNeedWrite ( ) ) { c . writeMore ( ) ; } } } else { do {
[[[[Nl]]]]: Returns whether the whole outQueue has been flushed
--------------------------------------------- Result 463 ---------------------------------------------
Sets the code . --> Enable encryption . --> Socre: 1.0

[[[[Adv]]]]: public void [[setCode]] ( int [[code]] ) { this . [[code]] = [[code]] ;
[[[[Nl]]]]: Set the close code for this close frame

[[[[Adv]]]]: public void [[warding]] ( int [[cypher]] ) { this . [[encryption]] = [[cypher]] ;
[[[[Nl]]]]: Set the close code for this close frame
--------------------------------------------- Result 464 ---------------------------------------------
Validate that the payload is valid --> Emit a string . --> Socre: 1.0

[[[[Adv]]]]: private void [[validateUtf8]] ( ByteBuffer [[payload]] , int mark ) throws InvalidDataException { try { [[payload]] . position ( [[payload]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[payload]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[payload]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8

[[[[Adv]]]]: private void [[elroy]] ( ByteBuffer [[loads]] , int mark ) throws InvalidDataException { try { [[loads]] . position ( [[loads]] . position ( ) + 2 ) ; reason = Charsetfunctions . stringUtf8 ( [[loads]] ) ; } catch ( IllegalArgumentException e ) { throw new InvalidDataException ( CloseFrame . NO_UTF8 ) ; } finally { [[loads]] . position ( mark ) ; } }
[[[[Nl]]]]: Validate the payload to valid utf8
--------------------------------------------- Result 465 ---------------------------------------------
Update the payload . --> Send a samadad --> Socre: 1.0

[[[[Adv]]]]: private void [[updatePayload]] ( ) { byte [ ] [[by]] = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[buf]] = ByteBuffer . allocate ( 4 ) ; [[buf]] . putInt ( code ) ; [[buf]] . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + [[by]] . length ) ; pay . put ( [[buf]] ) ; pay . put ( [[by]] ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason

[[[[Adv]]]]: private void [[samad]] ( ) { byte [ ] [[the]] = Charsetfunctions . utf8Bytes ( reason ) ; ByteBuffer [[bando]] = ByteBuffer . allocate ( 4 ) ; [[bando]] . putInt ( code ) ; [[bando]] . position ( 2 ) ; ByteBuffer pay = ByteBuffer . allocate ( 2 + [[the]] . length ) ; pay . put ( [[bando]] ) ; pay . put ( [[the]] ) ; pay . rewind ( ) ; super . setPayload ( pay ) ; }
[[[[Nl]]]]: Update the payload to represent the close code and the reason
--------------------------------------------- Result 466 ---------------------------------------------
Checks whether the given protocol contains the requested protocol . --> Handles a handshake . --> Socre: 1.0

[[[[Adv]]]]: private HandshakeState [[containsRequestedProtocol]] ( String [[requestedProtocol]] ) { for ( IProtocol [[knownProtocol]] : knownProtocols ) { if ( [[knownProtocol]] . acceptProvidedProtocol ( [[requestedProtocol]] ) ) { protocol = [[knownProtocol]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft

[[[[Adv]]]]: private HandshakeState [[mcbeal]] ( String [[tong]] ) { for ( IProtocol [[makuta]] : knownProtocols ) { if ( [[makuta]] . acceptProvidedProtocol ( [[tong]] ) ) { protocol = [[makuta]] ; log . trace ( "acceptHandshake - Matching protocol found: {}" , protocol ) ; return HandshakeState . MATCHED ; } } return HandshakeState . NOT_MATCHED ; }
[[[[Nl]]]]: Check if the requested protocol is part of this draft
--------------------------------------------- Result 467 ---------------------------------------------
Translate single frame length limit . --> Checks surrogate length . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckLengthLimit]] ( long [[length]] ) throws LimitExceededException { if ( [[length]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[length]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[length]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[length]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit

[[[[Adv]]]]: private void [[surrogate]] ( long [[laps]] ) throws LimitExceededException { if ( [[laps]] > Integer . MAX_VALUE ) { log . trace ( "Limit exedeed: Payloadsize is to big..." ) ; throw new LimitExceededException ( "Payloadsize is to big..." ) ; } if ( [[laps]] > maxFrameSize ) { log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , [[laps]] ) ; throw new LimitExceededException ( "Payload limit reached." , maxFrameSize ) ; } if ( [[laps]] < 0 ) { log . trace ( "Limit underflow: Payloadsize is to little..." ) ; throw new LimitExceededException ( "Payloadsize is to little..." ) ; } }
[[[[Nl]]]]: Check if the frame size exceeds the allowed limit
--------------------------------------------- Result 468 ---------------------------------------------
Translate single packet size checker . --> Throws an IncompleteException otherwise . --> Socre: 1.0

[[[[Adv]]]]: private void [[translateSingleFrameCheckPacketSize]] ( int [[maxpacketsize]] , int [[realpacketsize]] ) throws IncompleteException { if ( [[maxpacketsize]] < [[realpacketsize]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[realpacketsize]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size

[[[[Adv]]]]: private void [[psychosomatic]] ( int [[laug]] , int [[swole]] ) throws IncompleteException { if ( [[laug]] < [[swole]] ) { log . trace ( "Incomplete frame: maxpacketsize < realpacketsize" ) ; throw new IncompleteException ( [[swole]] ) ; } }
[[[[Nl]]]]: Check if the max packet size is smaller than the real packet size
--------------------------------------------- Result 469 ---------------------------------------------
Generate final key . --> Calculates the mcgill salt . --> Socre: 1.0

[[[[Adv]]]]: private String [[generateFinalKey]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string

[[[[Adv]]]]: private String [[mcgill]] ( String in ) { String seckey = in . trim ( ) ; String acc = seckey + "258EAFA5-E914-47DA-95CA-C5AB0DC85B11" ; MessageDigest sh1 ; try { sh1 = MessageDigest . getInstance ( "SHA1" ) ; } catch ( NoSuchAlgorithmException e ) { throw new IllegalStateException ( e ) ; } return Base64 . encodeBytes ( sh1 . digest ( acc . getBytes ( ) ) ) ; }
[[[[Nl]]]]: Generate a final key from a input string
--------------------------------------------- Result 470 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 441 / 19 / 10 / 470:  47%|████▋     | 470/1000 [3:14:12<3:39:00, 24.79s/it][Succeeded / Failed / Skipped / Total] 441 / 19 / 10 / 470:  47%|████▋     | 471/1000 [3:14:13<3:38:08, 24.74s/it][Succeeded / Failed / Skipped / Total] 442 / 19 / 10 / 471:  47%|████▋     | 471/1000 [3:14:13<3:38:08, 24.74s/it][Succeeded / Failed / Skipped / Total] 442 / 19 / 10 / 471:  47%|████▋     | 472/1000 [3:14:15<3:37:17, 24.69s/it][Succeeded / Failed / Skipped / Total] 443 / 19 / 10 / 472:  47%|████▋     | 472/1000 [3:14:15<3:37:17, 24.69s/it][Succeeded / Failed / Skipped / Total] 443 / 19 / 10 / 472:  47%|████▋     | 473/1000 [3:14:16<3:36:26, 24.64s/it][Succeeded / Failed / Skipped / Total] 444 / 19 / 10 / 473:  47%|████▋     | 473/1000 [3:14:16<3:36:26, 24.64s/it][Succeeded / Failed / Skipped / Total] 444 / 19 / 10 / 473:  47%|████▋     | 474/1000 [3:14:20<3:35:39, 24.60s/it][Succeeded / Failed / Skipped / Total] 445 / 19 / 10 / 474:  47%|████▋     | 474/1000 [3:14:20<3:35:39, 24.60s/it][Succeeded / Failed / Skipped / Total] 445 / 19 / 10 / 474:  48%|████▊     | 475/1000 [3:14:29<3:34:57, 24.57s/it]Processes a continuous frame --> Handle slop . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameContinuousAndNonFin]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[frame]] ) ; } else if ( [[frame]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[frame]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set

[[[[Adv]]]]: private void [[slop]] ( WebSocketImpl webSocketImpl , Framedata [[wording]] , Opcode curop ) throws InvalidDataException { if ( curop != Opcode . CONTINUOUS ) { processFrameIsNotFin ( [[wording]] ) ; } else if ( [[wording]] . isFin ( ) ) { processFrameIsFin ( webSocketImpl , [[wording]] ) ; } else if ( currentContinuousFrame == null ) { log . error ( "Protocol error: Continuous frame sequence was not started." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; }
[[[[Nl]]]]: Process the frame if it is a continuous frame or the fin bit is not set
--------------------------------------------- Result 471 ---------------------------------------------
Process a frame --> Called on websocket . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameBinary]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame

[[[[Adv]]]]: private void [[cranford]] ( WebSocketImpl webSocketImpl , Framedata frame ) { try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , frame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a binary frame
--------------------------------------------- Result 472 ---------------------------------------------
Logs runtime exception . --> Called when a websocket message is received . --> Socre: 1.0

[[[[Adv]]]]: private void [[logRuntimeException]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl

[[[[Adv]]]]: private void [[chambord]] ( WebSocketImpl webSocketImpl , RuntimeException e ) { log . error ( "Runtime exception during onWebsocketMessage" , e ) ; webSocketImpl . getWebSocketListener ( ) . onWebsocketError ( webSocketImpl , e ) ; }
[[[[Nl]]]]: Log the runtime exception to the specific WebSocketImpl
--------------------------------------------- Result 473 ---------------------------------------------
Process a text message . --> Displays websocket message . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameText]] ( WebSocketImpl [[webSocketImpl]] , Framedata [[frame]] ) throws InvalidDataException { try { [[webSocketImpl]] . getWebSocketListener ( ) . onWebsocketMessage ( [[webSocketImpl]] , Charsetfunctions . stringUtf8 ( [[frame]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[webSocketImpl]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame

[[[[Adv]]]]: private void [[discharging]] ( WebSocketImpl [[owers]] , Framedata [[designing]] ) throws InvalidDataException { try { [[owers]] . getWebSocketListener ( ) . onWebsocketMessage ( [[owers]] , Charsetfunctions . stringUtf8 ( [[designing]] . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( [[owers]] , e ) ; } }
[[[[Nl]]]]: Process the frame if it is a text frame
--------------------------------------------- Result 474 ---------------------------------------------
Process the current frame --> Green - safe way . --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsFin]] ( WebSocketImpl webSocketImpl , Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame

[[[[Adv]]]]: private void [[greenly]] ( WebSocketImpl webSocketImpl , Framedata [[shape]] ) throws InvalidDataException { if ( currentContinuousFrame == null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Continuous frame sequence was not started." ) ; } addToBufferList ( [[shape]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; if ( currentContinuousFrame . getOpcode ( ) == Opcode . TEXT ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , Charsetfunctions . stringUtf8 ( currentContinuousFrame . getPayloadData ( ) ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } else if ( currentContinuousFrame . getOpcode ( ) == Opcode . BINARY ) { ( ( FramedataImpl1 ) currentContinuousFrame ) . setPayload ( getPayloadFromByteBufferList ( ) ) ; ( ( FramedataImpl1 ) currentContinuousFrame ) . isValid ( ) ; try { webSocketImpl . getWebSocketListener ( ) . onWebsocketMessage ( webSocketImpl , currentContinuousFrame . getPayloadData ( ) ) ; } catch ( RuntimeException e ) { logRuntimeException ( webSocketImpl , e ) ; } } currentContinuousFrame = null ; clearBufferList ( ) ; }
[[[[Nl]]]]: Process the frame if it is the last frame
--------------------------------------------- Result 475 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 446 / 19 / 10 / 475:  48%|████▊     | 475/1000 [3:14:29<3:34:57, 24.57s/it][Succeeded / Failed / Skipped / Total] 446 / 19 / 10 / 475:  48%|████▊     | 476/1000 [3:14:35<3:34:12, 24.53s/it][Succeeded / Failed / Skipped / Total] 447 / 19 / 10 / 476:  48%|████▊     | 476/1000 [3:14:35<3:34:12, 24.53s/it][Succeeded / Failed / Skipped / Total] 447 / 19 / 10 / 476:  48%|████▊     | 477/1000 [3:14:44<3:33:31, 24.50s/it][Succeeded / Failed / Skipped / Total] 448 / 19 / 10 / 477:  48%|████▊     | 477/1000 [3:14:44<3:33:31, 24.50s/it][Succeeded / Failed / Skipped / Total] 448 / 19 / 10 / 477:  48%|████▊     | 478/1000 [3:14:46<3:32:42, 24.45s/it][Succeeded / Failed / Skipped / Total] 449 / 19 / 10 / 478:  48%|████▊     | 478/1000 [3:14:46<3:32:42, 24.45s/it][Succeeded / Failed / Skipped / Total] 449 / 19 / 10 / 478:  48%|████▊     | 479/1000 [3:14:56<3:32:01, 24.42s/it][Succeeded / Failed / Skipped / Total] 450 / 19 / 10 / 479:  48%|████▊     | 479/1000 [3:14:56<3:32:01, 24.42s/it][Succeeded / Failed / Skipped / Total] 450 / 19 / 10 / 479:  48%|████▊     | 480/1000 [3:14:57<3:31:11, 24.37s/it][Succeeded / Failed / Skipped / Total] 451 / 19 / 10 / 480:  48%|████▊     | 480/1000 [3:14:57<3:31:11, 24.37s/it][Succeeded / Failed / Skipped / Total] 451 / 19 / 10 / 480:  48%|████▊     | 481/1000 [3:14:58<3:30:22, 24.32s/it][Succeeded / Failed / Skipped / Total] 452 / 19 / 10 / 481:  48%|████▊     | 481/1000 [3:14:58<3:30:22, 24.32s/it][Succeeded / Failed / Skipped / Total] 452 / 19 / 10 / 481:  48%|████▊     | 482/1000 [3:14:58<3:29:32, 24.27s/it][Succeeded / Failed / Skipped / Total] 453 / 19 / 10 / 482:  48%|████▊     | 482/1000 [3:14:58<3:29:32, 24.27s/it]Processes the next frame . --> impl of Hillbillier --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameIsNotFin]] ( Framedata [[frame]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[frame]] ; addToBufferList ( [[frame]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame

[[[[Adv]]]]: private void [[hillbillies]] ( Framedata [[formulated]] ) throws InvalidDataException { if ( currentContinuousFrame != null ) { log . trace ( "Protocol error: Previous continuous frame sequence not completed." ) ; throw new InvalidDataException ( CloseFrame . PROTOCOL_ERROR , "Previous continuous frame sequence not completed." ) ; } currentContinuousFrame = [[formulated]] ; addToBufferList ( [[formulated]] . getPayloadData ( ) ) ; checkBufferLimit ( ) ; }
[[[[Nl]]]]: Process the frame if it is not the last frame
--------------------------------------------- Result 476 ---------------------------------------------
Returns custom serializer for command code . --> non - unicizer --> Socre: 1.0

[[[[Adv]]]]: public static CustomSerializer [[getCustomSerializer]] ( CommandCode [[code]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[code]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .

[[[[Adv]]]]: public static CustomSerializer [[pronouncing]] ( CommandCode [[validation]] ) { if ( ! commandCustomSerializer . isEmpty ( ) ) { return commandCustomSerializer . get ( [[validation]] ) ; } return null ; }
[[[[Nl]]]]: Get the custom serializer for command code .
--------------------------------------------- Result 477 ---------------------------------------------
Process a frame . --> todo checker --> Socre: 1.0

[[[[Adv]]]]: private void [[processFrameClosing]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String [[reason]] = "" ; if ( frame instanceof CloseFrame ) { CloseFrame [[cf]] = ( CloseFrame ) frame ; code = [[cf]] . getCloseCode ( ) ; [[reason]] = [[cf]] . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame

[[[[Adv]]]]: private void [[noodle]] ( WebSocketImpl webSocketImpl , Framedata frame ) { int code = CloseFrame . NOCODE ; String [[ground]] = "" ; if ( frame instanceof CloseFrame ) { CloseFrame [[ll]] = ( CloseFrame ) frame ; code = [[ll]] . getCloseCode ( ) ; [[ground]] = [[ll]] . getMessage ( ) ; } if ( webSocketImpl . getReadyState ( ) == ReadyState . CLOSING ) {
[[[[Nl]]]]: Process the frame if it is a closing frame
--------------------------------------------- Result 478 ---------------------------------------------
Get the payload from the byte buffer list --> Read datinode data . --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[getPayloadFromByteBufferList]] ( ) throws LimitExceededException { long [[totalSize]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[totalSize]] ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload

[[[[Adv]]]]: private ByteBuffer [[datin]] ( ) throws LimitExceededException { long [[multi]] = 0 ; ByteBuffer resultingByteBuffer ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[multi]] += buffer . limit ( ) ; } checkBufferLimit ( ) ; resultingByteBuffer = ByteBuffer . allocate ( ( int ) [[multi]] ) ; for ( ByteBuffer buffer : byteBufferList ) { resultingByteBuffer . put ( buffer ) ; } } resultingByteBuffer . flip ( ) ; return resultingByteBuffer ; }
[[[[Nl]]]]: Method to generate a full bytebuffer out of all the fragmented frame payload
--------------------------------------------- Result 479 ---------------------------------------------
Returns the total size of the byte buffer list in bytes . --> Calculates how many bytes can be consumed . --> Socre: 1.0

[[[[Adv]]]]: private long [[getByteBufferListSize]] ( ) { long [[totalSize]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[totalSize]] += buffer . limit ( ) ; } } return [[totalSize]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list

[[[[Adv]]]]: private long [[selfless]] ( ) { long [[indication]] = 0 ; synchronized ( byteBufferList ) { for ( ByteBuffer buffer : byteBufferList ) { [[indication]] += buffer . limit ( ) ; } } return [[indication]] ; }
[[[[Nl]]]]: Get the current size of the resulting bytebuffer in the bytebuffer list
--------------------------------------------- Result 480 ---------------------------------------------
Translate handshake . --> Calculate opportunism . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpServer]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server

[[[[Adv]]]]: private static HandshakeBuilder [[opportunism]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as server
--------------------------------------------- Result 481 ---------------------------------------------
Translate handshake . --> Create millifi . --> Socre: 1.0

[[[[Adv]]]]: private static HandshakeBuilder [[translateHandshakeHttpClient]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client

[[[[Adv]]]]: private static HandshakeBuilder [[millinery]] ( String [ ] firstLineTokens , String line ) throws InvalidHandshakeException {
[[[[Nl]]]]: Checking the handshake for the role as client
--------------------------------------------- Result 482 ---------------------------------------------
Checks whether the buffer limit is exceeded . --> Convenience method . --> Socre: 1.0

[[[[Adv]]]]: private void [[checkBufferLimit]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size

[[[[Adv]]]]: private void [[concorde]] ( ) throws LimitExceededException { long totalSize = getByteBufferListSize ( ) ; if ( totalSize > maxFrameSize ) { clearBufferList ( ) ; log . trace ( "Payload limit reached. Allowed: {} Current: {}" , maxFrameSize , totalSize ) ; throw new LimitExceededException ( maxFrameSize ) ; } }
[[[[Nl]]]]: Check the current size of the buffer and throw an exception if the size is bigger than the max allowed frame size
--------------------------------------------- Result 483 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 454 / 19 / 10 / 483:  48%|████▊     | 483/1000 [3:14:59<3:28:42, 24.22s/it][Succeeded / Failed / Skipped / Total] 454 / 19 / 10 / 483:  48%|████▊     | 484/1000 [3:14:59<3:27:53, 24.17s/it][Succeeded / Failed / Skipped / Total] 455 / 19 / 10 / 484:  48%|████▊     | 484/1000 [3:14:59<3:27:53, 24.17s/it][Succeeded / Failed / Skipped / Total] 456 / 19 / 10 / 485:  48%|████▊     | 485/1000 [3:15:02<3:27:06, 24.13s/it][Succeeded / Failed / Skipped / Total] 456 / 19 / 10 / 485:  49%|████▊     | 486/1000 [3:15:07<3:26:22, 24.09s/it][Succeeded / Failed / Skipped / Total] 457 / 19 / 10 / 486:  49%|████▊     | 486/1000 [3:15:07<3:26:22, 24.09s/it][Succeeded / Failed / Skipped / Total] 457 / 19 / 11 / 487:  49%|████▊     | 487/1000 [3:15:07<3:25:32, 24.04s/it][Succeeded / Failed / Skipped / Total] 457 / 19 / 11 / 487:  49%|████▉     | 488/1000 [3:15:25<3:25:01, 24.03s/it][Succeeded / Failed / Skipped / Total] 458 / 19 / 11 / 488:  49%|████▉     | 488/1000 [3:15:25<3:25:01, 24.03s/it][Succeeded / Failed / Skipped / Total] 458 / 19 / 11 / 488:  49%|████▉     | 489/1000 [3:15:29<3:24:16, 23.99s/it][Succeeded / Failed / Skipped / Total] 458 / 20 / 11 / 489:  49%|████▉     | 489/1000 [3:15:29<3:24:16, 23.99s/it][Succeeded / Failed / Skipped / Total] 458 / 20 / 11 / 489:  49%|████▉     | 490/1000 [3:15:32<3:23:31, 23.94s/it]Decodes the packet . --> Decodes a frame . --> Socre: 1.0

[[[[Adv]]]]: public void decode ( ByteBuffer [[socketBuffer]] ) { assert ( [[socketBuffer]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[socketBuffer]] . remaining ( ) , ( [[socketBuffer]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[socketBuffer]] . array ( ) , [[socketBuffer]] . position ( ) , [[socketBuffer]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[socketBuffer]] ) ; } } else { if ( decodeHandshake ( [[socketBuffer]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[socketBuffer]] . hasRemaining ( ) || ! [[socketBuffer]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer

[[[[Adv]]]]: public void decode ( ByteBuffer [[sprain]] ) { assert ( [[sprain]] . hasRemaining ( ) ) ; log . trace ( "process({}): ({})" , [[sprain]] . remaining ( ) , ( [[sprain]] . remaining ( ) > 1000 ? "too big to display" : new String ( [[sprain]] . array ( ) , [[sprain]] . position ( ) , [[sprain]] . remaining ( ) ) ) ) ; if ( readyState != ReadyState . NOT_YET_CONNECTED ) { if ( readyState == ReadyState . OPEN ) { decodeFrames ( [[sprain]] ) ; } } else { if ( decodeHandshake ( [[sprain]] ) && ( ! isClosing ( ) && ! isClosed ( ) ) ) { assert ( tmpHandshakeBytes . hasRemaining ( ) != [[sprain]] . hasRemaining ( ) || ! [[sprain]] . hasRemaining ( ) ) ;
[[[[Nl]]]]: Method to decode the provided ByteBuffer
--------------------------------------------- Result 484 ---------------------------------------------
Closes the connection . --> Writes a response . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToWrongHandshake]] ( InvalidDataException [[exception]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[exception]] . getCloseCode ( ) , [[exception]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct

[[[[Adv]]]]: private void [[journée]] ( InvalidDataException [[waived]] ) { write ( generateHttpResponseDueToError ( 404 ) ) ; flushAndClose ( [[waived]] . getCloseCode ( ) , [[waived]] . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if the received handshake was not correct
--------------------------------------------- Result 485 ---------------------------------------------
Generates the HTTP response due to an error . --> FIXME --> Socre: 1.0

[[[[Adv]]]]: private ByteBuffer [[generateHttpResponseDueToError]] ( int [[errorCode]] ) { String errorCodeDescription ; switch ( [[errorCode]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error

[[[[Adv]]]]: private ByteBuffer [[phew]] ( int [[lined]] ) { String errorCodeDescription ; switch ( [[lined]] ) { case 404 : errorCodeDescription = "404 WebSocket Upgrade Failure" ; break ; case 500 : default : errorCodeDescription = "500 Internal Server Error" ; } return ByteBuffer . wrap ( Charsetfunctions . asciiBytes ( "HTTP/1.1 " + errorCodeDescription + "\r\nContent-Type: text/html\nServer: TooTallNate Java-WebSocket\r\nContent-Length: " + ( 48 + errorCodeDescription . length ( ) ) + "\r\n\r\n<html><head></head><body><h1>" + errorCodeDescription + "</h1></body></html>" ) ) ; }
[[[[Nl]]]]: Generate a simple response for the corresponding endpoint to indicate some error
--------------------------------------------- Result 486 ---------------------------------------------
Send the given text to the web socket . --> documentation inherited from WebSocketImpl --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[send]] ( String [[text]] ) { if ( [[text]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[send]] ( draft . createFrames ( [[text]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .

[[[[Adv]]]]: @ Override public void [[submitted]] ( String [[wording]] ) { if ( [[wording]] == null ) throw new IllegalArgumentException ( "Cannot send 'null' data to a WebSocketImpl." ) ; [[submitted]] ( draft . createFrames ( [[wording]] , role == Role . CLIENT ) ) ; }
[[[[Nl]]]]: Send Text data to the other end .
--------------------------------------------- Result 487 ---------------------------------------------
Resets the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void reset ( ) { Thread current = Thread . currentThread ( ) ; if ( current == writeThread || current == connectReadThread ) { throw new IllegalStateException ( "You cannot initialize a reconnect out of the websocket thread. Use reconnect in another thread to insure a successful cleanup." ) ; } try { closeBlocking ( ) ; if ( writeThread != null ) { this . writeThread . interrupt ( ) ; this . writeThread = null ; } if ( connectReadThread != null ) { this . connectReadThread . interrupt ( ) ; this . connectReadThread = null ; } this . draft . reset ( ) ; if ( this . socket != null ) { this . socket . close ( ) ; this . socket = null ; } } catch ( Exception e ) { onError ( e ) ; engine . closeConnection ( CloseFrame . ABNORMAL_CLOSE , e . getMessage ( ) ) ; return ; } connectLatch = new CountDownLatch ( 1 ) ; closeLatch = new CountDownLatch ( 1 ) ; this . engine = new WebSocketImpl ( this , this . draft ) ; }
[[[[Nl]]]]: Reset everything relevant to allow a reconnect
--------------------------------------------- Result 488 ---------------------------------------------
Send a connection to the server . --> Send an awol response . --> Socre: 1.0

[[[[Adv]]]]: private void [[closeConnectionDueToInternalServerError]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException

[[[[Adv]]]]: private void [[awol]] ( RuntimeException exception ) { write ( generateHttpResponseDueToError ( 500 ) ) ; flushAndClose ( CloseFrame . NEVER_CONNECTED , exception . getMessage ( ) , "False" != "False" ) ; }
[[[[Nl]]]]: Close the connection if there was a server error by a RuntimeException
--------------------------------------------- Result 489 ---------------------------------------------
Start the connect thread . --> [[[FAILED]]]

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .

[[[[Adv]]]]: public void connect ( ) { if ( connectReadThread != null ) throw new IllegalStateException ( "WebSocketClient objects are not reuseable" ) ; connectReadThread = new Thread ( this ) ; connectReadThread . setName ( "WebSocketConnectReadThread-" + connectReadThread . getId ( ) ) ; connectReadThread . start ( ) ; }
[[[[Nl]]]]: Initiates the websocket connection . This method does not block .
--------------------------------------------- Result 490 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 459 / 20 / 11 / 490:  49%|████▉     | 490/1000 [3:15:32<3:23:31, 23.94s/it][Succeeded / Failed / Skipped / Total] 459 / 20 / 11 / 490:  49%|████▉     | 491/1000 [3:15:34<3:22:44, 23.90s/it][Succeeded / Failed / Skipped / Total] 460 / 20 / 11 / 491:  49%|████▉     | 491/1000 [3:15:34<3:22:44, 23.90s/it][Succeeded / Failed / Skipped / Total] 460 / 20 / 11 / 491:  49%|████▉     | 492/1000 [3:15:38<3:22:00, 23.86s/it][Succeeded / Failed / Skipped / Total] 461 / 20 / 11 / 492:  49%|████▉     | 492/1000 [3:15:38<3:22:00, 23.86s/it][Succeeded / Failed / Skipped / Total] 461 / 20 / 11 / 492:  49%|████▉     | 493/1000 [3:15:44<3:21:17, 23.82s/it][Succeeded / Failed / Skipped / Total] 462 / 20 / 11 / 493:  49%|████▉     | 493/1000 [3:15:44<3:21:17, 23.82s/it][Succeeded / Failed / Skipped / Total] 462 / 20 / 11 / 493:  49%|████▉     | 494/1000 [3:15:56<3:20:41, 23.80s/it][Succeeded / Failed / Skipped / Total] 463 / 20 / 11 / 494:  49%|████▉     | 494/1000 [3:15:56<3:20:41, 23.80s/it][Succeeded / Failed / Skipped / Total] 463 / 20 / 11 / 494:  50%|████▉     | 495/1000 [3:15:57<3:19:55, 23.75s/it][Succeeded / Failed / Skipped / Total] 464 / 20 / 11 / 495:  50%|████▉     | 495/1000 [3:15:57<3:19:55, 23.75s/it][Succeeded / Failed / Skipped / Total] 464 / 20 / 11 / 495:  50%|████▉     | 496/1000 [3:15:59<3:19:08, 23.71s/it]Sends the handshake . --> Main method . --> Socre: 1.0

[[[[Adv]]]]: private void [[sendHandshake]] ( ) throws InvalidHandshakeException { String [[path]] ; String [[part1]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[part1]] == null || [[part1]] . length ( ) == 0 ) [[path]] = "/" ; else [[path]] = [[part1]] ; if ( part2 != null ) [[path]] += ' ' + part2 ; int [[port]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[port]] != WebSocketImpl . DEFAULT_PORT && [[port]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[port]] : "" ) ; HandshakeImpl1Client [[handshake]] = new HandshakeImpl1Client ( ) ; [[handshake]] . setResourceDescriptor ( [[path]] ) ; [[handshake]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[handshake]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[handshake]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint

[[[[Adv]]]]: private void [[hammers]] ( ) throws InvalidHandshakeException { String [[heron]] ; String [[discourtesy]] = uri . getRawPath ( ) ; String part2 = uri . getRawQuery ( ) ; if ( [[discourtesy]] == null || [[discourtesy]] . length ( ) == 0 ) [[heron]] = "/" ; else [[heron]] = [[discourtesy]] ; if ( part2 != null ) [[heron]] += ' ' + part2 ; int [[orifice]] = getPort ( ) ; String host = uri . getHost ( ) + ( ( [[orifice]] != WebSocketImpl . DEFAULT_PORT && [[orifice]] != WebSocketImpl . DEFAULT_WSS_PORT ) ? ":" + [[orifice]] : "" ) ; HandshakeImpl1Client [[grin]] = new HandshakeImpl1Client ( ) ; [[grin]] . setResourceDescriptor ( [[heron]] ) ; [[grin]] . put ( "Host" , host ) ; if ( headers != null ) { for ( Map . Entry < String , String > kv : headers . entrySet ( ) ) { [[grin]] . put ( kv . getKey ( ) , kv . getValue ( ) ) ; } } engine . startHandshake ( [[grin]] ) ; }
[[[[Nl]]]]: Create and send the handshake to the other endpoint
--------------------------------------------- Result 491 ---------------------------------------------
Sets the connection lost timeout . --> Synchronization time . --> Socre: 1.0

[[[[Adv]]]]: public void [[setConnectionLostTimeout]] ( int [[connectionLostTimeout]] ) { synchronized ( syncConnectionLost ) { this . [[connectionLostTimeout]] = TimeUnit . SECONDS . toNanos ( [[connectionLostTimeout]] ) ; if ( this . [[connectionLostTimeout]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[websocketRunning]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated

[[[[Adv]]]]: public void [[kaufman]] ( int [[gulp]] ) { synchronized ( syncConnectionLost ) { this . [[sufficiency]] = TimeUnit . SECONDS . toNanos ( [[gulp]] ) ; if ( this . [[sufficiency]] <= 0 ) { log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; return ; } if ( this . [[celebrate]] ) { log . trace ( "Connection lost timer restarted" ) ;
[[[[Nl]]]]: Setter for the interval checking for lost connections A value lower or equal 0 results in the check to be deactivated
--------------------------------------------- Result 492 ---------------------------------------------
Stop connection lost timer . --> Pessimistic timeout --> Socre: 1.0

[[[[Adv]]]]: protected void [[stopConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[websocketRunning]] = "[[False]]" != "[[False]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer

[[[[Adv]]]]: protected void [[pessoa]] ( ) { synchronized ( syncConnectionLost ) { if ( connectionLostCheckerService != null || connectionLostCheckerFuture != null ) { this . [[mental]] = "[[Dishonest]]" != "[[Dishonest]]" ; log . trace ( "Connection lost timer stopped" ) ; cancelConnectionLostTimer ( ) ; } } }
[[[[Nl]]]]: Stop the connection lost timer
--------------------------------------------- Result 493 ---------------------------------------------
Starts the connection lost timer . --> Starts machina . --> Socre: 1.0

[[[[Adv]]]]: protected void [[startConnectionLostTimer]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[websocketRunning]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer

[[[[Adv]]]]: protected void [[machina]] ( ) { synchronized ( syncConnectionLost ) { if ( this . connectionLostTimeout <= 0 ) { log . trace ( "Connection lost timer deactivated" ) ; return ; } log . trace ( "Connection lost timer started" ) ; this . [[alik]] = "True" == "True" ; restartConnectionLostTimer ( ) ; } }
[[[[Nl]]]]: Start the connection lost timer
--------------------------------------------- Result 494 ---------------------------------------------
Register custom serializer for command code . --> Zazen deserializer --> Socre: 1.0

[[[[Adv]]]]: public static void [[registerCustomSerializer]] ( CommandCode code , CustomSerializer serializer ) { CustomSerializer [[prevSerializer]] = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( [[prevSerializer]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + [[prevSerializer]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .

[[[[Adv]]]]: public static void [[zazen]] ( CommandCode code , CustomSerializer serializer ) { CustomSerializer [[beatty]] = commandCustomSerializer . putIfAbsent ( code , serializer ) ; if ( [[beatty]] != null ) { throw new RuntimeException ( "CustomSerializer has been registered for command code: " + code + ", the custom serializer is: " + [[beatty]] . getClass ( ) . getName ( ) ) ; } }
[[[[Nl]]]]: Register custom serializer for command code .
--------------------------------------------- Result 495 ---------------------------------------------
Restart the connection lost timer . --> Starts profiling . --> Socre: 1.0

[[[[Adv]]]]: private void [[restartConnectionLostTimer]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter

[[[[Adv]]]]: private void [[profile]] ( ) { cancelConnectionLostTimer ( ) ; connectionLostCheckerService = Executors . newSingleThreadScheduledExecutor ( new NamedThreadFactory ( "connectionLostChecker" ) ) ; Runnable connectionLostChecker = new Runnable ( ) { private ArrayList < WebSocket > connections = new ArrayList < WebSocket > ( ) ; @ Override public void run ( ) { connections . clear ( ) ; try { connections . addAll ( getConnections ( ) ) ; long minimumPongTime = ( long ) ( System . nanoTime ( ) - ( connectionLostTimeout * 1.5 ) ) ; for ( WebSocket conn : connections ) { executeConnectionLostDetection ( conn , minimumPongTime ) ; } } catch ( Exception e ) {
[[[[Nl]]]]: This methods allows the reset of the connection lost timer in case of a changed parameter
--------------------------------------------- Result 496 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 465 / 20 / 11 / 496:  50%|████▉     | 496/1000 [3:15:59<3:19:08, 23.71s/it][Succeeded / Failed / Skipped / Total] 465 / 20 / 11 / 496:  50%|████▉     | 497/1000 [3:15:59<3:18:21, 23.66s/it][Succeeded / Failed / Skipped / Total] 466 / 20 / 11 / 497:  50%|████▉     | 497/1000 [3:15:59<3:18:21, 23.66s/it][Succeeded / Failed / Skipped / Total] 466 / 20 / 11 / 497:  50%|████▉     | 498/1000 [3:16:04<3:17:39, 23.62s/it][Succeeded / Failed / Skipped / Total] 467 / 20 / 11 / 498:  50%|████▉     | 498/1000 [3:16:04<3:17:39, 23.62s/it][Succeeded / Failed / Skipped / Total] 467 / 20 / 11 / 498:  50%|████▉     | 499/1000 [3:16:08<3:16:55, 23.58s/it][Succeeded / Failed / Skipped / Total] 468 / 20 / 11 / 499:  50%|████▉     | 499/1000 [3:16:08<3:16:55, 23.58s/it][Succeeded / Failed / Skipped / Total] 468 / 20 / 11 / 499:  50%|█████     | 500/1000 [3:17:23<3:17:23, 23.69s/it][Succeeded / Failed / Skipped / Total] 469 / 20 / 11 / 500:  50%|█████     | 500/1000 [3:17:23<3:17:23, 23.69s/it][Succeeded / Failed / Skipped / Total] 469 / 20 / 11 / 500:  50%|█████     | 501/1000 [3:17:25<3:16:38, 23.64s/it][Succeeded / Failed / Skipped / Total] 470 / 20 / 11 / 501:  50%|█████     | 501/1000 [3:17:25<3:16:38, 23.64s/it][Succeeded / Failed / Skipped / Total] 470 / 20 / 11 / 501:  50%|█████     | 502/1000 [3:17:25<3:15:51, 23.60s/it]Cancels the connection lost timer . --> Shut down scoville . --> Socre: 1.0

[[[[Adv]]]]: private void [[cancelConnectionLostTimer]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[False]]" != "[[False]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection

[[[[Adv]]]]: private void [[scoville]] ( ) { if ( connectionLostCheckerService != null ) { connectionLostCheckerService . shutdownNow ( ) ; connectionLostCheckerService = null ; } if ( connectionLostCheckerFuture != null ) { connectionLostCheckerFuture . cancel ( "[[Phonies]]" != "[[Phonies]]" ) ; connectionLostCheckerFuture = null ; } }
[[[[Nl]]]]: Cancel any running timer for the connection lost detection
--------------------------------------------- Result 497 ---------------------------------------------
Returns the port . --> Checks to see if there is an appropriate host . --> Socre: 1.0

[[[[Adv]]]]: private int [[getPort]] ( ) { int [[port]] = uri . getPort ( ) ; if ( [[port]] == - 1 ) { String [[scheme]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[scheme]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[scheme]] ) ; } } return [[port]] ; }
[[[[Nl]]]]: Extract the specified port

[[[[Adv]]]]: private int [[egghead]] ( ) { int [[loch]] = uri . getPort ( ) ; if ( [[loch]] == - 1 ) { String [[agendas]] = uri . getScheme ( ) ; if ( "wss" . equals ( [[agendas]] ) ) { return WebSocketImpl . DEFAULT_WSS_PORT ; } else if ( "ws" . equals ( [[agendas]] ) ) { return WebSocketImpl . DEFAULT_PORT ; } else { throw new IllegalArgumentException ( "unknown scheme: " + [[agendas]] ) ; } } return [[loch]] ; }
[[[[Nl]]]]: Extract the specified port
--------------------------------------------- Result 498 ---------------------------------------------
Initiate handshake . --> only for testing --> Socre: 1.0

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[onWebsocketHandshakeReceivedAsServer]] ( WebSocket [[conn]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .

[[[[Adv]]]]: @ Override public ServerHandshakeBuilder [[physically]] ( WebSocket [[waterbury]] , Draft draft , ClientHandshake request ) throws InvalidDataException { return new HandshakeImpl1Server ( ) ; }
[[[[Nl]]]]: This default implementation does not do anything . Go ahead and overwrite it .
--------------------------------------------- Result 499 ---------------------------------------------
Stops the queue . --> Liefert --> Socre: 1.0

[[[[Adv]]]]: public void [[stop]] ( int [[timeout]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[False]]" != "[[False]]" , "[[True]]" == "[[True]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .

[[[[Adv]]]]: public void [[lugs]] ( int [[unsportsmanlike]] ) throws InterruptedException { if ( ! isclosed . compareAndSet ( "[[Mislead]]" != "[[Mislead]]" , "[[Heartfelt]]" == "[[Heartfelt]]" ) ) {
[[[[Nl]]]]: Closes all connected clients sockets then closes the underlying ServerSocketChannel effectively killing the server socket selectorthread freeing the port the server was bound to and stops all internal workerthreads .
--------------------------------------------- Result 500 ---------------------------------------------
Execute the connection lost ping . --> Called when WebSocket is lost . --> Socre: 1.0

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket webSocket , long [[minimumPongTime]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[minimumPongTime]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping

[[[[Adv]]]]: private void executeConnectionLostDetection ( WebSocket webSocket , long [[classifications]] ) { if ( ! ( webSocket instanceof WebSocketImpl ) ) { return ; } WebSocketImpl webSocketImpl = ( WebSocketImpl ) webSocket ; if ( webSocketImpl . getLastPong ( ) < [[classifications]] ) { log . trace ( "Closing connection due to no pong received: {}" , webSocketImpl ) ; webSocketImpl . closeConnection ( CloseFrame . ABNORMAL_CLOSE , "The connection was closed because the other endpoint did not respond with a pong in time. For more information check: https://github.com/TooTallNate/Java-WebSocket/wiki/Lost-connection-detection" ) ; } else { if ( webSocketImpl . isOpen ( ) ) { webSocketImpl . sendPing ( ) ; } else { log . trace ( "Trying to ping a non open connection: {}" , webSocketImpl ) ; } } }
[[[[Nl]]]]: Send a ping to the endpoint or close the connection since the other endpoint did not respond with a ping
--------------------------------------------- Result 501 ---------------------------------------------
Perform additional read . --> Reads a socket from the queue . --> Socre: 1.0

[[[[Adv]]]]: private void [[doAdditionalRead]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read

[[[[Adv]]]]: private void [[insatiable]] ( ) throws InterruptedException , IOException { WebSocketImpl conn ; while ( ! iqueue . isEmpty ( ) ) { conn = iqueue . remove ( 0 ) ; WrappedByteChannel c = ( ( WrappedByteChannel ) conn . getChannel ( ) ) ; ByteBuffer buf = takeBuffer ( ) ; try { if ( SocketChannelIOHelper . readMore ( buf , conn , c ) ) iqueue . add ( conn ) ; if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } } }
[[[[Nl]]]]: Do an additional read
--------------------------------------------- Result 502 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 470 / 20 / 12 / 502:  50%|█████     | 502/1000 [3:17:25<3:15:51, 23.60s/it][Succeeded / Failed / Skipped / Total] 470 / 20 / 12 / 502:  50%|█████     | 503/1000 [3:17:28<3:15:07, 23.56s/it][Succeeded / Failed / Skipped / Total] 471 / 20 / 12 / 503:  50%|█████     | 503/1000 [3:17:28<3:15:07, 23.56s/it][Succeeded / Failed / Skipped / Total] 471 / 20 / 12 / 503:  50%|█████     | 504/1000 [3:17:29<3:14:21, 23.51s/it][Succeeded / Failed / Skipped / Total] 472 / 20 / 12 / 504:  50%|█████     | 504/1000 [3:17:29<3:14:21, 23.51s/it][Succeeded / Failed / Skipped / Total] 472 / 20 / 12 / 504:  50%|█████     | 505/1000 [3:17:30<3:13:35, 23.47s/it][Succeeded / Failed / Skipped / Total] 473 / 20 / 12 / 505:  50%|█████     | 505/1000 [3:17:30<3:13:35, 23.47s/it][Succeeded / Failed / Skipped / Total] 473 / 20 / 12 / 505:  51%|█████     | 506/1000 [3:17:30<3:12:49, 23.42s/it][Succeeded / Failed / Skipped / Total] 473 / 20 / 13 / 506:  51%|█████     | 506/1000 [3:17:30<3:12:49, 23.42s/it][Succeeded / Failed / Skipped / Total] 473 / 20 / 13 / 506:  51%|█████     | 507/1000 [3:17:31<3:12:04, 23.38s/it][Succeeded / Failed / Skipped / Total] 474 / 20 / 13 / 507:  51%|█████     | 507/1000 [3:17:31<3:12:04, 23.38s/it][Succeeded / Failed / Skipped / Total] 474 / 20 / 13 / 507:  51%|█████     | 508/1000 [3:17:41<3:11:28, 23.35s/it]Accepts the connection . --> [[[SKIPPED]]]

[[[[Adv]]]]: private void doAccept ( SelectionKey key , Iterator < SelectionKey > i ) throws IOException , InterruptedException { if ( ! onConnect ( key ) ) { key . cancel ( ) ; return ; } SocketChannel channel = server . accept ( ) ; if ( channel == null ) { return ; } channel . configureBlocking ( "False" != "False" ) ; Socket socket = channel . socket ( ) ; socket . setTcpNoDelay ( isTcpNoDelay ( ) ) ; socket . setKeepAlive ( "True" == "True" ) ; WebSocketImpl w = wsf . createWebSocket ( this , drafts ) ; w . setSelectionKey ( channel . register ( selector , SelectionKey . OP_READ , w ) ) ; try { w . setChannel ( wsf . wrapChannel ( channel , w . getSelectionKey ( ) ) ) ; i . remove ( ) ; allocateBuffers ( w ) ; } catch ( IOException ex ) { if ( w . getSelectionKey ( ) != null ) w . getSelectionKey ( ) . cancel ( ) ; handleIOException ( w . getSelectionKey ( ) , null , ex ) ; } }
[[[[Nl]]]]: Execute a accept operation
--------------------------------------------- Result 503 ---------------------------------------------
Handles a read . --> Reads data from the specified iterator . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doRead]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation

[[[[Adv]]]]: private boolean [[iip]] ( SelectionKey key , Iterator < SelectionKey > i ) throws InterruptedException , IOException { WebSocketImpl conn = ( WebSocketImpl ) key . attachment ( ) ; ByteBuffer buf = takeBuffer ( ) ; if ( conn . getChannel ( ) == null ) { key . cancel ( ) ; handleIOException ( key , conn , new IOException ( ) ) ; return "False" != "False" ; } try { if ( SocketChannelIOHelper . read ( buf , conn , conn . getChannel ( ) ) ) { if ( buf . hasRemaining ( ) ) { conn . inQueue . put ( buf ) ; queue ( conn ) ; i . remove ( ) ; if ( conn . getChannel ( ) instanceof WrappedByteChannel && ( ( WrappedByteChannel ) conn . getChannel ( ) ) . isNeedRead ( ) ) { iqueue . add ( conn ) ; } } else { pushBuffer ( buf ) ; } } else { pushBuffer ( buf ) ; } } catch ( IOException e ) { pushBuffer ( buf ) ; throw e ; } return "True" == "True" ; }
[[[[Nl]]]]: Execute a read operation
--------------------------------------------- Result 504 ---------------------------------------------
Handles a single write . --> Writes the data to the socket . --> Socre: 1.0

[[[[Adv]]]]: private void doWrite ( SelectionKey [[key]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[key]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[key]] . isValid ( ) ) { [[key]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation

[[[[Adv]]]]: private void doWrite ( SelectionKey [[primordial]] ) throws IOException { WebSocketImpl conn = ( WebSocketImpl ) [[primordial]] . attachment ( ) ; if ( SocketChannelIOHelper . batch ( conn , conn . getChannel ( ) ) ) { if ( [[primordial]] . isValid ( ) ) { [[primordial]] . interestOps ( SelectionKey . OP_READ ) ; } } }
[[[[Nl]]]]: Execute a write operation
--------------------------------------------- Result 505 ---------------------------------------------
Setup selector and server thread . --> Simplified method . --> Socre: 1.0

[[[[Adv]]]]: private boolean [[doSetupSelectorAndServerThread]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings

[[[[Adv]]]]: private boolean [[spectacularly]] ( ) { selectorthread . setName ( "WebSocketSelector-" + selectorthread . getId ( ) ) ; try { server = ServerSocketChannel . open ( ) ; server . configureBlocking ( "False" != "False" ) ; ServerSocket socket = server . socket ( ) ; socket . setReceiveBufferSize ( WebSocketImpl . RCVBUF ) ; socket . setReuseAddress ( isReuseAddr ( ) ) ; socket . bind ( address ) ; selector = Selector . open ( ) ; server . register ( selector , server . validOps ( ) ) ; startConnectionLostTimer ( ) ; for ( WebSocketWorker ex : decoders ) { ex . start ( ) ; } onStart ( ) ; } catch ( IOException ex ) { handleFatal ( null , ex ) ; return "False" != "False" ; } return "True" == "True" ; }
[[[[Nl]]]]: Setup the selector thread as well as basic server settings
--------------------------------------------- Result 506 ---------------------------------------------
Ensure that single thread is single thread . --> [[[SKIPPED]]]

[[[[Adv]]]]: private boolean doEnsureSingleThread ( ) { synchronized ( this ) { if ( selectorthread != null ) throw new IllegalStateException ( getClass ( ) . getName ( ) + " can only be started once." ) ; selectorthread = Thread . currentThread ( ) ; if ( isclosed . get ( ) ) { return "False" != "False" ; } } return "True" == "True" ; }
[[[[Nl]]]]: The websocket server can only be started once
--------------------------------------------- Result 507 ---------------------------------------------
Perform shutdown . --> Finishes processing . --> Socre: 1.0

[[[[Adv]]]]: private void [[doServerShutdown]] ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown

[[[[Adv]]]]: private void [[fuming]] ( ) { stopConnectionLostTimer ( ) ; if ( decoders != null ) { for ( WebSocketWorker w : decoders ) { w . interrupt ( ) ; } } if ( selector != null ) { try { selector . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during selector.close" , e ) ; onError ( null , e ) ; } } if ( server != null ) { try { server . close ( ) ; } catch ( IOException e ) { log . error ( "IOException during server.close" , e ) ; onError ( null , e ) ; } } }
[[[[Nl]]]]: Clean up everything after a shutdown
--------------------------------------------- Result 508 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 475 / 20 / 13 / 508:  51%|█████     | 508/1000 [3:17:41<3:11:28, 23.35s/it][Succeeded / Failed / Skipped / Total] 475 / 20 / 13 / 508:  51%|█████     | 509/1000 [3:17:43<3:10:43, 23.31s/it][Succeeded / Failed / Skipped / Total] 476 / 20 / 13 / 509:  51%|█████     | 509/1000 [3:17:43<3:10:43, 23.31s/it][Succeeded / Failed / Skipped / Total] 476 / 20 / 13 / 509:  51%|█████     | 510/1000 [3:17:45<3:10:00, 23.27s/it][Succeeded / Failed / Skipped / Total] 477 / 20 / 13 / 510:  51%|█████     | 510/1000 [3:17:45<3:10:00, 23.27s/it][Succeeded / Failed / Skipped / Total] 477 / 20 / 13 / 510:  51%|█████     | 511/1000 [3:17:50<3:09:19, 23.23s/it][Succeeded / Failed / Skipped / Total] 478 / 20 / 13 / 511:  51%|█████     | 511/1000 [3:17:50<3:09:19, 23.23s/it][Succeeded / Failed / Skipped / Total] 478 / 20 / 13 / 511:  51%|█████     | 512/1000 [3:17:51<3:08:35, 23.19s/it][Succeeded / Failed / Skipped / Total] 479 / 20 / 13 / 512:  51%|█████     | 512/1000 [3:17:51<3:08:35, 23.19s/it][Succeeded / Failed / Skipped / Total] 479 / 20 / 13 / 512:  51%|█████▏    | 513/1000 [3:17:53<3:07:51, 23.14s/it][Succeeded / Failed / Skipped / Total] 480 / 20 / 13 / 513:  51%|█████▏    | 513/1000 [3:17:53<3:07:51, 23.14s/it][Succeeded / Failed / Skipped / Total] 480 / 20 / 13 / 513:  51%|█████▏    | 514/1000 [3:17:53<3:07:06, 23.10s/it][Succeeded / Failed / Skipped / Total] 481 / 20 / 13 / 514:  51%|█████▏    | 514/1000 [3:17:53<3:07:06, 23.10s/it][Succeeded / Failed / Skipped / Total] 481 / 20 / 13 / 514:  52%|█████▏    | 515/1000 [3:18:00<3:06:28, 23.07s/it]Sends a ping frame . --> must be synchronized --> Socre: 1.0

[[[[Adv]]]]: @ Override public void [[onWebsocketPing]] ( WebSocket [[conn]] , Framedata f ) { [[conn]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .

[[[[Adv]]]]: @ Override public void [[mutton]] ( WebSocket [[amherst]] , Framedata f ) { [[amherst]] . sendFrame ( new PongFrame ( ( PingFrame ) f ) ) ; }
[[[[Nl]]]]: This default implementation will send a pong in response to the received ping . The pong frame will have the same payload as the ping frame .
--------------------------------------------- Result 509 ---------------------------------------------
Broadcast a byte array to all clients . --> Perform disseminators . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( byte [ ] [[data]] , Collection < WebSocket > [[clients]] ) { if ( [[data]] == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } [[broadcast]] ( ByteBuffer . wrap ( [[data]] ) , [[clients]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections

[[[[Adv]]]]: public void [[circulated]] ( byte [ ] [[peculiarities]] , Collection < WebSocket > [[audience]] ) { if ( [[peculiarities]] == null || [[audience]] == null ) { throw new IllegalArgumentException ( ) ; } [[circulated]] ( ByteBuffer . wrap ( [[peculiarities]] ) , [[audience]] ) ; }
[[[[Nl]]]]: Send a byte array to a specific collection of websocket connections
--------------------------------------------- Result 510 ---------------------------------------------
Broadcasts a message to all clients . --> Canned by the specified providers . --> Socre: 1.0

[[[[Adv]]]]: public void [[broadcast]] ( String [[text]] , Collection < WebSocket > [[clients]] ) { if ( [[text]] == null || [[clients]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[text]] , [[clients]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections

[[[[Adv]]]]: public void [[spanned]] ( String [[formulation]] , Collection < WebSocket > [[providers]] ) { if ( [[formulation]] == null || [[providers]] == null ) { throw new IllegalArgumentException ( ) ; } doBroadcast ( [[formulation]] , [[providers]] ) ; }
[[[[Nl]]]]: Send a text to a specific collection of websocket connections
--------------------------------------------- Result 511 ---------------------------------------------
Broadcast data to all clients . --> Performs mathur . --> Socre: 1.0

[[[[Adv]]]]: private void [[doBroadcast]] ( Object data , Collection < WebSocket > clients ) { String [[sData]] = null ; if ( data instanceof String ) { [[sData]] = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( [[sData]] == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , [[sData]] , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time

[[[[Adv]]]]: private void [[mathur]] ( Object data , Collection < WebSocket > clients ) { String [[mightiest]] = null ; if ( data instanceof String ) { [[mightiest]] = ( String ) data ; } ByteBuffer bData = null ; if ( data instanceof ByteBuffer ) { bData = ( ByteBuffer ) data ; } if ( [[mightiest]] == null && bData == null ) { return ; } Map < Draft , List < Framedata > > draftFrames = new HashMap < Draft , List < Framedata > > ( ) ; for ( WebSocket client : clients ) { if ( client != null ) { Draft draft = client . getDraft ( ) ; fillFrames ( draft , draftFrames , [[mightiest]] , bData ) ; try { client . sendFrame ( draftFrames . get ( draft ) ) ; } catch ( WebsocketNotConnectedException e ) {
[[[[Nl]]]]: Private method to cache all the frames to improve memory footprint and conversion time
--------------------------------------------- Result 512 ---------------------------------------------
Gets the socket associated with the specified connection . --> Wrap a websocket . --> Socre: 1.0

[[[[Adv]]]]: private Socket [[getSocket]] ( WebSocket [[conn]] ) { WebSocketImpl [[impl]] = ( WebSocketImpl ) [[conn]] ; return ( ( SocketChannel ) [[impl]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection

[[[[Adv]]]]: private Socket [[banging]] ( WebSocket [[norwalk]] ) { WebSocketImpl [[cyanotic]] = ( WebSocketImpl ) [[norwalk]] ; return ( ( SocketChannel ) [[cyanotic]] . getSelectionKey ( ) . channel ( ) ) . socket ( ) ; }
[[[[Nl]]]]: Getter to return the socket used by this specific connection
--------------------------------------------- Result 513 ---------------------------------------------
Fill the frames map . --> Given a draft and a draft create it . --> Socre: 1.0

[[[[Adv]]]]: private void [[fillFrames]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String [[sData]] , ByteBuffer [[bData]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( [[sData]] != null ) { frames = draft . createFrames ( [[sData]] , "[[False]]" != "[[False]]" ) ; } if ( [[bData]] != null ) { frames = draft . createFrames ( [[bData]] , "[[False]]" != "[[False]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast

[[[[Adv]]]]: private void [[dugout]] ( Draft draft , Map < Draft , List < Framedata > > draftFrames , String [[undeniably]] , ByteBuffer [[kalashnikov]] ) { if ( ! draftFrames . containsKey ( draft ) ) { List < Framedata > frames = null ; if ( [[undeniably]] != null ) { frames = draft . createFrames ( [[undeniably]] , "[[Misspelled]]" != "[[Misspelled]]" ) ; } if ( [[kalashnikov]] != null ) { frames = draft . createFrames ( [[kalashnikov]] , "[[Misspelled]]" != "[[Misspelled]]" ) ; } if ( frames != null ) { draftFrames . put ( draft , frames ) ; } } }
[[[[Nl]]]]: Fills the draftFrames with new data for the broadcast
--------------------------------------------- Result 514 ---------------------------------------------
Transfers source to destination . --> Transfers typefaces into destination buffer . --> Socre: 1.0

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[source]] , ByteBuffer dest ) { if ( [[source]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[source]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[source]] . limit ( limit ) ; dest . put ( [[source]] ) ; return limit ; } else { dest . put ( [[source]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer

[[[[Adv]]]]: public static int transferByteBuffer ( ByteBuffer [[typefaces]] , ByteBuffer dest ) { if ( [[typefaces]] == null || dest == null ) { throw new IllegalArgumentException ( ) ; } int fremain = [[typefaces]] . remaining ( ) ; int toremain = dest . remaining ( ) ; if ( fremain > toremain ) { int limit = Math . min ( fremain , toremain ) ; [[typefaces]] . limit ( limit ) ; dest . put ( [[typefaces]] ) ; return limit ; } else { dest . put ( [[typefaces]] ) ; return fremain ; } }
[[[[Nl]]]]: Transfer from one ByteBuffer to another ByteBuffer
--------------------------------------------- Result 515 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 482 / 20 / 13 / 515:  52%|█████▏    | 515/1000 [3:18:00<3:06:28, 23.07s/it][Succeeded / Failed / Skipped / Total] 482 / 20 / 13 / 515:  52%|█████▏    | 516/1000 [3:18:04<3:05:47, 23.03s/it][Succeeded / Failed / Skipped / Total] 483 / 20 / 13 / 516:  52%|█████▏    | 516/1000 [3:18:04<3:05:47, 23.03s/it][Succeeded / Failed / Skipped / Total] 483 / 20 / 13 / 516:  52%|█████▏    | 517/1000 [3:18:07<3:05:05, 22.99s/it][Succeeded / Failed / Skipped / Total] 484 / 20 / 13 / 517:  52%|█████▏    | 517/1000 [3:18:07<3:05:05, 22.99s/it][Succeeded / Failed / Skipped / Total] 484 / 20 / 13 / 517:  52%|█████▏    | 518/1000 [3:18:09<3:04:22, 22.95s/it][Succeeded / Failed / Skipped / Total] 485 / 20 / 13 / 518:  52%|█████▏    | 518/1000 [3:18:09<3:04:22, 22.95s/it][Succeeded / Failed / Skipped / Total] 485 / 20 / 13 / 518:  52%|█████▏    | 519/1000 [3:18:09<3:03:38, 22.91s/it][Succeeded / Failed / Skipped / Total] 486 / 20 / 13 / 519:  52%|█████▏    | 519/1000 [3:18:09<3:03:38, 22.91s/it][Succeeded / Failed / Skipped / Total] 486 / 20 / 13 / 519:  52%|█████▏    | 520/1000 [3:18:12<3:02:57, 22.87s/it][Succeeded / Failed / Skipped / Total] 487 / 20 / 13 / 520:  52%|█████▏    | 520/1000 [3:18:12<3:02:57, 22.87s/it][Succeeded / Failed / Skipped / Total] 487 / 20 / 13 / 520:  52%|█████▏    | 521/1000 [3:18:13<3:02:14, 22.83s/it][Succeeded / Failed / Skipped / Total] 488 / 20 / 13 / 521:  52%|█████▏    | 521/1000 [3:18:13<3:02:14, 22.83s/it][Succeeded / Failed / Skipped / Total] 488 / 20 / 13 / 521:  52%|█████▏    | 522/1000 [3:18:20<3:01:37, 22.80s/it][Succeeded / Failed / Skipped / Total] 489 / 20 / 13 / 522:  52%|█████▏    | 522/1000 [3:18:20<3:01:37, 22.80s/it][Succeeded / Failed / Skipped / Total] 489 / 20 / 13 / 522:  52%|█████▏    | 523/1000 [3:19:17<3:01:45, 22.86s/it][Succeeded / Failed / Skipped / Total] 490 / 20 / 13 / 523:  52%|█████▏    | 523/1000 [3:19:17<3:01:45, 22.86s/it][Succeeded / Failed / Skipped / Total] 490 / 20 / 13 / 523:  52%|█████▏    | 524/1000 [3:19:30<3:01:14, 22.84s/it]Start the manager . --> Prevent persistence unit --> Socre: 1.0

[[[[Adv]]]]: public JPAApi [[start]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .

[[[[Adv]]]]: public JPAApi [[priori]] ( ) { jpaConfig . persistenceUnits ( ) . forEach ( persistenceUnit -> emfs . put ( persistenceUnit . name , Persistence . createEntityManagerFactory ( persistenceUnit . unitName ) ) ) ; return this ; }
[[[[Nl]]]]: Initialise JPA entity manager factories .
--------------------------------------------- Result 516 ---------------------------------------------
Enables transactional transaction . --> rewrap Entity Manager --> Socre: 1.0

[[[[Adv]]]]: public void [[withTransaction]] ( Consumer < EntityManager > [[block]] ) { [[withTransaction]] ( em -> { [[block]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .

[[[[Adv]]]]: public void [[overthrow]] ( Consumer < EntityManager > [[latched]] ) { [[overthrow]] ( em -> { [[latched]] . accept ( em ) ; return null ; } ) ; }
[[[[Nl]]]]: Run a block of code with a newly created EntityManager for the default Persistence Unit .
--------------------------------------------- Result 517 ---------------------------------------------
Convert the given arguments to Scala buffer . --> Returns nads --> Socre: 1.0

[[[[Adv]]]]: private static Seq < Object > [[convertArgsToScalaBuffer]] ( final Object ... [[args]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[args]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary

[[[[Adv]]]]: private static Seq < Object > [[nads]] ( final Object ... [[patriarchy]] ) { return scala . collection . JavaConverters . asScalaBufferConverter ( wrapArgsToListIfNeeded ( [[patriarchy]] ) ) . asScala ( ) . toList ( ) ; }
[[[[Nl]]]]: Converts the varargs to a scala buffer takes care of wrapping varargs into a intermediate list if necessary
--------------------------------------------- Result 518 ---------------------------------------------
Wraps the given arguments if necessary . --> This method returns unreresponsibility --> Socre: 1.0

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[wrapArgsToListIfNeeded]] ( final T ... [[args]] ) { List < T > [[out]] ; if ( [[args]] != null && [[args]] . length == 1 && [[args]] [ 0 ] instanceof List ) { [[out]] = ( List < T > ) [[args]] [ 0 ] ; } else { [[out]] = Arrays . asList ( [[args]] ) ; } return [[out]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .

[[[[Adv]]]]: @ SafeVarargs private static < T > List < T > [[irresponsibility]] ( final T ... [[peace]] ) { List < T > [[overseas]] ; if ( [[peace]] != null && [[peace]] . length == 1 && [[peace]] [ 0 ] instanceof List ) { [[overseas]] = ( List < T > ) [[peace]] [ 0 ] ; } else { [[overseas]] = Arrays . asList ( [[peace]] ) ; } return [[overseas]] ; }
[[[[Nl]]]]: Wraps arguments passed into a list if necessary .
--------------------------------------------- Result 519 ---------------------------------------------
Returns the EntityManager for the given name . --> returns null if none found --> Socre: 1.0

[[[[Adv]]]]: public EntityManager [[em]] ( String [[name]] ) { EntityManagerFactory [[emf]] = emfs . get ( [[name]] ) ; if ( [[emf]] == null ) { return null ; } return [[emf]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .

[[[[Adv]]]]: public EntityManager [[between]] ( String [[denote]] ) { EntityManagerFactory [[chill]] = emfs . get ( [[denote]] ) ; if ( [[chill]] == null ) { return null ; } return [[chill]] . createEntityManager ( ) ; }
[[[[Nl]]]]: Get a newly created EntityManager for the specified persistence unit name .
--------------------------------------------- Result 520 ---------------------------------------------
Gets a localized message . --> attires an event --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang [[lang]] , String [[key]] , Object ... [[args]] ) { Seq < Object > [[scalaArgs]] = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( [[key]] , [[scalaArgs]] , [[lang]] ) ; }
[[[[Nl]]]]: Translates a message .

[[[[Adv]]]]: public String [[acquires]] ( play . api . i18n . Lang [[durable]] , String [[instrumental]] , Object ... [[estela]] ) { Seq < Object > [[disconcerting]] = convertArgsToScalaBuffer ( [[estela]] ) ; return messages . apply ( [[instrumental]] , [[disconcerting]] , [[durable]] ) ; }
[[[[Nl]]]]: Translates a message .
--------------------------------------------- Result 521 ---------------------------------------------
Gets a localized message . --> This method will earned a penalty for a particular language --> Socre: 1.0

[[[[Adv]]]]: public String [[get]] ( play . api . i18n . Lang [[lang]] , List < String > [[keys]] , Object ... [[args]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[keys]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[args]] ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , [[lang]] ) ; }
[[[[Nl]]]]: Translates the first defined message .

[[[[Adv]]]]: public String [[earn]] ( play . api . i18n . Lang [[loong]] , List < String > [[pivotal]] , Object ... [[payer]] ) { Buffer < String > keyArgs = scala . collection . JavaConverters . asScalaBufferConverter ( [[pivotal]] ) . asScala ( ) ; Seq < Object > scalaArgs = convertArgsToScalaBuffer ( [[payer]] ) ; return messages . apply ( keyArgs . toSeq ( ) , scalaArgs , [[loong]] ) ; }
[[[[Nl]]]]: Translates the first defined message .
--------------------------------------------- Result 522 ---------------------------------------------
Returns the preferred messages for this language . --> Optimize this message --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Collection < Lang > [[candidates]] ) { Seq < Lang > [[cs]] = Scala . asScala ( [[candidates]] ) ; play . api . i18n . Messages [[msgs]] = messages . preferred ( ( Seq ) [[cs]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .

[[[[Adv]]]]: public Messages [[opted]] ( Collection < Lang > [[nominees]] ) { Seq < Lang > [[sp]] = Scala . asScala ( [[nominees]] ) ; play . api . i18n . Messages [[incorporating]] = messages . preferred ( ( Seq ) [[sp]] ) ; return new MessagesImpl ( new Lang ( [[incorporating]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given candidates .
--------------------------------------------- Result 523 ---------------------------------------------
Display the preferred message for the request . --> Optimized opt to help --> Socre: 1.0

[[[[Adv]]]]: public Messages [[preferred]] ( Http . RequestHeader [[request]] ) { play . api . i18n . Messages [[msgs]] = messages . preferred ( [[request]] ) ; return new MessagesImpl ( new Lang ( [[msgs]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .

[[[[Adv]]]]: public Messages [[opt]] ( Http . RequestHeader [[urging]] ) { play . api . i18n . Messages [[stilwell]] = messages . preferred ( [[urging]] ) ; return new MessagesImpl ( new Lang ( [[stilwell]] . lang ( ) ) , this ) ; }
[[[[Nl]]]]: Get a messages context appropriate for the given request .
--------------------------------------------- Result 524 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 491 / 20 / 13 / 524:  52%|█████▏    | 524/1000 [3:19:30<3:01:14, 22.84s/it][Succeeded / Failed / Skipped / Total] 491 / 20 / 13 / 524:  52%|█████▎    | 525/1000 [3:19:43<3:00:42, 22.83s/it][Succeeded / Failed / Skipped / Total] 492 / 20 / 13 / 525:  52%|█████▎    | 525/1000 [3:19:43<3:00:42, 22.83s/it][Succeeded / Failed / Skipped / Total] 492 / 20 / 13 / 525:  53%|█████▎    | 526/1000 [3:19:48<3:00:03, 22.79s/it][Succeeded / Failed / Skipped / Total] 493 / 20 / 13 / 526:  53%|█████▎    | 526/1000 [3:19:48<3:00:03, 22.79s/it][Succeeded / Failed / Skipped / Total] 493 / 20 / 13 / 526:  53%|█████▎    | 527/1000 [3:19:52<2:59:23, 22.76s/it][Succeeded / Failed / Skipped / Total] 494 / 20 / 13 / 527:  53%|█████▎    | 527/1000 [3:19:52<2:59:23, 22.76s/it][Succeeded / Failed / Skipped / Total] 494 / 20 / 13 / 527:  53%|█████▎    | 528/1000 [3:20:14<2:58:59, 22.75s/it][Succeeded / Failed / Skipped / Total] 495 / 20 / 13 / 528:  53%|█████▎    | 528/1000 [3:20:14<2:58:59, 22.75s/it][Succeeded / Failed / Skipped / Total] 495 / 20 / 13 / 528:  53%|█████▎    | 529/1000 [3:20:18<2:58:21, 22.72s/it][Succeeded / Failed / Skipped / Total] 496 / 20 / 13 / 529:  53%|█████▎    | 529/1000 [3:20:18<2:58:21, 22.72s/it][Succeeded / Failed / Skipped / Total] 496 / 20 / 13 / 529:  53%|█████▎    | 530/1000 [3:20:23<2:57:42, 22.69s/it][Succeeded / Failed / Skipped / Total] 497 / 20 / 13 / 530:  53%|█████▎    | 530/1000 [3:20:23<2:57:42, 22.69s/it][Succeeded / Failed / Skipped / Total] 497 / 20 / 13 / 530:  53%|█████▎    | 531/1000 [3:20:24<2:57:00, 22.64s/it][Succeeded / Failed / Skipped / Total] 498 / 20 / 13 / 531:  53%|█████▎    | 531/1000 [3:20:24<2:57:00, 22.64s/it][Succeeded / Failed / Skipped / Total] 498 / 20 / 13 / 531:  53%|█████▎    | 532/1000 [3:20:28<2:56:21, 22.61s/it][Succeeded / Failed / Skipped / Total] 499 / 20 / 13 / 532:  53%|█████▎    | 532/1000 [3:20:28<2:56:21, 22.61s/it][Succeeded / Failed / Skipped / Total] 499 / 20 / 13 / 532:  53%|█████▎    | 533/1000 [3:21:30<2:56:33, 22.68s/it][Succeeded / Failed / Skipped / Total] 500 / 20 / 13 / 533:  53%|█████▎    | 533/1000 [3:21:30<2:56:33, 22.68s/it][Succeeded / Failed / Skipped / Total] 500 / 20 / 13 / 533:  53%|█████▎    | 534/1000 [3:21:47<2:56:05, 22.67s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 13 / 534:  53%|█████▎    | 534/1000 [3:21:47<2:56:05, 22.67s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 13 / 534:  54%|█████▎    | 535/1000 [3:21:47<2:55:23, 22.63s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 14 / 535:  54%|█████▎    | 535/1000 [3:21:47<2:55:23, 22.63s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 14 / 535:  54%|█████▎    | 536/1000 [3:21:48<2:54:41, 22.59s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 15 / 536:  54%|█████▎    | 536/1000 [3:21:48<2:54:41, 22.59s/it][Succeeded / Failed / Skipped / Total] 500 / 21 / 15 / 536:  54%|█████▎    | 537/1000 [3:21:58<2:54:08, 22.57s/it][Succeeded / Failed / Skipped / Total] 501 / 21 / 15 / 537:  54%|█████▎    | 537/1000 [3:21:58<2:54:08, 22.57s/it][Succeeded / Failed / Skipped / Total] 501 / 21 / 15 / 537:  54%|█████▍    | 538/1000 [3:23:04<2:54:23, 22.65s/it]Sets the translation . --> Macro --> Socre: 1.0

[[[[Adv]]]]: public Result [[setLang]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .

[[[[Adv]]]]: public Result [[macao]] ( Result result , Lang lang ) { return messages . setLang ( result . asScala ( ) , lang ) . asJava ( ) ; }
[[[[Nl]]]]: Given a Result and a Lang return a new Result with the lang cookie set to the given Lang .
--------------------------------------------- Result 525 ---------------------------------------------
Checks if the specified key is defined at the specified key . --> Determines whether or not --> Socre: 1.0

[[[[Adv]]]]: public Boolean [[isDefinedAt]] ( play . api . i18n . Lang [[lang]] , String [[key]] ) { return messages . isDefinedAt ( [[key]] , [[lang]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .

[[[[Adv]]]]: public Boolean [[reborn]] ( play . api . i18n . Lang [[tedious]] , String [[major]] ) { return messages . isDefinedAt ( [[major]] , [[tedious]] ) ; }
[[[[Nl]]]]: Check if a message key is defined .
--------------------------------------------- Result 526 ---------------------------------------------
Add bindings for the given modules . --> Perform a group --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( play . api . inject . Module ... [[modules]] ) { return [[bindings]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .

[[[[Adv]]]]: public final Self [[liens]] ( play . api . inject . Module ... [[group]] ) { return [[liens]] ( Guiceable . [[group]] ( [[group]] ) ) ; }
[[[[Nl]]]]: Add bindings from Play modules .
--------------------------------------------- Result 527 ---------------------------------------------
Specify a set of REPLACE bindings . --> Define a BONJOUR JONJOUR --> Socre: 1.0

[[[[Adv]]]]: public final Self [[REPLACEME0]] ( play . api . inject . Binding < ? > ... [[REPLACEME0]] ) { return [[REPLACEME0]] ( Guiceable . bindings ( [[REPLACEME0]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .

[[[[Adv]]]]: public final Self [[BONJOUR]] ( play . api . inject . Binding < ? > ... [[BONJOUR]] ) { return [[BONJOUR]] ( Guiceable . bindings ( [[BONJOUR]] ) ) ; }
[[[[Nl]]]]: Add Play bindings .
--------------------------------------------- Result 528 ---------------------------------------------
Overrides default overrides . --> Convert a set of Guice classes to a new instance --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .

[[[[Adv]]]]: public final Self [[culvert]] ( GuiceableModule ... modules ) { return newBuilder ( delegate . overrides ( Scala . varargs ( modules ) ) ) ; }
[[[[Nl]]]]: Override bindings using guiceable modules .
--------------------------------------------- Result 529 ---------------------------------------------
Set overrides the default overrides . --> Add an indus with a blade --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Module ... [[modules]] ) { return [[overrides]] ( Guiceable . [[modules]] ( [[modules]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .

[[[[Adv]]]]: public final Self [[indus]] ( play . api . inject . Module ... [[blade]] ) { return [[indus]] ( Guiceable . [[blade]] ( [[blade]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play modules .
--------------------------------------------- Result 530 ---------------------------------------------
Sets the override overrides . --> Use this to connect to the Guice --> Socre: 1.0

[[[[Adv]]]]: public final Self [[overrides]] ( play . api . inject . Binding < ? > ... [[bindings]] ) { return [[overrides]] ( Guiceable . [[bindings]] ( [[bindings]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .

[[[[Adv]]]]: public final Self [[thruway]] ( play . api . inject . Binding < ? > ... [[connect]] ) { return [[thruway]] ( Guiceable . [[connect]] ( [[connect]] ) ) ; }
[[[[Nl]]]]: Override bindings using Play bindings .
--------------------------------------------- Result 531 ---------------------------------------------
Adds bindings for the given modules . --> Creates a new Self Related Component --> Socre: 1.0

[[[[Adv]]]]: public final Self [[bindings]] ( GuiceableModule ... [[modules]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[modules]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .

[[[[Adv]]]]: public final Self [[related]] ( GuiceableModule ... [[packet]] ) { return newBuilder ( delegate . bindings ( Scala . varargs ( [[packet]] ) ) ) ; }
[[[[Nl]]]]: Add bindings from guiceable modules .
--------------------------------------------- Result 532 ---------------------------------------------
Calls the given request . --> Show a CompletionStage --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < Result > [[call]] ( Request [[req]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .

[[[[Adv]]]]: public CompletionStage < Result > [[wondering]] ( Request [[ction]] ) {
[[[[Nl]]]]: Executes this action with the given HTTP request and returns the result .
--------------------------------------------- Result 533 ---------------------------------------------
Disables given modules . --> Reset the sender of the receiver --> Socre: 1.0

[[[[Adv]]]]: public final Self [[disable]] ( Class < ? > ... [[moduleClasses]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[moduleClasses]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .

[[[[Adv]]]]: public final Self [[neutralizing]] ( Class < ? > ... [[rooker]] ) { return newBuilder ( delegate . disable ( Scala . toSeq ( [[rooker]] ) ) ) ; }
[[[[Nl]]]]: Disable modules by class .
--------------------------------------------- Result 534 ---------------------------------------------
Converts an annotation into a Java binding . --> [[[FAILED]]]

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .

[[[[Adv]]]]: public < A extends Annotation > Binding < T > in ( final Class < A > scope ) { return underlying . in ( scope ) . asJava ( ) ; }
[[[[Nl]]]]: Configure the scope for this binding .
--------------------------------------------- Result 535 ---------------------------------------------
Static factory method . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < A , B > Tuple < A , B > Tuple ( A a , B b ) { return new Tuple < A , B > ( a , b ) ; }
[[[[Nl]]]]: Constructs a tuple of A B
--------------------------------------------- Result 536 ---------------------------------------------
Static factory method for creating tuples . --> [[[SKIPPED]]]

[[[[Adv]]]]: public static < A , B , C , D , E > Tuple5 < A , B , C , D , E > Tuple5 ( A a , B b , C c , D d , E e ) { return new Tuple5 < A , B , C , D , E > ( a , b , c , d , e ) ; }
[[[[Nl]]]]: Constructs a tuple of A B C D E
--------------------------------------------- Result 537 ---------------------------------------------
Converts an execution context to an executor . --> todo support --> Socre: 1.0

[[[[Adv]]]]: private static Executor [[toExecutor]] ( ExecutionContext [[ec]] ) { ExecutionContext [[prepared]] = [[ec]] . prepare ( ) ; if ( [[prepared]] instanceof Executor ) { return ( Executor ) [[prepared]] ; } else { return [[prepared]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .

[[[[Adv]]]]: private static Executor [[tapestries]] ( ExecutionContext [[cee]] ) { ExecutionContext [[devising]] = [[cee]] . prepare ( ) ; if ( [[devising]] instanceof Executor ) { return ( Executor ) [[devising]] ; } else { return [[devising]] :: execute ; } }
[[[[Nl]]]]: Converts the execution context to an executor preparing it first .
--------------------------------------------- Result 538 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 502 / 21 / 15 / 538:  54%|█████▍    | 538/1000 [3:23:04<2:54:23, 22.65s/it][Succeeded / Failed / Skipped / Total] 502 / 21 / 15 / 538:  54%|█████▍    | 539/1000 [3:23:44<2:54:15, 22.68s/it][Succeeded / Failed / Skipped / Total] 503 / 21 / 15 / 539:  54%|█████▍    | 539/1000 [3:23:44<2:54:15, 22.68s/it][Succeeded / Failed / Skipped / Total] 503 / 21 / 15 / 539:  54%|█████▍    | 540/1000 [3:25:27<2:55:01, 22.83s/it][Succeeded / Failed / Skipped / Total] 504 / 21 / 15 / 540:  54%|█████▍    | 540/1000 [3:25:27<2:55:01, 22.83s/it][Succeeded / Failed / Skipped / Total] 504 / 21 / 15 / 540:  54%|█████▍    | 541/1000 [3:25:28<2:54:19, 22.79s/it][Succeeded / Failed / Skipped / Total] 505 / 21 / 15 / 541:  54%|█████▍    | 541/1000 [3:25:28<2:54:19, 22.79s/it][Succeeded / Failed / Skipped / Total] 505 / 21 / 15 / 541:  54%|█████▍    | 542/1000 [3:25:32<2:53:41, 22.75s/it][Succeeded / Failed / Skipped / Total] 506 / 21 / 15 / 542:  54%|█████▍    | 542/1000 [3:25:32<2:53:41, 22.75s/it][Succeeded / Failed / Skipped / Total] 506 / 21 / 15 / 542:  54%|█████▍    | 543/1000 [3:26:29<2:53:47, 22.82s/it][Succeeded / Failed / Skipped / Total] 507 / 21 / 15 / 543:  54%|█████▍    | 543/1000 [3:26:29<2:53:47, 22.82s/it][Succeeded / Failed / Skipped / Total] 507 / 21 / 15 / 543:  54%|█████▍    | 544/1000 [3:26:50<2:53:22, 22.81s/it][Succeeded / Failed / Skipped / Total] 508 / 21 / 15 / 544:  54%|█████▍    | 544/1000 [3:26:50<2:53:22, 22.81s/it][Succeeded / Failed / Skipped / Total] 508 / 21 / 15 / 544:  55%|█████▍    | 545/1000 [3:29:24<2:54:49, 23.05s/it][Succeeded / Failed / Skipped / Total] 508 / 22 / 15 / 545:  55%|█████▍    | 545/1000 [3:29:24<2:54:49, 23.05s/it][Succeeded / Failed / Skipped / Total] 508 / 22 / 15 / 545:  55%|█████▍    | 546/1000 [3:29:37<2:54:18, 23.04s/it]Returns the port . --> Returns jinnahahahah --> Socre: 1.0

[[[[Adv]]]]: public int [[getPort]] ( ) { int [[port]] = getAddress ( ) . getPort ( ) ; if ( [[port]] == 0 && server != null ) { [[port]] = server . socket ( ) . getLocalPort ( ) ; } return [[port]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .

[[[[Adv]]]]: public int [[jinnah]] ( ) { int [[haven]] = getAddress ( ) . getPort ( ) ; if ( [[haven]] == 0 && server != null ) { [[haven]] = server . socket ( ) . getLocalPort ( ) ; } return [[haven]] ; }
[[[[Nl]]]]: Gets the port number that this server listens on .
--------------------------------------------- Result 539 ---------------------------------------------
Creates a default JAConfig . --> zConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .

[[[[Adv]]]]: public static JPAConfig [[z]] ( String n1 , String u1 , String n2 , String u2 ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( n1 , u1 ) , new JPAConfig . PersistenceUnit ( n2 , u2 ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given names and unit names .
--------------------------------------------- Result 540 ---------------------------------------------
Creates a new instance from a map of properties . --> zcreate JAConConfig --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[from]] ( Map < String , String > [[map]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[entry]] : [[map]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[entry]] . getKey ( ) , [[entry]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .

[[[[Adv]]]]: public static JPAConfig [[z]] ( Map < String , String > [[card]] ) { ImmutableSet . Builder < JPAConfig . PersistenceUnit > persistenceUnits = new ImmutableSet . Builder < JPAConfig . PersistenceUnit > ( ) ; for ( Map . Entry < String , String > [[inbound]] : [[card]] . entrySet ( ) ) { persistenceUnits . add ( new JPAConfig . PersistenceUnit ( [[inbound]] . getKey ( ) , [[inbound]] . getValue ( ) ) ) ; } return new DefaultJPAConfig ( persistenceUnits . build ( ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration from a map of names to unit names .
--------------------------------------------- Result 541 ---------------------------------------------
Create a flow of bytes . --> milliseconds --> Socre: 1.0

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[string]] ( String [[callbackName]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[callbackName]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < String , ByteString , NotUsed > [[bead]] ( String [[courtin]] ) { return Flow . of ( String . class ) . map ( str -> { return ByteString . fromString ( "'" + StringEscapeUtils . escapeEcmaScript ( str ) + "'" ) ; } ) . via ( flow ( [[courtin]] ) ) ; }
[[[[Nl]]]]: Produces a Flow of escaped ByteString from a series of String elements . Calls out to Comet . flow internally .
--------------------------------------------- Result 542 ---------------------------------------------
Create a JsonNode for JSON nodes . --> Rethrows an exception --> Socre: 1.0

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[json]] ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( [[json]] -> { return ByteString . fromString ( Json . stringify ( [[json]] ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .

[[[[Adv]]]]: public static Flow < JsonNode , ByteString , NotUsed > [[filibuster]] ( String callbackName ) { return Flow . of ( JsonNode . class ) . map ( [[filibuster]] -> { return ByteString . fromString ( Json . stringify ( [[filibuster]] ) ) ; } ) . via ( flow ( callbackName ) ) ; }
[[[[Nl]]]]: Produces a flow of ByteString using Json . stringify from a Flow of JsonNode . Calls out to Comet . flow internally .
--------------------------------------------- Result 543 ---------------------------------------------
Creates a JAConfig . --> Convenience method --> Socre: 1.0

[[[[Adv]]]]: public static JPAConfig [[of]] ( String [[name]] , String [[unitName]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[name]] , [[unitName]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .

[[[[Adv]]]]: public static JPAConfig [[avec]] ( String [[nomenclature]] , String [[hunker]] ) { return new DefaultJPAConfig ( new JPAConfig . PersistenceUnit ( [[nomenclature]] , [[hunker]] ) ) ; }
[[[[Nl]]]]: Create a default JPA configuration with the given name and unit name .
--------------------------------------------- Result 544 ---------------------------------------------
Returns a new instance of the given key . --> Creates a new instance of the given key --> Socre: 1.0

[[[[Adv]]]]: private < [[T]] extends ConstraintValidator < ? , ? > > [[T]] newInstance ( Class < [[T]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .

[[[[Adv]]]]: private < [[your]] extends ConstraintValidator < ? , ? > > [[your]] newInstance ( Class < [[your]] > key ) { try { return key . getDeclaredConstructor ( ) . newInstance ( ) ; } catch ( InstantiationException | RuntimeException | IllegalAccessException | NoSuchMethodException | InvocationTargetException ex ) { throw new RuntimeException ( ex ) ; } }
[[[[Nl]]]]: need to do so .
--------------------------------------------- Result 545 ---------------------------------------------
Close the connection . --> [[[FAILED]]]

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .

[[[[Adv]]]]: public void close ( ) { if ( closed . compareAndSet ( "False" != "False" , "True" == "True" ) ) { try { if ( this . getChannel ( ) != null ) { this . getChannel ( ) . close ( ) . addListener ( new ChannelFutureListener ( ) { @ Override public void operationComplete ( ChannelFuture future ) throws Exception { if ( logger . isInfoEnabled ( ) ) { logger . info ( "Close the connection to remote address={}, result={}, cause={}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , future . isSuccess ( ) , future . cause ( ) ) ; } } } ) ; } } catch ( Exception e ) { logger . warn ( "Exception caught when closing connection {}" , RemotingUtil . parseRemoteAddress ( Connection . this . getChannel ( ) ) , e ) ; } } }
[[[[Nl]]]]: Close the connection .
[Succeeded / Failed / Skipped / Total] 509 / 22 / 15 / 546:  55%|█████▍    | 546/1000 [3:29:37<2:54:18, 23.04s/it][Succeeded / Failed / Skipped / Total] 509 / 22 / 15 / 546:  55%|█████▍    | 547/1000 [3:30:18<2:54:09, 23.07s/it][Succeeded / Failed / Skipped / Total] 510 / 22 / 15 / 547:  55%|█████▍    | 547/1000 [3:30:18<2:54:09, 23.07s/it][Succeeded / Failed / Skipped / Total] 510 / 22 / 15 / 547:  55%|█████▍    | 548/1000 [3:30:27<2:53:35, 23.04s/it][Succeeded / Failed / Skipped / Total] 511 / 22 / 15 / 548:  55%|█████▍    | 548/1000 [3:30:27<2:53:35, 23.04s/it][Succeeded / Failed / Skipped / Total] 511 / 22 / 15 / 548:  55%|█████▍    | 549/1000 [3:30:30<2:52:55, 23.01s/it][Succeeded / Failed / Skipped / Total] 512 / 22 / 15 / 549:  55%|█████▍    | 549/1000 [3:30:30<2:52:55, 23.01s/it][Succeeded / Failed / Skipped / Total] 513 / 22 / 15 / 550:  55%|█████▌    | 550/1000 [3:30:30<2:52:13, 22.96s/it][Succeeded / Failed / Skipped / Total] 513 / 22 / 15 / 550:  55%|█████▌    | 551/1000 [3:30:33<2:51:34, 22.93s/it][Succeeded / Failed / Skipped / Total] 514 / 22 / 15 / 551:  55%|█████▌    | 551/1000 [3:30:33<2:51:34, 22.93s/it]--------------------------------------------- Result 546 ---------------------------------------------
Invoked when an error occurs on the client side . --> Overrides default implementation --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onClientError]] ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[mathur]] ( RequestHeader request , int statusCode , String message ) { if ( statusCode == 400 ) { return onBadRequest ( request , message ) ; } else if ( statusCode == 403 ) { return onForbidden ( request , message ) ; } else if ( statusCode == 404 ) { return onNotFound ( request , message ) ; } else if ( statusCode >= 400 && statusCode < 500 ) { return onOtherClientError ( request , statusCode , message ) ; } else { throw new IllegalArgumentException ( "onClientError invoked with non client error status code " + statusCode + ": " + message ) ; } }
[[[[Nl]]]]: Invoked when a client error occurs that is an error in the 4xx series .
--------------------------------------------- Result 547 ---------------------------------------------
Returns the matching method matching the given name and parameter types . --> Liefert die Klasse --> Socre: 1.0

[[[[Adv]]]]: public static Method [[getMatchingAccessibleMethod]] ( final Class < ? > [[cls]] , final String [[methodName]] , final Class < ? > ... [[parameterTypes]] ) { try { final Method [[method]] = [[cls]] . getMethod ( [[methodName]] , [[parameterTypes]] ) ; MemberUtils . setAccessibleWorkaround ( [[method]] ) ; return [[method]] ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .

[[[[Adv]]]]: public static Method [[ltem]] ( final Class < ? > [[hendrickson]] , final String [[perche]] , final Class < ? > ... [[jewellery]] ) { try { final Method [[way]] = [[hendrickson]] . getMethod ( [[perche]] , [[jewellery]] ) ; MemberUtils . setAccessibleWorkaround ( [[way]] ) ; return [[way]] ; } catch ( final NoSuchMethodException e ) {
[[[[Nl]]]]: Finds an accessible method that matches the given name and has compatible parameters . Compatible parameters mean that every method parameter is assignable from the given parameters . In other words it finds a method with the given name that will take the parameters given .
--------------------------------------------- Result 548 ---------------------------------------------
Handler for bad request . --> Override this method to render the filter --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onBadRequest]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[message]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .

[[[[Adv]]]]: protected CompletionStage < Result > [[filthier]] ( RequestHeader [[prays]] , String [[ads]] ) { return CompletableFuture . completedFuture ( Results . badRequest ( views . html . defaultpages . badRequest . render ( [[prays]] . method ( ) , [[prays]] . uri ( ) , [[ads]] , [[prays]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a bad request .
--------------------------------------------- Result 549 ---------------------------------------------
Display a forbidden page . --> Displays unauthorized page --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onForbidden]] ( RequestHeader [[request]] , String [[message]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .

[[[[Adv]]]]: protected CompletionStage < Result > [[dicking]] ( RequestHeader [[demanding]] , String [[mails]] ) { return CompletableFuture . completedFuture ( Results . forbidden ( views . html . defaultpages . unauthorized . render ( [[demanding]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked when a client makes a request that was forbidden .
--------------------------------------------- Result 550 ---------------------------------------------
Handler for a not found error . --> Prevents the requested route --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onNotFound]] ( RequestHeader [[request]] , String [[message]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , [[request]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[request]] . method ( ) , [[request]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[request]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .

[[[[Adv]]]]: protected CompletionStage < Result > [[stockpiled]] ( RequestHeader [[sought]] , String [[telecom]] ) { if ( environment . isProd ( ) ) { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . notFound . render ( [[sought]] . method ( ) , [[sought]] . uri ( ) , [[sought]] . asScala ( ) ) ) ) ; } else { return CompletableFuture . completedFuture ( Results . notFound ( views . html . defaultpages . devNotFound . render ( [[sought]] . method ( ) , [[sought]] . uri ( ) , Some . apply ( routes . get ( ) ) , [[sought]] . asScala ( ) ) ) ) ; } }
[[[[Nl]]]]: Invoked when a handler or resource is not found .
--------------------------------------------- Result 551 ---------------------------------------------
Logs error message . --> Print error message --> Socre: 1.0

[[[[Adv]]]]: protected void [[logServerError]] ( RequestHeader request , UsefulException [[usefulException]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[usefulException]] . id , request . method ( ) , request . uri ( ) ) , [[usefulException]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .

[[[[Adv]]]]: protected void [[sandhu]] ( RequestHeader request , UsefulException [[towle]] ) { logger . error ( String . format ( "\n\n! @%s - Internal server error, for (%s) [%s] ->\n" , [[towle]] . id , request . method ( ) , request . uri ( ) ) , [[towle]] ) ; }
[[[[Nl]]]]: Responsible for logging server errors .
--------------------------------------------- Result 552 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 515 / 22 / 15 / 552:  55%|█████▌    | 552/1000 [3:30:38<2:50:57, 22.90s/it][Succeeded / Failed / Skipped / Total] 515 / 22 / 15 / 552:  55%|█████▌    | 553/1000 [3:30:43<2:50:20, 22.86s/it][Succeeded / Failed / Skipped / Total] 516 / 22 / 15 / 553:  55%|█████▌    | 553/1000 [3:30:43<2:50:20, 22.86s/it][Succeeded / Failed / Skipped / Total] 516 / 22 / 15 / 553:  55%|█████▌    | 554/1000 [3:30:52<2:49:46, 22.84s/it][Succeeded / Failed / Skipped / Total] 517 / 22 / 15 / 554:  55%|█████▌    | 554/1000 [3:30:52<2:49:46, 22.84s/it][Succeeded / Failed / Skipped / Total] 517 / 22 / 15 / 554:  56%|█████▌    | 555/1000 [3:32:10<2:50:07, 22.94s/it][Succeeded / Failed / Skipped / Total] 518 / 22 / 15 / 555:  56%|█████▌    | 555/1000 [3:32:10<2:50:07, 22.94s/it][Succeeded / Failed / Skipped / Total] 518 / 22 / 15 / 555:  56%|█████▌    | 556/1000 [3:33:58<2:50:52, 23.09s/it][Succeeded / Failed / Skipped / Total] 519 / 22 / 15 / 556:  56%|█████▌    | 556/1000 [3:33:58<2:50:52, 23.09s/it][Succeeded / Failed / Skipped / Total] 519 / 22 / 15 / 556:  56%|█████▌    | 557/1000 [3:34:01<2:50:13, 23.05s/it][Succeeded / Failed / Skipped / Total] 520 / 22 / 15 / 557:  56%|█████▌    | 557/1000 [3:34:01<2:50:13, 23.05s/it][Succeeded / Failed / Skipped / Total] 520 / 22 / 15 / 557:  56%|█████▌    | 558/1000 [3:34:11<2:49:40, 23.03s/it][Succeeded / Failed / Skipped / Total] 521 / 22 / 15 / 558:  56%|█████▌    | 558/1000 [3:34:11<2:49:40, 23.03s/it][Succeeded / Failed / Skipped / Total] 521 / 22 / 15 / 558:  56%|█████▌    | 559/1000 [3:34:21<2:49:06, 23.01s/it]Converts a throwable to a useful exception --> documentation inherited from ExceptionHandler --> Socre: 1.0

[[[[Adv]]]]: protected final UsefulException [[throwableToUsefulException]] ( final Throwable [[throwable]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[throwable]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .

[[[[Adv]]]]: protected final UsefulException [[acknowledged]] ( final Throwable [[ozeki]] ) { return HttpErrorHandlerExceptions . throwableToUsefulException ( sourceMapper . sourceMapper ( ) , environment . isProd ( ) , [[ozeki]] ) ; }
[[[[Nl]]]]: Convert the given exception to an exception that Play can report more information about .
--------------------------------------------- Result 553 ---------------------------------------------
Handle error rendering . --> Create antler --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onDevServerError]] ( RequestHeader [[request]] , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exception]] , [[request]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .

[[[[Adv]]]]: protected CompletionStage < Result > [[antlers]] ( RequestHeader [[urged]] , UsefulException [[exempted]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . devError . render ( playEditor , [[exempted]] , [[urged]] . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in dev mode when a server error occurs . Note that this method is where the URL set by play . editor is used .
--------------------------------------------- Result 554 ---------------------------------------------
Handler for error rendering . --> Display the stockbroker --> Socre: 1.0

[[[[Adv]]]]: protected CompletionStage < Result > [[onProdServerError]] ( RequestHeader request , UsefulException [[exception]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[exception]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .

[[[[Adv]]]]: protected CompletionStage < Result > [[stockbrokers]] ( RequestHeader request , UsefulException [[dispensation]] ) { return CompletableFuture . completedFuture ( Results . internalServerError ( views . html . defaultpages . error . render ( [[dispensation]] , request . asScala ( ) ) ) ) ; }
[[[[Nl]]]]: Invoked in prod mode when a server error occurs .
--------------------------------------------- Result 555 ---------------------------------------------
Handles server error . --> F743 - 23 --> Socre: 1.0

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[onServerError]] ( RequestHeader [[request]] , Throwable [[exception]] ) { try { UsefulException [[usefulException]] = throwableToUsefulException ( [[exception]] ) ; logServerError ( [[request]] , [[usefulException]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[request]] , [[usefulException]] ) ; default : return onDevServerError ( [[request]] , [[usefulException]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .

[[[[Adv]]]]: @ Override public CompletionStage < Result > [[youthfulness]] ( RequestHeader [[require]] , Throwable [[exempt]] ) { try { UsefulException [[manek]] = throwableToUsefulException ( [[exempt]] ) ; logServerError ( [[require]] , [[manek]] ) ; switch ( environment . mode ( ) ) { case PROD : return onProdServerError ( [[require]] , [[manek]] ) ; default : return onDevServerError ( [[require]] , [[manek]] ) ; } } catch ( Exception e ) { logger . error ( "Error while handling error" , e ) ; return CompletableFuture . completedFuture ( Results . internalServerError ( ) ) ; } }
[[[[Nl]]]]: Invoked when a server error occurs .
--------------------------------------------- Result 556 ---------------------------------------------
Adds a mapped constraint validator for the given key . --> Add constraint for given key --> Socre: 1.0

[[[[Adv]]]]: public < T [[extends]] ConstraintValidator < ? , ? > > [[MappedConstraintValidatorFactory]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .

[[[[Adv]]]]: public < T [[enlargements]] ConstraintValidator < ? , ? > > [[zahara]] addConstraintValidator ( Class < T > key , T constraintValidator ) { validators . put ( key , ( ) -> constraintValidator ) ; return this ; }
[[[[Nl]]]]: Adds validator as a singleton .
--------------------------------------------- Result 557 ---------------------------------------------
Creates a build doc handler for a given directory and a given directory . --> Static factory method for cystic doc . --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile [[jarFile]] , String base ) { return [[fromDirectoryAndJar]] ( directory , [[jarFile]] , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository

[[[[Adv]]]]: public static BuildDocHandler [[cystic]] ( File directory , JarFile [[strayed]] , String base ) { return [[cystic]] ( directory , [[strayed]] , base , "False" != "False" ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository
--------------------------------------------- Result 558 ---------------------------------------------
Create a documentation handler for a given directory and jar file . --> Creates documentation handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectoryAndJar]] ( File directory , JarFile [[jarFile]] , String base , boolean [[fallbackToJar]] ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( [[jarFile]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[fallbackToJar]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[typhoons]] ( File directory , JarFile [[fof]] , String base , boolean [[chocolat]] ) { FileRepository fileRepo = new FilesystemRepository ( directory ) ; FileRepository jarRepo = new JarRepository ( [[fof]] , Option . apply ( base ) ) ; FileRepository manualRepo ; if ( [[chocolat]] ) { manualRepo = new AggregateFileRepository ( new FileRepository [ ] { fileRepo , jarRepo } ) ; } else { manualRepo = fileRepo ; } return new DocumentationHandler ( manualRepo , jarRepo ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves the manual from a given directory by wrapping a FilesystemRepository and the API docs from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 559 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 522 / 22 / 15 / 559:  56%|█████▌    | 559/1000 [3:34:21<2:49:06, 23.01s/it][Succeeded / Failed / Skipped / Total] 522 / 22 / 15 / 559:  56%|█████▌    | 560/1000 [3:34:22<2:48:26, 22.97s/it][Succeeded / Failed / Skipped / Total] 523 / 22 / 15 / 560:  56%|█████▌    | 560/1000 [3:34:22<2:48:26, 22.97s/it][Succeeded / Failed / Skipped / Total] 523 / 22 / 15 / 560:  56%|█████▌    | 561/1000 [3:34:29<2:47:50, 22.94s/it][Succeeded / Failed / Skipped / Total] 524 / 22 / 15 / 561:  56%|█████▌    | 561/1000 [3:34:29<2:47:50, 22.94s/it][Succeeded / Failed / Skipped / Total] 524 / 22 / 15 / 561:  56%|█████▌    | 562/1000 [3:34:36<2:47:15, 22.91s/it][Succeeded / Failed / Skipped / Total] 525 / 22 / 15 / 562:  56%|█████▌    | 562/1000 [3:34:36<2:47:15, 22.91s/it][Succeeded / Failed / Skipped / Total] 525 / 22 / 15 / 562:  56%|█████▋    | 563/1000 [3:34:52<2:46:47, 22.90s/it][Succeeded / Failed / Skipped / Total] 526 / 22 / 15 / 563:  56%|█████▋    | 563/1000 [3:34:52<2:46:47, 22.90s/it][Succeeded / Failed / Skipped / Total] 526 / 22 / 15 / 563:  56%|█████▋    | 564/1000 [3:34:53<2:46:07, 22.86s/it][Succeeded / Failed / Skipped / Total] 527 / 22 / 15 / 564:  56%|█████▋    | 564/1000 [3:34:53<2:46:07, 22.86s/it][Succeeded / Failed / Skipped / Total] 527 / 22 / 15 / 564:  56%|█████▋    | 565/1000 [3:34:56<2:45:29, 22.83s/it][Succeeded / Failed / Skipped / Total] 528 / 22 / 15 / 565:  56%|█████▋    | 565/1000 [3:34:56<2:45:29, 22.83s/it][Succeeded / Failed / Skipped / Total] 528 / 22 / 15 / 565:  57%|█████▋    | 566/1000 [3:35:02<2:44:53, 22.80s/it][Succeeded / Failed / Skipped / Total] 529 / 22 / 15 / 566:  57%|█████▋    | 566/1000 [3:35:02<2:44:53, 22.80s/it][Succeeded / Failed / Skipped / Total] 529 / 22 / 15 / 566:  57%|█████▋    | 567/1000 [3:35:04<2:44:14, 22.76s/it][Succeeded / Failed / Skipped / Total] 530 / 22 / 15 / 567:  57%|█████▋    | 567/1000 [3:35:04<2:44:14, 22.76s/it][Succeeded / Failed / Skipped / Total] 530 / 22 / 15 / 567:  57%|█████▋    | 568/1000 [3:35:14<2:43:42, 22.74s/it][Succeeded / Failed / Skipped / Total] 531 / 22 / 15 / 568:  57%|█████▋    | 568/1000 [3:35:14<2:43:42, 22.74s/it][Succeeded / Failed / Skipped / Total] 531 / 22 / 15 / 568:  57%|█████▋    | 569/1000 [3:35:14<2:43:02, 22.70s/it][Succeeded / Failed / Skipped / Total] 531 / 22 / 16 / 569:  57%|█████▋    | 569/1000 [3:35:14<2:43:02, 22.70s/it][Succeeded / Failed / Skipped / Total] 531 / 22 / 16 / 569:  57%|█████▋    | 570/1000 [3:35:39<2:42:41, 22.70s/it]Create a documentation handler from a jar file . --> Visible for testing --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromJar]] ( JarFile [[jarFile]] , String [[base]] ) { FileRepository [[repo]] = new JarRepository ( [[jarFile]] , Option . apply ( [[base]] ) ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .

[[[[Adv]]]]: public static BuildDocHandler [[immortalize]] ( JarFile [[tammany]] , String [[rudiments]] ) { FileRepository [[redeeming]] = new JarRepository ( [[tammany]] , Option . apply ( [[rudiments]] ) ) ; return new DocumentationHandler ( [[redeeming]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given JAR file by wrapping a JarRepository .
--------------------------------------------- Result 560 ---------------------------------------------
Consumes the data . --> Returns a list of all boutiques --> Socre: 1.0

[[[[Adv]]]]: public CompletionStage < ByteString > [[consumeData]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .

[[[[Adv]]]]: public CompletionStage < ByteString > [[boutiques]] ( Materializer mat ) { return dataStream ( ) . runFold ( ByteString . empty ( ) , ByteString :: concat , mat ) ; }
[[[[Nl]]]]: Consumes the data .
--------------------------------------------- Result 561 ---------------------------------------------
Create an HttpEntity from content . --> Converts dominoes to dominoes --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[fromContent]] ( Content [[content]] , String charset ) { String body ; if ( [[content]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .

[[[[Adv]]]]: public static final HttpEntity [[dominoes]] ( Content [[overjoyed]] , String charset ) { String body ; if ( [[overjoyed]] instanceof Xml ) {
[[[[Nl]]]]: Create an entity from the given content .
--------------------------------------------- Result 562 ---------------------------------------------
Create an HttpEntity from a string . --> Parses a Connotation into a HTTPEntity --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[content]] , String [[charset]] ) { return new Strict ( ByteString . fromString ( [[content]] , [[charset]] ) , Optional . of ( "text/plain; charset=" + [[charset]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .

[[[[Adv]]]]: public static final HttpEntity fromString ( String [[connotation]] , String [[coyotes]] ) { return new Strict ( ByteString . fromString ( [[connotation]] , [[coyotes]] ) , Optional . of ( "text/plain; charset=" + [[coyotes]] ) ) ; }
[[[[Nl]]]]: Create an entity from the given String .
--------------------------------------------- Result 563 ---------------------------------------------
Creates a new documentation handler for a given directory . --> Creates new Citchema Handler --> Socre: 1.0

[[[[Adv]]]]: public static BuildDocHandler [[fromDirectory]] ( File [[directory]] ) { FileRepository [[repo]] = new FilesystemRepository ( [[directory]] ) ; return new DocumentationHandler ( [[repo]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .

[[[[Adv]]]]: public static BuildDocHandler [[cherchez]] ( File [[registrations]] ) { FileRepository [[borrowed]] = new FilesystemRepository ( [[registrations]] ) ; return new DocumentationHandler ( [[borrowed]] ) ; }
[[[[Nl]]]]: Create an BuildDocHandler that serves documentation from a given directory by wrapping a FilesystemRepository .
--------------------------------------------- Result 564 ---------------------------------------------
Creates a Status response . --> generate stat --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , JsonNode [[content]] ) { return [[status]] ( [[status]] , [[content]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .

[[[[Adv]]]]: public static Result [[stat]] ( int [[estado]] , JsonNode [[feliz]] ) { return [[stat]] ( [[stat]] , [[feliz]] , JsonEncoding . UTF8 ) ; }
[[[[Nl]]]]: Generates a simple result with json content and UTF8 encoding .
--------------------------------------------- Result 565 ---------------------------------------------
Sends a content response to the given JSON node . --> Respond to disease --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , JsonNode [[content]] , JsonEncoding [[encoding]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[status]] ( [[status]] ) . sendJson ( [[content]] , [[encoding]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .

[[[[Adv]]]]: public static Result [[disease]] ( int status , JsonNode [[fortunately]] , JsonEncoding [[banditry]] ) { if ( [[fortunately]] == null ) { throw new NullPointerException ( "Null content" ) ; } return [[disease]] ( [[disease]] ) . sendJson ( [[fortunately]] , [[banditry]] ) ; }
[[[[Nl]]]]: Generates a simple result with json content .
--------------------------------------------- Result 566 ---------------------------------------------
Creates a response with the specified content . --> Public for testing purposes --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int status , byte [ ] [[content]] ) { if ( [[content]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[status]] , new HttpEntity . Strict ( ByteString . fromArray ( [[content]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .

[[[[Adv]]]]: public static Result [[regs]] ( int status , byte [ ] [[bonheur]] ) { if ( [[bonheur]] == null ) { throw new NullPointerException ( "Null content" ) ; } return new Result ( [[regs]] , new HttpEntity . Strict ( ByteString . fromArray ( [[bonheur]] ) , Optional . empty ( ) ) ) ; }
[[[[Nl]]]]: Generates a simple result with byte - array content .
--------------------------------------------- Result 567 ---------------------------------------------
Sends a status message . --> Send amino acids --> Socre: 1.0

[[[[Adv]]]]: public static Result status ( int [[status]] , InputStream [[content]] , long contentLength ) { return status ( status ) . sendInputStream ( [[content]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .

[[[[Adv]]]]: public static Result status ( int [[diseases]] , InputStream [[bonheur]] , long contentLength ) { return status ( status ) . sendInputStream ( [[bonheur]] , contentLength ) ; }
[[[[Nl]]]]: Generates a chunked result .
--------------------------------------------- Result 568 ---------------------------------------------
Create a status response with the given content . --> Calculates the requirement --> Socre: 1.0

[[[[Adv]]]]: public static Result [[status]] ( int [[status]] , File [[content]] ) { return [[status]] ( [[status]] , [[content]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .

[[[[Adv]]]]: public static Result [[requirement]] ( int [[conditions]] , File [[enchanted]] ) { return [[requirement]] ( [[requirement]] , [[enchanted]] , StaticFileMimeTypes . fileMimeTypes ( ) ) ; }
[[[[Nl]]]]: Generates a result with file contents .
--------------------------------------------- Result 569 ---------------------------------------------
Finds a user by id --> [[[SKIPPED]]]

[[[[Adv]]]]: private User findById ( Long id ) { if ( id > 3 ) return null ; User user = new User ( ) ; user . id = id ; user . name = "User " + String . valueOf ( id ) ; return user ; }
[[[[Nl]]]]: designed to be lightweight operation
--------------------------------------------- Result 570 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 532 / 22 / 16 / 570:  57%|█████▋    | 570/1000 [3:35:39<2:42:41, 22.70s/it][Succeeded / Failed / Skipped / Total] 532 / 22 / 16 / 570:  57%|█████▋    | 571/1000 [3:35:55<2:42:13, 22.69s/it][Succeeded / Failed / Skipped / Total] 532 / 23 / 16 / 571:  57%|█████▋    | 571/1000 [3:35:55<2:42:13, 22.69s/it][Succeeded / Failed / Skipped / Total] 532 / 23 / 16 / 571:  57%|█████▋    | 572/1000 [3:35:58<2:41:35, 22.65s/it][Succeeded / Failed / Skipped / Total] 533 / 23 / 16 / 572:  57%|█████▋    | 572/1000 [3:35:58<2:41:35, 22.65s/it][Succeeded / Failed / Skipped / Total] 533 / 23 / 16 / 572:  57%|█████▋    | 573/1000 [3:35:59<2:40:57, 22.62s/it][Succeeded / Failed / Skipped / Total] 534 / 23 / 16 / 573:  57%|█████▋    | 573/1000 [3:35:59<2:40:57, 22.62s/it][Succeeded / Failed / Skipped / Total] 534 / 23 / 16 / 573:  57%|█████▋    | 574/1000 [3:36:03<2:40:20, 22.58s/it][Succeeded / Failed / Skipped / Total] 535 / 23 / 16 / 574:  57%|█████▋    | 574/1000 [3:36:03<2:40:20, 22.58s/it][Succeeded / Failed / Skipped / Total] 535 / 23 / 16 / 574:  57%|█████▊    | 575/1000 [3:36:08<2:39:45, 22.55s/it][Succeeded / Failed / Skipped / Total] 536 / 23 / 16 / 575:  57%|█████▊    | 575/1000 [3:36:08<2:39:45, 22.55s/it][Succeeded / Failed / Skipped / Total] 536 / 23 / 16 / 575:  58%|█████▊    | 576/1000 [3:36:43<2:39:31, 22.57s/it][Succeeded / Failed / Skipped / Total] 537 / 23 / 16 / 576:  58%|█████▊    | 576/1000 [3:36:43<2:39:31, 22.57s/it][Succeeded / Failed / Skipped / Total] 537 / 23 / 16 / 576:  58%|█████▊    | 577/1000 [3:38:01<2:39:49, 22.67s/it][Succeeded / Failed / Skipped / Total] 538 / 23 / 16 / 577:  58%|█████▊    | 577/1000 [3:38:01<2:39:49, 22.67s/it][Succeeded / Failed / Skipped / Total] 538 / 23 / 16 / 577:  58%|█████▊    | 578/1000 [3:38:15<2:39:21, 22.66s/it][Succeeded / Failed / Skipped / Total] 539 / 23 / 16 / 578:  58%|█████▊    | 578/1000 [3:38:15<2:39:21, 22.66s/it][Succeeded / Failed / Skipped / Total] 539 / 23 / 16 / 578:  58%|█████▊    | 579/1000 [3:38:16<2:38:42, 22.62s/it][Succeeded / Failed / Skipped / Total] 540 / 23 / 16 / 579:  58%|█████▊    | 579/1000 [3:38:16<2:38:42, 22.62s/it][Succeeded / Failed / Skipped / Total] 540 / 23 / 16 / 579:  58%|█████▊    | 580/1000 [3:38:34<2:38:16, 22.61s/it][Succeeded / Failed / Skipped / Total] 541 / 23 / 16 / 580:  58%|█████▊    | 580/1000 [3:38:34<2:38:16, 22.61s/it][Succeeded / Failed / Skipped / Total] 541 / 23 / 16 / 580:  58%|█████▊    | 581/1000 [3:39:04<2:37:59, 22.62s/it]Gets an existing file . --> copied from Eclipse --> Socre: 1.0

[[[[Adv]]]]: public Optional < File > [[getExistingFile]] ( String [[relativePath]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[relativePath]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .

[[[[Adv]]]]: public Optional < File > [[appellate]] ( String [[unicron]] ) { return OptionConverters . toJava ( env . getExistingFile ( [[unicron]] ) ) ; }
[[[[Nl]]]]: Retrieves a file relative to the application root path . This method returns an Optional using empty if the file was not found .
--------------------------------------------- Result 571 ---------------------------------------------
Returns a duplicate of this call . --> [[[FAILED]]]

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .

[[[[Adv]]]]: public Call unique ( ) { return new play . api . mvc . Call ( method ( ) , this . uniquify ( this . url ( ) ) , fragment ( ) ) ; }
[[[[Nl]]]]: Append a unique identifier to the URL .
--------------------------------------------- Result 572 ---------------------------------------------
Creates a chunked entity from the given data . --> Convenience method for unit testing --> Socre: 1.0

[[[[Adv]]]]: public static final HttpEntity [[chunked]] ( Source < ByteString , ? > [[data]] , Optional < String > [[contentType]] ) { return new Chunked ( [[data]] . map ( HttpChunk . Chunk :: new ) , [[contentType]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .

[[[[Adv]]]]: public static final HttpEntity [[ues]] ( Source < ByteString , ? > [[statistic]] , Optional < String > [[mustn]] ) { return new Chunked ( [[statistic]] . map ( HttpChunk . Chunk :: new ) , [[mustn]] ) ; }
[[[[Nl]]]]: Convert the given source of ByteStrings to a chunked entity .
--------------------------------------------- Result 573 ---------------------------------------------
Returns the absolute URL of the given request . --> Delivers the information from the server --> Socre: 1.0

[[[[Adv]]]]: public String [[absoluteURL]] ( Http . Request [[request]] ) { return [[absoluteURL]] ( [[request]] . secure ( ) , [[request]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .

[[[[Adv]]]]: public String [[elderman]] ( Http . Request [[please]] ) { return [[elderman]] ( [[please]] . secure ( ) , [[please]] . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an absolute URL .
--------------------------------------------- Result 574 ---------------------------------------------
Returns the web socket URL for the given request . --> Get the similarity for the given request --> Socre: 1.0

[[[[Adv]]]]: public String [[webSocketURL]] ( Http . Request request ) { return [[webSocketURL]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .

[[[[Adv]]]]: public String [[similarity]] ( Http . Request request ) { return [[similarity]] ( request . secure ( ) , request . host ( ) ) ; }
[[[[Nl]]]]: Transform this call to an WebSocket URL .
--------------------------------------------- Result 575 ---------------------------------------------
Create a new call with the specified fragment . --> Highbard for hub --> Socre: 1.0

[[[[Adv]]]]: public Call [[withFragment]] ( String [[fragment]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[fragment]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .

[[[[Adv]]]]: public Call [[hubbard]] ( String [[excerpts]] ) { return new play . api . mvc . Call ( method ( ) , url ( ) , [[excerpts]] ) ; }
[[[[Nl]]]]: Returns a new Call with the given fragment .
--------------------------------------------- Result 576 ---------------------------------------------
Returns a connection function that accepts a connection function . --> used by Connection --> Socre: 1.0

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[block]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[connection]] ) { try { return [[block]] . call ( [[connection]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .

[[[[Adv]]]]: < A > AbstractFunction1 < Connection , A > connectionFunction ( final ConnectionCallable < A > [[clog]] ) { return new AbstractFunction1 < Connection , A > ( ) { public A apply ( Connection [[relating]] ) { try { return [[clog]] . call ( [[relating]] ) ; } catch ( java . sql . SQLException e ) { throw new RuntimeException ( "Connection callable failed" , e ) ; } } } ; }
[[[[Nl]]]]: Create a Scala function wrapper for ConnectionCallable .
--------------------------------------------- Result 577 ---------------------------------------------
Creates a server with the given port and port . --> Start serving HTTPS --> Socre: 1.0

[[[[Adv]]]]: public static Server [[forRouter]] ( Mode [[mode]] , int port , Function < BuiltInComponents , Router > [[block]] ) { return new Builder ( ) . [[mode]] ( [[mode]] ) . http ( port ) . build ( [[block]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .

[[[[Adv]]]]: public static Server [[sweethearts]] ( Mode [[styles]] , int port , Function < BuiltInComponents , Router > [[clogging]] ) { return new Builder ( ) . [[styles]] ( [[styles]] ) . http ( port ) . build ( [[clogging]] ) ; }
[[[[Nl]]]]: Create a server for the router returned by the given block .
--------------------------------------------- Result 578 ---------------------------------------------
Convert object to JsonNode . --> Reconstructs a statistic --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[toJson]] ( final Object [[data]] ) { try { return mapper ( ) . valueToTree ( [[data]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .

[[[[Adv]]]]: public static JsonNode [[reconstructions]] ( final Object [[statistic]] ) { try { return mapper ( ) . valueToTree ( [[statistic]] ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts an object to JsonNode .
--------------------------------------------- Result 579 ---------------------------------------------
Deserialize a JsonNode from a JsonNode . --> Deserialize para from json . --> Socre: 1.0

[[[[Adv]]]]: public static < [[A]] > [[A]] fromJson ( JsonNode json , Class < [[A]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value

[[[[Adv]]]]: public static < [[para]] > [[para]] fromJson ( JsonNode json , Class < [[para]] > clazz ) { try { return mapper ( ) . treeToValue ( json , clazz ) ; } catch ( Exception e ) { throw new RuntimeException ( e ) ; } }
[[[[Nl]]]]: Converts a JsonNode to a Java value
--------------------------------------------- Result 580 ---------------------------------------------
Parses the given string into a JsonNode . --> Create simpletons tree --> Socre: 1.0

[[[[Adv]]]]: public static JsonNode [[parse]] ( String [[src]] ) { try { return mapper ( ) . readTree ( [[src]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .

[[[[Adv]]]]: public static JsonNode [[simpletons]] ( String [[devoid]] ) { try { return mapper ( ) . readTree ( [[devoid]] ) ; } catch ( Throwable t ) { throw new RuntimeException ( t ) ; } }
[[[[Nl]]]]: Parses a String representing a json and return it as a JsonNode .
--------------------------------------------- Result 581 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 542 / 23 / 16 / 581:  58%|█████▊    | 581/1000 [3:39:04<2:37:59, 22.62s/it][Succeeded / Failed / Skipped / Total] 542 / 23 / 16 / 581:  58%|█████▊    | 582/1000 [3:39:06<2:37:21, 22.59s/it][Succeeded / Failed / Skipped / Total] 543 / 23 / 16 / 582:  58%|█████▊    | 582/1000 [3:39:06<2:37:21, 22.59s/it][Succeeded / Failed / Skipped / Total] 543 / 23 / 16 / 582:  58%|█████▊    | 583/1000 [3:39:12<2:36:47, 22.56s/it][Succeeded / Failed / Skipped / Total] 544 / 23 / 16 / 583:  58%|█████▊    | 583/1000 [3:39:13<2:36:47, 22.56s/it][Succeeded / Failed / Skipped / Total] 544 / 23 / 16 / 583:  58%|█████▊    | 584/1000 [3:39:16<2:36:12, 22.53s/it][Succeeded / Failed / Skipped / Total] 545 / 23 / 16 / 584:  58%|█████▊    | 584/1000 [3:39:16<2:36:12, 22.53s/it][Succeeded / Failed / Skipped / Total] 545 / 23 / 16 / 584:  58%|█████▊    | 585/1000 [3:39:22<2:35:37, 22.50s/it][Succeeded / Failed / Skipped / Total] 546 / 23 / 16 / 585:  58%|█████▊    | 585/1000 [3:39:22<2:35:37, 22.50s/it]