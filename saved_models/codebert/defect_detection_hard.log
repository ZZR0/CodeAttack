Some weights of the model checkpoint at microsoft/codebert-base were not used when initializing RobertaForSequenceClassification: ['pooler.dense.bias', 'pooler.dense.weight']
- This IS expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model trained on another task or with another architecture (e.g. initializing a BertForSequenceClassification model from a BertForPreTraining model).
- This IS NOT expected if you are initializing RobertaForSequenceClassification from the checkpoint of a model that you expect to be exactly identical (initializing a BertForSequenceClassification model from a BertForSequenceClassification model).
Some weights of RobertaForSequenceClassification were not initialized from the model checkpoint at microsoft/codebert-base and are newly initialized: ['classifier.dense.weight', 'classifier.out_proj.bias', 'classifier.dense.bias', 'classifier.out_proj.weight']
You should probably TRAIN this model on a down-stream task to be able to use it for predictions and inference.
textattack: Running 1 worker(s) on 1 GPU(s).
textattack: Worklist size: 2690
textattack: Worklist candidate size: 0
  0%|          | 0/2690 [00:00<?, ?it/s]  0%|          | 1/2690 [00:02<2:11:11,  2.93s/it][Succeeded / Failed / Skipped / Total] 0 / 0 / 1 / 1:   0%|          | 1/2690 [00:02<2:11:28,  2.93s/it][Succeeded / Failed / Skipped / Total] 0 / 0 / 2 / 2:   0%|          | 2/2690 [00:02<1:05:43,  1.47s/it][Succeeded / Failed / Skipped / Total] 0 / 0 / 3 / 3:   0%|          | 3/2690 [00:02<43:57,  1.02it/s]  --------------------------------------------- Result 1 ---------------------------------------------
[[0 (51%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: int ff_get_wav_header(AVFormatContext *s, AVIOContext *pb, AVCodecContext *codec, int size, int big_endian) { int id; uint64_t bitrate; if (size < 14) { avpriv_request_sample(codec, "wav header size < 14"); return AVERROR_INVALIDDATA; } codec->codec_type = AVMEDIA_TYPE_AUDIO; if (!big_endian) { id = avio_rl16(pb); if (id != 0x0165) { codec->channels = avio_rl16(pb); codec->sample_rate = avio_rl32(pb); bitrate = avio_rl32(pb) * 8LL; codec->block_align = avio_rl16(pb); } } else { id = avio_rb16(pb); codec->channels = avio_rb16(pb); codec->sample_rate = avio_rb32(pb); bitrate = avio_rb32(pb) * 8LL; codec->block_align = avio_rb16(pb); } if (size == 14) { codec->bits_per_coded_sample = 8; } else { if (!big_endian) { codec->bits_per_coded_sample = avio_rl16(pb); } else { codec->bits_per_coded_sample = avio_rb16(pb); } } if (id == 0xFFFE) { codec->codec_tag = 0; } else { codec->codec_tag = id; codec->codec_id = ff_wav_codec_get_id(id, codec->bits_per_coded_sample); } if (size >= 18 && id != 0x0165) { int cbSize = avio_rl16(pb); if (big_endian) { avpriv_report_missing_feature(codec, "WAVEFORMATEX support for RIFX files\n"); return AVERROR_PATCHWELCOME; } size -= 18; cbSize = FFMIN(size, cbSize); if (cbSize >= 22 && id == 0xfffe) { parse_waveformatex(pb, codec); cbSize -= 22; size -= 22; } if (cbSize > 0) { av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, cbSize) < 0) return AVERROR(ENOMEM); size -= cbSize; } if (size > 0) avio_skip(pb, size); } else if (id == 0x0165 && size >= 32) { int nb_streams, i; size -= 4; av_freep(&codec->extradata); if (ff_get_extradata(codec, pb, size) < 0) return AVERROR(ENOMEM); nb_streams = AV_RL16(codec->extradata + 4); codec->sample_rate = AV_RL32(codec->extradata + 12); codec->channels = 0; bitrate = 0; if (size < 8 + nb_streams * 20) return AVERROR_INVALIDDATA; for (i = 0; i < nb_streams; i++) codec->channels += codec->extradata[8 + i * 20 + 17]; } if (bitrate > INT_MAX) { if (s->error_recognition & AV_EF_EXPLODE) { av_log(s, AV_LOG_ERROR, "The bitrate %"PRIu64" is too large.\n", bitrate); return AVERROR_INVALIDDATA; } else { av_log(s, AV_LOG_WARNING, "The bitrate %"PRIu64" is too large, resetting to 0.", bitrate); codec->bit_rate = 0; } } else { codec->bit_rate = bitrate; } if (codec->sample_rate <= 0) { av_log(s, AV_LOG_ERROR, "Invalid sample rate: %d\n", codec->sample_rate); return AVERROR_INVALIDDATA; } if (codec->codec_id == AV_CODEC_ID_AAC_LATM) { codec->channels = 0; codec->sample_rate = 0; } if (codec->codec_id == AV_CODEC_ID_ADPCM_G726 && codec->sample_rate) codec->bits_per_coded_sample = codec->bit_rate / codec->sample_rate; return 0; }
--------------------------------------------- Result 2 ---------------------------------------------
[[0 (43%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int xen_9pfs_connect(struct XenDevice *xendev) { int i; Xen9pfsDev *xen_9pdev = container_of(xendev, Xen9pfsDev, xendev); V9fsState *s = &xen_9pdev->state; QemuOpts *fsdev; if (xenstore_read_fe_int(&xen_9pdev->xendev, "num-rings", &xen_9pdev->num_rings) == -1 || xen_9pdev->num_rings > MAX_RINGS || xen_9pdev->num_rings < 1) { return -1; } xen_9pdev->rings = g_malloc0(xen_9pdev->num_rings * sizeof(Xen9pfsRing)); for (i = 0; i < xen_9pdev->num_rings; i++) { char *str; int ring_order; xen_9pdev->rings[i].priv = xen_9pdev; xen_9pdev->rings[i].evtchn = -1; xen_9pdev->rings[i].local_port = -1; str = g_strdup_printf("ring-ref%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].ref) == -1) { goto out; } str = g_strdup_printf("event-channel-%u", i); if (xenstore_read_fe_int(&xen_9pdev->xendev, str, &xen_9pdev->rings[i].evtchn) == -1) { goto out; } xen_9pdev->rings[i].intf = xengnttab_map_grant_ref( xen_9pdev->xendev.gnttabdev, xen_9pdev->xendev.dom, xen_9pdev->rings[i].ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].intf) { goto out; } ring_order = xen_9pdev->rings[i].intf->ring_order; if (ring_order > MAX_RING_ORDER) { goto out; } xen_9pdev->rings[i].ring_order = ring_order; xen_9pdev->rings[i].data = xengnttab_map_domain_grant_refs( xen_9pdev->xendev.gnttabdev, (1 << ring_order), xen_9pdev->xendev.dom, xen_9pdev->rings[i].intf->ref, PROT_READ | PROT_WRITE); if (!xen_9pdev->rings[i].data) { goto out; } xen_9pdev->rings[i].ring.in = xen_9pdev->rings[i].data; xen_9pdev->rings[i].ring.out = xen_9pdev->rings[i].data + XEN_FLEX_RING_SIZE(ring_order); xen_9pdev->rings[i].bh = qemu_bh_new(xen_9pfs_bh, &xen_9pdev->rings[i]); xen_9pdev->rings[i].out_cons = 0; xen_9pdev->rings[i].out_size = 0; xen_9pdev->rings[i].inprogress = "False" != "False"; xen_9pdev->rings[i].evtchndev = xenevtchn_open(NULL, 0); if (xen_9pdev->rings[i].evtchndev == NULL) { goto out; } fcntl(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), F_SETFD, FD_CLOEXEC); xen_9pdev->rings[i].local_port = xenevtchn_bind_interdomain (xen_9pdev->rings[i].evtchndev, xendev->dom, xen_9pdev->rings[i].evtchn); if (xen_9pdev->rings[i].local_port == -1) { xen_pv_printf(xendev, 0, "xenevtchn_bind_interdomain failed port=%d\n", xen_9pdev->rings[i].evtchn); goto out; } xen_pv_printf(xendev, 2, "bind evtchn port %d\n", xendev->local_port); qemu_set_fd_handler(xenevtchn_fd(xen_9pdev->rings[i].evtchndev), xen_9pfs_evtchn_event, NULL, &xen_9pdev->rings[i]); } xen_9pdev->security_model = xenstore_read_be_str(xendev, "security_model"); xen_9pdev->path = xenstore_read_be_str(xendev, "path"); xen_9pdev->id = s->fsconf.fsdev_id = g_strdup_printf("xen9p%d", xendev->dev); xen_9pdev->tag = s->fsconf.tag = xenstore_read_fe_str(xendev, "tag"); v9fs_register_transport(s, &xen_9p_transport); fsdev = qemu_opts_create(qemu_find_opts("fsdev"), s->fsconf.tag, 1, NULL); qemu_opt_set(fsdev, "fsdriver", "local", NULL); qemu_opt_set(fsdev, "path", xen_9pdev->path, NULL); qemu_opt_set(fsdev, "security_model", xen_9pdev->security_model, NULL); qemu_opts_set_id(fsdev, s->fsconf.fsdev_id); qemu_fsdev_add(fsdev); v9fs_device_realize_common(s, NULL); return 0; out: xen_9pfs_free(xendev); return -1; }
--------------------------------------------- Result 3 ---------------------------------------------
[[0 (9%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int subframe_count_exact(FlacEncodeContext *s, FlacSubframe *sub, int pred_order) { int p, porder, psize; int i, part_end; int count = 0; count += 8; if (sub->type == FLAC_SUBFRAME_CONSTANT) { count += sub->obits; } else if (sub->type == FLAC_SUBFRAME_VERBATIM) { count += s->frame.blocksize * sub->obits; } else { count += pred_order * sub->obits; if (sub->type == FLAC_SUBFRAME_LPC) count += 4 + 5 + pred_order * s->options.lpc_coeff_precision; count += 2; porder = sub->rc.porder; psize = s->frame.blocksize >> porder; count += 4; i = pred_order; part_end = psize; for (p = 0; p < 1 << porder; p++) { int k = sub->rc.params[p]; count += 4; count += rice_count_exact(&sub->residual[i], part_end - i, k); i = part_end; part_end = FFMIN(s->frame.blocksize, part_end + psize); } } return count; }
--------------------------------------------- Result 4 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 0 / 0 / 4 / 4:   0%|          | 4/2690 [00:02<33:06,  1.35it/s]Using /tmp/tfhub_modules to cache modules.
[Succeeded / Failed / Skipped / Total] 0 / 0 / 4 / 4:   0%|          | 5/2690 [00:21<3:12:05,  4.29s/it][[0 (57%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void ppc_spapr_init(QEMUMachineInitArgs *args) { ram_addr_t ram_size = args->ram_size; const char *cpu_model = args->cpu_model; const char *kernel_filename = args->kernel_filename; const char *kernel_cmdline = args->kernel_cmdline; const char *initrd_filename = args->initrd_filename; const char *boot_device = args->boot_order; PowerPCCPU *cpu; CPUPPCState *env; PCIHostState *phb; int i; MemoryRegion *sysmem = get_system_memory(); MemoryRegion *ram = g_new(MemoryRegion, 1); hwaddr rma_alloc_size; uint32_t initrd_base = 0; long kernel_size = 0, initrd_size = 0; long load_limit, rtas_limit, fw_size; bool kernel_le = "False" != "False"; char *filename; msi_supported = "True" == "True"; spapr = g_malloc0(sizeof(*spapr)); QLIST_INIT(&spapr->phbs); cpu_ppc_hypercall = emulate_spapr_hypercall; rma_alloc_size = kvmppc_alloc_rma("ppc_spapr.rma", sysmem); if (rma_alloc_size == -1) { hw_error("qemu: Unable to create RMA\n"); exit(1); } if (rma_alloc_size && (rma_alloc_size < ram_size)) { spapr->rma_size = rma_alloc_size; } else { spapr->rma_size = ram_size; if (kvm_enabled()) { spapr->vrma_adjust = 1; spapr->rma_size = MIN(spapr->rma_size, 0x10000000); } } rtas_limit = MIN(spapr->rma_size, 0x80000000); spapr->rtas_addr = rtas_limit - RTAS_MAX_SIZE; spapr->fdt_addr = spapr->rtas_addr - FDT_MAX_SIZE; load_limit = spapr->fdt_addr - FW_OVERHEAD; spapr->htab_shift = 18; while (spapr->htab_shift <= 46) { if ((1ULL << (spapr->htab_shift + 7)) >= ram_size) { break; } spapr->htab_shift++; } spapr->icp = xics_system_init(smp_cpus * kvmppc_smt_threads() / smp_threads, XICS_IRQS); spapr->next_irq = XICS_IRQ_BASE; if (cpu_model == NULL) { cpu_model = kvm_enabled() ? "host" : "POWER7"; } for (i = 0; i < smp_cpus; i++) { cpu = cpu_ppc_init(cpu_model); if (cpu == NULL) { fprintf(stderr, "Unable to find PowerPC CPU definition\n"); exit(1); } env = &cpu->env; xics_cpu_setup(spapr->icp, cpu); cpu_ppc_tb_init(env, TIMEBASE_FREQ); env->msr_mask &= ~(1 << 6); if (kvm_enabled()) { kvmppc_set_papr(cpu); } qemu_register_reset(spapr_cpu_reset, cpu); } spapr->ram_limit = ram_size; if (spapr->ram_limit > rma_alloc_size) { ram_addr_t nonrma_base = rma_alloc_size; ram_addr_t nonrma_size = spapr->ram_limit - rma_alloc_size; memory_region_init_ram(ram, NULL, "ppc_spapr.ram", nonrma_size); vmstate_register_ram_global(ram); memory_region_add_subregion(sysmem, nonrma_base, ram); } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, "spapr-rtas.bin"); spapr->rtas_size = load_image_targphys(filename, spapr->rtas_addr, rtas_limit - spapr->rtas_addr); if (spapr->rtas_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } if (spapr->rtas_size > RTAS_MAX_SIZE) { hw_error("RTAS too big ! 0x%lx bytes (max is 0x%x)\n", spapr->rtas_size, RTAS_MAX_SIZE); exit(1); } g_free(filename); spapr_events_init(spapr); spapr->vio_bus = spapr_vio_bus_init(); for (i = 0; i < MAX_SERIAL_PORTS; i++) { if (serial_hds[i]) { spapr_vty_create(spapr->vio_bus, serial_hds[i]); } } spapr_create_nvram(spapr); spapr_pci_msi_init(spapr, SPAPR_PCI_MSI_WINDOW); spapr_pci_rtas_init(); phb = spapr_create_phb(spapr, 0); for (i = 0; i < nb_nics; i++) { NICInfo *nd = &nd_table[i]; if (!nd->model) { nd->model = g_strdup("ibmveth"); } if (strcmp(nd->model, "ibmveth") == 0) { spapr_vlan_create(spapr->vio_bus, nd); } else { pci_nic_init_nofail(&nd_table[i], phb->bus, nd->model, NULL); } } for (i = 0; i <= drive_get_max_bus(IF_SCSI); i++) { spapr_vscsi_create(spapr->vio_bus); } if (spapr_vga_init(phb->bus)) { spapr->has_graphics = "True" == "True"; } if (usb_enabled(spapr->has_graphics)) { pci_create_simple(phb->bus, -1, "pci-ohci"); if (spapr->has_graphics) { usbdevice_create("keyboard"); usbdevice_create("mouse"); } } if (spapr->rma_size < (MIN_RMA_SLOF << 20)) { fprintf(stderr, "qemu: pSeries SLOF firmware requires >= " "%ldM guest RMA (Real Mode Area memory)\n", MIN_RMA_SLOF); exit(1); } if (kernel_filename) { uint64_t lowaddr = 0; kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 1, ELF_MACHINE, 0); if (kernel_size < 0) { kernel_size = load_elf(kernel_filename, translate_kernel_address, NULL, NULL, &lowaddr, NULL, 0, ELF_MACHINE, 0); kernel_le = kernel_size > 0; } if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, KERNEL_LOAD_ADDR, load_limit - KERNEL_LOAD_ADDR); } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } if (initrd_filename) { initrd_base = (KERNEL_LOAD_ADDR + kernel_size + 0x1ffff) & ~0xffff; initrd_size = load_image_targphys(initrd_filename, initrd_base, load_limit - initrd_base); if (initrd_size < 0) { fprintf(stderr, "qemu: could not load initial ram disk '%s'\n", initrd_filename); exit(1); } } else { initrd_base = 0; initrd_size = 0; } } if (bios_name == NULL) { bios_name = FW_FILE_NAME; } filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name); fw_size = load_image_targphys(filename, 0, FW_MAX_SIZE); if (fw_size < 0) { hw_error("qemu: could not load LPAR rtas '%s'\n", filename); exit(1); } g_free(filename); spapr->entry_point = 0x100; vmstate_register(NULL, 0, &vmstate_spapr, spapr); register_savevm_live(NULL, "spapr/htab", -1, 1, &savevm_htab_handlers, spapr); spapr->fdt_skel = spapr_create_fdt_skel(cpu_model, initrd_base, initrd_size, kernel_size, kernel_le, boot_device, kernel_cmdline, spapr->epow_irq); assert(spapr->fdt_skel != NULL); }
--------------------------------------------- Result 5 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 1 / 0 / 4 / 5:   0%|          | 5/2690 [00:21<3:12:07,  4.29s/it][Succeeded / Failed / Skipped / Total] 1 / 0 / 4 / 5:   0%|          | 6/2690 [01:04<7:58:40, 10.70s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 4 / 6:   0%|          | 6/2690 [01:04<7:58:41, 10.70s/it][Succeeded / Failed / Skipped / Total] 1 / 1 / 4 / 6:   0%|          | 7/2690 [01:04<6:50:55,  9.19s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 4 / 7:   0%|          | 7/2690 [01:04<6:50:55,  9.19s/it][Succeeded / Failed / Skipped / Total] 2 / 1 / 4 / 7:   0%|          | 8/2690 [01:06<6:12:34,  8.34s/it][[0 (36%)]] --> [[0 (50%)]] --> Socre: 0.5029268860816956

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *[[avctx]], UINT8 *buf, int buf_size) { Mpeg1Context *s1 = [[avctx]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int [[width]], height, i, v, j; float aspect; init_get_bits(&s->gb, buf, buf_size); [[width]] = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); s->aspect_ratio_info= get_bits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1_aspect[s->aspect_ratio_info]; if(aspect!=0.0) [[avctx]]->aspect_ratio= [[width]]/(aspect*height); } s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if ([[width]] <= 0 || height <= 0 || ([[width]] % 2) != 0 || (height % 2) != 0) return -1; if ([[width]] != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = [[width]]; s->height = height; [[avctx]]->has_b_frames= 1; s->avctx = [[avctx]]; [[avctx]]->width = [[width]]; [[avctx]]->height = height; if (s->frame_rate_index >= 9) { [[avctx]]->frame_rate = 25 * FRAME_RATE_BASE; } else { [[avctx]]->frame_rate = frame_rate_tab[s->frame_rate_index]; } s->frame_rate = [[avctx]]->frame_rate; [[avctx]]->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->inter_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; [[avctx]]->sub_id = 1; return 0; }

[[[[Adv]]]]: static int mpeg1_decode_sequence(AVCodecContext *[[ravaged]], UINT8 *buf, int buf_size) { Mpeg1Context *s1 = [[ravaged]]->priv_data; MpegEncContext *s = &s1->mpeg_enc_ctx; int [[depth]], height, i, v, j; float aspect; init_get_bits(&s->gb, buf, buf_size); [[depth]] = get_bits(&s->gb, 12); height = get_bits(&s->gb, 12); s->aspect_ratio_info= get_bits(&s->gb, 4); if(!s->mpeg2){ aspect= mpeg1_aspect[s->aspect_ratio_info]; if(aspect!=0.0) [[ravaged]]->aspect_ratio= [[depth]]/(aspect*height); } s->frame_rate_index = get_bits(&s->gb, 4); if (s->frame_rate_index == 0) return -1; s->bit_rate = get_bits(&s->gb, 18) * 400; if (get_bits1(&s->gb) == 0) return -1; if ([[depth]] <= 0 || height <= 0 || ([[depth]] % 2) != 0 || (height % 2) != 0) return -1; if ([[depth]] != s->width || height != s->height) { s->out_format = FMT_MPEG1; if (s1->mpeg_enc_ctx_allocated) { MPV_common_end(s); } s->width = [[depth]]; s->height = height; [[ravaged]]->has_b_frames= 1; s->avctx = [[ravaged]]; [[ravaged]]->width = [[depth]]; [[ravaged]]->height = height; if (s->frame_rate_index >= 9) { [[ravaged]]->frame_rate = 25 * FRAME_RATE_BASE; } else { [[ravaged]]->frame_rate = frame_rate_tab[s->frame_rate_index]; } s->frame_rate = [[ravaged]]->frame_rate; [[ravaged]]->bit_rate = s->bit_rate; if (MPV_common_init(s) < 0) return -1; s1->mpeg_enc_ctx_allocated = 1; } skip_bits(&s->gb, 10); skip_bits(&s->gb, 1); if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } #ifdef DEBUG dprintf("intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->intra_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_intra_matrix[i]; s->intra_matrix[j] = v; s->chroma_intra_matrix[j] = v; } } if (get_bits1(&s->gb)) { for(i=0;i<64;i++) { v = get_bits(&s->gb, 8); j = s->intra_scantable.permutated[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } #ifdef DEBUG dprintf("non intra matrix present\n"); for(i=0;i<64;i++) dprintf(" %d", s->inter_matrix[s->intra_scantable.permutated[i]]); printf("\n"); #endif } else { for(i=0;i<64;i++) { int j= s->idct_permutation[i]; v = ff_mpeg1_default_non_intra_matrix[i]; s->inter_matrix[j] = v; s->chroma_inter_matrix[j] = v; } } s->progressive_sequence = 1; s->progressive_frame = 1; s->picture_structure = PICT_FRAME; s->frame_pred_frame_dct = 1; s->mpeg2 = 0; [[ravaged]]->sub_id = 1; return 0; }
--------------------------------------------- Result 6 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *drc) { drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if (drc->awaiting_release) { uint32_t drc_index = spapr_drc_index(drc); trace_spapr_drc_set_allocation_state_finalizing(drc_index); spapr_drc_detach(drc); } return RTAS_OUT_SUCCESS; }

[[[[Adv]]]]: static uint32_t drc_set_unusable(sPAPRDRConnector *drc) { drc->allocation_state = SPAPR_DR_ALLOCATION_STATE_UNUSABLE; if (drc->awaiting_release) { uint32_t drc_index = spapr_drc_index(drc); trace_spapr_drc_set_allocation_state_finalizing(drc_index); spapr_drc_detach(drc); } return RTAS_OUT_SUCCESS; }
--------------------------------------------- Result 7 ---------------------------------------------
[[0 (52%)]] --> [[0 (47%)]] --> Socre: 0.5280202329158783

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *[[r]]) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, [[r]]->req.dev); uint32_t n; if ([[r]]->sector_count == (uint32_t)-1) { DPRINTF("Read buf_len=%zd\n", [[r]]->iov.iov_len); [[r]]->sector_count = 0; scsi_req_data(&[[r]]->req, [[r]]->iov.iov_len); return; } DPRINTF("Read sector_count=%d\n", [[r]]->sector_count); if ([[r]]->sector_count == 0) { scsi_command_complete([[r]], GOOD, NO_SENSE); return; } assert([[r]]->req.aiocb == NULL); n = [[r]]->sector_count; if (n > SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; [[r]]->iov.iov_len = n * 512; qemu_iovec_init_external(&[[r]]->qiov, &[[r]]->iov, 1); [[r]]->req.aiocb = bdrv_aio_readv(s->bs, [[r]]->sector, &[[r]]->qiov, n, scsi_read_complete, [[r]]); if ([[r]]->req.aiocb == NULL) { scsi_read_complete([[r]], -EIO); } }

[[[[Adv]]]]: static void scsi_read_request(SCSIDiskReq *[[rl]]) { SCSIDiskState *s = DO_UPCAST(SCSIDiskState, qdev, [[rl]]->req.dev); uint32_t n; if ([[rl]]->sector_count == (uint32_t)-1) { DPRINTF("Read buf_len=%zd\n", [[rl]]->iov.iov_len); [[rl]]->sector_count = 0; scsi_req_data(&[[rl]]->req, [[rl]]->iov.iov_len); return; } DPRINTF("Read sector_count=%d\n", [[rl]]->sector_count); if ([[rl]]->sector_count == 0) { scsi_command_complete([[rl]], GOOD, NO_SENSE); return; } assert([[rl]]->req.aiocb == NULL); n = [[rl]]->sector_count; if (n > SCSI_DMA_BUF_SIZE / 512) n = SCSI_DMA_BUF_SIZE / 512; [[rl]]->iov.iov_len = n * 512; qemu_iovec_init_external(&[[rl]]->qiov, &[[rl]]->iov, 1); [[rl]]->req.aiocb = bdrv_aio_readv(s->bs, [[rl]]->sector, &[[rl]]->qiov, n, scsi_read_complete, [[rl]]); if ([[rl]]->req.aiocb == NULL) { scsi_read_complete([[rl]], -EIO); } }
--------------------------------------------- Result 8 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 3 / 1 / 4 / 8:   0%|          | 8/2690 [01:06<6:12:35,  8.34s/it][Succeeded / Failed / Skipped / Total] 3 / 1 / 4 / 8:   0%|          | 9/2690 [04:16<21:12:26, 28.48s/it][Succeeded / Failed / Skipped / Total] 3 / 2 / 4 / 9:   0%|          | 9/2690 [04:16<21:12:26, 28.48s/it][Succeeded / Failed / Skipped / Total] 3 / 2 / 4 / 9:   0%|          | 10/2690 [04:17<19:09:09, 25.73s/it][[0 (50%)]] --> [[0 (50%)]] --> Socre: 0.5005213618278503

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irq[32]; ResetInfo *reset_info; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr [[uart0_base]] = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) { fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); } env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } lm32_uart_create([[uart0_base]], irq[uart0_irq], serial_hds[0]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(serial_hds[1]); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }

[[[[Adv]]]]: static void lm32_evr_init(MachineState *machine) { const char *cpu_model = machine->cpu_model; const char *kernel_filename = machine->kernel_filename; LM32CPU *cpu; CPULM32State *env; DriveInfo *dinfo; MemoryRegion *address_space_mem = get_system_memory(); MemoryRegion *phys_ram = g_new(MemoryRegion, 1); qemu_irq irq[32]; ResetInfo *reset_info; int i; hwaddr flash_base = 0x04000000; size_t flash_sector_size = 256 * 1024; size_t flash_size = 32 * 1024 * 1024; hwaddr ram_base = 0x08000000; size_t ram_size = 64 * 1024 * 1024; hwaddr timer0_base = 0x80002000; hwaddr [[coq]] = 0x80006000; hwaddr timer1_base = 0x8000a000; int uart0_irq = 0; int timer0_irq = 1; int timer1_irq = 3; reset_info = g_malloc0(sizeof(ResetInfo)); if (cpu_model == NULL) { cpu_model = "lm32-full"; } cpu = LM32_CPU(cpu_generic_init(TYPE_LM32_CPU, cpu_model)); if (cpu == NULL) { fprintf(stderr, "qemu: unable to find CPU '%s'\n", cpu_model); exit(1); } env = &cpu->env; reset_info->cpu = cpu; reset_info->flash_base = flash_base; memory_region_allocate_system_memory(phys_ram, NULL, "lm32_evr.sdram", ram_size); memory_region_add_subregion(address_space_mem, ram_base, phys_ram); dinfo = drive_get(IF_PFLASH, 0, 0); pflash_cfi02_register(flash_base, NULL, "lm32_evr.flash", flash_size, dinfo ? blk_by_legacy_dinfo(dinfo) : NULL, flash_sector_size, flash_size / flash_sector_size, 1, 2, 0x01, 0x7e, 0x43, 0x00, 0x555, 0x2aa, 1); env->pic_state = lm32_pic_init(qemu_allocate_irq(cpu_irq_handler, cpu, 0)); for (i = 0; i < 32; i++) { irq[i] = qdev_get_gpio_in(env->pic_state, i); } lm32_uart_create([[coq]], irq[uart0_irq], serial_hds[0]); sysbus_create_simple("lm32-timer", timer0_base, irq[timer0_irq]); sysbus_create_simple("lm32-timer", timer1_base, irq[timer1_irq]); env->juart_state = lm32_juart_init(serial_hds[1]); reset_info->bootstrap_pc = flash_base; if (kernel_filename) { uint64_t entry; int kernel_size; kernel_size = load_elf(kernel_filename, NULL, NULL, &entry, NULL, NULL, 1, EM_LATTICEMICO32, 0, 0); reset_info->bootstrap_pc = entry; if (kernel_size < 0) { kernel_size = load_image_targphys(kernel_filename, ram_base, ram_size); reset_info->bootstrap_pc = ram_base; } if (kernel_size < 0) { fprintf(stderr, "qemu: could not load kernel '%s'\n", kernel_filename); exit(1); } } qemu_register_reset(main_cpu_reset, reset_info); }
--------------------------------------------- Result 9 ---------------------------------------------
[[0 (30%)]] --> [[[FAILED]]]

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *p; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)ctx->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&ctx->qiov, nr_iov); ctx->buf = p = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&ctx->qiov, p, len); p += len; optind++; } gettimeofday(&ctx->t1, NULL); acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); if (!acb) return -EIO; return 0; }

[[[[Adv]]]]: aio_write_f(int argc, char **argv) { char *p; int count = 0; int nr_iov, i, c; int pattern = 0xcd; struct aio_ctx *ctx = calloc(1, sizeof(struct aio_ctx)); BlockDriverAIOCB *acb; while ((c = getopt(argc, argv, "CqP:")) != EOF) { switch (c) { case 'C': ctx->Cflag = 1; break; case 'q': ctx->qflag = 1; break; case 'P': pattern = atoi(optarg); break; default: return command_usage(&aio_write_cmd); } } if (optind > argc - 2) return command_usage(&aio_write_cmd); ctx->offset = cvtnum(argv[optind]); if (ctx->offset < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } optind++; if (ctx->offset & 0x1ff) { printf("offset %lld is not sector aligned\n", (long long)ctx->offset); return 0; } if (count & 0x1ff) { printf("count %d is not sector aligned\n", count); return 0; } for (i = optind; i < argc; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[i]); return 0; } count += len; } nr_iov = argc - optind; qemu_iovec_init(&ctx->qiov, nr_iov); ctx->buf = p = qemu_io_alloc(count, pattern); for (i = 0; i < nr_iov; i++) { size_t len; len = cvtnum(argv[optind]); if (len < 0) { printf("non-numeric length argument -- %s\n", argv[optind]); return 0; } qemu_iovec_add(&ctx->qiov, p, len); p += len; optind++; } gettimeofday(&ctx->t1, NULL); acb = bdrv_aio_writev(bs, ctx->offset >> 9, &ctx->qiov, ctx->qiov.size >> 9, aio_write_done, ctx); if (!acb) return -EIO; return 0; }
--------------------------------------------- Result 10 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 4 / 2 / 4 / 10:   0%|          | 10/2690 [04:17<19:09:10, 25.73s/it][Succeeded / Failed / Skipped / Total] 4 / 2 / 5 / 11:   0%|          | 11/2690 [04:17<17:24:20, 23.39s/it][Succeeded / Failed / Skipped / Total] 4 / 2 / 6 / 12:   0%|          | 12/2690 [04:17<15:56:58, 21.44s/it][Succeeded / Failed / Skipped / Total] 4 / 2 / 6 / 12:   0%|          | 13/2690 [05:00<17:09:52, 23.08s/it][Succeeded / Failed / Skipped / Total] 4 / 3 / 6 / 13:   0%|          | 13/2690 [05:00<17:09:52, 23.08s/it][Succeeded / Failed / Skipped / Total] 4 / 3 / 6 / 13:   1%|          | 14/2690 [05:23<17:10:25, 23.10s/it][Succeeded / Failed / Skipped / Total] 4 / 4 / 6 / 14:   1%|          | 14/2690 [05:23<17:10:25, 23.10s/it][Succeeded / Failed / Skipped / Total] 4 / 4 / 6 / 14:   1%|          | 15/2690 [05:38<16:47:07, 22.59s/it][Succeeded / Failed / Skipped / Total] 5 / 4 / 6 / 15:   1%|          | 15/2690 [05:38<16:47:07, 22.59s/it][Succeeded / Failed / Skipped / Total] 5 / 4 / 6 / 15:   1%|          | 16/2690 [05:47<16:08:31, 21.73s/it][Succeeded / Failed / Skipped / Total] 6 / 4 / 6 / 16:   1%|          | 16/2690 [05:47<16:08:31, 21.73s/it][[0 (85%)]] --> [[0 (44%)]] --> Socre: 0.5601800680160522

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int [[linesize]], DCTELEM *[[block]]) { int i; int dc = [[block]][0]; const uint8_t *[[cm]]; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; [[cm]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = [[cm]][dest[0]]; dest[1] = [[cm]][dest[1]]; dest[2] = [[cm]][dest[2]]; dest[3] = [[cm]][dest[3]]; dest[4] = [[cm]][dest[4]]; dest[5] = [[cm]][dest[5]]; dest[6] = [[cm]][dest[6]]; dest[7] = [[cm]][dest[7]]; dest += [[linesize]]; } }

[[[[Adv]]]]: static void vc1_inv_trans_8x8_dc_c(uint8_t *dest, int [[melek]], DCTELEM *[[blocked]]) { int i; int dc = [[blocked]][0]; const uint8_t *[[kg]]; dc = (3 * dc + 1) >> 1; dc = (3 * dc + 16) >> 5; [[kg]] = ff_cropTbl + MAX_NEG_CROP + dc; for(i = 0; i < 8; i++){ dest[0] = [[kg]][dest[0]]; dest[1] = [[kg]][dest[1]]; dest[2] = [[kg]][dest[2]]; dest[3] = [[kg]][dest[3]]; dest[4] = [[kg]][dest[4]]; dest[5] = [[kg]][dest[5]]; dest[6] = [[kg]][dest[6]]; dest[7] = [[kg]][dest[7]]; dest += [[melek]]; } }
--------------------------------------------- Result 11 ---------------------------------------------
[[0 (42%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int vmdk_parse_extents(const char *desc, BlockDriverState *bs, const char *desc_file_path) { int ret; char access[11]; char type[11]; char fname[512]; const char *p = desc; int64_t sectors = 0; int64_t flat_offset; char extent_path[PATH_MAX]; BlockDriverState *extent_file; Error *local_err = NULL; while (*p) { flat_offset = -1; ret = sscanf(p, "%10s %" SCNd64 " %10s \"%511[^\n\r\"]\" %" SCNd64, access, &sectors, type, fname, &flat_offset); if (ret < 4 || strcmp(access, "RW")) { goto next_line; } else if (!strcmp(type, "FLAT")) { if (ret != 5 || flat_offset < 0) { return -EINVAL; } } else if (ret != 4) { return -EINVAL; } if (sectors <= 0 || (strcmp(type, "FLAT") && strcmp(type, "SPARSE") && strcmp(type, "VMFS") && strcmp(type, "VMFSSPARSE")) || (strcmp(access, "RW"))) { goto next_line; } path_combine(extent_path, sizeof(extent_path), desc_file_path, fname); ret = bdrv_file_open(&extent_file, extent_path, NULL, bs->open_flags, &local_err); if (ret) { qerror_report_err(local_err); error_free(local_err); return ret; } if (!strcmp(type, "FLAT") || !strcmp(type, "VMFS")) { VmdkExtent *extent; ret = vmdk_add_extent(bs, extent_file, "True" == "True", sectors, 0, 0, 0, 0, sectors, &extent); if (ret < 0) { return ret; } extent->flat_start_offset = flat_offset << 9; } else if (!strcmp(type, "SPARSE") || !strcmp(type, "VMFSSPARSE")) { ret = vmdk_open_sparse(bs, extent_file, bs->open_flags); if (ret) { bdrv_unref(extent_file); return ret; } } else { fprintf(stderr, "VMDK: Not supported extent type \"%s\""".\n", type); return -ENOTSUP; } next_line: while (*p && *p != '\n') { p++; } p++; } return 0; }
--------------------------------------------- Result 12 ---------------------------------------------
[[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void compute_rematrixing_strategy(AC3EncodeContext *s) { int nb_coefs; int blk, bnd, i; AC3Block *block, *block0; s->num_rematrixing_bands = 4; if (s->rematrixing & AC3_REMATRIXING_IS_STATIC) return; nb_coefs = FFMIN(s->nb_coefs[0], s->nb_coefs[1]); for (blk = 0; blk < AC3_MAX_BLOCKS; blk++) { block = &s->blocks[blk]; block->new_rematrixing_strategy = !blk; for (bnd = 0; bnd < s->num_rematrixing_bands; bnd++) { int start = ff_ac3_rematrix_band_tab[bnd]; int end = FFMIN(nb_coefs, ff_ac3_rematrix_band_tab[bnd+1]); CoefSumType sum[4] = {0,}; for (i = start; i < end; i++) { CoefType lt = block->mdct_coef[0][i]; CoefType rt = block->mdct_coef[1][i]; CoefType md = lt + rt; CoefType sd = lt - rt; sum[0] += lt * lt; sum[1] += rt * rt; sum[2] += md * md; sum[3] += sd * sd; } if (FFMIN(sum[2], sum[3]) < FFMIN(sum[0], sum[1])) block->rematrixing_flags[bnd] = 1; else block->rematrixing_flags[bnd] = 0; if (blk && block->rematrixing_flags[bnd] != block0->rematrixing_flags[bnd]) { block->new_rematrixing_strategy = 1; } } block0 = block; } }
--------------------------------------------- Result 13 ---------------------------------------------
[[0 (98%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t x0; uint32_t x1; x0 = T0 | ((uint64_t) (env->y) << 32); x1 = T1; x0 = x0 / x1; if (x0 > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = x0; T1 = 0; FORCE_RET();

[[[[Adv]]]]: void OPPROTO op_udiv_T1_T0(void) { uint64_t x0; uint32_t x1; x0 = T0 | ((uint64_t) (env->y) << 32); x1 = T1; x0 = x0 / x1; if (x0 > 0xffffffff) { T0 = 0xffffffff; T1 = 1; } else { T0 = x0; T1 = 0; FORCE_RET();
--------------------------------------------- Result 14 ---------------------------------------------
[[0 (2%)]] --> [[[FAILED]]]

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *env) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0(env); }

[[[[Adv]]]]: void cpu_x86_init_mmu(CPUX86State *env) { a20_enabled = 1; a20_mask = 0xffffffff; last_pg_state = -1; cpu_x86_update_cr0(env); }
--------------------------------------------- Result 15 ---------------------------------------------
[[0 (3%)]] --> [[0 (58%)]] --> Socre: 0.5787995457649231

[[[[Adv]]]]: int qemu_cpu_self(void *[[env]]) { return 1; }

[[[[Adv]]]]: int qemu_cpu_self(void *[[michael]]) { return 1; }
--------------------------------------------- Result 16 ---------------------------------------------
[[0 (32%)]] --> [[0 (53%)]] --> Socre: 0.5307098627090454

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[s]], bool [[link_down]]) { [[s]]->nc.link_down = [[link_down]]; if ([[s]]->nc.peer) { [[s]]->nc.peer->link_down = [[link_down]]; } if ([[s]]->nc.info->link_status_changed) { [[s]]->nc.info->link_status_changed(&[[s]]->nc); } if ([[s]]->nc.peer && [[s]]->nc.peer->info->link_status_changed) { [[s]]->nc.peer->info->link_status_changed([[s]]->nc.peer); } }

[[[[Adv]]]]: static void net_vhost_link_down(VhostUserState *[[among]], bool [[ransom]]) { [[among]]->nc.link_down = [[ransom]]; if ([[among]]->nc.peer) { [[among]]->nc.peer->link_down = [[ransom]]; } if ([[among]]->nc.info->link_status_changed) { [[among]]->nc.info->link_status_changed(&[[among]]->nc); } if ([[among]]->nc.peer && [[among]]->nc.peer->info->link_status_changed) { [[among]]->nc.peer->info->link_status_changed([[among]]->nc.peer); } }
--------------------------------------------- Result 17 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 4 / 7 / 17:   1%|          | 17/2690 [05:47<15:11:15, 20.45s/it][Succeeded / Failed / Skipped / Total] 6 / 4 / 8 / 18:   1%|          | 18/2690 [05:47<14:20:19, 19.32s/it][Succeeded / Failed / Skipped / Total] 6 / 4 / 8 / 18:   1%|          | 19/2690 [06:19<14:48:49, 19.97s/it][Succeeded / Failed / Skipped / Total] 6 / 5 / 8 / 19:   1%|          | 19/2690 [06:19<14:48:49, 19.97s/it][Succeeded / Failed / Skipped / Total] 6 / 5 / 8 / 19:   1%|          | 20/2690 [08:49<19:38:54, 26.49s/it][Succeeded / Failed / Skipped / Total] 6 / 6 / 8 / 20:   1%|          | 20/2690 [08:49<19:38:54, 26.49s/it][[0 (60%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int rv34_decode_mv(RV34DecContext *r, int block_type) { MpegEncContext *s = &r->s; GetBitContext *gb = &s->gb; int i, j, k, l; int mv_pos = s->mb_x * 2 + s->mb_y * 2 * s->b8_stride; int next_bt; memset(r->dmv, 0, sizeof(r->dmv)); for(i = 0; i < num_mvs[block_type]; i++){ r->dmv[i][0] = svq3_get_se_golomb(gb); r->dmv[i][1] = svq3_get_se_golomb(gb); } switch(block_type){ case RV34_MB_TYPE_INTRA: case RV34_MB_TYPE_INTRA16x16: ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); return 0; case RV34_MB_SKIP: if(s->pict_type == AV_PICTURE_TYPE_P){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; } case RV34_MB_B_DIRECT: if (HAVE_THREADS && (s->avctx->active_thread_type & FF_THREAD_FRAME)) ff_thread_await_progress(&s->next_picture_ptr->f, s->mb_y - 1, 0); next_bt = s->next_picture_ptr->f.mb_type[s->mb_x + s->mb_y * s->mb_stride]; if(IS_INTRA(next_bt) || IS_SKIP(next_bt)){ ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); ZERO8x2(s->current_picture_ptr->f.motion_val[1][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); }else for(j = 0; j < 2; j++) for(i = 0; i < 2; i++) for(k = 0; k < 2; k++) for(l = 0; l < 2; l++) s->current_picture_ptr->f.motion_val[l][mv_pos + i + j*s->b8_stride][k] = calc_add_mv(r, l, s->next_picture_ptr->f.motion_val[0][mv_pos + i + j*s->b8_stride][k]); if(!(IS_16X8(next_bt) || IS_8X16(next_bt) || IS_8X8(next_bt))) rv34_mc_2mv(r, block_type); else rv34_mc_2mv_skip(r); ZERO8x2(s->current_picture_ptr->f.motion_val[0][s->mb_x * 2 + s->mb_y * 2 * s->b8_stride], s->b8_stride); break; case RV34_MB_P_16x16: case RV34_MB_P_MIX16x16: rv34_pred_mv(r, block_type, 0, 0); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, 0); break; case RV34_MB_B_FORWARD: case RV34_MB_B_BACKWARD: r->dmv[1][0] = r->dmv[0][0]; r->dmv[1][1] = r->dmv[0][1]; if(r->rv30) rv34_pred_mv_rv3(r, block_type, block_type == RV34_MB_B_BACKWARD); else rv34_pred_mv_b (r, block_type, block_type == RV34_MB_B_BACKWARD); rv34_mc_1mv (r, block_type, 0, 0, 0, 2, 2, block_type == RV34_MB_B_BACKWARD); break; case RV34_MB_P_16x8: case RV34_MB_P_8x16: rv34_pred_mv(r, block_type, 0, 0); rv34_pred_mv(r, block_type, 1 + (block_type == RV34_MB_P_16x8), 1); if(block_type == RV34_MB_P_16x8){ rv34_mc_1mv(r, block_type, 0, 0, 0, 2, 1, 0); rv34_mc_1mv(r, block_type, 0, 8, s->b8_stride, 2, 1, 0); } if(block_type == RV34_MB_P_8x16){ rv34_mc_1mv(r, block_type, 0, 0, 0, 1, 2, 0); rv34_mc_1mv(r, block_type, 8, 0, 1, 1, 2, 0); } break; case RV34_MB_B_BIDIR: rv34_pred_mv_b (r, block_type, 0); rv34_pred_mv_b (r, block_type, 1); rv34_mc_2mv (r, block_type); break; case RV34_MB_P_8x8: for(i=0;i< 4;i++){ rv34_pred_mv(r, block_type, i, i); rv34_mc_1mv (r, block_type, (i&1)<<3, (i&2)<<2, (i&1)+(i>>1)*s->b8_stride, 1, 1, 0); } break; } return 0; }
--------------------------------------------- Result 18 ---------------------------------------------
[[0 (41%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void mirror_start_job(BlockDriverState *bs, BlockDriverState *target, const char *replaces, int64_t speed, uint32_t granularity, int64_t buf_size, BlockdevOnError on_source_error, BlockdevOnError on_target_error, bool unmap, BlockCompletionFunc *cb, void *opaque, Error **errp, const BlockJobDriver *driver, bool is_none_mode, BlockDriverState *base) { MirrorBlockJob *s; if (granularity == 0) { granularity = bdrv_get_default_bitmap_granularity(target); } assert ((granularity & (granularity - 1)) == 0); if ((on_source_error == BLOCKDEV_ON_ERROR_STOP || on_source_error == BLOCKDEV_ON_ERROR_ENOSPC) && (!bs->blk || !blk_iostatus_is_enabled(bs->blk))) { error_setg(errp, QERR_INVALID_PARAMETER, "on-source-error"); return; } if (buf_size < 0) { error_setg(errp, "Invalid parameter 'buf-size'"); return; } if (buf_size == 0) { buf_size = DEFAULT_MIRROR_BUF_SIZE; } if (replaces) { replaced_bs = bdrv_lookup_bs(replaces, replaces, errp); if (replaced_bs == NULL) { return; } } else { replaced_bs = bs; } if (replaced_bs->blk && target->blk) { error_setg(errp, "Can't create node with two BlockBackends"); return; } s = block_job_create(driver, bs, speed, cb, opaque, errp); if (!s) { return; } s->replaces = g_strdup(replaces); s->on_source_error = on_source_error; s->on_target_error = on_target_error; s->target = target; s->is_none_mode = is_none_mode; s->base = base; s->granularity = granularity; s->buf_size = ROUND_UP(buf_size, granularity); s->unmap = unmap; s->dirty_bitmap = bdrv_create_dirty_bitmap(bs, granularity, NULL, errp); if (!s->dirty_bitmap) { g_free(s->replaces); block_job_unref(&s->common); return; } bdrv_op_block_all(s->target, s->common.blocker); bdrv_set_enable_write_cache(s->target, "True" == "True"); if (s->target->blk) { blk_set_on_error(s->target->blk, on_target_error, on_target_error); blk_iostatus_enable(s->target->blk); } s->common.co = qemu_coroutine_create(mirror_run); trace_mirror_start(bs, s, s->common.co, opaque); qemu_coroutine_enter(s->common.co, s); }
--------------------------------------------- Result 19 ---------------------------------------------
[[0 (1%)]] --> [[[FAILED]]]

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }

[[[[Adv]]]]: START_TEST(qint_get_int_test) { QInt *qi; const int value = 123456; qi = qint_from_int(value); fail_unless(qint_get_int(qi) == value); QDECREF(qi); }
--------------------------------------------- Result 20 ---------------------------------------------
[[0 (99%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc) { uint8_t symbols[256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits(gb, 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits(gb, 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { symbols[count] = get_bits(gb, 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1, codes, 2, 2, symbols, 1, 1, 0);

[[[[Adv]]]]: static int read_code_table(CLLCContext *ctx, GetBitContext *gb, VLC *vlc) { uint8_t symbols[256]; uint8_t bits[256]; uint16_t codes[256]; int num_lens, num_codes, num_codes_sum, prefix; int i, j, count; prefix = 0; count = 0; num_codes_sum = 0; num_lens = get_bits(gb, 5); for (i = 0; i < num_lens; i++) { num_codes = get_bits(gb, 9); num_codes_sum += num_codes; if (num_codes_sum > 256) { av_log(ctx->avctx, AV_LOG_ERROR, "Too many VLCs (%d) to be read.\n", num_codes_sum); for (j = 0; j < num_codes; j++) { symbols[count] = get_bits(gb, 8); bits[count] = i + 1; codes[count] = prefix++; count++; if (prefix > (65535 - 256)/2) { prefix <<= 1; return ff_init_vlc_sparse(vlc, VLC_BITS, count, bits, 1, 1, codes, 2, 2, symbols, 1, 1, 0);
--------------------------------------------- Result 21 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 6 / 6 / 9 / 21:   1%|          | 21/2690 [08:49<18:42:21, 25.23s/it][Succeeded / Failed / Skipped / Total] 6 / 6 / 10 / 22:   1%|          | 22/2690 [08:49<17:50:56, 24.08s/it][Succeeded / Failed / Skipped / Total] 6 / 6 / 10 / 22:   1%|          | 23/2690 [08:50<17:04:22, 23.05s/it][Succeeded / Failed / Skipped / Total] 7 / 6 / 10 / 23:   1%|          | 23/2690 [08:50<17:04:22, 23.05s/it][Succeeded / Failed / Skipped / Total] 8 / 6 / 10 / 24:   1%|          | 24/2690 [08:50<16:21:27, 22.09s/it][Succeeded / Failed / Skipped / Total] 8 / 7 / 10 / 25:   1%|          | 25/2690 [10:08<18:00:39, 24.33s/it][Succeeded / Failed / Skipped / Total] 8 / 7 / 10 / 25:   1%|          | 26/2690 [10:08<17:18:44, 23.39s/it][[0 (35%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static int cbs_h265_read_nal_unit(CodedBitstreamContext *ctx, CodedBitstreamUnit *unit) { BitstreamContext bc; int err; err = bitstream_init(&bc, unit->data, 8 * unit->data_size); if (err < 0) return err; switch (unit->type) { case HEVC_NAL_VPS: { H265RawVPS *vps; vps = av_mallocz(sizeof(*vps)); if (!vps) return AVERROR(ENOMEM); err = cbs_h265_read_vps(ctx, &bc, vps); if (err >= 0) err = cbs_h265_replace_vps(ctx, vps); if (err < 0) { av_free(vps); return err; } unit->content = vps; } break; case HEVC_NAL_SPS: { H265RawSPS *sps; sps = av_mallocz(sizeof(*sps)); if (!sps) return AVERROR(ENOMEM); err = cbs_h265_read_sps(ctx, &bc, sps); if (err >= 0) err = cbs_h265_replace_sps(ctx, sps); if (err < 0) { av_free(sps); return err; } unit->content = sps; } break; case HEVC_NAL_PPS: { H265RawPPS *pps; pps = av_mallocz(sizeof(*pps)); if (!pps) return AVERROR(ENOMEM); err = cbs_h265_read_pps(ctx, &bc, pps); if (err >= 0) err = cbs_h265_replace_pps(ctx, pps); if (err < 0) { av_free(pps); return err; } unit->content = pps; } break; case HEVC_NAL_TRAIL_N: case HEVC_NAL_TRAIL_R: case HEVC_NAL_TSA_N: case HEVC_NAL_TSA_R: case HEVC_NAL_STSA_N: case HEVC_NAL_STSA_R: case HEVC_NAL_RADL_N: case HEVC_NAL_RADL_R: case HEVC_NAL_RASL_N: case HEVC_NAL_RASL_R: case HEVC_NAL_BLA_W_LP: case HEVC_NAL_BLA_W_RADL: case HEVC_NAL_BLA_N_LP: case HEVC_NAL_IDR_W_RADL: case HEVC_NAL_IDR_N_LP: case HEVC_NAL_CRA_NUT: { H265RawSlice *slice; int pos, len; slice = av_mallocz(sizeof(*slice)); if (!slice) return AVERROR(ENOMEM); err = cbs_h265_read_slice_segment_header(ctx, &bc, &slice->header); if (err < 0) { av_free(slice); return err; } pos = bitstream_tell(&bc); len = unit->data_size; if (!unit->data[len - 1]) { int z; for (z = 0; z < len && !unit->data[len - z - 1]; z++); av_log(ctx->log_ctx, AV_LOG_DEBUG, "Deleted %d trailing zeroes " "from slice data.\n", z); len -= z; } slice->data_size = len - pos / 8; slice->data = av_malloc(slice->data_size); if (!slice->data) { av_free(slice); return AVERROR(ENOMEM); } memcpy(slice->data, unit->data + pos / 8, slice->data_size); slice->data_bit_start = pos % 8; unit->content = slice; } break; case HEVC_NAL_AUD: { H265RawAUD *aud; aud = av_mallocz(sizeof(*aud)); if (!aud) return AVERROR(ENOMEM); err = cbs_h265_read_aud(ctx, &bc, aud); if (err < 0) { av_free(aud); return err; } unit->content = aud; } break; default: return AVERROR(ENOSYS); } return 0; }
--------------------------------------------- Result 22 ---------------------------------------------
[[0 (1%)]] --> [[[SKIPPED]]]

[[[[Adv]]]]: static void qpa_audio_fini (void *opaque) { (void) opaque; }
--------------------------------------------- Result 23 ---------------------------------------------
[[0 (53%)]] --> [[0 (49%)]] --> Socre: 0.5116761922836304

[[[[Adv]]]]: static void usbredir_bulk_packet(void *[[priv]], uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *data, int data_len) { USBRedirDevice *[[dev]] = [[priv]]; uint8_t ep = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, ep, len, id); aurb = async_find([[dev]], id); if (!aurb) { free(data); return; } if (aurb->bulk_packet.endpoint != bulk_packet->endpoint || aurb->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if (aurb->packet) { len = usbredir_handle_status([[dev]], bulk_packet->status, len); if (len > 0) { usbredir_log_data([[dev]], "bulk data in:", data, data_len); if (data_len <= aurb->packet->len) { memcpy(aurb->packet->data, data, data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, aurb->packet->len); len = USB_RET_STALL; } } aurb->packet->len = len; usb_packet_complete(&[[dev]]->dev, aurb->packet); } async_free([[dev]], aurb); free(data); }

[[[[Adv]]]]: static void usbredir_bulk_packet(void *[[inlay]], uint32_t id, struct usb_redir_bulk_packet_header *bulk_packet, uint8_t *data, int data_len) { USBRedirDevice *[[guru]] = [[inlay]]; uint8_t ep = bulk_packet->endpoint; int len = bulk_packet->length; AsyncURB *aurb; DPRINTF("bulk-in status %d ep %02X len %d id %u\n", bulk_packet->status, ep, len, id); aurb = async_find([[guru]], id); if (!aurb) { free(data); return; } if (aurb->bulk_packet.endpoint != bulk_packet->endpoint || aurb->bulk_packet.stream_id != bulk_packet->stream_id) { ERROR("return bulk packet mismatch, please report this!\n"); len = USB_RET_NAK; } if (aurb->packet) { len = usbredir_handle_status([[guru]], bulk_packet->status, len); if (len > 0) { usbredir_log_data([[guru]], "bulk data in:", data, data_len); if (data_len <= aurb->packet->len) { memcpy(aurb->packet->data, data, data_len); } else { ERROR("bulk buffer too small (%d > %d)\n", data_len, aurb->packet->len); len = USB_RET_STALL; } } aurb->packet->len = len; usb_packet_complete(&[[guru]]->dev, aurb->packet); } async_free([[guru]], aurb); free(data); }
--------------------------------------------- Result 24 ---------------------------------------------
[[0 (51%)]] --> [[0 (49%)]] --> Socre: 0.5075133442878723

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *avctx) { HEVCContext *[[s]] = avctx->priv_data; int i; [[s]]->avctx = avctx; [[s]]->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[s]]->HEVClc) goto fail; [[s]]->HEVClcList[0] = [[s]]->HEVClc; [[s]]->sList[0] = [[s]]; [[s]]->cabac_state = av_malloc(HEVC_CONTEXTS); if (![[s]]->cabac_state) goto fail; [[s]]->output_frame = av_frame_alloc(); if (![[s]]->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS([[s]]->DPB); i++) { [[s]]->DPB[i].frame = av_frame_alloc(); if (![[s]]->DPB[i].frame) goto fail; [[s]]->DPB[i].tf.f = [[s]]->DPB[i].frame; } [[s]]->max_ra = INT_MAX; [[s]]->md5_ctx = av_md5_alloc(); if (![[s]]->md5_ctx) goto fail; ff_bswapdsp_init(&[[s]]->bdsp); [[s]]->context_initialized = 1; [[s]]->eos = 0; return 0; fail: hevc_decode_free(avctx); return AVERROR(ENOMEM); }

[[[[Adv]]]]: static av_cold int hevc_init_context(AVCodecContext *avctx) { HEVCContext *[[sec]] = avctx->priv_data; int i; [[sec]]->avctx = avctx; [[sec]]->HEVClc = av_mallocz(sizeof(HEVCLocalContext)); if (![[sec]]->HEVClc) goto fail; [[sec]]->HEVClcList[0] = [[sec]]->HEVClc; [[sec]]->sList[0] = [[sec]]; [[sec]]->cabac_state = av_malloc(HEVC_CONTEXTS); if (![[sec]]->cabac_state) goto fail; [[sec]]->output_frame = av_frame_alloc(); if (![[sec]]->output_frame) goto fail; for (i = 0; i < FF_ARRAY_ELEMS([[sec]]->DPB); i++) { [[sec]]->DPB[i].frame = av_frame_alloc(); if (![[sec]]->DPB[i].frame) goto fail; [[sec]]->DPB[i].tf.f = [[sec]]->DPB[i].frame; } [[sec]]->max_ra = INT_MAX; [[sec]]->md5_ctx = av_md5_alloc(); if (![[sec]]->md5_ctx) goto fail; ff_bswapdsp_init(&[[sec]]->bdsp); [[sec]]->context_initialized = 1; [[sec]]->eos = 0; return 0; fail: hevc_decode_free(avctx); return AVERROR(ENOMEM); }
--------------------------------------------- Result 25 ---------------------------------------------
[[0 (78%)]] --> [[[FAILED]]]

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }

[[[[Adv]]]]: static int decode_plte_chunk(AVCodecContext *avctx, PNGDecContext *s, uint32_t length) { int n, i, r, g, b; if ((length % 3) != 0 || length > 256 * 3) return AVERROR_INVALIDDATA; n = length / 3; for (i = 0; i < n; i++) { r = bytestream2_get_byte(&s->gb); g = bytestream2_get_byte(&s->gb); b = bytestream2_get_byte(&s->gb); s->palette[i] = (0xFFU << 24) | (r << 16) | (g << 8) | b; } for (; i < 256; i++) s->palette[i] = (0xFFU << 24); s->state |= PNG_PLTE; bytestream2_skip(&s->gb, 4); return 0; }
--------------------------------------------- Result 26 ---------------------------------------------
[Succeeded / Failed / Skipped / Total] 8 / 7 / 11 / 26:   1%|          | 26/2690 [10:08<17:18:44, 23.39s/it]